
TFM_Appli_Secure.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .TFM_VECTORS  00000418  0c038400  0c038400  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .copy.table   00000060  0c038818  0c038818  00000818  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .TFM_DATA     0000032c  30030800  0c0620ac  0002a800  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  3 .TFM_UNPRIV_DATA 00000000  3003f200  3003f200  0002ace0  2**5
                  CONTENTS
  4 .ER_TFM_SP_PS_DATA 00000000  3003f200  3003f200  0002ace0  2**5
                  CONTENTS
  5 .ER_TFM_SP_ITS_DATA 00000000  3003e960  3003e960  0002ace0  2**5
                  CONTENTS
  6 .ER_TFM_SP_CRYPTO_DATA 00000000  3003e980  3003e980  0002ace0  2**5
                  CONTENTS
  7 .ER_TFM_SP_PLATFORM_DATA 00000000  3003e9a0  3003e9a0  0002ace0  2**5
                  CONTENTS
  8 .ER_TFM_SP_INITIAL_ATTESTATION_DATA 00000000  3003e9c0  3003e9c0  0002ace0  2**5
                  CONTENTS
  9 .ER_TFM_APP_ROT_DATA 00000000  30040c40  30040c40  0002ace0  2**5
                  CONTENTS
 10 .zero.table   00000040  0c038878  0c038878  00000878  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 11 .TFM_BSS      0000de30  30030b30  30030b30  0002b400  2**3
                  ALLOC
 12 .TFM_UNPRIV_BSS 00000000  3003f200  3003f200  0002ace0  2**5
                  CONTENTS
 13 .TFM_SP_PS_BSS 00001a40  3003f200  3003f200  0002b400  2**5
                  ALLOC
 14 .TFM_SP_ITS_BSS 00000020  3003e960  3003e960  0002b400  2**5
                  ALLOC
 15 .TFM_SP_CRYPTO_BSS 00000020  3003e980  3003e980  0002b400  2**5
                  ALLOC
 16 .TFM_SP_PLATFORM_BSS 00000020  3003e9a0  3003e9a0  0002b400  2**5
                  ALLOC
 17 .TFM_SP_INITIAL_ATTESTATION_BSS 00000020  3003e9c0  3003e9c0  0002b400  2**5
                  ALLOC
 18 .TFM_APP_ROT_BSS 00000420  30040c40  30040c40  0002b400  2**5
                  ALLOC
 19 .TFM_SP_ITS_RO 00001100  0c0388c0  0c0388c0  000008c0  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 20 .TFM_SP_CRYPTO_RO 00001a40  0c0399c0  0c0399c0  000019c0  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 21 .TFM_SP_PLATFORM_RO 00000300  0c03b400  0c03b400  00003400  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 22 .TFM_SP_INITIAL_ATTESTATION_RO 00000000  0c03b700  0c03b700  0002ace0  2**5
                  CONTENTS
 23 .ER_UNPRIV_CODE 00007d60  0c03c000  0c03c000  00004000  2**13
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 24 .TFM_SP_PS_RO 000077a0  0c043d60  0c043d60  0000bd60  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 25 .TFM_APP_ROT_RO 000004c0  0c04b500  0c04b500  00013500  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 26 .ER_TFM_CODE  000166e4  0c04b9c0  0c04b9c0  000139c0  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 27 .ARM.exidx    00000008  0c0620a4  0c0620a4  0002a0a4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
 28 .tfm_secure_data_start 00000000  30030400  30030400  0002ace0  2**0
                  CONTENTS
 29 .msp_stack    00000400  30030400  30030400  0002b400  2**5
                  ALLOC
 30 .psp_stack    00000800  3003ea00  3003ea00  0002b400  2**9
                  ALLOC
 31 .heap         00001000  30041060  30041060  0002b400  2**3
                  ALLOC
 32 .gnu.sgstubs  00000060  0c065c80  0c065c80  0002ac80  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 33 .ARM.attributes 00000030  00000000  00000000  0002ace0  2**0
                  CONTENTS, READONLY
 34 .comment      00000043  00000000  00000000  0002ad10  2**0
                  CONTENTS, READONLY
 35 .debug_info   000c4c1c  00000000  00000000  0002ad53  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 36 .debug_abbrev 0001e6e2  00000000  00000000  000ef96f  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 37 .debug_loclists 000504e5  00000000  00000000  0010e051  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 38 .debug_aranges 000054e0  00000000  00000000  0015e536  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 39 .debug_rnglists 000063ba  00000000  00000000  00163a16  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 40 .debug_macro  0005f1ec  00000000  00000000  00169dd0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 41 .debug_line   000c1950  00000000  00000000  001c8fbc  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 42 .debug_str    0018f460  00000000  00000000  0028a90c  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 43 .debug_frame  00010a50  00000000  00000000  00419d6c  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .TFM_VECTORS:

0c038400 <__Vectors>:
 c038400:	00 08 03 30 35 87 03 0c 01 e9 04 0c 69 29 05 0c     ...05.......i)..
 c038410:	69 29 05 0c 69 29 05 0c 71 d4 05 0c 5f d4 05 0c     i)..i)..q..._...
	...
 c03842c:	61 d4 05 0c 39 86 03 0c 00 00 00 00 2d d4 05 0c     a...9.......-...
 c03843c:	3b 86 03 0c 3d 86 03 0c 3f 86 03 0c 41 86 03 0c     ;...=...?...A...
 c03844c:	43 86 03 0c 69 29 05 0c 45 86 03 0c 47 86 03 0c     C...i)..E...G...
 c03845c:	49 86 03 0c 4f cf 05 0c 4b 86 03 0c 4d 86 03 0c     I...O...K...M...
 c03846c:	4f 86 03 0c 51 86 03 0c 53 86 03 0c 55 86 03 0c     O...Q...S...U...
 c03847c:	57 86 03 0c 59 86 03 0c 5b 86 03 0c 5d 86 03 0c     W...Y...[...]...
 c03848c:	5f 86 03 0c 61 86 03 0c 63 86 03 0c 65 86 03 0c     _...a...c...e...
 c03849c:	67 86 03 0c 69 86 03 0c 6b 86 03 0c 6d 86 03 0c     g...i...k...m...
 c0384ac:	6f 86 03 0c 71 86 03 0c 73 86 03 0c 75 86 03 0c     o...q...s...u...
 c0384bc:	77 86 03 0c 79 86 03 0c 7b 86 03 0c 7d 86 03 0c     w...y...{...}...
 c0384cc:	7f 86 03 0c 81 86 03 0c 83 86 03 0c 85 86 03 0c     ................
 c0384dc:	87 86 03 0c 89 86 03 0c 8b 86 03 0c 8d 86 03 0c     ................
 c0384ec:	8f 86 03 0c 91 86 03 0c 93 86 03 0c 95 86 03 0c     ................
 c0384fc:	97 86 03 0c 99 86 03 0c 9b 86 03 0c 9d 86 03 0c     ................
 c03850c:	9f 86 03 0c a1 86 03 0c a3 86 03 0c a5 86 03 0c     ................
 c03851c:	a7 86 03 0c a9 86 03 0c ab 86 03 0c ad 86 03 0c     ................
 c03852c:	af 86 03 0c b1 86 03 0c b3 86 03 0c b5 86 03 0c     ................
 c03853c:	b7 86 03 0c b9 86 03 0c bb 86 03 0c bd 86 03 0c     ................
 c03854c:	bf 86 03 0c c1 86 03 0c c3 86 03 0c c5 86 03 0c     ................
 c03855c:	c7 86 03 0c c9 86 03 0c cb 86 03 0c cd 86 03 0c     ................
 c03856c:	cf 86 03 0c d1 86 03 0c d3 86 03 0c d5 86 03 0c     ................
 c03857c:	d7 86 03 0c d9 86 03 0c db 86 03 0c dd 86 03 0c     ................
 c03858c:	df 86 03 0c e1 86 03 0c e3 86 03 0c e5 86 03 0c     ................
 c03859c:	e7 86 03 0c e9 86 03 0c eb 86 03 0c ed 86 03 0c     ................
 c0385ac:	ef 86 03 0c f1 86 03 0c f3 86 03 0c f5 86 03 0c     ................
 c0385bc:	f7 86 03 0c f9 86 03 0c fb 86 03 0c fd 86 03 0c     ................
 c0385cc:	ff 86 03 0c 01 87 03 0c 03 87 03 0c 05 87 03 0c     ................
 c0385dc:	07 87 03 0c 09 87 03 0c 0b 87 03 0c 0d 87 03 0c     ................
 c0385ec:	0f 87 03 0c 11 87 03 0c 13 87 03 0c 15 87 03 0c     ................
 c0385fc:	17 87 03 0c 19 87 03 0c 1b 87 03 0c 1d 87 03 0c     ................
 c03860c:	1f 87 03 0c 21 87 03 0c 23 87 03 0c 25 87 03 0c     ....!...#...%...
 c03861c:	27 87 03 0c 29 87 03 0c 2b 87 03 0c 2d 87 03 0c     '...)...+...-...
 c03862c:	2f 87 03 0c 31 87 03 0c 33 87 03 0c                 /...1...3...

0c038638 <DebugMon_Handler>:
DEFAULT_IRQ_HANDLER(MemManage_Handler)
DEFAULT_IRQ_HANDLER(BusFault_Handler)
DEFAULT_IRQ_HANDLER(UsageFault_Handler)
DEFAULT_IRQ_HANDLER(SecureFault_Handler)
DEFAULT_IRQ_HANDLER(SVC_Handler)
DEFAULT_IRQ_HANDLER(DebugMon_Handler)
 c038638:	e7fe      	b.n	c038638 <DebugMon_Handler>

0c03863a <SysTick_Handler>:
DEFAULT_IRQ_HANDLER(PendSV_Handler)
DEFAULT_IRQ_HANDLER(SysTick_Handler)
 c03863a:	e7fe      	b.n	c03863a <SysTick_Handler>

0c03863c <WWDG_IRQHandler>:

DEFAULT_IRQ_HANDLER(WWDG_IRQHandler)
 c03863c:	e7fe      	b.n	c03863c <WWDG_IRQHandler>

0c03863e <PVD_PVM_IRQHandler>:
DEFAULT_IRQ_HANDLER(PVD_PVM_IRQHandler)
 c03863e:	e7fe      	b.n	c03863e <PVD_PVM_IRQHandler>

0c038640 <RTC_IRQHandler>:
DEFAULT_IRQ_HANDLER(RTC_IRQHandler)
 c038640:	e7fe      	b.n	c038640 <RTC_IRQHandler>

0c038642 <RTC_IRQHandler_S>:
DEFAULT_IRQ_HANDLER(RTC_IRQHandler_S)
 c038642:	e7fe      	b.n	c038642 <RTC_IRQHandler_S>

0c038644 <RAMCFG_IRQHandler>:
DEFAULT_IRQ_HANDLER(TAMP_IRQHandler)
DEFAULT_IRQ_HANDLER(RAMCFG_IRQHandler)
 c038644:	e7fe      	b.n	c038644 <RAMCFG_IRQHandler>

0c038646 <FLASH_IRQHandler>:
DEFAULT_IRQ_HANDLER(FLASH_IRQHandler)
 c038646:	e7fe      	b.n	c038646 <FLASH_IRQHandler>

0c038648 <FLASH_IRQHandler_S>:
DEFAULT_IRQ_HANDLER(FLASH_IRQHandler_S)
 c038648:	e7fe      	b.n	c038648 <FLASH_IRQHandler_S>

0c03864a <RCC_IRQHandler>:
DEFAULT_IRQ_HANDLER(GTZC_IRQHandler)
DEFAULT_IRQ_HANDLER(RCC_IRQHandler)
 c03864a:	e7fe      	b.n	c03864a <RCC_IRQHandler>

0c03864c <RCC_IRQHandler_S>:
DEFAULT_IRQ_HANDLER(RCC_IRQHandler_S)
 c03864c:	e7fe      	b.n	c03864c <RCC_IRQHandler_S>

0c03864e <EXTI0_IRQHandler>:
DEFAULT_IRQ_HANDLER(EXTI0_IRQHandler)
 c03864e:	e7fe      	b.n	c03864e <EXTI0_IRQHandler>

0c038650 <EXTI1_IRQHandler>:
DEFAULT_IRQ_HANDLER(EXTI1_IRQHandler)
 c038650:	e7fe      	b.n	c038650 <EXTI1_IRQHandler>

0c038652 <EXTI2_IRQHandler>:
DEFAULT_IRQ_HANDLER(EXTI2_IRQHandler)
 c038652:	e7fe      	b.n	c038652 <EXTI2_IRQHandler>

0c038654 <EXTI3_IRQHandler>:
DEFAULT_IRQ_HANDLER(EXTI3_IRQHandler)
 c038654:	e7fe      	b.n	c038654 <EXTI3_IRQHandler>

0c038656 <EXTI4_IRQHandler>:
DEFAULT_IRQ_HANDLER(EXTI4_IRQHandler)
 c038656:	e7fe      	b.n	c038656 <EXTI4_IRQHandler>

0c038658 <EXTI5_IRQHandler>:
DEFAULT_IRQ_HANDLER(EXTI5_IRQHandler)
 c038658:	e7fe      	b.n	c038658 <EXTI5_IRQHandler>

0c03865a <EXTI6_IRQHandler>:
DEFAULT_IRQ_HANDLER(EXTI6_IRQHandler)
 c03865a:	e7fe      	b.n	c03865a <EXTI6_IRQHandler>

0c03865c <EXTI7_IRQHandler>:
DEFAULT_IRQ_HANDLER(EXTI7_IRQHandler)
 c03865c:	e7fe      	b.n	c03865c <EXTI7_IRQHandler>

0c03865e <EXTI8_IRQHandler>:
DEFAULT_IRQ_HANDLER(EXTI8_IRQHandler)
 c03865e:	e7fe      	b.n	c03865e <EXTI8_IRQHandler>

0c038660 <EXTI9_IRQHandler>:
DEFAULT_IRQ_HANDLER(EXTI9_IRQHandler)
 c038660:	e7fe      	b.n	c038660 <EXTI9_IRQHandler>

0c038662 <EXTI10_IRQHandler>:
DEFAULT_IRQ_HANDLER(EXTI10_IRQHandler)
 c038662:	e7fe      	b.n	c038662 <EXTI10_IRQHandler>

0c038664 <EXTI11_IRQHandler>:
DEFAULT_IRQ_HANDLER(EXTI11_IRQHandler)
 c038664:	e7fe      	b.n	c038664 <EXTI11_IRQHandler>

0c038666 <EXTI12_IRQHandler>:
DEFAULT_IRQ_HANDLER(EXTI12_IRQHandler)
 c038666:	e7fe      	b.n	c038666 <EXTI12_IRQHandler>

0c038668 <EXTI13_IRQHandler>:
DEFAULT_IRQ_HANDLER(EXTI13_IRQHandler)
 c038668:	e7fe      	b.n	c038668 <EXTI13_IRQHandler>

0c03866a <EXTI14_IRQHandler>:
DEFAULT_IRQ_HANDLER(EXTI14_IRQHandler)
 c03866a:	e7fe      	b.n	c03866a <EXTI14_IRQHandler>

0c03866c <EXTI15_IRQHandler>:
DEFAULT_IRQ_HANDLER(EXTI15_IRQHandler)
 c03866c:	e7fe      	b.n	c03866c <EXTI15_IRQHandler>

0c03866e <IWDG_IRQHandler>:
DEFAULT_IRQ_HANDLER(IWDG_IRQHandler)
 c03866e:	e7fe      	b.n	c03866e <IWDG_IRQHandler>

0c038670 <SAES_IRQHandler>:
#if defined(STM32U585xx) || defined(STM32U5A5xx) || defined(STM32U5A9xx) || defined(STM32U545xx)
DEFAULT_IRQ_HANDLER(SAES_IRQHandler)
 c038670:	e7fe      	b.n	c038670 <SAES_IRQHandler>

0c038672 <GPDMA1_Channel0_IRQHandler>:
#endif /* defined(STM32U585xx) || defined(STM32U5A5xx) || defined(STM32U5A9xx) || defined(STM32U545xx) */
DEFAULT_IRQ_HANDLER(GPDMA1_Channel0_IRQHandler)
 c038672:	e7fe      	b.n	c038672 <GPDMA1_Channel0_IRQHandler>

0c038674 <GPDMA1_Channel1_IRQHandler>:
DEFAULT_IRQ_HANDLER(GPDMA1_Channel1_IRQHandler)
 c038674:	e7fe      	b.n	c038674 <GPDMA1_Channel1_IRQHandler>

0c038676 <GPDMA1_Channel2_IRQHandler>:
DEFAULT_IRQ_HANDLER(GPDMA1_Channel2_IRQHandler)
 c038676:	e7fe      	b.n	c038676 <GPDMA1_Channel2_IRQHandler>

0c038678 <GPDMA1_Channel3_IRQHandler>:
DEFAULT_IRQ_HANDLER(GPDMA1_Channel3_IRQHandler)
 c038678:	e7fe      	b.n	c038678 <GPDMA1_Channel3_IRQHandler>

0c03867a <GPDMA1_Channel4_IRQHandler>:
DEFAULT_IRQ_HANDLER(GPDMA1_Channel4_IRQHandler)
 c03867a:	e7fe      	b.n	c03867a <GPDMA1_Channel4_IRQHandler>

0c03867c <GPDMA1_Channel5_IRQHandler>:
DEFAULT_IRQ_HANDLER(GPDMA1_Channel5_IRQHandler)
 c03867c:	e7fe      	b.n	c03867c <GPDMA1_Channel5_IRQHandler>

0c03867e <GPDMA1_Channel6_IRQHandler>:
DEFAULT_IRQ_HANDLER(GPDMA1_Channel6_IRQHandler)
 c03867e:	e7fe      	b.n	c03867e <GPDMA1_Channel6_IRQHandler>

0c038680 <GPDMA1_Channel7_IRQHandler>:
DEFAULT_IRQ_HANDLER(GPDMA1_Channel7_IRQHandler)
 c038680:	e7fe      	b.n	c038680 <GPDMA1_Channel7_IRQHandler>

0c038682 <ADC1_IRQHandler>:
#if defined(STM32U585xx) || defined(STM32U575xx) || defined(STM32U535xx) || defined(STM32U545xx)
DEFAULT_IRQ_HANDLER(ADC1_IRQHandler)
 c038682:	e7fe      	b.n	c038682 <ADC1_IRQHandler>

0c038684 <DAC1_IRQHandler>:
#else
DEFAULT_IRQ_HANDLER(ADC1_2_IRQHandler)
#endif /* defined(STM32U585xx) || defined(STM32U575xx) || defined(STM32U535xx) || defined(STM32U545xx) */
DEFAULT_IRQ_HANDLER(DAC1_IRQHandler)
 c038684:	e7fe      	b.n	c038684 <DAC1_IRQHandler>

0c038686 <FDCAN1_IT0_IRQHandler>:
DEFAULT_IRQ_HANDLER(FDCAN1_IT0_IRQHandler)
 c038686:	e7fe      	b.n	c038686 <FDCAN1_IT0_IRQHandler>

0c038688 <FDCAN1_IT1_IRQHandler>:
DEFAULT_IRQ_HANDLER(FDCAN1_IT1_IRQHandler)
 c038688:	e7fe      	b.n	c038688 <FDCAN1_IT1_IRQHandler>

0c03868a <TIM1_BRK_IRQHandler>:
DEFAULT_IRQ_HANDLER(TIM1_BRK_IRQHandler)
 c03868a:	e7fe      	b.n	c03868a <TIM1_BRK_IRQHandler>

0c03868c <TIM1_UP_IRQHandler>:
DEFAULT_IRQ_HANDLER(TIM1_UP_IRQHandler)
 c03868c:	e7fe      	b.n	c03868c <TIM1_UP_IRQHandler>

0c03868e <TIM1_TRG_COM_IRQHandler>:
DEFAULT_IRQ_HANDLER(TIM1_TRG_COM_IRQHandler)
 c03868e:	e7fe      	b.n	c03868e <TIM1_TRG_COM_IRQHandler>

0c038690 <TIM1_CC_IRQHandler>:
DEFAULT_IRQ_HANDLER(TIM1_CC_IRQHandler)
 c038690:	e7fe      	b.n	c038690 <TIM1_CC_IRQHandler>

0c038692 <TIM2_IRQHandler>:
DEFAULT_IRQ_HANDLER(TIM2_IRQHandler)
 c038692:	e7fe      	b.n	c038692 <TIM2_IRQHandler>

0c038694 <TIM3_IRQHandler>:
DEFAULT_IRQ_HANDLER(TIM3_IRQHandler)
 c038694:	e7fe      	b.n	c038694 <TIM3_IRQHandler>

0c038696 <TIM4_IRQHandler>:
DEFAULT_IRQ_HANDLER(TIM4_IRQHandler)
 c038696:	e7fe      	b.n	c038696 <TIM4_IRQHandler>

0c038698 <TIM5_IRQHandler>:
DEFAULT_IRQ_HANDLER(TIM5_IRQHandler)
 c038698:	e7fe      	b.n	c038698 <TIM5_IRQHandler>

0c03869a <TIM6_IRQHandler>:
DEFAULT_IRQ_HANDLER(TIM6_IRQHandler)
 c03869a:	e7fe      	b.n	c03869a <TIM6_IRQHandler>

0c03869c <TIM7_IRQHandler>:
DEFAULT_IRQ_HANDLER(TIM7_IRQHandler)
 c03869c:	e7fe      	b.n	c03869c <TIM7_IRQHandler>

0c03869e <TIM8_BRK_IRQHandler>:
DEFAULT_IRQ_HANDLER(TIM8_BRK_IRQHandler)
 c03869e:	e7fe      	b.n	c03869e <TIM8_BRK_IRQHandler>

0c0386a0 <TIM8_UP_IRQHandler>:
DEFAULT_IRQ_HANDLER(TIM8_UP_IRQHandler)
 c0386a0:	e7fe      	b.n	c0386a0 <TIM8_UP_IRQHandler>

0c0386a2 <TIM8_TRG_COM_IRQHandler>:
DEFAULT_IRQ_HANDLER(TIM8_TRG_COM_IRQHandler)
 c0386a2:	e7fe      	b.n	c0386a2 <TIM8_TRG_COM_IRQHandler>

0c0386a4 <TIM8_CC_IRQHandler>:
DEFAULT_IRQ_HANDLER(TIM8_CC_IRQHandler)
 c0386a4:	e7fe      	b.n	c0386a4 <TIM8_CC_IRQHandler>

0c0386a6 <I2C1_EV_IRQHandler>:
DEFAULT_IRQ_HANDLER(I2C1_EV_IRQHandler)
 c0386a6:	e7fe      	b.n	c0386a6 <I2C1_EV_IRQHandler>

0c0386a8 <I2C1_ER_IRQHandler>:
DEFAULT_IRQ_HANDLER(I2C1_ER_IRQHandler)
 c0386a8:	e7fe      	b.n	c0386a8 <I2C1_ER_IRQHandler>

0c0386aa <I2C2_EV_IRQHandler>:
DEFAULT_IRQ_HANDLER(I2C2_EV_IRQHandler)
 c0386aa:	e7fe      	b.n	c0386aa <I2C2_EV_IRQHandler>

0c0386ac <I2C2_ER_IRQHandler>:
DEFAULT_IRQ_HANDLER(I2C2_ER_IRQHandler)
 c0386ac:	e7fe      	b.n	c0386ac <I2C2_ER_IRQHandler>

0c0386ae <SPI1_IRQHandler>:
DEFAULT_IRQ_HANDLER(SPI1_IRQHandler)
 c0386ae:	e7fe      	b.n	c0386ae <SPI1_IRQHandler>

0c0386b0 <SPI2_IRQHandler>:
DEFAULT_IRQ_HANDLER(SPI2_IRQHandler)
 c0386b0:	e7fe      	b.n	c0386b0 <SPI2_IRQHandler>

0c0386b2 <USART1_IRQHandler>:
DEFAULT_IRQ_HANDLER(USART1_IRQHandler)
 c0386b2:	e7fe      	b.n	c0386b2 <USART1_IRQHandler>

0c0386b4 <USART2_IRQHandler>:
#if !(defined(STM32U535xx) || defined(STM32U545xx))
DEFAULT_IRQ_HANDLER(USART2_IRQHandler)
 c0386b4:	e7fe      	b.n	c0386b4 <USART2_IRQHandler>

0c0386b6 <USART3_IRQHandler>:
#endif /* !(defined(STM32U535xx) || defined(STM32U545xx)) */
DEFAULT_IRQ_HANDLER(USART3_IRQHandler)
 c0386b6:	e7fe      	b.n	c0386b6 <USART3_IRQHandler>

0c0386b8 <UART4_IRQHandler>:
DEFAULT_IRQ_HANDLER(UART4_IRQHandler)
 c0386b8:	e7fe      	b.n	c0386b8 <UART4_IRQHandler>

0c0386ba <UART5_IRQHandler>:
DEFAULT_IRQ_HANDLER(UART5_IRQHandler)
 c0386ba:	e7fe      	b.n	c0386ba <UART5_IRQHandler>

0c0386bc <LPUART1_IRQHandler>:
DEFAULT_IRQ_HANDLER(LPUART1_IRQHandler)
 c0386bc:	e7fe      	b.n	c0386bc <LPUART1_IRQHandler>

0c0386be <LPTIM1_IRQHandler>:
DEFAULT_IRQ_HANDLER(LPTIM1_IRQHandler)
 c0386be:	e7fe      	b.n	c0386be <LPTIM1_IRQHandler>

0c0386c0 <LPTIM2_IRQHandler>:
DEFAULT_IRQ_HANDLER(LPTIM2_IRQHandler)
 c0386c0:	e7fe      	b.n	c0386c0 <LPTIM2_IRQHandler>

0c0386c2 <TIM15_IRQHandler>:
DEFAULT_IRQ_HANDLER(TIM15_IRQHandler)
 c0386c2:	e7fe      	b.n	c0386c2 <TIM15_IRQHandler>

0c0386c4 <TIM16_IRQHandler>:
DEFAULT_IRQ_HANDLER(TIM16_IRQHandler)
 c0386c4:	e7fe      	b.n	c0386c4 <TIM16_IRQHandler>

0c0386c6 <TIM17_IRQHandler>:
DEFAULT_IRQ_HANDLER(TIM17_IRQHandler)
 c0386c6:	e7fe      	b.n	c0386c6 <TIM17_IRQHandler>

0c0386c8 <COMP_IRQHandler>:
DEFAULT_IRQ_HANDLER(COMP_IRQHandler)
 c0386c8:	e7fe      	b.n	c0386c8 <COMP_IRQHandler>

0c0386ca <OTG_FS_IRQHandler>:
#if defined(STM32U535xx) || defined(STM32U545xx)
DEFAULT_IRQ_HANDLER(USB_IRQHandler)
#elif defined(STM32U585xx) || defined(STM32U575xx)
DEFAULT_IRQ_HANDLER(OTG_FS_IRQHandler)
 c0386ca:	e7fe      	b.n	c0386ca <OTG_FS_IRQHandler>

0c0386cc <CRS_IRQHandler>:
#else
DEFAULT_IRQ_HANDLER(OTG_HS_IRQHandler)
#endif /* defined(STM32U535xx) || defined(STM32U545xx) */
DEFAULT_IRQ_HANDLER(CRS_IRQHandler)
 c0386cc:	e7fe      	b.n	c0386cc <CRS_IRQHandler>

0c0386ce <FMC_IRQHandler>:
#if !(defined(STM32U535xx) || defined(STM32U545xx))
DEFAULT_IRQ_HANDLER(FMC_IRQHandler)
 c0386ce:	e7fe      	b.n	c0386ce <FMC_IRQHandler>

0c0386d0 <OCTOSPI1_IRQHandler>:
#endif /* !(defined(STM32U535xx) || defined(STM32U545xx)) */
DEFAULT_IRQ_HANDLER(OCTOSPI1_IRQHandler)
 c0386d0:	e7fe      	b.n	c0386d0 <OCTOSPI1_IRQHandler>

0c0386d2 <PWR_S3WU_IRQHandler>:
DEFAULT_IRQ_HANDLER(PWR_S3WU_IRQHandler)
 c0386d2:	e7fe      	b.n	c0386d2 <PWR_S3WU_IRQHandler>

0c0386d4 <SDMMC1_IRQHandler>:
DEFAULT_IRQ_HANDLER(SDMMC1_IRQHandler)
 c0386d4:	e7fe      	b.n	c0386d4 <SDMMC1_IRQHandler>

0c0386d6 <SDMMC2_IRQHandler>:
#if !(defined(STM32U535xx) || defined(STM32U545xx))
DEFAULT_IRQ_HANDLER(SDMMC2_IRQHandler)
 c0386d6:	e7fe      	b.n	c0386d6 <SDMMC2_IRQHandler>

0c0386d8 <GPDMA1_Channel8_IRQHandler>:
#endif /* !(defined(STM32U535xx) || defined(STM32U545xx)) */

DEFAULT_IRQ_HANDLER(DMA2_Channel1_IRQHandler)
DEFAULT_IRQ_HANDLER(GPDMA1_Channel8_IRQHandler)
 c0386d8:	e7fe      	b.n	c0386d8 <GPDMA1_Channel8_IRQHandler>

0c0386da <GPDMA1_Channel9_IRQHandler>:
DEFAULT_IRQ_HANDLER(GPDMA1_Channel9_IRQHandler)
 c0386da:	e7fe      	b.n	c0386da <GPDMA1_Channel9_IRQHandler>

0c0386dc <GPDMA1_Channel10_IRQHandler>:
DEFAULT_IRQ_HANDLER(GPDMA1_Channel10_IRQHandler)
 c0386dc:	e7fe      	b.n	c0386dc <GPDMA1_Channel10_IRQHandler>

0c0386de <GPDMA1_Channel11_IRQHandler>:
DEFAULT_IRQ_HANDLER(GPDMA1_Channel11_IRQHandler)
 c0386de:	e7fe      	b.n	c0386de <GPDMA1_Channel11_IRQHandler>

0c0386e0 <GPDMA1_Channel12_IRQHandler>:
DEFAULT_IRQ_HANDLER(GPDMA1_Channel12_IRQHandler)
 c0386e0:	e7fe      	b.n	c0386e0 <GPDMA1_Channel12_IRQHandler>

0c0386e2 <GPDMA1_Channel13_IRQHandler>:
DEFAULT_IRQ_HANDLER(GPDMA1_Channel13_IRQHandler)
 c0386e2:	e7fe      	b.n	c0386e2 <GPDMA1_Channel13_IRQHandler>

0c0386e4 <GPDMA1_Channel14_IRQHandler>:
DEFAULT_IRQ_HANDLER(GPDMA1_Channel14_IRQHandler)
 c0386e4:	e7fe      	b.n	c0386e4 <GPDMA1_Channel14_IRQHandler>

0c0386e6 <GPDMA1_Channel15_IRQHandler>:
DEFAULT_IRQ_HANDLER(GPDMA1_Channel15_IRQHandler)
 c0386e6:	e7fe      	b.n	c0386e6 <GPDMA1_Channel15_IRQHandler>

0c0386e8 <I2C3_EV_IRQHandler>:
DEFAULT_IRQ_HANDLER(I2C3_EV_IRQHandler)
 c0386e8:	e7fe      	b.n	c0386e8 <I2C3_EV_IRQHandler>

0c0386ea <I2C3_ER_IRQHandler>:
DEFAULT_IRQ_HANDLER(I2C3_ER_IRQHandler)
 c0386ea:	e7fe      	b.n	c0386ea <I2C3_ER_IRQHandler>

0c0386ec <SAI1_IRQHandler>:
DEFAULT_IRQ_HANDLER(SAI1_IRQHandler)
 c0386ec:	e7fe      	b.n	c0386ec <SAI1_IRQHandler>

0c0386ee <SAI2_IRQHandler>:
#if !(defined(STM32U535xx) || defined(STM32U545xx))
DEFAULT_IRQ_HANDLER(SAI2_IRQHandler)
 c0386ee:	e7fe      	b.n	c0386ee <SAI2_IRQHandler>

0c0386f0 <TSC_IRQHandler>:
#endif /* !(defined(STM32U535xx) || defined(STM32U545xx)) */
DEFAULT_IRQ_HANDLER(TSC_IRQHandler)
 c0386f0:	e7fe      	b.n	c0386f0 <TSC_IRQHandler>

0c0386f2 <AES_IRQHandler>:
#if defined(STM32U585xx) || defined(STM32U5A5xx) || defined(STM32U5A9xx) || defined(STM32U545xx)
DEFAULT_IRQ_HANDLER(AES_IRQHandler)
 c0386f2:	e7fe      	b.n	c0386f2 <AES_IRQHandler>

0c0386f4 <RNG_IRQHandler>:
#endif /* defined(STM32U585xx) || defined(STM32U5A5xx) || defined(STM32U5A9xx) || defined(STM32U545xx) */
DEFAULT_IRQ_HANDLER(RNG_IRQHandler)
 c0386f4:	e7fe      	b.n	c0386f4 <RNG_IRQHandler>

0c0386f6 <FPU_IRQHandler>:
DEFAULT_IRQ_HANDLER(FPU_IRQHandler)
 c0386f6:	e7fe      	b.n	c0386f6 <FPU_IRQHandler>

0c0386f8 <HASH_IRQHandler>:
DEFAULT_IRQ_HANDLER(HASH_IRQHandler)
 c0386f8:	e7fe      	b.n	c0386f8 <HASH_IRQHandler>

0c0386fa <PKA_IRQHandler>:
#if defined(STM32U585xx) || defined(STM32U5A5xx) || defined(STM32U5A9xx) || defined(STM32U545xx)
DEFAULT_IRQ_HANDLER(PKA_IRQHandler)
 c0386fa:	e7fe      	b.n	c0386fa <PKA_IRQHandler>

0c0386fc <LPTIM3_IRQHandler>:
#endif /* defined(STM32U585xx) || defined(STM32U5A5xx) || defined(STM32U5A9xx) || defined(STM32U545xx) */
DEFAULT_IRQ_HANDLER(LPTIM3_IRQHandler)
 c0386fc:	e7fe      	b.n	c0386fc <LPTIM3_IRQHandler>

0c0386fe <SPI3_IRQHandler>:
DEFAULT_IRQ_HANDLER(SPI3_IRQHandler)
 c0386fe:	e7fe      	b.n	c0386fe <SPI3_IRQHandler>

0c038700 <I2C4_ER_IRQHandler>:
DEFAULT_IRQ_HANDLER(I2C4_ER_IRQHandler)
 c038700:	e7fe      	b.n	c038700 <I2C4_ER_IRQHandler>

0c038702 <I2C4_EV_IRQHandler>:
DEFAULT_IRQ_HANDLER(I2C4_EV_IRQHandler)
 c038702:	e7fe      	b.n	c038702 <I2C4_EV_IRQHandler>

0c038704 <MDF1_FLT0_IRQHandler>:
DEFAULT_IRQ_HANDLER(MDF1_FLT0_IRQHandler)
 c038704:	e7fe      	b.n	c038704 <MDF1_FLT0_IRQHandler>

0c038706 <MDF1_FLT1_IRQHandler>:
DEFAULT_IRQ_HANDLER(MDF1_FLT1_IRQHandler)
 c038706:	e7fe      	b.n	c038706 <MDF1_FLT1_IRQHandler>

0c038708 <MDF1_FLT2_IRQHandler>:
#if !(defined(STM32U535xx) || defined(STM32U545xx))
DEFAULT_IRQ_HANDLER(MDF1_FLT2_IRQHandler)
 c038708:	e7fe      	b.n	c038708 <MDF1_FLT2_IRQHandler>

0c03870a <MDF1_FLT3_IRQHandler>:
DEFAULT_IRQ_HANDLER(MDF1_FLT3_IRQHandler)
 c03870a:	e7fe      	b.n	c03870a <MDF1_FLT3_IRQHandler>

0c03870c <UCPD1_IRQHandler>:
DEFAULT_IRQ_HANDLER(UCPD1_IRQHandler)
 c03870c:	e7fe      	b.n	c03870c <UCPD1_IRQHandler>

0c03870e <ICACHE_IRQHandler>:
#endif /* !(defined(STM32U535xx) || defined(STM32U545xx)) */
DEFAULT_IRQ_HANDLER(ICACHE_IRQHandler)
 c03870e:	e7fe      	b.n	c03870e <ICACHE_IRQHandler>

0c038710 <OTFDEC1_IRQHandler>:
#if defined(STM32U545xx)
DEFAULT_IRQ_HANDLER(OTFDEC1_IRQHandler)
#elif defined(STM32U585xx) || defined(STM32U5A5xx) || defined(STM32U5A9xx)
DEFAULT_IRQ_HANDLER(OTFDEC1_IRQHandler)
 c038710:	e7fe      	b.n	c038710 <OTFDEC1_IRQHandler>

0c038712 <OTFDEC2_IRQHandler>:
DEFAULT_IRQ_HANDLER(OTFDEC2_IRQHandler)
 c038712:	e7fe      	b.n	c038712 <OTFDEC2_IRQHandler>

0c038714 <LPTIM4_IRQHandler>:
#endif /* defined(STM32U545xx) */
DEFAULT_IRQ_HANDLER(LPTIM4_IRQHandler)
 c038714:	e7fe      	b.n	c038714 <LPTIM4_IRQHandler>

0c038716 <DCACHE1_IRQHandler>:
DEFAULT_IRQ_HANDLER(DCACHE1_IRQHandler)
 c038716:	e7fe      	b.n	c038716 <DCACHE1_IRQHandler>

0c038718 <ADF1_IRQHandler>:
DEFAULT_IRQ_HANDLER(ADF1_IRQHandler)
 c038718:	e7fe      	b.n	c038718 <ADF1_IRQHandler>

0c03871a <ADC4_IRQHandler>:
DEFAULT_IRQ_HANDLER(ADC4_IRQHandler)
 c03871a:	e7fe      	b.n	c03871a <ADC4_IRQHandler>

0c03871c <LPDMA1_Channel0_IRQHandler>:
DEFAULT_IRQ_HANDLER(LPDMA1_Channel0_IRQHandler)
 c03871c:	e7fe      	b.n	c03871c <LPDMA1_Channel0_IRQHandler>

0c03871e <LPDMA1_Channel1_IRQHandler>:
DEFAULT_IRQ_HANDLER(LPDMA1_Channel1_IRQHandler)
 c03871e:	e7fe      	b.n	c03871e <LPDMA1_Channel1_IRQHandler>

0c038720 <LPDMA1_Channel2_IRQHandler>:
DEFAULT_IRQ_HANDLER(LPDMA1_Channel2_IRQHandler)
 c038720:	e7fe      	b.n	c038720 <LPDMA1_Channel2_IRQHandler>

0c038722 <LPDMA1_Channel3_IRQHandler>:
DEFAULT_IRQ_HANDLER(LPDMA1_Channel3_IRQHandler)
 c038722:	e7fe      	b.n	c038722 <LPDMA1_Channel3_IRQHandler>

0c038724 <DMA2D_IRQHandler>:
#if !(defined(STM32U535xx) || defined(STM32U545xx))
DEFAULT_IRQ_HANDLER(DMA2D_IRQHandler)
 c038724:	e7fe      	b.n	c038724 <DMA2D_IRQHandler>

0c038726 <DCMI_PSSI_IRQHandler>:
#endif /* !(defined(STM32U535xx) || defined(STM32U545xx)) */
DEFAULT_IRQ_HANDLER(DCMI_PSSI_IRQHandler)
 c038726:	e7fe      	b.n	c038726 <DCMI_PSSI_IRQHandler>

0c038728 <OCTOSPI2_IRQHandler>:
#if !(defined(STM32U535xx) || defined(STM32U545xx))
DEFAULT_IRQ_HANDLER(OCTOSPI2_IRQHandler)
 c038728:	e7fe      	b.n	c038728 <OCTOSPI2_IRQHandler>

0c03872a <MDF1_FLT4_IRQHandler>:
DEFAULT_IRQ_HANDLER(MDF1_FLT4_IRQHandler)
 c03872a:	e7fe      	b.n	c03872a <MDF1_FLT4_IRQHandler>

0c03872c <MDF1_FLT5_IRQHandler>:
DEFAULT_IRQ_HANDLER(MDF1_FLT5_IRQHandler)
 c03872c:	e7fe      	b.n	c03872c <MDF1_FLT5_IRQHandler>

0c03872e <CORDIC_IRQHandler>:
#endif /* !(defined(STM32U535xx) || defined(STM32U545xx)) */
DEFAULT_IRQ_HANDLER(CORDIC_IRQHandler)
 c03872e:	e7fe      	b.n	c03872e <CORDIC_IRQHandler>

0c038730 <FMAC_IRQHandler>:
DEFAULT_IRQ_HANDLER(FMAC_IRQHandler)
 c038730:	e7fe      	b.n	c038730 <FMAC_IRQHandler>

0c038732 <LSECSSD_IRQHandler>:
DEFAULT_IRQ_HANDLER(LSECSSD_IRQHandler)
 c038732:	e7fe      	b.n	c038732 <LSECSSD_IRQHandler>

0c038734 <Reset_Handler>:

/*----------------------------------------------------------------------------
  Reset Handler called on controller reset
 *----------------------------------------------------------------------------*/
void Reset_Handler(void)
{
 c038734:	b507      	push	{r0, r1, r2, lr}
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 c038736:	2200      	movs	r2, #0
 c038738:	4b2b      	ldr	r3, [pc, #172]	@ (c0387e8 <Reset_Handler+0xb4>)
 c03873a:	f883 2304 	strb.w	r2, [r3, #772]	@ 0x304
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 c03873e:	2210      	movs	r2, #16
 c038740:	601a      	str	r2, [r3, #0]
#if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
    (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
  // without main extensions, the non-secure MSPLIM is RAZ/WI
  (void)MainStackPtrLimit;
#else
  __ASM volatile ("MSR msplim, %0" : : "r" (MainStackPtrLimit));
 c038742:	4b2a      	ldr	r3, [pc, #168]	@ (c0387ec <Reset_Handler+0xb8>)
 c038744:	f383 880a 	msr	MSPLIM, r3
  /*__disable_irq();*/
  /* Tamp IRQ prio is set to highest , and IRQ is enabled */
  NVIC_SetPriority(TAMP_IRQn, 0);
  NVIC_EnableIRQ(TAMP_IRQn);
  __set_MSPLIM((uint32_t)(&__MSP_STACK_LIMIT));
  SCB->VTOR = (uint32_t) &__VECTOR_TABLE[0];
 c038748:	4a29      	ldr	r2, [pc, #164]	@ (c0387f0 <Reset_Handler+0xbc>)
 c03874a:	4b2a      	ldr	r3, [pc, #168]	@ (c0387f4 <Reset_Handler+0xc0>)
 c03874c:	6093      	str	r3, [r2, #8]

  /* Program AIRCR with PRIS = 1*/
  tmp = SCB->AIRCR;
 c03874e:	68d3      	ldr	r3, [r2, #12]
  SCB->AIRCR = (~tmp & SCB_AIRCR_VECTKEYSTAT_Msk) |
  SCB_AIRCR_PRIS_Msk | (tmp & ~SCB_AIRCR_VECTKEY_Msk);
 c038750:	f083 437f 	eor.w	r3, r3, #4278190080	@ 0xff000000
 c038754:	f483 037f 	eor.w	r3, r3, #16711680	@ 0xff0000
 c038758:	f443 4380 	orr.w	r3, r3, #16384	@ 0x4000
  SCB->AIRCR = (~tmp & SCB_AIRCR_VECTKEYSTAT_Msk) |
 c03875c:	60d3      	str	r3, [r2, #12]

  /* Lock Secure Vector Table */
  /* Enable SYSCFG interface clock */
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 c03875e:	4b26      	ldr	r3, [pc, #152]	@ (c0387f8 <Reset_Handler+0xc4>)
 c038760:	f8d3 20a8 	ldr.w	r2, [r3, #168]	@ 0xa8
 c038764:	f042 0202 	orr.w	r2, r2, #2
 c038768:	f8c3 20a8 	str.w	r2, [r3, #168]	@ 0xa8
 c03876c:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
  SYSCFG->CSLCKR |= SYSCFG_CSLCKR_LOCKSVTAIRCR;
 c038770:	4a22      	ldr	r2, [pc, #136]	@ (c0387fc <Reset_Handler+0xc8>)
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 c038772:	f003 0302 	and.w	r3, r3, #2
 c038776:	9301      	str	r3, [sp, #4]
 c038778:	9b01      	ldr	r3, [sp, #4]
  SYSCFG->CSLCKR |= SYSCFG_CSLCKR_LOCKSVTAIRCR;
 c03877a:	6913      	ldr	r3, [r2, #16]
 c03877c:	f043 0301 	orr.w	r3, r3, #1
 c038780:	6113      	str	r3, [r2, #16]
  SystemInit();   /* CMSIS System Initialization */
 c038782:	f01a f8f7 	bl	c052974 <SystemInit>
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 c038786:	4b1e      	ldr	r3, [pc, #120]	@ (c038800 <Reset_Handler+0xcc>)
 c038788:	f383 8809 	msr	PSP, r3
  __ASM volatile ("MSR psplim, %0" : : "r" (ProcStackPtrLimit));
 c03878c:	4b1d      	ldr	r3, [pc, #116]	@ (c038804 <Reset_Handler+0xd0>)
 c03878e:	f383 880b 	msr	PSPLIM, r3
  __set_PSP((uint32_t)(&__INITIAL_SP));
  __set_PSPLIM((uint32_t)(&__STACK_LIMIT));
  __ASM volatile("MRS     R0, control\n"    /* Get control value */
 c038792:	f3ef 8014 	mrs	r0, CONTROL
 c038796:	f040 0002 	orr.w	r0, r0, #2
 c03879a:	f380 8814 	msr	CONTROL, r0
  for (__copy_table_t const* pTable = &__copy_table_start__; pTable < &__copy_table_end__; ++pTable) {
 c03879e:	4b1a      	ldr	r3, [pc, #104]	@ (c038808 <Reset_Handler+0xd4>)
 c0387a0:	491a      	ldr	r1, [pc, #104]	@ (c03880c <Reset_Handler+0xd8>)
 c0387a2:	428b      	cmp	r3, r1
 c0387a4:	d312      	bcc.n	c0387cc <Reset_Handler+0x98>
      pTable->dest[i] = 0u;
 c0387a6:	2000      	movs	r0, #0
  for (__zero_table_t const* pTable = &__zero_table_start__; pTable < &__zero_table_end__; ++pTable) {
 c0387a8:	4b19      	ldr	r3, [pc, #100]	@ (c038810 <Reset_Handler+0xdc>)
 c0387aa:	491a      	ldr	r1, [pc, #104]	@ (c038814 <Reset_Handler+0xe0>)
 c0387ac:	428b      	cmp	r3, r1
 c0387ae:	d318      	bcc.n	c0387e2 <Reset_Handler+0xae>
  _start();
 c0387b0:	f013 f92a 	bl	c04ba08 <_mainCRTStartup>
      pTable->dest[i] = pTable->src[i];
 c0387b4:	6818      	ldr	r0, [r3, #0]
 c0387b6:	f850 4022 	ldr.w	r4, [r0, r2, lsl #2]
 c0387ba:	6858      	ldr	r0, [r3, #4]
 c0387bc:	f840 4022 	str.w	r4, [r0, r2, lsl #2]
    for(uint32_t i=0u; i<pTable->wlen; ++i) {
 c0387c0:	3201      	adds	r2, #1
 c0387c2:	6898      	ldr	r0, [r3, #8]
 c0387c4:	4282      	cmp	r2, r0
 c0387c6:	d3f5      	bcc.n	c0387b4 <Reset_Handler+0x80>
  for (__copy_table_t const* pTable = &__copy_table_start__; pTable < &__copy_table_end__; ++pTable) {
 c0387c8:	330c      	adds	r3, #12
 c0387ca:	e7ea      	b.n	c0387a2 <Reset_Handler+0x6e>
    for(uint32_t i=0u; i<pTable->wlen; ++i) {
 c0387cc:	2200      	movs	r2, #0
 c0387ce:	e7f8      	b.n	c0387c2 <Reset_Handler+0x8e>
      pTable->dest[i] = 0u;
 c0387d0:	681c      	ldr	r4, [r3, #0]
 c0387d2:	f844 0022 	str.w	r0, [r4, r2, lsl #2]
    for(uint32_t i=0u; i<pTable->wlen; ++i) {
 c0387d6:	3201      	adds	r2, #1
 c0387d8:	685c      	ldr	r4, [r3, #4]
 c0387da:	42a2      	cmp	r2, r4
 c0387dc:	d3f8      	bcc.n	c0387d0 <Reset_Handler+0x9c>
  for (__zero_table_t const* pTable = &__zero_table_start__; pTable < &__zero_table_end__; ++pTable) {
 c0387de:	3308      	adds	r3, #8
 c0387e0:	e7e4      	b.n	c0387ac <Reset_Handler+0x78>
    for(uint32_t i=0u; i<pTable->wlen; ++i) {
 c0387e2:	2200      	movs	r2, #0
 c0387e4:	e7f8      	b.n	c0387d8 <Reset_Handler+0xa4>
 c0387e6:	bf00      	nop
 c0387e8:	e000e100 	.word	0xe000e100
 c0387ec:	30030400 	.word	0x30030400
 c0387f0:	e000ed00 	.word	0xe000ed00
 c0387f4:	0c038400 	.word	0x0c038400
 c0387f8:	56020c00 	.word	0x56020c00
 c0387fc:	56000400 	.word	0x56000400
 c038800:	3003f200 	.word	0x3003f200
 c038804:	3003ea00 	.word	0x3003ea00
 c038808:	0c038818 	.word	0x0c038818
 c03880c:	0c038878 	.word	0x0c038878
 c038810:	0c038878 	.word	0x0c038878
 c038814:	0c0388b8 	.word	0x0c0388b8

Disassembly of section .TFM_SP_ITS_RO:

0c0388c0 <tfm_its_init>:

    return PSA_SUCCESS;
}

psa_status_t tfm_its_init(void)
{
 c0388c0:	b570      	push	{r4, r5, r6, lr}
    if (TFM_HAL_ITS_FLASH_DRIVER.GetInfo()->program_unit
 c0388c2:	4b37      	ldr	r3, [pc, #220]	@ (c0389a0 <tfm_its_init+0xe0>)
{
 c0388c4:	b086      	sub	sp, #24
    if (TFM_HAL_ITS_FLASH_DRIVER.GetInfo()->program_unit
 c0388c6:	6a9e      	ldr	r6, [r3, #40]	@ 0x28
 c0388c8:	47b0      	blx	r6
 c0388ca:	6903      	ldr	r3, [r0, #16]
 c0388cc:	2b10      	cmp	r3, #16
 c0388ce:	d003      	beq.n	c0388d8 <tfm_its_init+0x18>
        return PSA_ERROR_PROGRAMMER_ERROR;
 c0388d0:	f06f 0080 	mvn.w	r0, #128	@ 0x80
    }
#endif /* PS_CREATE_FLASH_LAYOUT */
#endif /* TFM_PARTITION_PROTECTED_STORAGE */

    return status;
}
 c0388d4:	b006      	add	sp, #24
 c0388d6:	bd70      	pop	{r4, r5, r6, pc}
    fs_cfg_its.sector_size = TFM_HAL_ITS_FLASH_DRIVER.GetInfo()->sector_size;
 c0388d8:	47b0      	blx	r6
 c0388da:	4c32      	ldr	r4, [pc, #200]	@ (c0389a4 <tfm_its_init+0xe4>)
 c0388dc:	6883      	ldr	r3, [r0, #8]
 c0388de:	8123      	strh	r3, [r4, #8]
    fs_cfg_its.erase_val = TFM_HAL_ITS_FLASH_DRIVER.GetInfo()->erased_value;
 c0388e0:	47b0      	blx	r6
 c0388e2:	7d03      	ldrb	r3, [r0, #20]
    if (tfm_hal_its_fs_info(&its_fs_info) != TFM_HAL_SUCCESS) {
 c0388e4:	4668      	mov	r0, sp
    fs_cfg_its.erase_val = TFM_HAL_ITS_FLASH_DRIVER.GetInfo()->erased_value;
 c0388e6:	7523      	strb	r3, [r4, #20]
    if (tfm_hal_its_fs_info(&its_fs_info) != TFM_HAL_SUCCESS) {
 c0388e8:	f025 fb52 	bl	c05df90 <tfm_hal_its_fs_info>
 c0388ec:	2800      	cmp	r0, #0
 c0388ee:	d1ef      	bne.n	c0388d0 <tfm_its_init+0x10>
    fs_cfg_its.flash_area_addr = its_fs_info.flash_area_addr;
 c0388f0:	9b00      	ldr	r3, [sp, #0]
                            * its_fs_info.sectors_per_block;
 c0388f2:	8922      	ldrh	r2, [r4, #8]
    fs_cfg_its.flash_area_addr = its_fs_info.flash_area_addr;
 c0388f4:	6063      	str	r3, [r4, #4]
                            * its_fs_info.sectors_per_block;
 c0388f6:	f89d 3008 	ldrb.w	r3, [sp, #8]
 c0388fa:	fb13 f302 	smulbb	r3, r3, r2
    fs_cfg_its.num_blocks = its_fs_info.flash_area_size / fs_cfg_its.block_size;
 c0388fe:	9a01      	ldr	r2, [sp, #4]
                            * its_fs_info.sectors_per_block;
 c038900:	b29b      	uxth	r3, r3
    fs_cfg_its.num_blocks = its_fs_info.flash_area_size / fs_cfg_its.block_size;
 c038902:	fbb2 f2f3 	udiv	r2, r2, r3
    fs_cfg_its.block_size = fs_cfg_its.sector_size
 c038906:	8163      	strh	r3, [r4, #10]
    fs_cfg_its.num_blocks = its_fs_info.flash_area_size / fs_cfg_its.block_size;
 c038908:	81a2      	strh	r2, [r4, #12]
    if (TFM_HAL_PS_FLASH_DRIVER.GetInfo()->program_unit
 c03890a:	47b0      	blx	r6
 c03890c:	6903      	ldr	r3, [r0, #16]
 c03890e:	2b10      	cmp	r3, #16
 c038910:	d1de      	bne.n	c0388d0 <tfm_its_init+0x10>
    fs_cfg_ps.sector_size = TFM_HAL_PS_FLASH_DRIVER.GetInfo()->sector_size;
 c038912:	47b0      	blx	r6
 c038914:	4d24      	ldr	r5, [pc, #144]	@ (c0389a8 <tfm_its_init+0xe8>)
 c038916:	6883      	ldr	r3, [r0, #8]
 c038918:	812b      	strh	r3, [r5, #8]
    fs_cfg_ps.erase_val = TFM_HAL_PS_FLASH_DRIVER.GetInfo()->erased_value;
 c03891a:	47b0      	blx	r6
 c03891c:	7d03      	ldrb	r3, [r0, #20]
    if (tfm_hal_ps_fs_info(&ps_fs_info) != TFM_HAL_SUCCESS) {
 c03891e:	a803      	add	r0, sp, #12
    fs_cfg_ps.erase_val = TFM_HAL_PS_FLASH_DRIVER.GetInfo()->erased_value;
 c038920:	752b      	strb	r3, [r5, #20]
    if (tfm_hal_ps_fs_info(&ps_fs_info) != TFM_HAL_SUCCESS) {
 c038922:	f012 fc5c 	bl	c04b1de <tfm_hal_ps_fs_info>
 c038926:	2800      	cmp	r0, #0
 c038928:	d1d2      	bne.n	c0388d0 <tfm_its_init+0x10>
    fs_cfg_ps.flash_area_addr = ps_fs_info.flash_area_addr;
 c03892a:	9b03      	ldr	r3, [sp, #12]
    fs_cfg_ps.block_size = fs_cfg_ps.sector_size * ps_fs_info.sectors_per_block;
 c03892c:	892a      	ldrh	r2, [r5, #8]
    fs_cfg_ps.flash_area_addr = ps_fs_info.flash_area_addr;
 c03892e:	606b      	str	r3, [r5, #4]
    fs_cfg_ps.block_size = fs_cfg_ps.sector_size * ps_fs_info.sectors_per_block;
 c038930:	f89d 3014 	ldrb.w	r3, [sp, #20]
    status = its_flash_fs_init_ctx(&fs_ctx_its, &fs_cfg_its, &ITS_FLASH_OPS);
 c038934:	4621      	mov	r1, r4
    fs_cfg_ps.block_size = fs_cfg_ps.sector_size * ps_fs_info.sectors_per_block;
 c038936:	fb13 f302 	smulbb	r3, r3, r2
    fs_cfg_ps.num_blocks = ps_fs_info.flash_area_size / fs_cfg_ps.block_size;
 c03893a:	9a04      	ldr	r2, [sp, #16]
    fs_cfg_ps.block_size = fs_cfg_ps.sector_size * ps_fs_info.sectors_per_block;
 c03893c:	b29b      	uxth	r3, r3
    fs_cfg_ps.num_blocks = ps_fs_info.flash_area_size / fs_cfg_ps.block_size;
 c03893e:	fbb2 f2f3 	udiv	r2, r2, r3
    status = its_flash_fs_init_ctx(&fs_ctx_its, &fs_cfg_its, &ITS_FLASH_OPS);
 c038942:	481a      	ldr	r0, [pc, #104]	@ (c0389ac <tfm_its_init+0xec>)
    fs_cfg_ps.num_blocks = ps_fs_info.flash_area_size / fs_cfg_ps.block_size;
 c038944:	81aa      	strh	r2, [r5, #12]
    status = its_flash_fs_init_ctx(&fs_ctx_its, &fs_cfg_its, &ITS_FLASH_OPS);
 c038946:	4a1a      	ldr	r2, [pc, #104]	@ (c0389b0 <tfm_its_init+0xf0>)
    fs_cfg_ps.block_size = fs_cfg_ps.sector_size * ps_fs_info.sectors_per_block;
 c038948:	816b      	strh	r3, [r5, #10]
    status = its_flash_fs_init_ctx(&fs_ctx_its, &fs_cfg_its, &ITS_FLASH_OPS);
 c03894a:	f000 f996 	bl	c038c7a <its_flash_fs_init_ctx>
    if (status != PSA_SUCCESS) {
 c03894e:	2800      	cmp	r0, #0
 c038950:	d1c0      	bne.n	c0388d4 <tfm_its_init+0x14>
    status = its_flash_fs_prepare(&fs_ctx_its);
 c038952:	4816      	ldr	r0, [pc, #88]	@ (c0389ac <tfm_its_init+0xec>)
 c038954:	f000 f9d5 	bl	c038d02 <its_flash_fs_prepare>
     if (status != PSA_SUCCESS) {
 c038958:	b9b0      	cbnz	r0, c038988 <tfm_its_init+0xc8>
    status = its_flash_fs_init_ctx(&fs_ctx_ps, &fs_cfg_ps, &PS_FLASH_OPS);
 c03895a:	4a15      	ldr	r2, [pc, #84]	@ (c0389b0 <tfm_its_init+0xf0>)
 c03895c:	4912      	ldr	r1, [pc, #72]	@ (c0389a8 <tfm_its_init+0xe8>)
 c03895e:	4815      	ldr	r0, [pc, #84]	@ (c0389b4 <tfm_its_init+0xf4>)
 c038960:	f000 f98b 	bl	c038c7a <its_flash_fs_init_ctx>
    if (status != PSA_SUCCESS) {
 c038964:	2800      	cmp	r0, #0
 c038966:	d1b5      	bne.n	c0388d4 <tfm_its_init+0x14>
    status = its_flash_fs_prepare(&fs_ctx_ps);
 c038968:	4812      	ldr	r0, [pc, #72]	@ (c0389b4 <tfm_its_init+0xf4>)
 c03896a:	f000 f9ca 	bl	c038d02 <its_flash_fs_prepare>
     if (status != PSA_SUCCESS) {
 c03896e:	2800      	cmp	r0, #0
 c038970:	d0b0      	beq.n	c0388d4 <tfm_its_init+0x14>
        status = its_flash_fs_wipe_all(&fs_ctx_ps);
 c038972:	4810      	ldr	r0, [pc, #64]	@ (c0389b4 <tfm_its_init+0xf4>)
 c038974:	f000 f9df 	bl	c038d36 <its_flash_fs_wipe_all>
        if (status != PSA_SUCCESS) {
 c038978:	2800      	cmp	r0, #0
 c03897a:	d1ab      	bne.n	c0388d4 <tfm_its_init+0x14>
        status = its_flash_fs_prepare(&fs_ctx_ps);
 c03897c:	480d      	ldr	r0, [pc, #52]	@ (c0389b4 <tfm_its_init+0xf4>)
}
 c03897e:	b006      	add	sp, #24
 c038980:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        status = its_flash_fs_prepare(&fs_ctx_ps);
 c038984:	f000 b9bd 	b.w	c038d02 <its_flash_fs_prepare>
        status = its_flash_fs_wipe_all(&fs_ctx_its);
 c038988:	4808      	ldr	r0, [pc, #32]	@ (c0389ac <tfm_its_init+0xec>)
 c03898a:	f000 f9d4 	bl	c038d36 <its_flash_fs_wipe_all>
        if (status != PSA_SUCCESS) {
 c03898e:	2800      	cmp	r0, #0
 c038990:	d1a0      	bne.n	c0388d4 <tfm_its_init+0x14>
        status = its_flash_fs_prepare(&fs_ctx_its);
 c038992:	4806      	ldr	r0, [pc, #24]	@ (c0389ac <tfm_its_init+0xec>)
 c038994:	f000 f9b5 	bl	c038d02 <its_flash_fs_prepare>
    if (status != PSA_SUCCESS) {
 c038998:	2800      	cmp	r0, #0
 c03899a:	d0de      	beq.n	c03895a <tfm_its_init+0x9a>
 c03899c:	e79a      	b.n	c0388d4 <tfm_its_init+0x14>
 c03899e:	bf00      	nop
 c0389a0:	0c05f7f4 	.word	0x0c05f7f4
 c0389a4:	30030ab0 	.word	0x30030ab0
 c0389a8:	30030a98 	.word	0x30030a98
 c0389ac:	30038950 	.word	0x30038950
 c0389b0:	0c061568 	.word	0x0c061568
 c0389b4:	30038930 	.word	0x30038930

0c0389b8 <tfm_its_set>:

psa_status_t tfm_its_set(int32_t client_id,
                         psa_storage_uid_t uid,
                         size_t data_length,
                         psa_storage_create_flags_t create_flags)
{
 c0389b8:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
    size_t write_size;
    size_t offset;
    uint32_t flags;

    /* Check that the UID is valid */
    if (uid == TFM_ITS_INVALID_UID) {
 c0389bc:	ea52 0103 	orrs.w	r1, r2, r3
{
 c0389c0:	e9dd 540c 	ldrd	r5, r4, [sp, #48]	@ 0x30
    if (uid == TFM_ITS_INVALID_UID) {
 c0389c4:	d03d      	beq.n	c038a42 <tfm_its_set+0x8a>
        return PSA_ERROR_INVALID_ARGUMENT;
    }

    /* Check that the create_flags does not contain any unsupported flags */
    if (create_flags & ~(PSA_STORAGE_FLAG_WRITE_ONCE |
 c0389c6:	2c07      	cmp	r4, #7
 c0389c8:	d83e      	bhi.n	c038a48 <tfm_its_set+0x90>
 *        replaced with a secure implementation due to security concerns.
 */
__attribute__ ((always_inline)) __STATIC_INLINE
void *tfm_memcpy(void *dest, const void *src, size_t num)
{
    return (memcpy(dest, src, num));
 c0389ca:	4921      	ldr	r1, [pc, #132]	@ (c038a50 <tfm_its_set+0x98>)
    return (client_id == TFM_SP_PS) ? &fs_ctx_ps : &fs_ctx_its;
 c0389cc:	4e21      	ldr	r6, [pc, #132]	@ (c038a54 <tfm_its_set+0x9c>)
 c0389ce:	608b      	str	r3, [r1, #8]
 c0389d0:	4b21      	ldr	r3, [pc, #132]	@ (c038a58 <tfm_its_set+0xa0>)

    /* Set file id */
    tfm_its_get_fid(client_id, uid, g_fid);

    /* Read file info */
    status = its_flash_fs_file_get_info(get_fs_ctx(client_id), g_fid,
 c0389d2:	4f22      	ldr	r7, [pc, #136]	@ (c038a5c <tfm_its_set+0xa4>)
    return (client_id == TFM_SP_PS) ? &fs_ctx_ps : &fs_ctx_its;
 c0389d4:	f5b0 7f80 	cmp.w	r0, #256	@ 0x100
 c0389d8:	bf08      	it	eq
 c0389da:	461e      	moveq	r6, r3
 c0389dc:	6008      	str	r0, [r1, #0]
 c0389de:	604a      	str	r2, [r1, #4]
    status = its_flash_fs_file_get_info(get_fs_ctx(client_id), g_fid,
 c0389e0:	4630      	mov	r0, r6
 c0389e2:	463a      	mov	r2, r7
 c0389e4:	f000 f9a9 	bl	c038d3a <its_flash_fs_file_get_info>
                                        &g_file_info);
    if (status == PSA_SUCCESS) {
 c0389e8:	b928      	cbnz	r0, c0389f6 <tfm_its_set+0x3e>
        /* If the object exists and has the write once flag set, then it
         * cannot be modified.
         */
        if (g_file_info.flags & PSA_STORAGE_FLAG_WRITE_ONCE) {
 c0389ea:	68bb      	ldr	r3, [r7, #8]
 c0389ec:	07db      	lsls	r3, r3, #31
 c0389ee:	d505      	bpl.n	c0389fc <tfm_its_set+0x44>
            return PSA_ERROR_NOT_PERMITTED;
 c0389f0:	f06f 0084 	mvn.w	r0, #132	@ 0x84
 c0389f4:	e022      	b.n	c038a3c <tfm_its_set+0x84>
        }
    } else if (status != PSA_ERROR_DOES_NOT_EXIST) {
 c0389f6:	f110 0f8c 	cmn.w	r0, #140	@ 0x8c
 c0389fa:	d11f      	bne.n	c038a3c <tfm_its_set+0x84>
         * If other error occurred, return it
         */
        return status;
    }

    offset = 0;
 c0389fc:	2700      	movs	r7, #0
    do {
        /* Write as much of the data as will fit in the asset_data buffer */
        write_size = ITS_UTILS_MIN(data_length, sizeof(asset_data));

        /* Read asset data from the caller */
        (void)its_req_mngr_read(asset_data, write_size);
 c0389fe:	f8df 8060 	ldr.w	r8, [pc, #96]	@ c038a60 <tfm_its_set+0xa8>

        /* Write to the file in the file system */
        status = its_flash_fs_file_write(get_fs_ctx(client_id), g_fid, flags,
 c038a02:	f8df 904c 	ldr.w	r9, [pc, #76]	@ c038a50 <tfm_its_set+0x98>
    flags = (uint32_t)create_flags |
 c038a06:	f444 3a40 	orr.w	sl, r4, #196608	@ 0x30000
        write_size = ITS_UTILS_MIN(data_length, sizeof(asset_data));
 c038a0a:	f5b5 6f00 	cmp.w	r5, #2048	@ 0x800
 c038a0e:	462c      	mov	r4, r5
 c038a10:	bf28      	it	cs
 c038a12:	f44f 6400 	movcs.w	r4, #2048	@ 0x800
        (void)its_req_mngr_read(asset_data, write_size);
 c038a16:	4812      	ldr	r0, [pc, #72]	@ (c038a60 <tfm_its_set+0xa8>)
 c038a18:	4621      	mov	r1, r4
 c038a1a:	f000 ffb7 	bl	c03998c <its_req_mngr_read>
        status = its_flash_fs_file_write(get_fs_ctx(client_id), g_fid, flags,
 c038a1e:	462b      	mov	r3, r5
 c038a20:	4652      	mov	r2, sl
 c038a22:	4649      	mov	r1, r9
 c038a24:	4630      	mov	r0, r6
 c038a26:	e9cd 7801 	strd	r7, r8, [sp, #4]
 c038a2a:	9400      	str	r4, [sp, #0]
 c038a2c:	f000 f9a8 	bl	c038d80 <its_flash_fs_file_write>
                                         data_length, write_size, offset,
                                         asset_data);
        if (status != PSA_SUCCESS) {
 c038a30:	b920      	cbnz	r0, c038a3c <tfm_its_set+0x84>
        /* Do not create or truncate after the first iteration */
        flags &= ~(ITS_FLASH_FS_FLAG_CREATE | ITS_FLASH_FS_FLAG_TRUNCATE);

        offset += write_size;
        data_length -= write_size;
    } while (data_length > 0);
 c038a32:	1b2d      	subs	r5, r5, r4
        flags &= ~(ITS_FLASH_FS_FLAG_CREATE | ITS_FLASH_FS_FLAG_TRUNCATE);
 c038a34:	f42a 3a40 	bic.w	sl, sl, #196608	@ 0x30000
        offset += write_size;
 c038a38:	4427      	add	r7, r4
    } while (data_length > 0);
 c038a3a:	d1e6      	bne.n	c038a0a <tfm_its_set+0x52>

    return PSA_SUCCESS;
}
 c038a3c:	b004      	add	sp, #16
 c038a3e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        return PSA_ERROR_INVALID_ARGUMENT;
 c038a42:	f06f 0086 	mvn.w	r0, #134	@ 0x86
 c038a46:	e7f9      	b.n	c038a3c <tfm_its_set+0x84>
        return PSA_ERROR_NOT_SUPPORTED;
 c038a48:	f06f 0085 	mvn.w	r0, #133	@ 0x85
 c038a4c:	e7f6      	b.n	c038a3c <tfm_its_set+0x84>
 c038a4e:	bf00      	nop
 c038a50:	3003897c 	.word	0x3003897c
 c038a54:	30038950 	.word	0x30038950
 c038a58:	30038930 	.word	0x30038930
 c038a5c:	30038970 	.word	0x30038970
 c038a60:	30038988 	.word	0x30038988

0c038a64 <tfm_its_get>:
psa_status_t tfm_its_get(int32_t client_id,
                         psa_storage_uid_t uid,
                         size_t data_offset,
                         size_t data_size,
                         size_t *p_data_length)
{
 c038a64:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
        client_id = TFM_SP_PS;
    }
#endif

    /* Check that the UID is valid */
    if (uid == TFM_ITS_INVALID_UID) {
 c038a68:	ea52 0103 	orrs.w	r1, r2, r3
{
 c038a6c:	9e0c      	ldr	r6, [sp, #48]	@ 0x30
 c038a6e:	f8dd 9038 	ldr.w	r9, [sp, #56]	@ 0x38
    if (uid == TFM_ITS_INVALID_UID) {
 c038a72:	d03e      	beq.n	c038af2 <tfm_its_get+0x8e>
 c038a74:	4f20      	ldr	r7, [pc, #128]	@ (c038af8 <tfm_its_get+0x94>)

    /* Set file id */
    tfm_its_get_fid(client_id, uid, g_fid);

    /* Read file info */
    status = its_flash_fs_file_get_info(get_fs_ctx(client_id), g_fid,
 c038a76:	4c21      	ldr	r4, [pc, #132]	@ (c038afc <tfm_its_get+0x98>)
 c038a78:	607a      	str	r2, [r7, #4]
 c038a7a:	60bb      	str	r3, [r7, #8]
    return (client_id == TFM_SP_PS) ? &fs_ctx_ps : &fs_ctx_its;
 c038a7c:	4a20      	ldr	r2, [pc, #128]	@ (c038b00 <tfm_its_get+0x9c>)
 c038a7e:	4b21      	ldr	r3, [pc, #132]	@ (c038b04 <tfm_its_get+0xa0>)
 c038a80:	6038      	str	r0, [r7, #0]
 c038a82:	f5b0 7f80 	cmp.w	r0, #256	@ 0x100
 c038a86:	bf14      	ite	ne
 c038a88:	4690      	movne	r8, r2
 c038a8a:	4698      	moveq	r8, r3
    status = its_flash_fs_file_get_info(get_fs_ctx(client_id), g_fid,
 c038a8c:	4639      	mov	r1, r7
 c038a8e:	4622      	mov	r2, r4
 c038a90:	4640      	mov	r0, r8
 c038a92:	f000 f952 	bl	c038d3a <its_flash_fs_file_get_info>
                                        &g_file_info);
    if (status != PSA_SUCCESS) {
 c038a96:	4605      	mov	r5, r0
 c038a98:	b9f0      	cbnz	r0, c038ad8 <tfm_its_get+0x74>
        return status;
    }

    /* Boundary check the incoming request */
    if (data_offset > g_file_info.size_current) {
 c038a9a:	6824      	ldr	r4, [r4, #0]
 c038a9c:	42b4      	cmp	r4, r6
 c038a9e:	d328      	bcc.n	c038af2 <tfm_its_get+0x8e>
        return PSA_ERROR_INVALID_ARGUMENT;
    }

    /* Copy the object data only from within the file boundary */
    data_size = ITS_UTILS_MIN(data_size,
 c038aa0:	9b0d      	ldr	r3, [sp, #52]	@ 0x34
 c038aa2:	1ba4      	subs	r4, r4, r6
 c038aa4:	429c      	cmp	r4, r3
 c038aa6:	bf28      	it	cs
 c038aa8:	461c      	movcs	r4, r3
    do {
        /* Read as much of the data as will fit in the asset_data buffer */
        read_size = ITS_UTILS_MIN(data_size, sizeof(asset_data));

        /* Read file data from the filesystem */
        status = its_flash_fs_file_read(get_fs_ctx(client_id), g_fid, read_size,
 c038aaa:	f8df a05c 	ldr.w	sl, [pc, #92]	@ c038b08 <tfm_its_get+0xa4>
    *p_data_length = data_size;
 c038aae:	f8c9 4000 	str.w	r4, [r9]
        read_size = ITS_UTILS_MIN(data_size, sizeof(asset_data));
 c038ab2:	f5b4 6f00 	cmp.w	r4, #2048	@ 0x800
 c038ab6:	46a3      	mov	fp, r4
 c038ab8:	bf28      	it	cs
 c038aba:	f44f 6b00 	movcs.w	fp, #2048	@ 0x800
        status = its_flash_fs_file_read(get_fs_ctx(client_id), g_fid, read_size,
 c038abe:	4633      	mov	r3, r6
 c038ac0:	465a      	mov	r2, fp
 c038ac2:	4639      	mov	r1, r7
 c038ac4:	4640      	mov	r0, r8
 c038ac6:	f8cd a000 	str.w	sl, [sp]
 c038aca:	f000 fa5b 	bl	c038f84 <its_flash_fs_file_read>
                                        data_offset, asset_data);
        if (status != PSA_SUCCESS) {
 c038ace:	4605      	mov	r5, r0
 c038ad0:	b130      	cbz	r0, c038ae0 <tfm_its_get+0x7c>
            *p_data_length = 0;
 c038ad2:	2300      	movs	r3, #0
 c038ad4:	f8c9 3000 	str.w	r3, [r9]
        data_offset += read_size;
        data_size -= read_size;
    } while (data_size > 0);

    return PSA_SUCCESS;
}
 c038ad8:	4628      	mov	r0, r5
 c038ada:	b003      	add	sp, #12
 c038adc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        its_req_mngr_write(asset_data, read_size);
 c038ae0:	4659      	mov	r1, fp
 c038ae2:	4650      	mov	r0, sl
 c038ae4:	f000 ff5c 	bl	c0399a0 <its_req_mngr_write>
    } while (data_size > 0);
 c038ae8:	ebb4 040b 	subs.w	r4, r4, fp
        data_offset += read_size;
 c038aec:	445e      	add	r6, fp
    } while (data_size > 0);
 c038aee:	d1e0      	bne.n	c038ab2 <tfm_its_get+0x4e>
 c038af0:	e7f2      	b.n	c038ad8 <tfm_its_get+0x74>
        return PSA_ERROR_INVALID_ARGUMENT;
 c038af2:	f06f 0586 	mvn.w	r5, #134	@ 0x86
 c038af6:	e7ef      	b.n	c038ad8 <tfm_its_get+0x74>
 c038af8:	3003897c 	.word	0x3003897c
 c038afc:	30038970 	.word	0x30038970
 c038b00:	30038950 	.word	0x30038950
 c038b04:	30038930 	.word	0x30038930
 c038b08:	30038988 	.word	0x30038988

0c038b0c <tfm_its_get_info>:

psa_status_t tfm_its_get_info(int32_t client_id, psa_storage_uid_t uid,
                              struct psa_storage_info_t *p_info)
{
 c038b0c:	b570      	push	{r4, r5, r6, lr}
    psa_status_t status;

    /* Check that the UID is valid */
    if (uid == TFM_ITS_INVALID_UID) {
 c038b0e:	ea52 0103 	orrs.w	r1, r2, r3
{
 c038b12:	9c04      	ldr	r4, [sp, #16]
    if (uid == TFM_ITS_INVALID_UID) {
 c038b14:	d015      	beq.n	c038b42 <tfm_its_get_info+0x36>
 c038b16:	490c      	ldr	r1, [pc, #48]	@ (c038b48 <tfm_its_get_info+0x3c>)

    /* Set file id */
    tfm_its_get_fid(client_id, uid, g_fid);

    /* Read file info */
    status = its_flash_fs_file_get_info(get_fs_ctx(client_id), g_fid,
 c038b18:	4d0c      	ldr	r5, [pc, #48]	@ (c038b4c <tfm_its_get_info+0x40>)
 c038b1a:	4e0d      	ldr	r6, [pc, #52]	@ (c038b50 <tfm_its_get_info+0x44>)
 c038b1c:	608b      	str	r3, [r1, #8]
 c038b1e:	4b0d      	ldr	r3, [pc, #52]	@ (c038b54 <tfm_its_get_info+0x48>)
 c038b20:	6008      	str	r0, [r1, #0]
 c038b22:	604a      	str	r2, [r1, #4]
 c038b24:	f5b0 7f80 	cmp.w	r0, #256	@ 0x100
 c038b28:	bf14      	ite	ne
 c038b2a:	4630      	movne	r0, r6
 c038b2c:	4618      	moveq	r0, r3
 c038b2e:	462a      	mov	r2, r5
 c038b30:	f000 f903 	bl	c038d3a <its_flash_fs_file_get_info>
                                        &g_file_info);
    if (status != PSA_SUCCESS) {
 c038b34:	b920      	cbnz	r0, c038b40 <tfm_its_get_info+0x34>
        return status;
    }

    /* Copy file info to the PSA info struct */
    p_info->capacity = g_file_info.size_current;
 c038b36:	682b      	ldr	r3, [r5, #0]
    p_info->size = g_file_info.size_current;
 c038b38:	e9c4 3300 	strd	r3, r3, [r4]
    p_info->flags = g_file_info.flags;
 c038b3c:	68ab      	ldr	r3, [r5, #8]
 c038b3e:	60a3      	str	r3, [r4, #8]

    return PSA_SUCCESS;
}
 c038b40:	bd70      	pop	{r4, r5, r6, pc}
        return PSA_ERROR_INVALID_ARGUMENT;
 c038b42:	f06f 0086 	mvn.w	r0, #134	@ 0x86
 c038b46:	e7fb      	b.n	c038b40 <tfm_its_get_info+0x34>
 c038b48:	3003897c 	.word	0x3003897c
 c038b4c:	30038970 	.word	0x30038970
 c038b50:	30038950 	.word	0x30038950
 c038b54:	30038930 	.word	0x30038930

0c038b58 <tfm_its_remove>:
        client_id = TFM_SP_PS;
    }
#endif

    /* Check that the UID is valid */
    if (uid == TFM_ITS_INVALID_UID) {
 c038b58:	ea52 0103 	orrs.w	r1, r2, r3
{
 c038b5c:	b570      	push	{r4, r5, r6, lr}
    if (uid == TFM_ITS_INVALID_UID) {
 c038b5e:	d019      	beq.n	c038b94 <tfm_its_remove+0x3c>
 c038b60:	4c0f      	ldr	r4, [pc, #60]	@ (c038ba0 <tfm_its_remove+0x48>)
    return (client_id == TFM_SP_PS) ? &fs_ctx_ps : &fs_ctx_its;
 c038b62:	4d10      	ldr	r5, [pc, #64]	@ (c038ba4 <tfm_its_remove+0x4c>)
 c038b64:	60a3      	str	r3, [r4, #8]
 c038b66:	4b10      	ldr	r3, [pc, #64]	@ (c038ba8 <tfm_its_remove+0x50>)
    }

    /* Set file id */
    tfm_its_get_fid(client_id, uid, g_fid);

    status = its_flash_fs_file_get_info(get_fs_ctx(client_id), g_fid,
 c038b68:	4e10      	ldr	r6, [pc, #64]	@ (c038bac <tfm_its_remove+0x54>)
    return (client_id == TFM_SP_PS) ? &fs_ctx_ps : &fs_ctx_its;
 c038b6a:	f5b0 7f80 	cmp.w	r0, #256	@ 0x100
 c038b6e:	bf08      	it	eq
 c038b70:	461d      	moveq	r5, r3
 c038b72:	6020      	str	r0, [r4, #0]
 c038b74:	6062      	str	r2, [r4, #4]
    status = its_flash_fs_file_get_info(get_fs_ctx(client_id), g_fid,
 c038b76:	4621      	mov	r1, r4
 c038b78:	4632      	mov	r2, r6
 c038b7a:	4628      	mov	r0, r5
 c038b7c:	f000 f8dd 	bl	c038d3a <its_flash_fs_file_get_info>
                                        &g_file_info);
    if (status != PSA_SUCCESS) {
 c038b80:	b950      	cbnz	r0, c038b98 <tfm_its_remove+0x40>
    }

    /* If the object exists and has the write once flag set, then it
     * cannot be deleted.
     */
    if (g_file_info.flags & PSA_STORAGE_FLAG_WRITE_ONCE) {
 c038b82:	68b3      	ldr	r3, [r6, #8]
 c038b84:	07db      	lsls	r3, r3, #31
 c038b86:	d408      	bmi.n	c038b9a <tfm_its_remove+0x42>
        return PSA_ERROR_NOT_PERMITTED;
    }

    /* Delete old file from the persistent area */
    return its_flash_fs_file_delete(get_fs_ctx(client_id), g_fid);
 c038b88:	4621      	mov	r1, r4
 c038b8a:	4628      	mov	r0, r5
}
 c038b8c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    return its_flash_fs_file_delete(get_fs_ctx(client_id), g_fid);
 c038b90:	f000 b9e9 	b.w	c038f66 <its_flash_fs_file_delete>
        return PSA_ERROR_INVALID_ARGUMENT;
 c038b94:	f06f 0086 	mvn.w	r0, #134	@ 0x86
}
 c038b98:	bd70      	pop	{r4, r5, r6, pc}
        return PSA_ERROR_NOT_PERMITTED;
 c038b9a:	f06f 0084 	mvn.w	r0, #132	@ 0x84
 c038b9e:	e7fb      	b.n	c038b98 <tfm_its_remove+0x40>
 c038ba0:	3003897c 	.word	0x3003897c
 c038ba4:	30038950 	.word	0x30038950
 c038ba8:	30038930 	.word	0x30038930
 c038bac:	30038970 	.word	0x30038970

0c038bb0 <its_flash_fs_delete_idx>:
    return err;
}

static psa_status_t its_flash_fs_delete_idx(struct its_flash_fs_ctx_t *fs_ctx,
                                            uint32_t del_file_idx)
{
 c038bb0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    size_t del_file_data_idx;
    uint32_t del_file_lblock;
    size_t del_file_max_size;
    psa_status_t err;
    size_t src_offset = fs_ctx->cfg->block_size;
 c038bb4:	6803      	ldr	r3, [r0, #0]
{
 c038bb6:	b08b      	sub	sp, #44	@ 0x2c
    size_t nbr_bytes_to_move = 0;
    uint32_t idx;
    struct its_file_meta_t file_meta;

    err = its_flash_fs_mblock_read_file_meta(fs_ctx, del_file_idx, &file_meta);
 c038bb8:	aa02      	add	r2, sp, #8
{
 c038bba:	4604      	mov	r4, r0
 c038bbc:	460e      	mov	r6, r1
    size_t src_offset = fs_ctx->cfg->block_size;
 c038bbe:	895d      	ldrh	r5, [r3, #10]
    err = its_flash_fs_mblock_read_file_meta(fs_ctx, del_file_idx, &file_meta);
 c038bc0:	f000 fbab 	bl	c03931a <its_flash_fs_mblock_read_file_meta>
    if (err != PSA_SUCCESS) {
 c038bc4:	bb30      	cbnz	r0, c038c14 <its_flash_fs_delete_idx+0x64>
        return err;
    }

    if (its_utils_validate_fid(file_meta.id) != PSA_SUCCESS) {
 c038bc6:	a807      	add	r0, sp, #28
 c038bc8:	f000 fdf5 	bl	c0397b6 <its_utils_validate_fid>
 c038bcc:	4601      	mov	r1, r0
 c038bce:	2800      	cmp	r0, #0
 c038bd0:	d150      	bne.n	c038c74 <its_flash_fs_delete_idx+0xc4>
        return PSA_ERROR_DOES_NOT_EXIST;
    }

    /* Save logical block, data_index and max_size to be used later on */
    del_file_lblock = file_meta.lblock;
    del_file_data_idx = file_meta.data_idx;
 c038bd2:	e9dd 7a02 	ldrd	r7, sl, [sp, #8]
    del_file_max_size = file_meta.max_size;

    /* Remove file metadata */
    file_meta = (struct its_file_meta_t){0};
 c038bd6:	2220      	movs	r2, #32
 c038bd8:	a802      	add	r0, sp, #8
    del_file_max_size = file_meta.max_size;
 c038bda:	f8dd 9014 	ldr.w	r9, [sp, #20]
    file_meta = (struct its_file_meta_t){0};
 c038bde:	f022 fda6 	bl	c05b72e <memset>

    /* Update file metadata in to the scratch block */
    err = its_flash_fs_mblock_update_scratch_file_meta(fs_ctx, del_file_idx,
 c038be2:	4631      	mov	r1, r6
 c038be4:	4620      	mov	r0, r4
 c038be6:	aa02      	add	r2, sp, #8
 c038be8:	f000 fc5d 	bl	c0394a6 <its_flash_fs_mblock_update_scratch_file_meta>
                                                       &file_meta);
    if (err != PSA_SUCCESS) {
 c038bec:	b990      	cbnz	r0, c038c14 <its_flash_fs_delete_idx+0x64>
        return err;
    }

    /* Read all file metadata */
    for (idx = 0; idx < fs_ctx->cfg->max_num_files; idx++) {
 c038bee:	4683      	mov	fp, r0
    size_t nbr_bytes_to_move = 0;
 c038bf0:	4680      	mov	r8, r0
    for (idx = 0; idx < fs_ctx->cfg->max_num_files; idx++) {
 c038bf2:	6823      	ldr	r3, [r4, #0]
 c038bf4:	8a5b      	ldrh	r3, [r3, #18]
 c038bf6:	455b      	cmp	r3, fp
 c038bf8:	d80f      	bhi.n	c038c1a <its_flash_fs_delete_idx+0x6a>
            return err;
        }
    }

    /* Compact data block */
    err = its_flash_fs_dblock_compact_block(fs_ctx, del_file_lblock,
 c038bfa:	462b      	mov	r3, r5
 c038bfc:	464a      	mov	r2, r9
 c038bfe:	4639      	mov	r1, r7
 c038c00:	4620      	mov	r0, r4
 c038c02:	e9cd a800 	strd	sl, r8, [sp]
 c038c06:	f000 f9ed 	bl	c038fe4 <its_flash_fs_dblock_compact_block>
                                            del_file_max_size,
                                            src_offset, del_file_data_idx,
                                            nbr_bytes_to_move);
    if (err != PSA_SUCCESS) {
 c038c0a:	b918      	cbnz	r0, c038c14 <its_flash_fs_delete_idx+0x64>
     * metadata block needs to be copied in the scratch block, if the data
     * of the file processed is not located in the logical block 0. When an
     * file data is located in the logical block 0, that copy has been done
     * while processing the file data.
     */
    if (del_file_lblock != ITS_LOGICAL_DBLOCK0) {
 c038c0c:	bb57      	cbnz	r7, c038c64 <its_flash_fs_delete_idx+0xb4>
    }

    /* Update the metablock header, swap scratch and active blocks,
     * erase scratch blocks.
     */
    return its_flash_fs_mblock_meta_update_finalize(fs_ctx);
 c038c0e:	4620      	mov	r0, r4
 c038c10:	f000 fb6f 	bl	c0392f2 <its_flash_fs_mblock_meta_update_finalize>
}
 c038c14:	b00b      	add	sp, #44	@ 0x2c
 c038c16:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if (idx == del_file_idx) {
 c038c1a:	45b3      	cmp	fp, r6
 c038c1c:	d01f      	beq.n	c038c5e <its_flash_fs_delete_idx+0xae>
        err = its_flash_fs_mblock_read_file_meta(fs_ctx, idx, &file_meta);
 c038c1e:	4659      	mov	r1, fp
 c038c20:	4620      	mov	r0, r4
 c038c22:	aa02      	add	r2, sp, #8
 c038c24:	f000 fb79 	bl	c03931a <its_flash_fs_mblock_read_file_meta>
        if (err != PSA_SUCCESS) {
 c038c28:	2800      	cmp	r0, #0
 c038c2a:	d1f3      	bne.n	c038c14 <its_flash_fs_delete_idx+0x64>
        if ((file_meta.lblock == del_file_lblock) &&
 c038c2c:	9b02      	ldr	r3, [sp, #8]
 c038c2e:	42bb      	cmp	r3, r7
 c038c30:	d10e      	bne.n	c038c50 <its_flash_fs_delete_idx+0xa0>
            (its_utils_validate_fid(file_meta.id) == PSA_SUCCESS)) {
 c038c32:	a807      	add	r0, sp, #28
 c038c34:	f000 fdbf 	bl	c0397b6 <its_utils_validate_fid>
        if ((file_meta.lblock == del_file_lblock) &&
 c038c38:	b950      	cbnz	r0, c038c50 <its_flash_fs_delete_idx+0xa0>
            if (file_meta.data_idx > del_file_data_idx) {
 c038c3a:	9b03      	ldr	r3, [sp, #12]
 c038c3c:	4553      	cmp	r3, sl
 c038c3e:	d907      	bls.n	c038c50 <its_flash_fs_delete_idx+0xa0>
                if (src_offset > file_meta.data_idx) {
 c038c40:	429d      	cmp	r5, r3
 c038c42:	bf28      	it	cs
 c038c44:	461d      	movcs	r5, r3
                file_meta.data_idx -= del_file_max_size;
 c038c46:	eba3 0309 	sub.w	r3, r3, r9
 c038c4a:	9303      	str	r3, [sp, #12]
                nbr_bytes_to_move += file_meta.max_size;
 c038c4c:	9b05      	ldr	r3, [sp, #20]
 c038c4e:	4498      	add	r8, r3
        err = its_flash_fs_mblock_update_scratch_file_meta(fs_ctx, idx,
 c038c50:	4659      	mov	r1, fp
 c038c52:	4620      	mov	r0, r4
 c038c54:	aa02      	add	r2, sp, #8
 c038c56:	f000 fc26 	bl	c0394a6 <its_flash_fs_mblock_update_scratch_file_meta>
        if (err != PSA_SUCCESS) {
 c038c5a:	2800      	cmp	r0, #0
 c038c5c:	d1da      	bne.n	c038c14 <its_flash_fs_delete_idx+0x64>
    for (idx = 0; idx < fs_ctx->cfg->max_num_files; idx++) {
 c038c5e:	f10b 0b01 	add.w	fp, fp, #1
 c038c62:	e7c6      	b.n	c038bf2 <its_flash_fs_delete_idx+0x42>
        err = its_flash_fs_mblock_migrate_lb0_data_to_scratch(fs_ctx);
 c038c64:	4620      	mov	r0, r4
 c038c66:	f000 fcff 	bl	c039668 <its_flash_fs_mblock_migrate_lb0_data_to_scratch>
        if (err != PSA_SUCCESS) {
 c038c6a:	2800      	cmp	r0, #0
 c038c6c:	d0cf      	beq.n	c038c0e <its_flash_fs_delete_idx+0x5e>
            return PSA_ERROR_GENERIC_ERROR;
 c038c6e:	f06f 0083 	mvn.w	r0, #131	@ 0x83
 c038c72:	e7cf      	b.n	c038c14 <its_flash_fs_delete_idx+0x64>
        return PSA_ERROR_DOES_NOT_EXIST;
 c038c74:	f06f 008b 	mvn.w	r0, #139	@ 0x8b
 c038c78:	e7cc      	b.n	c038c14 <its_flash_fs_delete_idx+0x64>

0c038c7a <its_flash_fs_init_ctx>:
{
 c038c7a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 c038c7c:	460d      	mov	r5, r1
 c038c7e:	4617      	mov	r7, r2
    if (!fs_ctx || !fs_cfg || !fs_ops) {
 c038c80:	4606      	mov	r6, r0
 c038c82:	b378      	cbz	r0, c038ce4 <its_flash_fs_init_ctx+0x6a>
 c038c84:	b371      	cbz	r1, c038ce4 <its_flash_fs_init_ctx+0x6a>
 c038c86:	b36a      	cbz	r2, c038ce4 <its_flash_fs_init_ctx+0x6a>
    if ((cfg->num_blocks < 2) || (cfg->num_blocks == 3)) {
 c038c88:	898b      	ldrh	r3, [r1, #12]
        if (cfg->max_file_size >
 c038c8a:	8a0a      	ldrh	r2, [r1, #16]
    if ((cfg->num_blocks < 2) || (cfg->num_blocks == 3)) {
 c038c8c:	2b01      	cmp	r3, #1
                        cfg->block_size - its_flash_fs_all_metadata_size(cfg)) {
 c038c8e:	8949      	ldrh	r1, [r1, #10]
           + (cfg->max_num_files * sizeof(struct its_file_meta_t));
 c038c90:	8a68      	ldrh	r0, [r5, #18]
    if ((cfg->num_blocks < 2) || (cfg->num_blocks == 3)) {
 c038c92:	d922      	bls.n	c038cda <its_flash_fs_init_ctx+0x60>
 c038c94:	2b03      	cmp	r3, #3
 c038c96:	d028      	beq.n	c038cea <its_flash_fs_init_ctx+0x70>
    if (cfg->num_blocks == 2) {
 c038c98:	2b02      	cmp	r3, #2
 c038c9a:	d130      	bne.n	c038cfe <its_flash_fs_init_ctx+0x84>
           + (cfg->max_num_files * sizeof(struct its_file_meta_t));
 c038c9c:	1c43      	adds	r3, r0, #1
                        cfg->block_size - its_flash_fs_all_metadata_size(cfg)) {
 c038c9e:	eba1 1343 	sub.w	r3, r1, r3, lsl #5
    psa_status_t ret = PSA_SUCCESS;
 c038ca2:	429a      	cmp	r2, r3
 c038ca4:	bf8c      	ite	hi
 c038ca6:	f06f 0486 	mvnhi.w	r4, #134	@ 0x86
 c038caa:	2400      	movls	r4, #0
        return 1;
 c038cac:	428a      	cmp	r2, r1
 c038cae:	f04f 0301 	mov.w	r3, #1
 c038cb2:	bf88      	it	hi
 c038cb4:	f06f 0486 	mvnhi.w	r4, #134	@ 0x86
           + (cfg->max_num_files * sizeof(struct its_file_meta_t));
 c038cb8:	eb03 0340 	add.w	r3, r3, r0, lsl #1
 c038cbc:	3301      	adds	r3, #1
    if (its_flash_fs_all_metadata_size(cfg) > cfg->block_size) {
 c038cbe:	ebb1 1f03 	cmp.w	r1, r3, lsl #4
 c038cc2:	d30f      	bcc.n	c038ce4 <its_flash_fs_init_ctx+0x6a>
    if (err != PSA_SUCCESS) {
 c038cc4:	b974      	cbnz	r4, c038ce4 <its_flash_fs_init_ctx+0x6a>
}

__attribute__ ((always_inline)) __STATIC_INLINE
void *tfm_memset(void *ptr, int value, size_t num)
{
    return (memset(ptr, value, num));
 c038cc6:	2218      	movs	r2, #24
 c038cc8:	4621      	mov	r1, r4
 c038cca:	f106 0008 	add.w	r0, r6, #8
 c038cce:	f022 fd2e 	bl	c05b72e <memset>
    fs_ctx->ops = fs_ops;
 c038cd2:	e9c6 5700 	strd	r5, r7, [r6]
}
 c038cd6:	4620      	mov	r0, r4
 c038cd8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        ret = PSA_ERROR_INVALID_ARGUMENT;
 c038cda:	f06f 0486 	mvn.w	r4, #134	@ 0x86
 c038cde:	e00c      	b.n	c038cfa <its_flash_fs_init_ctx+0x80>
        return 1;
 c038ce0:	2301      	movs	r3, #1
 c038ce2:	e7e9      	b.n	c038cb8 <its_flash_fs_init_ctx+0x3e>
        return PSA_ERROR_INVALID_ARGUMENT;
 c038ce4:	f06f 0486 	mvn.w	r4, #134	@ 0x86
 c038ce8:	e7f5      	b.n	c038cd6 <its_flash_fs_init_ctx+0x5c>
            ret = PSA_ERROR_INVALID_ARGUMENT;
 c038cea:	f06f 0486 	mvn.w	r4, #134	@ 0x86
    if (cfg->max_file_size > cfg->block_size) {
 c038cee:	428a      	cmp	r2, r1
 c038cf0:	d903      	bls.n	c038cfa <its_flash_fs_init_ctx+0x80>
    if (cfg->num_blocks == 2) {
 c038cf2:	2b02      	cmp	r3, #2
        ret = PSA_ERROR_INVALID_ARGUMENT;
 c038cf4:	f06f 0486 	mvn.w	r4, #134	@ 0x86
    if (cfg->num_blocks == 2) {
 c038cf8:	d0f2      	beq.n	c038ce0 <its_flash_fs_init_ctx+0x66>
        return cfg->num_blocks - 2;
 c038cfa:	3b02      	subs	r3, #2
 c038cfc:	e7dc      	b.n	c038cb8 <its_flash_fs_init_ctx+0x3e>
    psa_status_t ret = PSA_SUCCESS;
 c038cfe:	2400      	movs	r4, #0
 c038d00:	e7f5      	b.n	c038cee <its_flash_fs_init_ctx+0x74>

0c038d02 <its_flash_fs_prepare>:
{
 c038d02:	b537      	push	{r0, r1, r2, r4, r5, lr}
 c038d04:	4605      	mov	r5, r0
    err = its_flash_fs_mblock_init(fs_ctx);
 c038d06:	f000 facb 	bl	c0392a0 <its_flash_fs_mblock_init>
    if (err != PSA_SUCCESS) {
 c038d0a:	4604      	mov	r4, r0
 c038d0c:	b958      	cbnz	r0, c038d26 <its_flash_fs_prepare+0x24>
    err = its_flash_fs_mblock_get_file_idx_flag(fs_ctx,
 c038d0e:	f04f 7180 	mov.w	r1, #16777216	@ 0x1000000
 c038d12:	4628      	mov	r0, r5
 c038d14:	aa01      	add	r2, sp, #4
 c038d16:	f000 fb31 	bl	c03937c <its_flash_fs_mblock_get_file_idx_flag>
    if (err == PSA_SUCCESS) {
 c038d1a:	b938      	cbnz	r0, c038d2c <its_flash_fs_prepare+0x2a>
        return its_flash_fs_delete_idx(fs_ctx, idx);
 c038d1c:	4628      	mov	r0, r5
 c038d1e:	9901      	ldr	r1, [sp, #4]
 c038d20:	f7ff ff46 	bl	c038bb0 <its_flash_fs_delete_idx>
 c038d24:	4604      	mov	r4, r0
}
 c038d26:	4620      	mov	r0, r4
 c038d28:	b003      	add	sp, #12
 c038d2a:	bd30      	pop	{r4, r5, pc}
    } else if (err != PSA_ERROR_DOES_NOT_EXIST) {
 c038d2c:	f110 0f8c 	cmn.w	r0, #140	@ 0x8c
 c038d30:	bf18      	it	ne
 c038d32:	4604      	movne	r4, r0
 c038d34:	e7f7      	b.n	c038d26 <its_flash_fs_prepare+0x24>

0c038d36 <its_flash_fs_wipe_all>:
    return its_flash_fs_mblock_reset_metablock(fs_ctx);
 c038d36:	f000 bbc6 	b.w	c0394c6 <its_flash_fs_mblock_reset_metablock>

0c038d3a <its_flash_fs_file_get_info>:
{
 c038d3a:	b570      	push	{r4, r5, r6, lr}
 c038d3c:	b08a      	sub	sp, #40	@ 0x28
 c038d3e:	4614      	mov	r4, r2
    err = its_flash_fs_mblock_get_file_idx(fs_ctx, fid, &idx);
 c038d40:	aa01      	add	r2, sp, #4
{
 c038d42:	4606      	mov	r6, r0
 c038d44:	460d      	mov	r5, r1
    err = its_flash_fs_mblock_get_file_idx(fs_ctx, fid, &idx);
 c038d46:	f000 faf8 	bl	c03933a <its_flash_fs_mblock_get_file_idx>
    if (err != PSA_SUCCESS) {
 c038d4a:	b118      	cbz	r0, c038d54 <its_flash_fs_file_get_info+0x1a>
        return PSA_ERROR_DOES_NOT_EXIST;
 c038d4c:	f06f 008b 	mvn.w	r0, #139	@ 0x8b
}
 c038d50:	b00a      	add	sp, #40	@ 0x28
 c038d52:	bd70      	pop	{r4, r5, r6, pc}
    err = its_flash_fs_mblock_read_file_meta(fs_ctx, idx, &tmp_metadata);
 c038d54:	4630      	mov	r0, r6
 c038d56:	9901      	ldr	r1, [sp, #4]
 c038d58:	aa02      	add	r2, sp, #8
 c038d5a:	f000 fade 	bl	c03931a <its_flash_fs_mblock_read_file_meta>
    if (err != PSA_SUCCESS) {
 c038d5e:	2800      	cmp	r0, #0
 c038d60:	d1f6      	bne.n	c038d50 <its_flash_fs_file_get_info+0x16>
    return (memcmp(ptr1, ptr2, num));
 c038d62:	220c      	movs	r2, #12
 c038d64:	4628      	mov	r0, r5
 c038d66:	a907      	add	r1, sp, #28
 c038d68:	f022 fc60 	bl	c05b62c <memcmp>
    if (tfm_memcmp(fid, tmp_metadata.id, ITS_FILE_ID_SIZE)) {
 c038d6c:	2800      	cmp	r0, #0
 c038d6e:	d1ed      	bne.n	c038d4c <its_flash_fs_file_get_info+0x12>
    info->size_max = tmp_metadata.max_size;
 c038d70:	9b05      	ldr	r3, [sp, #20]
 c038d72:	6063      	str	r3, [r4, #4]
    info->size_current = tmp_metadata.cur_size;
 c038d74:	9b04      	ldr	r3, [sp, #16]
 c038d76:	6023      	str	r3, [r4, #0]
    info->flags = tmp_metadata.flags & ITS_FLASH_FS_USER_FLAGS_MASK;
 c038d78:	f8bd 3018 	ldrh.w	r3, [sp, #24]
 c038d7c:	60a3      	str	r3, [r4, #8]
    return PSA_SUCCESS;
 c038d7e:	e7e7      	b.n	c038d50 <its_flash_fs_file_get_info+0x16>

0c038d80 <its_flash_fs_file_write>:
{
 c038d80:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 c038d84:	4690      	mov	r8, r2
    uint32_t old_idx = ITS_METADATA_INVALID_INDEX;
 c038d86:	f64f 72ff 	movw	r2, #65535	@ 0xffff
{
 c038d8a:	b093      	sub	sp, #76	@ 0x4c
    if (flags & ITS_FLASH_FS_INTERNAL_FLAGS_MASK) {
 c038d8c:	f1b8 7f80 	cmp.w	r8, #16777216	@ 0x1000000
{
 c038d90:	4604      	mov	r4, r0
 c038d92:	e9dd 651a 	ldrd	r6, r5, [sp, #104]	@ 0x68
 c038d96:	4689      	mov	r9, r1
    uint32_t new_idx = ITS_METADATA_INVALID_INDEX;
 c038d98:	e9cd 2204 	strd	r2, r2, [sp, #16]
    if (flags & ITS_FLASH_FS_INTERNAL_FLAGS_MASK) {
 c038d9c:	d304      	bcc.n	c038da8 <its_flash_fs_file_write+0x28>
        return PSA_ERROR_INVALID_ARGUMENT;
 c038d9e:	f06f 0086 	mvn.w	r0, #134	@ 0x86
}
 c038da2:	b013      	add	sp, #76	@ 0x4c
 c038da4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    max_size = ITS_UTILS_ALIGN(max_size, fs_ctx->cfg->program_unit);
 c038da8:	6802      	ldr	r2, [r0, #0]
 c038daa:	3b01      	subs	r3, #1
 c038dac:	89d7      	ldrh	r7, [r2, #14]
    err = its_flash_fs_mblock_get_file_idx(fs_ctx, fid, &old_idx);
 c038dae:	aa04      	add	r2, sp, #16
    max_size = ITS_UTILS_ALIGN(max_size, fs_ctx->cfg->program_unit);
 c038db0:	443b      	add	r3, r7
 c038db2:	427f      	negs	r7, r7
 c038db4:	401f      	ands	r7, r3
    err = its_flash_fs_mblock_get_file_idx(fs_ctx, fid, &old_idx);
 c038db6:	f000 fac0 	bl	c03933a <its_flash_fs_mblock_get_file_idx>
    if (err == PSA_SUCCESS) {
 c038dba:	2800      	cmp	r0, #0
 c038dbc:	f040 808d 	bne.w	c038eda <its_flash_fs_file_write+0x15a>
        err = its_flash_fs_mblock_read_file_meta(fs_ctx, old_idx, &file_meta);
 c038dc0:	4620      	mov	r0, r4
 c038dc2:	9904      	ldr	r1, [sp, #16]
 c038dc4:	aa0a      	add	r2, sp, #40	@ 0x28
 c038dc6:	f000 faa8 	bl	c03931a <its_flash_fs_mblock_read_file_meta>
        if (err != PSA_SUCCESS) {
 c038dca:	b110      	cbz	r0, c038dd2 <its_flash_fs_file_write+0x52>
            return PSA_ERROR_DOES_NOT_EXIST;
 c038dcc:	f06f 008b 	mvn.w	r0, #139	@ 0x8b
 c038dd0:	e7e7      	b.n	c038da2 <its_flash_fs_file_write+0x22>
        if (flags & ITS_FLASH_FS_FLAG_TRUNCATE) {
 c038dd2:	f418 3f00 	tst.w	r8, #131072	@ 0x20000
                new_idx = old_idx;
 c038dd6:	9904      	ldr	r1, [sp, #16]
        if (flags & ITS_FLASH_FS_FLAG_TRUNCATE) {
 c038dd8:	d005      	beq.n	c038de6 <its_flash_fs_file_write+0x66>
            if (file_meta.max_size == max_size) {
 c038dda:	9b0d      	ldr	r3, [sp, #52]	@ 0x34
 c038ddc:	42bb      	cmp	r3, r7
 c038dde:	d16f      	bne.n	c038ec0 <its_flash_fs_file_write+0x140>
                file_meta.cur_size = 0;
 c038de0:	900c      	str	r0, [sp, #48]	@ 0x30
                file_meta.flags = flags;
 c038de2:	f8cd 8038 	str.w	r8, [sp, #56]	@ 0x38
            new_idx = old_idx;
 c038de6:	9105      	str	r1, [sp, #20]
    if (new_idx == ITS_METADATA_INVALID_INDEX) {
 c038de8:	f64f 73ff 	movw	r3, #65535	@ 0xffff
 c038dec:	9a05      	ldr	r2, [sp, #20]
 c038dee:	429a      	cmp	r2, r3
 c038df0:	d17c      	bne.n	c038eec <its_flash_fs_file_write+0x16c>
        if (max_size > fs_ctx->cfg->max_file_size) {
 c038df2:	6823      	ldr	r3, [r4, #0]
 c038df4:	8a1b      	ldrh	r3, [r3, #16]
 c038df6:	42bb      	cmp	r3, r7
 c038df8:	d3d1      	bcc.n	c038d9e <its_flash_fs_file_write+0x1e>
        err = its_flash_fs_mblock_reserve_file(fs_ctx, fid, use_spare,
 c038dfa:	9904      	ldr	r1, [sp, #16]
 c038dfc:	ab06      	add	r3, sp, #24
 c038dfe:	9303      	str	r3, [sp, #12]
 c038e00:	ab0a      	add	r3, sp, #40	@ 0x28
 c038e02:	1a8a      	subs	r2, r1, r2
 c038e04:	9302      	str	r3, [sp, #8]
 c038e06:	ab05      	add	r3, sp, #20
 c038e08:	bf18      	it	ne
 c038e0a:	2201      	movne	r2, #1
 c038e0c:	e9cd 8300 	strd	r8, r3, [sp]
 c038e10:	4649      	mov	r1, r9
 c038e12:	463b      	mov	r3, r7
 c038e14:	4620      	mov	r0, r4
 c038e16:	f000 fadb 	bl	c0393d0 <its_flash_fs_mblock_reserve_file>
        if (err != PSA_SUCCESS) {
 c038e1a:	2800      	cmp	r0, #0
 c038e1c:	d1c1      	bne.n	c038da2 <its_flash_fs_file_write+0x22>
    if (data_size != 0) {
 c038e1e:	2e00      	cmp	r6, #0
 c038e20:	d16c      	bne.n	c038efc <its_flash_fs_file_write+0x17c>
    err = its_flash_fs_mblock_update_scratch_block_meta(fs_ctx,
 c038e22:	4620      	mov	r0, r4
 c038e24:	990a      	ldr	r1, [sp, #40]	@ 0x28
 c038e26:	aa06      	add	r2, sp, #24
 c038e28:	f000 fc35 	bl	c039696 <its_flash_fs_mblock_update_scratch_block_meta>
    if (err != PSA_SUCCESS) {
 c038e2c:	2800      	cmp	r0, #0
 c038e2e:	d151      	bne.n	c038ed4 <its_flash_fs_file_write+0x154>
    err = its_flash_fs_mblock_update_scratch_file_meta(fs_ctx, new_idx,
 c038e30:	9905      	ldr	r1, [sp, #20]
 c038e32:	4620      	mov	r0, r4
 c038e34:	aa0a      	add	r2, sp, #40	@ 0x28
 c038e36:	f000 fb36 	bl	c0394a6 <its_flash_fs_mblock_update_scratch_file_meta>
    if (err != PSA_SUCCESS) {
 c038e3a:	4601      	mov	r1, r0
 c038e3c:	2800      	cmp	r0, #0
 c038e3e:	d149      	bne.n	c038ed4 <its_flash_fs_file_write+0x154>
    idx = ITS_UTILS_MIN(new_idx, old_idx);
 c038e40:	e9dd 5304 	ldrd	r5, r3, [sp, #16]
 c038e44:	429d      	cmp	r5, r3
 c038e46:	bf28      	it	cs
 c038e48:	461d      	movcs	r5, r3
    err = its_flash_fs_mblock_cp_file_meta(fs_ctx, 0, idx);
 c038e4a:	4620      	mov	r0, r4
 c038e4c:	462a      	mov	r2, r5
 c038e4e:	f000 fbf5 	bl	c03963c <its_flash_fs_mblock_cp_file_meta>
    if (err != PSA_SUCCESS) {
 c038e52:	2800      	cmp	r0, #0
 c038e54:	d13e      	bne.n	c038ed4 <its_flash_fs_file_write+0x154>
    if (old_idx != ITS_METADATA_INVALID_INDEX && old_idx != new_idx) {
 c038e56:	f64f 72ff 	movw	r2, #65535	@ 0xffff
 c038e5a:	9b04      	ldr	r3, [sp, #16]
 c038e5c:	4293      	cmp	r3, r2
 c038e5e:	d00f      	beq.n	c038e80 <its_flash_fs_file_write+0x100>
 c038e60:	9a05      	ldr	r2, [sp, #20]
 c038e62:	4293      	cmp	r3, r2
 c038e64:	d00c      	beq.n	c038e80 <its_flash_fs_file_write+0x100>
        err = its_flash_fs_mblock_cp_file_meta(fs_ctx, idx + 1,
 c038e66:	429a      	cmp	r2, r3
 c038e68:	bf38      	it	cc
 c038e6a:	461a      	movcc	r2, r3
 c038e6c:	4620      	mov	r0, r4
 c038e6e:	1c69      	adds	r1, r5, #1
 c038e70:	f000 fbe4 	bl	c03963c <its_flash_fs_mblock_cp_file_meta>
        if (err != PSA_SUCCESS) {
 c038e74:	bb70      	cbnz	r0, c038ed4 <its_flash_fs_file_write+0x154>
        idx = ITS_UTILS_MAX(new_idx, old_idx);
 c038e76:	e9dd 5304 	ldrd	r5, r3, [sp, #16]
 c038e7a:	429d      	cmp	r5, r3
 c038e7c:	bf38      	it	cc
 c038e7e:	461d      	movcc	r5, r3
                                           fs_ctx->cfg->max_num_files);
 c038e80:	6823      	ldr	r3, [r4, #0]
    err = its_flash_fs_mblock_cp_file_meta(fs_ctx, idx + 1,
 c038e82:	4620      	mov	r0, r4
 c038e84:	8a5a      	ldrh	r2, [r3, #18]
 c038e86:	1c69      	adds	r1, r5, #1
 c038e88:	f000 fbd8 	bl	c03963c <its_flash_fs_mblock_cp_file_meta>
    if (err != PSA_SUCCESS) {
 c038e8c:	bb10      	cbnz	r0, c038ed4 <its_flash_fs_file_write+0x154>
    if ((file_meta.lblock != ITS_LOGICAL_DBLOCK0) || (data_size == 0)) {
 c038e8e:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 c038e90:	2b00      	cmp	r3, #0
 c038e92:	d162      	bne.n	c038f5a <its_flash_fs_file_write+0x1da>
 c038e94:	2e00      	cmp	r6, #0
 c038e96:	d060      	beq.n	c038f5a <its_flash_fs_file_write+0x1da>
    err = its_flash_fs_mblock_meta_update_finalize(fs_ctx);
 c038e98:	4620      	mov	r0, r4
 c038e9a:	f000 fa2a 	bl	c0392f2 <its_flash_fs_mblock_meta_update_finalize>
    if (err != PSA_SUCCESS) {
 c038e9e:	2800      	cmp	r0, #0
 c038ea0:	f47f af7f 	bne.w	c038da2 <its_flash_fs_file_write+0x22>
    if (old_idx != ITS_METADATA_INVALID_INDEX && old_idx != new_idx) {
 c038ea4:	f64f 73ff 	movw	r3, #65535	@ 0xffff
 c038ea8:	9904      	ldr	r1, [sp, #16]
 c038eaa:	4299      	cmp	r1, r3
 c038eac:	f43f af79 	beq.w	c038da2 <its_flash_fs_file_write+0x22>
 c038eb0:	9b05      	ldr	r3, [sp, #20]
 c038eb2:	4299      	cmp	r1, r3
 c038eb4:	f43f af75 	beq.w	c038da2 <its_flash_fs_file_write+0x22>
        err = its_flash_fs_delete_idx(fs_ctx, old_idx);
 c038eb8:	4620      	mov	r0, r4
 c038eba:	f7ff fe79 	bl	c038bb0 <its_flash_fs_delete_idx>
 c038ebe:	e770      	b.n	c038da2 <its_flash_fs_file_write+0x22>
                file_meta.flags |= ITS_FLASH_FS_FLAG_DELETE;
 c038ec0:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
                err = its_flash_fs_mblock_update_scratch_file_meta(fs_ctx,
 c038ec2:	4620      	mov	r0, r4
                file_meta.flags |= ITS_FLASH_FS_FLAG_DELETE;
 c038ec4:	f043 7380 	orr.w	r3, r3, #16777216	@ 0x1000000
                err = its_flash_fs_mblock_update_scratch_file_meta(fs_ctx,
 c038ec8:	aa0a      	add	r2, sp, #40	@ 0x28
                file_meta.flags |= ITS_FLASH_FS_FLAG_DELETE;
 c038eca:	930e      	str	r3, [sp, #56]	@ 0x38
                err = its_flash_fs_mblock_update_scratch_file_meta(fs_ctx,
 c038ecc:	f000 faeb 	bl	c0394a6 <its_flash_fs_mblock_update_scratch_file_meta>
                if (err != PSA_SUCCESS) {
 c038ed0:	2800      	cmp	r0, #0
 c038ed2:	d089      	beq.n	c038de8 <its_flash_fs_file_write+0x68>
                    return PSA_ERROR_GENERIC_ERROR;
 c038ed4:	f06f 0083 	mvn.w	r0, #131	@ 0x83
 c038ed8:	e763      	b.n	c038da2 <its_flash_fs_file_write+0x22>
    } else if (err == PSA_ERROR_DOES_NOT_EXIST) {
 c038eda:	f110 0f8c 	cmn.w	r0, #140	@ 0x8c
 c038ede:	f47f af60 	bne.w	c038da2 <its_flash_fs_file_write+0x22>
        if (!(flags & ITS_FLASH_FS_FLAG_CREATE)) {
 c038ee2:	f418 3f80 	tst.w	r8, #65536	@ 0x10000
 c038ee6:	f47f af7f 	bne.w	c038de8 <its_flash_fs_file_write+0x68>
 c038eea:	e76f      	b.n	c038dcc <its_flash_fs_file_write+0x4c>
        err = its_flash_fs_mblock_read_block_metadata(fs_ctx, file_meta.lblock,
 c038eec:	4620      	mov	r0, r4
 c038eee:	990a      	ldr	r1, [sp, #40]	@ 0x28
 c038ef0:	aa06      	add	r2, sp, #24
 c038ef2:	f000 fa61 	bl	c0393b8 <its_flash_fs_mblock_read_block_metadata>
        if (err != PSA_SUCCESS) {
 c038ef6:	2800      	cmp	r0, #0
 c038ef8:	d091      	beq.n	c038e1e <its_flash_fs_file_write+0x9e>
 c038efa:	e7eb      	b.n	c038ed4 <its_flash_fs_file_write+0x154>
    if (!ITS_UTILS_IS_ALIGNED(offset, fs_ctx->cfg->program_unit)) {
 c038efc:	6823      	ldr	r3, [r4, #0]
 c038efe:	89db      	ldrh	r3, [r3, #14]
 c038f00:	1e5a      	subs	r2, r3, #1
 c038f02:	422a      	tst	r2, r5
 c038f04:	d1e6      	bne.n	c038ed4 <its_flash_fs_file_write+0x154>
    size = ITS_UTILS_ALIGN(size, fs_ctx->cfg->program_unit);
 c038f06:	1e77      	subs	r7, r6, #1
 c038f08:	441f      	add	r7, r3
 c038f0a:	425b      	negs	r3, r3
 c038f0c:	401f      	ands	r7, r3
    if (offset > file_meta->cur_size) {
 c038f0e:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
 c038f10:	429d      	cmp	r5, r3
 c038f12:	d8df      	bhi.n	c038ed4 <its_flash_fs_file_write+0x154>
    if (its_utils_check_contained_in(file_meta->max_size, offset, size)
 c038f14:	463a      	mov	r2, r7
 c038f16:	4629      	mov	r1, r5
 c038f18:	980d      	ldr	r0, [sp, #52]	@ 0x34
 c038f1a:	f000 fc40 	bl	c03979e <its_utils_check_contained_in>
 c038f1e:	2800      	cmp	r0, #0
 c038f20:	d1d8      	bne.n	c038ed4 <its_flash_fs_file_write+0x154>
    return its_flash_fs_dblock_write_file(fs_ctx, block_meta, file_meta, offset,
 c038f22:	9b1c      	ldr	r3, [sp, #112]	@ 0x70
 c038f24:	4620      	mov	r0, r4
 c038f26:	e9cd 7300 	strd	r7, r3, [sp]
 c038f2a:	aa0a      	add	r2, sp, #40	@ 0x28
 c038f2c:	462b      	mov	r3, r5
 c038f2e:	a906      	add	r1, sp, #24
 c038f30:	f000 f8cc 	bl	c0390cc <its_flash_fs_dblock_write_file>
        if (err != PSA_SUCCESS) {
 c038f34:	2800      	cmp	r0, #0
 c038f36:	d1cd      	bne.n	c038ed4 <its_flash_fs_file_write+0x154>
        if (offset + data_size > file_meta.cur_size) {
 c038f38:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
 c038f3a:	4435      	add	r5, r6
 c038f3c:	429d      	cmp	r5, r3
            its_flash_fs_mblock_cur_data_scratch_id(fs_ctx, file_meta.lblock);
 c038f3e:	990a      	ldr	r1, [sp, #40]	@ 0x28
 c038f40:	4620      	mov	r0, r4
            file_meta.cur_size = offset + data_size;
 c038f42:	bf88      	it	hi
 c038f44:	950c      	strhi	r5, [sp, #48]	@ 0x30
        cur_phys_block = block_meta.phy_id;
 c038f46:	9d06      	ldr	r5, [sp, #24]
            its_flash_fs_mblock_cur_data_scratch_id(fs_ctx, file_meta.lblock);
 c038f48:	f000 f9a5 	bl	c039296 <its_flash_fs_mblock_cur_data_scratch_id>
        its_flash_fs_mblock_set_data_scratch(fs_ctx, cur_phys_block,
 c038f4c:	4629      	mov	r1, r5
        block_meta.phy_id =
 c038f4e:	9006      	str	r0, [sp, #24]
        its_flash_fs_mblock_set_data_scratch(fs_ctx, cur_phys_block,
 c038f50:	9a0a      	ldr	r2, [sp, #40]	@ 0x28
 c038f52:	4620      	mov	r0, r4
 c038f54:	f000 faa4 	bl	c0394a0 <its_flash_fs_mblock_set_data_scratch>
 c038f58:	e763      	b.n	c038e22 <its_flash_fs_file_write+0xa2>
        err = its_flash_fs_mblock_migrate_lb0_data_to_scratch(fs_ctx);
 c038f5a:	4620      	mov	r0, r4
 c038f5c:	f000 fb84 	bl	c039668 <its_flash_fs_mblock_migrate_lb0_data_to_scratch>
        if (err != PSA_SUCCESS) {
 c038f60:	2800      	cmp	r0, #0
 c038f62:	d099      	beq.n	c038e98 <its_flash_fs_file_write+0x118>
 c038f64:	e7b6      	b.n	c038ed4 <its_flash_fs_file_write+0x154>

0c038f66 <its_flash_fs_file_delete>:

psa_status_t its_flash_fs_file_delete(struct its_flash_fs_ctx_t *fs_ctx,
                                      const uint8_t *fid)
{
 c038f66:	b513      	push	{r0, r1, r4, lr}
    psa_status_t err;
    uint32_t del_file_idx;

    /* Get the file index */
    err = its_flash_fs_mblock_get_file_idx(fs_ctx, fid, &del_file_idx);
 c038f68:	aa01      	add	r2, sp, #4
{
 c038f6a:	4604      	mov	r4, r0
    err = its_flash_fs_mblock_get_file_idx(fs_ctx, fid, &del_file_idx);
 c038f6c:	f000 f9e5 	bl	c03933a <its_flash_fs_mblock_get_file_idx>
    if (err != PSA_SUCCESS) {
 c038f70:	b928      	cbnz	r0, c038f7e <its_flash_fs_file_delete+0x18>
        return PSA_ERROR_DOES_NOT_EXIST;
    }

    return its_flash_fs_delete_idx(fs_ctx, del_file_idx);
 c038f72:	4620      	mov	r0, r4
 c038f74:	9901      	ldr	r1, [sp, #4]
 c038f76:	f7ff fe1b 	bl	c038bb0 <its_flash_fs_delete_idx>
}
 c038f7a:	b002      	add	sp, #8
 c038f7c:	bd10      	pop	{r4, pc}
        return PSA_ERROR_DOES_NOT_EXIST;
 c038f7e:	f06f 008b 	mvn.w	r0, #139	@ 0x8b
 c038f82:	e7fa      	b.n	c038f7a <its_flash_fs_file_delete+0x14>

0c038f84 <its_flash_fs_file_read>:
psa_status_t its_flash_fs_file_read(struct its_flash_fs_ctx_t *fs_ctx,
                                    const uint8_t *fid,
                                    size_t size,
                                    size_t offset,
                                    uint8_t *data)
{
 c038f84:	b5f0      	push	{r4, r5, r6, r7, lr}
 c038f86:	b08d      	sub	sp, #52	@ 0x34
 c038f88:	4616      	mov	r6, r2
    psa_status_t err;
    uint32_t idx;
    struct its_file_meta_t tmp_metadata;

    /* Get the file index */
    err = its_flash_fs_mblock_get_file_idx(fs_ctx, fid, &idx);
 c038f8a:	aa03      	add	r2, sp, #12
{
 c038f8c:	4604      	mov	r4, r0
 c038f8e:	460f      	mov	r7, r1
 c038f90:	461d      	mov	r5, r3
    err = its_flash_fs_mblock_get_file_idx(fs_ctx, fid, &idx);
 c038f92:	f000 f9d2 	bl	c03933a <its_flash_fs_mblock_get_file_idx>
    if (err != PSA_SUCCESS) {
 c038f96:	b118      	cbz	r0, c038fa0 <its_flash_fs_file_read+0x1c>
        return PSA_ERROR_DOES_NOT_EXIST;
 c038f98:	f06f 008b 	mvn.w	r0, #139	@ 0x8b
    if (err != PSA_SUCCESS) {
        return PSA_ERROR_GENERIC_ERROR;
    }

    return PSA_SUCCESS;
}
 c038f9c:	b00d      	add	sp, #52	@ 0x34
 c038f9e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    err = its_flash_fs_mblock_read_file_meta(fs_ctx, idx, &tmp_metadata);
 c038fa0:	4620      	mov	r0, r4
 c038fa2:	9903      	ldr	r1, [sp, #12]
 c038fa4:	aa04      	add	r2, sp, #16
 c038fa6:	f000 f9b8 	bl	c03931a <its_flash_fs_mblock_read_file_meta>
    if (err != PSA_SUCCESS) {
 c038faa:	b110      	cbz	r0, c038fb2 <its_flash_fs_file_read+0x2e>
        return PSA_ERROR_GENERIC_ERROR;
 c038fac:	f06f 0083 	mvn.w	r0, #131	@ 0x83
 c038fb0:	e7f4      	b.n	c038f9c <its_flash_fs_file_read+0x18>
 c038fb2:	220c      	movs	r2, #12
 c038fb4:	4638      	mov	r0, r7
 c038fb6:	a909      	add	r1, sp, #36	@ 0x24
 c038fb8:	f022 fb38 	bl	c05b62c <memcmp>
    if (tfm_memcmp(fid, tmp_metadata.id, ITS_FILE_ID_SIZE)) {
 c038fbc:	2800      	cmp	r0, #0
 c038fbe:	d1eb      	bne.n	c038f98 <its_flash_fs_file_read+0x14>
    err = its_utils_check_contained_in(tmp_metadata.cur_size, offset, size);
 c038fc0:	4632      	mov	r2, r6
 c038fc2:	4629      	mov	r1, r5
 c038fc4:	9806      	ldr	r0, [sp, #24]
 c038fc6:	f000 fbea 	bl	c03979e <its_utils_check_contained_in>
    if (err != PSA_SUCCESS) {
 c038fca:	2800      	cmp	r0, #0
 c038fcc:	d1e6      	bne.n	c038f9c <its_flash_fs_file_read+0x18>
    err = its_flash_fs_dblock_read_file(fs_ctx, &tmp_metadata, offset, size,
 c038fce:	9b12      	ldr	r3, [sp, #72]	@ 0x48
 c038fd0:	462a      	mov	r2, r5
 c038fd2:	9300      	str	r3, [sp, #0]
 c038fd4:	4620      	mov	r0, r4
 c038fd6:	4633      	mov	r3, r6
 c038fd8:	a904      	add	r1, sp, #16
 c038fda:	f000 f856 	bl	c03908a <its_flash_fs_dblock_read_file>
    if (err != PSA_SUCCESS) {
 c038fde:	2800      	cmp	r0, #0
 c038fe0:	d0dc      	beq.n	c038f9c <its_flash_fs_file_read+0x18>
 c038fe2:	e7e3      	b.n	c038fac <its_flash_fs_file_read+0x28>

0c038fe4 <its_flash_fs_dblock_compact_block>:
                                              uint32_t lblock,
                                              size_t free_size,
                                              size_t src_offset,
                                              size_t dst_offset,
                                              size_t size)
{
 c038fe4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 c038fe8:	b086      	sub	sp, #24
 c038fea:	4617      	mov	r7, r2
 c038fec:	e9dd 8a0e 	ldrd	r8, sl, [sp, #56]	@ 0x38
    struct its_block_meta_t block_meta;
    psa_status_t err;
    uint32_t scratch_id = 0;

    /* Read current block meta */
    err = its_flash_fs_mblock_read_block_metadata(fs_ctx, lblock, &block_meta);
 c038ff0:	aa02      	add	r2, sp, #8
{
 c038ff2:	4605      	mov	r5, r0
 c038ff4:	460e      	mov	r6, r1
 c038ff6:	4699      	mov	r9, r3
    err = its_flash_fs_mblock_read_block_metadata(fs_ctx, lblock, &block_meta);
 c038ff8:	f000 f9de 	bl	c0393b8 <its_flash_fs_mblock_read_block_metadata>
    if (err != PSA_SUCCESS) {
 c038ffc:	4604      	mov	r4, r0
 c038ffe:	bb68      	cbnz	r0, c03905c <its_flash_fs_dblock_compact_block+0x78>
        return err;
    }

    /* Release data from block meta */
    block_meta.free_size += free_size;
 c039000:	9b04      	ldr	r3, [sp, #16]

    /* Save scratch data block physical IDs */
    scratch_id = its_flash_fs_mblock_cur_data_scratch_id(fs_ctx, lblock);
 c039002:	4631      	mov	r1, r6
    block_meta.free_size += free_size;
 c039004:	443b      	add	r3, r7
    scratch_id = its_flash_fs_mblock_cur_data_scratch_id(fs_ctx, lblock);
 c039006:	4628      	mov	r0, r5
    block_meta.free_size += free_size;
 c039008:	9304      	str	r3, [sp, #16]
    scratch_id = its_flash_fs_mblock_cur_data_scratch_id(fs_ctx, lblock);
 c03900a:	f000 f944 	bl	c039296 <its_flash_fs_mblock_cur_data_scratch_id>
 c03900e:	4607      	mov	r7, r0

    /* Check if there are bytes to be compacted */
    if (size > 0) {
 c039010:	f1ba 0f00 	cmp.w	sl, #0
 c039014:	d116      	bne.n	c039044 <its_flash_fs_dblock_compact_block+0x60>

    if (dst_offset > block_meta.data_start) {
        /* Copy data from the beginning of data block until
         * the position where the data will be reallocated later
         */
        err = its_flash_fs_block_to_block_move(fs_ctx, scratch_id,
 c039016:	e9dd 3202 	ldrd	r3, r2, [sp, #8]
    if (dst_offset > block_meta.data_start) {
 c03901a:	4542      	cmp	r2, r8
 c03901c:	d322      	bcc.n	c039064 <its_flash_fs_dblock_compact_block+0x80>

    /* Swap the scratch and current data blocks. Must swap even with nothing
     * to compact so that deleted file is left in scratch and erased as part
     * of finalization.
     */
    its_flash_fs_mblock_set_data_scratch(fs_ctx, block_meta.phy_id, lblock);
 c03901e:	4632      	mov	r2, r6
 c039020:	4628      	mov	r0, r5
 c039022:	9902      	ldr	r1, [sp, #8]
 c039024:	f000 fa3c 	bl	c0394a0 <its_flash_fs_mblock_set_data_scratch>

    /* Set scratch block ID as the one which contains the new data block */
    block_meta.phy_id = scratch_id;

    /* Update block metadata in scratch metadata block */
    err = its_flash_fs_mblock_update_scratch_block_meta(fs_ctx, lblock,
 c039028:	4631      	mov	r1, r6
 c03902a:	4628      	mov	r0, r5
 c03902c:	aa02      	add	r2, sp, #8
    block_meta.phy_id = scratch_id;
 c03902e:	9702      	str	r7, [sp, #8]
    err = its_flash_fs_mblock_update_scratch_block_meta(fs_ctx, lblock,
 c039030:	f000 fb31 	bl	c039696 <its_flash_fs_mblock_update_scratch_block_meta>
                                                        &block_meta);
    if (err != PSA_SUCCESS) {
 c039034:	4604      	mov	r4, r0
 c039036:	b300      	cbz	r0, c03907a <its_flash_fs_dblock_compact_block+0x96>
        /* Swap back the data block as there was an issue in the process */
        its_flash_fs_mblock_set_data_scratch(fs_ctx, scratch_id, lblock);
 c039038:	4632      	mov	r2, r6
 c03903a:	4639      	mov	r1, r7
 c03903c:	4628      	mov	r0, r5
 c03903e:	f000 fa2f 	bl	c0394a0 <its_flash_fs_mblock_set_data_scratch>
        return err;
 c039042:	e00b      	b.n	c03905c <its_flash_fs_dblock_compact_block+0x78>
        err = its_flash_fs_block_to_block_move(fs_ctx, scratch_id, dst_offset,
 c039044:	4601      	mov	r1, r0
 c039046:	4642      	mov	r2, r8
 c039048:	4628      	mov	r0, r5
 c03904a:	e9cd 9a00 	strd	r9, sl, [sp]
 c03904e:	9b02      	ldr	r3, [sp, #8]
 c039050:	f000 fac6 	bl	c0395e0 <its_flash_fs_block_to_block_move>
        if (err != PSA_SUCCESS) {
 c039054:	2800      	cmp	r0, #0
 c039056:	d0de      	beq.n	c039016 <its_flash_fs_dblock_compact_block+0x32>
            return PSA_ERROR_GENERIC_ERROR;
 c039058:	f06f 0483 	mvn.w	r4, #131	@ 0x83
    if (lblock != ITS_LOGICAL_DBLOCK0) {
        err = fs_ctx->ops->flush(fs_ctx->cfg);
    }

    return err;
}
 c03905c:	4620      	mov	r0, r4
 c03905e:	b006      	add	sp, #24
 c039060:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        err = its_flash_fs_block_to_block_move(fs_ctx, scratch_id,
 c039064:	eba8 0102 	sub.w	r1, r8, r2
 c039068:	e9cd 2100 	strd	r2, r1, [sp]
 c03906c:	4628      	mov	r0, r5
 c03906e:	4639      	mov	r1, r7
 c039070:	f000 fab6 	bl	c0395e0 <its_flash_fs_block_to_block_move>
        if (err != PSA_SUCCESS) {
 c039074:	2800      	cmp	r0, #0
 c039076:	d0d2      	beq.n	c03901e <its_flash_fs_dblock_compact_block+0x3a>
 c039078:	e7ee      	b.n	c039058 <its_flash_fs_dblock_compact_block+0x74>
    if (lblock != ITS_LOGICAL_DBLOCK0) {
 c03907a:	2e00      	cmp	r6, #0
 c03907c:	d0ee      	beq.n	c03905c <its_flash_fs_dblock_compact_block+0x78>
        err = fs_ctx->ops->flush(fs_ctx->cfg);
 c03907e:	686b      	ldr	r3, [r5, #4]
 c039080:	6828      	ldr	r0, [r5, #0]
 c039082:	68db      	ldr	r3, [r3, #12]
 c039084:	4798      	blx	r3
 c039086:	4604      	mov	r4, r0
 c039088:	e7e8      	b.n	c03905c <its_flash_fs_dblock_compact_block+0x78>

0c03908a <its_flash_fs_dblock_read_file>:
                                        struct its_flash_fs_ctx_t *fs_ctx,
                                        const struct its_file_meta_t *file_meta,
                                        size_t offset,
                                        size_t size,
                                        uint8_t *buf)
{
 c03908a:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
 c03908e:	460d      	mov	r5, r1
 c039090:	4616      	mov	r6, r2
    err = its_flash_fs_mblock_read_block_metadata(fs_ctx, lblock, &block_meta);
 c039092:	6809      	ldr	r1, [r1, #0]
 c039094:	466a      	mov	r2, sp
{
 c039096:	4604      	mov	r4, r0
 c039098:	461f      	mov	r7, r3
 c03909a:	f8dd 8028 	ldr.w	r8, [sp, #40]	@ 0x28
    err = its_flash_fs_mblock_read_block_metadata(fs_ctx, lblock, &block_meta);
 c03909e:	f000 f98b 	bl	c0393b8 <its_flash_fs_mblock_read_block_metadata>
    if (err != PSA_SUCCESS) {
 c0390a2:	b970      	cbnz	r0, c0390c2 <its_flash_fs_dblock_read_file+0x38>
    return block_meta.phy_id;
 c0390a4:	9900      	ldr	r1, [sp, #0]
    uint32_t phys_block;
    size_t pos;

    phys_block = its_dblock_lo_to_phy(fs_ctx, file_meta->lblock);
    if (phys_block == ITS_BLOCK_INVALID_ID) {
 c0390a6:	1c4b      	adds	r3, r1, #1
 c0390a8:	d00b      	beq.n	c0390c2 <its_flash_fs_dblock_read_file+0x38>
        return PSA_ERROR_GENERIC_ERROR;
    }

    pos = (file_meta->data_idx + offset);

    return fs_ctx->ops->read(fs_ctx->cfg, phys_block, buf, pos, size);
 c0390aa:	6862      	ldr	r2, [r4, #4]
    pos = (file_meta->data_idx + offset);
 c0390ac:	686b      	ldr	r3, [r5, #4]
    return fs_ctx->ops->read(fs_ctx->cfg, phys_block, buf, pos, size);
 c0390ae:	970a      	str	r7, [sp, #40]	@ 0x28
 c0390b0:	6855      	ldr	r5, [r2, #4]
 c0390b2:	4642      	mov	r2, r8
 c0390b4:	46ac      	mov	ip, r5
 c0390b6:	6820      	ldr	r0, [r4, #0]
 c0390b8:	4433      	add	r3, r6
}
 c0390ba:	b004      	add	sp, #16
 c0390bc:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    return fs_ctx->ops->read(fs_ctx->cfg, phys_block, buf, pos, size);
 c0390c0:	4760      	bx	ip
}
 c0390c2:	f06f 0083 	mvn.w	r0, #131	@ 0x83
 c0390c6:	b004      	add	sp, #16
 c0390c8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0c0390cc <its_flash_fs_dblock_write_file>:
                                      const struct its_block_meta_t *block_meta,
                                      const struct its_file_meta_t *file_meta,
                                      size_t offset,
                                      size_t size,
                                      const uint8_t *data)
{
 c0390cc:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
 c0390d0:	4615      	mov	r5, r2
 c0390d2:	e9dd a90a 	ldrd	sl, r9, [sp, #40]	@ 0x28
 c0390d6:	460e      	mov	r6, r1
 c0390d8:	461f      	mov	r7, r3
    psa_status_t err;
    uint32_t scratch_id;
    size_t pos;
    size_t num_bytes;

    scratch_id = its_flash_fs_mblock_cur_data_scratch_id(fs_ctx,
 c0390da:	6811      	ldr	r1, [r2, #0]
{
 c0390dc:	4604      	mov	r4, r0
    scratch_id = its_flash_fs_mblock_cur_data_scratch_id(fs_ctx,
 c0390de:	f000 f8da 	bl	c039296 <its_flash_fs_mblock_cur_data_scratch_id>
                                                         file_meta->lblock);

    /* Calculate the position of the new file data in the block */
    pos = file_meta->data_idx + offset;
 c0390e2:	686b      	ldr	r3, [r5, #4]

    /* Move data up to the new file data position */
    err = its_flash_fs_block_to_block_move(fs_ctx, scratch_id,
                                           block_meta->data_start,
 c0390e4:	6872      	ldr	r2, [r6, #4]
    pos = file_meta->data_idx + offset;
 c0390e6:	441f      	add	r7, r3
    err = its_flash_fs_block_to_block_move(fs_ctx, scratch_id,
 c0390e8:	1abb      	subs	r3, r7, r2
 c0390ea:	e9cd 2300 	strd	r2, r3, [sp]
    scratch_id = its_flash_fs_mblock_cur_data_scratch_id(fs_ctx,
 c0390ee:	4680      	mov	r8, r0
    err = its_flash_fs_block_to_block_move(fs_ctx, scratch_id,
 c0390f0:	4601      	mov	r1, r0
 c0390f2:	6833      	ldr	r3, [r6, #0]
 c0390f4:	4620      	mov	r0, r4
 c0390f6:	f000 fa73 	bl	c0395e0 <its_flash_fs_block_to_block_move>
                                           block_meta->phy_id,
                                           block_meta->data_start,
                                           pos - block_meta->data_start);
    if (err != PSA_SUCCESS) {
 c0390fa:	bb18      	cbnz	r0, c039144 <its_flash_fs_dblock_write_file+0x78>
        return err;
    }

    /* Write the new file data */
    err = fs_ctx->ops->write(fs_ctx->cfg, scratch_id, data, pos, size);
 c0390fc:	6863      	ldr	r3, [r4, #4]
 c0390fe:	f8cd a000 	str.w	sl, [sp]
 c039102:	f8d3 a008 	ldr.w	sl, [r3, #8]
 c039106:	464a      	mov	r2, r9
 c039108:	463b      	mov	r3, r7
 c03910a:	4641      	mov	r1, r8
 c03910c:	6820      	ldr	r0, [r4, #0]
 c03910e:	47d0      	blx	sl
    if (err != PSA_SUCCESS) {
 c039110:	b9c0      	cbnz	r0, c039144 <its_flash_fs_dblock_write_file+0x78>
        return err;
    }

    /* Calculate the position of the end of the file */
    pos = file_meta->data_idx + file_meta->max_size;
 c039112:	68eb      	ldr	r3, [r5, #12]
 c039114:	686a      	ldr	r2, [r5, #4]

    /* Calculate the size of the data in the block after the end of the file */
    num_bytes = (fs_ctx->cfg->block_size - block_meta->free_size) - pos;
 c039116:	68b1      	ldr	r1, [r6, #8]
    pos = file_meta->data_idx + file_meta->max_size;
 c039118:	441a      	add	r2, r3
    num_bytes = (fs_ctx->cfg->block_size - block_meta->free_size) - pos;
 c03911a:	6823      	ldr	r3, [r4, #0]

    /* Move data between the end of the file and the end of the block data */
    err = its_flash_fs_block_to_block_move(fs_ctx, scratch_id, pos,
 c03911c:	4620      	mov	r0, r4
    num_bytes = (fs_ctx->cfg->block_size - block_meta->free_size) - pos;
 c03911e:	895b      	ldrh	r3, [r3, #10]
 c039120:	1a5b      	subs	r3, r3, r1
 c039122:	1a9b      	subs	r3, r3, r2
    err = its_flash_fs_block_to_block_move(fs_ctx, scratch_id, pos,
 c039124:	e9cd 2300 	strd	r2, r3, [sp]
 c039128:	4641      	mov	r1, r8
 c03912a:	6833      	ldr	r3, [r6, #0]
 c03912c:	f000 fa58 	bl	c0395e0 <its_flash_fs_block_to_block_move>
                                           block_meta->phy_id, pos, num_bytes);
    if (err != PSA_SUCCESS) {
 c039130:	b940      	cbnz	r0, c039144 <its_flash_fs_dblock_write_file+0x78>

    /* Commit data block modifications to flash, unless the data is in logical
     * data block 0, in which case it will be flushed at the end of the metadata
     * block update.
     */
    if (file_meta->lblock != ITS_LOGICAL_DBLOCK0) {
 c039132:	682b      	ldr	r3, [r5, #0]
 c039134:	b133      	cbz	r3, c039144 <its_flash_fs_dblock_write_file+0x78>
        err = fs_ctx->ops->flush(fs_ctx->cfg);
 c039136:	6863      	ldr	r3, [r4, #4]
 c039138:	6820      	ldr	r0, [r4, #0]
 c03913a:	68db      	ldr	r3, [r3, #12]
    }

    return err;
}
 c03913c:	b002      	add	sp, #8
 c03913e:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
        err = fs_ctx->ops->flush(fs_ctx->cfg);
 c039142:	4718      	bx	r3
}
 c039144:	b002      	add	sp, #8
 c039146:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

0c03914a <its_mblock_update_scratch_block_meta>:
 */
static psa_status_t its_mblock_update_scratch_block_meta(
                                      struct its_flash_fs_ctx_t *fs_ctx,
                                      uint32_t lblock,
                                      const struct its_block_meta_t *block_meta)
{
 c03914a:	b513      	push	{r0, r1, r4, lr}
    size_t pos;

    /* Calculate the position */
    pos = its_mblock_block_meta_offset(lblock);
    return fs_ctx->ops->write(fs_ctx->cfg, fs_ctx->scratch_metablock,
 c03914c:	2410      	movs	r4, #16
    return ITS_BLOCK_META_HEADER_SIZE + (lblock * ITS_BLOCK_METADATA_SIZE);
 c03914e:	1c4b      	adds	r3, r1, #1
    return fs_ctx->ops->write(fs_ctx->cfg, fs_ctx->scratch_metablock,
 c039150:	6841      	ldr	r1, [r0, #4]
 c039152:	9400      	str	r4, [sp, #0]
 c039154:	688c      	ldr	r4, [r1, #8]
 c039156:	011b      	lsls	r3, r3, #4
 c039158:	69c1      	ldr	r1, [r0, #28]
 c03915a:	6800      	ldr	r0, [r0, #0]
 c03915c:	47a0      	blx	r4
                              (const uint8_t *)block_meta, pos,
                              ITS_BLOCK_METADATA_SIZE);
}
 c03915e:	b002      	add	sp, #8
 c039160:	bd10      	pop	{r4, pc}

0c039162 <its_mblock_write_scratch_meta_header>:
 *
 * \return Returns error code as specified in \ref psa_status_t
 */
static psa_status_t its_mblock_write_scratch_meta_header(
                                              struct its_flash_fs_ctx_t *fs_ctx)
{
 c039162:	b513      	push	{r0, r1, r4, lr}
    psa_status_t err;

    /* Increment the swap count */
    fs_ctx->meta_block_header.active_swap_count++;
 c039164:	7b43      	ldrb	r3, [r0, #13]
{
 c039166:	4601      	mov	r1, r0
    fs_ctx->meta_block_header.active_swap_count++;
 c039168:	1c5a      	adds	r2, r3, #1
 c03916a:	b2d2      	uxtb	r2, r2
 c03916c:	7342      	strb	r2, [r0, #13]
    return (swap_count == fs_ctx->cfg->erase_val)
 c03916e:	6800      	ldr	r0, [r0, #0]
           : PSA_SUCCESS;
 c039170:	7d04      	ldrb	r4, [r0, #20]
 c039172:	4294      	cmp	r4, r2
        /* Increment again to avoid using the erase val as the swap count */
        fs_ctx->meta_block_header.active_swap_count++;
    }

    /* Write the metadata block header */
    return fs_ctx->ops->write(fs_ctx->cfg, fs_ctx->scratch_metablock,
 c039174:	f04f 0210 	mov.w	r2, #16
        fs_ctx->meta_block_header.active_swap_count++;
 c039178:	bf04      	itt	eq
 c03917a:	3302      	addeq	r3, #2
 c03917c:	734b      	strbeq	r3, [r1, #13]
    return fs_ctx->ops->write(fs_ctx->cfg, fs_ctx->scratch_metablock,
 c03917e:	684b      	ldr	r3, [r1, #4]
 c039180:	9200      	str	r2, [sp, #0]
 c039182:	689c      	ldr	r4, [r3, #8]
 c039184:	f101 0208 	add.w	r2, r1, #8
 c039188:	2300      	movs	r3, #0
 c03918a:	69c9      	ldr	r1, [r1, #28]
 c03918c:	47a0      	blx	r4
                              (uint8_t *)(&fs_ctx->meta_block_header), 0,
                              ITS_BLOCK_META_HEADER_SIZE);
}
 c03918e:	b002      	add	sp, #8
 c039190:	bd10      	pop	{r4, pc}

0c039192 <its_mblock_erase_scratch_blocks>:
    err = fs_ctx->ops->erase(fs_ctx->cfg, fs_ctx->scratch_metablock);
 c039192:	6843      	ldr	r3, [r0, #4]
{
 c039194:	b510      	push	{r4, lr}
    err = fs_ctx->ops->erase(fs_ctx->cfg, fs_ctx->scratch_metablock);
 c039196:	69c1      	ldr	r1, [r0, #28]
{
 c039198:	4604      	mov	r4, r0
    err = fs_ctx->ops->erase(fs_ctx->cfg, fs_ctx->scratch_metablock);
 c03919a:	691b      	ldr	r3, [r3, #16]
 c03919c:	6800      	ldr	r0, [r0, #0]
 c03919e:	4798      	blx	r3
    if (err != PSA_SUCCESS) {
 c0391a0:	b950      	cbnz	r0, c0391b8 <its_mblock_erase_scratch_blocks+0x26>
    if (fs_ctx->cfg->num_blocks > 2) {
 c0391a2:	6823      	ldr	r3, [r4, #0]
 c0391a4:	899a      	ldrh	r2, [r3, #12]
 c0391a6:	2a02      	cmp	r2, #2
 c0391a8:	d906      	bls.n	c0391b8 <its_mblock_erase_scratch_blocks+0x26>
        err = fs_ctx->ops->erase(fs_ctx->cfg, scratch_datablock);
 c0391aa:	6862      	ldr	r2, [r4, #4]
 c0391ac:	68a1      	ldr	r1, [r4, #8]
 c0391ae:	4618      	mov	r0, r3
}
 c0391b0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        err = fs_ctx->ops->erase(fs_ctx->cfg, scratch_datablock);
 c0391b4:	6912      	ldr	r2, [r2, #16]
 c0391b6:	4710      	bx	r2
}
 c0391b8:	bd10      	pop	{r4, pc}

0c0391ba <its_mblock_file_meta_offset.isra.0>:
     return fs_ctx->cfg->num_blocks == 2 ? 0 :
 c0391ba:	8980      	ldrh	r0, [r0, #12]
           + (idx * ITS_FILE_METADATA_SIZE);
 c0391bc:	3101      	adds	r1, #1
     return fs_ctx->cfg->num_blocks == 2 ? 0 :
 c0391be:	2802      	cmp	r0, #2
 c0391c0:	bf0c      	ite	eq
 c0391c2:	2000      	moveq	r0, #0
 c0391c4:	3803      	subne	r0, #3
           + (idx * ITS_FILE_METADATA_SIZE);
 c0391c6:	eb00 0041 	add.w	r0, r0, r1, lsl #1
}
 c0391ca:	0100      	lsls	r0, r0, #4
 c0391cc:	4770      	bx	lr

0c0391ce <its_init_get_active_metablock>:

    /* Read the header of both the metdata blocks. If the read succeeds, then
     * attempt to validate the metadata header, otherwise assume that the block
     * update was incomplete
     */
    err = fs_ctx->ops->read(fs_ctx->cfg, ITS_METADATA_BLOCK0,
 c0391ce:	2210      	movs	r2, #16
{
 c0391d0:	b5f0      	push	{r4, r5, r6, r7, lr}
    err = fs_ctx->ops->read(fs_ctx->cfg, ITS_METADATA_BLOCK0,
 c0391d2:	6843      	ldr	r3, [r0, #4]
{
 c0391d4:	b08b      	sub	sp, #44	@ 0x2c
    err = fs_ctx->ops->read(fs_ctx->cfg, ITS_METADATA_BLOCK0,
 c0391d6:	9200      	str	r2, [sp, #0]
 c0391d8:	685d      	ldr	r5, [r3, #4]
 c0391da:	2300      	movs	r3, #0
{
 c0391dc:	4604      	mov	r4, r0
    err = fs_ctx->ops->read(fs_ctx->cfg, ITS_METADATA_BLOCK0,
 c0391de:	4619      	mov	r1, r3
 c0391e0:	6800      	ldr	r0, [r0, #0]
 c0391e2:	aa02      	add	r2, sp, #8
 c0391e4:	47a8      	blx	r5
                            (uint8_t *)&h_meta0, 0, ITS_BLOCK_META_HEADER_SIZE);
    if (err == PSA_SUCCESS) {
 c0391e6:	2800      	cmp	r0, #0
 c0391e8:	d146      	bne.n	c039278 <its_init_get_active_metablock+0xaa>
    err = its_mblock_validate_fs_version(h_meta->fs_version);
 c0391ea:	f89d 600c 	ldrb.w	r6, [sp, #12]
    return (swap_count == fs_ctx->cfg->erase_val)
 c0391ee:	6823      	ldr	r3, [r4, #0]
                                                 : PSA_SUCCESS;
 c0391f0:	2e01      	cmp	r6, #1
 c0391f2:	d145      	bne.n	c039280 <its_init_get_active_metablock+0xb2>
           : PSA_SUCCESS;
 c0391f4:	f89d 200d 	ldrb.w	r2, [sp, #13]
 c0391f8:	7d1b      	ldrb	r3, [r3, #20]
    uint8_t num_valid_meta_blocks = 0;
 c0391fa:	429a      	cmp	r2, r3
 c0391fc:	bf0a      	itet	eq
 c0391fe:	2600      	moveq	r6, #0
 c039200:	2500      	movne	r5, #0
 c039202:	f04f 35ff 	moveq.w	r5, #4294967295	@ 0xffffffff
            num_valid_meta_blocks++;
            cur_meta_block = ITS_METADATA_BLOCK0;
        }
    }

    err = fs_ctx->ops->read(fs_ctx->cfg, ITS_METADATA_BLOCK1,
 c039206:	2210      	movs	r2, #16
 c039208:	6863      	ldr	r3, [r4, #4]
 c03920a:	9200      	str	r2, [sp, #0]
 c03920c:	685f      	ldr	r7, [r3, #4]
 c03920e:	2101      	movs	r1, #1
 c039210:	2300      	movs	r3, #0
 c039212:	6820      	ldr	r0, [r4, #0]
 c039214:	aa06      	add	r2, sp, #24
 c039216:	47b8      	blx	r7
                            (uint8_t *)&h_meta1, 0, ITS_BLOCK_META_HEADER_SIZE);
    if (err == PSA_SUCCESS) {
 c039218:	2800      	cmp	r0, #0
 c03921a:	d135      	bne.n	c039288 <its_init_get_active_metablock+0xba>
                                                 : PSA_SUCCESS;
 c03921c:	f89d 101c 	ldrb.w	r1, [sp, #28]
 c039220:	2901      	cmp	r1, #1
 c039222:	d131      	bne.n	c039288 <its_init_get_active_metablock+0xba>
    return (swap_count == fs_ctx->cfg->erase_val)
 c039224:	6823      	ldr	r3, [r4, #0]
        err = its_mblock_validate_swap_count(fs_ctx, h_meta->active_swap_count);
 c039226:	f89d 201d 	ldrb.w	r2, [sp, #29]
    return (swap_count == fs_ctx->cfg->erase_val)
 c03922a:	7d1b      	ldrb	r3, [r3, #20]
           : PSA_SUCCESS;
 c03922c:	429a      	cmp	r2, r3
 c03922e:	d02b      	beq.n	c039288 <its_init_get_active_metablock+0xba>

    /* If there are more than 1 potential metablocks, the previous
     * update operation was interrupted by power failure. In which case,
     * need to find out which one is potentially latest metablock.
     */
    if (num_valid_meta_blocks > 1) {
 c039230:	2e01      	cmp	r6, #1
 c039232:	d12e      	bne.n	c039292 <its_init_get_active_metablock+0xc4>
    if (fs_ctx->cfg->erase_val == 0x00U) {
 c039234:	fab3 f383 	clz	r3, r3
 c039238:	095b      	lsrs	r3, r3, #5
    if ((meta1_swap_count == rollover_val) &&
 c03923a:	4293      	cmp	r3, r2
 c03923c:	f89d 100d 	ldrb.w	r1, [sp, #13]
 c039240:	d105      	bne.n	c03924e <its_init_get_active_metablock+0x80>
        (meta0_swap_count != (rollover_val + 1))) {
 c039242:	2b00      	cmp	r3, #0
 c039244:	bf0c      	ite	eq
 c039246:	2001      	moveq	r0, #1
 c039248:	2002      	movne	r0, #2
    if ((meta1_swap_count == rollover_val) &&
 c03924a:	4281      	cmp	r1, r0
 c03924c:	d10b      	bne.n	c039266 <its_init_get_active_metablock+0x98>
    } else if ((meta0_swap_count == rollover_val) &&
 c03924e:	4299      	cmp	r1, r3
 c039250:	d105      	bne.n	c03925e <its_init_get_active_metablock+0x90>
               (meta1_swap_count != (rollover_val + 1))) {
 c039252:	2900      	cmp	r1, #0
 c039254:	bf14      	ite	ne
 c039256:	2302      	movne	r3, #2
 c039258:	2301      	moveq	r3, #1
    } else if ((meta0_swap_count == rollover_val) &&
 c03925a:	429a      	cmp	r2, r3
 c03925c:	d112      	bne.n	c039284 <its_init_get_active_metablock+0xb6>
    } else if (meta1_swap_count > meta0_swap_count) {
 c03925e:	4291      	cmp	r1, r2
 c039260:	bf2c      	ite	cs
 c039262:	2600      	movcs	r6, #0
 c039264:	2601      	movcc	r6, #1
        cur_meta_block = its_mblock_latest_meta_block(fs_ctx, &h_meta0,
 c039266:	4635      	mov	r5, r6
                                                      &h_meta1);
    } else if (num_valid_meta_blocks == 0) {
        return PSA_ERROR_GENERIC_ERROR;
    }

    fs_ctx->active_metablock = cur_meta_block;
 c039268:	61a5      	str	r5, [r4, #24]
    fs_ctx->scratch_metablock = ITS_OTHER_META_BLOCK(cur_meta_block);
 c03926a:	fab5 f585 	clz	r5, r5

    return PSA_SUCCESS;
 c03926e:	2000      	movs	r0, #0
    fs_ctx->scratch_metablock = ITS_OTHER_META_BLOCK(cur_meta_block);
 c039270:	096d      	lsrs	r5, r5, #5
 c039272:	61e5      	str	r5, [r4, #28]
}
 c039274:	b00b      	add	sp, #44	@ 0x2c
 c039276:	bdf0      	pop	{r4, r5, r6, r7, pc}
    uint8_t num_valid_meta_blocks = 0;
 c039278:	2600      	movs	r6, #0
    uint32_t cur_meta_block = ITS_BLOCK_INVALID_ID;
 c03927a:	f04f 35ff 	mov.w	r5, #4294967295	@ 0xffffffff
 c03927e:	e7c2      	b.n	c039206 <its_init_get_active_metablock+0x38>
    uint8_t num_valid_meta_blocks = 0;
 c039280:	4606      	mov	r6, r0
 c039282:	e7fa      	b.n	c03927a <its_init_get_active_metablock+0xac>
        cur_meta = ITS_METADATA_BLOCK0;
 c039284:	2600      	movs	r6, #0
 c039286:	e7ee      	b.n	c039266 <its_init_get_active_metablock+0x98>
    } else if (num_valid_meta_blocks == 0) {
 c039288:	2e00      	cmp	r6, #0
 c03928a:	d1ed      	bne.n	c039268 <its_init_get_active_metablock+0x9a>
        return PSA_ERROR_GENERIC_ERROR;
 c03928c:	f06f 0083 	mvn.w	r0, #131	@ 0x83
 c039290:	e7f0      	b.n	c039274 <its_init_get_active_metablock+0xa6>
            cur_meta_block = ITS_METADATA_BLOCK1;
 c039292:	460d      	mov	r5, r1
 c039294:	e7e8      	b.n	c039268 <its_init_get_active_metablock+0x9a>

0c039296 <its_flash_fs_mblock_cur_data_scratch_id>:

uint32_t its_flash_fs_mblock_cur_data_scratch_id(
                                              struct its_flash_fs_ctx_t *fs_ctx,
                                              uint32_t lblock)
{
    if (lblock == ITS_LOGICAL_DBLOCK0) {
 c039296:	b909      	cbnz	r1, c03929c <its_flash_fs_mblock_cur_data_scratch_id+0x6>
        /* Scratch logical data block 0 physical IDs */
        return fs_ctx->scratch_metablock;
 c039298:	69c0      	ldr	r0, [r0, #28]
 c03929a:	4770      	bx	lr
    }

    return fs_ctx->meta_block_header.scratch_dblock;
 c03929c:	6880      	ldr	r0, [r0, #8]
}
 c03929e:	4770      	bx	lr

0c0392a0 <its_flash_fs_mblock_init>:
psa_status_t its_flash_fs_mblock_init(struct its_flash_fs_ctx_t *fs_ctx)
{
    psa_status_t err;

    /* Initialize Flash Interface */
    err = fs_ctx->ops->init(fs_ctx->cfg);
 c0392a0:	6843      	ldr	r3, [r0, #4]
{
 c0392a2:	b537      	push	{r0, r1, r2, r4, r5, lr}
    err = fs_ctx->ops->init(fs_ctx->cfg);
 c0392a4:	681b      	ldr	r3, [r3, #0]
{
 c0392a6:	4604      	mov	r4, r0
    err = fs_ctx->ops->init(fs_ctx->cfg);
 c0392a8:	6800      	ldr	r0, [r0, #0]
 c0392aa:	4798      	blx	r3
    if (err != PSA_SUCCESS) {
 c0392ac:	b930      	cbnz	r0, c0392bc <its_flash_fs_mblock_init+0x1c>
        return err;
    }

    err = its_init_get_active_metablock(fs_ctx);
 c0392ae:	4620      	mov	r0, r4
 c0392b0:	f7ff ff8d 	bl	c0391ce <its_init_get_active_metablock>
    if (err != PSA_SUCCESS) {
 c0392b4:	4603      	mov	r3, r0
 c0392b6:	b118      	cbz	r0, c0392c0 <its_flash_fs_mblock_init+0x20>
        return PSA_ERROR_GENERIC_ERROR;
 c0392b8:	f06f 0083 	mvn.w	r0, #131	@ 0x83
        return PSA_ERROR_GENERIC_ERROR;
    }

    /* Erase the other scratch metadata block */
    return its_mblock_erase_scratch_blocks(fs_ctx);
}
 c0392bc:	b003      	add	sp, #12
 c0392be:	bd30      	pop	{r4, r5, pc}
    err = fs_ctx->ops->read(fs_ctx->cfg, fs_ctx->active_metablock,
 c0392c0:	2110      	movs	r1, #16
 c0392c2:	6862      	ldr	r2, [r4, #4]
 c0392c4:	9100      	str	r1, [sp, #0]
 c0392c6:	6855      	ldr	r5, [r2, #4]
 c0392c8:	69a1      	ldr	r1, [r4, #24]
 c0392ca:	6820      	ldr	r0, [r4, #0]
 c0392cc:	f104 0208 	add.w	r2, r4, #8
 c0392d0:	47a8      	blx	r5
    if (err != PSA_SUCCESS) {
 c0392d2:	2800      	cmp	r0, #0
 c0392d4:	d1f0      	bne.n	c0392b8 <its_flash_fs_mblock_init+0x18>
                                                 : PSA_SUCCESS;
 c0392d6:	7b23      	ldrb	r3, [r4, #12]
 c0392d8:	2b01      	cmp	r3, #1
 c0392da:	d1ed      	bne.n	c0392b8 <its_flash_fs_mblock_init+0x18>
    return (swap_count == fs_ctx->cfg->erase_val)
 c0392dc:	6823      	ldr	r3, [r4, #0]
           : PSA_SUCCESS;
 c0392de:	7b62      	ldrb	r2, [r4, #13]
 c0392e0:	7d1b      	ldrb	r3, [r3, #20]
 c0392e2:	429a      	cmp	r2, r3
 c0392e4:	d0e8      	beq.n	c0392b8 <its_flash_fs_mblock_init+0x18>
    return its_mblock_erase_scratch_blocks(fs_ctx);
 c0392e6:	4620      	mov	r0, r4
}
 c0392e8:	b003      	add	sp, #12
 c0392ea:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    return its_mblock_erase_scratch_blocks(fs_ctx);
 c0392ee:	f7ff bf50 	b.w	c039192 <its_mblock_erase_scratch_blocks>

0c0392f2 <its_flash_fs_mblock_meta_update_finalize>:

psa_status_t its_flash_fs_mblock_meta_update_finalize(
                                              struct its_flash_fs_ctx_t *fs_ctx)
{
 c0392f2:	b510      	push	{r4, lr}
 c0392f4:	4604      	mov	r4, r0
    psa_status_t err;

    /* Write the metadata block header to flash */
    err = its_mblock_write_scratch_meta_header(fs_ctx);
 c0392f6:	f7ff ff34 	bl	c039162 <its_mblock_write_scratch_meta_header>
    if (err != PSA_SUCCESS) {
 c0392fa:	b968      	cbnz	r0, c039318 <its_flash_fs_mblock_meta_update_finalize+0x26>
        return err;
    }

    /* Commit metadata block modifications to flash */
    err = fs_ctx->ops->flush(fs_ctx->cfg);
 c0392fc:	6863      	ldr	r3, [r4, #4]
 c0392fe:	6820      	ldr	r0, [r4, #0]
 c039300:	68db      	ldr	r3, [r3, #12]
 c039302:	4798      	blx	r3
    if (err != PSA_SUCCESS) {
 c039304:	b940      	cbnz	r0, c039318 <its_flash_fs_mblock_meta_update_finalize+0x26>
    fs_ctx->scratch_metablock = fs_ctx->active_metablock;
 c039306:	e9d4 2306 	ldrd	r2, r3, [r4, #24]

    /* Update the running context */
    its_mblock_swap_metablocks(fs_ctx);

    /* Erase meta block and current scratch block */
    return its_mblock_erase_scratch_blocks(fs_ctx);
 c03930a:	4620      	mov	r0, r4
    fs_ctx->active_metablock = tmp_block;
 c03930c:	e9c4 3206 	strd	r3, r2, [r4, #24]
}
 c039310:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    return its_mblock_erase_scratch_blocks(fs_ctx);
 c039314:	f7ff bf3d 	b.w	c039192 <its_mblock_erase_scratch_blocks>
}
 c039318:	bd10      	pop	{r4, pc}

0c03931a <its_flash_fs_mblock_read_file_meta>:

psa_status_t its_flash_fs_mblock_read_file_meta(
                                              struct its_flash_fs_ctx_t *fs_ctx,
                                              uint32_t idx,
                                              struct its_file_meta_t *file_meta)
{
 c03931a:	b573      	push	{r0, r1, r4, r5, r6, lr}
 c03931c:	6805      	ldr	r5, [r0, #0]
 c03931e:	4604      	mov	r4, r0
    psa_status_t err;
    size_t offset;

    offset = its_mblock_file_meta_offset(fs_ctx, idx);
 c039320:	4628      	mov	r0, r5
 c039322:	f7ff ff4a 	bl	c0391ba <its_mblock_file_meta_offset.isra.0>
 c039326:	4603      	mov	r3, r0
    err = fs_ctx->ops->read(fs_ctx->cfg, fs_ctx->active_metablock,
 c039328:	2020      	movs	r0, #32
 c03932a:	6861      	ldr	r1, [r4, #4]
 c03932c:	9000      	str	r0, [sp, #0]
 c03932e:	684e      	ldr	r6, [r1, #4]
 c039330:	4628      	mov	r0, r5
 c039332:	69a1      	ldr	r1, [r4, #24]
 c039334:	47b0      	blx	r6
        err = its_mblock_validate_file_meta(fs_ctx, file_meta);
    }
#endif

    return err;
}
 c039336:	b002      	add	sp, #8
 c039338:	bd70      	pop	{r4, r5, r6, pc}

0c03933a <its_flash_fs_mblock_get_file_idx>:
{
 c03933a:	b5f0      	push	{r4, r5, r6, r7, lr}
 c03933c:	4605      	mov	r5, r0
 c03933e:	460e      	mov	r6, r1
 c039340:	4617      	mov	r7, r2
    for (i = 0; i < fs_ctx->cfg->max_num_files; i++) {
 c039342:	2400      	movs	r4, #0
{
 c039344:	b089      	sub	sp, #36	@ 0x24
    for (i = 0; i < fs_ctx->cfg->max_num_files; i++) {
 c039346:	682b      	ldr	r3, [r5, #0]
 c039348:	8a5b      	ldrh	r3, [r3, #18]
 c03934a:	42a3      	cmp	r3, r4
 c03934c:	d802      	bhi.n	c039354 <its_flash_fs_mblock_get_file_idx+0x1a>
    return PSA_ERROR_DOES_NOT_EXIST;
 c03934e:	f06f 008b 	mvn.w	r0, #139	@ 0x8b
 c039352:	e00c      	b.n	c03936e <its_flash_fs_mblock_get_file_idx+0x34>
        err = its_flash_fs_mblock_read_file_meta(fs_ctx, i, &tmp_metadata);
 c039354:	466a      	mov	r2, sp
 c039356:	4621      	mov	r1, r4
 c039358:	4628      	mov	r0, r5
 c03935a:	f7ff ffde 	bl	c03931a <its_flash_fs_mblock_read_file_meta>
        if (err != PSA_SUCCESS) {
 c03935e:	b950      	cbnz	r0, c039376 <its_flash_fs_mblock_get_file_idx+0x3c>
 c039360:	220c      	movs	r2, #12
 c039362:	4631      	mov	r1, r6
 c039364:	a805      	add	r0, sp, #20
 c039366:	f022 f961 	bl	c05b62c <memcmp>
        if (!tfm_memcmp(tmp_metadata.id, fid, ITS_FILE_ID_SIZE)) {
 c03936a:	b910      	cbnz	r0, c039372 <its_flash_fs_mblock_get_file_idx+0x38>
            *idx = i;
 c03936c:	603c      	str	r4, [r7, #0]
}
 c03936e:	b009      	add	sp, #36	@ 0x24
 c039370:	bdf0      	pop	{r4, r5, r6, r7, pc}
    for (i = 0; i < fs_ctx->cfg->max_num_files; i++) {
 c039372:	3401      	adds	r4, #1
 c039374:	e7e7      	b.n	c039346 <its_flash_fs_mblock_get_file_idx+0xc>
            return PSA_ERROR_GENERIC_ERROR;
 c039376:	f06f 0083 	mvn.w	r0, #131	@ 0x83
 c03937a:	e7f8      	b.n	c03936e <its_flash_fs_mblock_get_file_idx+0x34>

0c03937c <its_flash_fs_mblock_get_file_idx_flag>:
{
 c03937c:	b5f0      	push	{r4, r5, r6, r7, lr}
 c03937e:	4605      	mov	r5, r0
 c039380:	460e      	mov	r6, r1
 c039382:	4617      	mov	r7, r2
    for (i = 0; i < fs_ctx->cfg->max_num_files; i++) {
 c039384:	2400      	movs	r4, #0
{
 c039386:	b089      	sub	sp, #36	@ 0x24
    for (i = 0; i < fs_ctx->cfg->max_num_files; i++) {
 c039388:	682b      	ldr	r3, [r5, #0]
 c03938a:	8a5b      	ldrh	r3, [r3, #18]
 c03938c:	42a3      	cmp	r3, r4
 c03938e:	d802      	bhi.n	c039396 <its_flash_fs_mblock_get_file_idx_flag+0x1a>
    return PSA_ERROR_DOES_NOT_EXIST;
 c039390:	f06f 008b 	mvn.w	r0, #139	@ 0x8b
 c039394:	e009      	b.n	c0393aa <its_flash_fs_mblock_get_file_idx_flag+0x2e>
        err = its_flash_fs_mblock_read_file_meta(fs_ctx, i, &tmp_metadata);
 c039396:	466a      	mov	r2, sp
 c039398:	4621      	mov	r1, r4
 c03939a:	4628      	mov	r0, r5
 c03939c:	f7ff ffbd 	bl	c03931a <its_flash_fs_mblock_read_file_meta>
        if (err != PSA_SUCCESS) {
 c0393a0:	b938      	cbnz	r0, c0393b2 <its_flash_fs_mblock_get_file_idx_flag+0x36>
        if (tmp_metadata.flags & flags) {
 c0393a2:	9b04      	ldr	r3, [sp, #16]
 c0393a4:	421e      	tst	r6, r3
 c0393a6:	d002      	beq.n	c0393ae <its_flash_fs_mblock_get_file_idx_flag+0x32>
            *idx = i;
 c0393a8:	603c      	str	r4, [r7, #0]
}
 c0393aa:	b009      	add	sp, #36	@ 0x24
 c0393ac:	bdf0      	pop	{r4, r5, r6, r7, pc}
    for (i = 0; i < fs_ctx->cfg->max_num_files; i++) {
 c0393ae:	3401      	adds	r4, #1
 c0393b0:	e7ea      	b.n	c039388 <its_flash_fs_mblock_get_file_idx_flag+0xc>
            return PSA_ERROR_GENERIC_ERROR;
 c0393b2:	f06f 0083 	mvn.w	r0, #131	@ 0x83
 c0393b6:	e7f8      	b.n	c0393aa <its_flash_fs_mblock_get_file_idx_flag+0x2e>

0c0393b8 <its_flash_fs_mblock_read_block_metadata>:

psa_status_t its_flash_fs_mblock_read_block_metadata(
                                            struct its_flash_fs_ctx_t *fs_ctx,
                                            uint32_t lblock,
                                            struct its_block_meta_t *block_meta)
{
 c0393b8:	b513      	push	{r0, r1, r4, lr}
    psa_status_t err;
    size_t pos;

    pos = its_mblock_block_meta_offset(lblock);
    err = fs_ctx->ops->read(fs_ctx->cfg, fs_ctx->active_metablock,
 c0393ba:	2410      	movs	r4, #16
    return ITS_BLOCK_META_HEADER_SIZE + (lblock * ITS_BLOCK_METADATA_SIZE);
 c0393bc:	1c4b      	adds	r3, r1, #1
    err = fs_ctx->ops->read(fs_ctx->cfg, fs_ctx->active_metablock,
 c0393be:	6841      	ldr	r1, [r0, #4]
 c0393c0:	9400      	str	r4, [sp, #0]
 c0393c2:	684c      	ldr	r4, [r1, #4]
 c0393c4:	011b      	lsls	r3, r3, #4
 c0393c6:	6981      	ldr	r1, [r0, #24]
 c0393c8:	6800      	ldr	r0, [r0, #0]
 c0393ca:	47a0      	blx	r4
        err = its_mblock_validate_block_meta(fs_ctx, block_meta);
    }
#endif

    return err;
}
 c0393cc:	b002      	add	sp, #8
 c0393ce:	bd10      	pop	{r4, pc}

0c0393d0 <its_flash_fs_mblock_reserve_file>:
                                            size_t size,
                                            uint32_t flags,
                                            uint32_t *idx,
                                            struct its_file_meta_t *file_meta,
                                            struct its_block_meta_t *block_meta)
{
 c0393d0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c0393d4:	4606      	mov	r6, r0
 c0393d6:	4689      	mov	r9, r1
 c0393d8:	4690      	mov	r8, r2
 c0393da:	469a      	mov	sl, r3
    for (i = 0; i < its_num_active_dblocks(fs_ctx); i++) {
 c0393dc:	2700      	movs	r7, #0
{
 c0393de:	b089      	sub	sp, #36	@ 0x24
 c0393e0:	e9dd 5b14 	ldrd	r5, fp, [sp, #80]	@ 0x50
     return fs_ctx->cfg->num_blocks == 2 ? 0 :
 c0393e4:	6833      	ldr	r3, [r6, #0]
 c0393e6:	8998      	ldrh	r0, [r3, #12]
 c0393e8:	2802      	cmp	r0, #2
 c0393ea:	bf0c      	ite	eq
 c0393ec:	2000      	moveq	r0, #0
 c0393ee:	3803      	subne	r0, #3
    return its_num_dedicated_dblocks(fs_ctx) + 1;
 c0393f0:	3001      	adds	r0, #1
    for (i = 0; i < its_num_active_dblocks(fs_ctx); i++) {
 c0393f2:	4287      	cmp	r7, r0
 c0393f4:	d302      	bcc.n	c0393fc <its_flash_fs_mblock_reserve_file+0x2c>
    return PSA_ERROR_INSUFFICIENT_STORAGE;
 c0393f6:	f06f 048d 	mvn.w	r4, #141	@ 0x8d
 c0393fa:	e024      	b.n	c039446 <its_flash_fs_mblock_reserve_file+0x76>
        err = its_flash_fs_mblock_read_block_metadata(fs_ctx, i, block_meta);
 c0393fc:	465a      	mov	r2, fp
 c0393fe:	4639      	mov	r1, r7
 c039400:	4630      	mov	r0, r6
 c039402:	f7ff ffd9 	bl	c0393b8 <its_flash_fs_mblock_read_block_metadata>
        if (err != PSA_SUCCESS) {
 c039406:	4604      	mov	r4, r0
 c039408:	2800      	cmp	r0, #0
 c03940a:	d138      	bne.n	c03947e <its_flash_fs_mblock_reserve_file+0xae>
        if (block_meta->free_size >= size) {
 c03940c:	f8db 2008 	ldr.w	r2, [fp, #8]
 c039410:	4592      	cmp	sl, r2
 c039412:	d832      	bhi.n	c03947a <its_flash_fs_mblock_reserve_file+0xaa>
            file_meta->data_idx = fs_ctx->cfg->block_size
 c039414:	6833      	ldr	r3, [r6, #0]
            file_meta->lblock = i;
 c039416:	602f      	str	r7, [r5, #0]
            file_meta->data_idx = fs_ctx->cfg->block_size
 c039418:	895b      	ldrh	r3, [r3, #10]
            file_meta->max_size = size;
 c03941a:	f8c5 a00c 	str.w	sl, [r5, #12]
                                  - block_meta->free_size;
 c03941e:	1a9b      	subs	r3, r3, r2
            file_meta->data_idx = fs_ctx->cfg->block_size
 c039420:	606b      	str	r3, [r5, #4]
    return (memcpy(dest, src, num));
 c039422:	f8d9 3000 	ldr.w	r3, [r9]
 c039426:	616b      	str	r3, [r5, #20]
 c039428:	f8d9 3004 	ldr.w	r3, [r9, #4]
 c03942c:	61ab      	str	r3, [r5, #24]
 c03942e:	f8d9 3008 	ldr.w	r3, [r9, #8]
            file_meta->cur_size = 0;
 c039432:	60a8      	str	r0, [r5, #8]
 c039434:	61eb      	str	r3, [r5, #28]
            file_meta->flags = flags;
 c039436:	9b12      	ldr	r3, [sp, #72]	@ 0x48
 c039438:	612b      	str	r3, [r5, #16]
            block_meta->free_size -= size;
 c03943a:	f8db 3008 	ldr.w	r3, [fp, #8]
 c03943e:	eba3 030a 	sub.w	r3, r3, sl
 c039442:	f8cb 3008 	str.w	r3, [fp, #8]
    for (i = 0; i < fs_ctx->cfg->max_num_files; i++) {
 c039446:	2500      	movs	r5, #0
 c039448:	6833      	ldr	r3, [r6, #0]
 c03944a:	8a5b      	ldrh	r3, [r3, #18]
 c03944c:	429d      	cmp	r5, r3
 c03944e:	d205      	bcs.n	c03945c <its_flash_fs_mblock_reserve_file+0x8c>
        err = its_flash_fs_mblock_read_file_meta(fs_ctx, i, &tmp_metadata);
 c039450:	466a      	mov	r2, sp
 c039452:	4629      	mov	r1, r5
 c039454:	4630      	mov	r0, r6
 c039456:	f7ff ff60 	bl	c03931a <its_flash_fs_mblock_read_file_meta>
        if (err != PSA_SUCCESS) {
 c03945a:	b198      	cbz	r0, c039484 <its_flash_fs_mblock_reserve_file+0xb4>
            return ITS_METADATA_INVALID_INDEX;
 c03945c:	f64f 75ff 	movw	r5, #65535	@ 0xffff
    psa_status_t err;

    err = its_mblock_reserve_file(fs_ctx, fid, size, flags, file_meta,
                                  block_meta);

    *idx = its_get_free_file_index(fs_ctx, use_spare);
 c039460:	9b13      	ldr	r3, [sp, #76]	@ 0x4c
 c039462:	601d      	str	r5, [r3, #0]
    if ((err != PSA_SUCCESS) ||
 c039464:	b9cc      	cbnz	r4, c03949a <its_flash_fs_mblock_reserve_file+0xca>
 c039466:	f64f 73ff 	movw	r3, #65535	@ 0xffff
        (*idx == ITS_METADATA_INVALID_INDEX)) {
        return PSA_ERROR_INSUFFICIENT_STORAGE;
 c03946a:	429d      	cmp	r5, r3
 c03946c:	bf08      	it	eq
 c03946e:	f06f 048d 	mvneq.w	r4, #141	@ 0x8d
    }

    return PSA_SUCCESS;
}
 c039472:	4620      	mov	r0, r4
 c039474:	b009      	add	sp, #36	@ 0x24
 c039476:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    for (i = 0; i < its_num_active_dblocks(fs_ctx); i++) {
 c03947a:	3701      	adds	r7, #1
 c03947c:	e7b2      	b.n	c0393e4 <its_flash_fs_mblock_reserve_file+0x14>
            return PSA_ERROR_GENERIC_ERROR;
 c03947e:	f06f 0483 	mvn.w	r4, #131	@ 0x83
 c039482:	e7e0      	b.n	c039446 <its_flash_fs_mblock_reserve_file+0x76>
        if (its_utils_validate_fid(tmp_metadata.id) != PSA_SUCCESS) {
 c039484:	a805      	add	r0, sp, #20
 c039486:	f000 f996 	bl	c0397b6 <its_utils_validate_fid>
 c03948a:	b120      	cbz	r0, c039496 <its_flash_fs_mblock_reserve_file+0xc6>
            if (!use_spare) {
 c03948c:	f1b8 0f00 	cmp.w	r8, #0
 c039490:	d1e6      	bne.n	c039460 <its_flash_fs_mblock_reserve_file+0x90>
                use_spare = true;
 c039492:	f04f 0801 	mov.w	r8, #1
    for (i = 0; i < fs_ctx->cfg->max_num_files; i++) {
 c039496:	3501      	adds	r5, #1
 c039498:	e7d6      	b.n	c039448 <its_flash_fs_mblock_reserve_file+0x78>
        return PSA_ERROR_INSUFFICIENT_STORAGE;
 c03949a:	f06f 048d 	mvn.w	r4, #141	@ 0x8d
 c03949e:	e7e8      	b.n	c039472 <its_flash_fs_mblock_reserve_file+0xa2>

0c0394a0 <its_flash_fs_mblock_set_data_scratch>:
}

void its_flash_fs_mblock_set_data_scratch(struct its_flash_fs_ctx_t *fs_ctx,
                                          uint32_t phy_id, uint32_t lblock)
{
    if (lblock != ITS_LOGICAL_DBLOCK0) {
 c0394a0:	b102      	cbz	r2, c0394a4 <its_flash_fs_mblock_set_data_scratch+0x4>
        fs_ctx->meta_block_header.scratch_dblock = phy_id;
 c0394a2:	6081      	str	r1, [r0, #8]
    }
}
 c0394a4:	4770      	bx	lr

0c0394a6 <its_flash_fs_mblock_update_scratch_file_meta>:

psa_status_t its_flash_fs_mblock_update_scratch_file_meta(
                                        struct its_flash_fs_ctx_t *fs_ctx,
                                        uint32_t idx,
                                        const struct its_file_meta_t *file_meta)
{
 c0394a6:	b573      	push	{r0, r1, r4, r5, r6, lr}
 c0394a8:	6805      	ldr	r5, [r0, #0]
 c0394aa:	4604      	mov	r4, r0
    size_t pos;

    /* Calculate the position */
    pos = its_mblock_file_meta_offset(fs_ctx, idx);
 c0394ac:	4628      	mov	r0, r5
 c0394ae:	f7ff fe84 	bl	c0391ba <its_mblock_file_meta_offset.isra.0>
 c0394b2:	4603      	mov	r3, r0
    return fs_ctx->ops->write(fs_ctx->cfg, fs_ctx->scratch_metablock,
 c0394b4:	2020      	movs	r0, #32
 c0394b6:	6861      	ldr	r1, [r4, #4]
 c0394b8:	9000      	str	r0, [sp, #0]
 c0394ba:	688e      	ldr	r6, [r1, #8]
 c0394bc:	4628      	mov	r0, r5
 c0394be:	69e1      	ldr	r1, [r4, #28]
 c0394c0:	47b0      	blx	r6
                              (const uint8_t *)file_meta, pos,
                              ITS_FILE_METADATA_SIZE);
}
 c0394c2:	b002      	add	sp, #8
 c0394c4:	bd70      	pop	{r4, r5, r6, pc}

0c0394c6 <its_flash_fs_mblock_reset_metablock>:
{
 c0394c6:	b570      	push	{r4, r5, r6, lr}
 c0394c8:	b08c      	sub	sp, #48	@ 0x30
 c0394ca:	4605      	mov	r5, r0
    if (its_init_get_active_metablock(fs_ctx) == PSA_SUCCESS) {
 c0394cc:	f7ff fe7f 	bl	c0391ce <its_init_get_active_metablock>
 c0394d0:	2800      	cmp	r0, #0
 c0394d2:	d15e      	bne.n	c039592 <its_flash_fs_mblock_reset_metablock+0xcc>
        metablock_to_erase_first = fs_ctx->scratch_metablock;
 c0394d4:	69ee      	ldr	r6, [r5, #28]
    err = fs_ctx->ops->erase(fs_ctx->cfg, metablock_to_erase_first);
 c0394d6:	686b      	ldr	r3, [r5, #4]
 c0394d8:	4631      	mov	r1, r6
 c0394da:	691b      	ldr	r3, [r3, #16]
 c0394dc:	6828      	ldr	r0, [r5, #0]
 c0394de:	4798      	blx	r3
    if (err != PSA_SUCCESS) {
 c0394e0:	4604      	mov	r4, r0
 c0394e2:	2800      	cmp	r0, #0
 c0394e4:	d16d      	bne.n	c0395c2 <its_flash_fs_mblock_reset_metablock+0xfc>
    err = fs_ctx->ops->erase(fs_ctx->cfg,
 c0394e6:	fab6 f186 	clz	r1, r6
 c0394ea:	686b      	ldr	r3, [r5, #4]
 c0394ec:	6828      	ldr	r0, [r5, #0]
 c0394ee:	691b      	ldr	r3, [r3, #16]
 c0394f0:	0949      	lsrs	r1, r1, #5
 c0394f2:	4798      	blx	r3
    if (err != PSA_SUCCESS) {
 c0394f4:	4604      	mov	r4, r0
 c0394f6:	2800      	cmp	r0, #0
 c0394f8:	d163      	bne.n	c0395c2 <its_flash_fs_mblock_reset_metablock+0xfc>
                                    (fs_ctx->cfg->erase_val == 0x00U) ? 1U : 0U;
 c0394fa:	682b      	ldr	r3, [r5, #0]
    fs_ctx->meta_block_header.active_swap_count =
 c0394fc:	7d1a      	ldrb	r2, [r3, #20]
 c0394fe:	fab2 f282 	clz	r2, r2
 c039502:	0952      	lsrs	r2, r2, #5
 c039504:	736a      	strb	r2, [r5, #13]
    return fs_ctx->cfg->num_blocks == 2 ? 1 : 2;
 c039506:	2201      	movs	r2, #1
 c039508:	8999      	ldrh	r1, [r3, #12]
    fs_ctx->meta_block_header.fs_version = ITS_SUPPORTED_VERSION;
 c03950a:	732a      	strb	r2, [r5, #12]
    return fs_ctx->cfg->num_blocks == 2 ? 1 : 2;
 c03950c:	2902      	cmp	r1, #2
 c03950e:	bf0c      	ite	eq
 c039510:	4611      	moveq	r1, r2
 c039512:	2102      	movne	r1, #2
    fs_ctx->active_metablock = ITS_METADATA_BLOCK0;
 c039514:	e9c5 0206 	strd	r0, r2, [r5, #24]
    fs_ctx->meta_block_header.scratch_dblock = its_init_scratch_dblock(fs_ctx);
 c039518:	60a9      	str	r1, [r5, #8]
        its_mblock_file_meta_offset(fs_ctx, fs_ctx->cfg->max_num_files);
 c03951a:	4618      	mov	r0, r3
 c03951c:	8a59      	ldrh	r1, [r3, #18]
 c03951e:	f7ff fe4c 	bl	c0391ba <its_mblock_file_meta_offset.isra.0>
    block_meta.free_size = fs_ctx->cfg->block_size - block_meta.data_start;
 c039522:	895b      	ldrh	r3, [r3, #10]
    err = its_mblock_update_scratch_block_meta(fs_ctx, ITS_LOGICAL_DBLOCK0,
 c039524:	4621      	mov	r1, r4
    block_meta.free_size = fs_ctx->cfg->block_size - block_meta.data_start;
 c039526:	1a1b      	subs	r3, r3, r0
    block_meta.data_start =
 c039528:	9001      	str	r0, [sp, #4]
    err = its_mblock_update_scratch_block_meta(fs_ctx, ITS_LOGICAL_DBLOCK0,
 c03952a:	466a      	mov	r2, sp
 c03952c:	4628      	mov	r0, r5
    block_meta.phy_id = ITS_METADATA_BLOCK0;
 c03952e:	9400      	str	r4, [sp, #0]
    block_meta.free_size = fs_ctx->cfg->block_size - block_meta.data_start;
 c039530:	9302      	str	r3, [sp, #8]
    err = its_mblock_update_scratch_block_meta(fs_ctx, ITS_LOGICAL_DBLOCK0,
 c039532:	f7ff fe0a 	bl	c03914a <its_mblock_update_scratch_block_meta>
    if (err != PSA_SUCCESS) {
 c039536:	4604      	mov	r4, r0
 c039538:	2800      	cmp	r0, #0
 c03953a:	d142      	bne.n	c0395c2 <its_flash_fs_mblock_reset_metablock+0xfc>
    for (i = 0; i < its_num_dedicated_dblocks(fs_ctx); i++) {
 c03953c:	4606      	mov	r6, r0
    block_meta.free_size = fs_ctx->cfg->block_size;
 c03953e:	682b      	ldr	r3, [r5, #0]
    block_meta.data_start = 0;
 c039540:	9001      	str	r0, [sp, #4]
    block_meta.free_size = fs_ctx->cfg->block_size;
 c039542:	895b      	ldrh	r3, [r3, #10]
 c039544:	9302      	str	r3, [sp, #8]
    for (i = 0; i < its_num_dedicated_dblocks(fs_ctx); i++) {
 c039546:	6828      	ldr	r0, [r5, #0]
     return fs_ctx->cfg->num_blocks == 2 ? 0 :
 c039548:	8983      	ldrh	r3, [r0, #12]
 c03954a:	2b02      	cmp	r3, #2
 c03954c:	d123      	bne.n	c039596 <its_flash_fs_mblock_reset_metablock+0xd0>
    if (err != PSA_SUCCESS) {
 c03954e:	2c00      	cmp	r4, #0
 c039550:	d143      	bne.n	c0395da <its_flash_fs_mblock_reset_metablock+0x114>
     return fs_ctx->cfg->num_blocks == 2 ? 0 :
 c039552:	682b      	ldr	r3, [r5, #0]
 c039554:	899b      	ldrh	r3, [r3, #12]
 c039556:	2b02      	cmp	r3, #2
 c039558:	d002      	beq.n	c039560 <its_flash_fs_mblock_reset_metablock+0x9a>
 c03955a:	3b03      	subs	r3, #3
    for (i = 0; i < its_num_dedicated_dblocks(fs_ctx); i++) {
 c03955c:	429c      	cmp	r4, r3
 c03955e:	d324      	bcc.n	c0395aa <its_flash_fs_mblock_reset_metablock+0xe4>
    return (memset(ptr, value, num));
 c039560:	2220      	movs	r2, #32
 c039562:	2100      	movs	r1, #0
 c039564:	a804      	add	r0, sp, #16
 c039566:	f022 f8e2 	bl	c05b72e <memset>
    for (i = 0; i < fs_ctx->cfg->max_num_files; i++) {
 c03956a:	2400      	movs	r4, #0
 c03956c:	682b      	ldr	r3, [r5, #0]
 c03956e:	8a5b      	ldrh	r3, [r3, #18]
 c039570:	42a3      	cmp	r3, r4
 c039572:	d829      	bhi.n	c0395c8 <its_flash_fs_mblock_reset_metablock+0x102>
    err = its_mblock_write_scratch_meta_header(fs_ctx);
 c039574:	4628      	mov	r0, r5
 c039576:	f7ff fdf4 	bl	c039162 <its_mblock_write_scratch_meta_header>
    if (err != PSA_SUCCESS) {
 c03957a:	bb00      	cbnz	r0, c0395be <its_flash_fs_mblock_reset_metablock+0xf8>
    err = fs_ctx->ops->flush(fs_ctx->cfg);
 c03957c:	686b      	ldr	r3, [r5, #4]
 c03957e:	6828      	ldr	r0, [r5, #0]
 c039580:	68db      	ldr	r3, [r3, #12]
 c039582:	4798      	blx	r3
    if (err != PSA_SUCCESS) {
 c039584:	4604      	mov	r4, r0
 c039586:	b9e0      	cbnz	r0, c0395c2 <its_flash_fs_mblock_reset_metablock+0xfc>
    fs_ctx->scratch_metablock = fs_ctx->active_metablock;
 c039588:	e9d5 2306 	ldrd	r2, r3, [r5, #24]
    fs_ctx->active_metablock = tmp_block;
 c03958c:	e9c5 3206 	strd	r3, r2, [r5, #24]
    return PSA_SUCCESS;
 c039590:	e017      	b.n	c0395c2 <its_flash_fs_mblock_reset_metablock+0xfc>
    uint32_t metablock_to_erase_first = ITS_METADATA_BLOCK0;
 c039592:	2600      	movs	r6, #0
 c039594:	e79f      	b.n	c0394d6 <its_flash_fs_mblock_reset_metablock+0x10>
     return fs_ctx->cfg->num_blocks == 2 ? 0 :
 c039596:	3b03      	subs	r3, #3
    for (i = 0; i < its_num_dedicated_dblocks(fs_ctx); i++) {
 c039598:	429e      	cmp	r6, r3
 c03959a:	d2d8      	bcs.n	c03954e <its_flash_fs_mblock_reset_metablock+0x88>
        err |= fs_ctx->ops->erase(fs_ctx->cfg,
 c03959c:	686b      	ldr	r3, [r5, #4]
 c03959e:	1cf1      	adds	r1, r6, #3
 c0395a0:	691b      	ldr	r3, [r3, #16]
 c0395a2:	4798      	blx	r3
    for (i = 0; i < its_num_dedicated_dblocks(fs_ctx); i++) {
 c0395a4:	3601      	adds	r6, #1
        err |= fs_ctx->ops->erase(fs_ctx->cfg,
 c0395a6:	4304      	orrs	r4, r0
    for (i = 0; i < its_num_dedicated_dblocks(fs_ctx); i++) {
 c0395a8:	e7cd      	b.n	c039546 <its_flash_fs_mblock_reset_metablock+0x80>
        block_meta.phy_id = i + its_init_dblock_start(fs_ctx);
 c0395aa:	1ce3      	adds	r3, r4, #3
        err = its_mblock_update_scratch_block_meta(fs_ctx, i + 1, &block_meta);
 c0395ac:	3401      	adds	r4, #1
 c0395ae:	466a      	mov	r2, sp
 c0395b0:	4621      	mov	r1, r4
 c0395b2:	4628      	mov	r0, r5
        block_meta.phy_id = i + its_init_dblock_start(fs_ctx);
 c0395b4:	9300      	str	r3, [sp, #0]
        err = its_mblock_update_scratch_block_meta(fs_ctx, i + 1, &block_meta);
 c0395b6:	f7ff fdc8 	bl	c03914a <its_mblock_update_scratch_block_meta>
        if (err != PSA_SUCCESS) {
 c0395ba:	2800      	cmp	r0, #0
 c0395bc:	d0c9      	beq.n	c039552 <its_flash_fs_mblock_reset_metablock+0x8c>
            return PSA_ERROR_GENERIC_ERROR;
 c0395be:	f06f 0483 	mvn.w	r4, #131	@ 0x83
}
 c0395c2:	4620      	mov	r0, r4
 c0395c4:	b00c      	add	sp, #48	@ 0x30
 c0395c6:	bd70      	pop	{r4, r5, r6, pc}
        err = its_flash_fs_mblock_update_scratch_file_meta(fs_ctx, i,
 c0395c8:	4621      	mov	r1, r4
 c0395ca:	4628      	mov	r0, r5
 c0395cc:	aa04      	add	r2, sp, #16
 c0395ce:	f7ff ff6a 	bl	c0394a6 <its_flash_fs_mblock_update_scratch_file_meta>
        if (err != PSA_SUCCESS) {
 c0395d2:	2800      	cmp	r0, #0
 c0395d4:	d1f3      	bne.n	c0395be <its_flash_fs_mblock_reset_metablock+0xf8>
    for (i = 0; i < fs_ctx->cfg->max_num_files; i++) {
 c0395d6:	3401      	adds	r4, #1
 c0395d8:	e7c8      	b.n	c03956c <its_flash_fs_mblock_reset_metablock+0xa6>
        return PSA_ERROR_STORAGE_FAILURE;
 c0395da:	f06f 0491 	mvn.w	r4, #145	@ 0x91
 c0395de:	e7f0      	b.n	c0395c2 <its_flash_fs_mblock_reset_metablock+0xfc>

0c0395e0 <its_flash_fs_block_to_block_move>:
                                              uint32_t dst_block,
                                              size_t dst_offset,
                                              uint32_t src_block,
                                              size_t src_offset,
                                              size_t size)
{
 c0395e0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c0395e4:	4604      	mov	r4, r0
 c0395e6:	4688      	mov	r8, r1
 c0395e8:	4616      	mov	r6, r2
 c0395ea:	4699      	mov	r9, r3
 c0395ec:	b0c3      	sub	sp, #268	@ 0x10c
 c0395ee:	e9dd a54c 	ldrd	sl, r5, [sp, #304]	@ 0x130
    psa_status_t status;
    size_t bytes_to_move;
    uint8_t dst_block_data_copy[ITS_MAX_BLOCK_DATA_COPY];

    while (size > 0) {
 c0395f2:	b91d      	cbnz	r5, c0395fc <its_flash_fs_block_to_block_move+0x1c>

        /* Decrement remaining size to move */
        size -= bytes_to_move;
    }

    return PSA_SUCCESS;
 c0395f4:	4628      	mov	r0, r5
}
 c0395f6:	b043      	add	sp, #268	@ 0x10c
 c0395f8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        bytes_to_move = ITS_UTILS_MIN(size, ITS_MAX_BLOCK_DATA_COPY);
 c0395fc:	f5b5 7f80 	cmp.w	r5, #256	@ 0x100
 c039600:	462f      	mov	r7, r5
 c039602:	bf28      	it	cs
 c039604:	f44f 7780 	movcs.w	r7, #256	@ 0x100
        status = fs_ctx->ops->read(fs_ctx->cfg, src_block, dst_block_data_copy,
 c039608:	6863      	ldr	r3, [r4, #4]
 c03960a:	9700      	str	r7, [sp, #0]
 c03960c:	f8d3 b004 	ldr.w	fp, [r3, #4]
 c039610:	4649      	mov	r1, r9
 c039612:	4653      	mov	r3, sl
 c039614:	6820      	ldr	r0, [r4, #0]
 c039616:	aa02      	add	r2, sp, #8
 c039618:	47d8      	blx	fp
        if (status != PSA_SUCCESS) {
 c03961a:	2800      	cmp	r0, #0
 c03961c:	d1eb      	bne.n	c0395f6 <its_flash_fs_block_to_block_move+0x16>
        status = fs_ctx->ops->write(fs_ctx->cfg, dst_block, dst_block_data_copy,
 c03961e:	6863      	ldr	r3, [r4, #4]
 c039620:	9700      	str	r7, [sp, #0]
 c039622:	f8d3 b008 	ldr.w	fp, [r3, #8]
 c039626:	4641      	mov	r1, r8
 c039628:	4633      	mov	r3, r6
 c03962a:	6820      	ldr	r0, [r4, #0]
 c03962c:	aa02      	add	r2, sp, #8
 c03962e:	47d8      	blx	fp
        if (status != PSA_SUCCESS) {
 c039630:	2800      	cmp	r0, #0
 c039632:	d1e0      	bne.n	c0395f6 <its_flash_fs_block_to_block_move+0x16>
        dst_offset += bytes_to_move;
 c039634:	443e      	add	r6, r7
        src_offset += bytes_to_move;
 c039636:	44ba      	add	sl, r7
        size -= bytes_to_move;
 c039638:	1bed      	subs	r5, r5, r7
 c03963a:	e7da      	b.n	c0395f2 <its_flash_fs_block_to_block_move+0x12>

0c03963c <its_flash_fs_mblock_cp_file_meta>:
{
 c03963c:	b537      	push	{r0, r1, r2, r4, r5, lr}
 c03963e:	6805      	ldr	r5, [r0, #0]
 c039640:	4604      	mov	r4, r0
    size_t pos_start = its_mblock_file_meta_offset(fs_ctx, idx_start);
 c039642:	4628      	mov	r0, r5
 c039644:	f7ff fdb9 	bl	c0391ba <its_mblock_file_meta_offset.isra.0>
{
 c039648:	4613      	mov	r3, r2
    size_t pos_start = its_mblock_file_meta_offset(fs_ctx, idx_start);
 c03964a:	4602      	mov	r2, r0
    size_t pos_end = its_mblock_file_meta_offset(fs_ctx, idx_end);
 c03964c:	4619      	mov	r1, r3
 c03964e:	4628      	mov	r0, r5
 c039650:	f7ff fdb3 	bl	c0391ba <its_mblock_file_meta_offset.isra.0>
    return its_flash_fs_block_to_block_move(fs_ctx, fs_ctx->scratch_metablock,
 c039654:	1a80      	subs	r0, r0, r2
 c039656:	e9cd 2000 	strd	r2, r0, [sp]
 c03965a:	4620      	mov	r0, r4
 c03965c:	e9d4 3106 	ldrd	r3, r1, [r4, #24]
 c039660:	f7ff ffbe 	bl	c0395e0 <its_flash_fs_block_to_block_move>
}
 c039664:	b003      	add	sp, #12
 c039666:	bd30      	pop	{r4, r5, pc}

0c039668 <its_flash_fs_mblock_migrate_lb0_data_to_scratch>:
{
 c039668:	b510      	push	{r4, lr}
 c03966a:	b086      	sub	sp, #24
    err = its_flash_fs_mblock_read_block_metadata(fs_ctx, ITS_LOGICAL_DBLOCK0,
 c03966c:	2100      	movs	r1, #0
 c03966e:	aa02      	add	r2, sp, #8
{
 c039670:	4604      	mov	r4, r0
    err = its_flash_fs_mblock_read_block_metadata(fs_ctx, ITS_LOGICAL_DBLOCK0,
 c039672:	f7ff fea1 	bl	c0393b8 <its_flash_fs_mblock_read_block_metadata>
    if (err != PSA_SUCCESS) {
 c039676:	b960      	cbnz	r0, c039692 <its_flash_fs_mblock_migrate_lb0_data_to_scratch+0x2a>
    data_size = (fs_ctx->cfg->block_size - block_meta.data_start)
 c039678:	6823      	ldr	r3, [r4, #0]
 c03967a:	9a03      	ldr	r2, [sp, #12]
 c03967c:	9904      	ldr	r1, [sp, #16]
 c03967e:	895b      	ldrh	r3, [r3, #10]
 c039680:	4411      	add	r1, r2
 c039682:	1a5b      	subs	r3, r3, r1
    return its_flash_fs_block_to_block_move(fs_ctx, fs_ctx->scratch_metablock,
 c039684:	e9cd 2300 	strd	r2, r3, [sp]
 c039688:	4620      	mov	r0, r4
 c03968a:	e9d4 3106 	ldrd	r3, r1, [r4, #24]
 c03968e:	f7ff ffa7 	bl	c0395e0 <its_flash_fs_block_to_block_move>
}
 c039692:	b006      	add	sp, #24
 c039694:	bd10      	pop	{r4, pc}

0c039696 <its_flash_fs_mblock_update_scratch_block_meta>:
{
 c039696:	b5f0      	push	{r4, r5, r6, r7, lr}
 c039698:	4605      	mov	r5, r0
    if (lblock == ITS_LOGICAL_DBLOCK0) {
 c03969a:	460c      	mov	r4, r1
{
 c03969c:	b087      	sub	sp, #28
    if (lblock == ITS_LOGICAL_DBLOCK0) {
 c03969e:	b909      	cbnz	r1, c0396a4 <its_flash_fs_mblock_update_scratch_block_meta+0xe>
        block_meta->phy_id = fs_ctx->scratch_metablock;
 c0396a0:	69c3      	ldr	r3, [r0, #28]
 c0396a2:	6013      	str	r3, [r2, #0]
    err = its_mblock_update_scratch_block_meta(fs_ctx, lblock, block_meta);
 c0396a4:	4621      	mov	r1, r4
 c0396a6:	4628      	mov	r0, r5
 c0396a8:	f7ff fd4f 	bl	c03914a <its_mblock_update_scratch_block_meta>
    if (err != PSA_SUCCESS) {
 c0396ac:	4601      	mov	r1, r0
 c0396ae:	b9c0      	cbnz	r0, c0396e2 <its_flash_fs_mblock_update_scratch_block_meta+0x4c>
    meta_block = fs_ctx->active_metablock;
 c0396b0:	e9d5 7606 	ldrd	r7, r6, [r5, #24]
    if (lblock != ITS_LOGICAL_DBLOCK0) {
 c0396b4:	b97c      	cbnz	r4, c0396d6 <its_flash_fs_mblock_update_scratch_block_meta+0x40>
    size = its_mblock_file_meta_offset(fs_ctx, 0) - pos;
 c0396b6:	2100      	movs	r1, #0
 c0396b8:	6828      	ldr	r0, [r5, #0]
 c0396ba:	f7ff fd7e 	bl	c0391ba <its_mblock_file_meta_offset.isra.0>
    return ITS_BLOCK_META_HEADER_SIZE + (lblock * ITS_BLOCK_METADATA_SIZE);
 c0396be:	1ca2      	adds	r2, r4, #2
 c0396c0:	0112      	lsls	r2, r2, #4
    size = its_mblock_file_meta_offset(fs_ctx, 0) - pos;
 c0396c2:	1a80      	subs	r0, r0, r2
    return its_flash_fs_block_to_block_move(fs_ctx, scratch_block, pos,
 c0396c4:	e9cd 2000 	strd	r2, r0, [sp]
 c0396c8:	463b      	mov	r3, r7
 c0396ca:	4631      	mov	r1, r6
 c0396cc:	4628      	mov	r0, r5
 c0396ce:	f7ff ff87 	bl	c0395e0 <its_flash_fs_block_to_block_move>
}
 c0396d2:	b007      	add	sp, #28
 c0396d4:	bdf0      	pop	{r4, r5, r6, r7, pc}
        err = its_flash_fs_mblock_read_block_metadata(fs_ctx,
 c0396d6:	4628      	mov	r0, r5
 c0396d8:	aa02      	add	r2, sp, #8
 c0396da:	f7ff fe6d 	bl	c0393b8 <its_flash_fs_mblock_read_block_metadata>
        if (err != PSA_SUCCESS) {
 c0396de:	4601      	mov	r1, r0
 c0396e0:	b110      	cbz	r0, c0396e8 <its_flash_fs_mblock_update_scratch_block_meta+0x52>
        return PSA_ERROR_GENERIC_ERROR;
 c0396e2:	f06f 0083 	mvn.w	r0, #131	@ 0x83
 c0396e6:	e7f4      	b.n	c0396d2 <its_flash_fs_mblock_update_scratch_block_meta+0x3c>
        err = its_mblock_update_scratch_block_meta(fs_ctx, ITS_LOGICAL_DBLOCK0,
 c0396e8:	4628      	mov	r0, r5
 c0396ea:	aa02      	add	r2, sp, #8
        block_meta.phy_id = scratch_block;
 c0396ec:	9602      	str	r6, [sp, #8]
        err = its_mblock_update_scratch_block_meta(fs_ctx, ITS_LOGICAL_DBLOCK0,
 c0396ee:	f7ff fd2c 	bl	c03914a <its_mblock_update_scratch_block_meta>
        if (err != PSA_SUCCESS) {
 c0396f2:	2800      	cmp	r0, #0
 c0396f4:	d1f5      	bne.n	c0396e2 <its_flash_fs_mblock_update_scratch_block_meta+0x4c>
        if (lblock > 1) {
 c0396f6:	2c01      	cmp	r4, #1
 c0396f8:	d0dd      	beq.n	c0396b6 <its_flash_fs_mblock_update_scratch_block_meta+0x20>
            err = its_flash_fs_block_to_block_move(fs_ctx, scratch_block, pos,
 c0396fa:	2220      	movs	r2, #32
    return ITS_BLOCK_META_HEADER_SIZE + (lblock * ITS_BLOCK_METADATA_SIZE);
 c0396fc:	0123      	lsls	r3, r4, #4
            size = its_mblock_block_meta_offset(lblock) - pos;
 c0396fe:	3b10      	subs	r3, #16
            err = its_flash_fs_block_to_block_move(fs_ctx, scratch_block, pos,
 c039700:	9301      	str	r3, [sp, #4]
 c039702:	4631      	mov	r1, r6
 c039704:	463b      	mov	r3, r7
 c039706:	4628      	mov	r0, r5
 c039708:	9200      	str	r2, [sp, #0]
 c03970a:	f7ff ff69 	bl	c0395e0 <its_flash_fs_block_to_block_move>
            if (err != PSA_SUCCESS) {
 c03970e:	2800      	cmp	r0, #0
 c039710:	d0d1      	beq.n	c0396b6 <its_flash_fs_mblock_update_scratch_block_meta+0x20>
 c039712:	e7de      	b.n	c0396d2 <its_flash_fs_mblock_update_scratch_block_meta+0x3c>

0c039714 <its_flash_nor_init>:
{
    return cfg->flash_area_addr + (block_id * cfg->block_size) + offset;
}

static psa_status_t its_flash_nor_init(const struct its_flash_fs_config_t *cfg)
{
 c039714:	b508      	push	{r3, lr}
    int32_t err;

    err = ((ARM_DRIVER_FLASH *)cfg->flash_dev)->Initialize(NULL);
 c039716:	6803      	ldr	r3, [r0, #0]
 c039718:	2000      	movs	r0, #0
 c03971a:	689b      	ldr	r3, [r3, #8]
 c03971c:	4798      	blx	r3
    if (err != ARM_DRIVER_OK) {
        return PSA_ERROR_STORAGE_FAILURE;
 c03971e:	2800      	cmp	r0, #0
    }

    return PSA_SUCCESS;
}
 c039720:	bf18      	it	ne
 c039722:	f06f 0091 	mvnne.w	r0, #145	@ 0x91
 c039726:	bd08      	pop	{r3, pc}

0c039728 <its_flash_nor_read>:

static psa_status_t its_flash_nor_read(const struct its_flash_fs_config_t *cfg,
                                       uint32_t block_id, uint8_t *buff,
                                       size_t offset, size_t size)
{
 c039728:	b570      	push	{r4, r5, r6, lr}
 c03972a:	460e      	mov	r6, r1
 c03972c:	4611      	mov	r1, r2
    return cfg->flash_area_addr + (block_id * cfg->block_size) + offset;
 c03972e:	6842      	ldr	r2, [r0, #4]
 c039730:	8945      	ldrh	r5, [r0, #10]
 c039732:	4413      	add	r3, r2
    int32_t err;
    uint32_t addr = get_phys_address(cfg, block_id, offset);

    err = ((ARM_DRIVER_FLASH *)cfg->flash_dev)->ReadData(addr, buff, size);
 c039734:	6802      	ldr	r2, [r0, #0]
 c039736:	fb06 3005 	mla	r0, r6, r5, r3
 c03973a:	6954      	ldr	r4, [r2, #20]
 c03973c:	9a04      	ldr	r2, [sp, #16]
 c03973e:	47a0      	blx	r4
    if (err != ARM_DRIVER_OK) {
        return PSA_ERROR_STORAGE_FAILURE;
 c039740:	2800      	cmp	r0, #0
    }

    return PSA_SUCCESS;
}
 c039742:	bf18      	it	ne
 c039744:	f06f 0091 	mvnne.w	r0, #145	@ 0x91
 c039748:	bd70      	pop	{r4, r5, r6, pc}

0c03974a <its_flash_nor_write>:

static psa_status_t its_flash_nor_write(const struct its_flash_fs_config_t *cfg,
                                        uint32_t block_id, const uint8_t *buff,
                                        size_t offset, size_t size)
{
 c03974a:	b570      	push	{r4, r5, r6, lr}
 c03974c:	460e      	mov	r6, r1
 c03974e:	4611      	mov	r1, r2
    return cfg->flash_area_addr + (block_id * cfg->block_size) + offset;
 c039750:	6842      	ldr	r2, [r0, #4]
 c039752:	8945      	ldrh	r5, [r0, #10]
 c039754:	4413      	add	r3, r2
    int32_t err;
    uint32_t addr = get_phys_address(cfg, block_id, offset);

    err = ((ARM_DRIVER_FLASH *)cfg->flash_dev)->ProgramData(addr, buff, size);
 c039756:	6802      	ldr	r2, [r0, #0]
 c039758:	fb06 3005 	mla	r0, r6, r5, r3
 c03975c:	6994      	ldr	r4, [r2, #24]
 c03975e:	9a04      	ldr	r2, [sp, #16]
 c039760:	47a0      	blx	r4
    if (err != ARM_DRIVER_OK) {
        return PSA_ERROR_STORAGE_FAILURE;
 c039762:	2800      	cmp	r0, #0
    }

    return PSA_SUCCESS;
}
 c039764:	bf18      	it	ne
 c039766:	f06f 0091 	mvnne.w	r0, #145	@ 0x91
 c03976a:	bd70      	pop	{r4, r5, r6, pc}

0c03976c <its_flash_nor_flush>:
    /* Nothing needs to be done for NOR flash, as writes are commited to flash
     * immediately.
     */
    (void)cfg;
    return PSA_SUCCESS;
}
 c03976c:	2000      	movs	r0, #0
 c03976e:	4770      	bx	lr

0c039770 <its_flash_nor_erase>:

static psa_status_t its_flash_nor_erase(const struct its_flash_fs_config_t *cfg,
                                        uint32_t block_id)
{
 c039770:	b570      	push	{r4, r5, r6, lr}
 c039772:	4604      	mov	r4, r0
 c039774:	460e      	mov	r6, r1
    int32_t err;
    uint32_t addr;
    size_t offset;

    for (offset = 0; offset < cfg->block_size; offset += cfg->sector_size) {
 c039776:	2500      	movs	r5, #0
 c039778:	8963      	ldrh	r3, [r4, #10]
 c03977a:	42ab      	cmp	r3, r5
 c03977c:	d801      	bhi.n	c039782 <its_flash_nor_erase+0x12>
        if (err != ARM_DRIVER_OK) {
            return PSA_ERROR_STORAGE_FAILURE;
        }
    }

    return PSA_SUCCESS;
 c03977e:	2000      	movs	r0, #0
}
 c039780:	bd70      	pop	{r4, r5, r6, pc}
    return cfg->flash_area_addr + (block_id * cfg->block_size) + offset;
 c039782:	6860      	ldr	r0, [r4, #4]
 c039784:	fb06 0003 	mla	r0, r6, r3, r0
        err = ((ARM_DRIVER_FLASH *)cfg->flash_dev)->EraseSector(addr);
 c039788:	6823      	ldr	r3, [r4, #0]
 c03978a:	4428      	add	r0, r5
 c03978c:	69db      	ldr	r3, [r3, #28]
 c03978e:	4798      	blx	r3
        if (err != ARM_DRIVER_OK) {
 c039790:	b910      	cbnz	r0, c039798 <its_flash_nor_erase+0x28>
    for (offset = 0; offset < cfg->block_size; offset += cfg->sector_size) {
 c039792:	8923      	ldrh	r3, [r4, #8]
 c039794:	441d      	add	r5, r3
 c039796:	e7ef      	b.n	c039778 <its_flash_nor_erase+0x8>
            return PSA_ERROR_STORAGE_FAILURE;
 c039798:	f06f 0091 	mvn.w	r0, #145	@ 0x91
 c03979c:	e7f0      	b.n	c039780 <its_flash_nor_erase+0x10>

0c03979e <its_utils_check_contained_in>:
psa_status_t its_utils_check_contained_in(size_t superset_size,
                                          size_t subset_offset,
                                          size_t subset_size)
{
    /* Check that subset_offset is valid */
    if (subset_offset > superset_size) {
 c03979e:	4281      	cmp	r1, r0
 c0397a0:	d806      	bhi.n	c0397b0 <its_utils_check_contained_in+0x12>

    /* Check that subset_offset + subset_size fits in superset_size.
     * The previous check passed, so we know that subset_offset <= superset_size
     * and so the right hand side of the inequality cannot underflow.
     */
    if (subset_size > (superset_size - subset_offset)) {
 c0397a2:	1a40      	subs	r0, r0, r1
        return PSA_ERROR_INVALID_ARGUMENT;
 c0397a4:	4290      	cmp	r0, r2
 c0397a6:	bf2c      	ite	cs
 c0397a8:	2000      	movcs	r0, #0
 c0397aa:	f06f 0086 	mvncc.w	r0, #134	@ 0x86
 c0397ae:	4770      	bx	lr
 c0397b0:	f06f 0086 	mvn.w	r0, #134	@ 0x86
        return PSA_ERROR_INVALID_ARGUMENT;
    }

    return PSA_SUCCESS;
}
 c0397b4:	4770      	bx	lr

0c0397b6 <its_utils_validate_fid>:
psa_status_t its_utils_validate_fid(const uint8_t *fid)
{
    uint32_t fid_size = ITS_FILE_ID_SIZE;

    /* A file ID is valid if it is non-zero */
    while (fid_size--) {
 c0397b6:	f100 030c 	add.w	r3, r0, #12
 c0397ba:	4298      	cmp	r0, r3
 c0397bc:	d102      	bne.n	c0397c4 <its_utils_validate_fid+0xe>
        if (*fid++) {
            return PSA_SUCCESS;
        }
    }

    return PSA_ERROR_DOES_NOT_EXIST;
 c0397be:	f06f 008b 	mvn.w	r0, #139	@ 0x8b
 c0397c2:	4770      	bx	lr
        if (*fid++) {
 c0397c4:	f810 2b01 	ldrb.w	r2, [r0], #1
 c0397c8:	2a00      	cmp	r2, #0
 c0397ca:	d0f6      	beq.n	c0397ba <its_utils_validate_fid+0x4>
            return PSA_SUCCESS;
 c0397cc:	2000      	movs	r0, #0
}
 c0397ce:	4770      	bx	lr

0c0397d0 <tfm_its_remove_ipc>:

    return status;
}

static psa_status_t tfm_its_remove_ipc(void)
{
 c0397d0:	b513      	push	{r0, r1, r4, lr}
    psa_storage_uid_t uid;
    size_t num;

    if (msg.in_size[0] != sizeof(uid)) {
 c0397d2:	4c0a      	ldr	r4, [pc, #40]	@ (c0397fc <tfm_its_remove_ipc+0x2c>)
 c0397d4:	6923      	ldr	r3, [r4, #16]
 c0397d6:	2b08      	cmp	r3, #8
 c0397d8:	d003      	beq.n	c0397e2 <tfm_its_remove_ipc+0x12>
        /* The input argument size is incorrect */
        return PSA_ERROR_PROGRAMMER_ERROR;
 c0397da:	f06f 0080 	mvn.w	r0, #128	@ 0x80
    if (num != sizeof(uid)) {
        return PSA_ERROR_PROGRAMMER_ERROR;
    }

    return tfm_its_remove(msg.client_id, uid);
}
 c0397de:	b002      	add	sp, #8
 c0397e0:	bd10      	pop	{r4, pc}
    num = psa_read(msg.handle, 0, &uid, sizeof(uid));
 c0397e2:	466a      	mov	r2, sp
 c0397e4:	2100      	movs	r1, #0
 c0397e6:	6860      	ldr	r0, [r4, #4]
 c0397e8:	f003 f812 	bl	c03c810 <psa_read>
    if (num != sizeof(uid)) {
 c0397ec:	2808      	cmp	r0, #8
 c0397ee:	d1f4      	bne.n	c0397da <tfm_its_remove_ipc+0xa>
    return tfm_its_remove(msg.client_id, uid);
 c0397f0:	e9dd 2300 	ldrd	r2, r3, [sp]
 c0397f4:	68a0      	ldr	r0, [r4, #8]
 c0397f6:	f7ff f9af 	bl	c038b58 <tfm_its_remove>
 c0397fa:	e7f0      	b.n	c0397de <tfm_its_remove_ipc+0xe>
 c0397fc:	30039188 	.word	0x30039188

0c039800 <tfm_its_get_info_ipc>:
{
 c039800:	b5f0      	push	{r4, r5, r6, r7, lr}
    if (msg.in_size[0] != sizeof(uid) ||
 c039802:	4d12      	ldr	r5, [pc, #72]	@ (c03984c <tfm_its_get_info_ipc+0x4c>)
{
 c039804:	b089      	sub	sp, #36	@ 0x24
    if (msg.in_size[0] != sizeof(uid) ||
 c039806:	692b      	ldr	r3, [r5, #16]
 c039808:	2b08      	cmp	r3, #8
 c03980a:	d004      	beq.n	c039816 <tfm_its_get_info_ipc+0x16>
        return PSA_ERROR_PROGRAMMER_ERROR;
 c03980c:	f06f 0480 	mvn.w	r4, #128	@ 0x80
}
 c039810:	4620      	mov	r0, r4
 c039812:	b009      	add	sp, #36	@ 0x24
 c039814:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if (msg.in_size[0] != sizeof(uid) ||
 c039816:	6a2f      	ldr	r7, [r5, #32]
 c039818:	2f0c      	cmp	r7, #12
 c03981a:	d1f7      	bne.n	c03980c <tfm_its_get_info_ipc+0xc>
    num = psa_read(msg.handle, 0, &uid, sizeof(uid));
 c03981c:	2100      	movs	r1, #0
 c03981e:	6868      	ldr	r0, [r5, #4]
 c039820:	aa02      	add	r2, sp, #8
 c039822:	f002 fff5 	bl	c03c810 <psa_read>
    if (num != sizeof(uid)) {
 c039826:	2808      	cmp	r0, #8
 c039828:	d1f0      	bne.n	c03980c <tfm_its_get_info_ipc+0xc>
    status = tfm_its_get_info(msg.client_id, uid, &info);
 c03982a:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 c03982e:	ae05      	add	r6, sp, #20
 c039830:	9600      	str	r6, [sp, #0]
 c039832:	68a8      	ldr	r0, [r5, #8]
 c039834:	f7ff f96a 	bl	c038b0c <tfm_its_get_info>
    if (status == PSA_SUCCESS) {
 c039838:	4604      	mov	r4, r0
 c03983a:	2800      	cmp	r0, #0
 c03983c:	d1e8      	bne.n	c039810 <tfm_its_get_info_ipc+0x10>
        psa_write(msg.handle, 0, &info, sizeof(info));
 c03983e:	4601      	mov	r1, r0
 c039840:	463b      	mov	r3, r7
 c039842:	4632      	mov	r2, r6
 c039844:	6868      	ldr	r0, [r5, #4]
 c039846:	f002 ffe5 	bl	c03c814 <psa_write>
 c03984a:	e7e1      	b.n	c039810 <tfm_its_get_info_ipc+0x10>
 c03984c:	30039188 	.word	0x30039188

0c039850 <tfm_its_get_ipc>:
{
 c039850:	b570      	push	{r4, r5, r6, lr}
    if (msg.in_size[0] != sizeof(uid) ||
 c039852:	4c13      	ldr	r4, [pc, #76]	@ (c0398a0 <tfm_its_get_ipc+0x50>)
{
 c039854:	b088      	sub	sp, #32
    if (msg.in_size[0] != sizeof(uid) ||
 c039856:	6923      	ldr	r3, [r4, #16]
 c039858:	2b08      	cmp	r3, #8
 c03985a:	d003      	beq.n	c039864 <tfm_its_get_ipc+0x14>
        return PSA_ERROR_PROGRAMMER_ERROR;
 c03985c:	f06f 0080 	mvn.w	r0, #128	@ 0x80
}
 c039860:	b008      	add	sp, #32
 c039862:	bd70      	pop	{r4, r5, r6, pc}
    if (msg.in_size[0] != sizeof(uid) ||
 c039864:	6965      	ldr	r5, [r4, #20]
 c039866:	2d04      	cmp	r5, #4
 c039868:	d1f8      	bne.n	c03985c <tfm_its_get_ipc+0xc>
    num = psa_read(msg.handle, 0, &uid, sizeof(uid));
 c03986a:	2100      	movs	r1, #0
 c03986c:	6860      	ldr	r0, [r4, #4]
 c03986e:	aa06      	add	r2, sp, #24
    data_size = msg.out_size[0];
 c039870:	6a26      	ldr	r6, [r4, #32]
    num = psa_read(msg.handle, 0, &uid, sizeof(uid));
 c039872:	f002 ffcd 	bl	c03c810 <psa_read>
    if (num != sizeof(uid)) {
 c039876:	2808      	cmp	r0, #8
 c039878:	d1f0      	bne.n	c03985c <tfm_its_get_ipc+0xc>
    num = psa_read(msg.handle, 1, &data_offset, sizeof(data_offset));
 c03987a:	462b      	mov	r3, r5
 c03987c:	2101      	movs	r1, #1
 c03987e:	6860      	ldr	r0, [r4, #4]
 c039880:	aa04      	add	r2, sp, #16
 c039882:	f002 ffc5 	bl	c03c810 <psa_read>
    if (num != sizeof(data_offset)) {
 c039886:	2804      	cmp	r0, #4
 c039888:	d1e8      	bne.n	c03985c <tfm_its_get_ipc+0xc>
    return tfm_its_get(msg.client_id, uid, data_offset, data_size,
 c03988a:	ab05      	add	r3, sp, #20
 c03988c:	e9cd 6301 	strd	r6, r3, [sp, #4]
 c039890:	9b04      	ldr	r3, [sp, #16]
 c039892:	9300      	str	r3, [sp, #0]
 c039894:	68a0      	ldr	r0, [r4, #8]
 c039896:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
 c03989a:	f7ff f8e3 	bl	c038a64 <tfm_its_get>
 c03989e:	e7df      	b.n	c039860 <tfm_its_get_ipc+0x10>
 c0398a0:	30039188 	.word	0x30039188

0c0398a4 <tfm_its_set_ipc>:
{
 c0398a4:	b570      	push	{r4, r5, r6, lr}
    if (msg.in_size[0] != sizeof(uid) ||
 c0398a6:	4c12      	ldr	r4, [pc, #72]	@ (c0398f0 <tfm_its_set_ipc+0x4c>)
{
 c0398a8:	b086      	sub	sp, #24
    if (msg.in_size[0] != sizeof(uid) ||
 c0398aa:	6923      	ldr	r3, [r4, #16]
 c0398ac:	2b08      	cmp	r3, #8
 c0398ae:	d003      	beq.n	c0398b8 <tfm_its_set_ipc+0x14>
        return PSA_ERROR_PROGRAMMER_ERROR;
 c0398b0:	f06f 0080 	mvn.w	r0, #128	@ 0x80
}
 c0398b4:	b006      	add	sp, #24
 c0398b6:	bd70      	pop	{r4, r5, r6, pc}
    if (msg.in_size[0] != sizeof(uid) ||
 c0398b8:	69a5      	ldr	r5, [r4, #24]
 c0398ba:	2d04      	cmp	r5, #4
 c0398bc:	d1f8      	bne.n	c0398b0 <tfm_its_set_ipc+0xc>
    num = psa_read(msg.handle, 0, &uid, sizeof(uid));
 c0398be:	2100      	movs	r1, #0
 c0398c0:	6860      	ldr	r0, [r4, #4]
 c0398c2:	aa04      	add	r2, sp, #16
    data_length = msg.in_size[1];
 c0398c4:	6966      	ldr	r6, [r4, #20]
    num = psa_read(msg.handle, 0, &uid, sizeof(uid));
 c0398c6:	f002 ffa3 	bl	c03c810 <psa_read>
    if (num != sizeof(uid)) {
 c0398ca:	2808      	cmp	r0, #8
 c0398cc:	d1f0      	bne.n	c0398b0 <tfm_its_set_ipc+0xc>
    num = psa_read(msg.handle, 2, &create_flags, sizeof(create_flags));
 c0398ce:	462b      	mov	r3, r5
 c0398d0:	2102      	movs	r1, #2
 c0398d2:	6860      	ldr	r0, [r4, #4]
 c0398d4:	aa03      	add	r2, sp, #12
 c0398d6:	f002 ff9b 	bl	c03c810 <psa_read>
    if (num != sizeof(create_flags)) {
 c0398da:	2804      	cmp	r0, #4
 c0398dc:	d1e8      	bne.n	c0398b0 <tfm_its_set_ipc+0xc>
    return tfm_its_set(msg.client_id, uid, data_length, create_flags);
 c0398de:	9b03      	ldr	r3, [sp, #12]
 c0398e0:	e9cd 6300 	strd	r6, r3, [sp]
 c0398e4:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 c0398e8:	68a0      	ldr	r0, [r4, #8]
 c0398ea:	f7ff f865 	bl	c0389b8 <tfm_its_set>
 c0398ee:	e7e1      	b.n	c0398b4 <tfm_its_set_ipc+0x10>
 c0398f0:	30039188 	.word	0x30039188

0c0398f4 <its_signal_handle>:

static void its_signal_handle(psa_signal_t signal, its_func_t pfn)
{
 c0398f4:	b538      	push	{r3, r4, r5, lr}
    psa_status_t status;

    status = psa_get(signal, &msg);
 c0398f6:	4c0c      	ldr	r4, [pc, #48]	@ (c039928 <its_signal_handle+0x34>)
{
 c0398f8:	460d      	mov	r5, r1
    status = psa_get(signal, &msg);
 c0398fa:	4621      	mov	r1, r4
 c0398fc:	f002 ff86 	bl	c03c80c <psa_get>
    if (status != PSA_SUCCESS) {
 c039900:	4601      	mov	r1, r0
 c039902:	b980      	cbnz	r0, c039926 <its_signal_handle+0x32>
        return;
    }

    switch (msg.type) {
 c039904:	6823      	ldr	r3, [r4, #0]
 c039906:	2b00      	cmp	r3, #0
 c039908:	da05      	bge.n	c039916 <its_signal_handle+0x22>
 c03990a:	3302      	adds	r3, #2
 c03990c:	da06      	bge.n	c03991c <its_signal_handle+0x28>
        psa_reply(msg.handle, PSA_SUCCESS);
        break;
    default:
        psa_panic();
    }
}
 c03990e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
        psa_panic();
 c039912:	f002 bf83 	b.w	c03c81c <psa_panic>
    switch (msg.type) {
 c039916:	d1fa      	bne.n	c03990e <its_signal_handle+0x1a>
        status = pfn();
 c039918:	47a8      	blx	r5
 c03991a:	4601      	mov	r1, r0
        psa_reply(msg.handle, status);
 c03991c:	6860      	ldr	r0, [r4, #4]
}
 c03991e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
        psa_reply(msg.handle, status);
 c039922:	f002 bf79 	b.w	c03c818 <psa_reply>
}
 c039926:	bd38      	pop	{r3, r4, r5, pc}
 c039928:	30039188 	.word	0x30039188

0c03992c <tfm_its_req_mngr_init>:
#endif /* !defined(TFM_PSA_API) */

psa_status_t tfm_its_req_mngr_init(void)
{
 c03992c:	b570      	push	{r4, r5, r6, lr}
#ifdef TFM_PSA_API
    psa_signal_t signals = 0;

    if (tfm_its_init() != PSA_SUCCESS) {
 c03992e:	f7fe ffc7 	bl	c0388c0 <tfm_its_init>
 c039932:	b108      	cbz	r0, c039938 <tfm_its_req_mngr_init+0xc>
        psa_panic();
 c039934:	f002 ff72 	bl	c03c81c <psa_panic>
        } else if (signals & TFM_ITS_GET_SIGNAL) {
            its_signal_handle(TFM_ITS_GET_SIGNAL, tfm_its_get_ipc);
        } else if (signals & TFM_ITS_GET_INFO_SIGNAL) {
            its_signal_handle(TFM_ITS_GET_INFO_SIGNAL, tfm_its_get_info_ipc);
        } else if (signals & TFM_ITS_REMOVE_SIGNAL) {
            its_signal_handle(TFM_ITS_REMOVE_SIGNAL, tfm_its_remove_ipc);
 c039938:	4c10      	ldr	r4, [pc, #64]	@ (c03997c <tfm_its_req_mngr_init+0x50>)
            its_signal_handle(TFM_ITS_GET_INFO_SIGNAL, tfm_its_get_info_ipc);
 c03993a:	4d11      	ldr	r5, [pc, #68]	@ (c039980 <tfm_its_req_mngr_init+0x54>)
            its_signal_handle(TFM_ITS_GET_SIGNAL, tfm_its_get_ipc);
 c03993c:	4e11      	ldr	r6, [pc, #68]	@ (c039984 <tfm_its_req_mngr_init+0x58>)
        signals = psa_wait(PSA_WAIT_ANY, PSA_BLOCK);
 c03993e:	f04f 4100 	mov.w	r1, #2147483648	@ 0x80000000
 c039942:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 c039946:	f002 ff5f 	bl	c03c808 <psa_wait>
        if (signals & TFM_ITS_SET_SIGNAL) {
 c03994a:	06c3      	lsls	r3, r0, #27
 c03994c:	d504      	bpl.n	c039958 <tfm_its_req_mngr_init+0x2c>
            its_signal_handle(TFM_ITS_SET_SIGNAL, tfm_its_set_ipc);
 c03994e:	2010      	movs	r0, #16
 c039950:	490d      	ldr	r1, [pc, #52]	@ (c039988 <tfm_its_req_mngr_init+0x5c>)
            its_signal_handle(TFM_ITS_REMOVE_SIGNAL, tfm_its_remove_ipc);
 c039952:	f7ff ffcf 	bl	c0398f4 <its_signal_handle>
 c039956:	e7f2      	b.n	c03993e <tfm_its_req_mngr_init+0x12>
        } else if (signals & TFM_ITS_GET_SIGNAL) {
 c039958:	0681      	lsls	r1, r0, #26
 c03995a:	d502      	bpl.n	c039962 <tfm_its_req_mngr_init+0x36>
            its_signal_handle(TFM_ITS_GET_SIGNAL, tfm_its_get_ipc);
 c03995c:	4631      	mov	r1, r6
 c03995e:	2020      	movs	r0, #32
 c039960:	e7f7      	b.n	c039952 <tfm_its_req_mngr_init+0x26>
        } else if (signals & TFM_ITS_GET_INFO_SIGNAL) {
 c039962:	0642      	lsls	r2, r0, #25
 c039964:	d502      	bpl.n	c03996c <tfm_its_req_mngr_init+0x40>
            its_signal_handle(TFM_ITS_GET_INFO_SIGNAL, tfm_its_get_info_ipc);
 c039966:	4629      	mov	r1, r5
 c039968:	2040      	movs	r0, #64	@ 0x40
 c03996a:	e7f2      	b.n	c039952 <tfm_its_req_mngr_init+0x26>
        } else if (signals & TFM_ITS_REMOVE_SIGNAL) {
 c03996c:	0603      	lsls	r3, r0, #24
 c03996e:	d502      	bpl.n	c039976 <tfm_its_req_mngr_init+0x4a>
            its_signal_handle(TFM_ITS_REMOVE_SIGNAL, tfm_its_remove_ipc);
 c039970:	4621      	mov	r1, r4
 c039972:	2080      	movs	r0, #128	@ 0x80
 c039974:	e7ed      	b.n	c039952 <tfm_its_req_mngr_init+0x26>
        } else {
            psa_panic();
 c039976:	f002 ff51 	bl	c03c81c <psa_panic>
 c03997a:	e7e0      	b.n	c03993e <tfm_its_req_mngr_init+0x12>
 c03997c:	0c0397d1 	.word	0x0c0397d1
 c039980:	0c039801 	.word	0x0c039801
 c039984:	0c039851 	.word	0x0c039851
 c039988:	0c0398a5 	.word	0x0c0398a5

0c03998c <its_req_mngr_read>:
    return PSA_SUCCESS;
#endif
}

size_t its_req_mngr_read(uint8_t *buf, size_t num_bytes)
{
 c03998c:	4602      	mov	r2, r0
#ifdef TFM_PSA_API
    return psa_read(msg.handle, 1, buf, num_bytes);
 c03998e:	4803      	ldr	r0, [pc, #12]	@ (c03999c <its_req_mngr_read+0x10>)
{
 c039990:	460b      	mov	r3, r1
    return psa_read(msg.handle, 1, buf, num_bytes);
 c039992:	6840      	ldr	r0, [r0, #4]
 c039994:	2101      	movs	r1, #1
 c039996:	f002 bf3b 	b.w	c03c810 <psa_read>
 c03999a:	bf00      	nop
 c03999c:	30039188 	.word	0x30039188

0c0399a0 <its_req_mngr_write>:
    return num_bytes;
#endif
}

void its_req_mngr_write(const uint8_t *buf, size_t num_bytes)
{
 c0399a0:	4602      	mov	r2, r0
#ifdef TFM_PSA_API
    psa_write(msg.handle, 0, buf, num_bytes);
 c0399a2:	4803      	ldr	r0, [pc, #12]	@ (c0399b0 <its_req_mngr_write+0x10>)
{
 c0399a4:	460b      	mov	r3, r1
    psa_write(msg.handle, 0, buf, num_bytes);
 c0399a6:	6840      	ldr	r0, [r0, #4]
 c0399a8:	2100      	movs	r1, #0
 c0399aa:	f002 bf33 	b.w	c03c814 <psa_write>
 c0399ae:	bf00      	nop
 c0399b0:	30039188 	.word	0x30039188
	...

Disassembly of section .TFM_SP_CRYPTO_RO:

0c0399c0 <tfm_crypto_aead_encrypt>:
/*!@{*/
psa_status_t tfm_crypto_aead_encrypt(psa_invec in_vec[],
                                     size_t in_len,
                                     psa_outvec out_vec[],
                                     size_t out_len)
{
 c0399c0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c0399c4:	4614      	mov	r4, r2
#ifdef TFM_CRYPTO_AEAD_MODULE_DISABLED
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status = PSA_SUCCESS;

    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 3, out_len, 0, 1);
 c0399c6:	b24a      	sxtb	r2, r1
 c0399c8:	2a00      	cmp	r2, #0
{
 c0399ca:	b08f      	sub	sp, #60	@ 0x3c
    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 3, out_len, 0, 1);
 c0399cc:	dd3a      	ble.n	c039a44 <tfm_crypto_aead_encrypt+0x84>
 c0399ce:	2903      	cmp	r1, #3
 c0399d0:	d838      	bhi.n	c039a44 <tfm_crypto_aead_encrypt+0x84>
 c0399d2:	061a      	lsls	r2, r3, #24
 c0399d4:	d436      	bmi.n	c039a44 <tfm_crypto_aead_encrypt+0x84>
 c0399d6:	2b01      	cmp	r3, #1
 c0399d8:	d834      	bhi.n	c039a44 <tfm_crypto_aead_encrypt+0x84>

    if ((in_vec[0].len != sizeof(struct tfm_crypto_pack_iovec))) {
 c0399da:	6843      	ldr	r3, [r0, #4]
 c0399dc:	2b2c      	cmp	r3, #44	@ 0x2c
 c0399de:	d131      	bne.n	c039a44 <tfm_crypto_aead_encrypt+0x84>
    const uint8_t *plaintext = in_vec[1].base;
    size_t plaintext_length = in_vec[1].len;
    uint8_t *ciphertext = out_vec[0].base;
    size_t ciphertext_size = out_vec[0].len;
    const uint8_t *additional_data = in_vec[2].base;
    size_t additional_data_length = in_vec[2].len;
 c0399e0:	e9d0 6704 	ldrd	r6, r7, [r0, #16]
    size_t ciphertext_size = out_vec[0].len;
 c0399e4:	e9d4 ab00 	ldrd	sl, fp, [r4]
    mbedtls_svc_key_id_t encoded_key;

    /* Initialise ciphertext_length to zero. */
    out_vec[0].len = 0;
 c0399e8:	2100      	movs	r1, #0
    const struct tfm_crypto_pack_iovec *iov = in_vec[0].base;
 c0399ea:	6805      	ldr	r5, [r0, #0]
    psa_algorithm_t alg = iov->alg;
 c0399ec:	e9d5 9302 	ldrd	r9, r3, [r5, #8]
 c0399f0:	9308      	str	r3, [sp, #32]
    size_t nonce_length = aead_pack_input->nonce_length;
 c0399f2:	6aab      	ldr	r3, [r5, #40]	@ 0x28
 c0399f4:	9309      	str	r3, [sp, #36]	@ 0x24
    const uint8_t *plaintext = in_vec[1].base;
 c0399f6:	6883      	ldr	r3, [r0, #8]
 c0399f8:	930a      	str	r3, [sp, #40]	@ 0x28
    size_t plaintext_length = in_vec[1].len;
 c0399fa:	68c3      	ldr	r3, [r0, #12]

    status = tfm_crypto_check_handle_owner(key_id, NULL);
 c0399fc:	4648      	mov	r0, r9
    out_vec[0].len = 0;
 c0399fe:	6061      	str	r1, [r4, #4]
    size_t plaintext_length = in_vec[1].len;
 c039a00:	930b      	str	r3, [sp, #44]	@ 0x2c
    status = tfm_crypto_check_handle_owner(key_id, NULL);
 c039a02:	f000 fe45 	bl	c03a690 <tfm_crypto_check_handle_owner>
    if (status != PSA_SUCCESS) {
 c039a06:	b9d0      	cbnz	r0, c039a3e <tfm_crypto_aead_encrypt+0x7e>
        return status;
    }

    status = tfm_crypto_encode_id_and_owner(key_id, &encoded_key);
 c039a08:	f10d 0830 	add.w	r8, sp, #48	@ 0x30
 c039a0c:	4641      	mov	r1, r8
 c039a0e:	4648      	mov	r0, r9
 c039a10:	f000 fe66 	bl	c03a6e0 <tfm_crypto_encode_id_and_owner>
    if (status != PSA_SUCCESS) {
 c039a14:	b998      	cbnz	r0, c039a3e <tfm_crypto_aead_encrypt+0x7e>
        return status;
    }

    return psa_aead_encrypt(encoded_key, alg, nonce, nonce_length,
 c039a16:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 c039a18:	3404      	adds	r4, #4
 c039a1a:	9304      	str	r3, [sp, #16]
 c039a1c:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 c039a1e:	e9cd b406 	strd	fp, r4, [sp, #24]
 c039a22:	e9cd 7302 	strd	r7, r3, [sp, #8]
 c039a26:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 c039a28:	f8cd a014 	str.w	sl, [sp, #20]
 c039a2c:	9300      	str	r3, [sp, #0]
 c039a2e:	9601      	str	r6, [sp, #4]
 c039a30:	9a08      	ldr	r2, [sp, #32]
 c039a32:	f105 0318 	add.w	r3, r5, #24
 c039a36:	e898 0003 	ldmia.w	r8, {r0, r1}
 c039a3a:	f00c fc65 	bl	c046308 <mbedcrypto__psa_aead_encrypt>
                            additional_data, additional_data_length,
                            plaintext, plaintext_length,
                            ciphertext, ciphertext_size, &out_vec[0].len);
#endif /* TFM_CRYPTO_AEAD_MODULE_DISABLED */
}
 c039a3e:	b00f      	add	sp, #60	@ 0x3c
 c039a40:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 3, out_len, 0, 1);
 c039a44:	f06f 0080 	mvn.w	r0, #128	@ 0x80
 c039a48:	e7f9      	b.n	c039a3e <tfm_crypto_aead_encrypt+0x7e>

0c039a4a <tfm_crypto_aead_decrypt>:

psa_status_t tfm_crypto_aead_decrypt(psa_invec in_vec[],
                                     size_t in_len,
                                     psa_outvec out_vec[],
                                     size_t out_len)
{
 c039a4a:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c039a4e:	4614      	mov	r4, r2
#ifdef TFM_CRYPTO_AEAD_MODULE_DISABLED
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status = PSA_SUCCESS;

    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 3, out_len, 0, 1);
 c039a50:	b24a      	sxtb	r2, r1
 c039a52:	2a00      	cmp	r2, #0
{
 c039a54:	b08f      	sub	sp, #60	@ 0x3c
    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 3, out_len, 0, 1);
 c039a56:	dd3a      	ble.n	c039ace <tfm_crypto_aead_decrypt+0x84>
 c039a58:	2903      	cmp	r1, #3
 c039a5a:	d838      	bhi.n	c039ace <tfm_crypto_aead_decrypt+0x84>
 c039a5c:	061a      	lsls	r2, r3, #24
 c039a5e:	d436      	bmi.n	c039ace <tfm_crypto_aead_decrypt+0x84>
 c039a60:	2b01      	cmp	r3, #1
 c039a62:	d834      	bhi.n	c039ace <tfm_crypto_aead_decrypt+0x84>

    if ((in_vec[0].len != sizeof(struct tfm_crypto_pack_iovec))) {
 c039a64:	6843      	ldr	r3, [r0, #4]
 c039a66:	2b2c      	cmp	r3, #44	@ 0x2c
 c039a68:	d131      	bne.n	c039ace <tfm_crypto_aead_decrypt+0x84>
    const uint8_t *ciphertext = in_vec[1].base;
    size_t ciphertext_length = in_vec[1].len;
    uint8_t *plaintext = out_vec[0].base;
    size_t plaintext_size = out_vec[0].len;
    const uint8_t *additional_data = in_vec[2].base;
    size_t additional_data_length = in_vec[2].len;
 c039a6a:	e9d0 6704 	ldrd	r6, r7, [r0, #16]
    size_t plaintext_size = out_vec[0].len;
 c039a6e:	e9d4 ab00 	ldrd	sl, fp, [r4]
    mbedtls_svc_key_id_t encoded_key;

    /* Initialise plaintext_length to zero. */
    out_vec[0].len = 0;
 c039a72:	2100      	movs	r1, #0
    const struct tfm_crypto_pack_iovec *iov = in_vec[0].base;
 c039a74:	6805      	ldr	r5, [r0, #0]
    psa_algorithm_t alg = iov->alg;
 c039a76:	e9d5 9302 	ldrd	r9, r3, [r5, #8]
 c039a7a:	9308      	str	r3, [sp, #32]
    size_t nonce_length = aead_pack_input->nonce_length;
 c039a7c:	6aab      	ldr	r3, [r5, #40]	@ 0x28
 c039a7e:	9309      	str	r3, [sp, #36]	@ 0x24
    const uint8_t *ciphertext = in_vec[1].base;
 c039a80:	6883      	ldr	r3, [r0, #8]
 c039a82:	930a      	str	r3, [sp, #40]	@ 0x28
    size_t ciphertext_length = in_vec[1].len;
 c039a84:	68c3      	ldr	r3, [r0, #12]

    status = tfm_crypto_check_handle_owner(key_id, NULL);
 c039a86:	4648      	mov	r0, r9
    out_vec[0].len = 0;
 c039a88:	6061      	str	r1, [r4, #4]
    size_t ciphertext_length = in_vec[1].len;
 c039a8a:	930b      	str	r3, [sp, #44]	@ 0x2c
    status = tfm_crypto_check_handle_owner(key_id, NULL);
 c039a8c:	f000 fe00 	bl	c03a690 <tfm_crypto_check_handle_owner>
    if (status != PSA_SUCCESS) {
 c039a90:	b9d0      	cbnz	r0, c039ac8 <tfm_crypto_aead_decrypt+0x7e>
        return status;
    }

    status = tfm_crypto_encode_id_and_owner(key_id, &encoded_key);
 c039a92:	f10d 0830 	add.w	r8, sp, #48	@ 0x30
 c039a96:	4641      	mov	r1, r8
 c039a98:	4648      	mov	r0, r9
 c039a9a:	f000 fe21 	bl	c03a6e0 <tfm_crypto_encode_id_and_owner>
    if (status != PSA_SUCCESS) {
 c039a9e:	b998      	cbnz	r0, c039ac8 <tfm_crypto_aead_decrypt+0x7e>
        return status;
    }

    return psa_aead_decrypt(encoded_key, alg, nonce, nonce_length,
 c039aa0:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 c039aa2:	3404      	adds	r4, #4
 c039aa4:	9304      	str	r3, [sp, #16]
 c039aa6:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 c039aa8:	e9cd b406 	strd	fp, r4, [sp, #24]
 c039aac:	e9cd 7302 	strd	r7, r3, [sp, #8]
 c039ab0:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 c039ab2:	f8cd a014 	str.w	sl, [sp, #20]
 c039ab6:	9300      	str	r3, [sp, #0]
 c039ab8:	9601      	str	r6, [sp, #4]
 c039aba:	9a08      	ldr	r2, [sp, #32]
 c039abc:	f105 0318 	add.w	r3, r5, #24
 c039ac0:	e898 0003 	ldmia.w	r8, {r0, r1}
 c039ac4:	f00c fcb2 	bl	c04642c <mbedcrypto__psa_aead_decrypt>
                            additional_data, additional_data_length,
                            ciphertext, ciphertext_length,
                            plaintext, plaintext_size, &out_vec[0].len);
#endif /* TFM_CRYPTO_AEAD_MODULE_DISABLED */
}
 c039ac8:	b00f      	add	sp, #60	@ 0x3c
 c039aca:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 3, out_len, 0, 1);
 c039ace:	f06f 0080 	mvn.w	r0, #128	@ 0x80
 c039ad2:	e7f9      	b.n	c039ac8 <tfm_crypto_aead_decrypt+0x7e>

0c039ad4 <tfm_crypto_aead_encrypt_setup>:
                                           psa_outvec out_vec[],
                                           size_t out_len)
{
    /* FixMe: To be implemented */
    return PSA_ERROR_NOT_SUPPORTED;
}
 c039ad4:	f06f 0085 	mvn.w	r0, #133	@ 0x85
 c039ad8:	4770      	bx	lr

0c039ada <tfm_crypto_aead_decrypt_setup>:

psa_status_t tfm_crypto_aead_decrypt_setup(psa_invec in_vec[],
 c039ada:	f06f 0085 	mvn.w	r0, #133	@ 0x85
 c039ade:	4770      	bx	lr

0c039ae0 <tfm_crypto_aead_abort>:
{
    /* FixMe: To be implemented */
    return PSA_ERROR_NOT_SUPPORTED;
}

psa_status_t tfm_crypto_aead_abort(psa_invec in_vec[],
 c039ae0:	f06f 0085 	mvn.w	r0, #133	@ 0x85
 c039ae4:	4770      	bx	lr

0c039ae6 <tfm_crypto_aead_finish>:
{
    /* FixMe: To be implemented */
    return PSA_ERROR_NOT_SUPPORTED;
}

psa_status_t tfm_crypto_aead_finish(psa_invec in_vec[],
 c039ae6:	f06f 0085 	mvn.w	r0, #133	@ 0x85
 c039aea:	4770      	bx	lr

0c039aec <tfm_crypto_aead_generate_nonce>:
{
    /* FixMe: To be implemented */
    return PSA_ERROR_NOT_SUPPORTED;
}

psa_status_t tfm_crypto_aead_generate_nonce(psa_invec in_vec[],
 c039aec:	f06f 0085 	mvn.w	r0, #133	@ 0x85
 c039af0:	4770      	bx	lr

0c039af2 <tfm_crypto_aead_set_nonce>:
{
    /* FixMe: To be implemented */
    return PSA_ERROR_NOT_SUPPORTED;
}

psa_status_t tfm_crypto_aead_set_nonce(psa_invec in_vec[],
 c039af2:	f06f 0085 	mvn.w	r0, #133	@ 0x85
 c039af6:	4770      	bx	lr

0c039af8 <tfm_crypto_aead_set_lengths>:
{
    /* FixMe: To be implemented */
    return PSA_ERROR_NOT_SUPPORTED;
}

psa_status_t tfm_crypto_aead_set_lengths(psa_invec in_vec[],
 c039af8:	f06f 0085 	mvn.w	r0, #133	@ 0x85
 c039afc:	4770      	bx	lr

0c039afe <tfm_crypto_aead_update>:
{
    /* FixMe: To be implemented */
    return PSA_ERROR_NOT_SUPPORTED;
}

psa_status_t tfm_crypto_aead_update(psa_invec in_vec[],
 c039afe:	f06f 0085 	mvn.w	r0, #133	@ 0x85
 c039b02:	4770      	bx	lr

0c039b04 <tfm_crypto_aead_update_ad>:
{
    /* FixMe: To be implemented */
    return PSA_ERROR_NOT_SUPPORTED;
}

psa_status_t tfm_crypto_aead_update_ad(psa_invec in_vec[],
 c039b04:	f06f 0085 	mvn.w	r0, #133	@ 0x85
 c039b08:	4770      	bx	lr

0c039b0a <tfm_crypto_aead_verify>:
{
    /* FixMe: To be implemented */
    return PSA_ERROR_NOT_SUPPORTED;
}

psa_status_t tfm_crypto_aead_verify(psa_invec in_vec[],
 c039b0a:	f06f 0085 	mvn.w	r0, #133	@ 0x85
 c039b0e:	4770      	bx	lr

0c039b10 <tfm_crypto_init_alloc>:
 *
 */

/*!@{*/
psa_status_t tfm_crypto_init_alloc(void)
{
 c039b10:	b508      	push	{r3, lr}
 c039b12:	f44f 52b4 	mov.w	r2, #5760	@ 0x1680
 c039b16:	2100      	movs	r1, #0
 c039b18:	4802      	ldr	r0, [pc, #8]	@ (c039b24 <tfm_crypto_init_alloc+0x14>)
 c039b1a:	f021 fe08 	bl	c05b72e <memset>
    /* Clear the contents of the local contexts */
    (void)tfm_memset(operation, 0, sizeof(operation));
    return PSA_SUCCESS;
}
 c039b1e:	2000      	movs	r0, #0
 c039b20:	bd08      	pop	{r3, pc}
 c039b22:	bf00      	nop
 c039b24:	30031fe8 	.word	0x30031fe8

0c039b28 <tfm_crypto_operation_alloc>:
psa_status_t tfm_crypto_operation_alloc(enum tfm_crypto_operation_type type,
                                        uint32_t *handle,
                                        void **ctx)
{
    uint32_t i = 0;
    int32_t partition_id = 0;
 c039b28:	2300      	movs	r3, #0
{
 c039b2a:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 c039b2c:	4607      	mov	r7, r0
    psa_status_t status;

    status = tfm_crypto_get_caller_id(&partition_id);
 c039b2e:	a801      	add	r0, sp, #4
{
 c039b30:	460e      	mov	r6, r1
 c039b32:	4615      	mov	r5, r2
    int32_t partition_id = 0;
 c039b34:	9301      	str	r3, [sp, #4]
    status = tfm_crypto_get_caller_id(&partition_id);
 c039b36:	f000 fc67 	bl	c03a408 <tfm_crypto_get_caller_id>
    if (status != PSA_SUCCESS) {
 c039b3a:	b9c8      	cbnz	r0, c039b70 <tfm_crypto_operation_alloc+0x48>
        return status;
    }

    /* Handle must be initialised before calling a setup function */
    if (*handle != TFM_CRYPTO_INVALID_HANDLE) {
 c039b3c:	6833      	ldr	r3, [r6, #0]
 c039b3e:	b9f3      	cbnz	r3, c039b7e <tfm_crypto_operation_alloc+0x56>
        return PSA_ERROR_BAD_STATE;
    }

    /* Init to invalid values */
    if (ctx == NULL) {
 c039b40:	b305      	cbz	r5, c039b84 <tfm_crypto_operation_alloc+0x5c>
        return PSA_ERROR_INVALID_ARGUMENT;
    }
    *ctx = NULL;
 c039b42:	f44f 7c34 	mov.w	ip, #720	@ 0x2d0

    for (i=0; i<TFM_CRYPTO_CONC_OPER_NUM; i++) {
        if (operation[i].in_use == TFM_CRYPTO_NOT_IN_USE) {
 c039b46:	4a11      	ldr	r2, [pc, #68]	@ (c039b8c <tfm_crypto_operation_alloc+0x64>)
    *ctx = NULL;
 c039b48:	602b      	str	r3, [r5, #0]
        if (operation[i].in_use == TFM_CRYPTO_NOT_IN_USE) {
 c039b4a:	fb0c f403 	mul.w	r4, ip, r3
 c039b4e:	5911      	ldr	r1, [r2, r4]
 c039b50:	469e      	mov	lr, r3
            operation[i].in_use = TFM_CRYPTO_IN_USE;
            operation[i].owner = partition_id;
            operation[i].type = type;
            *handle = i + 1;
 c039b52:	3301      	adds	r3, #1
        if (operation[i].in_use == TFM_CRYPTO_NOT_IN_USE) {
 c039b54:	b971      	cbnz	r1, c039b74 <tfm_crypto_operation_alloc+0x4c>
            operation[i].in_use = TFM_CRYPTO_IN_USE;
 c039b56:	f04f 0e01 	mov.w	lr, #1
 c039b5a:	eb02 0c04 	add.w	ip, r2, r4
 c039b5e:	f842 e004 	str.w	lr, [r2, r4]
            operation[i].owner = partition_id;
 c039b62:	9901      	ldr	r1, [sp, #4]
            *ctx = (void *) &(operation[i].operation);
 c039b64:	3410      	adds	r4, #16
 c039b66:	4414      	add	r4, r2
            operation[i].type = type;
 c039b68:	e9cc 1701 	strd	r1, r7, [ip, #4]
            *handle = i + 1;
 c039b6c:	6033      	str	r3, [r6, #0]
            *ctx = (void *) &(operation[i].operation);
 c039b6e:	602c      	str	r4, [r5, #0]
            return PSA_SUCCESS;
        }
    }

    return PSA_ERROR_NOT_PERMITTED;
}
 c039b70:	b003      	add	sp, #12
 c039b72:	bdf0      	pop	{r4, r5, r6, r7, pc}
    for (i=0; i<TFM_CRYPTO_CONC_OPER_NUM; i++) {
 c039b74:	2b08      	cmp	r3, #8
 c039b76:	d1e8      	bne.n	c039b4a <tfm_crypto_operation_alloc+0x22>
    return PSA_ERROR_NOT_PERMITTED;
 c039b78:	f06f 0084 	mvn.w	r0, #132	@ 0x84
 c039b7c:	e7f8      	b.n	c039b70 <tfm_crypto_operation_alloc+0x48>
        return PSA_ERROR_BAD_STATE;
 c039b7e:	f06f 0088 	mvn.w	r0, #136	@ 0x88
 c039b82:	e7f5      	b.n	c039b70 <tfm_crypto_operation_alloc+0x48>
        return PSA_ERROR_INVALID_ARGUMENT;
 c039b84:	f06f 0086 	mvn.w	r0, #134	@ 0x86
 c039b88:	e7f2      	b.n	c039b70 <tfm_crypto_operation_alloc+0x48>
 c039b8a:	bf00      	nop
 c039b8c:	30031fe8 	.word	0x30031fe8

0c039b90 <tfm_crypto_operation_release>:

psa_status_t tfm_crypto_operation_release(uint32_t *handle)
{
    uint32_t h_val = *handle;
    int32_t partition_id = 0;
 c039b90:	2300      	movs	r3, #0
{
 c039b92:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    uint32_t h_val = *handle;
 c039b94:	6805      	ldr	r5, [r0, #0]
{
 c039b96:	4606      	mov	r6, r0
    psa_status_t status;

    status = tfm_crypto_get_caller_id(&partition_id);
 c039b98:	a801      	add	r0, sp, #4
    int32_t partition_id = 0;
 c039b9a:	9301      	str	r3, [sp, #4]
    status = tfm_crypto_get_caller_id(&partition_id);
 c039b9c:	f000 fc34 	bl	c03a408 <tfm_crypto_get_caller_id>
    if (status != PSA_SUCCESS) {
 c039ba0:	4604      	mov	r4, r0
 c039ba2:	bb20      	cbnz	r0, c039bee <tfm_crypto_operation_release+0x5e>
        return status;
    }

    if ( (h_val != TFM_CRYPTO_INVALID_HANDLE) &&
 c039ba4:	3d01      	subs	r5, #1
 c039ba6:	2d07      	cmp	r5, #7
 c039ba8:	d824      	bhi.n	c039bf4 <tfm_crypto_operation_release+0x64>
         (h_val <= TFM_CRYPTO_CONC_OPER_NUM) &&
         (operation[h_val - 1].in_use == TFM_CRYPTO_IN_USE) &&
 c039baa:	f44f 7334 	mov.w	r3, #720	@ 0x2d0
 c039bae:	436b      	muls	r3, r5
 c039bb0:	4f12      	ldr	r7, [pc, #72]	@ (c039bfc <tfm_crypto_operation_release+0x6c>)
         (h_val <= TFM_CRYPTO_CONC_OPER_NUM) &&
 c039bb2:	58f9      	ldr	r1, [r7, r3]
         (operation[h_val - 1].in_use == TFM_CRYPTO_IN_USE) &&
 c039bb4:	18fa      	adds	r2, r7, r3
         (h_val <= TFM_CRYPTO_CONC_OPER_NUM) &&
 c039bb6:	2901      	cmp	r1, #1
 c039bb8:	d11c      	bne.n	c039bf4 <tfm_crypto_operation_release+0x64>
         (operation[h_val - 1].in_use == TFM_CRYPTO_IN_USE) &&
 c039bba:	6850      	ldr	r0, [r2, #4]
 c039bbc:	9901      	ldr	r1, [sp, #4]
 c039bbe:	4288      	cmp	r0, r1
 c039bc0:	d118      	bne.n	c039bf4 <tfm_crypto_operation_release+0x64>
    uint8_t *mem_ptr = (uint8_t *) &(operation[index].operation);
 c039bc2:	3310      	adds	r3, #16
 c039bc4:	18f8      	adds	r0, r7, r3
    switch(operation[index].type) {
 c039bc6:	6893      	ldr	r3, [r2, #8]
 c039bc8:	2100      	movs	r1, #0
 c039bca:	3b01      	subs	r3, #1
 c039bcc:	2b03      	cmp	r3, #3
 c039bce:	bf96      	itet	ls
 c039bd0:	4a0b      	ldrls	r2, [pc, #44]	@ (c039c00 <tfm_crypto_operation_release+0x70>)
 c039bd2:	4622      	movhi	r2, r4
 c039bd4:	f832 2013 	ldrhls.w	r2, [r2, r3, lsl #1]
 c039bd8:	f021 fda9 	bl	c05b72e <memset>
         (operation[h_val - 1].owner == partition_id)) {

        memset_operation_context(h_val - 1);
        operation[h_val - 1].in_use = TFM_CRYPTO_NOT_IN_USE;
 c039bdc:	f44f 7334 	mov.w	r3, #720	@ 0x2d0
 c039be0:	435d      	muls	r5, r3
 c039be2:	2300      	movs	r3, #0
 c039be4:	197a      	adds	r2, r7, r5
        operation[h_val - 1].type = TFM_CRYPTO_OPERATION_NONE;
        operation[h_val - 1].owner = 0;
 c039be6:	e9c2 3301 	strd	r3, r3, [r2, #4]
        operation[h_val - 1].in_use = TFM_CRYPTO_NOT_IN_USE;
 c039bea:	517b      	str	r3, [r7, r5]
        *handle = TFM_CRYPTO_INVALID_HANDLE;
 c039bec:	6033      	str	r3, [r6, #0]
        return PSA_SUCCESS;
    }

    return PSA_ERROR_INVALID_ARGUMENT;
}
 c039bee:	4620      	mov	r0, r4
 c039bf0:	b003      	add	sp, #12
 c039bf2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return PSA_ERROR_INVALID_ARGUMENT;
 c039bf4:	f06f 0486 	mvn.w	r4, #134	@ 0x86
 c039bf8:	e7f9      	b.n	c039bee <tfm_crypto_operation_release+0x5e>
 c039bfa:	bf00      	nop
 c039bfc:	30031fe8 	.word	0x30031fe8
 c039c00:	0c0613ca 	.word	0x0c0613ca

0c039c04 <tfm_crypto_operation_lookup>:

psa_status_t tfm_crypto_operation_lookup(enum tfm_crypto_operation_type type,
                                         uint32_t handle,
                                         void **ctx)
{
    int32_t partition_id = 0;
 c039c04:	2300      	movs	r3, #0
{
 c039c06:	b573      	push	{r0, r1, r4, r5, r6, lr}
 c039c08:	4606      	mov	r6, r0
    psa_status_t status;

    status = tfm_crypto_get_caller_id(&partition_id);
 c039c0a:	a801      	add	r0, sp, #4
{
 c039c0c:	460c      	mov	r4, r1
 c039c0e:	4615      	mov	r5, r2
    int32_t partition_id = 0;
 c039c10:	9301      	str	r3, [sp, #4]
    status = tfm_crypto_get_caller_id(&partition_id);
 c039c12:	f000 fbf9 	bl	c03a408 <tfm_crypto_get_caller_id>
    if (status != PSA_SUCCESS) {
 c039c16:	b9a0      	cbnz	r0, c039c42 <tfm_crypto_operation_lookup+0x3e>
        return status;
    }

    if ( (handle != TFM_CRYPTO_INVALID_HANDLE) &&
 c039c18:	1e61      	subs	r1, r4, #1
 c039c1a:	2907      	cmp	r1, #7
 c039c1c:	d813      	bhi.n	c039c46 <tfm_crypto_operation_lookup+0x42>
         (handle <= TFM_CRYPTO_CONC_OPER_NUM) &&
         (operation[handle - 1].in_use == TFM_CRYPTO_IN_USE) &&
 c039c1e:	f44f 7234 	mov.w	r2, #720	@ 0x2d0
 c039c22:	4351      	muls	r1, r2
 c039c24:	4b09      	ldr	r3, [pc, #36]	@ (c039c4c <tfm_crypto_operation_lookup+0x48>)
         (handle <= TFM_CRYPTO_CONC_OPER_NUM) &&
 c039c26:	585c      	ldr	r4, [r3, r1]
         (operation[handle - 1].in_use == TFM_CRYPTO_IN_USE) &&
 c039c28:	185a      	adds	r2, r3, r1
         (handle <= TFM_CRYPTO_CONC_OPER_NUM) &&
 c039c2a:	2c01      	cmp	r4, #1
 c039c2c:	d10b      	bne.n	c039c46 <tfm_crypto_operation_lookup+0x42>
         (operation[handle - 1].in_use == TFM_CRYPTO_IN_USE) &&
 c039c2e:	6894      	ldr	r4, [r2, #8]
 c039c30:	42b4      	cmp	r4, r6
 c039c32:	d108      	bne.n	c039c46 <tfm_crypto_operation_lookup+0x42>
         (operation[handle - 1].type == type) &&
 c039c34:	6854      	ldr	r4, [r2, #4]
 c039c36:	9a01      	ldr	r2, [sp, #4]
 c039c38:	4294      	cmp	r4, r2
 c039c3a:	d104      	bne.n	c039c46 <tfm_crypto_operation_lookup+0x42>
         (operation[handle - 1].owner == partition_id)) {

        *ctx = (void *) &(operation[handle - 1].operation);
 c039c3c:	3110      	adds	r1, #16
 c039c3e:	4419      	add	r1, r3
 c039c40:	6029      	str	r1, [r5, #0]
        return PSA_SUCCESS;
    }

    return PSA_ERROR_BAD_STATE;
}
 c039c42:	b002      	add	sp, #8
 c039c44:	bd70      	pop	{r4, r5, r6, pc}
    return PSA_ERROR_BAD_STATE;
 c039c46:	f06f 0088 	mvn.w	r0, #136	@ 0x88
 c039c4a:	e7fa      	b.n	c039c42 <tfm_crypto_operation_lookup+0x3e>
 c039c4c:	30031fe8 	.word	0x30031fe8

0c039c50 <tfm_crypto_sign_hash>:
/*!@{*/
psa_status_t tfm_crypto_sign_hash(psa_invec in_vec[],
                                  size_t in_len,
                                  psa_outvec out_vec[],
                                  size_t out_len)
{
 c039c50:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c039c54:	4691      	mov	r9, r2
#ifdef TFM_CRYPTO_ASYMMETRIC_MODULE_DISABLED
    return PSA_ERROR_NOT_SUPPORTED;
#else
    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 2, out_len, 0, 1);
 c039c56:	b24a      	sxtb	r2, r1
 c039c58:	2a00      	cmp	r2, #0
{
 c039c5a:	b087      	sub	sp, #28
    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 2, out_len, 0, 1);
 c039c5c:	dd2a      	ble.n	c039cb4 <tfm_crypto_sign_hash+0x64>
 c039c5e:	2902      	cmp	r1, #2
 c039c60:	d828      	bhi.n	c039cb4 <tfm_crypto_sign_hash+0x64>
 c039c62:	061a      	lsls	r2, r3, #24
 c039c64:	d426      	bmi.n	c039cb4 <tfm_crypto_sign_hash+0x64>
 c039c66:	2b01      	cmp	r3, #1
 c039c68:	d824      	bhi.n	c039cb4 <tfm_crypto_sign_hash+0x64>

    if ((in_vec[0].len != sizeof(struct tfm_crypto_pack_iovec))) {
 c039c6a:	6843      	ldr	r3, [r0, #4]
 c039c6c:	2b2c      	cmp	r3, #44	@ 0x2c
 c039c6e:	d121      	bne.n	c039cb4 <tfm_crypto_sign_hash+0x64>

    const struct tfm_crypto_pack_iovec *iov = in_vec[0].base;
    psa_key_id_t key_id = iov->key_id;
    psa_algorithm_t alg = iov->alg;
    const uint8_t *hash = in_vec[1].base;
    size_t hash_length = in_vec[1].len;
 c039c70:	e9d0 5602 	ldrd	r5, r6, [r0, #8]
    uint8_t *signature = out_vec[0].base;
    size_t signature_size = out_vec[0].len;
 c039c74:	e9d9 7800 	ldrd	r7, r8, [r9]
    const struct tfm_crypto_pack_iovec *iov = in_vec[0].base;
 c039c78:	6803      	ldr	r3, [r0, #0]
    mbedtls_svc_key_id_t encoded_key;

    psa_status_t status = tfm_crypto_check_handle_owner(key_id, NULL);
 c039c7a:	2100      	movs	r1, #0
    psa_algorithm_t alg = iov->alg;
 c039c7c:	e9d3 b402 	ldrd	fp, r4, [r3, #8]
    psa_status_t status = tfm_crypto_check_handle_owner(key_id, NULL);
 c039c80:	4658      	mov	r0, fp
 c039c82:	f000 fd05 	bl	c03a690 <tfm_crypto_check_handle_owner>
    if (status != PSA_SUCCESS) {
 c039c86:	b990      	cbnz	r0, c039cae <tfm_crypto_sign_hash+0x5e>
        return status;
    }

    status = tfm_crypto_encode_id_and_owner(key_id, &encoded_key);
 c039c88:	f10d 0a10 	add.w	sl, sp, #16
 c039c8c:	4651      	mov	r1, sl
 c039c8e:	4658      	mov	r0, fp
 c039c90:	f000 fd26 	bl	c03a6e0 <tfm_crypto_encode_id_and_owner>
    if (status != PSA_SUCCESS) {
 c039c94:	b958      	cbnz	r0, c039cae <tfm_crypto_sign_hash+0x5e>
        return status;
    }

    return psa_sign_hash(encoded_key, alg, hash, hash_length,
 c039c96:	f109 0304 	add.w	r3, r9, #4
 c039c9a:	e9cd 8302 	strd	r8, r3, [sp, #8]
 c039c9e:	e9cd 6700 	strd	r6, r7, [sp]
 c039ca2:	462b      	mov	r3, r5
 c039ca4:	e89a 0003 	ldmia.w	sl, {r0, r1}
 c039ca8:	4622      	mov	r2, r4
 c039caa:	f00c f89d 	bl	c045de8 <mbedcrypto__psa_sign_hash>
                         signature, signature_size, &(out_vec[0].len));
#endif /* TFM_CRYPTO_ASYMMETRIC_MODULE_DISABLED */
}
 c039cae:	b007      	add	sp, #28
 c039cb0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 2, out_len, 0, 1);
 c039cb4:	f06f 0080 	mvn.w	r0, #128	@ 0x80
 c039cb8:	e7f9      	b.n	c039cae <tfm_crypto_sign_hash+0x5e>

0c039cba <tfm_crypto_verify_hash>:

psa_status_t tfm_crypto_verify_hash(psa_invec in_vec[],
                                    size_t in_len,
                                    psa_outvec out_vec[],
                                    size_t out_len)
{
 c039cba:	460a      	mov	r2, r1
 c039cbc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 c039cc0:	4619      	mov	r1, r3
#ifdef TFM_CRYPTO_ASYMMETRIC_MODULE_DISABLED
    return PSA_ERROR_NOT_SUPPORTED;
#else
    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 3, out_len, 0, 0);
 c039cc2:	b253      	sxtb	r3, r2
 c039cc4:	2b00      	cmp	r3, #0
{
 c039cc6:	b086      	sub	sp, #24
    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 3, out_len, 0, 0);
 c039cc8:	dd25      	ble.n	c039d16 <tfm_crypto_verify_hash+0x5c>
 c039cca:	2a03      	cmp	r2, #3
 c039ccc:	d823      	bhi.n	c039d16 <tfm_crypto_verify_hash+0x5c>
 c039cce:	060b      	lsls	r3, r1, #24
 c039cd0:	d421      	bmi.n	c039d16 <tfm_crypto_verify_hash+0x5c>
 c039cd2:	bb01      	cbnz	r1, c039d16 <tfm_crypto_verify_hash+0x5c>

    if ((in_vec[0].len != sizeof(struct tfm_crypto_pack_iovec))) {
 c039cd4:	6843      	ldr	r3, [r0, #4]
 c039cd6:	2b2c      	cmp	r3, #44	@ 0x2c
 c039cd8:	d11d      	bne.n	c039d16 <tfm_crypto_verify_hash+0x5c>
    const struct tfm_crypto_pack_iovec *iov = in_vec[0].base;

    psa_key_id_t key_id = iov->key_id;
    psa_algorithm_t alg = iov->alg;
    const uint8_t *hash = in_vec[1].base;
    size_t hash_length = in_vec[1].len;
 c039cda:	e9d0 5602 	ldrd	r5, r6, [r0, #8]
    const uint8_t *signature = in_vec[2].base;
    size_t signature_length = in_vec[2].len;
 c039cde:	e9d0 7804 	ldrd	r7, r8, [r0, #16]
    const struct tfm_crypto_pack_iovec *iov = in_vec[0].base;
 c039ce2:	6803      	ldr	r3, [r0, #0]
    psa_algorithm_t alg = iov->alg;
 c039ce4:	e9d3 9402 	ldrd	r9, r4, [r3, #8]
    mbedtls_svc_key_id_t encoded_key;
    psa_status_t status = tfm_crypto_check_handle_owner(key_id, NULL);
 c039ce8:	4648      	mov	r0, r9
 c039cea:	f000 fcd1 	bl	c03a690 <tfm_crypto_check_handle_owner>

    if (status != PSA_SUCCESS) {
 c039cee:	b978      	cbnz	r0, c039d10 <tfm_crypto_verify_hash+0x56>
        return status;
    }

    status = tfm_crypto_encode_id_and_owner(key_id, &encoded_key);
 c039cf0:	f10d 0a10 	add.w	sl, sp, #16
 c039cf4:	4651      	mov	r1, sl
 c039cf6:	4648      	mov	r0, r9
 c039cf8:	f000 fcf2 	bl	c03a6e0 <tfm_crypto_encode_id_and_owner>
    if (status != PSA_SUCCESS) {
 c039cfc:	b940      	cbnz	r0, c039d10 <tfm_crypto_verify_hash+0x56>
        return status;
    }

    return psa_verify_hash(encoded_key, alg, hash, hash_length,
 c039cfe:	e9cd 7801 	strd	r7, r8, [sp, #4]
 c039d02:	9600      	str	r6, [sp, #0]
 c039d04:	462b      	mov	r3, r5
 c039d06:	e89a 0003 	ldmia.w	sl, {r0, r1}
 c039d0a:	4622      	mov	r2, r4
 c039d0c:	f00c f8ce 	bl	c045eac <mbedcrypto__psa_verify_hash>
                           signature, signature_length);
#endif /* TFM_CRYPTO_ASYMMETRIC_MODULE_DISABLED */
}
 c039d10:	b006      	add	sp, #24
 c039d12:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 3, out_len, 0, 0);
 c039d16:	f06f 0080 	mvn.w	r0, #128	@ 0x80
 c039d1a:	e7f9      	b.n	c039d10 <tfm_crypto_verify_hash+0x56>

0c039d1c <tfm_crypto_asymmetric_encrypt>:

psa_status_t tfm_crypto_asymmetric_encrypt(psa_invec in_vec[],
                                           size_t in_len,
                                           psa_outvec out_vec[],
                                           size_t out_len)
{
 c039d1c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c039d20:	4614      	mov	r4, r2
#ifdef TFM_CRYPTO_ASYMMETRIC_MODULE_DISABLED
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status;

    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 3, out_len, 0, 1);
 c039d22:	b24a      	sxtb	r2, r1
 c039d24:	2a00      	cmp	r2, #0
{
 c039d26:	b099      	sub	sp, #100	@ 0x64
    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 3, out_len, 0, 1);
 c039d28:	dd4e      	ble.n	c039dc8 <tfm_crypto_asymmetric_encrypt+0xac>
 c039d2a:	2903      	cmp	r1, #3
 c039d2c:	d84c      	bhi.n	c039dc8 <tfm_crypto_asymmetric_encrypt+0xac>
 c039d2e:	061a      	lsls	r2, r3, #24
 c039d30:	d44a      	bmi.n	c039dc8 <tfm_crypto_asymmetric_encrypt+0xac>
 c039d32:	2b01      	cmp	r3, #1
 c039d34:	d848      	bhi.n	c039dc8 <tfm_crypto_asymmetric_encrypt+0xac>

    if ((in_vec[0].len != sizeof(struct tfm_crypto_pack_iovec))) {
 c039d36:	6843      	ldr	r3, [r0, #4]
 c039d38:	2b2c      	cmp	r3, #44	@ 0x2c
 c039d3a:	d145      	bne.n	c039dc8 <tfm_crypto_asymmetric_encrypt+0xac>
    psa_key_id_t key_id = iov->key_id;
    psa_algorithm_t alg = iov->alg;
    const uint8_t *input = in_vec[1].base;
    size_t input_length = in_vec[1].len;
    const uint8_t *salt = in_vec[2].base;
    size_t salt_length = in_vec[2].len;
 c039d3c:	e9d0 9a04 	ldrd	r9, sl, [r0, #16]
    uint8_t *output = out_vec[0].base;
    size_t output_size = out_vec[0].len;
 c039d40:	e9d4 b600 	ldrd	fp, r6, [r4]
    psa_key_type_t type;
    size_t key_bits;
    psa_key_attributes_t key_attributes = PSA_KEY_ATTRIBUTES_INIT;
 c039d44:	2230      	movs	r2, #48	@ 0x30
    const struct tfm_crypto_pack_iovec *iov = in_vec[0].base;
 c039d46:	6803      	ldr	r3, [r0, #0]
    psa_key_attributes_t key_attributes = PSA_KEY_ATTRIBUTES_INIT;
 c039d48:	2100      	movs	r1, #0
    psa_algorithm_t alg = iov->alg;
 c039d4a:	e9d3 7302 	ldrd	r7, r3, [r3, #8]
 c039d4e:	9307      	str	r3, [sp, #28]
    const uint8_t *input = in_vec[1].base;
 c039d50:	6883      	ldr	r3, [r0, #8]
 c039d52:	9308      	str	r3, [sp, #32]
    size_t input_length = in_vec[1].len;
 c039d54:	68c3      	ldr	r3, [r0, #12]
    psa_key_attributes_t key_attributes = PSA_KEY_ATTRIBUTES_INIT;
 c039d56:	eb0d 0002 	add.w	r0, sp, r2
    size_t input_length = in_vec[1].len;
 c039d5a:	9309      	str	r3, [sp, #36]	@ 0x24
    psa_key_attributes_t key_attributes = PSA_KEY_ATTRIBUTES_INIT;
 c039d5c:	f021 fce7 	bl	c05b72e <memset>
    mbedtls_svc_key_id_t encoded_key;

    status = tfm_crypto_check_handle_owner(key_id, NULL);
 c039d60:	2100      	movs	r1, #0
 c039d62:	4638      	mov	r0, r7
 c039d64:	f000 fc94 	bl	c03a690 <tfm_crypto_check_handle_owner>
    if (status != PSA_SUCCESS) {
 c039d68:	bb58      	cbnz	r0, c039dc2 <tfm_crypto_asymmetric_encrypt+0xa6>
        return status;
    }

    status = tfm_crypto_encode_id_and_owner(key_id, &encoded_key);
 c039d6a:	ad0a      	add	r5, sp, #40	@ 0x28
 c039d6c:	4629      	mov	r1, r5
 c039d6e:	4638      	mov	r0, r7
 c039d70:	f000 fcb6 	bl	c03a6e0 <tfm_crypto_encode_id_and_owner>
    if (status != PSA_SUCCESS) {
 c039d74:	bb28      	cbnz	r0, c039dc2 <tfm_crypto_asymmetric_encrypt+0xa6>
        return status;
    }

    status = psa_get_key_attributes(encoded_key, &key_attributes);
 c039d76:	e895 0003 	ldmia.w	r5, {r0, r1}
 c039d7a:	aa0c      	add	r2, sp, #48	@ 0x30
 c039d7c:	f00b fa44 	bl	c045208 <mbedcrypto__psa_get_key_attributes>
    if (status != PSA_SUCCESS) {
 c039d80:	b9f8      	cbnz	r0, c039dc2 <tfm_crypto_asymmetric_encrypt+0xa6>
    }

    key_bits = psa_get_key_bits(&key_attributes);
    type = psa_get_key_type(&key_attributes);

    psa_reset_key_attributes(&key_attributes);
 c039d82:	a80c      	add	r0, sp, #48	@ 0x30
}

static inline psa_key_type_t psa_get_key_type(
    const psa_key_attributes_t *attributes)
{
    return( attributes->core.type );
 c039d84:	f8bd 8030 	ldrh.w	r8, [sp, #48]	@ 0x30
}

static inline size_t psa_get_key_bits(
    const psa_key_attributes_t *attributes)
{
    return( attributes->core.bits );
 c039d88:	f8bd 7032 	ldrh.w	r7, [sp, #50]	@ 0x32
 c039d8c:	f00d fcc3 	bl	c047716 <mbedcrypto__psa_reset_key_attributes>

    /* Check that the output buffer is large enough */
    if (output_size < PSA_ASYMMETRIC_ENCRYPT_OUTPUT_SIZE(type, key_bits, alg)) {
 c039d90:	f244 0201 	movw	r2, #16385	@ 0x4001
 c039d94:	f428 5340 	bic.w	r3, r8, #12288	@ 0x3000
 c039d98:	4293      	cmp	r3, r2
 c039d9a:	d103      	bne.n	c039da4 <tfm_crypto_asymmetric_encrypt+0x88>
 c039d9c:	3707      	adds	r7, #7
 c039d9e:	ebb6 0fd7 	cmp.w	r6, r7, lsr #3
 c039da2:	d314      	bcc.n	c039dce <tfm_crypto_asymmetric_encrypt+0xb2>
        return PSA_ERROR_BUFFER_TOO_SMALL;
    }

    return psa_asymmetric_encrypt(encoded_key, alg, input, input_length,
 c039da4:	3404      	adds	r4, #4
 c039da6:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 c039da8:	e9cd 6404 	strd	r6, r4, [sp, #16]
 c039dac:	e9cd ab02 	strd	sl, fp, [sp, #8]
 c039db0:	9300      	str	r3, [sp, #0]
 c039db2:	f8cd 9004 	str.w	r9, [sp, #4]
 c039db6:	e9dd 2307 	ldrd	r2, r3, [sp, #28]
 c039dba:	e895 0003 	ldmia.w	r5, {r0, r1}
 c039dbe:	f00c f889 	bl	c045ed4 <mbedcrypto__psa_asymmetric_encrypt>
                                  salt, salt_length,
                                  output, output_size, &(out_vec[0].len));
#endif /* TFM_CRYPTO_ASYMMETRIC_MODULE_DISABLED */
}
 c039dc2:	b019      	add	sp, #100	@ 0x64
 c039dc4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 3, out_len, 0, 1);
 c039dc8:	f06f 0080 	mvn.w	r0, #128	@ 0x80
 c039dcc:	e7f9      	b.n	c039dc2 <tfm_crypto_asymmetric_encrypt+0xa6>
        return PSA_ERROR_BUFFER_TOO_SMALL;
 c039dce:	f06f 0089 	mvn.w	r0, #137	@ 0x89
 c039dd2:	e7f6      	b.n	c039dc2 <tfm_crypto_asymmetric_encrypt+0xa6>

0c039dd4 <tfm_crypto_asymmetric_decrypt>:

psa_status_t tfm_crypto_asymmetric_decrypt(psa_invec in_vec[],
                                           size_t in_len,
                                           psa_outvec out_vec[],
                                           size_t out_len)
{
 c039dd4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c039dd8:	4614      	mov	r4, r2
#ifdef TFM_CRYPTO_ASYMMETRIC_MODULE_DISABLED
    return PSA_ERROR_NOT_SUPPORTED;
#else

    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 3, out_len, 0, 1);
 c039dda:	b24a      	sxtb	r2, r1
 c039ddc:	2a00      	cmp	r2, #0
{
 c039dde:	b08b      	sub	sp, #44	@ 0x2c
    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 3, out_len, 0, 1);
 c039de0:	dd30      	ble.n	c039e44 <tfm_crypto_asymmetric_decrypt+0x70>
 c039de2:	2903      	cmp	r1, #3
 c039de4:	d82e      	bhi.n	c039e44 <tfm_crypto_asymmetric_decrypt+0x70>
 c039de6:	061a      	lsls	r2, r3, #24
 c039de8:	d42c      	bmi.n	c039e44 <tfm_crypto_asymmetric_decrypt+0x70>
 c039dea:	2b01      	cmp	r3, #1
 c039dec:	d82a      	bhi.n	c039e44 <tfm_crypto_asymmetric_decrypt+0x70>

    if ((in_vec[0].len != sizeof(struct tfm_crypto_pack_iovec))) {
 c039dee:	6843      	ldr	r3, [r0, #4]
 c039df0:	2b2c      	cmp	r3, #44	@ 0x2c
 c039df2:	d127      	bne.n	c039e44 <tfm_crypto_asymmetric_decrypt+0x70>

    psa_key_id_t key_id = iov->key_id;
    psa_algorithm_t alg = iov->alg;
    const uint8_t *input = in_vec[1].base;
    size_t input_length = in_vec[1].len;
    const uint8_t *salt = in_vec[2].base;
 c039df4:	e9d0 7503 	ldrd	r7, r5, [r0, #12]
    size_t salt_length = in_vec[2].len;
    uint8_t *output = out_vec[0].base;
    size_t output_size = out_vec[0].len;
 c039df8:	e9d4 ab00 	ldrd	sl, fp, [r4]
    const struct tfm_crypto_pack_iovec *iov = in_vec[0].base;
 c039dfc:	6802      	ldr	r2, [r0, #0]
    size_t salt_length = in_vec[2].len;
 c039dfe:	f8d0 9014 	ldr.w	r9, [r0, #20]
    psa_algorithm_t alg = iov->alg;
 c039e02:	e9d2 6302 	ldrd	r6, r3, [r2, #8]
 c039e06:	9306      	str	r3, [sp, #24]
    const uint8_t *input = in_vec[1].base;
 c039e08:	6883      	ldr	r3, [r0, #8]
    psa_status_t status;
    mbedtls_svc_key_id_t encoded_key;

    status = tfm_crypto_check_handle_owner(key_id, NULL);
 c039e0a:	2100      	movs	r1, #0
 c039e0c:	4630      	mov	r0, r6
    const uint8_t *input = in_vec[1].base;
 c039e0e:	9307      	str	r3, [sp, #28]
    status = tfm_crypto_check_handle_owner(key_id, NULL);
 c039e10:	f000 fc3e 	bl	c03a690 <tfm_crypto_check_handle_owner>
    if (status != PSA_SUCCESS) {
 c039e14:	b998      	cbnz	r0, c039e3e <tfm_crypto_asymmetric_decrypt+0x6a>
        return status;
    }

    status = tfm_crypto_encode_id_and_owner(key_id, &encoded_key);
 c039e16:	f10d 0820 	add.w	r8, sp, #32
 c039e1a:	4641      	mov	r1, r8
 c039e1c:	4630      	mov	r0, r6
 c039e1e:	f000 fc5f 	bl	c03a6e0 <tfm_crypto_encode_id_and_owner>
    if (status != PSA_SUCCESS) {
 c039e22:	b960      	cbnz	r0, c039e3e <tfm_crypto_asymmetric_decrypt+0x6a>
        return status;
    }

    return psa_asymmetric_decrypt(encoded_key, alg, input, input_length,
 c039e24:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
 c039e28:	3404      	adds	r4, #4
 c039e2a:	e9cd b404 	strd	fp, r4, [sp, #16]
 c039e2e:	e9cd 9a02 	strd	r9, sl, [sp, #8]
 c039e32:	e9cd 7500 	strd	r7, r5, [sp]
 c039e36:	e898 0003 	ldmia.w	r8, {r0, r1}
 c039e3a:	f00c f8db 	bl	c045ff4 <mbedcrypto__psa_asymmetric_decrypt>
                                  salt, salt_length,
                                  output, output_size, &(out_vec[0].len));
#endif /* TFM_CRYPTO_ASYMMETRIC_MODULE_DISABLED */
}
 c039e3e:	b00b      	add	sp, #44	@ 0x2c
 c039e40:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 3, out_len, 0, 1);
 c039e44:	f06f 0080 	mvn.w	r0, #128	@ 0x80
 c039e48:	e7f9      	b.n	c039e3e <tfm_crypto_asymmetric_decrypt+0x6a>

0c039e4a <tfm_crypto_cipher_generate_iv>:
/*!@{*/
psa_status_t tfm_crypto_cipher_generate_iv(psa_invec in_vec[],
                                           size_t in_len,
                                           psa_outvec out_vec[],
                                           size_t out_len)
{
 c039e4a:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
 c039e4e:	4614      	mov	r4, r2
#ifdef TFM_CRYPTO_CIPHER_MODULE_DISABLED
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status = PSA_SUCCESS;
    psa_cipher_operation_t *operation = NULL;
 c039e50:	2200      	movs	r2, #0
 c039e52:	9201      	str	r2, [sp, #4]

    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 1, out_len, 1, 2);
 c039e54:	b24a      	sxtb	r2, r1
 c039e56:	2a00      	cmp	r2, #0
{
 c039e58:	4605      	mov	r5, r0
 c039e5a:	4608      	mov	r0, r1
    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 1, out_len, 1, 2);
 c039e5c:	dd22      	ble.n	c039ea4 <tfm_crypto_cipher_generate_iv+0x5a>
 c039e5e:	2901      	cmp	r1, #1
 c039e60:	d120      	bne.n	c039ea4 <tfm_crypto_cipher_generate_iv+0x5a>
 c039e62:	b25a      	sxtb	r2, r3
 c039e64:	2a00      	cmp	r2, #0
 c039e66:	dd1d      	ble.n	c039ea4 <tfm_crypto_cipher_generate_iv+0x5a>
 c039e68:	2b02      	cmp	r3, #2
 c039e6a:	d81b      	bhi.n	c039ea4 <tfm_crypto_cipher_generate_iv+0x5a>

    if ((in_vec[0].len != sizeof(struct tfm_crypto_pack_iovec)) ||
 c039e6c:	686b      	ldr	r3, [r5, #4]
 c039e6e:	2b2c      	cmp	r3, #44	@ 0x2c
 c039e70:	d118      	bne.n	c039ea4 <tfm_crypto_cipher_generate_iv+0x5a>
 c039e72:	6863      	ldr	r3, [r4, #4]
 c039e74:	2b04      	cmp	r3, #4
 c039e76:	d115      	bne.n	c039ea4 <tfm_crypto_cipher_generate_iv+0x5a>

    const struct tfm_crypto_pack_iovec *iov = in_vec[0].base;
    uint32_t handle = iov->op_handle;
    uint32_t *handle_out = out_vec[0].base;
    unsigned char *iv = out_vec[1].base;
    size_t iv_size = out_vec[1].len;
 c039e78:	e9d4 7802 	ldrd	r7, r8, [r4, #8]
    uint32_t handle = iov->op_handle;
 c039e7c:	682b      	ldr	r3, [r5, #0]
    uint32_t *handle_out = out_vec[0].base;
 c039e7e:	6826      	ldr	r6, [r4, #0]
    uint32_t handle = iov->op_handle;
 c039e80:	691d      	ldr	r5, [r3, #16]

    /* Init the handle in the operation with the one passed from the iov */
    *handle_out = iov->op_handle;

    /* Look up the corresponding operation context */
    status = tfm_crypto_operation_lookup(TFM_CRYPTO_CIPHER_OPERATION,
 c039e82:	aa01      	add	r2, sp, #4
 c039e84:	4629      	mov	r1, r5
    *handle_out = iov->op_handle;
 c039e86:	6035      	str	r5, [r6, #0]
    status = tfm_crypto_operation_lookup(TFM_CRYPTO_CIPHER_OPERATION,
 c039e88:	f7ff febc 	bl	c039c04 <tfm_crypto_operation_lookup>
                                         handle,
                                         (void **)&operation);
    if (status != PSA_SUCCESS) {
 c039e8c:	b938      	cbnz	r0, c039e9e <tfm_crypto_cipher_generate_iv+0x54>
        return status;
    }

    *handle_out = handle;

    return psa_cipher_generate_iv(operation, iv, iv_size, &out_vec[1].len);
 c039e8e:	4642      	mov	r2, r8
 c039e90:	4639      	mov	r1, r7
 c039e92:	9801      	ldr	r0, [sp, #4]
    *handle_out = handle;
 c039e94:	6035      	str	r5, [r6, #0]
    return psa_cipher_generate_iv(operation, iv, iv_size, &out_vec[1].len);
 c039e96:	f104 030c 	add.w	r3, r4, #12
 c039e9a:	f00c fef3 	bl	c046c84 <mbedcrypto__psa_cipher_generate_iv>
#endif /* TFM_CRYPTO_CIPHER_MODULE_DISABLED */
}
 c039e9e:	b002      	add	sp, #8
 c039ea0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 1, out_len, 1, 2);
 c039ea4:	f06f 0080 	mvn.w	r0, #128	@ 0x80
 c039ea8:	e7f9      	b.n	c039e9e <tfm_crypto_cipher_generate_iv+0x54>

0c039eaa <tfm_crypto_cipher_set_iv>:

psa_status_t tfm_crypto_cipher_set_iv(psa_invec in_vec[],
                                      size_t in_len,
                                      psa_outvec out_vec[],
                                      size_t out_len)
{
 c039eaa:	b537      	push	{r0, r1, r2, r4, r5, lr}
 c039eac:	4604      	mov	r4, r0
 c039eae:	4618      	mov	r0, r3
#ifdef TFM_CRYPTO_CIPHER_MODULE_DISABLED
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status = PSA_SUCCESS;
    psa_cipher_operation_t *operation = NULL;
 c039eb0:	2300      	movs	r3, #0
 c039eb2:	9301      	str	r3, [sp, #4]

    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 2, out_len, 1, 1);
 c039eb4:	b24b      	sxtb	r3, r1
 c039eb6:	2b00      	cmp	r3, #0
 c039eb8:	dd1d      	ble.n	c039ef6 <tfm_crypto_cipher_set_iv+0x4c>
 c039eba:	2902      	cmp	r1, #2
 c039ebc:	d81b      	bhi.n	c039ef6 <tfm_crypto_cipher_set_iv+0x4c>
 c039ebe:	b243      	sxtb	r3, r0
 c039ec0:	2b00      	cmp	r3, #0
 c039ec2:	dd18      	ble.n	c039ef6 <tfm_crypto_cipher_set_iv+0x4c>
 c039ec4:	2801      	cmp	r0, #1
 c039ec6:	d116      	bne.n	c039ef6 <tfm_crypto_cipher_set_iv+0x4c>

    if ((in_vec[0].len != sizeof(struct tfm_crypto_pack_iovec)) ||
 c039ec8:	6863      	ldr	r3, [r4, #4]
 c039eca:	2b2c      	cmp	r3, #44	@ 0x2c
 c039ecc:	d113      	bne.n	c039ef6 <tfm_crypto_cipher_set_iv+0x4c>
 c039ece:	6853      	ldr	r3, [r2, #4]
 c039ed0:	2b04      	cmp	r3, #4
 c039ed2:	d110      	bne.n	c039ef6 <tfm_crypto_cipher_set_iv+0x4c>
        (out_vec[0].len != sizeof(uint32_t))) {
        return PSA_ERROR_PROGRAMMER_ERROR;
    }
    const struct tfm_crypto_pack_iovec *iov = in_vec[0].base;
    uint32_t handle = iov->op_handle;
 c039ed4:	6823      	ldr	r3, [r4, #0]
    uint32_t *handle_out = out_vec[0].base;
    const unsigned char *iv = in_vec[1].base;
    size_t iv_length = in_vec[1].len;
 c039ed6:	e9d4 5402 	ldrd	r5, r4, [r4, #8]
    uint32_t handle = iov->op_handle;
 c039eda:	6919      	ldr	r1, [r3, #16]

    /* Init the handle in the operation with the one passed from the iov */
    *handle_out = iov->op_handle;
 c039edc:	6813      	ldr	r3, [r2, #0]

    /* Look up the corresponding operation context */
    status = tfm_crypto_operation_lookup(TFM_CRYPTO_CIPHER_OPERATION,
 c039ede:	aa01      	add	r2, sp, #4
    *handle_out = iov->op_handle;
 c039ee0:	6019      	str	r1, [r3, #0]
    status = tfm_crypto_operation_lookup(TFM_CRYPTO_CIPHER_OPERATION,
 c039ee2:	f7ff fe8f 	bl	c039c04 <tfm_crypto_operation_lookup>
                                         handle,
                                         (void **)&operation);
    if (status != PSA_SUCCESS) {
 c039ee6:	b920      	cbnz	r0, c039ef2 <tfm_crypto_cipher_set_iv+0x48>
        return status;
    }

    return psa_cipher_set_iv(operation, iv, iv_length);
 c039ee8:	4622      	mov	r2, r4
 c039eea:	4629      	mov	r1, r5
 c039eec:	9801      	ldr	r0, [sp, #4]
 c039eee:	f00c f9b7 	bl	c046260 <mbedcrypto__psa_cipher_set_iv>
#endif /* TFM_CRYPTO_CIPHER_MODULE_DISABLED */
}
 c039ef2:	b003      	add	sp, #12
 c039ef4:	bd30      	pop	{r4, r5, pc}
    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 2, out_len, 1, 1);
 c039ef6:	f06f 0080 	mvn.w	r0, #128	@ 0x80
 c039efa:	e7fa      	b.n	c039ef2 <tfm_crypto_cipher_set_iv+0x48>

0c039efc <tfm_crypto_cipher_encrypt_setup>:

psa_status_t tfm_crypto_cipher_encrypt_setup(psa_invec in_vec[],
                                             size_t in_len,
                                             psa_outvec out_vec[],
                                             size_t out_len)
{
 c039efc:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
 c039f00:	460c      	mov	r4, r1
#ifdef TFM_CRYPTO_CIPHER_MODULE_DISABLED
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status = PSA_SUCCESS;
    psa_cipher_operation_t *operation = NULL;
 c039f02:	2100      	movs	r1, #0
{
 c039f04:	461d      	mov	r5, r3

    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 1, out_len, 1, 1);
 c039f06:	b263      	sxtb	r3, r4
 c039f08:	428b      	cmp	r3, r1
    psa_cipher_operation_t *operation = NULL;
 c039f0a:	9100      	str	r1, [sp, #0]
    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 1, out_len, 1, 1);
 c039f0c:	dd36      	ble.n	c039f7c <tfm_crypto_cipher_encrypt_setup+0x80>
 c039f0e:	2c01      	cmp	r4, #1
 c039f10:	d134      	bne.n	c039f7c <tfm_crypto_cipher_encrypt_setup+0x80>
 c039f12:	b26b      	sxtb	r3, r5
 c039f14:	428b      	cmp	r3, r1
 c039f16:	dd31      	ble.n	c039f7c <tfm_crypto_cipher_encrypt_setup+0x80>
 c039f18:	2d01      	cmp	r5, #1
 c039f1a:	d12f      	bne.n	c039f7c <tfm_crypto_cipher_encrypt_setup+0x80>

    if ((out_vec[0].len != sizeof(uint32_t)) ||
 c039f1c:	6853      	ldr	r3, [r2, #4]
 c039f1e:	2b04      	cmp	r3, #4
 c039f20:	d12c      	bne.n	c039f7c <tfm_crypto_cipher_encrypt_setup+0x80>
 c039f22:	6843      	ldr	r3, [r0, #4]
 c039f24:	2b2c      	cmp	r3, #44	@ 0x2c
 c039f26:	d129      	bne.n	c039f7c <tfm_crypto_cipher_encrypt_setup+0x80>
        (in_vec[0].len != sizeof(struct tfm_crypto_pack_iovec))) {
        return PSA_ERROR_PROGRAMMER_ERROR;
    }
    const struct tfm_crypto_pack_iovec *iov = in_vec[0].base;
 c039f28:	6803      	ldr	r3, [r0, #0]
    uint32_t handle = iov->op_handle;
    uint32_t *handle_out = out_vec[0].base;
 c039f2a:	6816      	ldr	r6, [r2, #0]
    uint32_t handle = iov->op_handle;
 c039f2c:	6918      	ldr	r0, [r3, #16]
    psa_key_id_t key_id = iov->key_id;
    psa_algorithm_t alg = iov->alg;
 c039f2e:	e9d3 8702 	ldrd	r8, r7, [r3, #8]
    uint32_t handle = iov->op_handle;
 c039f32:	9001      	str	r0, [sp, #4]
    mbedtls_svc_key_id_t encoded_key;

    status = tfm_crypto_check_handle_owner(key_id, NULL);
 c039f34:	4640      	mov	r0, r8
 c039f36:	f000 fbab 	bl	c03a690 <tfm_crypto_check_handle_owner>
    if (status != PSA_SUCCESS) {
 c039f3a:	4604      	mov	r4, r0
 c039f3c:	b9d0      	cbnz	r0, c039f74 <tfm_crypto_cipher_encrypt_setup+0x78>
        return status;
    }

    /* Allocate the operation context in the secure world */
    status = tfm_crypto_operation_alloc(TFM_CRYPTO_CIPHER_OPERATION,
 c039f3e:	466a      	mov	r2, sp
 c039f40:	4628      	mov	r0, r5
 c039f42:	a901      	add	r1, sp, #4
 c039f44:	f7ff fdf0 	bl	c039b28 <tfm_crypto_operation_alloc>
                                        &handle,
                                        (void **)&operation);
    if (status != PSA_SUCCESS) {
 c039f48:	4604      	mov	r4, r0
 c039f4a:	b998      	cbnz	r0, c039f74 <tfm_crypto_cipher_encrypt_setup+0x78>
        return status;
    }
    *handle_out = handle;
 c039f4c:	9b01      	ldr	r3, [sp, #4]

    status = tfm_crypto_encode_id_and_owner(key_id, &encoded_key);
 c039f4e:	ad02      	add	r5, sp, #8
 c039f50:	4629      	mov	r1, r5
 c039f52:	4640      	mov	r0, r8
    *handle_out = handle;
 c039f54:	6033      	str	r3, [r6, #0]
    status = tfm_crypto_encode_id_and_owner(key_id, &encoded_key);
 c039f56:	f000 fbc3 	bl	c03a6e0 <tfm_crypto_encode_id_and_owner>
    if (status != PSA_SUCCESS) {
 c039f5a:	4604      	mov	r4, r0
 c039f5c:	b938      	cbnz	r0, c039f6e <tfm_crypto_cipher_encrypt_setup+0x72>
        goto exit;
    }

    status = psa_cipher_encrypt_setup(operation, encoded_key, alg);
 c039f5e:	e895 0006 	ldmia.w	r5, {r1, r2}
 c039f62:	463b      	mov	r3, r7
 c039f64:	9800      	ldr	r0, [sp, #0]
 c039f66:	f00c f963 	bl	c046230 <mbedcrypto__psa_cipher_encrypt_setup>
    if (status != PSA_SUCCESS) {
 c039f6a:	4604      	mov	r4, r0
 c039f6c:	b110      	cbz	r0, c039f74 <tfm_crypto_cipher_encrypt_setup+0x78>

    return status;

exit:
    /* Release the operation context, ignore if the operation fails. */
    (void)tfm_crypto_operation_release(handle_out);
 c039f6e:	4630      	mov	r0, r6
 c039f70:	f7ff fe0e 	bl	c039b90 <tfm_crypto_operation_release>
    return status;
#endif /* TFM_CRYPTO_CIPHER_MODULE_DISABLED */
}
 c039f74:	4620      	mov	r0, r4
 c039f76:	b004      	add	sp, #16
 c039f78:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 1, out_len, 1, 1);
 c039f7c:	f06f 0480 	mvn.w	r4, #128	@ 0x80
 c039f80:	e7f8      	b.n	c039f74 <tfm_crypto_cipher_encrypt_setup+0x78>

0c039f82 <tfm_crypto_cipher_decrypt_setup>:

psa_status_t tfm_crypto_cipher_decrypt_setup(psa_invec in_vec[],
                                             size_t in_len,
                                             psa_outvec out_vec[],
                                             size_t out_len)
{
 c039f82:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
 c039f86:	460c      	mov	r4, r1
#ifdef TFM_CRYPTO_CIPHER_MODULE_DISABLED
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status = PSA_SUCCESS;
    psa_cipher_operation_t *operation = NULL;
 c039f88:	2100      	movs	r1, #0
{
 c039f8a:	461d      	mov	r5, r3

    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 1, out_len, 1, 1);
 c039f8c:	b263      	sxtb	r3, r4
 c039f8e:	428b      	cmp	r3, r1
    psa_cipher_operation_t *operation = NULL;
 c039f90:	9100      	str	r1, [sp, #0]
    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 1, out_len, 1, 1);
 c039f92:	dd36      	ble.n	c03a002 <tfm_crypto_cipher_decrypt_setup+0x80>
 c039f94:	2c01      	cmp	r4, #1
 c039f96:	d134      	bne.n	c03a002 <tfm_crypto_cipher_decrypt_setup+0x80>
 c039f98:	b26b      	sxtb	r3, r5
 c039f9a:	428b      	cmp	r3, r1
 c039f9c:	dd31      	ble.n	c03a002 <tfm_crypto_cipher_decrypt_setup+0x80>
 c039f9e:	2d01      	cmp	r5, #1
 c039fa0:	d12f      	bne.n	c03a002 <tfm_crypto_cipher_decrypt_setup+0x80>

    if ((out_vec[0].len != sizeof(uint32_t)) ||
 c039fa2:	6853      	ldr	r3, [r2, #4]
 c039fa4:	2b04      	cmp	r3, #4
 c039fa6:	d12c      	bne.n	c03a002 <tfm_crypto_cipher_decrypt_setup+0x80>
 c039fa8:	6843      	ldr	r3, [r0, #4]
 c039faa:	2b2c      	cmp	r3, #44	@ 0x2c
 c039fac:	d129      	bne.n	c03a002 <tfm_crypto_cipher_decrypt_setup+0x80>
        (in_vec[0].len != sizeof(struct tfm_crypto_pack_iovec))) {
        return PSA_ERROR_PROGRAMMER_ERROR;
    }
    const struct tfm_crypto_pack_iovec *iov = in_vec[0].base;
 c039fae:	6803      	ldr	r3, [r0, #0]
    uint32_t handle = iov->op_handle;
    uint32_t *handle_out = out_vec[0].base;
 c039fb0:	6816      	ldr	r6, [r2, #0]
    uint32_t handle = iov->op_handle;
 c039fb2:	6918      	ldr	r0, [r3, #16]
    psa_key_id_t key_id = iov->key_id;
    psa_algorithm_t alg = iov->alg;
 c039fb4:	e9d3 8702 	ldrd	r8, r7, [r3, #8]
    uint32_t handle = iov->op_handle;
 c039fb8:	9001      	str	r0, [sp, #4]
    mbedtls_svc_key_id_t encoded_key;

    status = tfm_crypto_check_handle_owner(key_id, NULL);
 c039fba:	4640      	mov	r0, r8
 c039fbc:	f000 fb68 	bl	c03a690 <tfm_crypto_check_handle_owner>
    if (status != PSA_SUCCESS) {
 c039fc0:	4604      	mov	r4, r0
 c039fc2:	b9d0      	cbnz	r0, c039ffa <tfm_crypto_cipher_decrypt_setup+0x78>
        return status;
    }

    /* Allocate the operation context in the secure world */
    status = tfm_crypto_operation_alloc(TFM_CRYPTO_CIPHER_OPERATION,
 c039fc4:	466a      	mov	r2, sp
 c039fc6:	4628      	mov	r0, r5
 c039fc8:	a901      	add	r1, sp, #4
 c039fca:	f7ff fdad 	bl	c039b28 <tfm_crypto_operation_alloc>
                                        &handle,
                                        (void **)&operation);
    if (status != PSA_SUCCESS) {
 c039fce:	4604      	mov	r4, r0
 c039fd0:	b998      	cbnz	r0, c039ffa <tfm_crypto_cipher_decrypt_setup+0x78>
        return status;
    }

    *handle_out = handle;
 c039fd2:	9b01      	ldr	r3, [sp, #4]
    status = tfm_crypto_encode_id_and_owner(key_id, &encoded_key);
 c039fd4:	ad02      	add	r5, sp, #8
 c039fd6:	4629      	mov	r1, r5
 c039fd8:	4640      	mov	r0, r8
    *handle_out = handle;
 c039fda:	6033      	str	r3, [r6, #0]
    status = tfm_crypto_encode_id_and_owner(key_id, &encoded_key);
 c039fdc:	f000 fb80 	bl	c03a6e0 <tfm_crypto_encode_id_and_owner>
    if (status != PSA_SUCCESS) {
 c039fe0:	4604      	mov	r4, r0
 c039fe2:	b938      	cbnz	r0, c039ff4 <tfm_crypto_cipher_decrypt_setup+0x72>
        goto exit;
    }

    status = psa_cipher_decrypt_setup(operation, encoded_key, alg);
 c039fe4:	e895 0006 	ldmia.w	r5, {r1, r2}
 c039fe8:	463b      	mov	r3, r7
 c039fea:	9800      	ldr	r0, [sp, #0]
 c039fec:	f00c f92c 	bl	c046248 <mbedcrypto__psa_cipher_decrypt_setup>
    if (status != PSA_SUCCESS) {
 c039ff0:	4604      	mov	r4, r0
 c039ff2:	b110      	cbz	r0, c039ffa <tfm_crypto_cipher_decrypt_setup+0x78>

    return status;

exit:
    /* Release the operation context, ignore if the operation fails. */
    (void)tfm_crypto_operation_release(handle_out);
 c039ff4:	4630      	mov	r0, r6
 c039ff6:	f7ff fdcb 	bl	c039b90 <tfm_crypto_operation_release>
    return status;
#endif /* TFM_CRYPTO_CIPHER_MODULE_DISABLED */
}
 c039ffa:	4620      	mov	r0, r4
 c039ffc:	b004      	add	sp, #16
 c039ffe:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 1, out_len, 1, 1);
 c03a002:	f06f 0480 	mvn.w	r4, #128	@ 0x80
 c03a006:	e7f8      	b.n	c039ffa <tfm_crypto_cipher_decrypt_setup+0x78>

0c03a008 <tfm_crypto_cipher_update>:

psa_status_t tfm_crypto_cipher_update(psa_invec in_vec[],
                                      size_t in_len,
                                      psa_outvec out_vec[],
                                      size_t out_len)
{
 c03a008:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
 c03a00c:	4614      	mov	r4, r2
#ifdef TFM_CRYPTO_CIPHER_MODULE_DISABLED
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status = PSA_SUCCESS;
    psa_cipher_operation_t *operation = NULL;
 c03a00e:	2200      	movs	r2, #0

    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 2, out_len, 1, 2);
 c03a010:	b24d      	sxtb	r5, r1
 c03a012:	4295      	cmp	r5, r2
    psa_cipher_operation_t *operation = NULL;
 c03a014:	9203      	str	r2, [sp, #12]
    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 2, out_len, 1, 2);
 c03a016:	dd26      	ble.n	c03a066 <tfm_crypto_cipher_update+0x5e>
 c03a018:	2902      	cmp	r1, #2
 c03a01a:	d824      	bhi.n	c03a066 <tfm_crypto_cipher_update+0x5e>
 c03a01c:	b259      	sxtb	r1, r3
 c03a01e:	4291      	cmp	r1, r2
 c03a020:	dd21      	ble.n	c03a066 <tfm_crypto_cipher_update+0x5e>
 c03a022:	2b02      	cmp	r3, #2
 c03a024:	d81f      	bhi.n	c03a066 <tfm_crypto_cipher_update+0x5e>

    if ((in_vec[0].len != sizeof(struct tfm_crypto_pack_iovec)) ||
 c03a026:	6843      	ldr	r3, [r0, #4]
 c03a028:	2b2c      	cmp	r3, #44	@ 0x2c
 c03a02a:	d11c      	bne.n	c03a066 <tfm_crypto_cipher_update+0x5e>
 c03a02c:	6863      	ldr	r3, [r4, #4]
 c03a02e:	2b04      	cmp	r3, #4
 c03a030:	d119      	bne.n	c03a066 <tfm_crypto_cipher_update+0x5e>

    const struct tfm_crypto_pack_iovec *iov = in_vec[0].base;
    uint32_t handle = iov->op_handle;
    uint32_t *handle_out = out_vec[0].base;
    const uint8_t *input = in_vec[1].base;
    size_t input_length = in_vec[1].len;
 c03a032:	e9d0 5602 	ldrd	r5, r6, [r0, #8]
    unsigned char *output = out_vec[1].base;
    size_t output_size = out_vec[1].len;
 c03a036:	e9d4 7802 	ldrd	r7, r8, [r4, #8]
    uint32_t handle = iov->op_handle;
 c03a03a:	6803      	ldr	r3, [r0, #0]

    /* Initialise the output_length to zero */
    out_vec[1].len = 0;

    /* Look up the corresponding operation context */
    status = tfm_crypto_operation_lookup(TFM_CRYPTO_CIPHER_OPERATION,
 c03a03c:	2001      	movs	r0, #1
    uint32_t handle = iov->op_handle;
 c03a03e:	6919      	ldr	r1, [r3, #16]
    *handle_out = iov->op_handle;
 c03a040:	6823      	ldr	r3, [r4, #0]
 c03a042:	6019      	str	r1, [r3, #0]
    out_vec[1].len = 0;
 c03a044:	60e2      	str	r2, [r4, #12]
    status = tfm_crypto_operation_lookup(TFM_CRYPTO_CIPHER_OPERATION,
 c03a046:	aa03      	add	r2, sp, #12
 c03a048:	f7ff fddc 	bl	c039c04 <tfm_crypto_operation_lookup>
                                         handle,
                                         (void **)&operation);
    if (status != PSA_SUCCESS) {
 c03a04c:	b940      	cbnz	r0, c03a060 <tfm_crypto_cipher_update+0x58>
        return status;
    }

    return psa_cipher_update(operation, input, input_length,
 c03a04e:	340c      	adds	r4, #12
 c03a050:	463b      	mov	r3, r7
 c03a052:	4632      	mov	r2, r6
 c03a054:	4629      	mov	r1, r5
 c03a056:	e9cd 8400 	strd	r8, r4, [sp]
 c03a05a:	9803      	ldr	r0, [sp, #12]
 c03a05c:	f00c f91e 	bl	c04629c <mbedcrypto__psa_cipher_update>
                             output, output_size, &out_vec[1].len);
#endif /* TFM_CRYPTO_CIPHER_MODULE_DISABLED */
}
 c03a060:	b004      	add	sp, #16
 c03a062:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 2, out_len, 1, 2);
 c03a066:	f06f 0080 	mvn.w	r0, #128	@ 0x80
 c03a06a:	e7f9      	b.n	c03a060 <tfm_crypto_cipher_update+0x58>

0c03a06c <tfm_crypto_cipher_finish>:

psa_status_t tfm_crypto_cipher_finish(psa_invec in_vec[],
                                      size_t in_len,
                                      psa_outvec out_vec[],
                                      size_t out_len)
{
 c03a06c:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
 c03a070:	4615      	mov	r5, r2
#ifdef TFM_CRYPTO_CIPHER_MODULE_DISABLED
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status = PSA_SUCCESS;
    psa_cipher_operation_t *operation = NULL;
 c03a072:	2200      	movs	r2, #0
{
 c03a074:	4604      	mov	r4, r0
 c03a076:	4608      	mov	r0, r1

    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 1, out_len, 1, 2);
 c03a078:	b249      	sxtb	r1, r1
 c03a07a:	4291      	cmp	r1, r2
    psa_cipher_operation_t *operation = NULL;
 c03a07c:	9201      	str	r2, [sp, #4]
    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 1, out_len, 1, 2);
 c03a07e:	dd28      	ble.n	c03a0d2 <tfm_crypto_cipher_finish+0x66>
 c03a080:	2801      	cmp	r0, #1
 c03a082:	d126      	bne.n	c03a0d2 <tfm_crypto_cipher_finish+0x66>
 c03a084:	b259      	sxtb	r1, r3
 c03a086:	4291      	cmp	r1, r2
 c03a088:	dd23      	ble.n	c03a0d2 <tfm_crypto_cipher_finish+0x66>
 c03a08a:	2b02      	cmp	r3, #2
 c03a08c:	d821      	bhi.n	c03a0d2 <tfm_crypto_cipher_finish+0x66>

    if ((in_vec[0].len != sizeof(struct tfm_crypto_pack_iovec)) ||
 c03a08e:	6863      	ldr	r3, [r4, #4]
 c03a090:	2b2c      	cmp	r3, #44	@ 0x2c
 c03a092:	d11e      	bne.n	c03a0d2 <tfm_crypto_cipher_finish+0x66>
 c03a094:	686b      	ldr	r3, [r5, #4]
 c03a096:	2b04      	cmp	r3, #4
 c03a098:	d11b      	bne.n	c03a0d2 <tfm_crypto_cipher_finish+0x66>
    }
    const struct tfm_crypto_pack_iovec *iov = in_vec[0].base;
    uint32_t handle = iov->op_handle;
    uint32_t *handle_out = out_vec[0].base;
    unsigned char *output = out_vec[1].base;
    size_t output_size = out_vec[1].len;
 c03a09a:	e9d5 7802 	ldrd	r7, r8, [r5, #8]
    uint32_t handle = iov->op_handle;
 c03a09e:	6823      	ldr	r3, [r4, #0]
    uint32_t *handle_out = out_vec[0].base;
 c03a0a0:	682e      	ldr	r6, [r5, #0]
    uint32_t handle = iov->op_handle;
 c03a0a2:	6919      	ldr	r1, [r3, #16]

    /* Init the handle in the operation with the one passed from the iov */
    *handle_out = iov->op_handle;
 c03a0a4:	6031      	str	r1, [r6, #0]

    /* Initialise the output_length to zero */
    out_vec[1].len = 0;
 c03a0a6:	60ea      	str	r2, [r5, #12]

    /* Look up the corresponding operation context */
    status = tfm_crypto_operation_lookup(TFM_CRYPTO_CIPHER_OPERATION,
 c03a0a8:	aa01      	add	r2, sp, #4
 c03a0aa:	f7ff fdab 	bl	c039c04 <tfm_crypto_operation_lookup>
                                         handle,
                                         (void **)&operation);
    if (status != PSA_SUCCESS) {
 c03a0ae:	4604      	mov	r4, r0
 c03a0b0:	b958      	cbnz	r0, c03a0ca <tfm_crypto_cipher_finish+0x5e>
        return status;
    }

    status = psa_cipher_finish(operation, output, output_size, &out_vec[1].len);
 c03a0b2:	4642      	mov	r2, r8
 c03a0b4:	4639      	mov	r1, r7
 c03a0b6:	9801      	ldr	r0, [sp, #4]
 c03a0b8:	f105 030c 	add.w	r3, r5, #12
 c03a0bc:	f00c f908 	bl	c0462d0 <mbedcrypto__psa_cipher_finish>
    if (status == PSA_SUCCESS) {
 c03a0c0:	4604      	mov	r4, r0
 c03a0c2:	b910      	cbnz	r0, c03a0ca <tfm_crypto_cipher_finish+0x5e>
        /* Release the operation context, ignore if the operation fails. */
        (void)tfm_crypto_operation_release(handle_out);
 c03a0c4:	4630      	mov	r0, r6
 c03a0c6:	f7ff fd63 	bl	c039b90 <tfm_crypto_operation_release>
    }

    return status;
#endif /* TFM_CRYPTO_CIPHER_MODULE_DISABLED */
}
 c03a0ca:	4620      	mov	r0, r4
 c03a0cc:	b002      	add	sp, #8
 c03a0ce:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 1, out_len, 1, 2);
 c03a0d2:	f06f 0480 	mvn.w	r4, #128	@ 0x80
 c03a0d6:	e7f8      	b.n	c03a0ca <tfm_crypto_cipher_finish+0x5e>

0c03a0d8 <tfm_crypto_cipher_abort>:

psa_status_t tfm_crypto_cipher_abort(psa_invec in_vec[],
                                     size_t in_len,
                                     psa_outvec out_vec[],
                                     size_t out_len)
{
 c03a0d8:	b537      	push	{r0, r1, r2, r4, r5, lr}
#ifdef TFM_CRYPTO_CIPHER_MODULE_DISABLED
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status = PSA_SUCCESS;
    psa_cipher_operation_t *operation = NULL;
 c03a0da:	2400      	movs	r4, #0
{
 c03a0dc:	4605      	mov	r5, r0
 c03a0de:	4618      	mov	r0, r3

    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 1, out_len, 1, 1);
 c03a0e0:	b24b      	sxtb	r3, r1
 c03a0e2:	42a3      	cmp	r3, r4
    psa_cipher_operation_t *operation = NULL;
 c03a0e4:	9401      	str	r4, [sp, #4]
    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 1, out_len, 1, 1);
 c03a0e6:	dd23      	ble.n	c03a130 <tfm_crypto_cipher_abort+0x58>
 c03a0e8:	2901      	cmp	r1, #1
 c03a0ea:	d121      	bne.n	c03a130 <tfm_crypto_cipher_abort+0x58>
 c03a0ec:	b243      	sxtb	r3, r0
 c03a0ee:	42a3      	cmp	r3, r4
 c03a0f0:	dd1e      	ble.n	c03a130 <tfm_crypto_cipher_abort+0x58>
 c03a0f2:	2801      	cmp	r0, #1
 c03a0f4:	d11c      	bne.n	c03a130 <tfm_crypto_cipher_abort+0x58>

    if ((in_vec[0].len != sizeof(struct tfm_crypto_pack_iovec)) ||
 c03a0f6:	686b      	ldr	r3, [r5, #4]
 c03a0f8:	2b2c      	cmp	r3, #44	@ 0x2c
 c03a0fa:	d119      	bne.n	c03a130 <tfm_crypto_cipher_abort+0x58>
 c03a0fc:	6853      	ldr	r3, [r2, #4]
 c03a0fe:	2b04      	cmp	r3, #4
 c03a100:	d116      	bne.n	c03a130 <tfm_crypto_cipher_abort+0x58>
        (out_vec[0].len != sizeof(uint32_t))) {
        return PSA_ERROR_PROGRAMMER_ERROR;
    }
    const struct tfm_crypto_pack_iovec *iov = in_vec[0].base;
    uint32_t handle = iov->op_handle;
 c03a102:	682b      	ldr	r3, [r5, #0]
    uint32_t *handle_out = out_vec[0].base;
 c03a104:	6815      	ldr	r5, [r2, #0]
    uint32_t handle = iov->op_handle;
 c03a106:	6919      	ldr	r1, [r3, #16]

    /* Init the handle in the operation with the one passed from the iov */
    *handle_out = iov->op_handle;

    /* Look up the corresponding operation context */
    status = tfm_crypto_operation_lookup(TFM_CRYPTO_CIPHER_OPERATION,
 c03a108:	aa01      	add	r2, sp, #4
    *handle_out = iov->op_handle;
 c03a10a:	6029      	str	r1, [r5, #0]
    status = tfm_crypto_operation_lookup(TFM_CRYPTO_CIPHER_OPERATION,
 c03a10c:	f7ff fd7a 	bl	c039c04 <tfm_crypto_operation_lookup>
                                         handle,
                                         (void **)&operation);
    if (status != PSA_SUCCESS) {
 c03a110:	b938      	cbnz	r0, c03a122 <tfm_crypto_cipher_abort+0x4a>
        /* Operation does not exist, so abort has no effect */
        return PSA_SUCCESS;
    }

    status = psa_cipher_abort(operation);
 c03a112:	9801      	ldr	r0, [sp, #4]
 c03a114:	f00b fff2 	bl	c0460fc <mbedcrypto__psa_cipher_abort>

    if (status != PSA_SUCCESS) {
 c03a118:	4604      	mov	r4, r0
        /* Release the operation context, ignore if the operation fails. */
        (void)tfm_crypto_operation_release(handle_out);
 c03a11a:	4628      	mov	r0, r5
    if (status != PSA_SUCCESS) {
 c03a11c:	b124      	cbz	r4, c03a128 <tfm_crypto_cipher_abort+0x50>
        (void)tfm_crypto_operation_release(handle_out);
 c03a11e:	f7ff fd37 	bl	c039b90 <tfm_crypto_operation_release>
        return status;
    }

    return tfm_crypto_operation_release(handle_out);
#endif /* TFM_CRYPTO_CIPHER_MODULE_DISABLED */
}
 c03a122:	4620      	mov	r0, r4
 c03a124:	b003      	add	sp, #12
 c03a126:	bd30      	pop	{r4, r5, pc}
    return tfm_crypto_operation_release(handle_out);
 c03a128:	f7ff fd32 	bl	c039b90 <tfm_crypto_operation_release>
 c03a12c:	4604      	mov	r4, r0
 c03a12e:	e7f8      	b.n	c03a122 <tfm_crypto_cipher_abort+0x4a>
    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 1, out_len, 1, 1);
 c03a130:	f06f 0480 	mvn.w	r4, #128	@ 0x80
 c03a134:	e7f5      	b.n	c03a122 <tfm_crypto_cipher_abort+0x4a>

0c03a136 <tfm_crypto_cipher_encrypt>:
                                       psa_outvec out_vec[],
                                       size_t out_len)
{
    /* FixMe: To be implemented */
    return PSA_ERROR_NOT_SUPPORTED;
}
 c03a136:	f06f 0085 	mvn.w	r0, #133	@ 0x85
 c03a13a:	4770      	bx	lr

0c03a13c <tfm_crypto_cipher_decrypt>:

psa_status_t tfm_crypto_cipher_decrypt(psa_invec in_vec[],
 c03a13c:	f06f 0085 	mvn.w	r0, #133	@ 0x85
 c03a140:	4770      	bx	lr

0c03a142 <tfm_crypto_hash_setup>:
/*!@{*/
psa_status_t tfm_crypto_hash_setup(psa_invec in_vec[],
                                   size_t in_len,
                                   psa_outvec out_vec[],
                                   size_t out_len)
{
 c03a142:	b573      	push	{r0, r1, r4, r5, r6, lr}
#ifdef TFM_CRYPTO_HASH_MODULE_DISABLED
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status = PSA_SUCCESS;
    psa_hash_operation_t *operation = NULL;
 c03a144:	2400      	movs	r4, #0
 c03a146:	9400      	str	r4, [sp, #0]

    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 1, out_len, 1, 1);
 c03a148:	b24c      	sxtb	r4, r1
 c03a14a:	2c00      	cmp	r4, #0
 c03a14c:	dd27      	ble.n	c03a19e <tfm_crypto_hash_setup+0x5c>
 c03a14e:	2901      	cmp	r1, #1
 c03a150:	d125      	bne.n	c03a19e <tfm_crypto_hash_setup+0x5c>
 c03a152:	b259      	sxtb	r1, r3
 c03a154:	2900      	cmp	r1, #0
 c03a156:	dd22      	ble.n	c03a19e <tfm_crypto_hash_setup+0x5c>
 c03a158:	2b01      	cmp	r3, #1
 c03a15a:	d120      	bne.n	c03a19e <tfm_crypto_hash_setup+0x5c>

    if ((out_vec[0].len != sizeof(uint32_t)) ||
 c03a15c:	6853      	ldr	r3, [r2, #4]
 c03a15e:	2b04      	cmp	r3, #4
 c03a160:	d11d      	bne.n	c03a19e <tfm_crypto_hash_setup+0x5c>
 c03a162:	6843      	ldr	r3, [r0, #4]
 c03a164:	2b2c      	cmp	r3, #44	@ 0x2c
 c03a166:	d11a      	bne.n	c03a19e <tfm_crypto_hash_setup+0x5c>
        (in_vec[0].len != sizeof(struct tfm_crypto_pack_iovec))) {
        return PSA_ERROR_PROGRAMMER_ERROR;
    }
    const struct tfm_crypto_pack_iovec *iov = in_vec[0].base;
 c03a168:	6801      	ldr	r1, [r0, #0]
    uint32_t handle = iov->op_handle;
    uint32_t *handle_out = out_vec[0].base;
 c03a16a:	6815      	ldr	r5, [r2, #0]
    uint32_t handle = iov->op_handle;
 c03a16c:	690b      	ldr	r3, [r1, #16]
    psa_algorithm_t alg = iov->alg;
 c03a16e:	68ce      	ldr	r6, [r1, #12]
    uint32_t handle = iov->op_handle;
 c03a170:	9301      	str	r3, [sp, #4]

    /* Init the handle in the operation with the one passed from the iov */
    *handle_out = iov->op_handle;

    /* Allocate the operation context in the secure world */
    status = tfm_crypto_operation_alloc(TFM_CRYPTO_HASH_OPERATION,
 c03a172:	466a      	mov	r2, sp
 c03a174:	2003      	movs	r0, #3
    *handle_out = iov->op_handle;
 c03a176:	602b      	str	r3, [r5, #0]
    status = tfm_crypto_operation_alloc(TFM_CRYPTO_HASH_OPERATION,
 c03a178:	a901      	add	r1, sp, #4
 c03a17a:	f7ff fcd5 	bl	c039b28 <tfm_crypto_operation_alloc>
                                        &handle,
                                        (void **)&operation);
    if (status != PSA_SUCCESS) {
 c03a17e:	4604      	mov	r4, r0
 c03a180:	b950      	cbnz	r0, c03a198 <tfm_crypto_hash_setup+0x56>
        return status;
    }

    *handle_out = handle;
 c03a182:	9b01      	ldr	r3, [sp, #4]

    status = psa_hash_setup(operation, alg);
 c03a184:	4631      	mov	r1, r6
 c03a186:	9800      	ldr	r0, [sp, #0]
    *handle_out = handle;
 c03a188:	602b      	str	r3, [r5, #0]
    status = psa_hash_setup(operation, alg);
 c03a18a:	f00b fab9 	bl	c045700 <mbedcrypto__psa_hash_setup>
    if (status != PSA_SUCCESS) {
 c03a18e:	4604      	mov	r4, r0
 c03a190:	b110      	cbz	r0, c03a198 <tfm_crypto_hash_setup+0x56>
        /* Release the operation context, ignore if the operation fails. */
        (void)tfm_crypto_operation_release(handle_out);
 c03a192:	4628      	mov	r0, r5
 c03a194:	f7ff fcfc 	bl	c039b90 <tfm_crypto_operation_release>
    }

    return status;
#endif /* TFM_CRYPTO_HASH_MODULE_DISABLED */
}
 c03a198:	4620      	mov	r0, r4
 c03a19a:	b002      	add	sp, #8
 c03a19c:	bd70      	pop	{r4, r5, r6, pc}
    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 1, out_len, 1, 1);
 c03a19e:	f06f 0480 	mvn.w	r4, #128	@ 0x80
 c03a1a2:	e7f9      	b.n	c03a198 <tfm_crypto_hash_setup+0x56>

0c03a1a4 <tfm_crypto_hash_update>:

psa_status_t tfm_crypto_hash_update(psa_invec in_vec[],
                                    size_t in_len,
                                    psa_outvec out_vec[],
                                    size_t out_len)
{
 c03a1a4:	b537      	push	{r0, r1, r2, r4, r5, lr}
#ifdef TFM_CRYPTO_HASH_MODULE_DISABLED
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status = PSA_SUCCESS;
    psa_hash_operation_t *operation = NULL;
 c03a1a6:	2400      	movs	r4, #0
 c03a1a8:	9401      	str	r4, [sp, #4]

    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 2, out_len, 1, 1);
 c03a1aa:	b24c      	sxtb	r4, r1
 c03a1ac:	2c00      	cmp	r4, #0
 c03a1ae:	dd1e      	ble.n	c03a1ee <tfm_crypto_hash_update+0x4a>
 c03a1b0:	2902      	cmp	r1, #2
 c03a1b2:	d81c      	bhi.n	c03a1ee <tfm_crypto_hash_update+0x4a>
 c03a1b4:	b259      	sxtb	r1, r3
 c03a1b6:	2900      	cmp	r1, #0
 c03a1b8:	dd19      	ble.n	c03a1ee <tfm_crypto_hash_update+0x4a>
 c03a1ba:	2b01      	cmp	r3, #1
 c03a1bc:	d117      	bne.n	c03a1ee <tfm_crypto_hash_update+0x4a>

    if ((in_vec[0].len != sizeof(struct tfm_crypto_pack_iovec)) ||
 c03a1be:	6843      	ldr	r3, [r0, #4]
 c03a1c0:	2b2c      	cmp	r3, #44	@ 0x2c
 c03a1c2:	d114      	bne.n	c03a1ee <tfm_crypto_hash_update+0x4a>
 c03a1c4:	6853      	ldr	r3, [r2, #4]
 c03a1c6:	2b04      	cmp	r3, #4
 c03a1c8:	d111      	bne.n	c03a1ee <tfm_crypto_hash_update+0x4a>
    }
    const struct tfm_crypto_pack_iovec *iov = in_vec[0].base;
    uint32_t handle = iov->op_handle;
    uint32_t *handle_out = out_vec[0].base;
    const uint8_t *input = in_vec[1].base;
    size_t input_length = in_vec[1].len;
 c03a1ca:	e9d0 4502 	ldrd	r4, r5, [r0, #8]
    uint32_t handle = iov->op_handle;
 c03a1ce:	6803      	ldr	r3, [r0, #0]

    /* Init the handle in the operation with the one passed from the iov */
    *handle_out = iov->op_handle;

    /* Look up the corresponding operation context */
    status = tfm_crypto_operation_lookup(TFM_CRYPTO_HASH_OPERATION,
 c03a1d0:	2003      	movs	r0, #3
    uint32_t handle = iov->op_handle;
 c03a1d2:	6919      	ldr	r1, [r3, #16]
    *handle_out = iov->op_handle;
 c03a1d4:	6813      	ldr	r3, [r2, #0]
    status = tfm_crypto_operation_lookup(TFM_CRYPTO_HASH_OPERATION,
 c03a1d6:	aa01      	add	r2, sp, #4
    *handle_out = iov->op_handle;
 c03a1d8:	6019      	str	r1, [r3, #0]
    status = tfm_crypto_operation_lookup(TFM_CRYPTO_HASH_OPERATION,
 c03a1da:	f7ff fd13 	bl	c039c04 <tfm_crypto_operation_lookup>
                                         handle,
                                         (void **)&operation);
    if (status != PSA_SUCCESS) {
 c03a1de:	b920      	cbnz	r0, c03a1ea <tfm_crypto_hash_update+0x46>
        return status;
    }

    return psa_hash_update(operation, input, input_length);
 c03a1e0:	462a      	mov	r2, r5
 c03a1e2:	4621      	mov	r1, r4
 c03a1e4:	9801      	ldr	r0, [sp, #4]
 c03a1e6:	f00b faab 	bl	c045740 <mbedcrypto__psa_hash_update>
#endif /* TFM_CRYPTO_HASH_MODULE_DISABLED */
}
 c03a1ea:	b003      	add	sp, #12
 c03a1ec:	bd30      	pop	{r4, r5, pc}
    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 2, out_len, 1, 1);
 c03a1ee:	f06f 0080 	mvn.w	r0, #128	@ 0x80
 c03a1f2:	e7fa      	b.n	c03a1ea <tfm_crypto_hash_update+0x46>

0c03a1f4 <tfm_crypto_hash_finish>:

psa_status_t tfm_crypto_hash_finish(psa_invec in_vec[],
                                    size_t in_len,
                                    psa_outvec out_vec[],
                                    size_t out_len)
{
 c03a1f4:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
 c03a1f8:	4615      	mov	r5, r2
#ifdef TFM_CRYPTO_HASH_MODULE_DISABLED
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status = PSA_SUCCESS;
    psa_hash_operation_t *operation = NULL;
 c03a1fa:	2200      	movs	r2, #0

    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 1, out_len, 1, 2);
 c03a1fc:	b24c      	sxtb	r4, r1
 c03a1fe:	4294      	cmp	r4, r2
    psa_hash_operation_t *operation = NULL;
 c03a200:	9201      	str	r2, [sp, #4]
    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 1, out_len, 1, 2);
 c03a202:	dd29      	ble.n	c03a258 <tfm_crypto_hash_finish+0x64>
 c03a204:	2901      	cmp	r1, #1
 c03a206:	d127      	bne.n	c03a258 <tfm_crypto_hash_finish+0x64>
 c03a208:	b259      	sxtb	r1, r3
 c03a20a:	4291      	cmp	r1, r2
 c03a20c:	dd24      	ble.n	c03a258 <tfm_crypto_hash_finish+0x64>
 c03a20e:	2b02      	cmp	r3, #2
 c03a210:	d822      	bhi.n	c03a258 <tfm_crypto_hash_finish+0x64>

    if ((in_vec[0].len != sizeof(struct tfm_crypto_pack_iovec)) ||
 c03a212:	6843      	ldr	r3, [r0, #4]
 c03a214:	2b2c      	cmp	r3, #44	@ 0x2c
 c03a216:	d11f      	bne.n	c03a258 <tfm_crypto_hash_finish+0x64>
 c03a218:	686b      	ldr	r3, [r5, #4]
 c03a21a:	2b04      	cmp	r3, #4
 c03a21c:	d11c      	bne.n	c03a258 <tfm_crypto_hash_finish+0x64>
    }
    const struct tfm_crypto_pack_iovec *iov = in_vec[0].base;
    uint32_t handle = iov->op_handle;
    uint32_t *handle_out = out_vec[0].base;
    uint8_t *hash = out_vec[1].base;
    size_t hash_size = out_vec[1].len;
 c03a21e:	e9d5 7802 	ldrd	r7, r8, [r5, #8]
    uint32_t handle = iov->op_handle;
 c03a222:	6803      	ldr	r3, [r0, #0]
    uint32_t *handle_out = out_vec[0].base;
 c03a224:	682e      	ldr	r6, [r5, #0]
    uint32_t handle = iov->op_handle;
 c03a226:	6919      	ldr	r1, [r3, #16]

    /* Initialise hash_length to zero */
    out_vec[1].len = 0;

    /* Look up the corresponding operation context */
    status = tfm_crypto_operation_lookup(TFM_CRYPTO_HASH_OPERATION,
 c03a228:	2003      	movs	r0, #3
    *handle_out = iov->op_handle;
 c03a22a:	6031      	str	r1, [r6, #0]
    out_vec[1].len = 0;
 c03a22c:	60ea      	str	r2, [r5, #12]
    status = tfm_crypto_operation_lookup(TFM_CRYPTO_HASH_OPERATION,
 c03a22e:	aa01      	add	r2, sp, #4
 c03a230:	f7ff fce8 	bl	c039c04 <tfm_crypto_operation_lookup>
                                         handle,
                                         (void **)&operation);
    if (status != PSA_SUCCESS) {
 c03a234:	4604      	mov	r4, r0
 c03a236:	b958      	cbnz	r0, c03a250 <tfm_crypto_hash_finish+0x5c>
        return status;
    }

    status = psa_hash_finish(operation, hash, hash_size, &out_vec[1].len);
 c03a238:	4642      	mov	r2, r8
 c03a23a:	4639      	mov	r1, r7
 c03a23c:	9801      	ldr	r0, [sp, #4]
 c03a23e:	f105 030c 	add.w	r3, r5, #12
 c03a242:	f00b fa91 	bl	c045768 <mbedcrypto__psa_hash_finish>
    if (status == PSA_SUCCESS) {
 c03a246:	4604      	mov	r4, r0
 c03a248:	b910      	cbnz	r0, c03a250 <tfm_crypto_hash_finish+0x5c>
        /* Release the operation context, ignore if the operation fails. */
        (void)tfm_crypto_operation_release(handle_out);
 c03a24a:	4630      	mov	r0, r6
 c03a24c:	f7ff fca0 	bl	c039b90 <tfm_crypto_operation_release>
    }

    return status;
#endif /* TFM_CRYPTO_HASH_MODULE_DISABLED */
}
 c03a250:	4620      	mov	r0, r4
 c03a252:	b002      	add	sp, #8
 c03a254:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 1, out_len, 1, 2);
 c03a258:	f06f 0480 	mvn.w	r4, #128	@ 0x80
 c03a25c:	e7f8      	b.n	c03a250 <tfm_crypto_hash_finish+0x5c>

0c03a25e <tfm_crypto_hash_verify>:

psa_status_t tfm_crypto_hash_verify(psa_invec in_vec[],
                                    size_t in_len,
                                    psa_outvec out_vec[],
                                    size_t out_len)
{
 c03a25e:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
#ifdef TFM_CRYPTO_HASH_MODULE_DISABLED
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status = PSA_SUCCESS;
    psa_hash_operation_t *operation = NULL;
 c03a260:	2400      	movs	r4, #0
 c03a262:	9401      	str	r4, [sp, #4]

    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 2, out_len, 1, 1);
 c03a264:	b24c      	sxtb	r4, r1
 c03a266:	2c00      	cmp	r4, #0
 c03a268:	dd25      	ble.n	c03a2b6 <tfm_crypto_hash_verify+0x58>
 c03a26a:	2902      	cmp	r1, #2
 c03a26c:	d823      	bhi.n	c03a2b6 <tfm_crypto_hash_verify+0x58>
 c03a26e:	b259      	sxtb	r1, r3
 c03a270:	2900      	cmp	r1, #0
 c03a272:	dd20      	ble.n	c03a2b6 <tfm_crypto_hash_verify+0x58>
 c03a274:	2b01      	cmp	r3, #1
 c03a276:	d11e      	bne.n	c03a2b6 <tfm_crypto_hash_verify+0x58>

    if ((in_vec[0].len != sizeof(struct tfm_crypto_pack_iovec)) ||
 c03a278:	6843      	ldr	r3, [r0, #4]
 c03a27a:	2b2c      	cmp	r3, #44	@ 0x2c
 c03a27c:	d11b      	bne.n	c03a2b6 <tfm_crypto_hash_verify+0x58>
 c03a27e:	6853      	ldr	r3, [r2, #4]
 c03a280:	2b04      	cmp	r3, #4
 c03a282:	d118      	bne.n	c03a2b6 <tfm_crypto_hash_verify+0x58>
    }
    const struct tfm_crypto_pack_iovec *iov = in_vec[0].base;
    uint32_t handle = iov->op_handle;
    uint32_t *handle_out = out_vec[0].base;
    const uint8_t *hash = in_vec[1].base;
    size_t hash_length = in_vec[1].len;
 c03a284:	e9d0 6702 	ldrd	r6, r7, [r0, #8]
    uint32_t handle = iov->op_handle;
 c03a288:	6803      	ldr	r3, [r0, #0]
    uint32_t *handle_out = out_vec[0].base;
 c03a28a:	6815      	ldr	r5, [r2, #0]
    uint32_t handle = iov->op_handle;
 c03a28c:	6919      	ldr	r1, [r3, #16]

    /* Init the handle in the operation with the one passed from the iov */
    *handle_out = iov->op_handle;

    /* Look up the corresponding operation context */
    status = tfm_crypto_operation_lookup(TFM_CRYPTO_HASH_OPERATION,
 c03a28e:	2003      	movs	r0, #3
    *handle_out = iov->op_handle;
 c03a290:	6029      	str	r1, [r5, #0]
    status = tfm_crypto_operation_lookup(TFM_CRYPTO_HASH_OPERATION,
 c03a292:	aa01      	add	r2, sp, #4
 c03a294:	f7ff fcb6 	bl	c039c04 <tfm_crypto_operation_lookup>
                                         handle,
                                         (void **)&operation);
    if (status != PSA_SUCCESS) {
 c03a298:	4604      	mov	r4, r0
 c03a29a:	b948      	cbnz	r0, c03a2b0 <tfm_crypto_hash_verify+0x52>
        return status;
    }

    status = psa_hash_verify(operation, hash, hash_length);
 c03a29c:	463a      	mov	r2, r7
 c03a29e:	4631      	mov	r1, r6
 c03a2a0:	9801      	ldr	r0, [sp, #4]
 c03a2a2:	f00b fa72 	bl	c04578a <mbedcrypto__psa_hash_verify>
    if (status == PSA_SUCCESS) {
 c03a2a6:	4604      	mov	r4, r0
 c03a2a8:	b910      	cbnz	r0, c03a2b0 <tfm_crypto_hash_verify+0x52>
        /* Release the operation context, ignore if the operation fails. */
        (void)tfm_crypto_operation_release(handle_out);
 c03a2aa:	4628      	mov	r0, r5
 c03a2ac:	f7ff fc70 	bl	c039b90 <tfm_crypto_operation_release>
    }

    return status;
#endif /* TFM_CRYPTO_HASH_MODULE_DISABLED */
}
 c03a2b0:	4620      	mov	r0, r4
 c03a2b2:	b003      	add	sp, #12
 c03a2b4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 2, out_len, 1, 1);
 c03a2b6:	f06f 0480 	mvn.w	r4, #128	@ 0x80
 c03a2ba:	e7f9      	b.n	c03a2b0 <tfm_crypto_hash_verify+0x52>

0c03a2bc <tfm_crypto_hash_abort>:

psa_status_t tfm_crypto_hash_abort(psa_invec in_vec[],
                                   size_t in_len,
                                   psa_outvec out_vec[],
                                   size_t out_len)
{
 c03a2bc:	b537      	push	{r0, r1, r2, r4, r5, lr}
#ifdef TFM_CRYPTO_HASH_MODULE_DISABLED
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status = PSA_SUCCESS;
    psa_hash_operation_t *operation = NULL;
 c03a2be:	2400      	movs	r4, #0

    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 1, out_len, 1, 1);
 c03a2c0:	b24d      	sxtb	r5, r1
 c03a2c2:	42a5      	cmp	r5, r4
    psa_hash_operation_t *operation = NULL;
 c03a2c4:	9401      	str	r4, [sp, #4]
    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 1, out_len, 1, 1);
 c03a2c6:	dd24      	ble.n	c03a312 <tfm_crypto_hash_abort+0x56>
 c03a2c8:	2901      	cmp	r1, #1
 c03a2ca:	d122      	bne.n	c03a312 <tfm_crypto_hash_abort+0x56>
 c03a2cc:	b259      	sxtb	r1, r3
 c03a2ce:	42a1      	cmp	r1, r4
 c03a2d0:	dd1f      	ble.n	c03a312 <tfm_crypto_hash_abort+0x56>
 c03a2d2:	2b01      	cmp	r3, #1
 c03a2d4:	d11d      	bne.n	c03a312 <tfm_crypto_hash_abort+0x56>

    if ((in_vec[0].len != sizeof(struct tfm_crypto_pack_iovec)) ||
 c03a2d6:	6843      	ldr	r3, [r0, #4]
 c03a2d8:	2b2c      	cmp	r3, #44	@ 0x2c
 c03a2da:	d11a      	bne.n	c03a312 <tfm_crypto_hash_abort+0x56>
 c03a2dc:	6853      	ldr	r3, [r2, #4]
 c03a2de:	2b04      	cmp	r3, #4
 c03a2e0:	d117      	bne.n	c03a312 <tfm_crypto_hash_abort+0x56>
        (out_vec[0].len != sizeof(uint32_t))) {
        return PSA_ERROR_PROGRAMMER_ERROR;
    }
    const struct tfm_crypto_pack_iovec *iov = in_vec[0].base;
    uint32_t handle = iov->op_handle;
 c03a2e2:	6803      	ldr	r3, [r0, #0]
    uint32_t *handle_out = out_vec[0].base;
 c03a2e4:	6815      	ldr	r5, [r2, #0]
    uint32_t handle = iov->op_handle;
 c03a2e6:	6919      	ldr	r1, [r3, #16]

    /* Init the handle in the operation with the one passed from the iov */
    *handle_out = iov->op_handle;

    /* Look up the corresponding operation context */
    status = tfm_crypto_operation_lookup(TFM_CRYPTO_HASH_OPERATION,
 c03a2e8:	2003      	movs	r0, #3
    *handle_out = iov->op_handle;
 c03a2ea:	6029      	str	r1, [r5, #0]
    status = tfm_crypto_operation_lookup(TFM_CRYPTO_HASH_OPERATION,
 c03a2ec:	aa01      	add	r2, sp, #4
 c03a2ee:	f7ff fc89 	bl	c039c04 <tfm_crypto_operation_lookup>
                                         handle,
                                         (void **)&operation);
    if (status != PSA_SUCCESS) {
 c03a2f2:	b938      	cbnz	r0, c03a304 <tfm_crypto_hash_abort+0x48>
        /* Operation does not exist, so abort has no effect */
        return PSA_SUCCESS;
    }

    status = psa_hash_abort(operation);
 c03a2f4:	9801      	ldr	r0, [sp, #4]
 c03a2f6:	f00b f9f8 	bl	c0456ea <mbedcrypto__psa_hash_abort>
    if (status != PSA_SUCCESS) {
 c03a2fa:	4604      	mov	r4, r0
        /* Release the operation context, ignore if the operation fails. */
        (void)tfm_crypto_operation_release(handle_out);
 c03a2fc:	4628      	mov	r0, r5
    if (status != PSA_SUCCESS) {
 c03a2fe:	b124      	cbz	r4, c03a30a <tfm_crypto_hash_abort+0x4e>
        (void)tfm_crypto_operation_release(handle_out);
 c03a300:	f7ff fc46 	bl	c039b90 <tfm_crypto_operation_release>
        return status;
    }

    return tfm_crypto_operation_release(handle_out);
#endif /* TFM_CRYPTO_HASH_MODULE_DISABLED */
}
 c03a304:	4620      	mov	r0, r4
 c03a306:	b003      	add	sp, #12
 c03a308:	bd30      	pop	{r4, r5, pc}
    return tfm_crypto_operation_release(handle_out);
 c03a30a:	f7ff fc41 	bl	c039b90 <tfm_crypto_operation_release>
 c03a30e:	4604      	mov	r4, r0
 c03a310:	e7f8      	b.n	c03a304 <tfm_crypto_hash_abort+0x48>
    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 1, out_len, 1, 1);
 c03a312:	f06f 0480 	mvn.w	r4, #128	@ 0x80
 c03a316:	e7f5      	b.n	c03a304 <tfm_crypto_hash_abort+0x48>

0c03a318 <tfm_crypto_hash_clone>:

psa_status_t tfm_crypto_hash_clone(psa_invec in_vec[],
                                   size_t in_len,
                                   psa_outvec out_vec[],
                                   size_t out_len)
{
 c03a318:	b513      	push	{r0, r1, r4, lr}
#ifdef TFM_CRYPTO_HASH_MODULE_DISABLED
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status = PSA_SUCCESS;
    psa_hash_operation_t *source_operation = NULL;
 c03a31a:	2400      	movs	r4, #0
    psa_hash_operation_t *target_operation = NULL;
 c03a31c:	e9cd 4400 	strd	r4, r4, [sp]

    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 1, out_len, 1, 1);
 c03a320:	b24c      	sxtb	r4, r1
 c03a322:	2c00      	cmp	r4, #0
 c03a324:	dd20      	ble.n	c03a368 <tfm_crypto_hash_clone+0x50>
 c03a326:	2901      	cmp	r1, #1
 c03a328:	d11e      	bne.n	c03a368 <tfm_crypto_hash_clone+0x50>
 c03a32a:	b259      	sxtb	r1, r3
 c03a32c:	2900      	cmp	r1, #0
 c03a32e:	dd1b      	ble.n	c03a368 <tfm_crypto_hash_clone+0x50>
 c03a330:	2b01      	cmp	r3, #1
 c03a332:	d119      	bne.n	c03a368 <tfm_crypto_hash_clone+0x50>

    if ((in_vec[0].len != sizeof(struct tfm_crypto_pack_iovec)) ||
 c03a334:	6843      	ldr	r3, [r0, #4]
 c03a336:	2b2c      	cmp	r3, #44	@ 0x2c
 c03a338:	d116      	bne.n	c03a368 <tfm_crypto_hash_clone+0x50>
 c03a33a:	6853      	ldr	r3, [r2, #4]
 c03a33c:	2b04      	cmp	r3, #4
 c03a33e:	d113      	bne.n	c03a368 <tfm_crypto_hash_clone+0x50>
        (out_vec[0].len != sizeof(uint32_t))) {
        return PSA_ERROR_PROGRAMMER_ERROR;
    }
    const struct tfm_crypto_pack_iovec *iov = in_vec[0].base;
    uint32_t source_handle = iov->op_handle;
 c03a340:	6803      	ldr	r3, [r0, #0]
    uint32_t *target_handle = out_vec[0].base;
 c03a342:	6814      	ldr	r4, [r2, #0]

    /* Look up the corresponding source operation context */
    status = tfm_crypto_operation_lookup(TFM_CRYPTO_HASH_OPERATION,
 c03a344:	2003      	movs	r0, #3
 c03a346:	466a      	mov	r2, sp
 c03a348:	6919      	ldr	r1, [r3, #16]
 c03a34a:	f7ff fc5b 	bl	c039c04 <tfm_crypto_operation_lookup>
                                         source_handle,
                                         (void **)&source_operation);
    if (status != PSA_SUCCESS) {
 c03a34e:	b948      	cbnz	r0, c03a364 <tfm_crypto_hash_clone+0x4c>
        return status;
    }

    /* Allocate the target operation context in the secure world */
    status = tfm_crypto_operation_alloc(TFM_CRYPTO_HASH_OPERATION,
 c03a350:	4621      	mov	r1, r4
 c03a352:	2003      	movs	r0, #3
 c03a354:	aa01      	add	r2, sp, #4
 c03a356:	f7ff fbe7 	bl	c039b28 <tfm_crypto_operation_alloc>
                                        target_handle,
                                        (void **)&target_operation);
    if (status != PSA_SUCCESS) {
 c03a35a:	b918      	cbnz	r0, c03a364 <tfm_crypto_hash_clone+0x4c>
        return status;
    }

    return psa_hash_clone(source_operation, target_operation);
 c03a35c:	e9dd 0100 	ldrd	r0, r1, [sp]
 c03a360:	f00b fa87 	bl	c045872 <mbedcrypto__psa_hash_clone>
#endif /* TFM_CRYPTO_HASH_MODULE_DISABLED */
}
 c03a364:	b002      	add	sp, #8
 c03a366:	bd10      	pop	{r4, pc}
    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 1, out_len, 1, 1);
 c03a368:	f06f 0080 	mvn.w	r0, #128	@ 0x80
 c03a36c:	e7fa      	b.n	c03a364 <tfm_crypto_hash_clone+0x4c>

0c03a36e <tfm_crypto_hash_compute>:

psa_status_t tfm_crypto_hash_compute(psa_invec in_vec[],
                                     size_t in_len,
                                     psa_outvec out_vec[],
                                     size_t out_len)
{
 c03a36e:	b573      	push	{r0, r1, r4, r5, r6, lr}
 c03a370:	4614      	mov	r4, r2
#ifdef TFM_CRYPTO_HASH_MODULE_DISABLED
    return PSA_ERROR_NOT_SUPPORTED;
#else

    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 2, out_len, 0, 1);
 c03a372:	b24a      	sxtb	r2, r1
 c03a374:	2a00      	cmp	r2, #0
{
 c03a376:	4605      	mov	r5, r0
    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 2, out_len, 0, 1);
 c03a378:	dd17      	ble.n	c03a3aa <tfm_crypto_hash_compute+0x3c>
 c03a37a:	2902      	cmp	r1, #2
 c03a37c:	d815      	bhi.n	c03a3aa <tfm_crypto_hash_compute+0x3c>
 c03a37e:	061a      	lsls	r2, r3, #24
 c03a380:	d413      	bmi.n	c03a3aa <tfm_crypto_hash_compute+0x3c>
 c03a382:	2b01      	cmp	r3, #1
 c03a384:	d811      	bhi.n	c03a3aa <tfm_crypto_hash_compute+0x3c>

    if ((in_vec[0].len != sizeof(struct tfm_crypto_pack_iovec))) {
 c03a386:	6843      	ldr	r3, [r0, #4]
 c03a388:	2b2c      	cmp	r3, #44	@ 0x2c
 c03a38a:	d10e      	bne.n	c03a3aa <tfm_crypto_hash_compute+0x3c>
    }

    const struct tfm_crypto_pack_iovec *iov = in_vec[0].base;
    psa_algorithm_t alg = iov->alg;
    const uint8_t *input = in_vec[1].base;
    size_t input_length = in_vec[1].len;
 c03a38c:	e9d5 1202 	ldrd	r1, r2, [r5, #8]
    uint8_t *hash = out_vec[0].base;
    size_t hash_size = out_vec[0].len;

    /* Initialize hash_length to zero */
    out_vec[0].len = 0;
 c03a390:	2600      	movs	r6, #0
    psa_algorithm_t alg = iov->alg;
 c03a392:	6803      	ldr	r3, [r0, #0]
 c03a394:	68d8      	ldr	r0, [r3, #12]
    size_t hash_size = out_vec[0].len;
 c03a396:	e9d4 3500 	ldrd	r3, r5, [r4]
    out_vec[0].len = 0;
 c03a39a:	f844 6f04 	str.w	r6, [r4, #4]!
    return psa_hash_compute(alg, input, input_length, hash, hash_size,
 c03a39e:	e9cd 5400 	strd	r5, r4, [sp]
 c03a3a2:	f00b fa20 	bl	c0457e6 <mbedcrypto__psa_hash_compute>
                            &out_vec[0].len);
#endif /* TFM_CRYPTO_HASH_MODULE_DISABLED */
}
 c03a3a6:	b002      	add	sp, #8
 c03a3a8:	bd70      	pop	{r4, r5, r6, pc}
    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 2, out_len, 0, 1);
 c03a3aa:	f06f 0080 	mvn.w	r0, #128	@ 0x80
 c03a3ae:	e7fa      	b.n	c03a3a6 <tfm_crypto_hash_compute+0x38>

0c03a3b0 <tfm_crypto_hash_compare>:
{
#ifdef TFM_CRYPTO_HASH_MODULE_DISABLED
    return PSA_ERROR_NOT_SUPPORTED;
#else

    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 3, out_len, 0, 0);
 c03a3b0:	b24a      	sxtb	r2, r1
 c03a3b2:	2a00      	cmp	r2, #0
{
 c03a3b4:	b513      	push	{r0, r1, r4, lr}
    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 3, out_len, 0, 0);
 c03a3b6:	dd12      	ble.n	c03a3de <tfm_crypto_hash_compare+0x2e>
 c03a3b8:	2903      	cmp	r1, #3
 c03a3ba:	d810      	bhi.n	c03a3de <tfm_crypto_hash_compare+0x2e>
 c03a3bc:	061a      	lsls	r2, r3, #24
 c03a3be:	d40e      	bmi.n	c03a3de <tfm_crypto_hash_compare+0x2e>
 c03a3c0:	b96b      	cbnz	r3, c03a3de <tfm_crypto_hash_compare+0x2e>

    if ((in_vec[0].len != sizeof(struct tfm_crypto_pack_iovec))) {
 c03a3c2:	6843      	ldr	r3, [r0, #4]
 c03a3c4:	2b2c      	cmp	r3, #44	@ 0x2c
 c03a3c6:	d10a      	bne.n	c03a3de <tfm_crypto_hash_compare+0x2e>
    const uint8_t *input = in_vec[1].base;
    size_t input_length = in_vec[1].len;
    const uint8_t *hash = in_vec[2].base;
    size_t hash_length = in_vec[2].len;

    return psa_hash_compare(alg, input, input_length, hash, hash_length);
 c03a3c8:	6943      	ldr	r3, [r0, #20]
    psa_algorithm_t alg = iov->alg;
 c03a3ca:	6804      	ldr	r4, [r0, #0]
    return psa_hash_compare(alg, input, input_length, hash, hash_length);
 c03a3cc:	9300      	str	r3, [sp, #0]
 c03a3ce:	6881      	ldr	r1, [r0, #8]
 c03a3d0:	e9d0 2303 	ldrd	r2, r3, [r0, #12]
 c03a3d4:	68e0      	ldr	r0, [r4, #12]
 c03a3d6:	f00b fa19 	bl	c04580c <mbedcrypto__psa_hash_compare>
#endif /* TFM_CRYPTO_HASH_MODULE_DISABLED */
}
 c03a3da:	b002      	add	sp, #8
 c03a3dc:	bd10      	pop	{r4, pc}
    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 3, out_len, 0, 0);
 c03a3de:	f06f 0080 	mvn.w	r0, #128	@ 0x80
 c03a3e2:	e7fa      	b.n	c03a3da <tfm_crypto_hash_compare+0x2a>

0c03a3e4 <tfm_crypto_clear_scratch>:

    return PSA_SUCCESS;
}

void tfm_crypto_clear_scratch(void)
{
 c03a3e4:	b538      	push	{r3, r4, r5, lr}
    scratch.owner = 0;
 c03a3e6:	2500      	movs	r5, #0
 c03a3e8:	4806      	ldr	r0, [pc, #24]	@ (c03a404 <tfm_crypto_clear_scratch+0x20>)
 c03a3ea:	4629      	mov	r1, r5
 c03a3ec:	f500 5480 	add.w	r4, r0, #4096	@ 0x1000
 c03a3f0:	f8d4 2400 	ldr.w	r2, [r4, #1024]	@ 0x400
 c03a3f4:	f8c4 5404 	str.w	r5, [r4, #1028]	@ 0x404
 c03a3f8:	f021 f999 	bl	c05b72e <memset>
    (void)tfm_memset(scratch.buf, 0, scratch.alloc_index);
    scratch.alloc_index = 0;
 c03a3fc:	f8c4 5400 	str.w	r5, [r4, #1024]	@ 0x400
}
 c03a400:	bd38      	pop	{r3, r4, r5, pc}
 c03a402:	bf00      	nop
 c03a404:	30036268 	.word	0x30036268

0c03a408 <tfm_crypto_get_caller_id>:
    *id = scratch.owner;
 c03a408:	4b02      	ldr	r3, [pc, #8]	@ (c03a414 <tfm_crypto_get_caller_id+0xc>)
 c03a40a:	f8d3 3404 	ldr.w	r3, [r3, #1028]	@ 0x404
 c03a40e:	6003      	str	r3, [r0, #0]
        return PSA_ERROR_NOT_PERMITTED;
    } else {
        return PSA_SUCCESS;
    }
#endif
}
 c03a410:	2000      	movs	r0, #0
 c03a412:	4770      	bx	lr
 c03a414:	30037268 	.word	0x30037268

0c03a418 <tfm_crypto_init>:



psa_status_t tfm_crypto_init(void)
{
 c03a418:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c03a41c:	b0ab      	sub	sp, #172	@ 0xac
    return tfm_crypto_init_alloc();
 c03a41e:	f7ff fb77 	bl	c039b10 <tfm_crypto_init_alloc>
    psa_status_t status;

    /* Initialise other modules of the service */
    status = tfm_crypto_module_init();
    if (status != PSA_SUCCESS) {
 c03a422:	2800      	cmp	r0, #0
 c03a424:	f040 80e0 	bne.w	c03a5e8 <tfm_crypto_init+0x1d0>
    mbedtls_memory_buffer_alloc_init(mbedtls_mem_buf,
 c03a428:	f44f 5130 	mov.w	r1, #11264	@ 0x2c00
 c03a42c:	4870      	ldr	r0, [pc, #448]	@ (c03a5f0 <tfm_crypto_init+0x1d8>)
 c03a42e:	f01c fc51 	bl	c056cd4 <mbedtls_memory_buffer_alloc_init>
    if ((status = psa_register_se_driver( PSA_SE_ST_LOCATION,
 c03a432:	2001      	movs	r0, #1
 c03a434:	496f      	ldr	r1, [pc, #444]	@ (c03a5f4 <tfm_crypto_init+0x1dc>)
 c03a436:	f00e fcc7 	bl	c048dc8 <psa_register_se_driver>
 c03a43a:	2800      	cmp	r0, #0
 c03a43c:	f040 80d4 	bne.w	c03a5e8 <tfm_crypto_init+0x1d0>
    return psa_crypto_init();
 c03a440:	f00c fd94 	bl	c046f6c <mbedcrypto__psa_crypto_init>
        return status;
    }

    /* Initialise the engine layer */
    status = tfm_crypto_engine_init();
    if (status != PSA_SUCCESS) {
 c03a444:	2800      	cmp	r0, #0
 c03a446:	f040 80cf 	bne.w	c03a5e8 <tfm_crypto_init+0x1d0>
        return status;
    }

#ifdef PSA_USE_SE_ST
    status = register_se_keys();
 c03a44a:	f010 fadb 	bl	c04aa04 <register_se_keys>
    if (status != PSA_SUCCESS) {
 c03a44e:	2800      	cmp	r0, #0
 c03a450:	f040 80ca 	bne.w	c03a5e8 <tfm_crypto_init+0x1d0>
    struct tfm_crypto_pack_iovec iov = {0};
 c03a454:	f10d 094c 	add.w	r9, sp, #76	@ 0x4c
 c03a458:	4601      	mov	r1, r0
 c03a45a:	222c      	movs	r2, #44	@ 0x2c
 c03a45c:	4648      	mov	r0, r9
 c03a45e:	f021 f966 	bl	c05b72e <memset>
    uint32_t sfn_id = TFM_CRYPTO_SID_INVALID;
 c03a462:	f04f 34ff 	mov.w	r4, #4294967295	@ 0xffffffff
        signals = psa_wait(PSA_WAIT_ANY, PSA_BLOCK);
 c03a466:	f04f 4100 	mov.w	r1, #2147483648	@ 0x80000000
 c03a46a:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 c03a46e:	f002 f9cb 	bl	c03c808 <psa_wait>
        if (signals & TFM_CRYPTO_SIGNAL) {
 c03a472:	06c2      	lsls	r2, r0, #27
 c03a474:	f140 80b7 	bpl.w	c03a5e6 <tfm_crypto_init+0x1ce>
            if (psa_get(TFM_CRYPTO_SIGNAL, &msg) != PSA_SUCCESS) {
 c03a478:	2010      	movs	r0, #16
 c03a47a:	a91e      	add	r1, sp, #120	@ 0x78
 c03a47c:	f002 f9c6 	bl	c03c80c <psa_get>
 c03a480:	b100      	cbz	r0, c03a484 <tfm_crypto_init+0x6c>
                while (1) {
 c03a482:	e7fe      	b.n	c03a482 <tfm_crypto_init+0x6a>
            switch (msg.type) {
 c03a484:	991e      	ldr	r1, [sp, #120]	@ 0x78
 c03a486:	2900      	cmp	r1, #0
 c03a488:	da02      	bge.n	c03a490 <tfm_crypto_init+0x78>
 c03a48a:	3102      	adds	r1, #2
 c03a48c:	da02      	bge.n	c03a494 <tfm_crypto_init+0x7c>
                while (1) {
 c03a48e:	e7fe      	b.n	c03a48e <tfm_crypto_init+0x76>
            switch (msg.type) {
 c03a490:	d005      	beq.n	c03a49e <tfm_crypto_init+0x86>
 c03a492:	e7fc      	b.n	c03a48e <tfm_crypto_init+0x76>
                psa_reply(msg.handle, PSA_SUCCESS);
 c03a494:	4601      	mov	r1, r0
                psa_reply(msg.handle, status);
 c03a496:	981f      	ldr	r0, [sp, #124]	@ 0x7c
 c03a498:	f002 f9be 	bl	c03c818 <psa_reply>
                break;
 c03a49c:	e7e3      	b.n	c03a466 <tfm_crypto_init+0x4e>
    read_size = psa_read(msg->handle,
 c03a49e:	232c      	movs	r3, #44	@ 0x2c
 c03a4a0:	464a      	mov	r2, r9
 c03a4a2:	981f      	ldr	r0, [sp, #124]	@ 0x7c
 c03a4a4:	f002 f9b4 	bl	c03c810 <psa_read>
    if (read_size != sizeof(struct tfm_crypto_pack_iovec)) {
 c03a4a8:	282c      	cmp	r0, #44	@ 0x2c
 c03a4aa:	d105      	bne.n	c03a4b8 <tfm_crypto_init+0xa0>
    if (iov->sfn_id >= TFM_CRYPTO_SID_MAX) {
 c03a4ac:	9c13      	ldr	r4, [sp, #76]	@ 0x4c
 c03a4ae:	2c40      	cmp	r4, #64	@ 0x40
 c03a4b0:	d904      	bls.n	c03a4bc <tfm_crypto_init+0xa4>
        *sfn_id_p = TFM_CRYPTO_SID_INVALID;
 c03a4b2:	f04f 34ff 	mov.w	r4, #4294967295	@ 0xffffffff
 c03a4b6:	e021      	b.n	c03a4fc <tfm_crypto_init+0xe4>
                if (sfn_id != TFM_CRYPTO_SID_INVALID) {
 c03a4b8:	1c63      	adds	r3, r4, #1
 c03a4ba:	d01f      	beq.n	c03a4fc <tfm_crypto_init+0xe4>
    psa_invec in_vec[PSA_MAX_IOVEC] = { {NULL, 0} };
 c03a4bc:	2220      	movs	r2, #32
 c03a4be:	2100      	movs	r1, #0
 c03a4c0:	a803      	add	r0, sp, #12
 c03a4c2:	f021 f934 	bl	c05b72e <memset>
    psa_outvec out_vec[PSA_MAX_IOVEC] = { {NULL, 0} };
 c03a4c6:	2220      	movs	r2, #32
 c03a4c8:	2100      	movs	r1, #0
 c03a4ca:	a80b      	add	r0, sp, #44	@ 0x2c
 c03a4cc:	f021 f92f 	bl	c05b72e <memset>
    size_t in_len = PSA_MAX_IOVEC, out_len = PSA_MAX_IOVEC, i;
 c03a4d0:	2304      	movs	r3, #4
 c03a4d2:	aa26      	add	r2, sp, #152	@ 0x98
    while ((in_len > 0) && (msg->in_size[in_len - 1] == 0)) {
 c03a4d4:	f852 1d04 	ldr.w	r1, [r2, #-4]!
 c03a4d8:	469a      	mov	sl, r3
 c03a4da:	3b01      	subs	r3, #1
 c03a4dc:	b161      	cbz	r1, c03a4f8 <tfm_crypto_init+0xe0>
    in_vec[0].len = sizeof(struct tfm_crypto_pack_iovec);
 c03a4de:	232c      	movs	r3, #44	@ 0x2c
    if (requested_size > (sizeof(scratch.buf) - scratch.alloc_index)) {
 c03a4e0:	f8df b114 	ldr.w	fp, [pc, #276]	@ c03a5f8 <tfm_crypto_init+0x1e0>
    for (i = 1; i < in_len; i++) {
 c03a4e4:	2501      	movs	r5, #1
    in_vec[0].base = iov;
 c03a4e6:	f8cd 900c 	str.w	r9, [sp, #12]
    in_vec[0].len = sizeof(struct tfm_crypto_pack_iovec);
 c03a4ea:	9304      	str	r3, [sp, #16]
    for (i = 1; i < in_len; i++) {
 c03a4ec:	ae03      	add	r6, sp, #12
 c03a4ee:	f10d 0888 	add.w	r8, sp, #136	@ 0x88
    if (requested_size > (sizeof(scratch.buf) - scratch.alloc_index)) {
 c03a4f2:	f50b 5780 	add.w	r7, fp, #4096	@ 0x1000
    for (i = 1; i < in_len; i++) {
 c03a4f6:	e01e      	b.n	c03a536 <tfm_crypto_init+0x11e>
    while ((in_len > 0) && (msg->in_size[in_len - 1] == 0)) {
 c03a4f8:	2b00      	cmp	r3, #0
 c03a4fa:	d1eb      	bne.n	c03a4d4 <tfm_crypto_init+0xbc>
                    status = PSA_ERROR_GENERIC_ERROR;
 c03a4fc:	f06f 0783 	mvn.w	r7, #131	@ 0x83
 c03a500:	e066      	b.n	c03a5d0 <tfm_crypto_init+0x1b8>
        status = tfm_crypto_alloc_scratch(msg->in_size[i], &alloc_buf_ptr);
 c03a502:	f8d8 3004 	ldr.w	r3, [r8, #4]
    if (requested_size > (sizeof(scratch.buf) - scratch.alloc_index)) {
 c03a506:	f5c1 52a0 	rsb	r2, r1, #5120	@ 0x1400
    requested_size = ALIGN(requested_size, TFM_CRYPTO_IOVEC_ALIGNMENT);
 c03a50a:	1cd8      	adds	r0, r3, #3
 c03a50c:	f020 0003 	bic.w	r0, r0, #3
    if (requested_size > (sizeof(scratch.buf) - scratch.alloc_index)) {
 c03a510:	4290      	cmp	r0, r2
 c03a512:	d859      	bhi.n	c03a5c8 <tfm_crypto_init+0x1b0>
    scratch.alloc_index += requested_size;
 c03a514:	4408      	add	r0, r1
    *buf = (void *)&scratch.buf[scratch.alloc_index];
 c03a516:	eb01 020b 	add.w	r2, r1, fp
    scratch.alloc_index += requested_size;
 c03a51a:	f8c7 0400 	str.w	r0, [r7, #1024]	@ 0x400
        (void) psa_read(msg->handle, i, alloc_buf_ptr, msg->in_size[i]);
 c03a51e:	4629      	mov	r1, r5
 c03a520:	981f      	ldr	r0, [sp, #124]	@ 0x7c
 c03a522:	9201      	str	r2, [sp, #4]
 c03a524:	f002 f974 	bl	c03c810 <psa_read>
        in_vec[i].base = alloc_buf_ptr;
 c03a528:	9a01      	ldr	r2, [sp, #4]
        in_vec[i].len = msg->in_size[i];
 c03a52a:	f858 3f04 	ldr.w	r3, [r8, #4]!
        in_vec[i].base = alloc_buf_ptr;
 c03a52e:	60b2      	str	r2, [r6, #8]
        in_vec[i].len = msg->in_size[i];
 c03a530:	60f3      	str	r3, [r6, #12]
    for (i = 1; i < in_len; i++) {
 c03a532:	3501      	adds	r5, #1
 c03a534:	3608      	adds	r6, #8
 c03a536:	4555      	cmp	r5, sl
    if (requested_size > (sizeof(scratch.buf) - scratch.alloc_index)) {
 c03a538:	f8d7 1400 	ldr.w	r1, [r7, #1024]	@ 0x400
    for (i = 1; i < in_len; i++) {
 c03a53c:	d1e1      	bne.n	c03a502 <tfm_crypto_init+0xea>
    size_t in_len = PSA_MAX_IOVEC, out_len = PSA_MAX_IOVEC, i;
 c03a53e:	2504      	movs	r5, #4
 c03a540:	ab2a      	add	r3, sp, #168	@ 0xa8
    while ((out_len > 0) && (msg->out_size[out_len - 1] == 0)) {
 c03a542:	f853 0d04 	ldr.w	r0, [r3, #-4]!
 c03a546:	462a      	mov	r2, r5
 c03a548:	3d01      	subs	r5, #1
 c03a54a:	b108      	cbz	r0, c03a550 <tfm_crypto_init+0x138>
 c03a54c:	4615      	mov	r5, r2
 c03a54e:	e001      	b.n	c03a554 <tfm_crypto_init+0x13c>
 c03a550:	2d00      	cmp	r5, #0
 c03a552:	d1f6      	bne.n	c03a542 <tfm_crypto_init+0x12a>
    for (i = 0; i < out_len; i++) {
 c03a554:	2300      	movs	r3, #0
 c03a556:	ae0b      	add	r6, sp, #44	@ 0x2c
 c03a558:	4632      	mov	r2, r6
 c03a55a:	469c      	mov	ip, r3
 c03a55c:	f10d 0e94 	add.w	lr, sp, #148	@ 0x94
 c03a560:	e013      	b.n	c03a58a <tfm_crypto_init+0x172>
        status = tfm_crypto_alloc_scratch(msg->out_size[i], &alloc_buf_ptr);
 c03a562:	f85e 8f04 	ldr.w	r8, [lr, #4]!
    if (requested_size > (sizeof(scratch.buf) - scratch.alloc_index)) {
 c03a566:	f5c1 5ba0 	rsb	fp, r1, #5120	@ 0x1400
    requested_size = ALIGN(requested_size, TFM_CRYPTO_IOVEC_ALIGNMENT);
 c03a56a:	f108 0003 	add.w	r0, r8, #3
 c03a56e:	f020 0003 	bic.w	r0, r0, #3
    if (requested_size > (sizeof(scratch.buf) - scratch.alloc_index)) {
 c03a572:	4558      	cmp	r0, fp
 c03a574:	f102 0208 	add.w	r2, r2, #8
 c03a578:	d822      	bhi.n	c03a5c0 <tfm_crypto_init+0x1a8>
    *buf = (void *)&scratch.buf[scratch.alloc_index];
 c03a57a:	4b1f      	ldr	r3, [pc, #124]	@ (c03a5f8 <tfm_crypto_init+0x1e0>)
    for (i = 0; i < out_len; i++) {
 c03a57c:	f10c 0c01 	add.w	ip, ip, #1
    *buf = (void *)&scratch.buf[scratch.alloc_index];
 c03a580:	18cb      	adds	r3, r1, r3
        out_vec[i].len = msg->out_size[i];
 c03a582:	e942 3802 	strd	r3, r8, [r2, #-8]
    for (i = 0; i < out_len; i++) {
 c03a586:	2301      	movs	r3, #1
    scratch.alloc_index += requested_size;
 c03a588:	4401      	add	r1, r0
    for (i = 0; i < out_len; i++) {
 c03a58a:	45ac      	cmp	ip, r5
 c03a58c:	d1e9      	bne.n	c03a562 <tfm_crypto_init+0x14a>
 c03a58e:	b113      	cbz	r3, c03a596 <tfm_crypto_init+0x17e>
 c03a590:	4b1a      	ldr	r3, [pc, #104]	@ (c03a5fc <tfm_crypto_init+0x1e4>)
 c03a592:	f8c3 1400 	str.w	r1, [r3, #1024]	@ 0x400
    scratch.owner = id;
 c03a596:	9b20      	ldr	r3, [sp, #128]	@ 0x80
    status = sfid_func_table[sfn_id](in_vec, in_len, out_vec, out_len);
 c03a598:	4651      	mov	r1, sl
    scratch.owner = id;
 c03a59a:	f8c7 3404 	str.w	r3, [r7, #1028]	@ 0x404
    status = sfid_func_table[sfn_id](in_vec, in_len, out_vec, out_len);
 c03a59e:	4b18      	ldr	r3, [pc, #96]	@ (c03a600 <tfm_crypto_init+0x1e8>)
 c03a5a0:	aa0b      	add	r2, sp, #44	@ 0x2c
 c03a5a2:	f853 7024 	ldr.w	r7, [r3, r4, lsl #2]
 c03a5a6:	a803      	add	r0, sp, #12
 c03a5a8:	462b      	mov	r3, r5
 c03a5aa:	47b8      	blx	r7
    for (i = 0; i < out_len; i++) {
 c03a5ac:	f04f 0800 	mov.w	r8, #0
    status = sfid_func_table[sfn_id](in_vec, in_len, out_vec, out_len);
 c03a5b0:	4607      	mov	r7, r0
    for (i = 0; i < out_len; i++) {
 c03a5b2:	4545      	cmp	r5, r8
 c03a5b4:	f106 0608 	add.w	r6, r6, #8
 c03a5b8:	d10c      	bne.n	c03a5d4 <tfm_crypto_init+0x1bc>
    tfm_crypto_clear_scratch();
 c03a5ba:	f7ff ff13 	bl	c03a3e4 <tfm_crypto_clear_scratch>
    return status;
 c03a5be:	e007      	b.n	c03a5d0 <tfm_crypto_init+0x1b8>
 c03a5c0:	b113      	cbz	r3, c03a5c8 <tfm_crypto_init+0x1b0>
 c03a5c2:	4b0e      	ldr	r3, [pc, #56]	@ (c03a5fc <tfm_crypto_init+0x1e4>)
 c03a5c4:	f8c3 1400 	str.w	r1, [r3, #1024]	@ 0x400
            tfm_crypto_clear_scratch();
 c03a5c8:	f7ff ff0c 	bl	c03a3e4 <tfm_crypto_clear_scratch>
        return PSA_ERROR_INSUFFICIENT_MEMORY;
 c03a5cc:	f06f 078c 	mvn.w	r7, #140	@ 0x8c
                psa_reply(msg.handle, status);
 c03a5d0:	4639      	mov	r1, r7
 c03a5d2:	e760      	b.n	c03a496 <tfm_crypto_init+0x7e>
        psa_write(msg->handle, i, out_vec[i].base, out_vec[i].len);
 c03a5d4:	4641      	mov	r1, r8
 c03a5d6:	e956 2302 	ldrd	r2, r3, [r6, #-8]
 c03a5da:	981f      	ldr	r0, [sp, #124]	@ 0x7c
 c03a5dc:	f002 f91a 	bl	c03c814 <psa_write>
    for (i = 0; i < out_len; i++) {
 c03a5e0:	f108 0801 	add.w	r8, r8, #1
 c03a5e4:	e7e5      	b.n	c03a5b2 <tfm_crypto_init+0x19a>
            while (1) {
 c03a5e6:	e7fe      	b.n	c03a5e6 <tfm_crypto_init+0x1ce>
    /* Should not return in normal operations */
    tfm_crypto_ipc_handler();
#endif

    return status;
}
 c03a5e8:	b02b      	add	sp, #172	@ 0xac
 c03a5ea:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 c03a5ee:	bf00      	nop
 c03a5f0:	30033668 	.word	0x30033668
 c03a5f4:	0c0618e4 	.word	0x0c0618e4
 c03a5f8:	30036268 	.word	0x30036268
 c03a5fc:	30037268 	.word	0x30037268
 c03a600:	0c0613d4 	.word	0x0c0613d4

0c03a604 <tfm_crypto_key_attributes_from_client>:
/*!@{*/
psa_status_t tfm_crypto_key_attributes_from_client(
                    const struct psa_client_key_attributes_s *client_key_attr,
                    int32_t client_id,
                    psa_key_attributes_t *key_attributes)
{
 c03a604:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 c03a608:	4688      	mov	r8, r1
 c03a60a:	4616      	mov	r6, r2
    if (client_key_attr == NULL || key_attributes == NULL) {
 c03a60c:	4607      	mov	r7, r0
{
 c03a60e:	b08c      	sub	sp, #48	@ 0x30
    if (client_key_attr == NULL || key_attributes == NULL) {
 c03a610:	b300      	cbz	r0, c03a654 <tfm_crypto_key_attributes_from_client+0x50>
 c03a612:	b1fa      	cbz	r2, c03a654 <tfm_crypto_key_attributes_from_client+0x50>
        return PSA_ERROR_PROGRAMMER_ERROR;
    }

    *key_attributes = psa_key_attributes_init();
 c03a614:	4635      	mov	r5, r6
 c03a616:	466c      	mov	r4, sp
    return( v );
 c03a618:	2230      	movs	r2, #48	@ 0x30
 c03a61a:	2100      	movs	r1, #0
 c03a61c:	4668      	mov	r0, sp
 c03a61e:	f021 f886 	bl	c05b72e <memset>
 c03a622:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 c03a624:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 c03a626:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 c03a628:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 c03a62a:	e894 000f 	ldmia.w	r4, {r0, r1, r2, r3}
 c03a62e:	e885 000f 	stmia.w	r5, {r0, r1, r2, r3}

    /* Use the client key id as the key_id and its partition id as the owner */
    key_attributes->core.id.key_id = client_key_attr->id;
    key_attributes->core.id.owner = client_id;

    return PSA_SUCCESS;
 c03a632:	2000      	movs	r0, #0
    key_attributes->core.type = client_key_attr->type;
 c03a634:	8abb      	ldrh	r3, [r7, #20]
 c03a636:	8033      	strh	r3, [r6, #0]
    key_attributes->core.lifetime = client_key_attr->lifetime;
 c03a638:	683b      	ldr	r3, [r7, #0]
 c03a63a:	6073      	str	r3, [r6, #4]
    key_attributes->core.policy.usage = client_key_attr->usage;
 c03a63c:	68fb      	ldr	r3, [r7, #12]
 c03a63e:	6133      	str	r3, [r6, #16]
    key_attributes->core.policy.alg = client_key_attr->alg;
 c03a640:	68bb      	ldr	r3, [r7, #8]
 c03a642:	6173      	str	r3, [r6, #20]
    key_attributes->core.bits = client_key_attr->bits;
 c03a644:	693b      	ldr	r3, [r7, #16]
 c03a646:	8073      	strh	r3, [r6, #2]
    key_attributes->core.id.key_id = client_key_attr->id;
 c03a648:	687b      	ldr	r3, [r7, #4]
    key_attributes->core.id.owner = client_id;
 c03a64a:	e9c6 3802 	strd	r3, r8, [r6, #8]
}
 c03a64e:	b00c      	add	sp, #48	@ 0x30
 c03a650:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        return PSA_ERROR_PROGRAMMER_ERROR;
 c03a654:	f06f 0080 	mvn.w	r0, #128	@ 0x80
 c03a658:	e7f9      	b.n	c03a64e <tfm_crypto_key_attributes_from_client+0x4a>

0c03a65a <tfm_crypto_key_attributes_to_client>:

psa_status_t tfm_crypto_key_attributes_to_client(
                        const psa_key_attributes_t *key_attributes,
                        struct psa_client_key_attributes_s *client_key_attr)
{
 c03a65a:	b510      	push	{r4, lr}
    if (client_key_attr == NULL || key_attributes == NULL) {
 c03a65c:	460b      	mov	r3, r1
{
 c03a65e:	4604      	mov	r4, r0
    if (client_key_attr == NULL || key_attributes == NULL) {
 c03a660:	b199      	cbz	r1, c03a68a <tfm_crypto_key_attributes_to_client+0x30>
 c03a662:	b190      	cbz	r0, c03a68a <tfm_crypto_key_attributes_to_client+0x30>
        return PSA_ERROR_PROGRAMMER_ERROR;
    }

    struct psa_client_key_attributes_s v = PSA_CLIENT_KEY_ATTRIBUTES_INIT;
    *client_key_attr = v;
 c03a664:	2218      	movs	r2, #24
 c03a666:	2100      	movs	r1, #0
 c03a668:	4618      	mov	r0, r3
 c03a66a:	f021 f860 	bl	c05b72e <memset>

    /* Copy core key attributes from the client core key attributes */
    client_key_attr->type = key_attributes->core.type;
 c03a66e:	8822      	ldrh	r2, [r4, #0]
 c03a670:	8282      	strh	r2, [r0, #20]
    client_key_attr->lifetime = key_attributes->core.lifetime;
 c03a672:	6862      	ldr	r2, [r4, #4]
 c03a674:	6002      	str	r2, [r0, #0]
    client_key_attr->usage = key_attributes->core.policy.usage;
 c03a676:	6922      	ldr	r2, [r4, #16]
 c03a678:	60c2      	str	r2, [r0, #12]
    client_key_attr->alg = key_attributes->core.policy.alg;
 c03a67a:	6962      	ldr	r2, [r4, #20]
 c03a67c:	6082      	str	r2, [r0, #8]
    client_key_attr->bits = key_attributes->core.bits;
 c03a67e:	8862      	ldrh	r2, [r4, #2]
 c03a680:	6102      	str	r2, [r0, #16]

    /* Return the key_id as the client key id, do not return the owner */
    client_key_attr->id = key_attributes->core.id.key_id;
 c03a682:	68a2      	ldr	r2, [r4, #8]
 c03a684:	6042      	str	r2, [r0, #4]

    return PSA_SUCCESS;
 c03a686:	2000      	movs	r0, #0
}
 c03a688:	bd10      	pop	{r4, pc}
        return PSA_ERROR_PROGRAMMER_ERROR;
 c03a68a:	f06f 0080 	mvn.w	r0, #128	@ 0x80
 c03a68e:	e7fb      	b.n	c03a688 <tfm_crypto_key_attributes_to_client+0x2e>

0c03a690 <tfm_crypto_check_handle_owner>:
                                           uint32_t *index)
{
#ifdef TFM_CRYPTO_KEY_MODULE_DISABLED
    return PSA_ERROR_NOT_SUPPORTED;
#else
    int32_t partition_id = 0;
 c03a690:	2300      	movs	r3, #0
{
 c03a692:	b573      	push	{r0, r1, r4, r5, r6, lr}
 c03a694:	4605      	mov	r5, r0
    uint32_t i = 0;
    psa_status_t status;

    status = tfm_crypto_get_caller_id(&partition_id);
 c03a696:	a801      	add	r0, sp, #4
{
 c03a698:	460c      	mov	r4, r1
    int32_t partition_id = 0;
 c03a69a:	9301      	str	r3, [sp, #4]
    status = tfm_crypto_get_caller_id(&partition_id);
 c03a69c:	f7ff feb4 	bl	c03a408 <tfm_crypto_get_caller_id>
    if (status != PSA_SUCCESS) {
 c03a6a0:	b978      	cbnz	r0, c03a6c2 <tfm_crypto_check_handle_owner+0x32>
 c03a6a2:	4a0e      	ldr	r2, [pc, #56]	@ (c03a6dc <tfm_crypto_check_handle_owner+0x4c>)
        return status;
    }

    for (i = 0; i < TFM_CRYPTO_MAX_KEY_HANDLES; i++) {
 c03a6a4:	4603      	mov	r3, r0
 c03a6a6:	4611      	mov	r1, r2
        if (handle_owner[i].in_use && handle_owner[i].key == key) {
 c03a6a8:	7a16      	ldrb	r6, [r2, #8]
 c03a6aa:	b166      	cbz	r6, c03a6c6 <tfm_crypto_check_handle_owner+0x36>
 c03a6ac:	6856      	ldr	r6, [r2, #4]
 c03a6ae:	42ae      	cmp	r6, r5
 c03a6b0:	d109      	bne.n	c03a6c6 <tfm_crypto_check_handle_owner+0x36>
            if (handle_owner[i].owner == partition_id) {
 c03a6b2:	220c      	movs	r2, #12
 c03a6b4:	435a      	muls	r2, r3
 c03a6b6:	5889      	ldr	r1, [r1, r2]
 c03a6b8:	9a01      	ldr	r2, [sp, #4]
 c03a6ba:	4291      	cmp	r1, r2
 c03a6bc:	d10b      	bne.n	c03a6d6 <tfm_crypto_check_handle_owner+0x46>
                if (index != NULL) {
 c03a6be:	b104      	cbz	r4, c03a6c2 <tfm_crypto_check_handle_owner+0x32>
                    *index = i;
 c03a6c0:	6023      	str	r3, [r4, #0]
        }
    }

    return PSA_ERROR_INVALID_HANDLE;
#endif /* TFM_CRYPTO_KEY_MODULE_DISABLED */
}
 c03a6c2:	b002      	add	sp, #8
 c03a6c4:	bd70      	pop	{r4, r5, r6, pc}
    for (i = 0; i < TFM_CRYPTO_MAX_KEY_HANDLES; i++) {
 c03a6c6:	3301      	adds	r3, #1
 c03a6c8:	2b20      	cmp	r3, #32
 c03a6ca:	f102 020c 	add.w	r2, r2, #12
 c03a6ce:	d1eb      	bne.n	c03a6a8 <tfm_crypto_check_handle_owner+0x18>
    return PSA_ERROR_INVALID_HANDLE;
 c03a6d0:	f06f 0087 	mvn.w	r0, #135	@ 0x87
 c03a6d4:	e7f5      	b.n	c03a6c2 <tfm_crypto_check_handle_owner+0x32>
                return PSA_ERROR_NOT_PERMITTED;
 c03a6d6:	f06f 0084 	mvn.w	r0, #132	@ 0x84
 c03a6da:	e7f2      	b.n	c03a6c2 <tfm_crypto_check_handle_owner+0x32>
 c03a6dc:	30037670 	.word	0x30037670

0c03a6e0 <tfm_crypto_encode_id_and_owner>:

psa_status_t tfm_crypto_encode_id_and_owner(psa_key_id_t key_id,
                                            mbedtls_svc_key_id_t *enc_key_ptr)
{
    int32_t partition_id = 0;
 c03a6e0:	2300      	movs	r3, #0
{
 c03a6e2:	b537      	push	{r0, r1, r2, r4, r5, lr}
 c03a6e4:	4605      	mov	r5, r0
    psa_status_t status = tfm_crypto_get_caller_id(&partition_id);
 c03a6e6:	a801      	add	r0, sp, #4
{
 c03a6e8:	460c      	mov	r4, r1
    int32_t partition_id = 0;
 c03a6ea:	9301      	str	r3, [sp, #4]
    psa_status_t status = tfm_crypto_get_caller_id(&partition_id);
 c03a6ec:	f7ff fe8c 	bl	c03a408 <tfm_crypto_get_caller_id>

    if (status != PSA_SUCCESS) {
 c03a6f0:	b918      	cbnz	r0, c03a6fa <tfm_crypto_encode_id_and_owner+0x1a>
        return status;
    }

    /* If Null Pointer, return PSA_ERROR_PROGRAMMER_ERROR */
    if (enc_key_ptr == NULL) {
 c03a6f2:	b124      	cbz	r4, c03a6fe <tfm_crypto_encode_id_and_owner+0x1e>
        return PSA_ERROR_PROGRAMMER_ERROR;
    }

    /* Use the client key id as the key_id and its partition id as the owner */
    *enc_key_ptr = mbedtls_svc_key_id_make(partition_id, key_id);
 c03a6f4:	9b01      	ldr	r3, [sp, #4]
 c03a6f6:	6025      	str	r5, [r4, #0]
 c03a6f8:	6063      	str	r3, [r4, #4]

    return PSA_SUCCESS;
}
 c03a6fa:	b003      	add	sp, #12
 c03a6fc:	bd30      	pop	{r4, r5, pc}
        return PSA_ERROR_PROGRAMMER_ERROR;
 c03a6fe:	f06f 0080 	mvn.w	r0, #128	@ 0x80
 c03a702:	e7fa      	b.n	c03a6fa <tfm_crypto_encode_id_and_owner+0x1a>

0c03a704 <tfm_crypto_check_key_storage>:

psa_status_t tfm_crypto_check_key_storage(uint32_t *index)
{
 c03a704:	4601      	mov	r1, r0
#ifdef TFM_CRYPTO_KEY_MODULE_DISABLED
    return PSA_ERROR_NOT_SUPPORTED;
#else
    uint32_t i;

    for (i = 0; i < TFM_CRYPTO_MAX_KEY_HANDLES; i++) {
 c03a706:	2300      	movs	r3, #0
 c03a708:	4a06      	ldr	r2, [pc, #24]	@ (c03a724 <tfm_crypto_check_key_storage+0x20>)
        if (handle_owner[i].in_use == TFM_CRYPTO_NOT_IN_USE) {
 c03a70a:	7a10      	ldrb	r0, [r2, #8]
 c03a70c:	b908      	cbnz	r0, c03a712 <tfm_crypto_check_key_storage+0xe>
            *index = i;
 c03a70e:	600b      	str	r3, [r1, #0]
            return PSA_SUCCESS;
 c03a710:	4770      	bx	lr
    for (i = 0; i < TFM_CRYPTO_MAX_KEY_HANDLES; i++) {
 c03a712:	3301      	adds	r3, #1
 c03a714:	2b20      	cmp	r3, #32
 c03a716:	f102 020c 	add.w	r2, r2, #12
 c03a71a:	d1f6      	bne.n	c03a70a <tfm_crypto_check_key_storage+0x6>
        }
    }

    return PSA_ERROR_INSUFFICIENT_MEMORY;
 c03a71c:	f06f 008c 	mvn.w	r0, #140	@ 0x8c
#endif /* TFM_CRYPTO_KEY_MODULE_DISABLED */
}
 c03a720:	4770      	bx	lr
 c03a722:	bf00      	nop
 c03a724:	30037670 	.word	0x30037670

0c03a728 <tfm_crypto_set_key_storage>:

psa_status_t tfm_crypto_set_key_storage(uint32_t index,
                                        psa_key_id_t key_handle)
{
 c03a728:	b537      	push	{r0, r1, r2, r4, r5, lr}
 c03a72a:	4604      	mov	r4, r0
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status;
    int32_t partition_id;

    status = tfm_crypto_get_caller_id(&partition_id);
 c03a72c:	a801      	add	r0, sp, #4
{
 c03a72e:	460d      	mov	r5, r1
    status = tfm_crypto_get_caller_id(&partition_id);
 c03a730:	f7ff fe6a 	bl	c03a408 <tfm_crypto_get_caller_id>
    if (status != PSA_SUCCESS) {
 c03a734:	b940      	cbnz	r0, c03a748 <tfm_crypto_set_key_storage+0x20>
        return status;
    }

    handle_owner[index].owner = partition_id;
 c03a736:	230c      	movs	r3, #12
 c03a738:	4363      	muls	r3, r4
 c03a73a:	4904      	ldr	r1, [pc, #16]	@ (c03a74c <tfm_crypto_set_key_storage+0x24>)
 c03a73c:	9c01      	ldr	r4, [sp, #4]
 c03a73e:	18ca      	adds	r2, r1, r3
 c03a740:	50cc      	str	r4, [r1, r3]
    handle_owner[index].key = key_handle;
    handle_owner[index].in_use = TFM_CRYPTO_IN_USE;
 c03a742:	2301      	movs	r3, #1
    handle_owner[index].key = key_handle;
 c03a744:	6055      	str	r5, [r2, #4]
    handle_owner[index].in_use = TFM_CRYPTO_IN_USE;
 c03a746:	7213      	strb	r3, [r2, #8]

    return PSA_SUCCESS;
#endif /* TFM_CRYPTO_KEY_MODULE_DISABLED */
}
 c03a748:	b003      	add	sp, #12
 c03a74a:	bd30      	pop	{r4, r5, pc}
 c03a74c:	30037670 	.word	0x30037670

0c03a750 <tfm_crypto_set_key_domain_parameters>:
    return PSA_ERROR_NOT_SUPPORTED;
#else
    /* FixMe: To be implemented */
    return PSA_ERROR_NOT_SUPPORTED;
#endif /* TFM_CRYPTO_KEY_MODULE_DISABLED */
}
 c03a750:	f06f 0085 	mvn.w	r0, #133	@ 0x85
 c03a754:	4770      	bx	lr

0c03a756 <tfm_crypto_get_key_domain_parameters>:

psa_status_t tfm_crypto_get_key_domain_parameters(psa_invec in_vec[],
 c03a756:	f06f 0085 	mvn.w	r0, #133	@ 0x85
 c03a75a:	4770      	bx	lr

0c03a75c <tfm_crypto_import_key>:

psa_status_t tfm_crypto_import_key(psa_invec in_vec[],
                                   size_t in_len,
                                   psa_outvec out_vec[],
                                   size_t out_len)
{
 c03a75c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
#ifdef TFM_CRYPTO_KEY_MODULE_DISABLED
    return PSA_ERROR_NOT_SUPPORTED;
#else

    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 2, 3, out_len, 1, 1);
 c03a760:	b24c      	sxtb	r4, r1
 c03a762:	2c01      	cmp	r4, #1
{
 c03a764:	b091      	sub	sp, #68	@ 0x44
    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 2, 3, out_len, 1, 1);
 c03a766:	dd29      	ble.n	c03a7bc <tfm_crypto_import_key+0x60>
 c03a768:	2903      	cmp	r1, #3
 c03a76a:	d827      	bhi.n	c03a7bc <tfm_crypto_import_key+0x60>
 c03a76c:	b259      	sxtb	r1, r3
 c03a76e:	2900      	cmp	r1, #0
 c03a770:	dd24      	ble.n	c03a7bc <tfm_crypto_import_key+0x60>
 c03a772:	2b01      	cmp	r3, #1
 c03a774:	d122      	bne.n	c03a7bc <tfm_crypto_import_key+0x60>

    if ((in_vec[0].len != sizeof(struct tfm_crypto_pack_iovec)) ||
 c03a776:	6843      	ldr	r3, [r0, #4]
 c03a778:	2b2c      	cmp	r3, #44	@ 0x2c
 c03a77a:	d11f      	bne.n	c03a7bc <tfm_crypto_import_key+0x60>
 c03a77c:	68c3      	ldr	r3, [r0, #12]
 c03a77e:	2b18      	cmp	r3, #24
 c03a780:	d11c      	bne.n	c03a7bc <tfm_crypto_import_key+0x60>
        (in_vec[1].len != sizeof(struct psa_client_key_attributes_s)) ||
 c03a782:	6853      	ldr	r3, [r2, #4]
 c03a784:	2b04      	cmp	r3, #4
 c03a786:	d119      	bne.n	c03a7bc <tfm_crypto_import_key+0x60>
        (out_vec[0].len != sizeof(psa_key_id_t))) {
        return PSA_ERROR_PROGRAMMER_ERROR;
    }
    const struct psa_client_key_attributes_s *client_key_attr = in_vec[1].base;
    const uint8_t *data = in_vec[2].base;
    size_t data_length = in_vec[2].len;
 c03a788:	e9d0 6804 	ldrd	r6, r8, [r0, #16]
    const struct psa_client_key_attributes_s *client_key_attr = in_vec[1].base;
 c03a78c:	f8d0 9008 	ldr.w	r9, [r0, #8]
    psa_key_id_t *psa_key = out_vec[0].base;
 c03a790:	6817      	ldr	r7, [r2, #0]

    psa_status_t status;
    psa_key_attributes_t key_attributes = PSA_KEY_ATTRIBUTES_INIT;
 c03a792:	2100      	movs	r1, #0
 c03a794:	2230      	movs	r2, #48	@ 0x30
 c03a796:	a804      	add	r0, sp, #16
 c03a798:	f020 ffc9 	bl	c05b72e <memset>
    uint32_t i = 0;
    mbedtls_svc_key_id_t encoded_key;
    int32_t partition_id = 0;
 c03a79c:	4b1f      	ldr	r3, [pc, #124]	@ (c03a81c <tfm_crypto_import_key+0xc0>)
 c03a79e:	2400      	movs	r4, #0
 c03a7a0:	461d      	mov	r5, r3
 c03a7a2:	9401      	str	r4, [sp, #4]
    bool empty_found = false;

    for (i = 0; i < TFM_CRYPTO_MAX_KEY_HANDLES; i++) {
        if (handle_owner[i].in_use == TFM_CRYPTO_NOT_IN_USE) {
 c03a7a4:	7a1a      	ldrb	r2, [r3, #8]
 c03a7a6:	b17a      	cbz	r2, c03a7c8 <tfm_crypto_import_key+0x6c>
    for (i = 0; i < TFM_CRYPTO_MAX_KEY_HANDLES; i++) {
 c03a7a8:	3401      	adds	r4, #1
 c03a7aa:	2c20      	cmp	r4, #32
 c03a7ac:	f103 030c 	add.w	r3, r3, #12
 c03a7b0:	d1f8      	bne.n	c03a7a4 <tfm_crypto_import_key+0x48>
            break;
        }
    }

    if (!empty_found) {
        return PSA_ERROR_INSUFFICIENT_MEMORY;
 c03a7b2:	f06f 008c 	mvn.w	r0, #140	@ 0x8c
        handle_owner[i].in_use = TFM_CRYPTO_IN_USE;
    }

    return status;
#endif /* TFM_CRYPTO_KEY_MODULE_DISABLED */
}
 c03a7b6:	b011      	add	sp, #68	@ 0x44
 c03a7b8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 2, 3, out_len, 1, 1);
 c03a7bc:	f06f 0080 	mvn.w	r0, #128	@ 0x80
 c03a7c0:	e7f9      	b.n	c03a7b6 <tfm_crypto_import_key+0x5a>
            return PSA_ERROR_NOT_PERMITTED;
 c03a7c2:	f06f 0084 	mvn.w	r0, #132	@ 0x84
 c03a7c6:	e7f6      	b.n	c03a7b6 <tfm_crypto_import_key+0x5a>
    if ((data_length == 0) && (data == NULL))
 c03a7c8:	f1b8 0f00 	cmp.w	r8, #0
 c03a7cc:	d106      	bne.n	c03a7dc <tfm_crypto_import_key+0x80>
 c03a7ce:	b92e      	cbnz	r6, c03a7dc <tfm_crypto_import_key+0x80>
        if (handle_owner[i].owner != TFM_SP_PS) {
 c03a7d0:	230c      	movs	r3, #12
 c03a7d2:	4363      	muls	r3, r4
 c03a7d4:	58eb      	ldr	r3, [r5, r3]
 c03a7d6:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 c03a7da:	d1f2      	bne.n	c03a7c2 <tfm_crypto_import_key+0x66>
    status = tfm_crypto_get_caller_id(&partition_id);
 c03a7dc:	a801      	add	r0, sp, #4
 c03a7de:	f7ff fe13 	bl	c03a408 <tfm_crypto_get_caller_id>
    if (status != PSA_SUCCESS) {
 c03a7e2:	2800      	cmp	r0, #0
 c03a7e4:	d1e7      	bne.n	c03a7b6 <tfm_crypto_import_key+0x5a>
    status = tfm_crypto_key_attributes_from_client(client_key_attr,
 c03a7e6:	4648      	mov	r0, r9
 c03a7e8:	9901      	ldr	r1, [sp, #4]
 c03a7ea:	aa04      	add	r2, sp, #16
 c03a7ec:	f7ff ff0a 	bl	c03a604 <tfm_crypto_key_attributes_from_client>
    if (status != PSA_SUCCESS) {
 c03a7f0:	2800      	cmp	r0, #0
 c03a7f2:	d1e0      	bne.n	c03a7b6 <tfm_crypto_import_key+0x5a>
    status = psa_import_key(&key_attributes, data, data_length, &encoded_key);
 c03a7f4:	ab02      	add	r3, sp, #8
 c03a7f6:	4642      	mov	r2, r8
 c03a7f8:	4631      	mov	r1, r6
 c03a7fa:	a804      	add	r0, sp, #16
 c03a7fc:	f00a fe78 	bl	c0454f0 <mbedcrypto__psa_import_key>
    *psa_key = encoded_key.key_id;
 c03a800:	9b02      	ldr	r3, [sp, #8]
 c03a802:	603b      	str	r3, [r7, #0]
    if (status == PSA_SUCCESS) {
 c03a804:	2800      	cmp	r0, #0
 c03a806:	d1d6      	bne.n	c03a7b6 <tfm_crypto_import_key+0x5a>
        handle_owner[i].owner = partition_id;
 c03a808:	230c      	movs	r3, #12
 c03a80a:	4363      	muls	r3, r4
 c03a80c:	9901      	ldr	r1, [sp, #4]
 c03a80e:	18ea      	adds	r2, r5, r3
 c03a810:	50e9      	str	r1, [r5, r3]
        handle_owner[i].key = *psa_key;
 c03a812:	683b      	ldr	r3, [r7, #0]
 c03a814:	6053      	str	r3, [r2, #4]
        handle_owner[i].in_use = TFM_CRYPTO_IN_USE;
 c03a816:	2301      	movs	r3, #1
 c03a818:	7213      	strb	r3, [r2, #8]
 c03a81a:	e7cc      	b.n	c03a7b6 <tfm_crypto_import_key+0x5a>
 c03a81c:	30037670 	.word	0x30037670

0c03a820 <tfm_crypto_open_key>:

psa_status_t tfm_crypto_open_key(psa_invec in_vec[],
                                 size_t in_len,
                                 psa_outvec out_vec[],
                                 size_t out_len)
{
 c03a820:	b5f0      	push	{r4, r5, r6, r7, lr}
#ifdef TFM_CRYPTO_KEY_MODULE_DISABLED
    return PSA_ERROR_NOT_SUPPORTED;
#else

    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 2, 2, out_len, 1, 1);
 c03a822:	b24c      	sxtb	r4, r1
 c03a824:	2c01      	cmp	r4, #1
{
 c03a826:	b085      	sub	sp, #20
    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 2, 2, out_len, 1, 1);
 c03a828:	dd3b      	ble.n	c03a8a2 <tfm_crypto_open_key+0x82>
 c03a82a:	2902      	cmp	r1, #2
 c03a82c:	d139      	bne.n	c03a8a2 <tfm_crypto_open_key+0x82>
 c03a82e:	b259      	sxtb	r1, r3
 c03a830:	2900      	cmp	r1, #0
 c03a832:	dd36      	ble.n	c03a8a2 <tfm_crypto_open_key+0x82>
 c03a834:	2b01      	cmp	r3, #1
 c03a836:	d134      	bne.n	c03a8a2 <tfm_crypto_open_key+0x82>

    if ((in_vec[0].len != sizeof(struct tfm_crypto_pack_iovec)) ||
 c03a838:	6843      	ldr	r3, [r0, #4]
 c03a83a:	2b2c      	cmp	r3, #44	@ 0x2c
 c03a83c:	d131      	bne.n	c03a8a2 <tfm_crypto_open_key+0x82>
 c03a83e:	68c3      	ldr	r3, [r0, #12]
 c03a840:	2b04      	cmp	r3, #4
 c03a842:	d12e      	bne.n	c03a8a2 <tfm_crypto_open_key+0x82>
        (in_vec[1].len != sizeof(psa_key_id_t)) ||
 c03a844:	6853      	ldr	r3, [r2, #4]
 c03a846:	2b04      	cmp	r3, #4
 c03a848:	d12b      	bne.n	c03a8a2 <tfm_crypto_open_key+0x82>
        (out_vec[0].len != sizeof(psa_key_id_t))) {
        return PSA_ERROR_PROGRAMMER_ERROR;
    }

    psa_key_id_t client_key_id = *((psa_key_id_t *)in_vec[1].base);
 c03a84a:	6883      	ldr	r3, [r0, #8]
    psa_status_t status;
    mbedtls_svc_key_id_t encoded_key;
    int32_t partition_id;
    uint32_t i;

    for (i = 0; i < TFM_CRYPTO_MAX_KEY_HANDLES; i++) {
 c03a84c:	2400      	movs	r4, #0
    psa_key_id_t client_key_id = *((psa_key_id_t *)in_vec[1].base);
 c03a84e:	681f      	ldr	r7, [r3, #0]
    psa_key_id_t *key = out_vec[0].base;
 c03a850:	4b15      	ldr	r3, [pc, #84]	@ (c03a8a8 <tfm_crypto_open_key+0x88>)
 c03a852:	6816      	ldr	r6, [r2, #0]
    for (i = 0; i < TFM_CRYPTO_MAX_KEY_HANDLES; i++) {
 c03a854:	461d      	mov	r5, r3
        if (handle_owner[i].in_use == TFM_CRYPTO_NOT_IN_USE) {
 c03a856:	7a1a      	ldrb	r2, [r3, #8]
 c03a858:	b142      	cbz	r2, c03a86c <tfm_crypto_open_key+0x4c>
    for (i = 0; i < TFM_CRYPTO_MAX_KEY_HANDLES; i++) {
 c03a85a:	3401      	adds	r4, #1
 c03a85c:	2c20      	cmp	r4, #32
 c03a85e:	f103 030c 	add.w	r3, r3, #12
 c03a862:	d1f8      	bne.n	c03a856 <tfm_crypto_open_key+0x36>
            break;
        }
    }

    if (i == TFM_CRYPTO_MAX_KEY_HANDLES) {
        return PSA_ERROR_INSUFFICIENT_MEMORY;
 c03a864:	f06f 008c 	mvn.w	r0, #140	@ 0x8c
        handle_owner[i].in_use = TFM_CRYPTO_IN_USE;
    }

    return status;
#endif /* TFM_CRYPTO_KEY_MODULE_DISABLED */
}
 c03a868:	b005      	add	sp, #20
 c03a86a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    status = tfm_crypto_get_caller_id(&partition_id);
 c03a86c:	a801      	add	r0, sp, #4
 c03a86e:	f7ff fdcb 	bl	c03a408 <tfm_crypto_get_caller_id>
    if (status != PSA_SUCCESS) {
 c03a872:	2800      	cmp	r0, #0
 c03a874:	d1f8      	bne.n	c03a868 <tfm_crypto_open_key+0x48>
    encoded_key = mbedtls_svc_key_id_make(partition_id, client_key_id);
 c03a876:	9b01      	ldr	r3, [sp, #4]
 c03a878:	9702      	str	r7, [sp, #8]
 c03a87a:	9303      	str	r3, [sp, #12]
    status = psa_open_key(encoded_key, &encoded_key);
 c03a87c:	aa02      	add	r2, sp, #8
 c03a87e:	e892 0003 	ldmia.w	r2, {r0, r1}
 c03a882:	f00e fc33 	bl	c0490ec <mbedcrypto__psa_open_key>
    *key = encoded_key.key_id;
 c03a886:	9b02      	ldr	r3, [sp, #8]
 c03a888:	6033      	str	r3, [r6, #0]
    if (status == PSA_SUCCESS) {
 c03a88a:	2800      	cmp	r0, #0
 c03a88c:	d1ec      	bne.n	c03a868 <tfm_crypto_open_key+0x48>
        handle_owner[i].owner = partition_id;
 c03a88e:	230c      	movs	r3, #12
 c03a890:	435c      	muls	r4, r3
 c03a892:	9a01      	ldr	r2, [sp, #4]
 c03a894:	192b      	adds	r3, r5, r4
 c03a896:	512a      	str	r2, [r5, r4]
        handle_owner[i].key = *key;
 c03a898:	6832      	ldr	r2, [r6, #0]
 c03a89a:	605a      	str	r2, [r3, #4]
        handle_owner[i].in_use = TFM_CRYPTO_IN_USE;
 c03a89c:	2201      	movs	r2, #1
 c03a89e:	721a      	strb	r2, [r3, #8]
 c03a8a0:	e7e2      	b.n	c03a868 <tfm_crypto_open_key+0x48>
    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 2, 2, out_len, 1, 1);
 c03a8a2:	f06f 0080 	mvn.w	r0, #128	@ 0x80
 c03a8a6:	e7df      	b.n	c03a868 <tfm_crypto_open_key+0x48>
 c03a8a8:	30037670 	.word	0x30037670

0c03a8ac <tfm_crypto_close_key>:

psa_status_t tfm_crypto_close_key(psa_invec in_vec[],
                                  size_t in_len,
                                  psa_outvec out_vec[],
                                  size_t out_len)
{
 c03a8ac:	b5f0      	push	{r4, r5, r6, r7, lr}
#ifdef TFM_CRYPTO_KEY_MODULE_DISABLED
    return PSA_ERROR_NOT_SUPPORTED;
#else
    (void)out_vec;

    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 1, out_len, 0, 0);
 c03a8ae:	b24a      	sxtb	r2, r1
 c03a8b0:	2a00      	cmp	r2, #0
{
 c03a8b2:	b085      	sub	sp, #20
    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 1, out_len, 0, 0);
 c03a8b4:	dd21      	ble.n	c03a8fa <tfm_crypto_close_key+0x4e>
 c03a8b6:	2901      	cmp	r1, #1
 c03a8b8:	d11f      	bne.n	c03a8fa <tfm_crypto_close_key+0x4e>
 c03a8ba:	061a      	lsls	r2, r3, #24
 c03a8bc:	d41d      	bmi.n	c03a8fa <tfm_crypto_close_key+0x4e>
 c03a8be:	b9e3      	cbnz	r3, c03a8fa <tfm_crypto_close_key+0x4e>

    if (in_vec[0].len != sizeof(struct tfm_crypto_pack_iovec)) {
 c03a8c0:	6843      	ldr	r3, [r0, #4]
 c03a8c2:	2b2c      	cmp	r3, #44	@ 0x2c
 c03a8c4:	d119      	bne.n	c03a8fa <tfm_crypto_close_key+0x4e>
        return PSA_ERROR_PROGRAMMER_ERROR;
    }
    const struct tfm_crypto_pack_iovec *iov = in_vec[0].base;

    psa_key_id_t key = iov->key_id;
 c03a8c6:	6803      	ldr	r3, [r0, #0]
    uint32_t index;
    mbedtls_svc_key_id_t encoded_key;

    psa_status_t status = tfm_crypto_check_handle_owner(key, &index);
 c03a8c8:	a901      	add	r1, sp, #4
    psa_key_id_t key = iov->key_id;
 c03a8ca:	689f      	ldr	r7, [r3, #8]
    psa_status_t status = tfm_crypto_check_handle_owner(key, &index);
 c03a8cc:	4638      	mov	r0, r7
 c03a8ce:	f7ff fedf 	bl	c03a690 <tfm_crypto_check_handle_owner>
    if (status != PSA_SUCCESS) {
 c03a8d2:	b980      	cbnz	r0, c03a8f6 <tfm_crypto_close_key+0x4a>
        return status;
    }

    encoded_key = mbedtls_svc_key_id_make(handle_owner[index].owner, key);
 c03a8d4:	230c      	movs	r3, #12
 c03a8d6:	9c01      	ldr	r4, [sp, #4]
 c03a8d8:	4d09      	ldr	r5, [pc, #36]	@ (c03a900 <tfm_crypto_close_key+0x54>)
 c03a8da:	435c      	muls	r4, r3
 c03a8dc:	592b      	ldr	r3, [r5, r4]
 c03a8de:	192e      	adds	r6, r5, r4
 * \param key_id   Identifier of the key.
 */
static inline mbedtls_svc_key_id_t mbedtls_svc_key_id_make(
    mbedtls_key_owner_id_t owner_id, psa_key_id_t key_id )
{
    return( (mbedtls_svc_key_id_t){ .key_id = key_id,
 c03a8e0:	e9cd 7302 	strd	r7, r3, [sp, #8]
    status = psa_close_key(encoded_key);
 c03a8e4:	ab04      	add	r3, sp, #16
 c03a8e6:	e913 0003 	ldmdb	r3, {r0, r1}
 c03a8ea:	f00e fc20 	bl	c04912e <mbedcrypto__psa_close_key>

    if (status == PSA_SUCCESS) {
 c03a8ee:	b910      	cbnz	r0, c03a8f6 <tfm_crypto_close_key+0x4a>
        handle_owner[index].owner = 0;
 c03a8f0:	5128      	str	r0, [r5, r4]
        handle_owner[index].key = 0;
 c03a8f2:	6070      	str	r0, [r6, #4]
        handle_owner[index].in_use = TFM_CRYPTO_NOT_IN_USE;
 c03a8f4:	7230      	strb	r0, [r6, #8]
    }

    return status;
#endif /* TFM_CRYPTO_KEY_MODULE_DISABLED */
}
 c03a8f6:	b005      	add	sp, #20
 c03a8f8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 1, out_len, 0, 0);
 c03a8fa:	f06f 0080 	mvn.w	r0, #128	@ 0x80
 c03a8fe:	e7fa      	b.n	c03a8f6 <tfm_crypto_close_key+0x4a>
 c03a900:	30037670 	.word	0x30037670

0c03a904 <tfm_crypto_destroy_key>:

psa_status_t tfm_crypto_destroy_key(psa_invec in_vec[],
                                    size_t in_len,
                                    psa_outvec out_vec[],
                                    size_t out_len)
{
 c03a904:	b5f0      	push	{r4, r5, r6, r7, lr}
#ifdef TFM_CRYPTO_KEY_MODULE_DISABLED
    return PSA_ERROR_NOT_SUPPORTED;
#else
    (void)out_vec;

    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 1, out_len, 0, 0);
 c03a906:	b24a      	sxtb	r2, r1
 c03a908:	2a00      	cmp	r2, #0
{
 c03a90a:	b085      	sub	sp, #20
    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 1, out_len, 0, 0);
 c03a90c:	dd21      	ble.n	c03a952 <tfm_crypto_destroy_key+0x4e>
 c03a90e:	2901      	cmp	r1, #1
 c03a910:	d11f      	bne.n	c03a952 <tfm_crypto_destroy_key+0x4e>
 c03a912:	061a      	lsls	r2, r3, #24
 c03a914:	d41d      	bmi.n	c03a952 <tfm_crypto_destroy_key+0x4e>
 c03a916:	b9e3      	cbnz	r3, c03a952 <tfm_crypto_destroy_key+0x4e>

    if (in_vec[0].len != sizeof(struct tfm_crypto_pack_iovec)) {
 c03a918:	6843      	ldr	r3, [r0, #4]
 c03a91a:	2b2c      	cmp	r3, #44	@ 0x2c
 c03a91c:	d119      	bne.n	c03a952 <tfm_crypto_destroy_key+0x4e>
        return PSA_ERROR_PROGRAMMER_ERROR;
    }
    const struct tfm_crypto_pack_iovec *iov = in_vec[0].base;
    psa_key_id_t key = iov->key_id;
 c03a91e:	6803      	ldr	r3, [r0, #0]
    uint32_t index;
    mbedtls_svc_key_id_t encoded_key;

    psa_status_t status = tfm_crypto_check_handle_owner(key, &index);
 c03a920:	a901      	add	r1, sp, #4
    psa_key_id_t key = iov->key_id;
 c03a922:	689f      	ldr	r7, [r3, #8]
    psa_status_t status = tfm_crypto_check_handle_owner(key, &index);
 c03a924:	4638      	mov	r0, r7
 c03a926:	f7ff feb3 	bl	c03a690 <tfm_crypto_check_handle_owner>
    if (status != PSA_SUCCESS) {
 c03a92a:	b980      	cbnz	r0, c03a94e <tfm_crypto_destroy_key+0x4a>
        return status;
    }

    encoded_key = mbedtls_svc_key_id_make(handle_owner[index].owner, key);
 c03a92c:	230c      	movs	r3, #12
 c03a92e:	9c01      	ldr	r4, [sp, #4]
 c03a930:	4d09      	ldr	r5, [pc, #36]	@ (c03a958 <tfm_crypto_destroy_key+0x54>)
 c03a932:	435c      	muls	r4, r3
 c03a934:	592b      	ldr	r3, [r5, r4]
 c03a936:	192e      	adds	r6, r5, r4
 c03a938:	e9cd 7302 	strd	r7, r3, [sp, #8]

    status = psa_destroy_key(encoded_key);
 c03a93c:	ab04      	add	r3, sp, #16
 c03a93e:	e913 0003 	ldmdb	r3, {r0, r1}
 c03a942:	f00a fbfb 	bl	c04513c <mbedcrypto__psa_destroy_key>
    if (status == PSA_SUCCESS) {
 c03a946:	b910      	cbnz	r0, c03a94e <tfm_crypto_destroy_key+0x4a>
        handle_owner[index].owner = 0;
 c03a948:	5128      	str	r0, [r5, r4]
        handle_owner[index].key = 0;
 c03a94a:	6070      	str	r0, [r6, #4]
        handle_owner[index].in_use = TFM_CRYPTO_NOT_IN_USE;
 c03a94c:	7230      	strb	r0, [r6, #8]
    }

    return status;
#endif /* TFM_CRYPTO_KEY_MODULE_DISABLED */
}
 c03a94e:	b005      	add	sp, #20
 c03a950:	bdf0      	pop	{r4, r5, r6, r7, pc}
    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 1, out_len, 0, 0);
 c03a952:	f06f 0080 	mvn.w	r0, #128	@ 0x80
 c03a956:	e7fa      	b.n	c03a94e <tfm_crypto_destroy_key+0x4a>
 c03a958:	30037670 	.word	0x30037670

0c03a95c <tfm_crypto_get_key_attributes>:

psa_status_t tfm_crypto_get_key_attributes(psa_invec in_vec[],
                                           size_t in_len,
                                           psa_outvec out_vec[],
                                           size_t out_len)
{
 c03a95c:	b570      	push	{r4, r5, r6, lr}
#ifdef TFM_CRYPTO_KEY_MODULE_DISABLED
    return PSA_ERROR_NOT_SUPPORTED;
#else

    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 1, out_len, 1, 1);
 c03a95e:	b24c      	sxtb	r4, r1
 c03a960:	2c00      	cmp	r4, #0
{
 c03a962:	b08e      	sub	sp, #56	@ 0x38
    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 1, out_len, 1, 1);
 c03a964:	dd2b      	ble.n	c03a9be <tfm_crypto_get_key_attributes+0x62>
 c03a966:	2901      	cmp	r1, #1
 c03a968:	d129      	bne.n	c03a9be <tfm_crypto_get_key_attributes+0x62>
 c03a96a:	b259      	sxtb	r1, r3
 c03a96c:	2900      	cmp	r1, #0
 c03a96e:	dd26      	ble.n	c03a9be <tfm_crypto_get_key_attributes+0x62>
 c03a970:	2b01      	cmp	r3, #1
 c03a972:	d124      	bne.n	c03a9be <tfm_crypto_get_key_attributes+0x62>

    if ((in_vec[0].len != sizeof(struct tfm_crypto_pack_iovec)) ||
 c03a974:	6843      	ldr	r3, [r0, #4]
 c03a976:	2b2c      	cmp	r3, #44	@ 0x2c
 c03a978:	d121      	bne.n	c03a9be <tfm_crypto_get_key_attributes+0x62>
 c03a97a:	6853      	ldr	r3, [r2, #4]
 c03a97c:	2b18      	cmp	r3, #24
 c03a97e:	d11e      	bne.n	c03a9be <tfm_crypto_get_key_attributes+0x62>
        (out_vec[0].len != sizeof(struct psa_client_key_attributes_s))) {
        return PSA_ERROR_PROGRAMMER_ERROR;
    }
    const struct tfm_crypto_pack_iovec *iov = in_vec[0].base;

    psa_key_id_t key = iov->key_id;
 c03a980:	6803      	ldr	r3, [r0, #0]
    struct psa_client_key_attributes_s *client_key_attr = out_vec[0].base;
    psa_status_t status;
    psa_key_attributes_t key_attributes = PSA_KEY_ATTRIBUTES_INIT;
 c03a982:	2100      	movs	r1, #0
    psa_key_id_t key = iov->key_id;
 c03a984:	689d      	ldr	r5, [r3, #8]
    struct psa_client_key_attributes_s *client_key_attr = out_vec[0].base;
 c03a986:	6816      	ldr	r6, [r2, #0]
    psa_key_attributes_t key_attributes = PSA_KEY_ATTRIBUTES_INIT;
 c03a988:	a802      	add	r0, sp, #8
 c03a98a:	2230      	movs	r2, #48	@ 0x30
 c03a98c:	f020 fecf 	bl	c05b72e <memset>
    mbedtls_svc_key_id_t encoded_key;

    status = tfm_crypto_check_handle_owner(key, NULL);
 c03a990:	2100      	movs	r1, #0
 c03a992:	4628      	mov	r0, r5
 c03a994:	f7ff fe7c 	bl	c03a690 <tfm_crypto_check_handle_owner>
    if (status != PSA_SUCCESS) {
 c03a998:	b978      	cbnz	r0, c03a9ba <tfm_crypto_get_key_attributes+0x5e>
        return status;
    }

    status = tfm_crypto_encode_id_and_owner(key, &encoded_key);
 c03a99a:	466c      	mov	r4, sp
 c03a99c:	4628      	mov	r0, r5
 c03a99e:	4621      	mov	r1, r4
 c03a9a0:	f7ff fe9e 	bl	c03a6e0 <tfm_crypto_encode_id_and_owner>
    if (status != PSA_SUCCESS) {
 c03a9a4:	b948      	cbnz	r0, c03a9ba <tfm_crypto_get_key_attributes+0x5e>
        return status;
    }

    status = psa_get_key_attributes(encoded_key, &key_attributes);
 c03a9a6:	e894 0003 	ldmia.w	r4, {r0, r1}
 c03a9aa:	aa02      	add	r2, sp, #8
 c03a9ac:	f00a fc2c 	bl	c045208 <mbedcrypto__psa_get_key_attributes>
    if (status == PSA_SUCCESS) {
 c03a9b0:	b918      	cbnz	r0, c03a9ba <tfm_crypto_get_key_attributes+0x5e>
        status = tfm_crypto_key_attributes_to_client(&key_attributes,
 c03a9b2:	4631      	mov	r1, r6
 c03a9b4:	a802      	add	r0, sp, #8
 c03a9b6:	f7ff fe50 	bl	c03a65a <tfm_crypto_key_attributes_to_client>
                                                     client_key_attr);
    }

    return status;
#endif /* TFM_CRYPTO_KEY_MODULE_DISABLED */
}
 c03a9ba:	b00e      	add	sp, #56	@ 0x38
 c03a9bc:	bd70      	pop	{r4, r5, r6, pc}
    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 1, out_len, 1, 1);
 c03a9be:	f06f 0080 	mvn.w	r0, #128	@ 0x80
 c03a9c2:	e7fa      	b.n	c03a9ba <tfm_crypto_get_key_attributes+0x5e>

0c03a9c4 <tfm_crypto_reset_key_attributes>:

psa_status_t tfm_crypto_reset_key_attributes(psa_invec in_vec[],
                                             size_t in_len,
                                             psa_outvec out_vec[],
                                             size_t out_len)
{
 c03a9c4:	b510      	push	{r4, lr}
#if (TFM_CRYPTO_KEY_MODULE_DISABLED != 0)
    return PSA_ERROR_NOT_SUPPORTED;
#else

    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 1, out_len, 1, 1);
 c03a9c6:	b24c      	sxtb	r4, r1
 c03a9c8:	2c00      	cmp	r4, #0
{
 c03a9ca:	b08e      	sub	sp, #56	@ 0x38
    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 1, out_len, 1, 1);
 c03a9cc:	dd25      	ble.n	c03aa1a <tfm_crypto_reset_key_attributes+0x56>
 c03a9ce:	2901      	cmp	r1, #1
 c03a9d0:	d123      	bne.n	c03aa1a <tfm_crypto_reset_key_attributes+0x56>
 c03a9d2:	b259      	sxtb	r1, r3
 c03a9d4:	2900      	cmp	r1, #0
 c03a9d6:	dd20      	ble.n	c03aa1a <tfm_crypto_reset_key_attributes+0x56>
 c03a9d8:	2b01      	cmp	r3, #1
 c03a9da:	d11e      	bne.n	c03aa1a <tfm_crypto_reset_key_attributes+0x56>

    if ((in_vec[0].len != sizeof(struct tfm_crypto_pack_iovec)) ||
 c03a9dc:	6843      	ldr	r3, [r0, #4]
 c03a9de:	2b2c      	cmp	r3, #44	@ 0x2c
 c03a9e0:	d11b      	bne.n	c03aa1a <tfm_crypto_reset_key_attributes+0x56>
 c03a9e2:	6853      	ldr	r3, [r2, #4]
 c03a9e4:	2b18      	cmp	r3, #24
 c03a9e6:	d118      	bne.n	c03aa1a <tfm_crypto_reset_key_attributes+0x56>
        (out_vec[0].len != sizeof(struct psa_client_key_attributes_s))) {
        return PSA_ERROR_PROGRAMMER_ERROR;
    }

    struct psa_client_key_attributes_s *client_key_attr = out_vec[0].base;
 c03a9e8:	6814      	ldr	r4, [r2, #0]
    psa_status_t status;
    psa_key_attributes_t key_attributes = PSA_KEY_ATTRIBUTES_INIT;
 c03a9ea:	2100      	movs	r1, #0
 c03a9ec:	2230      	movs	r2, #48	@ 0x30
 c03a9ee:	a802      	add	r0, sp, #8
 c03a9f0:	f020 fe9d 	bl	c05b72e <memset>
    int32_t partition_id;

    status = tfm_crypto_get_caller_id(&partition_id);
 c03a9f4:	a801      	add	r0, sp, #4
 c03a9f6:	f7ff fd07 	bl	c03a408 <tfm_crypto_get_caller_id>
    if (status != PSA_SUCCESS) {
 c03a9fa:	b960      	cbnz	r0, c03aa16 <tfm_crypto_reset_key_attributes+0x52>
        return status;
    }

    status = tfm_crypto_key_attributes_from_client(client_key_attr,
 c03a9fc:	4620      	mov	r0, r4
 c03a9fe:	9901      	ldr	r1, [sp, #4]
 c03aa00:	aa02      	add	r2, sp, #8
 c03aa02:	f7ff fdff 	bl	c03a604 <tfm_crypto_key_attributes_from_client>
                                                   partition_id,
                                                   &key_attributes);
    if (status != PSA_SUCCESS) {
 c03aa06:	b930      	cbnz	r0, c03aa16 <tfm_crypto_reset_key_attributes+0x52>
        return status;
    }

    psa_reset_key_attributes(&key_attributes);
 c03aa08:	a802      	add	r0, sp, #8
 c03aa0a:	f00c fe84 	bl	c047716 <mbedcrypto__psa_reset_key_attributes>

    return tfm_crypto_key_attributes_to_client(&key_attributes,
 c03aa0e:	4621      	mov	r1, r4
 c03aa10:	a802      	add	r0, sp, #8
 c03aa12:	f7ff fe22 	bl	c03a65a <tfm_crypto_key_attributes_to_client>
                                               client_key_attr);
#endif /* TFM_CRYPTO_KEY_MODULE_DISABLED */
}
 c03aa16:	b00e      	add	sp, #56	@ 0x38
 c03aa18:	bd10      	pop	{r4, pc}
    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 1, out_len, 1, 1);
 c03aa1a:	f06f 0080 	mvn.w	r0, #128	@ 0x80
 c03aa1e:	e7fa      	b.n	c03aa16 <tfm_crypto_reset_key_attributes+0x52>

0c03aa20 <tfm_crypto_export_key>:

psa_status_t tfm_crypto_export_key(psa_invec in_vec[],
                                   size_t in_len,
                                   psa_outvec out_vec[],
                                   size_t out_len)
{
 c03aa20:	b5f0      	push	{r4, r5, r6, r7, lr}
 c03aa22:	4614      	mov	r4, r2
#ifdef TFM_CRYPTO_KEY_MODULE_DISABLED
    return PSA_ERROR_NOT_SUPPORTED;
#else

    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 1, out_len, 0, 1);
 c03aa24:	b24a      	sxtb	r2, r1
 c03aa26:	2a00      	cmp	r2, #0
{
 c03aa28:	b087      	sub	sp, #28
    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 1, out_len, 0, 1);
 c03aa2a:	dd23      	ble.n	c03aa74 <tfm_crypto_export_key+0x54>
 c03aa2c:	2901      	cmp	r1, #1
 c03aa2e:	d121      	bne.n	c03aa74 <tfm_crypto_export_key+0x54>
 c03aa30:	061a      	lsls	r2, r3, #24
 c03aa32:	d41f      	bmi.n	c03aa74 <tfm_crypto_export_key+0x54>
 c03aa34:	2b01      	cmp	r3, #1
 c03aa36:	d81d      	bhi.n	c03aa74 <tfm_crypto_export_key+0x54>

    if (in_vec[0].len != sizeof(struct tfm_crypto_pack_iovec)) {
 c03aa38:	6843      	ldr	r3, [r0, #4]
 c03aa3a:	2b2c      	cmp	r3, #44	@ 0x2c
 c03aa3c:	d11a      	bne.n	c03aa74 <tfm_crypto_export_key+0x54>
    }
    const struct tfm_crypto_pack_iovec *iov = in_vec[0].base;

    psa_key_id_t key = iov->key_id;
    uint8_t *data = out_vec[0].base;
    size_t data_size = out_vec[0].len;
 c03aa3e:	e9d4 6700 	ldrd	r6, r7, [r4]
    psa_key_id_t key = iov->key_id;
 c03aa42:	6803      	ldr	r3, [r0, #0]
    mbedtls_svc_key_id_t encoded_key;
    uint32_t index;

    psa_status_t status = tfm_crypto_check_handle_owner(key, &index);
 c03aa44:	a903      	add	r1, sp, #12
    psa_key_id_t key = iov->key_id;
 c03aa46:	689d      	ldr	r5, [r3, #8]
    psa_status_t status = tfm_crypto_check_handle_owner(key, &index);
 c03aa48:	4628      	mov	r0, r5
 c03aa4a:	f7ff fe21 	bl	c03a690 <tfm_crypto_check_handle_owner>

    if (status != PSA_SUCCESS) {
 c03aa4e:	b978      	cbnz	r0, c03aa70 <tfm_crypto_export_key+0x50>
        return status;
    }

    encoded_key = mbedtls_svc_key_id_make(handle_owner[index].owner, key);
 c03aa50:	230c      	movs	r3, #12
 c03aa52:	9903      	ldr	r1, [sp, #12]
    return psa_export_key(encoded_key, data, data_size,
 c03aa54:	3404      	adds	r4, #4
    encoded_key = mbedtls_svc_key_id_make(handle_owner[index].owner, key);
 c03aa56:	4359      	muls	r1, r3
 c03aa58:	4b08      	ldr	r3, [pc, #32]	@ (c03aa7c <tfm_crypto_export_key+0x5c>)
    return psa_export_key(encoded_key, data, data_size,
 c03aa5a:	4632      	mov	r2, r6
    encoded_key = mbedtls_svc_key_id_make(handle_owner[index].owner, key);
 c03aa5c:	585b      	ldr	r3, [r3, r1]
    return psa_export_key(encoded_key, data, data_size,
 c03aa5e:	9400      	str	r4, [sp, #0]
 c03aa60:	e9cd 5304 	strd	r5, r3, [sp, #16]
 c03aa64:	a906      	add	r1, sp, #24
 c03aa66:	463b      	mov	r3, r7
 c03aa68:	e911 0003 	ldmdb	r1, {r0, r1}
 c03aa6c:	f00a fc93 	bl	c045396 <mbedcrypto__psa_export_key>
                          &(out_vec[0].len));
#endif /* TFM_CRYPTO_KEY_MODULE_DISABLED */
}
 c03aa70:	b007      	add	sp, #28
 c03aa72:	bdf0      	pop	{r4, r5, r6, r7, pc}
    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 1, out_len, 0, 1);
 c03aa74:	f06f 0080 	mvn.w	r0, #128	@ 0x80
 c03aa78:	e7fa      	b.n	c03aa70 <tfm_crypto_export_key+0x50>
 c03aa7a:	bf00      	nop
 c03aa7c:	30037670 	.word	0x30037670

0c03aa80 <tfm_crypto_export_public_key>:

psa_status_t tfm_crypto_export_public_key(psa_invec in_vec[],
                                          size_t in_len,
                                          psa_outvec out_vec[],
                                          size_t out_len)
{
 c03aa80:	b5f0      	push	{r4, r5, r6, r7, lr}
 c03aa82:	4614      	mov	r4, r2
#ifdef TFM_CRYPTO_KEY_MODULE_DISABLED
    return PSA_ERROR_NOT_SUPPORTED;
#else

    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 1, out_len, 0, 1);
 c03aa84:	b24a      	sxtb	r2, r1
 c03aa86:	2a00      	cmp	r2, #0
{
 c03aa88:	b087      	sub	sp, #28
    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 1, out_len, 0, 1);
 c03aa8a:	dd23      	ble.n	c03aad4 <tfm_crypto_export_public_key+0x54>
 c03aa8c:	2901      	cmp	r1, #1
 c03aa8e:	d121      	bne.n	c03aad4 <tfm_crypto_export_public_key+0x54>
 c03aa90:	061a      	lsls	r2, r3, #24
 c03aa92:	d41f      	bmi.n	c03aad4 <tfm_crypto_export_public_key+0x54>
 c03aa94:	2b01      	cmp	r3, #1
 c03aa96:	d81d      	bhi.n	c03aad4 <tfm_crypto_export_public_key+0x54>

    if (in_vec[0].len != sizeof(struct tfm_crypto_pack_iovec)) {
 c03aa98:	6843      	ldr	r3, [r0, #4]
 c03aa9a:	2b2c      	cmp	r3, #44	@ 0x2c
 c03aa9c:	d11a      	bne.n	c03aad4 <tfm_crypto_export_public_key+0x54>
        return PSA_ERROR_PROGRAMMER_ERROR;
    }
    const struct tfm_crypto_pack_iovec *iov = in_vec[0].base;
    psa_key_id_t key = iov->key_id;
    uint8_t *data = out_vec[0].base;
    size_t data_size = out_vec[0].len;
 c03aa9e:	e9d4 6700 	ldrd	r6, r7, [r4]
    psa_key_id_t key = iov->key_id;
 c03aaa2:	6803      	ldr	r3, [r0, #0]
    mbedtls_svc_key_id_t encoded_key;
    uint32_t index;

    psa_status_t status = tfm_crypto_check_handle_owner(key, &index);
 c03aaa4:	a903      	add	r1, sp, #12
    psa_key_id_t key = iov->key_id;
 c03aaa6:	689d      	ldr	r5, [r3, #8]
    psa_status_t status = tfm_crypto_check_handle_owner(key, &index);
 c03aaa8:	4628      	mov	r0, r5
 c03aaaa:	f7ff fdf1 	bl	c03a690 <tfm_crypto_check_handle_owner>

    if (status != PSA_SUCCESS) {
 c03aaae:	b978      	cbnz	r0, c03aad0 <tfm_crypto_export_public_key+0x50>
        return status;
    }

    encoded_key = mbedtls_svc_key_id_make(handle_owner[index].owner, key);
 c03aab0:	230c      	movs	r3, #12
 c03aab2:	9903      	ldr	r1, [sp, #12]

    return psa_export_public_key(encoded_key, data, data_size,
 c03aab4:	3404      	adds	r4, #4
    encoded_key = mbedtls_svc_key_id_make(handle_owner[index].owner, key);
 c03aab6:	4359      	muls	r1, r3
 c03aab8:	4b08      	ldr	r3, [pc, #32]	@ (c03aadc <tfm_crypto_export_public_key+0x5c>)
    return psa_export_public_key(encoded_key, data, data_size,
 c03aaba:	4632      	mov	r2, r6
    encoded_key = mbedtls_svc_key_id_make(handle_owner[index].owner, key);
 c03aabc:	585b      	ldr	r3, [r3, r1]
    return psa_export_public_key(encoded_key, data, data_size,
 c03aabe:	9400      	str	r4, [sp, #0]
 c03aac0:	e9cd 5304 	strd	r5, r3, [sp, #16]
 c03aac4:	a906      	add	r1, sp, #24
 c03aac6:	463b      	mov	r3, r7
 c03aac8:	e911 0003 	ldmdb	r1, {r0, r1}
 c03aacc:	f00a fcd7 	bl	c04547e <mbedcrypto__psa_export_public_key>
                                 &(out_vec[0].len));
#endif /* TFM_CRYPTO_KEY_MODULE_DISABLED */
}
 c03aad0:	b007      	add	sp, #28
 c03aad2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 1, out_len, 0, 1);
 c03aad4:	f06f 0080 	mvn.w	r0, #128	@ 0x80
 c03aad8:	e7fa      	b.n	c03aad0 <tfm_crypto_export_public_key+0x50>
 c03aada:	bf00      	nop
 c03aadc:	30037670 	.word	0x30037670

0c03aae0 <tfm_crypto_purge_key>:

psa_status_t tfm_crypto_purge_key(psa_invec in_vec[],
                                  size_t in_len,
                                  psa_outvec out_vec[],
                                  size_t out_len)
{
 c03aae0:	b5f0      	push	{r4, r5, r6, r7, lr}
#ifdef TFM_CRYPTO_KEY_MODULE_DISABLED
    return PSA_ERROR_NOT_SUPPORTED;
#else
    (void)out_vec;

    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 1, out_len, 0, 0);
 c03aae2:	b24a      	sxtb	r2, r1
 c03aae4:	2a00      	cmp	r2, #0
{
 c03aae6:	b085      	sub	sp, #20
    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 1, out_len, 0, 0);
 c03aae8:	dd21      	ble.n	c03ab2e <tfm_crypto_purge_key+0x4e>
 c03aaea:	2901      	cmp	r1, #1
 c03aaec:	d11f      	bne.n	c03ab2e <tfm_crypto_purge_key+0x4e>
 c03aaee:	061a      	lsls	r2, r3, #24
 c03aaf0:	d41d      	bmi.n	c03ab2e <tfm_crypto_purge_key+0x4e>
 c03aaf2:	b9e3      	cbnz	r3, c03ab2e <tfm_crypto_purge_key+0x4e>

    if (in_vec[0].len != sizeof(struct tfm_crypto_pack_iovec)) {
 c03aaf4:	6843      	ldr	r3, [r0, #4]
 c03aaf6:	2b2c      	cmp	r3, #44	@ 0x2c
 c03aaf8:	d119      	bne.n	c03ab2e <tfm_crypto_purge_key+0x4e>
        return PSA_ERROR_PROGRAMMER_ERROR;
    }
    const struct tfm_crypto_pack_iovec *iov = in_vec[0].base;
    psa_key_id_t key = iov->key_id;
 c03aafa:	6803      	ldr	r3, [r0, #0]
    uint32_t index;
    mbedtls_svc_key_id_t encoded_key;

    psa_status_t status = tfm_crypto_check_handle_owner(key, &index);
 c03aafc:	a901      	add	r1, sp, #4
    psa_key_id_t key = iov->key_id;
 c03aafe:	689f      	ldr	r7, [r3, #8]
    psa_status_t status = tfm_crypto_check_handle_owner(key, &index);
 c03ab00:	4638      	mov	r0, r7
 c03ab02:	f7ff fdc5 	bl	c03a690 <tfm_crypto_check_handle_owner>

    if (status != PSA_SUCCESS) {
 c03ab06:	b980      	cbnz	r0, c03ab2a <tfm_crypto_purge_key+0x4a>
        return status;
    }

    encoded_key = mbedtls_svc_key_id_make(handle_owner[index].owner, key);
 c03ab08:	230c      	movs	r3, #12
 c03ab0a:	9c01      	ldr	r4, [sp, #4]
 c03ab0c:	4d09      	ldr	r5, [pc, #36]	@ (c03ab34 <tfm_crypto_purge_key+0x54>)
 c03ab0e:	435c      	muls	r4, r3
 c03ab10:	592b      	ldr	r3, [r5, r4]
 c03ab12:	192e      	adds	r6, r5, r4
 c03ab14:	e9cd 7302 	strd	r7, r3, [sp, #8]

    status = psa_purge_key(encoded_key);
 c03ab18:	ab04      	add	r3, sp, #16
 c03ab1a:	e913 0003 	ldmdb	r3, {r0, r1}
 c03ab1e:	f00e fb27 	bl	c049170 <mbedcrypto__psa_purge_key>
    if (status == PSA_SUCCESS) {
 c03ab22:	b910      	cbnz	r0, c03ab2a <tfm_crypto_purge_key+0x4a>
        handle_owner[index].owner = 0;
 c03ab24:	5128      	str	r0, [r5, r4]
        handle_owner[index].key = 0;
 c03ab26:	6070      	str	r0, [r6, #4]
        handle_owner[index].in_use = TFM_CRYPTO_NOT_IN_USE;
 c03ab28:	7230      	strb	r0, [r6, #8]
    }

    return status;
#endif /* TFM_CRYPTO_KEY_MODULE_DISABLED */
}
 c03ab2a:	b005      	add	sp, #20
 c03ab2c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 1, out_len, 0, 0);
 c03ab2e:	f06f 0080 	mvn.w	r0, #128	@ 0x80
 c03ab32:	e7fa      	b.n	c03ab2a <tfm_crypto_purge_key+0x4a>
 c03ab34:	30037670 	.word	0x30037670

0c03ab38 <tfm_crypto_copy_key>:

psa_status_t tfm_crypto_copy_key(psa_invec in_vec[],
                                 size_t in_len,
                                 psa_outvec out_vec[],
                                 size_t out_len)
{
 c03ab38:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
#ifdef TFM_CRYPTO_KEY_MODULE_DISABLED
    return PSA_ERROR_NOT_SUPPORTED;
#else

    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 2, 2, out_len, 1, 1);
 c03ab3c:	b24c      	sxtb	r4, r1
 c03ab3e:	2c01      	cmp	r4, #1
{
 c03ab40:	b092      	sub	sp, #72	@ 0x48
    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 2, 2, out_len, 1, 1);
 c03ab42:	dd29      	ble.n	c03ab98 <tfm_crypto_copy_key+0x60>
 c03ab44:	2902      	cmp	r1, #2
 c03ab46:	d127      	bne.n	c03ab98 <tfm_crypto_copy_key+0x60>
 c03ab48:	b259      	sxtb	r1, r3
 c03ab4a:	2900      	cmp	r1, #0
 c03ab4c:	dd24      	ble.n	c03ab98 <tfm_crypto_copy_key+0x60>
 c03ab4e:	2b01      	cmp	r3, #1
 c03ab50:	d122      	bne.n	c03ab98 <tfm_crypto_copy_key+0x60>

    if ((in_vec[0].len != sizeof(struct tfm_crypto_pack_iovec)) ||
 c03ab52:	6843      	ldr	r3, [r0, #4]
 c03ab54:	2b2c      	cmp	r3, #44	@ 0x2c
 c03ab56:	d11f      	bne.n	c03ab98 <tfm_crypto_copy_key+0x60>
 c03ab58:	6853      	ldr	r3, [r2, #4]
 c03ab5a:	2b04      	cmp	r3, #4
 c03ab5c:	d11c      	bne.n	c03ab98 <tfm_crypto_copy_key+0x60>
        (out_vec[0].len != sizeof(psa_key_id_t)) ||
 c03ab5e:	68c3      	ldr	r3, [r0, #12]
 c03ab60:	2b18      	cmp	r3, #24
 c03ab62:	d119      	bne.n	c03ab98 <tfm_crypto_copy_key+0x60>
        (in_vec[1].len != sizeof(struct psa_client_key_attributes_s))) {
        return PSA_ERROR_PROGRAMMER_ERROR;
    }
    const struct tfm_crypto_pack_iovec *iov = in_vec[0].base;

    psa_key_id_t source_key_id = iov->key_id;
 c03ab64:	6803      	ldr	r3, [r0, #0]
    psa_key_id_t *target_key_id = out_vec[0].base;
 c03ab66:	6815      	ldr	r5, [r2, #0]
    const struct psa_client_key_attributes_s *client_key_attr = in_vec[1].base;
 c03ab68:	f8d0 8008 	ldr.w	r8, [r0, #8]
    psa_status_t status;
    psa_key_attributes_t key_attributes = PSA_KEY_ATTRIBUTES_INIT;
 c03ab6c:	2230      	movs	r2, #48	@ 0x30
 c03ab6e:	2100      	movs	r1, #0
 c03ab70:	a806      	add	r0, sp, #24
    psa_key_id_t source_key_id = iov->key_id;
 c03ab72:	689f      	ldr	r7, [r3, #8]
    psa_key_attributes_t key_attributes = PSA_KEY_ATTRIBUTES_INIT;
 c03ab74:	f020 fddb 	bl	c05b72e <memset>
    uint32_t i = 0;
    int32_t partition_id = 0;
 c03ab78:	4b20      	ldr	r3, [pc, #128]	@ (c03abfc <tfm_crypto_copy_key+0xc4>)
 c03ab7a:	2400      	movs	r4, #0
 c03ab7c:	461e      	mov	r6, r3
 c03ab7e:	9401      	str	r4, [sp, #4]
    bool empty_found = false;
    mbedtls_svc_key_id_t target_key;
    mbedtls_svc_key_id_t encoded_key;

    for (i = 0; i < TFM_CRYPTO_MAX_KEY_HANDLES; i++) {
        if (handle_owner[i].in_use == TFM_CRYPTO_NOT_IN_USE) {
 c03ab80:	7a1a      	ldrb	r2, [r3, #8]
 c03ab82:	b162      	cbz	r2, c03ab9e <tfm_crypto_copy_key+0x66>
    for (i = 0; i < TFM_CRYPTO_MAX_KEY_HANDLES; i++) {
 c03ab84:	3401      	adds	r4, #1
 c03ab86:	2c20      	cmp	r4, #32
 c03ab88:	f103 030c 	add.w	r3, r3, #12
 c03ab8c:	d1f8      	bne.n	c03ab80 <tfm_crypto_copy_key+0x48>
            break;
        }
    }

    if (!empty_found) {
        return PSA_ERROR_INSUFFICIENT_MEMORY;
 c03ab8e:	f06f 008c 	mvn.w	r0, #140	@ 0x8c
        handle_owner[i].in_use = TFM_CRYPTO_IN_USE;
    }

    return status;
#endif /* TFM_CRYPTO_KEY_MODULE_DISABLED */
}
 c03ab92:	b012      	add	sp, #72	@ 0x48
 c03ab94:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 2, 2, out_len, 1, 1);
 c03ab98:	f06f 0080 	mvn.w	r0, #128	@ 0x80
 c03ab9c:	e7f9      	b.n	c03ab92 <tfm_crypto_copy_key+0x5a>
    status = tfm_crypto_get_caller_id(&partition_id);
 c03ab9e:	a801      	add	r0, sp, #4
 c03aba0:	f7ff fc32 	bl	c03a408 <tfm_crypto_get_caller_id>
    if (status != PSA_SUCCESS) {
 c03aba4:	2800      	cmp	r0, #0
 c03aba6:	d1f4      	bne.n	c03ab92 <tfm_crypto_copy_key+0x5a>
    status = tfm_crypto_key_attributes_from_client(client_key_attr,
 c03aba8:	4640      	mov	r0, r8
 c03abaa:	9901      	ldr	r1, [sp, #4]
 c03abac:	aa06      	add	r2, sp, #24
 c03abae:	f7ff fd29 	bl	c03a604 <tfm_crypto_key_attributes_from_client>
    if (status != PSA_SUCCESS) {
 c03abb2:	2800      	cmp	r0, #0
 c03abb4:	d1ed      	bne.n	c03ab92 <tfm_crypto_copy_key+0x5a>
    status = tfm_crypto_check_handle_owner(source_key_id, NULL);
 c03abb6:	4601      	mov	r1, r0
 c03abb8:	4638      	mov	r0, r7
 c03abba:	f7ff fd69 	bl	c03a690 <tfm_crypto_check_handle_owner>
    if (status != PSA_SUCCESS) {
 c03abbe:	2800      	cmp	r0, #0
 c03abc0:	d1e7      	bne.n	c03ab92 <tfm_crypto_copy_key+0x5a>
    status = tfm_crypto_encode_id_and_owner(source_key_id, &encoded_key);
 c03abc2:	f10d 0810 	add.w	r8, sp, #16
 c03abc6:	4641      	mov	r1, r8
 c03abc8:	4638      	mov	r0, r7
 c03abca:	f7ff fd89 	bl	c03a6e0 <tfm_crypto_encode_id_and_owner>
    if (status != PSA_SUCCESS) {
 c03abce:	2800      	cmp	r0, #0
 c03abd0:	d1df      	bne.n	c03ab92 <tfm_crypto_copy_key+0x5a>
    status = psa_copy_key(encoded_key, &key_attributes, &target_key);
 c03abd2:	e898 0003 	ldmia.w	r8, {r0, r1}
 c03abd6:	ab02      	add	r3, sp, #8
 c03abd8:	aa06      	add	r2, sp, #24
 c03abda:	f00a fd00 	bl	c0455de <mbedcrypto__psa_copy_key>
    *target_key_id = target_key.key_id;
 c03abde:	9b02      	ldr	r3, [sp, #8]
 c03abe0:	602b      	str	r3, [r5, #0]
    if (status == PSA_SUCCESS) {
 c03abe2:	2800      	cmp	r0, #0
 c03abe4:	d1d5      	bne.n	c03ab92 <tfm_crypto_copy_key+0x5a>
        handle_owner[i].owner = partition_id;
 c03abe6:	230c      	movs	r3, #12
 c03abe8:	4363      	muls	r3, r4
 c03abea:	9901      	ldr	r1, [sp, #4]
 c03abec:	18f2      	adds	r2, r6, r3
 c03abee:	50f1      	str	r1, [r6, r3]
        handle_owner[i].key = *target_key_id;
 c03abf0:	682b      	ldr	r3, [r5, #0]
 c03abf2:	6053      	str	r3, [r2, #4]
        handle_owner[i].in_use = TFM_CRYPTO_IN_USE;
 c03abf4:	2301      	movs	r3, #1
 c03abf6:	7213      	strb	r3, [r2, #8]
 c03abf8:	e7cb      	b.n	c03ab92 <tfm_crypto_copy_key+0x5a>
 c03abfa:	bf00      	nop
 c03abfc:	30037670 	.word	0x30037670

0c03ac00 <tfm_crypto_generate_key>:

psa_status_t tfm_crypto_generate_key(psa_invec in_vec[],
                                     size_t in_len,
                                     psa_outvec out_vec[],
                                     size_t out_len)
{
 c03ac00:	b5f0      	push	{r4, r5, r6, r7, lr}
#ifdef TFM_CRYPTO_KEY_MODULE_DISABLED
    return PSA_ERROR_NOT_SUPPORTED;
#else

    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 2, 2, out_len, 1, 1);
 c03ac02:	b24c      	sxtb	r4, r1
 c03ac04:	2c01      	cmp	r4, #1
{
 c03ac06:	b091      	sub	sp, #68	@ 0x44
    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 2, 2, out_len, 1, 1);
 c03ac08:	dd25      	ble.n	c03ac56 <tfm_crypto_generate_key+0x56>
 c03ac0a:	2902      	cmp	r1, #2
 c03ac0c:	d123      	bne.n	c03ac56 <tfm_crypto_generate_key+0x56>
 c03ac0e:	b259      	sxtb	r1, r3
 c03ac10:	2900      	cmp	r1, #0
 c03ac12:	dd20      	ble.n	c03ac56 <tfm_crypto_generate_key+0x56>
 c03ac14:	2b01      	cmp	r3, #1
 c03ac16:	d11e      	bne.n	c03ac56 <tfm_crypto_generate_key+0x56>

    if ((in_vec[0].len != sizeof(struct tfm_crypto_pack_iovec)) ||
 c03ac18:	6843      	ldr	r3, [r0, #4]
 c03ac1a:	2b2c      	cmp	r3, #44	@ 0x2c
 c03ac1c:	d11b      	bne.n	c03ac56 <tfm_crypto_generate_key+0x56>
 c03ac1e:	68c3      	ldr	r3, [r0, #12]
 c03ac20:	2b18      	cmp	r3, #24
 c03ac22:	d118      	bne.n	c03ac56 <tfm_crypto_generate_key+0x56>
        (in_vec[1].len != sizeof(struct psa_client_key_attributes_s)) ||
 c03ac24:	6853      	ldr	r3, [r2, #4]
 c03ac26:	2b04      	cmp	r3, #4
 c03ac28:	d115      	bne.n	c03ac56 <tfm_crypto_generate_key+0x56>
        (out_vec[0].len != sizeof(psa_key_id_t))) {
        return PSA_ERROR_PROGRAMMER_ERROR;
    }
    psa_key_id_t *key_handle = out_vec[0].base;
 c03ac2a:	6815      	ldr	r5, [r2, #0]
    const struct psa_client_key_attributes_s *client_key_attr = in_vec[1].base;
 c03ac2c:	6887      	ldr	r7, [r0, #8]
    psa_status_t status;
    psa_key_attributes_t key_attributes = PSA_KEY_ATTRIBUTES_INIT;
 c03ac2e:	2230      	movs	r2, #48	@ 0x30
 c03ac30:	2100      	movs	r1, #0
 c03ac32:	a804      	add	r0, sp, #16
 c03ac34:	f020 fd7b 	bl	c05b72e <memset>
    uint32_t i = 0;
    int32_t partition_id = 0;
 c03ac38:	4b17      	ldr	r3, [pc, #92]	@ (c03ac98 <tfm_crypto_generate_key+0x98>)
 c03ac3a:	2400      	movs	r4, #0
 c03ac3c:	461e      	mov	r6, r3
 c03ac3e:	9401      	str	r4, [sp, #4]
    bool empty_found = false;
    mbedtls_svc_key_id_t encoded_key;

    for (i = 0; i < TFM_CRYPTO_MAX_KEY_HANDLES; i++) {
        if (handle_owner[i].in_use == TFM_CRYPTO_NOT_IN_USE) {
 c03ac40:	7a1a      	ldrb	r2, [r3, #8]
 c03ac42:	b15a      	cbz	r2, c03ac5c <tfm_crypto_generate_key+0x5c>
    for (i = 0; i < TFM_CRYPTO_MAX_KEY_HANDLES; i++) {
 c03ac44:	3401      	adds	r4, #1
 c03ac46:	2c20      	cmp	r4, #32
 c03ac48:	f103 030c 	add.w	r3, r3, #12
 c03ac4c:	d1f8      	bne.n	c03ac40 <tfm_crypto_generate_key+0x40>
            break;
        }
    }

    if (!empty_found) {
        return PSA_ERROR_INSUFFICIENT_MEMORY;
 c03ac4e:	f06f 008c 	mvn.w	r0, #140	@ 0x8c
        handle_owner[i].in_use = TFM_CRYPTO_IN_USE;
    }

    return status;
#endif /* TFM_CRYPTO_KEY_MODULE_DISABLED */
}
 c03ac52:	b011      	add	sp, #68	@ 0x44
 c03ac54:	bdf0      	pop	{r4, r5, r6, r7, pc}
    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 2, 2, out_len, 1, 1);
 c03ac56:	f06f 0080 	mvn.w	r0, #128	@ 0x80
 c03ac5a:	e7fa      	b.n	c03ac52 <tfm_crypto_generate_key+0x52>
    status = tfm_crypto_get_caller_id(&partition_id);
 c03ac5c:	a801      	add	r0, sp, #4
 c03ac5e:	f7ff fbd3 	bl	c03a408 <tfm_crypto_get_caller_id>
    if (status != PSA_SUCCESS) {
 c03ac62:	2800      	cmp	r0, #0
 c03ac64:	d1f5      	bne.n	c03ac52 <tfm_crypto_generate_key+0x52>
    status = tfm_crypto_key_attributes_from_client(client_key_attr,
 c03ac66:	4638      	mov	r0, r7
 c03ac68:	9901      	ldr	r1, [sp, #4]
 c03ac6a:	aa04      	add	r2, sp, #16
 c03ac6c:	f7ff fcca 	bl	c03a604 <tfm_crypto_key_attributes_from_client>
    if (status != PSA_SUCCESS) {
 c03ac70:	2800      	cmp	r0, #0
 c03ac72:	d1ee      	bne.n	c03ac52 <tfm_crypto_generate_key+0x52>
    status = psa_generate_key(&key_attributes, &encoded_key);
 c03ac74:	a902      	add	r1, sp, #8
 c03ac76:	a804      	add	r0, sp, #16
 c03ac78:	f00c f8a6 	bl	c046dc8 <mbedcrypto__psa_generate_key>
    *key_handle = encoded_key.key_id;
 c03ac7c:	9b02      	ldr	r3, [sp, #8]
 c03ac7e:	602b      	str	r3, [r5, #0]
    if (status == PSA_SUCCESS) {
 c03ac80:	2800      	cmp	r0, #0
 c03ac82:	d1e6      	bne.n	c03ac52 <tfm_crypto_generate_key+0x52>
        handle_owner[i].owner = partition_id;
 c03ac84:	230c      	movs	r3, #12
 c03ac86:	4363      	muls	r3, r4
 c03ac88:	9901      	ldr	r1, [sp, #4]
 c03ac8a:	18f2      	adds	r2, r6, r3
 c03ac8c:	50f1      	str	r1, [r6, r3]
        handle_owner[i].key = *key_handle;
 c03ac8e:	682b      	ldr	r3, [r5, #0]
 c03ac90:	6053      	str	r3, [r2, #4]
        handle_owner[i].in_use = TFM_CRYPTO_IN_USE;
 c03ac92:	2301      	movs	r3, #1
 c03ac94:	7213      	strb	r3, [r2, #8]
 c03ac96:	e7dc      	b.n	c03ac52 <tfm_crypto_generate_key+0x52>
 c03ac98:	30037670 	.word	0x30037670

0c03ac9c <tfm_crypto_key_derivation_setup>:
/*!@{*/
psa_status_t tfm_crypto_key_derivation_setup(psa_invec in_vec[],
                                             size_t in_len,
                                             psa_outvec out_vec[],
                                             size_t out_len)
{
 c03ac9c:	b573      	push	{r0, r1, r4, r5, r6, lr}
 c03ac9e:	4604      	mov	r4, r0
#ifdef TFM_CRYPTO_KEY_DERIVATION_MODULE_DISABLED
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status = PSA_SUCCESS;
    psa_key_derivation_operation_t *operation = NULL;
 c03aca0:	2000      	movs	r0, #0
 c03aca2:	9000      	str	r0, [sp, #0]

    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 1, out_len, 1, 1);
 c03aca4:	b248      	sxtb	r0, r1
 c03aca6:	2800      	cmp	r0, #0
 c03aca8:	dd2c      	ble.n	c03ad04 <tfm_crypto_key_derivation_setup+0x68>
 c03acaa:	2901      	cmp	r1, #1
 c03acac:	d12a      	bne.n	c03ad04 <tfm_crypto_key_derivation_setup+0x68>
 c03acae:	b259      	sxtb	r1, r3
 c03acb0:	2900      	cmp	r1, #0
 c03acb2:	dd27      	ble.n	c03ad04 <tfm_crypto_key_derivation_setup+0x68>
 c03acb4:	2b01      	cmp	r3, #1
 c03acb6:	d125      	bne.n	c03ad04 <tfm_crypto_key_derivation_setup+0x68>

    if ((out_vec[0].len != sizeof(uint32_t)) ||
 c03acb8:	6850      	ldr	r0, [r2, #4]
 c03acba:	2804      	cmp	r0, #4
 c03acbc:	d122      	bne.n	c03ad04 <tfm_crypto_key_derivation_setup+0x68>
 c03acbe:	6863      	ldr	r3, [r4, #4]
 c03acc0:	2b2c      	cmp	r3, #44	@ 0x2c
 c03acc2:	d11f      	bne.n	c03ad04 <tfm_crypto_key_derivation_setup+0x68>
        (in_vec[0].len != sizeof(struct tfm_crypto_pack_iovec))) {
        return PSA_ERROR_PROGRAMMER_ERROR;
    }
    const struct tfm_crypto_pack_iovec *iov = in_vec[0].base;
 c03acc4:	6823      	ldr	r3, [r4, #0]
    uint32_t handle = iov->op_handle;
    uint32_t *handle_out = out_vec[0].base;
 c03acc6:	6816      	ldr	r6, [r2, #0]
    uint32_t handle = iov->op_handle;
 c03acc8:	6919      	ldr	r1, [r3, #16]
    psa_algorithm_t alg = iov->alg;

    /* Allocate the operation context in the secure world */
    status = tfm_crypto_operation_alloc(TFM_CRYPTO_KEY_DERIVATION_OPERATION,
 c03acca:	466a      	mov	r2, sp
    uint32_t handle = iov->op_handle;
 c03accc:	9101      	str	r1, [sp, #4]
    status = tfm_crypto_operation_alloc(TFM_CRYPTO_KEY_DERIVATION_OPERATION,
 c03acce:	a901      	add	r1, sp, #4
    psa_algorithm_t alg = iov->alg;
 c03acd0:	68dd      	ldr	r5, [r3, #12]
    status = tfm_crypto_operation_alloc(TFM_CRYPTO_KEY_DERIVATION_OPERATION,
 c03acd2:	f7fe ff29 	bl	c039b28 <tfm_crypto_operation_alloc>
                                        &handle,
                                        (void **)&operation);
    if (status != PSA_SUCCESS) {
 c03acd6:	4604      	mov	r4, r0
 c03acd8:	b930      	cbnz	r0, c03ace8 <tfm_crypto_key_derivation_setup+0x4c>
        return status;
    }

    *handle_out = handle;
 c03acda:	9b01      	ldr	r3, [sp, #4]

    if (alg == TFM_CRYPTO_ALG_HUK_DERIVATION) {
        status = tfm_crypto_huk_derivation_setup(operation, alg);
 c03acdc:	9800      	ldr	r0, [sp, #0]
    *handle_out = handle;
 c03acde:	6033      	str	r3, [r6, #0]
    if (alg == TFM_CRYPTO_ALG_HUK_DERIVATION) {
 c03ace0:	4b0a      	ldr	r3, [pc, #40]	@ (c03ad0c <tfm_crypto_key_derivation_setup+0x70>)
 c03ace2:	429d      	cmp	r5, r3
 c03ace4:	d103      	bne.n	c03acee <tfm_crypto_key_derivation_setup+0x52>
    operation->alg = TFM_CRYPTO_ALG_HUK_DERIVATION;
 c03ace6:	6005      	str	r5, [r0, #0]
        return status;
    }

    return status;
#endif /* TFM_CRYPTO_KEY_DERIVATION_MODULE_DISABLED */
}
 c03ace8:	4620      	mov	r0, r4
 c03acea:	b002      	add	sp, #8
 c03acec:	bd70      	pop	{r4, r5, r6, pc}
        status = psa_key_derivation_setup(operation, alg);
 c03acee:	4629      	mov	r1, r5
 c03acf0:	f00b fefa 	bl	c046ae8 <mbedcrypto__psa_key_derivation_setup>
    if (status != PSA_SUCCESS) {
 c03acf4:	4605      	mov	r5, r0
 c03acf6:	2800      	cmp	r0, #0
 c03acf8:	d0f6      	beq.n	c03ace8 <tfm_crypto_key_derivation_setup+0x4c>
        (void)tfm_crypto_operation_release(handle_out);
 c03acfa:	4630      	mov	r0, r6
 c03acfc:	f7fe ff48 	bl	c039b90 <tfm_crypto_operation_release>
        return status;
 c03ad00:	462c      	mov	r4, r5
 c03ad02:	e7f1      	b.n	c03ace8 <tfm_crypto_key_derivation_setup+0x4c>
    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 1, out_len, 1, 1);
 c03ad04:	f06f 0480 	mvn.w	r4, #128	@ 0x80
 c03ad08:	e7ee      	b.n	c03ace8 <tfm_crypto_key_derivation_setup+0x4c>
 c03ad0a:	bf00      	nop
 c03ad0c:	b0000f00 	.word	0xb0000f00

0c03ad10 <tfm_crypto_key_derivation_get_capacity>:

psa_status_t tfm_crypto_key_derivation_get_capacity(psa_invec in_vec[],
                                                    size_t in_len,
                                                    psa_outvec out_vec[],
                                                    size_t out_len)
{
 c03ad10:	b537      	push	{r0, r1, r2, r4, r5, lr}
 c03ad12:	4604      	mov	r4, r0
#ifdef TFM_CRYPTO_KEY_DERIVATION_MODULE_DISABLED
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status;

    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 1, out_len, 1, 1);
 c03ad14:	b248      	sxtb	r0, r1
 c03ad16:	2800      	cmp	r0, #0
 c03ad18:	dd1d      	ble.n	c03ad56 <tfm_crypto_key_derivation_get_capacity+0x46>
 c03ad1a:	2901      	cmp	r1, #1
 c03ad1c:	d11b      	bne.n	c03ad56 <tfm_crypto_key_derivation_get_capacity+0x46>
 c03ad1e:	b259      	sxtb	r1, r3
 c03ad20:	2900      	cmp	r1, #0
 c03ad22:	dd18      	ble.n	c03ad56 <tfm_crypto_key_derivation_get_capacity+0x46>
 c03ad24:	2b01      	cmp	r3, #1
 c03ad26:	d116      	bne.n	c03ad56 <tfm_crypto_key_derivation_get_capacity+0x46>

    if ((in_vec[0].len != sizeof(struct tfm_crypto_pack_iovec)) ||
 c03ad28:	6863      	ldr	r3, [r4, #4]
 c03ad2a:	2b2c      	cmp	r3, #44	@ 0x2c
 c03ad2c:	d113      	bne.n	c03ad56 <tfm_crypto_key_derivation_get_capacity+0x46>
 c03ad2e:	6850      	ldr	r0, [r2, #4]
 c03ad30:	2804      	cmp	r0, #4
 c03ad32:	d110      	bne.n	c03ad56 <tfm_crypto_key_derivation_get_capacity+0x46>
    }
    const struct tfm_crypto_pack_iovec *iov = in_vec[0].base;

    uint32_t handle = iov->op_handle;
    size_t *capacity = out_vec[0].base;
    psa_key_derivation_operation_t *operation = NULL;
 c03ad34:	2500      	movs	r5, #0
    uint32_t handle = iov->op_handle;
 c03ad36:	6823      	ldr	r3, [r4, #0]
    size_t *capacity = out_vec[0].base;
 c03ad38:	6814      	ldr	r4, [r2, #0]

    /* Look up the corresponding operation context */
    status = tfm_crypto_operation_lookup(TFM_CRYPTO_KEY_DERIVATION_OPERATION,
 c03ad3a:	6919      	ldr	r1, [r3, #16]
 c03ad3c:	aa01      	add	r2, sp, #4
    psa_key_derivation_operation_t *operation = NULL;
 c03ad3e:	9501      	str	r5, [sp, #4]
    status = tfm_crypto_operation_lookup(TFM_CRYPTO_KEY_DERIVATION_OPERATION,
 c03ad40:	f7fe ff60 	bl	c039c04 <tfm_crypto_operation_lookup>
                                         handle,
                                         (void **)&operation);
    if (status != PSA_SUCCESS) {
 c03ad44:	b110      	cbz	r0, c03ad4c <tfm_crypto_key_derivation_get_capacity+0x3c>
        *capacity = 0;
 c03ad46:	6025      	str	r5, [r4, #0]
        return status;
    }

    return psa_key_derivation_get_capacity(operation, capacity);
#endif /* TFM_CRYPTO_KEY_DERIVATION_MODULE_DISABLED */
}
 c03ad48:	b003      	add	sp, #12
 c03ad4a:	bd30      	pop	{r4, r5, pc}
    return psa_key_derivation_get_capacity(operation, capacity);
 c03ad4c:	4621      	mov	r1, r4
 c03ad4e:	9801      	ldr	r0, [sp, #4]
 c03ad50:	f00b fd20 	bl	c046794 <mbedcrypto__psa_key_derivation_get_capacity>
 c03ad54:	e7f8      	b.n	c03ad48 <tfm_crypto_key_derivation_get_capacity+0x38>
    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 1, out_len, 1, 1);
 c03ad56:	f06f 0080 	mvn.w	r0, #128	@ 0x80
 c03ad5a:	e7f5      	b.n	c03ad48 <tfm_crypto_key_derivation_get_capacity+0x38>

0c03ad5c <tfm_crypto_key_derivation_set_capacity>:
#ifdef TFM_CRYPTO_KEY_DERIVATION_MODULE_DISABLED
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status;

    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 1, out_len, 0, 0);
 c03ad5c:	b24a      	sxtb	r2, r1
 c03ad5e:	2a00      	cmp	r2, #0
{
 c03ad60:	b513      	push	{r0, r1, r4, lr}
    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 1, out_len, 0, 0);
 c03ad62:	dd16      	ble.n	c03ad92 <tfm_crypto_key_derivation_set_capacity+0x36>
 c03ad64:	2901      	cmp	r1, #1
 c03ad66:	d114      	bne.n	c03ad92 <tfm_crypto_key_derivation_set_capacity+0x36>
 c03ad68:	061a      	lsls	r2, r3, #24
 c03ad6a:	d412      	bmi.n	c03ad92 <tfm_crypto_key_derivation_set_capacity+0x36>
 c03ad6c:	b98b      	cbnz	r3, c03ad92 <tfm_crypto_key_derivation_set_capacity+0x36>

    if ((in_vec[0].len != sizeof(struct tfm_crypto_pack_iovec))) {
 c03ad6e:	6842      	ldr	r2, [r0, #4]
 c03ad70:	2a2c      	cmp	r2, #44	@ 0x2c
 c03ad72:	d10e      	bne.n	c03ad92 <tfm_crypto_key_derivation_set_capacity+0x36>
        return PSA_ERROR_PROGRAMMER_ERROR;
    }
    const struct tfm_crypto_pack_iovec *iov = in_vec[0].base;
 c03ad74:	6801      	ldr	r1, [r0, #0]
    uint32_t handle = iov->op_handle;
    size_t capacity = iov->capacity;
    psa_key_derivation_operation_t *operation = NULL;

    /* Look up the corresponding operation context */
    status = tfm_crypto_operation_lookup(TFM_CRYPTO_KEY_DERIVATION_OPERATION,
 c03ad76:	aa01      	add	r2, sp, #4
    size_t capacity = iov->capacity;
 c03ad78:	694c      	ldr	r4, [r1, #20]
    status = tfm_crypto_operation_lookup(TFM_CRYPTO_KEY_DERIVATION_OPERATION,
 c03ad7a:	2004      	movs	r0, #4
 c03ad7c:	6909      	ldr	r1, [r1, #16]
    psa_key_derivation_operation_t *operation = NULL;
 c03ad7e:	9301      	str	r3, [sp, #4]
    status = tfm_crypto_operation_lookup(TFM_CRYPTO_KEY_DERIVATION_OPERATION,
 c03ad80:	f7fe ff40 	bl	c039c04 <tfm_crypto_operation_lookup>
                                         handle,
                                         (void **)&operation);
    if (status != PSA_SUCCESS) {
 c03ad84:	b918      	cbnz	r0, c03ad8e <tfm_crypto_key_derivation_set_capacity+0x32>
        return status;
    }

    return psa_key_derivation_set_capacity(operation, capacity);
 c03ad86:	4621      	mov	r1, r4
 c03ad88:	9801      	ldr	r0, [sp, #4]
 c03ad8a:	f00b fd0c 	bl	c0467a6 <mbedcrypto__psa_key_derivation_set_capacity>
#endif /* TFM_CRYPTO_KEY_DERIVATION_MODULE_DISABLED */
}
 c03ad8e:	b002      	add	sp, #8
 c03ad90:	bd10      	pop	{r4, pc}
    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 1, out_len, 0, 0);
 c03ad92:	f06f 0080 	mvn.w	r0, #128	@ 0x80
 c03ad96:	e7fa      	b.n	c03ad8e <tfm_crypto_key_derivation_set_capacity+0x32>

0c03ad98 <tfm_crypto_key_derivation_input_bytes>:
#ifdef TFM_CRYPTO_KEY_DERIVATION_MODULE_DISABLED
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status;

    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 2, out_len, 0, 0);
 c03ad98:	b24a      	sxtb	r2, r1
 c03ad9a:	2a00      	cmp	r2, #0
{
 c03ad9c:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 2, out_len, 0, 0);
 c03ada0:	dd49      	ble.n	c03ae36 <tfm_crypto_key_derivation_input_bytes+0x9e>
 c03ada2:	2902      	cmp	r1, #2
 c03ada4:	d847      	bhi.n	c03ae36 <tfm_crypto_key_derivation_input_bytes+0x9e>
 c03ada6:	061a      	lsls	r2, r3, #24
 c03ada8:	d445      	bmi.n	c03ae36 <tfm_crypto_key_derivation_input_bytes+0x9e>
 c03adaa:	2b00      	cmp	r3, #0
 c03adac:	d143      	bne.n	c03ae36 <tfm_crypto_key_derivation_input_bytes+0x9e>

    if ((in_vec[0].len != sizeof(struct tfm_crypto_pack_iovec))) {
 c03adae:	6842      	ldr	r2, [r0, #4]
 c03adb0:	2a2c      	cmp	r2, #44	@ 0x2c
 c03adb2:	d140      	bne.n	c03ae36 <tfm_crypto_key_derivation_input_bytes+0x9e>
    const struct tfm_crypto_pack_iovec *iov = in_vec[0].base;

    uint32_t handle = iov->op_handle;
    psa_key_derivation_step_t step = iov->step;
    const uint8_t *data = in_vec[1].base;
    size_t data_length = in_vec[1].len;
 c03adb4:	e9d0 6702 	ldrd	r6, r7, [r0, #8]
    const struct tfm_crypto_pack_iovec *iov = in_vec[0].base;
 c03adb8:	6801      	ldr	r1, [r0, #0]
    psa_key_derivation_operation_t *operation = NULL;

    /* Look up the corresponding operation context */
    status = tfm_crypto_operation_lookup(TFM_CRYPTO_KEY_DERIVATION_OPERATION,
 c03adba:	466a      	mov	r2, sp
    psa_key_derivation_step_t step = iov->step;
 c03adbc:	888d      	ldrh	r5, [r1, #4]
    status = tfm_crypto_operation_lookup(TFM_CRYPTO_KEY_DERIVATION_OPERATION,
 c03adbe:	2004      	movs	r0, #4
 c03adc0:	6909      	ldr	r1, [r1, #16]
    psa_key_derivation_operation_t *operation = NULL;
 c03adc2:	9300      	str	r3, [sp, #0]
    status = tfm_crypto_operation_lookup(TFM_CRYPTO_KEY_DERIVATION_OPERATION,
 c03adc4:	f7fe ff1e 	bl	c039c04 <tfm_crypto_operation_lookup>
                                         handle,
                                         (void **)&operation);
    if (status != PSA_SUCCESS) {
 c03adc8:	4604      	mov	r4, r0
 c03adca:	bb10      	cbnz	r0, c03ae12 <tfm_crypto_key_derivation_input_bytes+0x7a>
        return status;
    }

    if (operation->alg == TFM_CRYPTO_ALG_HUK_DERIVATION) {
 c03adcc:	f8dd 8000 	ldr.w	r8, [sp]
 c03add0:	4b1a      	ldr	r3, [pc, #104]	@ (c03ae3c <tfm_crypto_key_derivation_input_bytes+0xa4>)
 c03add2:	f8d8 2000 	ldr.w	r2, [r8]
 c03add6:	429a      	cmp	r2, r3
 c03add8:	d125      	bne.n	c03ae26 <tfm_crypto_key_derivation_input_bytes+0x8e>
    if (step != PSA_KEY_DERIVATION_INPUT_LABEL) {
 c03adda:	f240 2301 	movw	r3, #513	@ 0x201
 c03adde:	429d      	cmp	r5, r3
 c03ade0:	d11b      	bne.n	c03ae1a <tfm_crypto_key_derivation_input_bytes+0x82>
    status = tfm_crypto_get_caller_id(&partition_id);
 c03ade2:	a801      	add	r0, sp, #4
 c03ade4:	f7ff fb10 	bl	c03a408 <tfm_crypto_get_caller_id>
    if (status != PSA_SUCCESS) {
 c03ade8:	4604      	mov	r4, r0
 c03adea:	b990      	cbnz	r0, c03ae12 <tfm_crypto_key_derivation_input_bytes+0x7a>
    operation->ctx.tls12_prf.label = mbedtls_calloc(1, sizeof(partition_id)
 c03adec:	1d3d      	adds	r5, r7, #4
 c03adee:	4629      	mov	r1, r5
 c03adf0:	2001      	movs	r0, #1
 c03adf2:	f000 fad7 	bl	c03b3a4 <mbedtls_calloc>
 c03adf6:	f8c8 0024 	str.w	r0, [r8, #36]	@ 0x24
    if (operation->ctx.tls12_prf.label == NULL) {
 c03adfa:	b188      	cbz	r0, c03ae20 <tfm_crypto_key_derivation_input_bytes+0x88>
    return (memcpy(dest, src, num));
 c03adfc:	9b01      	ldr	r3, [sp, #4]
 c03adfe:	463a      	mov	r2, r7
 c03ae00:	6003      	str	r3, [r0, #0]
    (void)tfm_memcpy(operation->ctx.tls12_prf.label + sizeof(partition_id),
 c03ae02:	f8d8 0024 	ldr.w	r0, [r8, #36]	@ 0x24
 c03ae06:	4631      	mov	r1, r6
 c03ae08:	3004      	adds	r0, #4
 c03ae0a:	f020 fc1f 	bl	c05b64c <memcpy>
    operation->ctx.tls12_prf.label_length = sizeof(partition_id) + data_length;
 c03ae0e:	f8c8 5028 	str.w	r5, [r8, #40]	@ 0x28
    } else {
        return psa_key_derivation_input_bytes(operation, step, data,
                                              data_length);
    }
#endif /* TFM_CRYPTO_KEY_DERIVATION_MODULE_DISABLED */
}
 c03ae12:	4620      	mov	r0, r4
 c03ae14:	b002      	add	sp, #8
 c03ae16:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        return PSA_ERROR_INVALID_ARGUMENT;
 c03ae1a:	f06f 0486 	mvn.w	r4, #134	@ 0x86
 c03ae1e:	e7f8      	b.n	c03ae12 <tfm_crypto_key_derivation_input_bytes+0x7a>
        return PSA_ERROR_INSUFFICIENT_MEMORY;
 c03ae20:	f06f 048c 	mvn.w	r4, #140	@ 0x8c
        return tfm_crypto_huk_derivation_input_bytes(operation, step, data,
 c03ae24:	e7f5      	b.n	c03ae12 <tfm_crypto_key_derivation_input_bytes+0x7a>
        return psa_key_derivation_input_bytes(operation, step, data,
 c03ae26:	463b      	mov	r3, r7
 c03ae28:	4632      	mov	r2, r6
 c03ae2a:	4629      	mov	r1, r5
 c03ae2c:	4640      	mov	r0, r8
 c03ae2e:	f00b fe7a 	bl	c046b26 <mbedcrypto__psa_key_derivation_input_bytes>
 c03ae32:	4604      	mov	r4, r0
 c03ae34:	e7ed      	b.n	c03ae12 <tfm_crypto_key_derivation_input_bytes+0x7a>
    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 2, out_len, 0, 0);
 c03ae36:	f06f 0480 	mvn.w	r4, #128	@ 0x80
 c03ae3a:	e7ea      	b.n	c03ae12 <tfm_crypto_key_derivation_input_bytes+0x7a>
 c03ae3c:	b0000f00 	.word	0xb0000f00

0c03ae40 <tfm_crypto_key_derivation_output_bytes>:

psa_status_t tfm_crypto_key_derivation_output_bytes(psa_invec in_vec[],
                                                    size_t in_len,
                                                    psa_outvec out_vec[],
                                                    size_t out_len)
{
 c03ae40:	b537      	push	{r0, r1, r2, r4, r5, lr}
#ifdef TFM_CRYPTO_KEY_DERIVATION_MODULE_DISABLED
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status;

    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 1, out_len, 0, 1);
 c03ae42:	b24c      	sxtb	r4, r1
 c03ae44:	2c00      	cmp	r4, #0
 c03ae46:	dd1a      	ble.n	c03ae7e <tfm_crypto_key_derivation_output_bytes+0x3e>
 c03ae48:	2901      	cmp	r1, #1
 c03ae4a:	d118      	bne.n	c03ae7e <tfm_crypto_key_derivation_output_bytes+0x3e>
 c03ae4c:	0619      	lsls	r1, r3, #24
 c03ae4e:	d416      	bmi.n	c03ae7e <tfm_crypto_key_derivation_output_bytes+0x3e>
 c03ae50:	2b01      	cmp	r3, #1
 c03ae52:	d814      	bhi.n	c03ae7e <tfm_crypto_key_derivation_output_bytes+0x3e>

    if ((in_vec[0].len != sizeof(struct tfm_crypto_pack_iovec))) {
 c03ae54:	6843      	ldr	r3, [r0, #4]
 c03ae56:	2b2c      	cmp	r3, #44	@ 0x2c
 c03ae58:	d111      	bne.n	c03ae7e <tfm_crypto_key_derivation_output_bytes+0x3e>
    }
    const struct tfm_crypto_pack_iovec *iov = in_vec[0].base;

    uint32_t handle = iov->op_handle;
    uint8_t *output = out_vec[0].base;
    size_t output_length = out_vec[0].len;
 c03ae5a:	e9d2 4500 	ldrd	r4, r5, [r2]
    psa_key_derivation_operation_t *operation = NULL;
 c03ae5e:	2200      	movs	r2, #0
    uint32_t handle = iov->op_handle;
 c03ae60:	6803      	ldr	r3, [r0, #0]
    psa_key_derivation_operation_t *operation = NULL;
 c03ae62:	9201      	str	r2, [sp, #4]

    /* Look up the corresponding operation context */
    status = tfm_crypto_operation_lookup(TFM_CRYPTO_KEY_DERIVATION_OPERATION,
 c03ae64:	2004      	movs	r0, #4
 c03ae66:	6919      	ldr	r1, [r3, #16]
 c03ae68:	aa01      	add	r2, sp, #4
 c03ae6a:	f7fe fecb 	bl	c039c04 <tfm_crypto_operation_lookup>
                                         handle,
                                         (void **)&operation);
    if (status != PSA_SUCCESS) {
 c03ae6e:	b920      	cbnz	r0, c03ae7a <tfm_crypto_key_derivation_output_bytes+0x3a>
        return status;
    }

    return psa_key_derivation_output_bytes(operation, output, output_length);
 c03ae70:	462a      	mov	r2, r5
 c03ae72:	4621      	mov	r1, r4
 c03ae74:	9801      	ldr	r0, [sp, #4]
 c03ae76:	f00b fca5 	bl	c0467c4 <mbedcrypto__psa_key_derivation_output_bytes>
#endif /* TFM_CRYPTO_KEY_DERIVATION_MODULE_DISABLED */
}
 c03ae7a:	b003      	add	sp, #12
 c03ae7c:	bd30      	pop	{r4, r5, pc}
    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 1, out_len, 0, 1);
 c03ae7e:	f06f 0080 	mvn.w	r0, #128	@ 0x80
 c03ae82:	e7fa      	b.n	c03ae7a <tfm_crypto_key_derivation_output_bytes+0x3a>

0c03ae84 <tfm_crypto_key_derivation_input_key>:

psa_status_t tfm_crypto_key_derivation_input_key(psa_invec in_vec[],
                                                 size_t in_len,
                                                 psa_outvec out_vec[],
                                                 size_t out_len)
{
 c03ae84:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
 c03ae86:	460a      	mov	r2, r1
 c03ae88:	4619      	mov	r1, r3
#ifdef TFM_CRYPTO_KEY_DERIVATION_MODULE_DISABLED
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status;

    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 1, out_len, 0, 0);
 c03ae8a:	b253      	sxtb	r3, r2
 c03ae8c:	2b00      	cmp	r3, #0
 c03ae8e:	dd24      	ble.n	c03aeda <tfm_crypto_key_derivation_input_key+0x56>
 c03ae90:	2a01      	cmp	r2, #1
 c03ae92:	d122      	bne.n	c03aeda <tfm_crypto_key_derivation_input_key+0x56>
 c03ae94:	060b      	lsls	r3, r1, #24
 c03ae96:	d420      	bmi.n	c03aeda <tfm_crypto_key_derivation_input_key+0x56>
 c03ae98:	b9f9      	cbnz	r1, c03aeda <tfm_crypto_key_derivation_input_key+0x56>

    if ((in_vec[0].len != sizeof(struct tfm_crypto_pack_iovec))) {
 c03ae9a:	6843      	ldr	r3, [r0, #4]
 c03ae9c:	2b2c      	cmp	r3, #44	@ 0x2c
 c03ae9e:	d11c      	bne.n	c03aeda <tfm_crypto_key_derivation_input_key+0x56>
        return PSA_ERROR_PROGRAMMER_ERROR;
    }
    const struct tfm_crypto_pack_iovec *iov = in_vec[0].base;
 c03aea0:	6803      	ldr	r3, [r0, #0]
    uint32_t handle = iov->op_handle;
    psa_key_id_t key_id = iov->key_id;
    psa_key_derivation_step_t step = iov->step;
    psa_key_derivation_operation_t *operation = NULL;
 c03aea2:	9101      	str	r1, [sp, #4]
    psa_key_id_t key_id = iov->key_id;
 c03aea4:	689d      	ldr	r5, [r3, #8]
    uint32_t handle = iov->op_handle;
 c03aea6:	691c      	ldr	r4, [r3, #16]
    mbedtls_svc_key_id_t encoded_key;

    status = tfm_crypto_check_handle_owner(key_id, NULL);
 c03aea8:	4628      	mov	r0, r5
    psa_key_derivation_step_t step = iov->step;
 c03aeaa:	889e      	ldrh	r6, [r3, #4]
    status = tfm_crypto_check_handle_owner(key_id, NULL);
 c03aeac:	f7ff fbf0 	bl	c03a690 <tfm_crypto_check_handle_owner>
    if (status != PSA_SUCCESS) {
 c03aeb0:	b988      	cbnz	r0, c03aed6 <tfm_crypto_key_derivation_input_key+0x52>
        return status;
    }

    /* Look up the corresponding operation context */
    status = tfm_crypto_operation_lookup(TFM_CRYPTO_KEY_DERIVATION_OPERATION,
 c03aeb2:	4621      	mov	r1, r4
 c03aeb4:	2004      	movs	r0, #4
 c03aeb6:	aa01      	add	r2, sp, #4
 c03aeb8:	f7fe fea4 	bl	c039c04 <tfm_crypto_operation_lookup>
                                         handle,
                                         (void **)&operation);
    if (status != PSA_SUCCESS) {
 c03aebc:	b958      	cbnz	r0, c03aed6 <tfm_crypto_key_derivation_input_key+0x52>
        return status;
    }

    status = tfm_crypto_encode_id_and_owner(key_id, &encoded_key);
 c03aebe:	ac02      	add	r4, sp, #8
 c03aec0:	4621      	mov	r1, r4
 c03aec2:	4628      	mov	r0, r5
 c03aec4:	f7ff fc0c 	bl	c03a6e0 <tfm_crypto_encode_id_and_owner>
    if (status != PSA_SUCCESS) {
 c03aec8:	b928      	cbnz	r0, c03aed6 <tfm_crypto_key_derivation_input_key+0x52>
        return status;
    }

    return psa_key_derivation_input_key(operation, step, encoded_key);
 c03aeca:	e894 000c 	ldmia.w	r4, {r2, r3}
 c03aece:	4631      	mov	r1, r6
 c03aed0:	9801      	ldr	r0, [sp, #4]
 c03aed2:	f00b fe31 	bl	c046b38 <mbedcrypto__psa_key_derivation_input_key>
#endif /* TFM_CRYPTO_KEY_DERIVATION_MODULE_DISABLED */
}
 c03aed6:	b004      	add	sp, #16
 c03aed8:	bd70      	pop	{r4, r5, r6, pc}
    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 1, out_len, 0, 0);
 c03aeda:	f06f 0080 	mvn.w	r0, #128	@ 0x80
 c03aede:	e7fa      	b.n	c03aed6 <tfm_crypto_key_derivation_input_key+0x52>

0c03aee0 <tfm_crypto_key_derivation_output_key>:

psa_status_t tfm_crypto_key_derivation_output_key(psa_invec in_vec[],
                                                  size_t in_len,
                                                  psa_outvec out_vec[],
                                                  size_t out_len)
{
 c03aee0:	b5f0      	push	{r4, r5, r6, r7, lr}
#ifdef TFM_CRYPTO_KEY_DERIVATION_MODULE_DISABLED
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status;

    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 2, 2, out_len, 1, 1);
 c03aee2:	b24c      	sxtb	r4, r1
 c03aee4:	2c01      	cmp	r4, #1
{
 c03aee6:	b093      	sub	sp, #76	@ 0x4c
    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 2, 2, out_len, 1, 1);
 c03aee8:	dd45      	ble.n	c03af76 <tfm_crypto_key_derivation_output_key+0x96>
 c03aeea:	2902      	cmp	r1, #2
 c03aeec:	d143      	bne.n	c03af76 <tfm_crypto_key_derivation_output_key+0x96>
 c03aeee:	b259      	sxtb	r1, r3
 c03aef0:	2900      	cmp	r1, #0
 c03aef2:	dd40      	ble.n	c03af76 <tfm_crypto_key_derivation_output_key+0x96>
 c03aef4:	2b01      	cmp	r3, #1
 c03aef6:	d13e      	bne.n	c03af76 <tfm_crypto_key_derivation_output_key+0x96>

    if ((in_vec[0].len != sizeof(struct tfm_crypto_pack_iovec)) ||
 c03aef8:	6843      	ldr	r3, [r0, #4]
 c03aefa:	2b2c      	cmp	r3, #44	@ 0x2c
 c03aefc:	d13b      	bne.n	c03af76 <tfm_crypto_key_derivation_output_key+0x96>
 c03aefe:	68c3      	ldr	r3, [r0, #12]
 c03af00:	2b18      	cmp	r3, #24
 c03af02:	d138      	bne.n	c03af76 <tfm_crypto_key_derivation_output_key+0x96>
        (in_vec[1].len != sizeof(struct psa_client_key_attributes_s)) ||
 c03af04:	6855      	ldr	r5, [r2, #4]
 c03af06:	2d04      	cmp	r5, #4
 c03af08:	d135      	bne.n	c03af76 <tfm_crypto_key_derivation_output_key+0x96>
    }
    const struct tfm_crypto_pack_iovec *iov = in_vec[0].base;

    uint32_t handle = iov->op_handle;
    const struct psa_client_key_attributes_s *client_key_attr = in_vec[1].base;
    psa_key_derivation_operation_t *operation = NULL;
 c03af0a:	2100      	movs	r1, #0
    uint32_t handle = iov->op_handle;
 c03af0c:	6803      	ldr	r3, [r0, #0]
    const struct psa_client_key_attributes_s *client_key_attr = in_vec[1].base;
 c03af0e:	6886      	ldr	r6, [r0, #8]
    uint32_t handle = iov->op_handle;
 c03af10:	691f      	ldr	r7, [r3, #16]
    psa_key_id_t *key_handle = out_vec[0].base;
 c03af12:	6814      	ldr	r4, [r2, #0]
    psa_key_attributes_t key_attributes = PSA_KEY_ATTRIBUTES_INIT;
 c03af14:	a806      	add	r0, sp, #24
 c03af16:	2230      	movs	r2, #48	@ 0x30
    psa_key_derivation_operation_t *operation = NULL;
 c03af18:	9101      	str	r1, [sp, #4]
    psa_key_attributes_t key_attributes = PSA_KEY_ATTRIBUTES_INIT;
 c03af1a:	f020 fc08 	bl	c05b72e <memset>
    int32_t partition_id;
    uint32_t index;
    mbedtls_svc_key_id_t encoded_key;

    /* Look up the corresponding operation context */
    status = tfm_crypto_operation_lookup(TFM_CRYPTO_KEY_DERIVATION_OPERATION,
 c03af1e:	4639      	mov	r1, r7
 c03af20:	4628      	mov	r0, r5
 c03af22:	aa01      	add	r2, sp, #4
 c03af24:	f7fe fe6e 	bl	c039c04 <tfm_crypto_operation_lookup>
                                         handle,
                                         (void **)&operation);
    if (status != PSA_SUCCESS) {
 c03af28:	b9f0      	cbnz	r0, c03af68 <tfm_crypto_key_derivation_output_key+0x88>
        return status;
    }

    status = tfm_crypto_check_key_storage(&index);
 c03af2a:	a803      	add	r0, sp, #12
 c03af2c:	f7ff fbea 	bl	c03a704 <tfm_crypto_check_key_storage>
    if (status != PSA_SUCCESS) {
 c03af30:	b9d0      	cbnz	r0, c03af68 <tfm_crypto_key_derivation_output_key+0x88>
        return status;
    }

    status = tfm_crypto_get_caller_id(&partition_id);
 c03af32:	a802      	add	r0, sp, #8
 c03af34:	f7ff fa68 	bl	c03a408 <tfm_crypto_get_caller_id>
    if (status != PSA_SUCCESS) {
 c03af38:	b9b0      	cbnz	r0, c03af68 <tfm_crypto_key_derivation_output_key+0x88>
        return status;
    }

    status = tfm_crypto_key_attributes_from_client(client_key_attr,
 c03af3a:	4630      	mov	r0, r6
 c03af3c:	9902      	ldr	r1, [sp, #8]
 c03af3e:	aa06      	add	r2, sp, #24
 c03af40:	f7ff fb60 	bl	c03a604 <tfm_crypto_key_attributes_from_client>
                                                   partition_id,
                                                   &key_attributes);
    if (status != PSA_SUCCESS) {
 c03af44:	b980      	cbnz	r0, c03af68 <tfm_crypto_key_derivation_output_key+0x88>
        return status;
    }

    if (operation->alg == TFM_CRYPTO_ALG_HUK_DERIVATION) {
 c03af46:	9901      	ldr	r1, [sp, #4]
 c03af48:	4b0c      	ldr	r3, [pc, #48]	@ (c03af7c <tfm_crypto_key_derivation_output_key+0x9c>)
 c03af4a:	680a      	ldr	r2, [r1, #0]
 c03af4c:	429a      	cmp	r2, r3
 c03af4e:	d10d      	bne.n	c03af6c <tfm_crypto_key_derivation_output_key+0x8c>
    return psa_import_key(attributes, NULL,
 c03af50:	4602      	mov	r2, r0
 c03af52:	4601      	mov	r1, r0
 c03af54:	ab04      	add	r3, sp, #16
 c03af56:	a806      	add	r0, sp, #24
 c03af58:	f00a faca 	bl	c0454f0 <mbedcrypto__psa_import_key>
                                                      operation, &encoded_key);
    } else {
        status = psa_key_derivation_output_key(&key_attributes, operation,
                                               &encoded_key);
    }
    *key_handle = encoded_key.key_id;
 c03af5c:	9904      	ldr	r1, [sp, #16]
 c03af5e:	6021      	str	r1, [r4, #0]

    if (status == PSA_SUCCESS) {
 c03af60:	b910      	cbnz	r0, c03af68 <tfm_crypto_key_derivation_output_key+0x88>
        status = tfm_crypto_set_key_storage(index, *key_handle);
 c03af62:	9803      	ldr	r0, [sp, #12]
 c03af64:	f7ff fbe0 	bl	c03a728 <tfm_crypto_set_key_storage>
    }

    return status;
#endif /* TFM_CRYPTO_KEY_DERIVATION_MODULE_DISABLED */
}
 c03af68:	b013      	add	sp, #76	@ 0x4c
 c03af6a:	bdf0      	pop	{r4, r5, r6, r7, pc}
        status = psa_key_derivation_output_key(&key_attributes, operation,
 c03af6c:	aa04      	add	r2, sp, #16
 c03af6e:	a806      	add	r0, sp, #24
 c03af70:	f00b fd36 	bl	c0469e0 <mbedcrypto__psa_key_derivation_output_key>
 c03af74:	e7f2      	b.n	c03af5c <tfm_crypto_key_derivation_output_key+0x7c>
    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 2, 2, out_len, 1, 1);
 c03af76:	f06f 0080 	mvn.w	r0, #128	@ 0x80
 c03af7a:	e7f5      	b.n	c03af68 <tfm_crypto_key_derivation_output_key+0x88>
 c03af7c:	b0000f00 	.word	0xb0000f00

0c03af80 <tfm_crypto_key_derivation_abort>:

psa_status_t tfm_crypto_key_derivation_abort(psa_invec in_vec[],
                                             size_t in_len,
                                             psa_outvec out_vec[],
                                             size_t out_len)
{
 c03af80:	b573      	push	{r0, r1, r4, r5, r6, lr}
 c03af82:	4604      	mov	r4, r0
#ifdef TFM_CRYPTO_KEY_DERIVATION_MODULE_DISABLED
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status;

    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 1, out_len, 1, 1);
 c03af84:	b248      	sxtb	r0, r1
 c03af86:	2800      	cmp	r0, #0
 c03af88:	dd3d      	ble.n	c03b006 <tfm_crypto_key_derivation_abort+0x86>
 c03af8a:	2901      	cmp	r1, #1
 c03af8c:	d13b      	bne.n	c03b006 <tfm_crypto_key_derivation_abort+0x86>
 c03af8e:	b259      	sxtb	r1, r3
 c03af90:	2900      	cmp	r1, #0
 c03af92:	dd38      	ble.n	c03b006 <tfm_crypto_key_derivation_abort+0x86>
 c03af94:	2b01      	cmp	r3, #1
 c03af96:	d136      	bne.n	c03b006 <tfm_crypto_key_derivation_abort+0x86>

    if ((in_vec[0].len != sizeof(struct tfm_crypto_pack_iovec)) ||
 c03af98:	6863      	ldr	r3, [r4, #4]
 c03af9a:	2b2c      	cmp	r3, #44	@ 0x2c
 c03af9c:	d133      	bne.n	c03b006 <tfm_crypto_key_derivation_abort+0x86>
 c03af9e:	6850      	ldr	r0, [r2, #4]
 c03afa0:	2804      	cmp	r0, #4
 c03afa2:	d130      	bne.n	c03b006 <tfm_crypto_key_derivation_abort+0x86>
        (out_vec[0].len != sizeof(uint32_t))) {
        return PSA_ERROR_PROGRAMMER_ERROR;
    }
    const struct tfm_crypto_pack_iovec *iov = in_vec[0].base;

    uint32_t handle = iov->op_handle;
 c03afa4:	6823      	ldr	r3, [r4, #0]
    uint32_t *handle_out = out_vec[0].base;
    psa_key_derivation_operation_t *operation = NULL;
 c03afa6:	2400      	movs	r4, #0
    uint32_t handle = iov->op_handle;
 c03afa8:	691e      	ldr	r6, [r3, #16]
    uint32_t *handle_out = out_vec[0].base;
 c03afaa:	6815      	ldr	r5, [r2, #0]

    /* Init the handle in the operation with the one passed from the iov */
    *handle_out = iov->op_handle;

    /* Look up the corresponding operation context */
    status = tfm_crypto_operation_lookup(TFM_CRYPTO_KEY_DERIVATION_OPERATION,
 c03afac:	4631      	mov	r1, r6
    psa_key_derivation_operation_t *operation = NULL;
 c03afae:	9401      	str	r4, [sp, #4]
    status = tfm_crypto_operation_lookup(TFM_CRYPTO_KEY_DERIVATION_OPERATION,
 c03afb0:	aa01      	add	r2, sp, #4
    *handle_out = iov->op_handle;
 c03afb2:	602e      	str	r6, [r5, #0]
    status = tfm_crypto_operation_lookup(TFM_CRYPTO_KEY_DERIVATION_OPERATION,
 c03afb4:	f7fe fe26 	bl	c039c04 <tfm_crypto_operation_lookup>
                                         handle,
                                         (void **)&operation);
    if (status != PSA_SUCCESS) {
 c03afb8:	4601      	mov	r1, r0
 c03afba:	bb08      	cbnz	r0, c03b000 <tfm_crypto_key_derivation_abort+0x80>
        return PSA_SUCCESS;
    }

    *handle_out = handle;

    if (operation->alg == TFM_CRYPTO_ALG_HUK_DERIVATION) {
 c03afbc:	9c01      	ldr	r4, [sp, #4]
    *handle_out = handle;
 c03afbe:	602e      	str	r6, [r5, #0]
    if (operation->alg == TFM_CRYPTO_ALG_HUK_DERIVATION) {
 c03afc0:	6822      	ldr	r2, [r4, #0]
 c03afc2:	4b12      	ldr	r3, [pc, #72]	@ (c03b00c <tfm_crypto_key_derivation_abort+0x8c>)
 c03afc4:	429a      	cmp	r2, r3
 c03afc6:	d112      	bne.n	c03afee <tfm_crypto_key_derivation_abort+0x6e>
    if (operation->ctx.tls12_prf.label != NULL) {
 c03afc8:	6a60      	ldr	r0, [r4, #36]	@ 0x24
 c03afca:	b128      	cbz	r0, c03afd8 <tfm_crypto_key_derivation_abort+0x58>
    return (memset(ptr, value, num));
 c03afcc:	6aa2      	ldr	r2, [r4, #40]	@ 0x28
 c03afce:	f020 fbae 	bl	c05b72e <memset>
        mbedtls_free(operation->ctx.tls12_prf.label);
 c03afd2:	6a60      	ldr	r0, [r4, #36]	@ 0x24
 c03afd4:	f000 f9ec 	bl	c03b3b0 <mbedtls_free>
 c03afd8:	f44f 7230 	mov.w	r2, #704	@ 0x2c0
 c03afdc:	2100      	movs	r1, #0
 c03afde:	4620      	mov	r0, r4
 c03afe0:	f020 fba5 	bl	c05b72e <memset>
        /* Release the operation context, ignore if the operation fails. */
        (void)tfm_crypto_operation_release(handle_out);
        return status;
    }

    status = tfm_crypto_operation_release(handle_out);
 c03afe4:	4628      	mov	r0, r5
 c03afe6:	f7fe fdd3 	bl	c039b90 <tfm_crypto_operation_release>
 c03afea:	4604      	mov	r4, r0

    return status;
 c03afec:	e008      	b.n	c03b000 <tfm_crypto_key_derivation_abort+0x80>
        status = psa_key_derivation_abort(operation);
 c03afee:	4620      	mov	r0, r4
 c03aff0:	f00b faae 	bl	c046550 <mbedcrypto__psa_key_derivation_abort>
    if (status != PSA_SUCCESS) {
 c03aff4:	4604      	mov	r4, r0
 c03aff6:	2800      	cmp	r0, #0
 c03aff8:	d0f4      	beq.n	c03afe4 <tfm_crypto_key_derivation_abort+0x64>
        (void)tfm_crypto_operation_release(handle_out);
 c03affa:	4628      	mov	r0, r5
 c03affc:	f7fe fdc8 	bl	c039b90 <tfm_crypto_operation_release>
#endif /* TFM_CRYPTO_KEY_DERIVATION_MODULE_DISABLED */
}
 c03b000:	4620      	mov	r0, r4
 c03b002:	b002      	add	sp, #8
 c03b004:	bd70      	pop	{r4, r5, r6, pc}
    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 1, out_len, 1, 1);
 c03b006:	f06f 0480 	mvn.w	r4, #128	@ 0x80
 c03b00a:	e7f9      	b.n	c03b000 <tfm_crypto_key_derivation_abort+0x80>
 c03b00c:	b0000f00 	.word	0xb0000f00

0c03b010 <tfm_crypto_key_derivation_key_agreement>:

psa_status_t tfm_crypto_key_derivation_key_agreement(psa_invec in_vec[],
                                                     size_t in_len,
                                                     psa_outvec out_vec[],
                                                     size_t out_len)
{
 c03b010:	460a      	mov	r2, r1
 c03b012:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 c03b016:	4619      	mov	r1, r3
#ifdef TFM_CRYPTO_KEY_DERIVATION_MODULE_DISABLED
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status;

    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 2, out_len, 0, 0);
 c03b018:	b253      	sxtb	r3, r2
 c03b01a:	2b00      	cmp	r3, #0
{
 c03b01c:	b086      	sub	sp, #24
    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 2, out_len, 0, 0);
 c03b01e:	dd2b      	ble.n	c03b078 <tfm_crypto_key_derivation_key_agreement+0x68>
 c03b020:	2a02      	cmp	r2, #2
 c03b022:	d829      	bhi.n	c03b078 <tfm_crypto_key_derivation_key_agreement+0x68>
 c03b024:	060b      	lsls	r3, r1, #24
 c03b026:	d427      	bmi.n	c03b078 <tfm_crypto_key_derivation_key_agreement+0x68>
 c03b028:	bb31      	cbnz	r1, c03b078 <tfm_crypto_key_derivation_key_agreement+0x68>

    if ((in_vec[0].len != sizeof(struct tfm_crypto_pack_iovec))) {
 c03b02a:	6843      	ldr	r3, [r0, #4]
 c03b02c:	2b2c      	cmp	r3, #44	@ 0x2c
 c03b02e:	d123      	bne.n	c03b078 <tfm_crypto_key_derivation_key_agreement+0x68>
    const struct tfm_crypto_pack_iovec *iov = in_vec[0].base;

    uint32_t handle = iov->op_handle;
    psa_key_id_t private_key = iov->key_id;
    const uint8_t *peer_key = in_vec[1].base;
    size_t peer_key_length = in_vec[1].len;
 c03b030:	e9d0 5602 	ldrd	r5, r6, [r0, #8]
    const struct tfm_crypto_pack_iovec *iov = in_vec[0].base;
 c03b034:	6803      	ldr	r3, [r0, #0]
    psa_key_derivation_operation_t *operation = NULL;
 c03b036:	9103      	str	r1, [sp, #12]
    psa_key_id_t private_key = iov->key_id;
 c03b038:	689f      	ldr	r7, [r3, #8]
    uint32_t handle = iov->op_handle;
 c03b03a:	f8d3 8010 	ldr.w	r8, [r3, #16]
    psa_key_derivation_step_t step = iov->step;
    mbedtls_svc_key_id_t encoded_key;

    status = tfm_crypto_check_handle_owner(private_key, NULL);
 c03b03e:	4638      	mov	r0, r7
    psa_key_derivation_step_t step = iov->step;
 c03b040:	889c      	ldrh	r4, [r3, #4]
    status = tfm_crypto_check_handle_owner(private_key, NULL);
 c03b042:	f7ff fb25 	bl	c03a690 <tfm_crypto_check_handle_owner>
    if (status != PSA_SUCCESS) {
 c03b046:	b9a0      	cbnz	r0, c03b072 <tfm_crypto_key_derivation_key_agreement+0x62>
        return status;
    }

    /* Look up the corresponding operation context */
    status = tfm_crypto_operation_lookup(TFM_CRYPTO_KEY_DERIVATION_OPERATION,
 c03b048:	4641      	mov	r1, r8
 c03b04a:	2004      	movs	r0, #4
 c03b04c:	aa03      	add	r2, sp, #12
 c03b04e:	f7fe fdd9 	bl	c039c04 <tfm_crypto_operation_lookup>
                                         handle,
                                         (void **)&operation);
    if (status != PSA_SUCCESS) {
 c03b052:	b970      	cbnz	r0, c03b072 <tfm_crypto_key_derivation_key_agreement+0x62>
        return status;
    }

    status = tfm_crypto_encode_id_and_owner(private_key, &encoded_key);
 c03b054:	f10d 0810 	add.w	r8, sp, #16
 c03b058:	4641      	mov	r1, r8
 c03b05a:	4638      	mov	r0, r7
 c03b05c:	f7ff fb40 	bl	c03a6e0 <tfm_crypto_encode_id_and_owner>
    if (status != PSA_SUCCESS) {
 c03b060:	b938      	cbnz	r0, c03b072 <tfm_crypto_key_derivation_key_agreement+0x62>
        return status;
    }

    return psa_key_derivation_key_agreement(operation, step,
 c03b062:	e9cd 5600 	strd	r5, r6, [sp]
 c03b066:	4621      	mov	r1, r4
 c03b068:	e898 000c 	ldmia.w	r8, {r2, r3}
 c03b06c:	9803      	ldr	r0, [sp, #12]
 c03b06e:	f00b fd95 	bl	c046b9c <mbedcrypto__psa_key_derivation_key_agreement>
                                            encoded_key,
                                            peer_key,
                                            peer_key_length);
#endif /* TFM_CRYPTO_KEY_DERIVATION_MODULE_DISABLED */
}
 c03b072:	b006      	add	sp, #24
 c03b074:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 2, out_len, 0, 0);
 c03b078:	f06f 0080 	mvn.w	r0, #128	@ 0x80
 c03b07c:	e7f9      	b.n	c03b072 <tfm_crypto_key_derivation_key_agreement+0x62>

0c03b07e <tfm_crypto_generate_random>:

psa_status_t tfm_crypto_generate_random(psa_invec in_vec[],
                                        size_t in_len,
                                        psa_outvec out_vec[],
                                        size_t out_len)
{
 c03b07e:	b410      	push	{r4}
#ifdef TFM_CRYPTO_KEY_DERIVATION_MODULE_DISABLED
    return PSA_ERROR_NOT_SUPPORTED;
#else

    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 1, out_len, 0, 1);
 c03b080:	b24c      	sxtb	r4, r1
 c03b082:	2c00      	cmp	r4, #0
 c03b084:	dd0d      	ble.n	c03b0a2 <tfm_crypto_generate_random+0x24>
 c03b086:	2901      	cmp	r1, #1
 c03b088:	d10b      	bne.n	c03b0a2 <tfm_crypto_generate_random+0x24>
 c03b08a:	0619      	lsls	r1, r3, #24
 c03b08c:	d409      	bmi.n	c03b0a2 <tfm_crypto_generate_random+0x24>
 c03b08e:	2b01      	cmp	r3, #1
 c03b090:	d807      	bhi.n	c03b0a2 <tfm_crypto_generate_random+0x24>

    if (in_vec[0].len != sizeof(struct tfm_crypto_pack_iovec)) {
 c03b092:	6843      	ldr	r3, [r0, #4]
 c03b094:	2b2c      	cmp	r3, #44	@ 0x2c
 c03b096:	d104      	bne.n	c03b0a2 <tfm_crypto_generate_random+0x24>
        return PSA_ERROR_PROGRAMMER_ERROR;
    }
    uint8_t *output = out_vec[0].base;
    size_t output_size = out_vec[0].len;

    return psa_generate_random(output, output_size);
 c03b098:	e9d2 0100 	ldrd	r0, r1, [r2]
#endif /* TFM_CRYPTO_KEY_DERIVATION_MODULE_DISABLED */
}
 c03b09c:	bc10      	pop	{r4}
    return psa_generate_random(output, output_size);
 c03b09e:	f00b bdcd 	b.w	c046c3c <mbedcrypto__psa_generate_random>
}
 c03b0a2:	f06f 0080 	mvn.w	r0, #128	@ 0x80
 c03b0a6:	bc10      	pop	{r4}
 c03b0a8:	4770      	bx	lr

0c03b0aa <tfm_crypto_raw_key_agreement>:

psa_status_t tfm_crypto_raw_key_agreement(psa_invec in_vec[],
                                          size_t in_len,
                                          psa_outvec out_vec[],
                                          size_t out_len)
{
 c03b0aa:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c03b0ae:	4691      	mov	r9, r2
#ifdef TFM_CRYPTO_KEY_DERIVATION_MODULE_DISABLED
    return PSA_ERROR_NOT_SUPPORTED;
#else

    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 2, out_len, 0, 1);
 c03b0b0:	b24a      	sxtb	r2, r1
 c03b0b2:	2a00      	cmp	r2, #0
{
 c03b0b4:	b087      	sub	sp, #28
    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 2, out_len, 0, 1);
 c03b0b6:	dd2a      	ble.n	c03b10e <tfm_crypto_raw_key_agreement+0x64>
 c03b0b8:	2902      	cmp	r1, #2
 c03b0ba:	d828      	bhi.n	c03b10e <tfm_crypto_raw_key_agreement+0x64>
 c03b0bc:	061a      	lsls	r2, r3, #24
 c03b0be:	d426      	bmi.n	c03b10e <tfm_crypto_raw_key_agreement+0x64>
 c03b0c0:	2b01      	cmp	r3, #1
 c03b0c2:	d824      	bhi.n	c03b10e <tfm_crypto_raw_key_agreement+0x64>

    if (in_vec[0].len != sizeof(struct tfm_crypto_pack_iovec)) {
 c03b0c4:	6843      	ldr	r3, [r0, #4]
 c03b0c6:	2b2c      	cmp	r3, #44	@ 0x2c
 c03b0c8:	d121      	bne.n	c03b10e <tfm_crypto_raw_key_agreement+0x64>
    uint8_t *output = out_vec[0].base;
    size_t output_size = out_vec[0].len;
    psa_algorithm_t alg = iov->alg;
    psa_key_id_t private_key = iov->key_id;
    const uint8_t *peer_key = in_vec[1].base;
    size_t peer_key_length = in_vec[1].len;
 c03b0ca:	e9d0 5602 	ldrd	r5, r6, [r0, #8]
    size_t output_size = out_vec[0].len;
 c03b0ce:	e9d9 7800 	ldrd	r7, r8, [r9]
    const struct tfm_crypto_pack_iovec *iov = in_vec[0].base;
 c03b0d2:	6803      	ldr	r3, [r0, #0]
    mbedtls_svc_key_id_t encoded_key;

    psa_status_t status = tfm_crypto_check_handle_owner(private_key, NULL);
 c03b0d4:	2100      	movs	r1, #0
    psa_key_id_t private_key = iov->key_id;
 c03b0d6:	e9d3 a402 	ldrd	sl, r4, [r3, #8]
    psa_status_t status = tfm_crypto_check_handle_owner(private_key, NULL);
 c03b0da:	4650      	mov	r0, sl
 c03b0dc:	f7ff fad8 	bl	c03a690 <tfm_crypto_check_handle_owner>

    if (status != PSA_SUCCESS) {
 c03b0e0:	b990      	cbnz	r0, c03b108 <tfm_crypto_raw_key_agreement+0x5e>
        return status;
    }

    status = tfm_crypto_encode_id_and_owner(private_key, &encoded_key);
 c03b0e2:	f10d 0b10 	add.w	fp, sp, #16
 c03b0e6:	4659      	mov	r1, fp
 c03b0e8:	4650      	mov	r0, sl
 c03b0ea:	f7ff faf9 	bl	c03a6e0 <tfm_crypto_encode_id_and_owner>
    if (status != PSA_SUCCESS) {
 c03b0ee:	b958      	cbnz	r0, c03b108 <tfm_crypto_raw_key_agreement+0x5e>
        return status;
    }

    return psa_raw_key_agreement(alg, encoded_key, peer_key, peer_key_length,
 c03b0f0:	f109 0304 	add.w	r3, r9, #4
 c03b0f4:	e9cd 8302 	strd	r8, r3, [sp, #8]
 c03b0f8:	e9cd 6700 	strd	r6, r7, [sp]
 c03b0fc:	462b      	mov	r3, r5
 c03b0fe:	e89b 0006 	ldmia.w	fp, {r1, r2}
 c03b102:	4620      	mov	r0, r4
 c03b104:	f00b fdf8 	bl	c046cf8 <mbedcrypto__psa_raw_key_agreement>
                                 output, output_size, &out_vec[0].len);
#endif /* TFM_CRYPTO_KEY_DERIVATION_MODULE_DISABLED */
}
 c03b108:	b007      	add	sp, #28
 c03b10a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 2, out_len, 0, 1);
 c03b10e:	f06f 0080 	mvn.w	r0, #128	@ 0x80
 c03b112:	e7f9      	b.n	c03b108 <tfm_crypto_raw_key_agreement+0x5e>

0c03b114 <tfm_crypto_mac_sign_setup>:
/*!@{*/
psa_status_t tfm_crypto_mac_sign_setup(psa_invec in_vec[],
                                       size_t in_len,
                                       psa_outvec out_vec[],
                                       size_t out_len)
{
 c03b114:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
 c03b118:	460c      	mov	r4, r1
#ifdef TFM_CRYPTO_MAC_MODULE_DISABLED
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status = PSA_SUCCESS;
    psa_mac_operation_t *operation = NULL;
 c03b11a:	2100      	movs	r1, #0

    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 1, out_len, 1, 1);
 c03b11c:	b265      	sxtb	r5, r4
 c03b11e:	428d      	cmp	r5, r1
    psa_mac_operation_t *operation = NULL;
 c03b120:	9100      	str	r1, [sp, #0]
    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 1, out_len, 1, 1);
 c03b122:	dd38      	ble.n	c03b196 <tfm_crypto_mac_sign_setup+0x82>
 c03b124:	2c01      	cmp	r4, #1
 c03b126:	d136      	bne.n	c03b196 <tfm_crypto_mac_sign_setup+0x82>
 c03b128:	b25c      	sxtb	r4, r3
 c03b12a:	428c      	cmp	r4, r1
 c03b12c:	dd33      	ble.n	c03b196 <tfm_crypto_mac_sign_setup+0x82>
 c03b12e:	2b01      	cmp	r3, #1
 c03b130:	d131      	bne.n	c03b196 <tfm_crypto_mac_sign_setup+0x82>

    if ((out_vec[0].len != sizeof(uint32_t)) ||
 c03b132:	6853      	ldr	r3, [r2, #4]
 c03b134:	2b04      	cmp	r3, #4
 c03b136:	d12e      	bne.n	c03b196 <tfm_crypto_mac_sign_setup+0x82>
 c03b138:	6843      	ldr	r3, [r0, #4]
 c03b13a:	2b2c      	cmp	r3, #44	@ 0x2c
 c03b13c:	d12b      	bne.n	c03b196 <tfm_crypto_mac_sign_setup+0x82>
        (in_vec[0].len != sizeof(struct tfm_crypto_pack_iovec))) {
        return PSA_ERROR_PROGRAMMER_ERROR;
    }
    const struct tfm_crypto_pack_iovec *iov = in_vec[0].base;
 c03b13e:	6805      	ldr	r5, [r0, #0]
    uint32_t handle = iov->op_handle;
    uint32_t *handle_out = out_vec[0].base;
 c03b140:	6816      	ldr	r6, [r2, #0]
    uint32_t handle = iov->op_handle;
 c03b142:	692b      	ldr	r3, [r5, #16]
    psa_key_id_t key_id = iov->key_id;
    psa_algorithm_t alg = iov->alg;
 c03b144:	e9d5 8702 	ldrd	r8, r7, [r5, #8]
    mbedtls_svc_key_id_t encoded_key;

    status = tfm_crypto_check_handle_owner(key_id, NULL);
 c03b148:	4640      	mov	r0, r8
    uint32_t handle = iov->op_handle;
 c03b14a:	9301      	str	r3, [sp, #4]
    status = tfm_crypto_check_handle_owner(key_id, NULL);
 c03b14c:	f7ff faa0 	bl	c03a690 <tfm_crypto_check_handle_owner>
    if (status != PSA_SUCCESS) {
 c03b150:	4604      	mov	r4, r0
 c03b152:	b9e0      	cbnz	r0, c03b18e <tfm_crypto_mac_sign_setup+0x7a>
        return status;
    }

    /* Init the handle in the operation with the one passed from the iov */
    *handle_out = iov->op_handle;
 c03b154:	692b      	ldr	r3, [r5, #16]

    /* Allocate the operation context in the secure world */
    status = tfm_crypto_operation_alloc(TFM_CRYPTO_MAC_OPERATION,
 c03b156:	466a      	mov	r2, sp
 c03b158:	2002      	movs	r0, #2
    *handle_out = iov->op_handle;
 c03b15a:	6033      	str	r3, [r6, #0]
    status = tfm_crypto_operation_alloc(TFM_CRYPTO_MAC_OPERATION,
 c03b15c:	a901      	add	r1, sp, #4
 c03b15e:	f7fe fce3 	bl	c039b28 <tfm_crypto_operation_alloc>
                                        &handle,
                                        (void **)&operation);
    if (status != PSA_SUCCESS) {
 c03b162:	4604      	mov	r4, r0
 c03b164:	b998      	cbnz	r0, c03b18e <tfm_crypto_mac_sign_setup+0x7a>
        return status;
    }

    *handle_out = handle;
 c03b166:	9b01      	ldr	r3, [sp, #4]

    status = tfm_crypto_encode_id_and_owner(key_id, &encoded_key);
 c03b168:	ad02      	add	r5, sp, #8
 c03b16a:	4629      	mov	r1, r5
 c03b16c:	4640      	mov	r0, r8
    *handle_out = handle;
 c03b16e:	6033      	str	r3, [r6, #0]
    status = tfm_crypto_encode_id_and_owner(key_id, &encoded_key);
 c03b170:	f7ff fab6 	bl	c03a6e0 <tfm_crypto_encode_id_and_owner>
    if (status != PSA_SUCCESS) {
 c03b174:	4604      	mov	r4, r0
 c03b176:	b938      	cbnz	r0, c03b188 <tfm_crypto_mac_sign_setup+0x74>
        goto exit;
    }

    status = psa_mac_sign_setup(operation, encoded_key, alg);
 c03b178:	e895 0006 	ldmia.w	r5, {r1, r2}
 c03b17c:	463b      	mov	r3, r7
 c03b17e:	9800      	ldr	r0, [sp, #0]
 c03b180:	f00a fc50 	bl	c045a24 <mbedcrypto__psa_mac_sign_setup>
    if (status != PSA_SUCCESS) {
 c03b184:	4604      	mov	r4, r0
 c03b186:	b110      	cbz	r0, c03b18e <tfm_crypto_mac_sign_setup+0x7a>

    return status;

exit:
    /* Release the operation context, ignore if the operation fails. */
    (void)tfm_crypto_operation_release(handle_out);
 c03b188:	4630      	mov	r0, r6
 c03b18a:	f7fe fd01 	bl	c039b90 <tfm_crypto_operation_release>
    return status;
#endif /* TFM_CRYPTO_MAC_MODULE_DISABLED */
}
 c03b18e:	4620      	mov	r0, r4
 c03b190:	b004      	add	sp, #16
 c03b192:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 1, out_len, 1, 1);
 c03b196:	f06f 0480 	mvn.w	r4, #128	@ 0x80
 c03b19a:	e7f8      	b.n	c03b18e <tfm_crypto_mac_sign_setup+0x7a>

0c03b19c <tfm_crypto_mac_verify_setup>:

psa_status_t tfm_crypto_mac_verify_setup(psa_invec in_vec[],
                                         size_t in_len,
                                         psa_outvec out_vec[],
                                         size_t out_len)
{
 c03b19c:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
 c03b1a0:	460c      	mov	r4, r1
#ifdef TFM_CRYPTO_MAC_MODULE_DISABLED
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status = PSA_SUCCESS;
    psa_mac_operation_t *operation = NULL;
 c03b1a2:	2100      	movs	r1, #0

    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 1, out_len, 1, 1);
 c03b1a4:	b265      	sxtb	r5, r4
 c03b1a6:	428d      	cmp	r5, r1
    psa_mac_operation_t *operation = NULL;
 c03b1a8:	9100      	str	r1, [sp, #0]
    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 1, out_len, 1, 1);
 c03b1aa:	dd38      	ble.n	c03b21e <tfm_crypto_mac_verify_setup+0x82>
 c03b1ac:	2c01      	cmp	r4, #1
 c03b1ae:	d136      	bne.n	c03b21e <tfm_crypto_mac_verify_setup+0x82>
 c03b1b0:	b25c      	sxtb	r4, r3
 c03b1b2:	428c      	cmp	r4, r1
 c03b1b4:	dd33      	ble.n	c03b21e <tfm_crypto_mac_verify_setup+0x82>
 c03b1b6:	2b01      	cmp	r3, #1
 c03b1b8:	d131      	bne.n	c03b21e <tfm_crypto_mac_verify_setup+0x82>

    if ((out_vec[0].len != sizeof(uint32_t)) ||
 c03b1ba:	6853      	ldr	r3, [r2, #4]
 c03b1bc:	2b04      	cmp	r3, #4
 c03b1be:	d12e      	bne.n	c03b21e <tfm_crypto_mac_verify_setup+0x82>
 c03b1c0:	6843      	ldr	r3, [r0, #4]
 c03b1c2:	2b2c      	cmp	r3, #44	@ 0x2c
 c03b1c4:	d12b      	bne.n	c03b21e <tfm_crypto_mac_verify_setup+0x82>
        (in_vec[0].len != sizeof(struct tfm_crypto_pack_iovec))) {
        return PSA_ERROR_PROGRAMMER_ERROR;
    }
    const struct tfm_crypto_pack_iovec *iov = in_vec[0].base;
 c03b1c6:	6805      	ldr	r5, [r0, #0]
    uint32_t handle = iov->op_handle;
    uint32_t *handle_out = out_vec[0].base;
 c03b1c8:	6816      	ldr	r6, [r2, #0]
    uint32_t handle = iov->op_handle;
 c03b1ca:	692b      	ldr	r3, [r5, #16]
    psa_key_id_t key_id = iov->key_id;
    psa_algorithm_t alg = iov->alg;
 c03b1cc:	e9d5 8702 	ldrd	r8, r7, [r5, #8]
    mbedtls_svc_key_id_t encoded_key;

    status = tfm_crypto_check_handle_owner(key_id, NULL);
 c03b1d0:	4640      	mov	r0, r8
    uint32_t handle = iov->op_handle;
 c03b1d2:	9301      	str	r3, [sp, #4]
    status = tfm_crypto_check_handle_owner(key_id, NULL);
 c03b1d4:	f7ff fa5c 	bl	c03a690 <tfm_crypto_check_handle_owner>
    if (status != PSA_SUCCESS) {
 c03b1d8:	4604      	mov	r4, r0
 c03b1da:	b9e0      	cbnz	r0, c03b216 <tfm_crypto_mac_verify_setup+0x7a>
        return status;
    }

    /* Init the handle in the operation with the one passed from the iov */
    *handle_out = iov->op_handle;
 c03b1dc:	692b      	ldr	r3, [r5, #16]

    /* Allocate the operation context in the secure world */
    status = tfm_crypto_operation_alloc(TFM_CRYPTO_MAC_OPERATION,
 c03b1de:	466a      	mov	r2, sp
 c03b1e0:	2002      	movs	r0, #2
    *handle_out = iov->op_handle;
 c03b1e2:	6033      	str	r3, [r6, #0]
    status = tfm_crypto_operation_alloc(TFM_CRYPTO_MAC_OPERATION,
 c03b1e4:	a901      	add	r1, sp, #4
 c03b1e6:	f7fe fc9f 	bl	c039b28 <tfm_crypto_operation_alloc>
                                        &handle,
                                        (void **)&operation);
    if (status != PSA_SUCCESS) {
 c03b1ea:	4604      	mov	r4, r0
 c03b1ec:	b998      	cbnz	r0, c03b216 <tfm_crypto_mac_verify_setup+0x7a>
        return status;
    }

    *handle_out = handle;
 c03b1ee:	9b01      	ldr	r3, [sp, #4]

    status = tfm_crypto_encode_id_and_owner(key_id, &encoded_key);
 c03b1f0:	ad02      	add	r5, sp, #8
 c03b1f2:	4629      	mov	r1, r5
 c03b1f4:	4640      	mov	r0, r8
    *handle_out = handle;
 c03b1f6:	6033      	str	r3, [r6, #0]
    status = tfm_crypto_encode_id_and_owner(key_id, &encoded_key);
 c03b1f8:	f7ff fa72 	bl	c03a6e0 <tfm_crypto_encode_id_and_owner>
    if (status != PSA_SUCCESS) {
 c03b1fc:	4604      	mov	r4, r0
 c03b1fe:	b938      	cbnz	r0, c03b210 <tfm_crypto_mac_verify_setup+0x74>
        goto exit;
    }

    status = psa_mac_verify_setup(operation, encoded_key, alg);
 c03b200:	e895 0006 	ldmia.w	r5, {r1, r2}
 c03b204:	463b      	mov	r3, r7
 c03b206:	9800      	ldr	r0, [sp, #0]
 c03b208:	f00a fc18 	bl	c045a3c <mbedcrypto__psa_mac_verify_setup>
    if (status != PSA_SUCCESS) {
 c03b20c:	4604      	mov	r4, r0
 c03b20e:	b110      	cbz	r0, c03b216 <tfm_crypto_mac_verify_setup+0x7a>

    return status;

exit:
    /* Release the operation context, ignore if the operation fails. */
    (void)tfm_crypto_operation_release(handle_out);
 c03b210:	4630      	mov	r0, r6
 c03b212:	f7fe fcbd 	bl	c039b90 <tfm_crypto_operation_release>
    return status;
#endif /* TFM_CRYPTO_MAC_MODULE_DISABLED */
}
 c03b216:	4620      	mov	r0, r4
 c03b218:	b004      	add	sp, #16
 c03b21a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 1, out_len, 1, 1);
 c03b21e:	f06f 0480 	mvn.w	r4, #128	@ 0x80
 c03b222:	e7f8      	b.n	c03b216 <tfm_crypto_mac_verify_setup+0x7a>

0c03b224 <tfm_crypto_mac_update>:

psa_status_t tfm_crypto_mac_update(psa_invec in_vec[],
                                   size_t in_len,
                                   psa_outvec out_vec[],
                                   size_t out_len)
{
 c03b224:	b537      	push	{r0, r1, r2, r4, r5, lr}
#ifdef TFM_CRYPTO_MAC_MODULE_DISABLED
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status = PSA_SUCCESS;
    psa_mac_operation_t *operation = NULL;
 c03b226:	2400      	movs	r4, #0
 c03b228:	9401      	str	r4, [sp, #4]

    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 2, out_len, 1, 1);
 c03b22a:	b24c      	sxtb	r4, r1
 c03b22c:	2c00      	cmp	r4, #0
 c03b22e:	dd1e      	ble.n	c03b26e <tfm_crypto_mac_update+0x4a>
 c03b230:	2902      	cmp	r1, #2
 c03b232:	d81c      	bhi.n	c03b26e <tfm_crypto_mac_update+0x4a>
 c03b234:	b259      	sxtb	r1, r3
 c03b236:	2900      	cmp	r1, #0
 c03b238:	dd19      	ble.n	c03b26e <tfm_crypto_mac_update+0x4a>
 c03b23a:	2b01      	cmp	r3, #1
 c03b23c:	d117      	bne.n	c03b26e <tfm_crypto_mac_update+0x4a>

    if ((in_vec[0].len != sizeof(struct tfm_crypto_pack_iovec)) ||
 c03b23e:	6843      	ldr	r3, [r0, #4]
 c03b240:	2b2c      	cmp	r3, #44	@ 0x2c
 c03b242:	d114      	bne.n	c03b26e <tfm_crypto_mac_update+0x4a>
 c03b244:	6853      	ldr	r3, [r2, #4]
 c03b246:	2b04      	cmp	r3, #4
 c03b248:	d111      	bne.n	c03b26e <tfm_crypto_mac_update+0x4a>
    }
    const struct tfm_crypto_pack_iovec *iov = in_vec[0].base;
    uint32_t handle = iov->op_handle;
    uint32_t *handle_out = out_vec[0].base;
    const uint8_t *input = in_vec[1].base;
    size_t input_length = in_vec[1].len;
 c03b24a:	e9d0 4502 	ldrd	r4, r5, [r0, #8]
    uint32_t handle = iov->op_handle;
 c03b24e:	6803      	ldr	r3, [r0, #0]

    /* Init the handle in the operation with the one passed from the iov */
    *handle_out = iov->op_handle;

    /* Look up the corresponding operation context */
    status = tfm_crypto_operation_lookup(TFM_CRYPTO_MAC_OPERATION,
 c03b250:	2002      	movs	r0, #2
    uint32_t handle = iov->op_handle;
 c03b252:	6919      	ldr	r1, [r3, #16]
    *handle_out = iov->op_handle;
 c03b254:	6813      	ldr	r3, [r2, #0]
    status = tfm_crypto_operation_lookup(TFM_CRYPTO_MAC_OPERATION,
 c03b256:	aa01      	add	r2, sp, #4
    *handle_out = iov->op_handle;
 c03b258:	6019      	str	r1, [r3, #0]
    status = tfm_crypto_operation_lookup(TFM_CRYPTO_MAC_OPERATION,
 c03b25a:	f7fe fcd3 	bl	c039c04 <tfm_crypto_operation_lookup>
                                         handle,
                                         (void **)&operation);
    if (status != PSA_SUCCESS) {
 c03b25e:	b920      	cbnz	r0, c03b26a <tfm_crypto_mac_update+0x46>
        return status;
    }

    return psa_mac_update(operation, input, input_length);
 c03b260:	462a      	mov	r2, r5
 c03b262:	4621      	mov	r1, r4
 c03b264:	9801      	ldr	r0, [sp, #4]
 c03b266:	f00a fbf5 	bl	c045a54 <mbedcrypto__psa_mac_update>
#endif /* TFM_CRYPTO_MAC_MODULE_DISABLED */
}
 c03b26a:	b003      	add	sp, #12
 c03b26c:	bd30      	pop	{r4, r5, pc}
    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 2, out_len, 1, 1);
 c03b26e:	f06f 0080 	mvn.w	r0, #128	@ 0x80
 c03b272:	e7fa      	b.n	c03b26a <tfm_crypto_mac_update+0x46>

0c03b274 <tfm_crypto_mac_sign_finish>:

psa_status_t tfm_crypto_mac_sign_finish(psa_invec in_vec[],
                                        size_t in_len,
                                        psa_outvec out_vec[],
                                        size_t out_len)
{
 c03b274:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
 c03b278:	4615      	mov	r5, r2
#ifdef TFM_CRYPTO_MAC_MODULE_DISABLED
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status = PSA_SUCCESS;
    psa_mac_operation_t *operation = NULL;
 c03b27a:	2200      	movs	r2, #0

    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 1, out_len, 1, 2);
 c03b27c:	b24c      	sxtb	r4, r1
 c03b27e:	4294      	cmp	r4, r2
    psa_mac_operation_t *operation = NULL;
 c03b280:	9201      	str	r2, [sp, #4]
    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 1, out_len, 1, 2);
 c03b282:	dd29      	ble.n	c03b2d8 <tfm_crypto_mac_sign_finish+0x64>
 c03b284:	2901      	cmp	r1, #1
 c03b286:	d127      	bne.n	c03b2d8 <tfm_crypto_mac_sign_finish+0x64>
 c03b288:	b259      	sxtb	r1, r3
 c03b28a:	4291      	cmp	r1, r2
 c03b28c:	dd24      	ble.n	c03b2d8 <tfm_crypto_mac_sign_finish+0x64>
 c03b28e:	2b02      	cmp	r3, #2
 c03b290:	d822      	bhi.n	c03b2d8 <tfm_crypto_mac_sign_finish+0x64>

    if ((in_vec[0].len != sizeof(struct tfm_crypto_pack_iovec)) ||
 c03b292:	6843      	ldr	r3, [r0, #4]
 c03b294:	2b2c      	cmp	r3, #44	@ 0x2c
 c03b296:	d11f      	bne.n	c03b2d8 <tfm_crypto_mac_sign_finish+0x64>
 c03b298:	686b      	ldr	r3, [r5, #4]
 c03b29a:	2b04      	cmp	r3, #4
 c03b29c:	d11c      	bne.n	c03b2d8 <tfm_crypto_mac_sign_finish+0x64>
    }
    const struct tfm_crypto_pack_iovec *iov = in_vec[0].base;
    uint32_t handle = iov->op_handle;
    uint32_t *handle_out = out_vec[0].base;
    uint8_t *mac = out_vec[1].base;
    size_t mac_size = out_vec[1].len;
 c03b29e:	e9d5 7802 	ldrd	r7, r8, [r5, #8]
    uint32_t handle = iov->op_handle;
 c03b2a2:	6803      	ldr	r3, [r0, #0]
    uint32_t *handle_out = out_vec[0].base;
 c03b2a4:	682e      	ldr	r6, [r5, #0]
    uint32_t handle = iov->op_handle;
 c03b2a6:	6919      	ldr	r1, [r3, #16]

    /* Initialise mac_length to zero */
    out_vec[1].len = 0;

    /* Look up the corresponding operation context */
    status = tfm_crypto_operation_lookup(TFM_CRYPTO_MAC_OPERATION,
 c03b2a8:	2002      	movs	r0, #2
    *handle_out = iov->op_handle;
 c03b2aa:	6031      	str	r1, [r6, #0]
    out_vec[1].len = 0;
 c03b2ac:	60ea      	str	r2, [r5, #12]
    status = tfm_crypto_operation_lookup(TFM_CRYPTO_MAC_OPERATION,
 c03b2ae:	aa01      	add	r2, sp, #4
 c03b2b0:	f7fe fca8 	bl	c039c04 <tfm_crypto_operation_lookup>
                                         handle,
                                         (void **)&operation);
    if (status != PSA_SUCCESS) {
 c03b2b4:	4604      	mov	r4, r0
 c03b2b6:	b958      	cbnz	r0, c03b2d0 <tfm_crypto_mac_sign_finish+0x5c>
        return status;
    }

    status = psa_mac_sign_finish(operation, mac, mac_size, &out_vec[1].len);
 c03b2b8:	4642      	mov	r2, r8
 c03b2ba:	4639      	mov	r1, r7
 c03b2bc:	9801      	ldr	r0, [sp, #4]
 c03b2be:	f105 030c 	add.w	r3, r5, #12
 c03b2c2:	f00a fbdb 	bl	c045a7c <mbedcrypto__psa_mac_sign_finish>
    if (status == PSA_SUCCESS) {
 c03b2c6:	4604      	mov	r4, r0
 c03b2c8:	b910      	cbnz	r0, c03b2d0 <tfm_crypto_mac_sign_finish+0x5c>
        /* Release the operation context, ignore if the operation fails. */
        (void)tfm_crypto_operation_release(handle_out);
 c03b2ca:	4630      	mov	r0, r6
 c03b2cc:	f7fe fc60 	bl	c039b90 <tfm_crypto_operation_release>
    }

    return status;
#endif /* TFM_CRYPTO_MAC_MODULE_DISABLED */
}
 c03b2d0:	4620      	mov	r0, r4
 c03b2d2:	b002      	add	sp, #8
 c03b2d4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 1, out_len, 1, 2);
 c03b2d8:	f06f 0480 	mvn.w	r4, #128	@ 0x80
 c03b2dc:	e7f8      	b.n	c03b2d0 <tfm_crypto_mac_sign_finish+0x5c>

0c03b2de <tfm_crypto_mac_verify_finish>:

psa_status_t tfm_crypto_mac_verify_finish(psa_invec in_vec[],
                                          size_t in_len,
                                          psa_outvec out_vec[],
                                          size_t out_len)
{
 c03b2de:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
#ifdef TFM_CRYPTO_MAC_MODULE_DISABLED
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status = PSA_SUCCESS;
    psa_mac_operation_t *operation = NULL;
 c03b2e0:	2400      	movs	r4, #0
 c03b2e2:	9401      	str	r4, [sp, #4]

    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 2, out_len, 1, 1);
 c03b2e4:	b24c      	sxtb	r4, r1
 c03b2e6:	2c00      	cmp	r4, #0
 c03b2e8:	dd25      	ble.n	c03b336 <tfm_crypto_mac_verify_finish+0x58>
 c03b2ea:	2902      	cmp	r1, #2
 c03b2ec:	d823      	bhi.n	c03b336 <tfm_crypto_mac_verify_finish+0x58>
 c03b2ee:	b259      	sxtb	r1, r3
 c03b2f0:	2900      	cmp	r1, #0
 c03b2f2:	dd20      	ble.n	c03b336 <tfm_crypto_mac_verify_finish+0x58>
 c03b2f4:	2b01      	cmp	r3, #1
 c03b2f6:	d11e      	bne.n	c03b336 <tfm_crypto_mac_verify_finish+0x58>

    if ((in_vec[0].len != sizeof(struct tfm_crypto_pack_iovec)) ||
 c03b2f8:	6843      	ldr	r3, [r0, #4]
 c03b2fa:	2b2c      	cmp	r3, #44	@ 0x2c
 c03b2fc:	d11b      	bne.n	c03b336 <tfm_crypto_mac_verify_finish+0x58>
 c03b2fe:	6853      	ldr	r3, [r2, #4]
 c03b300:	2b04      	cmp	r3, #4
 c03b302:	d118      	bne.n	c03b336 <tfm_crypto_mac_verify_finish+0x58>
    }
    const struct tfm_crypto_pack_iovec *iov = in_vec[0].base;
    uint32_t handle = iov->op_handle;
    uint32_t *handle_out = out_vec[0].base;
    const uint8_t *mac = in_vec[1].base;
    size_t mac_length = in_vec[1].len;
 c03b304:	e9d0 6702 	ldrd	r6, r7, [r0, #8]
    uint32_t handle = iov->op_handle;
 c03b308:	6803      	ldr	r3, [r0, #0]
    uint32_t *handle_out = out_vec[0].base;
 c03b30a:	6815      	ldr	r5, [r2, #0]
    uint32_t handle = iov->op_handle;
 c03b30c:	6919      	ldr	r1, [r3, #16]

    /* Init the handle in the operation with the one passed from the iov */
    *handle_out = iov->op_handle;

    /* Look up the corresponding operation context */
    status = tfm_crypto_operation_lookup(TFM_CRYPTO_MAC_OPERATION,
 c03b30e:	2002      	movs	r0, #2
    *handle_out = iov->op_handle;
 c03b310:	6029      	str	r1, [r5, #0]
    status = tfm_crypto_operation_lookup(TFM_CRYPTO_MAC_OPERATION,
 c03b312:	aa01      	add	r2, sp, #4
 c03b314:	f7fe fc76 	bl	c039c04 <tfm_crypto_operation_lookup>
                                         handle,
                                         (void **)&operation);
    if (status != PSA_SUCCESS) {
 c03b318:	4604      	mov	r4, r0
 c03b31a:	b948      	cbnz	r0, c03b330 <tfm_crypto_mac_verify_finish+0x52>
        return status;
    }

    status = psa_mac_verify_finish(operation, mac, mac_length);
 c03b31c:	463a      	mov	r2, r7
 c03b31e:	4631      	mov	r1, r6
 c03b320:	9801      	ldr	r0, [sp, #4]
 c03b322:	f00a fc61 	bl	c045be8 <mbedcrypto__psa_mac_verify_finish>
    if (status == PSA_SUCCESS) {
 c03b326:	4604      	mov	r4, r0
 c03b328:	b910      	cbnz	r0, c03b330 <tfm_crypto_mac_verify_finish+0x52>
        /* Release the operation context, ignore if the operation fails. */
        (void)tfm_crypto_operation_release(handle_out);
 c03b32a:	4628      	mov	r0, r5
 c03b32c:	f7fe fc30 	bl	c039b90 <tfm_crypto_operation_release>
    }

    return status;
#endif /* TFM_CRYPTO_MAC_MODULE_DISABLED */
}
 c03b330:	4620      	mov	r0, r4
 c03b332:	b003      	add	sp, #12
 c03b334:	bdf0      	pop	{r4, r5, r6, r7, pc}
    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 2, out_len, 1, 1);
 c03b336:	f06f 0480 	mvn.w	r4, #128	@ 0x80
 c03b33a:	e7f9      	b.n	c03b330 <tfm_crypto_mac_verify_finish+0x52>

0c03b33c <tfm_crypto_mac_abort>:

psa_status_t tfm_crypto_mac_abort(psa_invec in_vec[],
                                  size_t in_len,
                                  psa_outvec out_vec[],
                                  size_t out_len)
{
 c03b33c:	b537      	push	{r0, r1, r2, r4, r5, lr}
#ifdef TFM_CRYPTO_MAC_MODULE_DISABLED
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status = PSA_SUCCESS;
    psa_mac_operation_t *operation = NULL;
 c03b33e:	2400      	movs	r4, #0

    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 1, out_len, 1, 1);
 c03b340:	b24d      	sxtb	r5, r1
 c03b342:	42a5      	cmp	r5, r4
    psa_mac_operation_t *operation = NULL;
 c03b344:	9401      	str	r4, [sp, #4]
    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 1, out_len, 1, 1);
 c03b346:	dd24      	ble.n	c03b392 <tfm_crypto_mac_abort+0x56>
 c03b348:	2901      	cmp	r1, #1
 c03b34a:	d122      	bne.n	c03b392 <tfm_crypto_mac_abort+0x56>
 c03b34c:	b259      	sxtb	r1, r3
 c03b34e:	42a1      	cmp	r1, r4
 c03b350:	dd1f      	ble.n	c03b392 <tfm_crypto_mac_abort+0x56>
 c03b352:	2b01      	cmp	r3, #1
 c03b354:	d11d      	bne.n	c03b392 <tfm_crypto_mac_abort+0x56>

    if ((in_vec[0].len != sizeof(struct tfm_crypto_pack_iovec)) ||
 c03b356:	6843      	ldr	r3, [r0, #4]
 c03b358:	2b2c      	cmp	r3, #44	@ 0x2c
 c03b35a:	d11a      	bne.n	c03b392 <tfm_crypto_mac_abort+0x56>
 c03b35c:	6853      	ldr	r3, [r2, #4]
 c03b35e:	2b04      	cmp	r3, #4
 c03b360:	d117      	bne.n	c03b392 <tfm_crypto_mac_abort+0x56>
        (out_vec[0].len != sizeof(uint32_t))) {
        return PSA_ERROR_PROGRAMMER_ERROR;
    }
    const struct tfm_crypto_pack_iovec *iov = in_vec[0].base;
    uint32_t handle = iov->op_handle;
 c03b362:	6803      	ldr	r3, [r0, #0]
    uint32_t *handle_out = out_vec[0].base;
 c03b364:	6815      	ldr	r5, [r2, #0]
    uint32_t handle = iov->op_handle;
 c03b366:	6919      	ldr	r1, [r3, #16]

    /* Init the handle in the operation with the one passed from the iov */
    *handle_out = iov->op_handle;

    /* Look up the corresponding operation context */
    status = tfm_crypto_operation_lookup(TFM_CRYPTO_MAC_OPERATION,
 c03b368:	2002      	movs	r0, #2
    *handle_out = iov->op_handle;
 c03b36a:	6029      	str	r1, [r5, #0]
    status = tfm_crypto_operation_lookup(TFM_CRYPTO_MAC_OPERATION,
 c03b36c:	aa01      	add	r2, sp, #4
 c03b36e:	f7fe fc49 	bl	c039c04 <tfm_crypto_operation_lookup>
                                         handle,
                                         (void **)&operation);
    if (status != PSA_SUCCESS) {
 c03b372:	b938      	cbnz	r0, c03b384 <tfm_crypto_mac_abort+0x48>
        /* Operation does not exist, so abort has no effect */
        return PSA_SUCCESS;
    }

    status = psa_mac_abort(operation);
 c03b374:	9801      	ldr	r0, [sp, #4]
 c03b376:	f00a fa8e 	bl	c045896 <mbedcrypto__psa_mac_abort>

    if (status != PSA_SUCCESS) {
 c03b37a:	4604      	mov	r4, r0
        /* Release the operation context, ignore if the operation fails. */
        (void)tfm_crypto_operation_release(handle_out);
 c03b37c:	4628      	mov	r0, r5
    if (status != PSA_SUCCESS) {
 c03b37e:	b124      	cbz	r4, c03b38a <tfm_crypto_mac_abort+0x4e>
        (void)tfm_crypto_operation_release(handle_out);
 c03b380:	f7fe fc06 	bl	c039b90 <tfm_crypto_operation_release>
        return status;
    }

    return tfm_crypto_operation_release(handle_out);
#endif /* TFM_CRYPTO_MAC_MODULE_DISABLED */
}
 c03b384:	4620      	mov	r0, r4
 c03b386:	b003      	add	sp, #12
 c03b388:	bd30      	pop	{r4, r5, pc}
    return tfm_crypto_operation_release(handle_out);
 c03b38a:	f7fe fc01 	bl	c039b90 <tfm_crypto_operation_release>
 c03b38e:	4604      	mov	r4, r0
 c03b390:	e7f8      	b.n	c03b384 <tfm_crypto_mac_abort+0x48>
    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 1, out_len, 1, 1);
 c03b392:	f06f 0480 	mvn.w	r4, #128	@ 0x80
 c03b396:	e7f5      	b.n	c03b384 <tfm_crypto_mac_abort+0x48>

0c03b398 <tfm_crypto_mac_compute>:
                                    psa_outvec out_vec[],
                                    size_t out_len)
{
    /* FixMe: To be implemented */
    return PSA_ERROR_NOT_SUPPORTED;
}
 c03b398:	f06f 0085 	mvn.w	r0, #133	@ 0x85
 c03b39c:	4770      	bx	lr

0c03b39e <tfm_crypto_mac_verify>:

psa_status_t tfm_crypto_mac_verify(psa_invec in_vec[],
 c03b39e:	f06f 0085 	mvn.w	r0, #133	@ 0x85
 c03b3a2:	4770      	bx	lr

0c03b3a4 <mbedtls_calloc>:
void * (*mbedtls_calloc_func)( size_t, size_t ) = MBEDTLS_PLATFORM_STD_CALLOC;
void (*mbedtls_free_func)( void * ) = MBEDTLS_PLATFORM_STD_FREE;

void * mbedtls_calloc( size_t nmemb, size_t size )
{
    return (*mbedtls_calloc_func)( nmemb, size );
 c03b3a4:	4b01      	ldr	r3, [pc, #4]	@ (c03b3ac <mbedtls_calloc+0x8>)
 c03b3a6:	681b      	ldr	r3, [r3, #0]
 c03b3a8:	4718      	bx	r3
 c03b3aa:	bf00      	nop
 c03b3ac:	3003090c 	.word	0x3003090c

0c03b3b0 <mbedtls_free>:
}

void mbedtls_free( void * ptr )
{
    (*mbedtls_free_func)( ptr );
 c03b3b0:	4b01      	ldr	r3, [pc, #4]	@ (c03b3b8 <mbedtls_free+0x8>)
 c03b3b2:	681b      	ldr	r3, [r3, #0]
 c03b3b4:	4718      	bx	r3
 c03b3b6:	bf00      	nop
 c03b3b8:	30030908 	.word	0x30030908

0c03b3bc <mbedtls_platform_set_calloc_free>:
}

int mbedtls_platform_set_calloc_free( void * (*calloc_func)( size_t, size_t ),
                              void (*free_func)( void * ) )
{
    mbedtls_calloc_func = calloc_func;
 c03b3bc:	4b02      	ldr	r3, [pc, #8]	@ (c03b3c8 <mbedtls_platform_set_calloc_free+0xc>)
 c03b3be:	6018      	str	r0, [r3, #0]
    mbedtls_free_func = free_func;
 c03b3c0:	4b02      	ldr	r3, [pc, #8]	@ (c03b3cc <mbedtls_platform_set_calloc_free+0x10>)
    return( 0 );
}
 c03b3c2:	2000      	movs	r0, #0
    mbedtls_free_func = free_func;
 c03b3c4:	6019      	str	r1, [r3, #0]
}
 c03b3c6:	4770      	bx	lr
 c03b3c8:	3003090c 	.word	0x3003090c
 c03b3cc:	30030908 	.word	0x30030908

0c03b3d0 <mbedtls_platform_zeroize>:

void mbedtls_platform_zeroize( void *buf, size_t len )
{
    MBEDTLS_INTERNAL_VALIDATE( len == 0 || buf != NULL );

    if( len > 0 )
 c03b3d0:	460a      	mov	r2, r1
 c03b3d2:	b119      	cbz	r1, c03b3dc <mbedtls_platform_zeroize+0xc>
        memset_func( buf, 0, len );
 c03b3d4:	4b02      	ldr	r3, [pc, #8]	@ (c03b3e0 <mbedtls_platform_zeroize+0x10>)
 c03b3d6:	2100      	movs	r1, #0
 c03b3d8:	681b      	ldr	r3, [r3, #0]
 c03b3da:	4718      	bx	r3
}
 c03b3dc:	4770      	bx	lr
 c03b3de:	bf00      	nop
 c03b3e0:	30030910 	.word	0x30030910
	...

Disassembly of section .TFM_SP_PLATFORM_RO:

0c03b400 <platform_sp_ioctl_ipc>:
    return TFM_PLATFORM_ERR_SUCCESS;
}

static enum tfm_platform_err_t
platform_sp_ioctl_ipc(const psa_msg_t *msg)
{
 c03b400:	b570      	push	{r4, r5, r6, lr}
    void *input = NULL;
    void *output = NULL;
    psa_invec invec = {0};
 c03b402:	2400      	movs	r4, #0
{
 c03b404:	4605      	mov	r5, r0
    uint8_t input_buffer[INPUT_BUFFER_SIZE] = {0};
    uint8_t output_buffer[OUTPUT_BUFFER_SIZE] = {0};
    tfm_platform_ioctl_req_t request = 0;
    enum tfm_platform_err_t ret = TFM_PLATFORM_ERR_SYSTEM_ERROR;
    int num = 0;
    uint32_t in_len = PSA_MAX_IOVEC;
 c03b406:	2604      	movs	r6, #4
{
 c03b408:	b0a6      	sub	sp, #152	@ 0x98
    uint8_t input_buffer[INPUT_BUFFER_SIZE] = {0};
 c03b40a:	223c      	movs	r2, #60	@ 0x3c
 c03b40c:	4621      	mov	r1, r4
 c03b40e:	a807      	add	r0, sp, #28
    psa_invec invec = {0};
 c03b410:	e9cd 4402 	strd	r4, r4, [sp, #8]
    psa_outvec outvec = {0};
 c03b414:	e9cd 4404 	strd	r4, r4, [sp, #16]
    uint8_t input_buffer[INPUT_BUFFER_SIZE] = {0};
 c03b418:	9406      	str	r4, [sp, #24]
 c03b41a:	f020 f988 	bl	c05b72e <memset>
    uint8_t output_buffer[OUTPUT_BUFFER_SIZE] = {0};
 c03b41e:	223c      	movs	r2, #60	@ 0x3c
 c03b420:	4621      	mov	r1, r4
 c03b422:	a817      	add	r0, sp, #92	@ 0x5c
 c03b424:	9416      	str	r4, [sp, #88]	@ 0x58
 c03b426:	f020 f982 	bl	c05b72e <memset>
    tfm_platform_ioctl_req_t request = 0;
 c03b42a:	9401      	str	r4, [sp, #4]
    uint32_t out_len = PSA_MAX_IOVEC;

    while ((in_len > 0) && (msg->in_size[in_len - 1] == 0)) {
 c03b42c:	f105 0320 	add.w	r3, r5, #32
 c03b430:	f853 1d04 	ldr.w	r1, [r3, #-4]!
 c03b434:	4632      	mov	r2, r6
 c03b436:	3e01      	subs	r6, #1
 c03b438:	b109      	cbz	r1, c03b43e <platform_sp_ioctl_ipc+0x3e>
 c03b43a:	4616      	mov	r6, r2
 c03b43c:	e001      	b.n	c03b442 <platform_sp_ioctl_ipc+0x42>
 c03b43e:	2e00      	cmp	r6, #0
 c03b440:	d1f6      	bne.n	c03b430 <platform_sp_ioctl_ipc+0x30>
 c03b442:	2404      	movs	r4, #4
 c03b444:	f105 0330 	add.w	r3, r5, #48	@ 0x30
        in_len--;
    }

    while ((out_len > 0) && (msg->out_size[out_len - 1] == 0)) {
 c03b448:	f853 1d04 	ldr.w	r1, [r3, #-4]!
 c03b44c:	4622      	mov	r2, r4
 c03b44e:	3c01      	subs	r4, #1
 c03b450:	b109      	cbz	r1, c03b456 <platform_sp_ioctl_ipc+0x56>
 c03b452:	4614      	mov	r4, r2
 c03b454:	e001      	b.n	c03b45a <platform_sp_ioctl_ipc+0x5a>
 c03b456:	2c00      	cmp	r4, #0
 c03b458:	d1f6      	bne.n	c03b448 <platform_sp_ioctl_ipc+0x48>
        out_len--;
    }

    if ((in_len < 1) || (in_len > 2) ||
 c03b45a:	1e73      	subs	r3, r6, #1
 c03b45c:	2b01      	cmp	r3, #1
 c03b45e:	d838      	bhi.n	c03b4d2 <platform_sp_ioctl_ipc+0xd2>
 c03b460:	2c01      	cmp	r4, #1
 c03b462:	d836      	bhi.n	c03b4d2 <platform_sp_ioctl_ipc+0xd2>
        (out_len > 1)) {
        return TFM_PLATFORM_ERR_SYSTEM_ERROR;
    }

    num = psa_read(msg->handle, 0, &request, sizeof(request));
 c03b464:	2304      	movs	r3, #4
 c03b466:	2100      	movs	r1, #0
 c03b468:	6868      	ldr	r0, [r5, #4]
 c03b46a:	eb0d 0203 	add.w	r2, sp, r3
 c03b46e:	f001 f9cf 	bl	c03c810 <psa_read>
    if (num != sizeof(request)) {
 c03b472:	2804      	cmp	r0, #4
 c03b474:	d004      	beq.n	c03b480 <platform_sp_ioctl_ipc+0x80>
        return (enum tfm_platform_err_t) PSA_ERROR_PROGRAMMER_ERROR;
 c03b476:	f06f 0680 	mvn.w	r6, #128	@ 0x80
    if (output != NULL) {
        psa_write(msg->handle, 0, outvec.base, outvec.len);
    }

    return ret;
}
 c03b47a:	4630      	mov	r0, r6
 c03b47c:	b026      	add	sp, #152	@ 0x98
 c03b47e:	bd70      	pop	{r4, r5, r6, pc}
    if (in_len > 1) {
 c03b480:	2e02      	cmp	r6, #2
 c03b482:	d124      	bne.n	c03b4ce <platform_sp_ioctl_ipc+0xce>
        if (msg->in_size[1] > INPUT_BUFFER_SIZE) {
 c03b484:	696b      	ldr	r3, [r5, #20]
 c03b486:	2b40      	cmp	r3, #64	@ 0x40
 c03b488:	d8f5      	bhi.n	c03b476 <platform_sp_ioctl_ipc+0x76>
        num = psa_read(msg->handle, 1, &input_buffer, msg->in_size[1]);
 c03b48a:	ae06      	add	r6, sp, #24
 c03b48c:	4632      	mov	r2, r6
 c03b48e:	2101      	movs	r1, #1
 c03b490:	6868      	ldr	r0, [r5, #4]
 c03b492:	f001 f9bd 	bl	c03c810 <psa_read>
        if (num != msg->in_size[1]) {
 c03b496:	696b      	ldr	r3, [r5, #20]
 c03b498:	4298      	cmp	r0, r3
 c03b49a:	d1ec      	bne.n	c03b476 <platform_sp_ioctl_ipc+0x76>
        invec.len = msg->in_size[1];
 c03b49c:	e9cd 6002 	strd	r6, r0, [sp, #8]
        input = &invec;
 c03b4a0:	a902      	add	r1, sp, #8
    if (out_len > 0) {
 c03b4a2:	b134      	cbz	r4, c03b4b2 <platform_sp_ioctl_ipc+0xb2>
        if (msg->out_size[0] > OUTPUT_BUFFER_SIZE) {
 c03b4a4:	6a2b      	ldr	r3, [r5, #32]
 c03b4a6:	2b40      	cmp	r3, #64	@ 0x40
 c03b4a8:	d8e5      	bhi.n	c03b476 <platform_sp_ioctl_ipc+0x76>
        outvec.base = output_buffer;
 c03b4aa:	aa16      	add	r2, sp, #88	@ 0x58
        outvec.len = msg->out_size[0];
 c03b4ac:	e9cd 2304 	strd	r2, r3, [sp, #16]
        output = &outvec;
 c03b4b0:	ac04      	add	r4, sp, #16
    ret = tfm_platform_hal_ioctl(request, input, output);
 c03b4b2:	4622      	mov	r2, r4
 c03b4b4:	9801      	ldr	r0, [sp, #4]
 c03b4b6:	f000 f8e5 	bl	c03b684 <tfm_platform_hal_ioctl>
 c03b4ba:	4606      	mov	r6, r0
    if (output != NULL) {
 c03b4bc:	2c00      	cmp	r4, #0
 c03b4be:	d0dc      	beq.n	c03b47a <platform_sp_ioctl_ipc+0x7a>
        psa_write(msg->handle, 0, outvec.base, outvec.len);
 c03b4c0:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 c03b4c4:	2100      	movs	r1, #0
 c03b4c6:	6868      	ldr	r0, [r5, #4]
 c03b4c8:	f001 f9a4 	bl	c03c814 <psa_write>
 c03b4cc:	e7d5      	b.n	c03b47a <platform_sp_ioctl_ipc+0x7a>
    void *input = NULL;
 c03b4ce:	2100      	movs	r1, #0
 c03b4d0:	e7e7      	b.n	c03b4a2 <platform_sp_ioctl_ipc+0xa2>
        return TFM_PLATFORM_ERR_SYSTEM_ERROR;
 c03b4d2:	2601      	movs	r6, #1
 c03b4d4:	e7d1      	b.n	c03b47a <platform_sp_ioctl_ipc+0x7a>

0c03b4d6 <platform_signal_handle>:

static void platform_signal_handle(psa_signal_t signal, plat_func_t pfn)
{
 c03b4d6:	b510      	push	{r4, lr}
 c03b4d8:	b08c      	sub	sp, #48	@ 0x30
 c03b4da:	460c      	mov	r4, r1
    psa_msg_t msg;
    psa_status_t status;

    status = psa_get(signal, &msg);
 c03b4dc:	4669      	mov	r1, sp
 c03b4de:	f001 f995 	bl	c03c80c <psa_get>
    switch (msg.type) {
 c03b4e2:	9b00      	ldr	r3, [sp, #0]
 c03b4e4:	2b00      	cmp	r3, #0
 c03b4e6:	da04      	bge.n	c03b4f2 <platform_signal_handle+0x1c>
 c03b4e8:	3302      	adds	r3, #2
 c03b4ea:	da0b      	bge.n	c03b504 <platform_signal_handle+0x2e>
        break;
    case PSA_IPC_DISCONNECT:
        psa_reply(msg.handle, PSA_SUCCESS);
        break;
    default:
        psa_panic();
 c03b4ec:	f001 f996 	bl	c03c81c <psa_panic>
    }
}
 c03b4f0:	e00c      	b.n	c03b50c <platform_signal_handle+0x36>
    switch (msg.type) {
 c03b4f2:	d003      	beq.n	c03b4fc <platform_signal_handle+0x26>
 c03b4f4:	f2a3 33f2 	subw	r3, r3, #1010	@ 0x3f2
 c03b4f8:	2b01      	cmp	r3, #1
 c03b4fa:	d8f7      	bhi.n	c03b4ec <platform_signal_handle+0x16>
        status = (psa_status_t)pfn(&msg);
 c03b4fc:	4668      	mov	r0, sp
 c03b4fe:	47a0      	blx	r4
 c03b500:	4601      	mov	r1, r0
 c03b502:	e000      	b.n	c03b506 <platform_signal_handle+0x30>
        psa_reply(msg.handle, PSA_SUCCESS);
 c03b504:	2100      	movs	r1, #0
        psa_reply(msg.handle, status);
 c03b506:	9801      	ldr	r0, [sp, #4]
 c03b508:	f001 f986 	bl	c03c818 <psa_reply>
}
 c03b50c:	b00c      	add	sp, #48	@ 0x30
 c03b50e:	bd10      	pop	{r4, pc}

0c03b510 <platform_sp_nv_counter_ipc>:
    uint8_t counter_val = 0;
 c03b510:	2300      	movs	r3, #0
{
 c03b512:	b573      	push	{r0, r1, r4, r5, r6, lr}
 c03b514:	4604      	mov	r4, r0
    uint8_t counter_val = 0;
 c03b516:	f88d 3003 	strb.w	r3, [sp, #3]
    size_t in_len = PSA_MAX_IOVEC, out_len = PSA_MAX_IOVEC, num = 0;
 c03b51a:	2304      	movs	r3, #4
 c03b51c:	f100 0220 	add.w	r2, r0, #32
    while ((in_len > 0) && (msg->in_size[in_len - 1] == 0)) {
 c03b520:	f852 1d04 	ldr.w	r1, [r2, #-4]!
 c03b524:	461e      	mov	r6, r3
 c03b526:	3b01      	subs	r3, #1
 c03b528:	b149      	cbz	r1, c03b53e <platform_sp_nv_counter_ipc+0x2e>
 c03b52a:	2504      	movs	r5, #4
 c03b52c:	f104 0330 	add.w	r3, r4, #48	@ 0x30
    while ((out_len > 0) && (msg->out_size[out_len - 1] == 0)) {
 c03b530:	f853 1d04 	ldr.w	r1, [r3, #-4]!
 c03b534:	462a      	mov	r2, r5
 c03b536:	3d01      	subs	r5, #1
 c03b538:	b129      	cbz	r1, c03b546 <platform_sp_nv_counter_ipc+0x36>
 c03b53a:	4615      	mov	r5, r2
 c03b53c:	e005      	b.n	c03b54a <platform_sp_nv_counter_ipc+0x3a>
    while ((in_len > 0) && (msg->in_size[in_len - 1] == 0)) {
 c03b53e:	2b00      	cmp	r3, #0
 c03b540:	d1ee      	bne.n	c03b520 <platform_sp_nv_counter_ipc+0x10>
 c03b542:	461e      	mov	r6, r3
 c03b544:	e7f1      	b.n	c03b52a <platform_sp_nv_counter_ipc+0x1a>
    while ((out_len > 0) && (msg->out_size[out_len - 1] == 0)) {
 c03b546:	2d00      	cmp	r5, #0
 c03b548:	d1f2      	bne.n	c03b530 <platform_sp_nv_counter_ipc+0x20>
    switch (msg->type) {
 c03b54a:	f240 32f2 	movw	r2, #1010	@ 0x3f2
 c03b54e:	6823      	ldr	r3, [r4, #0]
 c03b550:	4293      	cmp	r3, r2
 c03b552:	d027      	beq.n	c03b5a4 <platform_sp_nv_counter_ipc+0x94>
 c03b554:	f240 32f3 	movw	r2, #1011	@ 0x3f3
 c03b558:	4293      	cmp	r3, r2
 c03b55a:	d102      	bne.n	c03b562 <platform_sp_nv_counter_ipc+0x52>
        if (msg->in_size[0] != NV_COUNTER_ID_SIZE ||
 c03b55c:	6923      	ldr	r3, [r4, #16]
 c03b55e:	2b04      	cmp	r3, #4
 c03b560:	d003      	beq.n	c03b56a <platform_sp_nv_counter_ipc+0x5a>
            return TFM_PLATFORM_ERR_SYSTEM_ERROR;
 c03b562:	2501      	movs	r5, #1
}
 c03b564:	4628      	mov	r0, r5
 c03b566:	b002      	add	sp, #8
 c03b568:	bd70      	pop	{r4, r5, r6, pc}
        if (msg->in_size[0] != NV_COUNTER_ID_SIZE ||
 c03b56a:	2e01      	cmp	r6, #1
 c03b56c:	d1f9      	bne.n	c03b562 <platform_sp_nv_counter_ipc+0x52>
            in_len != 1 || out_len != 0) {
 c03b56e:	2d00      	cmp	r5, #0
 c03b570:	d1f7      	bne.n	c03b562 <platform_sp_nv_counter_ipc+0x52>
        num = psa_read(msg->handle, 0, &counter_id, msg->in_size[0]);
 c03b572:	4629      	mov	r1, r5
 c03b574:	6860      	ldr	r0, [r4, #4]
 c03b576:	aa01      	add	r2, sp, #4
 c03b578:	f001 f94a 	bl	c03c810 <psa_read>
        if (num != msg->in_size[0]) {
 c03b57c:	6923      	ldr	r3, [r4, #16]
 c03b57e:	4283      	cmp	r3, r0
 c03b580:	d1ef      	bne.n	c03b562 <platform_sp_nv_counter_ipc+0x52>
        if (!nv_counter_access_grant(msg->client_id, counter_id)) {
 c03b582:	9801      	ldr	r0, [sp, #4]
 c03b584:	68a3      	ldr	r3, [r4, #8]
    if (nv_counter_no >= NV_COUNTER_MAP_SIZE ||
 c03b586:	2802      	cmp	r0, #2
 c03b588:	d8eb      	bhi.n	c03b562 <platform_sp_nv_counter_ipc+0x52>
    req_id = nv_counter_access_map[nv_counter_no];
 c03b58a:	4a1a      	ldr	r2, [pc, #104]	@ (c03b5f4 <platform_sp_nv_counter_ipc+0xe4>)
 c03b58c:	f852 2020 	ldr.w	r2, [r2, r0, lsl #2]
    if (client_id == req_id && req_id != 0) {
 c03b590:	4293      	cmp	r3, r2
 c03b592:	d1e6      	bne.n	c03b562 <platform_sp_nv_counter_ipc+0x52>
 c03b594:	2b00      	cmp	r3, #0
 c03b596:	d0e4      	beq.n	c03b562 <platform_sp_nv_counter_ipc+0x52>
        err = tfm_plat_increment_nv_counter(counter_id);
 c03b598:	f013 fbea 	bl	c04ed70 <tfm_plat_increment_nv_counter>
    if (err != TFM_PLAT_ERR_SUCCESS) {
 c03b59c:	1e05      	subs	r5, r0, #0
 c03b59e:	bf18      	it	ne
 c03b5a0:	2501      	movne	r5, #1
 c03b5a2:	e7df      	b.n	c03b564 <platform_sp_nv_counter_ipc+0x54>
        num = psa_read(msg->handle, 0, &counter_id, msg->in_size[0]);
 c03b5a4:	6923      	ldr	r3, [r4, #16]
 c03b5a6:	2100      	movs	r1, #0
 c03b5a8:	6860      	ldr	r0, [r4, #4]
 c03b5aa:	aa01      	add	r2, sp, #4
 c03b5ac:	f001 f930 	bl	c03c810 <psa_read>
        if (msg->in_size[0] != NV_COUNTER_ID_SIZE ||
 c03b5b0:	6923      	ldr	r3, [r4, #16]
 c03b5b2:	2b04      	cmp	r3, #4
 c03b5b4:	d1d5      	bne.n	c03b562 <platform_sp_nv_counter_ipc+0x52>
 c03b5b6:	2e01      	cmp	r6, #1
 c03b5b8:	d1d3      	bne.n	c03b562 <platform_sp_nv_counter_ipc+0x52>
            in_len != 1 || out_len != 1) {
 c03b5ba:	2d01      	cmp	r5, #1
 c03b5bc:	d1d1      	bne.n	c03b562 <platform_sp_nv_counter_ipc+0x52>
        if (!nv_counter_access_grant(msg->client_id, counter_id)) {
 c03b5be:	9801      	ldr	r0, [sp, #4]
 c03b5c0:	68a3      	ldr	r3, [r4, #8]
    if (nv_counter_no >= NV_COUNTER_MAP_SIZE ||
 c03b5c2:	2802      	cmp	r0, #2
 c03b5c4:	d8cd      	bhi.n	c03b562 <platform_sp_nv_counter_ipc+0x52>
    req_id = nv_counter_access_map[nv_counter_no];
 c03b5c6:	4a0b      	ldr	r2, [pc, #44]	@ (c03b5f4 <platform_sp_nv_counter_ipc+0xe4>)
 c03b5c8:	f852 2020 	ldr.w	r2, [r2, r0, lsl #2]
    if (client_id == req_id && req_id != 0) {
 c03b5cc:	4293      	cmp	r3, r2
 c03b5ce:	d1c8      	bne.n	c03b562 <platform_sp_nv_counter_ipc+0x52>
 c03b5d0:	2b00      	cmp	r3, #0
 c03b5d2:	d0c6      	beq.n	c03b562 <platform_sp_nv_counter_ipc+0x52>
        err = tfm_plat_read_nv_counter(counter_id,  msg->out_size[0],
 c03b5d4:	6a21      	ldr	r1, [r4, #32]
 c03b5d6:	f10d 0203 	add.w	r2, sp, #3
 c03b5da:	f013 fb71 	bl	c04ecc0 <tfm_plat_read_nv_counter>
        if (err != TFM_PLAT_ERR_SUCCESS) {
 c03b5de:	4605      	mov	r5, r0
 c03b5e0:	2800      	cmp	r0, #0
 c03b5e2:	d1be      	bne.n	c03b562 <platform_sp_nv_counter_ipc+0x52>
        psa_write(msg->handle, 0, &counter_val, msg->out_size[0]);
 c03b5e4:	4601      	mov	r1, r0
 c03b5e6:	6a23      	ldr	r3, [r4, #32]
 c03b5e8:	6860      	ldr	r0, [r4, #4]
 c03b5ea:	f10d 0203 	add.w	r2, sp, #3
 c03b5ee:	f001 f911 	bl	c03c814 <psa_write>
    if (err != TFM_PLAT_ERR_SUCCESS) {
 c03b5f2:	e7b7      	b.n	c03b564 <platform_sp_nv_counter_ipc+0x54>
 c03b5f4:	0c05f83c 	.word	0x0c05f83c

0c03b5f8 <platform_sp_system_reset>:
{
 c03b5f8:	b510      	push	{r4, lr}
    if (tfm_spm_request_reset_vote() != 0) {
 c03b5fa:	f021 fee7 	bl	c05d3cc <tfm_spm_request_reset_vote>
 c03b5fe:	4604      	mov	r4, r0
 c03b600:	b918      	cbnz	r0, c03b60a <platform_sp_system_reset+0x12>
    tfm_hal_system_reset();
 c03b602:	f017 f9b4 	bl	c05296e <tfm_hal_system_reset>
    return TFM_PLATFORM_ERR_SUCCESS;
 c03b606:	4620      	mov	r0, r4
}
 c03b608:	bd10      	pop	{r4, pc}
        return TFM_PLATFORM_ERR_SYSTEM_ERROR;
 c03b60a:	2001      	movs	r0, #1
 c03b60c:	e7fc      	b.n	c03b608 <platform_sp_system_reset+0x10>

0c03b60e <platform_sp_system_reset_ipc>:
    return platform_sp_system_reset();
 c03b60e:	f7ff bff3 	b.w	c03b5f8 <platform_sp_system_reset>
	...

0c03b614 <platform_sp_init>:


#endif /* TFM_PSA_API */

enum tfm_platform_err_t platform_sp_init(void)
{
 c03b614:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    /* Initialise the non-volatile counters */
    enum tfm_plat_err_t err;
    err = tfm_plat_init_nv_counter();
 c03b616:	f013 fb07 	bl	c04ec28 <tfm_plat_init_nv_counter>
    if (err != TFM_PLAT_ERR_SUCCESS) {
 c03b61a:	b108      	cbz	r0, c03b620 <platform_sp_init+0xc>
#ifdef TFM_PSA_API
        psa_panic();
 c03b61c:	f001 f8fe 	bl	c03c81c <psa_panic>
                                   platform_sp_system_reset_ipc);
        } else if (signals & TFM_SP_PLATFORM_IOCTL_SIGNAL) {
            platform_signal_handle(TFM_SP_PLATFORM_IOCTL_SIGNAL,
                                   platform_sp_ioctl_ipc);
       } else if (signals & TFM_SP_PLATFORM_NV_COUNTER_SIGNAL) {
            platform_signal_handle(TFM_SP_PLATFORM_NV_COUNTER_SIGNAL,
 c03b620:	4d12      	ldr	r5, [pc, #72]	@ (c03b66c <platform_sp_init+0x58>)
            platform_signal_handle(TFM_SP_PLATFORM_IOCTL_SIGNAL,
 c03b622:	4e13      	ldr	r6, [pc, #76]	@ (c03b670 <platform_sp_init+0x5c>)
            platform_signal_handle(TFM_SP_PLATFORM_SYSTEM_RESET_SIGNAL,
 c03b624:	4f13      	ldr	r7, [pc, #76]	@ (c03b674 <platform_sp_init+0x60>)
        signals = psa_wait(PSA_WAIT_ANY, PSA_BLOCK);
 c03b626:	f04f 4100 	mov.w	r1, #2147483648	@ 0x80000000
 c03b62a:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 c03b62e:	f001 f8eb 	bl	c03c808 <psa_wait>
        if (signals & SPM_TAMPER_IRQ)
 c03b632:	1e04      	subs	r4, r0, #0
 c03b634:	da01      	bge.n	c03b63a <platform_sp_init+0x26>
             tfm_hal_system_reset();
 c03b636:	f017 f99a 	bl	c05296e <tfm_hal_system_reset>
        if (signals & SPM_GTZC_IRQ)
 c03b63a:	0060      	lsls	r0, r4, #1
 c03b63c:	d501      	bpl.n	c03b642 <platform_sp_init+0x2e>
            tfm_hal_system_reset();
 c03b63e:	f017 f996 	bl	c05296e <tfm_hal_system_reset>
        if (signals & TFM_SP_PLATFORM_SYSTEM_RESET_SIGNAL) {
 c03b642:	06e1      	lsls	r1, r4, #27
 c03b644:	d504      	bpl.n	c03b650 <platform_sp_init+0x3c>
            platform_signal_handle(TFM_SP_PLATFORM_SYSTEM_RESET_SIGNAL,
 c03b646:	4639      	mov	r1, r7
 c03b648:	2010      	movs	r0, #16
            platform_signal_handle(TFM_SP_PLATFORM_NV_COUNTER_SIGNAL,
 c03b64a:	f7ff ff44 	bl	c03b4d6 <platform_signal_handle>
 c03b64e:	e7ea      	b.n	c03b626 <platform_sp_init+0x12>
        } else if (signals & TFM_SP_PLATFORM_IOCTL_SIGNAL) {
 c03b650:	06a2      	lsls	r2, r4, #26
 c03b652:	d502      	bpl.n	c03b65a <platform_sp_init+0x46>
            platform_signal_handle(TFM_SP_PLATFORM_IOCTL_SIGNAL,
 c03b654:	4631      	mov	r1, r6
 c03b656:	2020      	movs	r0, #32
 c03b658:	e7f7      	b.n	c03b64a <platform_sp_init+0x36>
       } else if (signals & TFM_SP_PLATFORM_NV_COUNTER_SIGNAL) {
 c03b65a:	0663      	lsls	r3, r4, #25
 c03b65c:	d502      	bpl.n	c03b664 <platform_sp_init+0x50>
            platform_signal_handle(TFM_SP_PLATFORM_NV_COUNTER_SIGNAL,
 c03b65e:	4629      	mov	r1, r5
 c03b660:	2040      	movs	r0, #64	@ 0x40
 c03b662:	e7f2      	b.n	c03b64a <platform_sp_init+0x36>
                                   platform_sp_nv_counter_ipc);
        } else {
            psa_panic();
 c03b664:	f001 f8da 	bl	c03c81c <psa_panic>
 c03b668:	e7dd      	b.n	c03b626 <platform_sp_init+0x12>
 c03b66a:	bf00      	nop
 c03b66c:	0c03b511 	.word	0x0c03b511
 c03b670:	0c03b401 	.word	0x0c03b401
 c03b674:	0c03b60f 	.word	0x0c03b60f

0c03b678 <tfm_hal_platform_init>:
#include "tfm_spm_hal.h"
#include "uart_stdout.h"
#include "tfm_hal_platform.h"

__WEAK enum tfm_hal_status_t tfm_hal_platform_init(void)
{
 c03b678:	b508      	push	{r3, lr}
  __ASM volatile ("cpsie i" : : : "memory");
 c03b67a:	b662      	cpsie	i
    __enable_irq();
    stdio_init();
 c03b67c:	f023 f81e 	bl	c05e6bc <stdio_init>

    return TFM_HAL_SUCCESS;
}
 c03b680:	2000      	movs	r0, #0
 c03b682:	bd08      	pop	{r3, pc}

0c03b684 <tfm_platform_hal_ioctl>:
#endif /* TFM_TEST_PRIV_PROTECTION */

enum tfm_platform_err_t tfm_platform_hal_ioctl(tfm_platform_ioctl_req_t request,
                                               psa_invec *in_vec,
                                               psa_outvec *out_vec)
{
 c03b684:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
  switch (request)
 c03b686:	b120      	cbz	r0, c03b692 <tfm_platform_hal_ioctl+0xe>
 c03b688:	2801      	cmp	r0, #1
 c03b68a:	d019      	beq.n	c03b6c0 <tfm_platform_hal_ioctl+0x3c>
 c03b68c:	2003      	movs	r0, #3
      break;
#endif /* TFM_TEST_PRIV_PROTECTION */
    default:
      return TFM_PLATFORM_ERR_NOT_SUPPORTED;
  }
} 
 c03b68e:	b004      	add	sp, #16
 c03b690:	bd70      	pop	{r4, r5, r6, pc}
  const uint8_t FlagPattern[16]={0x1 ,0xff, 0xff, 0xff, 0xff , 0xff, 0xff, 0xff,
 c03b692:	466a      	mov	r2, sp
 c03b694:	4615      	mov	r5, r2
 c03b696:	4b13      	ldr	r3, [pc, #76]	@ (c03b6e4 <tfm_platform_hal_ioctl+0x60>)
 c03b698:	f103 0610 	add.w	r6, r3, #16
 c03b69c:	4614      	mov	r4, r2
 c03b69e:	6818      	ldr	r0, [r3, #0]
 c03b6a0:	6859      	ldr	r1, [r3, #4]
 c03b6a2:	3308      	adds	r3, #8
 c03b6a4:	c403      	stmia	r4!, {r0, r1}
 c03b6a6:	42b3      	cmp	r3, r6
 c03b6a8:	4622      	mov	r2, r4
 c03b6aa:	d1f7      	bne.n	c03b69c <tfm_platform_hal_ioctl+0x18>
  if (FLASH_PRIMARY_SECURE_DEV_NAME.ProgramData(ConfirmAddress, FlagPattern, sizeof(FlagPattern)) == ARM_DRIVER_OK)
 c03b6ac:	2210      	movs	r2, #16
 c03b6ae:	4629      	mov	r1, r5
 c03b6b0:	4b0d      	ldr	r3, [pc, #52]	@ (c03b6e8 <tfm_platform_hal_ioctl+0x64>)
 c03b6b2:	480e      	ldr	r0, [pc, #56]	@ (c03b6ec <tfm_platform_hal_ioctl+0x68>)
  if (FLASH_PRIMARY_DATA_SECURE_DEV_NAME.ProgramData(ConfirmAddress, FlagPattern, sizeof(FlagPattern)) == ARM_DRIVER_OK)
 c03b6b4:	699b      	ldr	r3, [r3, #24]
 c03b6b6:	4798      	blx	r3
 c03b6b8:	3800      	subs	r0, #0
 c03b6ba:	bf18      	it	ne
 c03b6bc:	2001      	movne	r0, #1
	  return tfm_platform_confirm_secure_data_image();
 c03b6be:	e7e6      	b.n	c03b68e <tfm_platform_hal_ioctl+0xa>
  const uint8_t FlagPattern[16]={0x1 ,0xff, 0xff, 0xff, 0xff , 0xff, 0xff, 0xff,
 c03b6c0:	466a      	mov	r2, sp
 c03b6c2:	4615      	mov	r5, r2
 c03b6c4:	4b07      	ldr	r3, [pc, #28]	@ (c03b6e4 <tfm_platform_hal_ioctl+0x60>)
 c03b6c6:	f103 0610 	add.w	r6, r3, #16
 c03b6ca:	4614      	mov	r4, r2
 c03b6cc:	6818      	ldr	r0, [r3, #0]
 c03b6ce:	6859      	ldr	r1, [r3, #4]
 c03b6d0:	3308      	adds	r3, #8
 c03b6d2:	c403      	stmia	r4!, {r0, r1}
 c03b6d4:	42b3      	cmp	r3, r6
 c03b6d6:	4622      	mov	r2, r4
 c03b6d8:	d1f7      	bne.n	c03b6ca <tfm_platform_hal_ioctl+0x46>
  if (FLASH_PRIMARY_DATA_SECURE_DEV_NAME.ProgramData(ConfirmAddress, FlagPattern, sizeof(FlagPattern)) == ARM_DRIVER_OK)
 c03b6da:	2210      	movs	r2, #16
 c03b6dc:	4629      	mov	r1, r5
 c03b6de:	4b02      	ldr	r3, [pc, #8]	@ (c03b6e8 <tfm_platform_hal_ioctl+0x64>)
 c03b6e0:	4803      	ldr	r0, [pc, #12]	@ (c03b6f0 <tfm_platform_hal_ioctl+0x6c>)
 c03b6e2:	e7e7      	b.n	c03b6b4 <tfm_platform_hal_ioctl+0x30>
 c03b6e4:	0c05fa80 	.word	0x0c05fa80
 c03b6e8:	0c05f7f4 	.word	0x0c05f7f4
 c03b6ec:	00067fe0 	.word	0x00067fe0
 c03b6f0:	00037fe0 	.word	0x00037fe0
	...

Disassembly of section .ER_UNPRIV_CODE:

0c03c000 <psa_open_key>:
    return PSA_SUCCESS;
}

psa_status_t psa_open_key(psa_key_id_t id,
                          psa_key_id_t *key_id)
{
 c03c000:	b570      	push	{r4, r5, r6, lr}
 c03c002:	b096      	sub	sp, #88	@ 0x58
 c03c004:	460c      	mov	r4, r1
#ifdef TFM_CRYPTO_KEY_MODULE_DISABLED
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status;
    struct tfm_crypto_pack_iovec iov = {
 c03c006:	2228      	movs	r2, #40	@ 0x28
 c03c008:	2100      	movs	r1, #0
{
 c03c00a:	9003      	str	r0, [sp, #12]
    struct tfm_crypto_pack_iovec iov = {
 c03c00c:	a80c      	add	r0, sp, #48	@ 0x30
 c03c00e:	f01f fb8e 	bl	c05b72e <memset>
        .sfn_id = TFM_CRYPTO_OPEN_KEY_SID,
    };
    psa_invec in_vec[] = {
 c03c012:	ab0b      	add	r3, sp, #44	@ 0x2c
 c03c014:	9307      	str	r3, [sp, #28]
 c03c016:	232c      	movs	r3, #44	@ 0x2c
 c03c018:	9308      	str	r3, [sp, #32]
 c03c01a:	ab03      	add	r3, sp, #12
 c03c01c:	9309      	str	r3, [sp, #36]	@ 0x24
    struct tfm_crypto_pack_iovec iov = {
 c03c01e:	2602      	movs	r6, #2
    psa_invec in_vec[] = {
 c03c020:	2304      	movs	r3, #4
    psa_outvec out_vec[] = {
        {.base = key_id, .len = sizeof(psa_key_id_t)},
    };

#ifdef TFM_PSA_API
    PSA_CONNECT(TFM_CRYPTO);
 c03c022:	2101      	movs	r1, #1
 c03c024:	2080      	movs	r0, #128	@ 0x80
    psa_outvec out_vec[] = {
 c03c026:	e9cd 4305 	strd	r4, r3, [sp, #20]
    struct tfm_crypto_pack_iovec iov = {
 c03c02a:	960b      	str	r6, [sp, #44]	@ 0x2c
    psa_invec in_vec[] = {
 c03c02c:	930a      	str	r3, [sp, #40]	@ 0x28
    PSA_CONNECT(TFM_CRYPTO);
 c03c02e:	f000 fbdb 	bl	c03c7e8 <psa_connect>
 c03c032:	1e05      	subs	r5, r0, #0
 c03c034:	dd0f      	ble.n	c03c056 <psa_open_key+0x56>
#endif

    status = API_DISPATCH(tfm_crypto_open_key,
 c03c036:	2301      	movs	r3, #1
 c03c038:	9301      	str	r3, [sp, #4]
 c03c03a:	ab05      	add	r3, sp, #20
 c03c03c:	9300      	str	r3, [sp, #0]
 c03c03e:	2100      	movs	r1, #0
 c03c040:	4633      	mov	r3, r6
 c03c042:	aa07      	add	r2, sp, #28
 c03c044:	f000 fbd2 	bl	c03c7ec <psa_call>
 c03c048:	4604      	mov	r4, r0
                          TFM_CRYPTO_OPEN_KEY);

#ifdef TFM_PSA_API
    PSA_CLOSE();
 c03c04a:	4628      	mov	r0, r5
 c03c04c:	f000 fbda 	bl	c03c804 <psa_close>
#endif

    return status;
#endif /* TFM_CRYPTO_KEY_MODULE_DISABLED */
}
 c03c050:	4620      	mov	r0, r4
 c03c052:	b016      	add	sp, #88	@ 0x58
 c03c054:	bd70      	pop	{r4, r5, r6, pc}
    PSA_CONNECT(TFM_CRYPTO);
 c03c056:	f06f 0483 	mvn.w	r4, #131	@ 0x83
 c03c05a:	e7f9      	b.n	c03c050 <psa_open_key+0x50>

0c03c05c <psa_close_key>:

psa_status_t psa_close_key(psa_key_id_t key_id)
{
 c03c05c:	b530      	push	{r4, r5, lr}
 c03c05e:	b091      	sub	sp, #68	@ 0x44
 c03c060:	4604      	mov	r4, r0
#ifdef TFM_CRYPTO_KEY_MODULE_DISABLED
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status;
    struct tfm_crypto_pack_iovec iov = {
 c03c062:	2228      	movs	r2, #40	@ 0x28
 c03c064:	2100      	movs	r1, #0
 c03c066:	a806      	add	r0, sp, #24
 c03c068:	f01f fb61 	bl	c05b72e <memset>
 c03c06c:	2303      	movs	r3, #3
 c03c06e:	9305      	str	r3, [sp, #20]
        .sfn_id = TFM_CRYPTO_CLOSE_KEY_SID,
        .key_id = key_id,
    };
    psa_invec in_vec[] = {
 c03c070:	ab05      	add	r3, sp, #20
 c03c072:	9303      	str	r3, [sp, #12]
 c03c074:	232c      	movs	r3, #44	@ 0x2c
        {.base = &iov, .len = sizeof(struct tfm_crypto_pack_iovec)},
    };

#ifdef TFM_PSA_API
    PSA_CONNECT(TFM_CRYPTO);
 c03c076:	2101      	movs	r1, #1
 c03c078:	2080      	movs	r0, #128	@ 0x80
    struct tfm_crypto_pack_iovec iov = {
 c03c07a:	9407      	str	r4, [sp, #28]
    psa_invec in_vec[] = {
 c03c07c:	9304      	str	r3, [sp, #16]
    PSA_CONNECT(TFM_CRYPTO);
 c03c07e:	f000 fbb3 	bl	c03c7e8 <psa_connect>
 c03c082:	1e05      	subs	r5, r0, #0
 c03c084:	dd0d      	ble.n	c03c0a2 <psa_close_key+0x46>
#endif

    status = API_DISPATCH_NO_OUTVEC(tfm_crypto_close_key,
 c03c086:	2100      	movs	r1, #0
 c03c088:	2301      	movs	r3, #1
 c03c08a:	e9cd 1100 	strd	r1, r1, [sp]
 c03c08e:	aa03      	add	r2, sp, #12
 c03c090:	f000 fbac 	bl	c03c7ec <psa_call>
 c03c094:	4604      	mov	r4, r0
                                    TFM_CRYPTO_CLOSE_KEY);;

#ifdef TFM_PSA_API
    PSA_CLOSE();
 c03c096:	4628      	mov	r0, r5
 c03c098:	f000 fbb4 	bl	c03c804 <psa_close>
#endif

    return status;
#endif /* TFM_CRYPTO_KEY_MODULE_DISABLED */
}
 c03c09c:	4620      	mov	r0, r4
 c03c09e:	b011      	add	sp, #68	@ 0x44
 c03c0a0:	bd30      	pop	{r4, r5, pc}
    PSA_CONNECT(TFM_CRYPTO);
 c03c0a2:	f06f 0483 	mvn.w	r4, #131	@ 0x83
 c03c0a6:	e7f9      	b.n	c03c09c <psa_close_key+0x40>

0c03c0a8 <psa_destroy_key>:
    return status;
#endif /* TFM_CRYPTO_KEY_MODULE_DISABLED */
}

psa_status_t psa_destroy_key(psa_key_id_t key_id)
{
 c03c0a8:	b530      	push	{r4, r5, lr}
 c03c0aa:	b091      	sub	sp, #68	@ 0x44
 c03c0ac:	4604      	mov	r4, r0
#ifdef TFM_CRYPTO_KEY_MODULE_DISABLED
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status;
    struct tfm_crypto_pack_iovec iov = {
 c03c0ae:	2228      	movs	r2, #40	@ 0x28
 c03c0b0:	2100      	movs	r1, #0
 c03c0b2:	a806      	add	r0, sp, #24
 c03c0b4:	f01f fb3b 	bl	c05b72e <memset>
 c03c0b8:	2305      	movs	r3, #5
 c03c0ba:	9305      	str	r3, [sp, #20]
        .sfn_id = TFM_CRYPTO_DESTROY_KEY_SID,
        .key_id = key_id,
    };
    psa_invec in_vec[] = {
 c03c0bc:	ab05      	add	r3, sp, #20
 c03c0be:	9303      	str	r3, [sp, #12]
 c03c0c0:	232c      	movs	r3, #44	@ 0x2c
        {.base = &iov, .len = sizeof(struct tfm_crypto_pack_iovec)},
    };

#ifdef TFM_PSA_API
    PSA_CONNECT(TFM_CRYPTO);
 c03c0c2:	2101      	movs	r1, #1
 c03c0c4:	2080      	movs	r0, #128	@ 0x80
    struct tfm_crypto_pack_iovec iov = {
 c03c0c6:	9407      	str	r4, [sp, #28]
    psa_invec in_vec[] = {
 c03c0c8:	9304      	str	r3, [sp, #16]
    PSA_CONNECT(TFM_CRYPTO);
 c03c0ca:	f000 fb8d 	bl	c03c7e8 <psa_connect>
 c03c0ce:	1e05      	subs	r5, r0, #0
 c03c0d0:	dd0d      	ble.n	c03c0ee <psa_destroy_key+0x46>
#endif

    status = API_DISPATCH_NO_OUTVEC(tfm_crypto_destroy_key,
 c03c0d2:	2100      	movs	r1, #0
 c03c0d4:	2301      	movs	r3, #1
 c03c0d6:	e9cd 1100 	strd	r1, r1, [sp]
 c03c0da:	aa03      	add	r2, sp, #12
 c03c0dc:	f000 fb86 	bl	c03c7ec <psa_call>
 c03c0e0:	4604      	mov	r4, r0
                                    TFM_CRYPTO_DESTROY_KEY);
#ifdef TFM_PSA_API
    PSA_CLOSE();
 c03c0e2:	4628      	mov	r0, r5
 c03c0e4:	f000 fb8e 	bl	c03c804 <psa_close>
#endif

    return status;
#endif /* TFM_CRYPTO_KEY_MODULE_DISABLED */
}
 c03c0e8:	4620      	mov	r0, r4
 c03c0ea:	b011      	add	sp, #68	@ 0x44
 c03c0ec:	bd30      	pop	{r4, r5, pc}
    PSA_CONNECT(TFM_CRYPTO);
 c03c0ee:	f06f 0483 	mvn.w	r4, #131	@ 0x83
 c03c0f2:	e7f9      	b.n	c03c0e8 <psa_destroy_key+0x40>

0c03c0f4 <psa_get_key_attributes>:

psa_status_t psa_get_key_attributes(psa_key_id_t key_id,
                                    psa_key_attributes_t *attributes)
{
 c03c0f4:	b570      	push	{r4, r5, r6, lr}
#ifdef TFM_CRYPTO_KEY_MODULE_DISABLED
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status;
    struct tfm_crypto_pack_iovec iov = {
 c03c0f6:	262c      	movs	r6, #44	@ 0x2c
{
 c03c0f8:	b092      	sub	sp, #72	@ 0x48
    struct tfm_crypto_pack_iovec iov = {
 c03c0fa:	ab07      	add	r3, sp, #28
{
 c03c0fc:	4605      	mov	r5, r0
 c03c0fe:	460c      	mov	r4, r1
    struct tfm_crypto_pack_iovec iov = {
 c03c100:	4632      	mov	r2, r6
 c03c102:	2100      	movs	r1, #0
 c03c104:	4618      	mov	r0, r3
 c03c106:	f01f fb12 	bl	c05b72e <memset>
        .key_id = key_id,
    };
    psa_invec in_vec[] = {
        {.base = &iov, .len = sizeof(struct tfm_crypto_pack_iovec)},
    };
    psa_outvec out_vec[] = {
 c03c10a:	2318      	movs	r3, #24
    psa_invec in_vec[] = {
 c03c10c:	e9cd 0603 	strd	r0, r6, [sp, #12]
        {.base = attributes, .len = sizeof(psa_key_attributes_t)},
    };

#ifdef TFM_PSA_API
    PSA_CONNECT(TFM_CRYPTO);
 c03c110:	2101      	movs	r1, #1
 c03c112:	2080      	movs	r0, #128	@ 0x80
    struct tfm_crypto_pack_iovec iov = {
 c03c114:	9509      	str	r5, [sp, #36]	@ 0x24
    psa_outvec out_vec[] = {
 c03c116:	9405      	str	r4, [sp, #20]
 c03c118:	9306      	str	r3, [sp, #24]
    PSA_CONNECT(TFM_CRYPTO);
 c03c11a:	f000 fb65 	bl	c03c7e8 <psa_connect>
 c03c11e:	1e05      	subs	r5, r0, #0
 c03c120:	dd0e      	ble.n	c03c140 <psa_get_key_attributes+0x4c>
#endif

    status = API_DISPATCH(tfm_crypto_get_key_attributes,
 c03c122:	2301      	movs	r3, #1
 c03c124:	aa05      	add	r2, sp, #20
 c03c126:	9200      	str	r2, [sp, #0]
 c03c128:	2100      	movs	r1, #0
 c03c12a:	9301      	str	r3, [sp, #4]
 c03c12c:	aa03      	add	r2, sp, #12
 c03c12e:	f000 fb5d 	bl	c03c7ec <psa_call>
 c03c132:	4604      	mov	r4, r0
                          TFM_CRYPTO_GET_KEY_ATTRIBUTES);
#ifdef TFM_PSA_API
    PSA_CLOSE();
 c03c134:	4628      	mov	r0, r5
 c03c136:	f000 fb65 	bl	c03c804 <psa_close>
#endif

    return status;
#endif /* TFM_CRYPTO_KEY_MODULE_DISABLED */
}
 c03c13a:	4620      	mov	r0, r4
 c03c13c:	b012      	add	sp, #72	@ 0x48
 c03c13e:	bd70      	pop	{r4, r5, r6, pc}
    PSA_CONNECT(TFM_CRYPTO);
 c03c140:	f06f 0483 	mvn.w	r4, #131	@ 0x83
 c03c144:	e7f9      	b.n	c03c13a <psa_get_key_attributes+0x46>

0c03c146 <psa_export_key>:

psa_status_t psa_export_key(psa_key_id_t key_id,
                            uint8_t *data,
                            size_t data_size,
                            size_t *data_length)
{
 c03c146:	b5f0      	push	{r4, r5, r6, r7, lr}
 c03c148:	b093      	sub	sp, #76	@ 0x4c
 c03c14a:	460d      	mov	r5, r1
 c03c14c:	4607      	mov	r7, r0
 c03c14e:	4614      	mov	r4, r2
#ifdef TFM_CRYPTO_KEY_MODULE_DISABLED
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status;
    struct tfm_crypto_pack_iovec iov = {
 c03c150:	2100      	movs	r1, #0
 c03c152:	2228      	movs	r2, #40	@ 0x28
 c03c154:	a808      	add	r0, sp, #32
{
 c03c156:	461e      	mov	r6, r3
    struct tfm_crypto_pack_iovec iov = {
 c03c158:	f01f fae9 	bl	c05b72e <memset>
 c03c15c:	2306      	movs	r3, #6
 c03c15e:	9307      	str	r3, [sp, #28]
        .sfn_id = TFM_CRYPTO_EXPORT_KEY_SID,
        .key_id = key_id,
    };
    psa_invec in_vec[] = {
 c03c160:	ab07      	add	r3, sp, #28
 c03c162:	9303      	str	r3, [sp, #12]
 c03c164:	232c      	movs	r3, #44	@ 0x2c
    psa_outvec out_vec[] = {
        {.base = data, .len = data_size}
    };

#ifdef TFM_PSA_API
    PSA_CONNECT(TFM_CRYPTO);
 c03c166:	2101      	movs	r1, #1
 c03c168:	2080      	movs	r0, #128	@ 0x80
    psa_outvec out_vec[] = {
 c03c16a:	e9cd 3504 	strd	r3, r5, [sp, #16]
    struct tfm_crypto_pack_iovec iov = {
 c03c16e:	9709      	str	r7, [sp, #36]	@ 0x24
    psa_outvec out_vec[] = {
 c03c170:	9406      	str	r4, [sp, #24]
    PSA_CONNECT(TFM_CRYPTO);
 c03c172:	f000 fb39 	bl	c03c7e8 <psa_connect>
 c03c176:	1e05      	subs	r5, r0, #0
 c03c178:	dd10      	ble.n	c03c19c <psa_export_key+0x56>
#endif

    status = API_DISPATCH(tfm_crypto_export_key,
 c03c17a:	2301      	movs	r3, #1
 c03c17c:	aa05      	add	r2, sp, #20
 c03c17e:	9301      	str	r3, [sp, #4]
 c03c180:	9200      	str	r2, [sp, #0]
 c03c182:	2100      	movs	r1, #0
 c03c184:	aa03      	add	r2, sp, #12
 c03c186:	f000 fb31 	bl	c03c7ec <psa_call>
                          TFM_CRYPTO_EXPORT_KEY);

    *data_length = out_vec[0].len;
 c03c18a:	9b06      	ldr	r3, [sp, #24]
    status = API_DISPATCH(tfm_crypto_export_key,
 c03c18c:	4604      	mov	r4, r0
    *data_length = out_vec[0].len;
 c03c18e:	6033      	str	r3, [r6, #0]

#ifdef TFM_PSA_API
    PSA_CLOSE();
 c03c190:	4628      	mov	r0, r5
 c03c192:	f000 fb37 	bl	c03c804 <psa_close>
#endif

    return status;
#endif /* TFM_CRYPTO_KEY_MODULE_DISABLED */
}
 c03c196:	4620      	mov	r0, r4
 c03c198:	b013      	add	sp, #76	@ 0x4c
 c03c19a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    PSA_CONNECT(TFM_CRYPTO);
 c03c19c:	f06f 0483 	mvn.w	r4, #131	@ 0x83
 c03c1a0:	e7f9      	b.n	c03c196 <psa_export_key+0x50>

0c03c1a2 <psa_export_public_key>:

psa_status_t psa_export_public_key(psa_key_id_t key_id,
                                   uint8_t *data,
                                   size_t data_size,
                                   size_t *data_length)
{
 c03c1a2:	b5f0      	push	{r4, r5, r6, r7, lr}
 c03c1a4:	b093      	sub	sp, #76	@ 0x4c
 c03c1a6:	460d      	mov	r5, r1
 c03c1a8:	4607      	mov	r7, r0
 c03c1aa:	4614      	mov	r4, r2
#ifdef TFM_CRYPTO_KEY_MODULE_DISABLED
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status;
    struct tfm_crypto_pack_iovec iov = {
 c03c1ac:	2100      	movs	r1, #0
 c03c1ae:	2228      	movs	r2, #40	@ 0x28
 c03c1b0:	a808      	add	r0, sp, #32
{
 c03c1b2:	461e      	mov	r6, r3
    struct tfm_crypto_pack_iovec iov = {
 c03c1b4:	f01f fabb 	bl	c05b72e <memset>
 c03c1b8:	2307      	movs	r3, #7
 c03c1ba:	9307      	str	r3, [sp, #28]
        .sfn_id = TFM_CRYPTO_EXPORT_PUBLIC_KEY_SID,
        .key_id = key_id,
    };

    psa_invec in_vec[] = {
 c03c1bc:	ab07      	add	r3, sp, #28
 c03c1be:	9303      	str	r3, [sp, #12]
 c03c1c0:	232c      	movs	r3, #44	@ 0x2c
    psa_outvec out_vec[] = {
        {.base = data, .len = data_size}
    };

#ifdef TFM_PSA_API
    PSA_CONNECT(TFM_CRYPTO);
 c03c1c2:	2101      	movs	r1, #1
 c03c1c4:	2080      	movs	r0, #128	@ 0x80
    psa_outvec out_vec[] = {
 c03c1c6:	e9cd 3504 	strd	r3, r5, [sp, #16]
    struct tfm_crypto_pack_iovec iov = {
 c03c1ca:	9709      	str	r7, [sp, #36]	@ 0x24
    psa_outvec out_vec[] = {
 c03c1cc:	9406      	str	r4, [sp, #24]
    PSA_CONNECT(TFM_CRYPTO);
 c03c1ce:	f000 fb0b 	bl	c03c7e8 <psa_connect>
 c03c1d2:	1e05      	subs	r5, r0, #0
 c03c1d4:	dd10      	ble.n	c03c1f8 <psa_export_public_key+0x56>
#endif

    status = API_DISPATCH(tfm_crypto_export_public_key,
 c03c1d6:	2301      	movs	r3, #1
 c03c1d8:	aa05      	add	r2, sp, #20
 c03c1da:	9301      	str	r3, [sp, #4]
 c03c1dc:	9200      	str	r2, [sp, #0]
 c03c1de:	2100      	movs	r1, #0
 c03c1e0:	aa03      	add	r2, sp, #12
 c03c1e2:	f000 fb03 	bl	c03c7ec <psa_call>
                          TFM_CRYPTO_EXPORT_PUBLIC_KEY);

    *data_length = out_vec[0].len;
 c03c1e6:	9b06      	ldr	r3, [sp, #24]
    status = API_DISPATCH(tfm_crypto_export_public_key,
 c03c1e8:	4604      	mov	r4, r0
    *data_length = out_vec[0].len;
 c03c1ea:	6033      	str	r3, [r6, #0]

#ifdef TFM_PSA_API
    PSA_CLOSE();
 c03c1ec:	4628      	mov	r0, r5
 c03c1ee:	f000 fb09 	bl	c03c804 <psa_close>
#endif

    return status;
#endif /* TFM_CRYPTO_KEY_MODULE_DISABLED */
}
 c03c1f2:	4620      	mov	r0, r4
 c03c1f4:	b013      	add	sp, #76	@ 0x4c
 c03c1f6:	bdf0      	pop	{r4, r5, r6, r7, pc}
    PSA_CONNECT(TFM_CRYPTO);
 c03c1f8:	f06f 0483 	mvn.w	r4, #131	@ 0x83
 c03c1fc:	e7f9      	b.n	c03c1f2 <psa_export_public_key+0x50>

0c03c1fe <psa_hash_setup>:
#endif /* TFM_CRYPTO_CIPHER_MODULE_DISABLED */
}

psa_status_t psa_hash_setup(psa_hash_operation_t *operation,
                            psa_algorithm_t alg)
{
 c03c1fe:	b530      	push	{r4, r5, lr}
 c03c200:	b093      	sub	sp, #76	@ 0x4c
 c03c202:	4604      	mov	r4, r0
 c03c204:	460d      	mov	r5, r1
#ifdef TFM_CRYPTO_HASH_MODULE_DISABLED
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status;
    struct tfm_crypto_pack_iovec iov = {
 c03c206:	2228      	movs	r2, #40	@ 0x28
 c03c208:	2100      	movs	r1, #0
 c03c20a:	a808      	add	r0, sp, #32
 c03c20c:	f01f fa8f 	bl	c05b72e <memset>
 c03c210:	230c      	movs	r3, #12
 c03c212:	9307      	str	r3, [sp, #28]
 c03c214:	6823      	ldr	r3, [r4, #0]
    psa_outvec out_vec[] = {
        {.base = &(operation->handle), .len = sizeof(uint32_t)},
    };

#ifdef TFM_PSA_API
    PSA_CONNECT(TFM_CRYPTO);
 c03c216:	2101      	movs	r1, #1
    struct tfm_crypto_pack_iovec iov = {
 c03c218:	930b      	str	r3, [sp, #44]	@ 0x2c
    psa_invec in_vec[] = {
 c03c21a:	ab07      	add	r3, sp, #28
 c03c21c:	9303      	str	r3, [sp, #12]
 c03c21e:	232c      	movs	r3, #44	@ 0x2c
    psa_outvec out_vec[] = {
 c03c220:	e9cd 3404 	strd	r3, r4, [sp, #16]
 c03c224:	2304      	movs	r3, #4
    PSA_CONNECT(TFM_CRYPTO);
 c03c226:	2080      	movs	r0, #128	@ 0x80
    struct tfm_crypto_pack_iovec iov = {
 c03c228:	950a      	str	r5, [sp, #40]	@ 0x28
    psa_outvec out_vec[] = {
 c03c22a:	9306      	str	r3, [sp, #24]
    PSA_CONNECT(TFM_CRYPTO);
 c03c22c:	f000 fadc 	bl	c03c7e8 <psa_connect>
 c03c230:	1e05      	subs	r5, r0, #0
 c03c232:	dd0e      	ble.n	c03c252 <psa_hash_setup+0x54>
#endif

    status = API_DISPATCH(tfm_crypto_hash_setup,
 c03c234:	2301      	movs	r3, #1
 c03c236:	aa05      	add	r2, sp, #20
 c03c238:	9200      	str	r2, [sp, #0]
 c03c23a:	2100      	movs	r1, #0
 c03c23c:	9301      	str	r3, [sp, #4]
 c03c23e:	aa03      	add	r2, sp, #12
 c03c240:	f000 fad4 	bl	c03c7ec <psa_call>
 c03c244:	4604      	mov	r4, r0
                          TFM_CRYPTO_HASH_SETUP);

#ifdef TFM_PSA_API
    PSA_CLOSE();
 c03c246:	4628      	mov	r0, r5
 c03c248:	f000 fadc 	bl	c03c804 <psa_close>
#endif

    return status;
#endif /* TFM_CRYPTO_HASH_MODULE_DISABLED */
}
 c03c24c:	4620      	mov	r0, r4
 c03c24e:	b013      	add	sp, #76	@ 0x4c
 c03c250:	bd30      	pop	{r4, r5, pc}
    PSA_CONNECT(TFM_CRYPTO);
 c03c252:	f06f 0483 	mvn.w	r4, #131	@ 0x83
 c03c256:	e7f9      	b.n	c03c24c <psa_hash_setup+0x4e>

0c03c258 <psa_hash_update>:

psa_status_t psa_hash_update(psa_hash_operation_t *operation,
                             const uint8_t *input,
                             size_t input_length)
{
 c03c258:	b570      	push	{r4, r5, r6, lr}
 c03c25a:	4615      	mov	r5, r2
#ifdef TFM_CRYPTO_HASH_MODULE_DISABLED
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status;
    struct tfm_crypto_pack_iovec iov = {
 c03c25c:	2228      	movs	r2, #40	@ 0x28
{
 c03c25e:	b094      	sub	sp, #80	@ 0x50
 c03c260:	4604      	mov	r4, r0
 c03c262:	460e      	mov	r6, r1
    struct tfm_crypto_pack_iovec iov = {
 c03c264:	eb0d 0002 	add.w	r0, sp, r2
 c03c268:	2100      	movs	r1, #0
 c03c26a:	f01f fa60 	bl	c05b72e <memset>
 c03c26e:	230d      	movs	r3, #13
 c03c270:	9309      	str	r3, [sp, #36]	@ 0x24
 c03c272:	6823      	ldr	r3, [r4, #0]
    psa_outvec out_vec[] = {
        {.base = &(operation->handle), .len = sizeof(uint32_t)},
    };

#ifdef TFM_PSA_API
    PSA_CONNECT(TFM_CRYPTO);
 c03c274:	2101      	movs	r1, #1
    struct tfm_crypto_pack_iovec iov = {
 c03c276:	930d      	str	r3, [sp, #52]	@ 0x34
    psa_invec in_vec[] = {
 c03c278:	ab09      	add	r3, sp, #36	@ 0x24
 c03c27a:	9305      	str	r3, [sp, #20]
 c03c27c:	232c      	movs	r3, #44	@ 0x2c
 c03c27e:	e9cd 3606 	strd	r3, r6, [sp, #24]
    psa_outvec out_vec[] = {
 c03c282:	2304      	movs	r3, #4
    PSA_CONNECT(TFM_CRYPTO);
 c03c284:	2080      	movs	r0, #128	@ 0x80
    psa_invec in_vec[] = {
 c03c286:	9508      	str	r5, [sp, #32]
    psa_outvec out_vec[] = {
 c03c288:	9403      	str	r4, [sp, #12]
 c03c28a:	9304      	str	r3, [sp, #16]
    PSA_CONNECT(TFM_CRYPTO);
 c03c28c:	f000 faac 	bl	c03c7e8 <psa_connect>
 c03c290:	1e05      	subs	r5, r0, #0
 c03c292:	dd0f      	ble.n	c03c2b4 <psa_hash_update+0x5c>
#endif

    status = API_DISPATCH(tfm_crypto_hash_update,
 c03c294:	2301      	movs	r3, #1
 c03c296:	9301      	str	r3, [sp, #4]
 c03c298:	ab03      	add	r3, sp, #12
 c03c29a:	9300      	str	r3, [sp, #0]
 c03c29c:	2100      	movs	r1, #0
 c03c29e:	2302      	movs	r3, #2
 c03c2a0:	aa05      	add	r2, sp, #20
 c03c2a2:	f000 faa3 	bl	c03c7ec <psa_call>
 c03c2a6:	4604      	mov	r4, r0
                          TFM_CRYPTO_HASH_UPDATE);

#ifdef TFM_PSA_API
    PSA_CLOSE();
 c03c2a8:	4628      	mov	r0, r5
 c03c2aa:	f000 faab 	bl	c03c804 <psa_close>
#endif

    return status;
#endif /* TFM_CRYPTO_HASH_MODULE_DISABLED */
}
 c03c2ae:	4620      	mov	r0, r4
 c03c2b0:	b014      	add	sp, #80	@ 0x50
 c03c2b2:	bd70      	pop	{r4, r5, r6, pc}
    PSA_CONNECT(TFM_CRYPTO);
 c03c2b4:	f06f 0483 	mvn.w	r4, #131	@ 0x83
 c03c2b8:	e7f9      	b.n	c03c2ae <psa_hash_update+0x56>

0c03c2ba <psa_hash_finish>:

psa_status_t psa_hash_finish(psa_hash_operation_t *operation,
                             uint8_t *hash,
                             size_t hash_size,
                             size_t *hash_length)
{
 c03c2ba:	b5f0      	push	{r4, r5, r6, r7, lr}
 c03c2bc:	4615      	mov	r5, r2
#ifdef TFM_CRYPTO_HASH_MODULE_DISABLED
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status;
    struct tfm_crypto_pack_iovec iov = {
 c03c2be:	2228      	movs	r2, #40	@ 0x28
{
 c03c2c0:	b095      	sub	sp, #84	@ 0x54
 c03c2c2:	4604      	mov	r4, r0
 c03c2c4:	460f      	mov	r7, r1
    struct tfm_crypto_pack_iovec iov = {
 c03c2c6:	eb0d 0002 	add.w	r0, sp, r2
 c03c2ca:	2100      	movs	r1, #0
{
 c03c2cc:	461e      	mov	r6, r3
    struct tfm_crypto_pack_iovec iov = {
 c03c2ce:	f01f fa2e 	bl	c05b72e <memset>
 c03c2d2:	230e      	movs	r3, #14
 c03c2d4:	9309      	str	r3, [sp, #36]	@ 0x24
 c03c2d6:	6823      	ldr	r3, [r4, #0]
        {.base = &(operation->handle), .len = sizeof(uint32_t)},
        {.base = hash, .len = hash_size},
    };

#ifdef TFM_PSA_API
    PSA_CONNECT(TFM_CRYPTO);
 c03c2d8:	2101      	movs	r1, #1
    struct tfm_crypto_pack_iovec iov = {
 c03c2da:	930d      	str	r3, [sp, #52]	@ 0x34
    psa_invec in_vec[] = {
 c03c2dc:	ab09      	add	r3, sp, #36	@ 0x24
 c03c2de:	9303      	str	r3, [sp, #12]
 c03c2e0:	232c      	movs	r3, #44	@ 0x2c
    psa_outvec out_vec[] = {
 c03c2e2:	e9cd 3404 	strd	r3, r4, [sp, #16]
 c03c2e6:	2304      	movs	r3, #4
    PSA_CONNECT(TFM_CRYPTO);
 c03c2e8:	2080      	movs	r0, #128	@ 0x80
    psa_outvec out_vec[] = {
 c03c2ea:	9508      	str	r5, [sp, #32]
 c03c2ec:	e9cd 3706 	strd	r3, r7, [sp, #24]
    PSA_CONNECT(TFM_CRYPTO);
 c03c2f0:	f000 fa7a 	bl	c03c7e8 <psa_connect>
 c03c2f4:	1e05      	subs	r5, r0, #0
 c03c2f6:	dd11      	ble.n	c03c31c <psa_hash_finish+0x62>
#endif

    status = API_DISPATCH(tfm_crypto_hash_finish,
 c03c2f8:	2302      	movs	r3, #2
 c03c2fa:	9301      	str	r3, [sp, #4]
 c03c2fc:	ab05      	add	r3, sp, #20
 c03c2fe:	9300      	str	r3, [sp, #0]
 c03c300:	2100      	movs	r1, #0
 c03c302:	2301      	movs	r3, #1
 c03c304:	aa03      	add	r2, sp, #12
 c03c306:	f000 fa71 	bl	c03c7ec <psa_call>
                          TFM_CRYPTO_HASH_FINISH);

    *hash_length = out_vec[1].len;
 c03c30a:	9b08      	ldr	r3, [sp, #32]
    status = API_DISPATCH(tfm_crypto_hash_finish,
 c03c30c:	4604      	mov	r4, r0
    *hash_length = out_vec[1].len;
 c03c30e:	6033      	str	r3, [r6, #0]

#ifdef TFM_PSA_API
    PSA_CLOSE();
 c03c310:	4628      	mov	r0, r5
 c03c312:	f000 fa77 	bl	c03c804 <psa_close>
#endif

    return status;
#endif /* TFM_CRYPTO_HASH_MODULE_DISABLED */
}
 c03c316:	4620      	mov	r0, r4
 c03c318:	b015      	add	sp, #84	@ 0x54
 c03c31a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    PSA_CONNECT(TFM_CRYPTO);
 c03c31c:	f06f 0483 	mvn.w	r4, #131	@ 0x83
 c03c320:	e7f9      	b.n	c03c316 <psa_hash_finish+0x5c>

0c03c322 <psa_aead_encrypt>:
                              const uint8_t *plaintext,
                              size_t plaintext_length,
                              uint8_t *ciphertext,
                              size_t ciphertext_size,
                              size_t *ciphertext_length)
{
 c03c322:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 c03c326:	b097      	sub	sp, #92	@ 0x5c
 c03c328:	4680      	mov	r8, r0
 c03c32a:	e9dd 691e 	ldrd	r6, r9, [sp, #120]	@ 0x78
 c03c32e:	460f      	mov	r7, r1
 c03c330:	4615      	mov	r5, r2
#ifdef TFM_CRYPTO_AEAD_MODULE_DISABLED
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status;
    struct tfm_crypto_pack_iovec iov = {
 c03c332:	2100      	movs	r1, #0
 c03c334:	2224      	movs	r2, #36	@ 0x24
 c03c336:	a80c      	add	r0, sp, #48	@ 0x30
{
 c03c338:	461c      	mov	r4, r3
    struct tfm_crypto_pack_iovec iov = {
 c03c33a:	f01f f9f8 	bl	c05b72e <memset>
 c03c33e:	2323      	movs	r3, #35	@ 0x23
 c03c340:	e9cd 870d 	strd	r8, r7, [sp, #52]	@ 0x34
 c03c344:	930b      	str	r3, [sp, #44]	@ 0x2c
 c03c346:	9415      	str	r4, [sp, #84]	@ 0x54
        .alg = alg,
        .aead_in = {.nonce = {0}, .nonce_length = nonce_length}
    };

    /* Sanitize the optional input */
    if ((additional_data == NULL) && (additional_data_length != 0)) {
 c03c348:	b946      	cbnz	r6, c03c35c <psa_aead_encrypt+0x3a>
 c03c34a:	f1b9 0f00 	cmp.w	r9, #0
 c03c34e:	d005      	beq.n	c03c35c <psa_aead_encrypt+0x3a>
        return PSA_ERROR_INVALID_ARGUMENT;
 c03c350:	f06f 0486 	mvn.w	r4, #134	@ 0x86
    PSA_CLOSE();
#endif

    return status;
#endif /* TFM_CRYPTO_AEAD_MODULE_DISABLED */
}
 c03c354:	4620      	mov	r0, r4
 c03c356:	b017      	add	sp, #92	@ 0x5c
 c03c358:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    psa_invec in_vec[] = {
 c03c35c:	ab0b      	add	r3, sp, #44	@ 0x2c
 c03c35e:	9305      	str	r3, [sp, #20]
 c03c360:	232c      	movs	r3, #44	@ 0x2c
 c03c362:	9306      	str	r3, [sp, #24]
 c03c364:	9b20      	ldr	r3, [sp, #128]	@ 0x80
    if (nonce_length > TFM_CRYPTO_MAX_NONCE_LENGTH) {
 c03c366:	2c10      	cmp	r4, #16
    psa_invec in_vec[] = {
 c03c368:	9307      	str	r3, [sp, #28]
 c03c36a:	9b21      	ldr	r3, [sp, #132]	@ 0x84
 c03c36c:	f8cd 9028 	str.w	r9, [sp, #40]	@ 0x28
 c03c370:	e9cd 3608 	strd	r3, r6, [sp, #32]
    psa_outvec out_vec[] = {
 c03c374:	9b22      	ldr	r3, [sp, #136]	@ 0x88
 c03c376:	9303      	str	r3, [sp, #12]
 c03c378:	9b23      	ldr	r3, [sp, #140]	@ 0x8c
 c03c37a:	9304      	str	r3, [sp, #16]
    if (nonce_length > TFM_CRYPTO_MAX_NONCE_LENGTH) {
 c03c37c:	d8e8      	bhi.n	c03c350 <psa_aead_encrypt+0x2e>
    if (nonce != NULL) {
 c03c37e:	b125      	cbz	r5, c03c38a <psa_aead_encrypt+0x68>
            iov.aead_in.nonce[idx] = nonce[idx];
 c03c380:	4622      	mov	r2, r4
 c03c382:	4629      	mov	r1, r5
 c03c384:	a811      	add	r0, sp, #68	@ 0x44
 c03c386:	f01f f961 	bl	c05b64c <memcpy>
    PSA_CONNECT(TFM_CRYPTO);
 c03c38a:	2101      	movs	r1, #1
 c03c38c:	2080      	movs	r0, #128	@ 0x80
 c03c38e:	f000 fa2b 	bl	c03c7e8 <psa_connect>
 c03c392:	1e05      	subs	r5, r0, #0
 c03c394:	dd13      	ble.n	c03c3be <psa_aead_encrypt+0x9c>
    status = psa_call(ipc_handle, PSA_IPC_CALL, in_vec, in_len,
 c03c396:	2301      	movs	r3, #1
    size_t in_len = ARRAY_SIZE(in_vec);
 c03c398:	2e00      	cmp	r6, #0
    status = psa_call(ipc_handle, PSA_IPC_CALL, in_vec, in_len,
 c03c39a:	9301      	str	r3, [sp, #4]
 c03c39c:	ab03      	add	r3, sp, #12
 c03c39e:	9300      	str	r3, [sp, #0]
 c03c3a0:	aa05      	add	r2, sp, #20
 c03c3a2:	bf0c      	ite	eq
 c03c3a4:	2302      	moveq	r3, #2
 c03c3a6:	2303      	movne	r3, #3
 c03c3a8:	2100      	movs	r1, #0
 c03c3aa:	f000 fa1f 	bl	c03c7ec <psa_call>
    *ciphertext_length = out_vec[0].len;
 c03c3ae:	9b24      	ldr	r3, [sp, #144]	@ 0x90
 c03c3b0:	9a04      	ldr	r2, [sp, #16]
    status = psa_call(ipc_handle, PSA_IPC_CALL, in_vec, in_len,
 c03c3b2:	4604      	mov	r4, r0
    *ciphertext_length = out_vec[0].len;
 c03c3b4:	601a      	str	r2, [r3, #0]
    PSA_CLOSE();
 c03c3b6:	4628      	mov	r0, r5
 c03c3b8:	f000 fa24 	bl	c03c804 <psa_close>
    return status;
 c03c3bc:	e7ca      	b.n	c03c354 <psa_aead_encrypt+0x32>
    PSA_CONNECT(TFM_CRYPTO);
 c03c3be:	f06f 0483 	mvn.w	r4, #131	@ 0x83
 c03c3c2:	e7c7      	b.n	c03c354 <psa_aead_encrypt+0x32>

0c03c3c4 <psa_aead_decrypt>:
                              const uint8_t *ciphertext,
                              size_t ciphertext_length,
                              uint8_t *plaintext,
                              size_t plaintext_size,
                              size_t *plaintext_length)
{
 c03c3c4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
#ifdef TFM_CRYPTO_AEAD_MODULE_DISABLED
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status;
    struct tfm_crypto_pack_iovec iov = {
 c03c3c8:	f04f 0a24 	mov.w	sl, #36	@ 0x24
{
 c03c3cc:	4680      	mov	r8, r0
 c03c3ce:	460f      	mov	r7, r1
 c03c3d0:	461c      	mov	r4, r3
 c03c3d2:	b096      	sub	sp, #88	@ 0x58
 c03c3d4:	4615      	mov	r5, r2
 c03c3d6:	e9dd 691e 	ldrd	r6, r9, [sp, #120]	@ 0x78
    struct tfm_crypto_pack_iovec iov = {
 c03c3da:	4652      	mov	r2, sl
 c03c3dc:	2100      	movs	r1, #0
 c03c3de:	a80c      	add	r0, sp, #48	@ 0x30
 c03c3e0:	f01f f9a5 	bl	c05b72e <memset>
 c03c3e4:	e9cd 870d 	strd	r8, r7, [sp, #52]	@ 0x34
 c03c3e8:	f8cd a02c 	str.w	sl, [sp, #44]	@ 0x2c
 c03c3ec:	9415      	str	r4, [sp, #84]	@ 0x54
        .alg = alg,
        .aead_in = {.nonce = {0}, .nonce_length = nonce_length}
    };

    /* Sanitize the optional input */
    if ((additional_data == NULL) && (additional_data_length != 0)) {
 c03c3ee:	b946      	cbnz	r6, c03c402 <psa_aead_decrypt+0x3e>
 c03c3f0:	f1b9 0f00 	cmp.w	r9, #0
 c03c3f4:	d005      	beq.n	c03c402 <psa_aead_decrypt+0x3e>
        return PSA_ERROR_INVALID_ARGUMENT;
 c03c3f6:	f06f 0486 	mvn.w	r4, #134	@ 0x86
    PSA_CLOSE();
#endif

    return status;
#endif /* TFM_CRYPTO_AEAD_MODULE_DISABLED */
}
 c03c3fa:	4620      	mov	r0, r4
 c03c3fc:	b016      	add	sp, #88	@ 0x58
 c03c3fe:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    psa_invec in_vec[] = {
 c03c402:	ab0b      	add	r3, sp, #44	@ 0x2c
 c03c404:	9305      	str	r3, [sp, #20]
 c03c406:	232c      	movs	r3, #44	@ 0x2c
 c03c408:	9306      	str	r3, [sp, #24]
 c03c40a:	9b20      	ldr	r3, [sp, #128]	@ 0x80
    if (nonce_length > TFM_CRYPTO_MAX_NONCE_LENGTH) {
 c03c40c:	2c10      	cmp	r4, #16
    psa_invec in_vec[] = {
 c03c40e:	9307      	str	r3, [sp, #28]
 c03c410:	9b21      	ldr	r3, [sp, #132]	@ 0x84
 c03c412:	f8cd 9028 	str.w	r9, [sp, #40]	@ 0x28
 c03c416:	e9cd 3608 	strd	r3, r6, [sp, #32]
    psa_outvec out_vec[] = {
 c03c41a:	9b22      	ldr	r3, [sp, #136]	@ 0x88
 c03c41c:	9303      	str	r3, [sp, #12]
 c03c41e:	9b23      	ldr	r3, [sp, #140]	@ 0x8c
 c03c420:	9304      	str	r3, [sp, #16]
    if (nonce_length > TFM_CRYPTO_MAX_NONCE_LENGTH) {
 c03c422:	d8e8      	bhi.n	c03c3f6 <psa_aead_decrypt+0x32>
    if (nonce != NULL) {
 c03c424:	b125      	cbz	r5, c03c430 <psa_aead_decrypt+0x6c>
            iov.aead_in.nonce[idx] = nonce[idx];
 c03c426:	4622      	mov	r2, r4
 c03c428:	4629      	mov	r1, r5
 c03c42a:	a811      	add	r0, sp, #68	@ 0x44
 c03c42c:	f01f f90e 	bl	c05b64c <memcpy>
    PSA_CONNECT(TFM_CRYPTO);
 c03c430:	2101      	movs	r1, #1
 c03c432:	2080      	movs	r0, #128	@ 0x80
 c03c434:	f000 f9d8 	bl	c03c7e8 <psa_connect>
 c03c438:	1e05      	subs	r5, r0, #0
 c03c43a:	dd13      	ble.n	c03c464 <psa_aead_decrypt+0xa0>
    status = psa_call(ipc_handle, PSA_IPC_CALL, in_vec, in_len,
 c03c43c:	2301      	movs	r3, #1
    size_t in_len = ARRAY_SIZE(in_vec);
 c03c43e:	2e00      	cmp	r6, #0
    status = psa_call(ipc_handle, PSA_IPC_CALL, in_vec, in_len,
 c03c440:	9301      	str	r3, [sp, #4]
 c03c442:	ab03      	add	r3, sp, #12
 c03c444:	9300      	str	r3, [sp, #0]
 c03c446:	aa05      	add	r2, sp, #20
 c03c448:	bf0c      	ite	eq
 c03c44a:	2302      	moveq	r3, #2
 c03c44c:	2303      	movne	r3, #3
 c03c44e:	2100      	movs	r1, #0
 c03c450:	f000 f9cc 	bl	c03c7ec <psa_call>
    *plaintext_length = out_vec[0].len;
 c03c454:	9b24      	ldr	r3, [sp, #144]	@ 0x90
 c03c456:	9a04      	ldr	r2, [sp, #16]
    status = psa_call(ipc_handle, PSA_IPC_CALL, in_vec, in_len,
 c03c458:	4604      	mov	r4, r0
    *plaintext_length = out_vec[0].len;
 c03c45a:	601a      	str	r2, [r3, #0]
    PSA_CLOSE();
 c03c45c:	4628      	mov	r0, r5
 c03c45e:	f000 f9d1 	bl	c03c804 <psa_close>
    return status;
 c03c462:	e7ca      	b.n	c03c3fa <psa_aead_decrypt+0x36>
    PSA_CONNECT(TFM_CRYPTO);
 c03c464:	f06f 0483 	mvn.w	r4, #131	@ 0x83
 c03c468:	e7c7      	b.n	c03c3fa <psa_aead_decrypt+0x36>

0c03c46a <psa_sign_hash>:
                           const uint8_t *hash,
                           size_t hash_length,
                           uint8_t *signature,
                           size_t signature_size,
                           size_t *signature_length)
{
 c03c46a:	b5f0      	push	{r4, r5, r6, r7, lr}
 c03c46c:	4615      	mov	r5, r2
#ifdef TFM_CRYPTO_ASYMMETRIC_MODULE_DISABLED
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status;
    struct tfm_crypto_pack_iovec iov = {
 c03c46e:	2228      	movs	r2, #40	@ 0x28
{
 c03c470:	b095      	sub	sp, #84	@ 0x54
 c03c472:	4607      	mov	r7, r0
 c03c474:	460e      	mov	r6, r1
    struct tfm_crypto_pack_iovec iov = {
 c03c476:	eb0d 0002 	add.w	r0, sp, r2
 c03c47a:	2100      	movs	r1, #0
{
 c03c47c:	461c      	mov	r4, r3
    struct tfm_crypto_pack_iovec iov = {
 c03c47e:	f01f f956 	bl	c05b72e <memset>
 c03c482:	232f      	movs	r3, #47	@ 0x2f
 c03c484:	9309      	str	r3, [sp, #36]	@ 0x24
        .sfn_id = TFM_CRYPTO_SIGN_HASH_SID,
        .key_id = key_id,
        .alg = alg,
    };

    psa_invec in_vec[] = {
 c03c486:	ab09      	add	r3, sp, #36	@ 0x24
 c03c488:	9305      	str	r3, [sp, #20]
 c03c48a:	232c      	movs	r3, #44	@ 0x2c
 c03c48c:	e9cd 3506 	strd	r3, r5, [sp, #24]
        {.base = &iov, .len = sizeof(struct tfm_crypto_pack_iovec)},
        {.base = hash, .len = hash_length},
    };
    psa_outvec out_vec[] = {
 c03c490:	9b1a      	ldr	r3, [sp, #104]	@ 0x68
        {.base = signature, .len = signature_size},
    };

#ifdef TFM_PSA_API
    PSA_CONNECT(TFM_CRYPTO);
 c03c492:	2101      	movs	r1, #1
    psa_outvec out_vec[] = {
 c03c494:	9303      	str	r3, [sp, #12]
 c03c496:	9b1b      	ldr	r3, [sp, #108]	@ 0x6c
    PSA_CONNECT(TFM_CRYPTO);
 c03c498:	2080      	movs	r0, #128	@ 0x80
    struct tfm_crypto_pack_iovec iov = {
 c03c49a:	e9cd 760b 	strd	r7, r6, [sp, #44]	@ 0x2c
    psa_invec in_vec[] = {
 c03c49e:	9408      	str	r4, [sp, #32]
    psa_outvec out_vec[] = {
 c03c4a0:	9304      	str	r3, [sp, #16]
    PSA_CONNECT(TFM_CRYPTO);
 c03c4a2:	f000 f9a1 	bl	c03c7e8 <psa_connect>
 c03c4a6:	1e05      	subs	r5, r0, #0
 c03c4a8:	dd12      	ble.n	c03c4d0 <psa_sign_hash+0x66>
#endif
    status = API_DISPATCH(tfm_crypto_sign_hash,
 c03c4aa:	2301      	movs	r3, #1
 c03c4ac:	9301      	str	r3, [sp, #4]
 c03c4ae:	ab03      	add	r3, sp, #12
 c03c4b0:	9300      	str	r3, [sp, #0]
 c03c4b2:	aa05      	add	r2, sp, #20
 c03c4b4:	2302      	movs	r3, #2
 c03c4b6:	2100      	movs	r1, #0
 c03c4b8:	f000 f998 	bl	c03c7ec <psa_call>
                          TFM_CRYPTO_SIGN_HASH);

    *signature_length = out_vec[0].len;
 c03c4bc:	9b1c      	ldr	r3, [sp, #112]	@ 0x70
 c03c4be:	9a04      	ldr	r2, [sp, #16]
    status = API_DISPATCH(tfm_crypto_sign_hash,
 c03c4c0:	4604      	mov	r4, r0
    *signature_length = out_vec[0].len;
 c03c4c2:	601a      	str	r2, [r3, #0]

#ifdef TFM_PSA_API
    PSA_CLOSE();
 c03c4c4:	4628      	mov	r0, r5
 c03c4c6:	f000 f99d 	bl	c03c804 <psa_close>
#endif

    return status;
#endif /* TFM_CRYPTO_ASYMMETRIC_MODULE_DISABLED */
}
 c03c4ca:	4620      	mov	r0, r4
 c03c4cc:	b015      	add	sp, #84	@ 0x54
 c03c4ce:	bdf0      	pop	{r4, r5, r6, r7, pc}
    PSA_CONNECT(TFM_CRYPTO);
 c03c4d0:	f06f 0483 	mvn.w	r4, #131	@ 0x83
 c03c4d4:	e7f9      	b.n	c03c4ca <psa_sign_hash+0x60>

0c03c4d6 <psa_key_derivation_abort>:
    return status;
#endif /* TFM_CRYPTO_GENERATOR_MODULE_DISABLED */
}

psa_status_t psa_key_derivation_abort(psa_key_derivation_operation_t *operation)
{
 c03c4d6:	b530      	push	{r4, r5, lr}
 c03c4d8:	b093      	sub	sp, #76	@ 0x4c
 c03c4da:	4604      	mov	r4, r0
#ifdef TFM_CRYPTO_GENERATOR_MODULE_DISABLED
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status;
    struct tfm_crypto_pack_iovec iov = {
 c03c4dc:	2228      	movs	r2, #40	@ 0x28
 c03c4de:	2100      	movs	r1, #0
 c03c4e0:	a808      	add	r0, sp, #32
 c03c4e2:	f01f f924 	bl	c05b72e <memset>
 c03c4e6:	233b      	movs	r3, #59	@ 0x3b
 c03c4e8:	9307      	str	r3, [sp, #28]
 c03c4ea:	6823      	ldr	r3, [r4, #0]
    psa_outvec out_vec[] = {
        {.base = &(operation->handle), .len = sizeof(uint32_t)},
    };

#ifdef TFM_PSA_API
    PSA_CONNECT(TFM_CRYPTO);
 c03c4ec:	2101      	movs	r1, #1
    struct tfm_crypto_pack_iovec iov = {
 c03c4ee:	930b      	str	r3, [sp, #44]	@ 0x2c
    psa_invec in_vec[] = {
 c03c4f0:	ab07      	add	r3, sp, #28
 c03c4f2:	9303      	str	r3, [sp, #12]
 c03c4f4:	232c      	movs	r3, #44	@ 0x2c
    psa_outvec out_vec[] = {
 c03c4f6:	e9cd 3404 	strd	r3, r4, [sp, #16]
 c03c4fa:	2304      	movs	r3, #4
    PSA_CONNECT(TFM_CRYPTO);
 c03c4fc:	2080      	movs	r0, #128	@ 0x80
    psa_outvec out_vec[] = {
 c03c4fe:	9306      	str	r3, [sp, #24]
    PSA_CONNECT(TFM_CRYPTO);
 c03c500:	f000 f972 	bl	c03c7e8 <psa_connect>
 c03c504:	1e05      	subs	r5, r0, #0
 c03c506:	dd0e      	ble.n	c03c526 <psa_key_derivation_abort+0x50>
#endif

    status = API_DISPATCH(tfm_crypto_key_derivation_abort,
 c03c508:	2301      	movs	r3, #1
 c03c50a:	aa05      	add	r2, sp, #20
 c03c50c:	9200      	str	r2, [sp, #0]
 c03c50e:	2100      	movs	r1, #0
 c03c510:	9301      	str	r3, [sp, #4]
 c03c512:	aa03      	add	r2, sp, #12
 c03c514:	f000 f96a 	bl	c03c7ec <psa_call>
 c03c518:	4604      	mov	r4, r0
                          TFM_CRYPTO_KEY_DERIVATION_ABORT);
#ifdef TFM_PSA_API
    PSA_CLOSE();
 c03c51a:	4628      	mov	r0, r5
 c03c51c:	f000 f972 	bl	c03c804 <psa_close>
#endif

    return status;
#endif /* TFM_CRYPTO_GENERATOR_MODULE_DISABLED */
}
 c03c520:	4620      	mov	r0, r4
 c03c522:	b013      	add	sp, #76	@ 0x4c
 c03c524:	bd30      	pop	{r4, r5, pc}
    PSA_CONNECT(TFM_CRYPTO);
 c03c526:	f06f 0483 	mvn.w	r4, #131	@ 0x83
 c03c52a:	e7f9      	b.n	c03c520 <psa_key_derivation_abort+0x4a>

0c03c52c <psa_key_derivation_setup>:
#endif /* TFM_CRYPTO_GENERATOR_MODULE_DISABLED */
}

psa_status_t psa_key_derivation_setup(psa_key_derivation_operation_t *operation,
                                      psa_algorithm_t alg)
{
 c03c52c:	b530      	push	{r4, r5, lr}
 c03c52e:	b093      	sub	sp, #76	@ 0x4c
 c03c530:	4604      	mov	r4, r0
 c03c532:	460d      	mov	r5, r1
#ifdef TFM_CRYPTO_GENERATOR_MODULE_DISABLED
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status;
    struct tfm_crypto_pack_iovec iov = {
 c03c534:	2228      	movs	r2, #40	@ 0x28
 c03c536:	2100      	movs	r1, #0
 c03c538:	a808      	add	r0, sp, #32
 c03c53a:	f01f f8f8 	bl	c05b72e <memset>
 c03c53e:	2333      	movs	r3, #51	@ 0x33
 c03c540:	9307      	str	r3, [sp, #28]
 c03c542:	6823      	ldr	r3, [r4, #0]
    psa_outvec out_vec[] = {
        {.base = &(operation->handle), .len = sizeof(uint32_t)},
    };

#ifdef TFM_PSA_API
    PSA_CONNECT(TFM_CRYPTO);
 c03c544:	2101      	movs	r1, #1
    struct tfm_crypto_pack_iovec iov = {
 c03c546:	930b      	str	r3, [sp, #44]	@ 0x2c
    psa_invec in_vec[] = {
 c03c548:	ab07      	add	r3, sp, #28
 c03c54a:	9303      	str	r3, [sp, #12]
 c03c54c:	232c      	movs	r3, #44	@ 0x2c
    psa_outvec out_vec[] = {
 c03c54e:	e9cd 3404 	strd	r3, r4, [sp, #16]
 c03c552:	2304      	movs	r3, #4
    PSA_CONNECT(TFM_CRYPTO);
 c03c554:	2080      	movs	r0, #128	@ 0x80
    struct tfm_crypto_pack_iovec iov = {
 c03c556:	950a      	str	r5, [sp, #40]	@ 0x28
    psa_outvec out_vec[] = {
 c03c558:	9306      	str	r3, [sp, #24]
    PSA_CONNECT(TFM_CRYPTO);
 c03c55a:	f000 f945 	bl	c03c7e8 <psa_connect>
 c03c55e:	1e05      	subs	r5, r0, #0
 c03c560:	dd0e      	ble.n	c03c580 <psa_key_derivation_setup+0x54>
#endif

    status = API_DISPATCH(tfm_crypto_key_derivation_setup,
 c03c562:	2301      	movs	r3, #1
 c03c564:	aa05      	add	r2, sp, #20
 c03c566:	9200      	str	r2, [sp, #0]
 c03c568:	2100      	movs	r1, #0
 c03c56a:	9301      	str	r3, [sp, #4]
 c03c56c:	aa03      	add	r2, sp, #12
 c03c56e:	f000 f93d 	bl	c03c7ec <psa_call>
 c03c572:	4604      	mov	r4, r0
                          TFM_CRYPTO_KEY_DERIVATION_SETUP);
#ifdef TFM_PSA_API
    PSA_CLOSE();
 c03c574:	4628      	mov	r0, r5
 c03c576:	f000 f945 	bl	c03c804 <psa_close>
#endif

    return status;
#endif /* TFM_CRYPTO_GENERATOR_MODULE_DISABLED */
}
 c03c57a:	4620      	mov	r0, r4
 c03c57c:	b013      	add	sp, #76	@ 0x4c
 c03c57e:	bd30      	pop	{r4, r5, pc}
    PSA_CONNECT(TFM_CRYPTO);
 c03c580:	f06f 0483 	mvn.w	r4, #131	@ 0x83
 c03c584:	e7f9      	b.n	c03c57a <psa_key_derivation_setup+0x4e>

0c03c586 <psa_key_derivation_input_bytes>:
psa_status_t psa_key_derivation_input_bytes(
                                      psa_key_derivation_operation_t *operation,
                                      psa_key_derivation_step_t step,
                                      const uint8_t *data,
                                      size_t data_length)
{
 c03c586:	b5f0      	push	{r4, r5, r6, r7, lr}
 c03c588:	b093      	sub	sp, #76	@ 0x4c
 c03c58a:	4615      	mov	r5, r2
 c03c58c:	4606      	mov	r6, r0
 c03c58e:	460f      	mov	r7, r1
#if (TFM_CRYPTO_GENERATOR_MODULE_DISABLED != 0)
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status;
    struct tfm_crypto_pack_iovec iov = {
 c03c590:	2226      	movs	r2, #38	@ 0x26
 c03c592:	2100      	movs	r1, #0
 c03c594:	f10d 0022 	add.w	r0, sp, #34	@ 0x22
{
 c03c598:	461c      	mov	r4, r3
    struct tfm_crypto_pack_iovec iov = {
 c03c59a:	f01f f8c8 	bl	c05b72e <memset>
 c03c59e:	2336      	movs	r3, #54	@ 0x36
 c03c5a0:	9307      	str	r3, [sp, #28]
 c03c5a2:	6833      	ldr	r3, [r6, #0]
        {.base = &iov, .len = sizeof(struct tfm_crypto_pack_iovec)},
        {.base = data, .len = data_length},
    };

#ifdef TFM_PSA_API
    PSA_CONNECT(TFM_CRYPTO);
 c03c5a4:	2101      	movs	r1, #1
    struct tfm_crypto_pack_iovec iov = {
 c03c5a6:	930b      	str	r3, [sp, #44]	@ 0x2c
    psa_invec in_vec[] = {
 c03c5a8:	ab07      	add	r3, sp, #28
 c03c5aa:	9303      	str	r3, [sp, #12]
 c03c5ac:	232c      	movs	r3, #44	@ 0x2c
    PSA_CONNECT(TFM_CRYPTO);
 c03c5ae:	2080      	movs	r0, #128	@ 0x80
    psa_invec in_vec[] = {
 c03c5b0:	e9cd 3504 	strd	r3, r5, [sp, #16]
    struct tfm_crypto_pack_iovec iov = {
 c03c5b4:	f8ad 7020 	strh.w	r7, [sp, #32]
    psa_invec in_vec[] = {
 c03c5b8:	9406      	str	r4, [sp, #24]
    PSA_CONNECT(TFM_CRYPTO);
 c03c5ba:	f000 f915 	bl	c03c7e8 <psa_connect>
 c03c5be:	1e05      	subs	r5, r0, #0
 c03c5c0:	dd0d      	ble.n	c03c5de <psa_key_derivation_input_bytes+0x58>
#endif

    status = API_DISPATCH_NO_OUTVEC(tfm_crypto_key_derivation_input_bytes,
 c03c5c2:	2100      	movs	r1, #0
 c03c5c4:	2302      	movs	r3, #2
 c03c5c6:	e9cd 1100 	strd	r1, r1, [sp]
 c03c5ca:	aa03      	add	r2, sp, #12
 c03c5cc:	f000 f90e 	bl	c03c7ec <psa_call>
 c03c5d0:	4604      	mov	r4, r0
                                    TFM_CRYPTO_KEY_DERIVATION_INPUT_BYTES);
#ifdef TFM_PSA_API
    PSA_CLOSE();
 c03c5d2:	4628      	mov	r0, r5
 c03c5d4:	f000 f916 	bl	c03c804 <psa_close>
#endif

    return status;
#endif /* TFM_CRYPTO_GENERATOR_MODULE_DISABLED */
}
 c03c5d8:	4620      	mov	r0, r4
 c03c5da:	b013      	add	sp, #76	@ 0x4c
 c03c5dc:	bdf0      	pop	{r4, r5, r6, r7, pc}
    PSA_CONNECT(TFM_CRYPTO);
 c03c5de:	f06f 0483 	mvn.w	r4, #131	@ 0x83
 c03c5e2:	e7f9      	b.n	c03c5d8 <psa_key_derivation_input_bytes+0x52>

0c03c5e4 <psa_key_derivation_output_key>:

psa_status_t psa_key_derivation_output_key(
                                      const psa_key_attributes_t *attributes,
                                      psa_key_derivation_operation_t *operation,
                                      psa_key_id_t *key_id)
{
 c03c5e4:	b570      	push	{r4, r5, r6, lr}
 c03c5e6:	4614      	mov	r4, r2
#if (TFM_CRYPTO_GENERATOR_MODULE_DISABLED != 0)
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status;
    struct tfm_crypto_pack_iovec iov = {
 c03c5e8:	2228      	movs	r2, #40	@ 0x28
{
 c03c5ea:	b094      	sub	sp, #80	@ 0x50
 c03c5ec:	4605      	mov	r5, r0
 c03c5ee:	460e      	mov	r6, r1
    struct tfm_crypto_pack_iovec iov = {
 c03c5f0:	eb0d 0002 	add.w	r0, sp, r2
 c03c5f4:	2100      	movs	r1, #0
 c03c5f6:	f01f f89a 	bl	c05b72e <memset>
 c03c5fa:	233a      	movs	r3, #58	@ 0x3a
 c03c5fc:	9309      	str	r3, [sp, #36]	@ 0x24
 c03c5fe:	6833      	ldr	r3, [r6, #0]
    psa_outvec out_vec[] = {
        {.base = key_id, .len = sizeof(psa_key_id_t)}
    };

#ifdef TFM_PSA_API
    PSA_CONNECT(TFM_CRYPTO);
 c03c600:	2101      	movs	r1, #1
    struct tfm_crypto_pack_iovec iov = {
 c03c602:	930d      	str	r3, [sp, #52]	@ 0x34
    psa_invec in_vec[] = {
 c03c604:	ab09      	add	r3, sp, #36	@ 0x24
 c03c606:	9305      	str	r3, [sp, #20]
 c03c608:	232c      	movs	r3, #44	@ 0x2c
 c03c60a:	e9cd 3506 	strd	r3, r5, [sp, #24]
 c03c60e:	2318      	movs	r3, #24
 c03c610:	9308      	str	r3, [sp, #32]
    psa_outvec out_vec[] = {
 c03c612:	2304      	movs	r3, #4
    PSA_CONNECT(TFM_CRYPTO);
 c03c614:	2080      	movs	r0, #128	@ 0x80
    psa_outvec out_vec[] = {
 c03c616:	9403      	str	r4, [sp, #12]
 c03c618:	9304      	str	r3, [sp, #16]
    PSA_CONNECT(TFM_CRYPTO);
 c03c61a:	f000 f8e5 	bl	c03c7e8 <psa_connect>
 c03c61e:	1e05      	subs	r5, r0, #0
 c03c620:	dd0f      	ble.n	c03c642 <psa_key_derivation_output_key+0x5e>
#endif

    status = API_DISPATCH(tfm_crypto_key_derivation_output_key,
 c03c622:	2301      	movs	r3, #1
 c03c624:	9301      	str	r3, [sp, #4]
 c03c626:	ab03      	add	r3, sp, #12
 c03c628:	9300      	str	r3, [sp, #0]
 c03c62a:	2100      	movs	r1, #0
 c03c62c:	2302      	movs	r3, #2
 c03c62e:	aa05      	add	r2, sp, #20
 c03c630:	f000 f8dc 	bl	c03c7ec <psa_call>
 c03c634:	4604      	mov	r4, r0
                          TFM_CRYPTO_KEY_DERIVATION_OUTPUT_KEY);
#ifdef TFM_PSA_API
    PSA_CLOSE();
 c03c636:	4628      	mov	r0, r5
 c03c638:	f000 f8e4 	bl	c03c804 <psa_close>
#endif

    return status;
#endif /* TFM_CRYPTO_GENERATOR_MODULE_DISABLED */
}
 c03c63c:	4620      	mov	r0, r4
 c03c63e:	b014      	add	sp, #80	@ 0x50
 c03c640:	bd70      	pop	{r4, r5, r6, pc}
    PSA_CONNECT(TFM_CRYPTO);
 c03c642:	f06f 0483 	mvn.w	r4, #131	@ 0x83
 c03c646:	e7f9      	b.n	c03c63c <psa_key_derivation_output_key+0x58>

0c03c648 <psa_its_set>:

psa_status_t psa_its_set(psa_storage_uid_t uid,
                         size_t data_length,
                         const void *p_data,
                         psa_storage_create_flags_t create_flags)
{
 c03c648:	b530      	push	{r4, r5, lr}
 c03c64a:	b08b      	sub	sp, #44	@ 0x2c
 c03c64c:	e9cd 0102 	strd	r0, r1, [sp, #8]
    psa_status_t status;
#ifdef TFM_PSA_API
    psa_handle_t handle;
#endif

    psa_invec in_vec[] = {
 c03c650:	a902      	add	r1, sp, #8
 c03c652:	9104      	str	r1, [sp, #16]
 c03c654:	2108      	movs	r1, #8
 c03c656:	e9cd 1305 	strd	r1, r3, [sp, #20]
 c03c65a:	ab0e      	add	r3, sp, #56	@ 0x38
 c03c65c:	9308      	str	r3, [sp, #32]
 c03c65e:	2304      	movs	r3, #4
        { .base = p_data, .len = data_length },
        { .base = &create_flags, .len = sizeof(create_flags) }
    };

#ifdef TFM_PSA_API
    handle = psa_connect(TFM_ITS_SET_SID, TFM_ITS_SET_VERSION);
 c03c660:	2101      	movs	r1, #1
 c03c662:	2070      	movs	r0, #112	@ 0x70
    psa_invec in_vec[] = {
 c03c664:	9207      	str	r2, [sp, #28]
 c03c666:	9309      	str	r3, [sp, #36]	@ 0x24
    handle = psa_connect(TFM_ITS_SET_SID, TFM_ITS_SET_VERSION);
 c03c668:	f000 f8be 	bl	c03c7e8 <psa_connect>
    if (!PSA_HANDLE_IS_VALID(handle)) {
 c03c66c:	1e05      	subs	r5, r0, #0
 c03c66e:	dd0d      	ble.n	c03c68c <psa_its_set+0x44>
        return PSA_ERROR_GENERIC_ERROR;
    }

    status = psa_call(handle, PSA_IPC_CALL, in_vec, IOVEC_LEN(in_vec), NULL, 0);
 c03c670:	2100      	movs	r1, #0
 c03c672:	2303      	movs	r3, #3
 c03c674:	e9cd 1100 	strd	r1, r1, [sp]
 c03c678:	aa04      	add	r2, sp, #16
 c03c67a:	f000 f8b7 	bl	c03c7ec <psa_call>
 c03c67e:	4604      	mov	r4, r0

    psa_close(handle);
 c03c680:	4628      	mov	r0, r5
 c03c682:	f000 f8bf 	bl	c03c804 <psa_close>
        return PSA_ERROR_INVALID_ARGUMENT;
    }
#endif

    return status;
}
 c03c686:	4620      	mov	r0, r4
 c03c688:	b00b      	add	sp, #44	@ 0x2c
 c03c68a:	bd30      	pop	{r4, r5, pc}
        return PSA_ERROR_GENERIC_ERROR;
 c03c68c:	f06f 0483 	mvn.w	r4, #131	@ 0x83
 c03c690:	e7f9      	b.n	c03c686 <psa_its_set+0x3e>

0c03c692 <psa_its_get>:
psa_status_t psa_its_get(psa_storage_uid_t uid,
                         size_t data_offset,
                         size_t data_size,
                         void *p_data,
                         size_t *p_data_length)
{
 c03c692:	b570      	push	{r4, r5, r6, lr}
 c03c694:	b08c      	sub	sp, #48	@ 0x30
 c03c696:	9203      	str	r2, [sp, #12]
    psa_status_t status;
#ifdef TFM_PSA_API
    psa_handle_t handle;
#endif

    psa_invec in_vec[] = {
 c03c698:	aa04      	add	r2, sp, #16
 c03c69a:	9208      	str	r2, [sp, #32]
 c03c69c:	2208      	movs	r2, #8
 c03c69e:	9209      	str	r2, [sp, #36]	@ 0x24
 c03c6a0:	aa03      	add	r2, sp, #12
 c03c6a2:	920a      	str	r2, [sp, #40]	@ 0x28
 c03c6a4:	2204      	movs	r2, #4
{
 c03c6a6:	9e11      	ldr	r6, [sp, #68]	@ 0x44
    psa_invec in_vec[] = {
 c03c6a8:	920b      	str	r2, [sp, #44]	@ 0x2c
        { .base = &uid, .len = sizeof(uid) },
        { .base = &data_offset, .len = sizeof(data_offset) }
    };

    psa_outvec out_vec[] = {
 c03c6aa:	9a10      	ldr	r2, [sp, #64]	@ 0x40
{
 c03c6ac:	e9cd 0104 	strd	r0, r1, [sp, #16]
    psa_outvec out_vec[] = {
 c03c6b0:	e9cd 2306 	strd	r2, r3, [sp, #24]
        { .base = p_data, .len = data_size }
    };

    if (p_data_length == NULL) {
 c03c6b4:	b1be      	cbz	r6, c03c6e6 <psa_its_get+0x54>
        return PSA_ERROR_INVALID_ARGUMENT;
    }

#ifdef TFM_PSA_API
    handle = psa_connect(TFM_ITS_GET_SID, TFM_ITS_GET_VERSION);
 c03c6b6:	2101      	movs	r1, #1
 c03c6b8:	2071      	movs	r0, #113	@ 0x71
 c03c6ba:	f000 f895 	bl	c03c7e8 <psa_connect>
    if (!PSA_HANDLE_IS_VALID(handle)) {
 c03c6be:	1e05      	subs	r5, r0, #0
 c03c6c0:	dd14      	ble.n	c03c6ec <psa_its_get+0x5a>
        return PSA_ERROR_GENERIC_ERROR;
    }

    status = psa_call(handle, PSA_IPC_CALL, in_vec, IOVEC_LEN(in_vec), out_vec,
 c03c6c2:	2301      	movs	r3, #1
 c03c6c4:	9301      	str	r3, [sp, #4]
 c03c6c6:	ab06      	add	r3, sp, #24
 c03c6c8:	2100      	movs	r1, #0
 c03c6ca:	9300      	str	r3, [sp, #0]
 c03c6cc:	aa08      	add	r2, sp, #32
 c03c6ce:	2302      	movs	r3, #2
 c03c6d0:	f000 f88c 	bl	c03c7ec <psa_call>
 c03c6d4:	4604      	mov	r4, r0
                      IOVEC_LEN(out_vec));

    psa_close(handle);
 c03c6d6:	4628      	mov	r0, r5
 c03c6d8:	f000 f894 	bl	c03c804 <psa_close>
     */
    if (status == (psa_status_t)TFM_ERROR_INVALID_PARAMETER) {
        return PSA_ERROR_INVALID_ARGUMENT;
    }
#endif
    *p_data_length = out_vec[0].len;
 c03c6dc:	9b07      	ldr	r3, [sp, #28]
 c03c6de:	6033      	str	r3, [r6, #0]

    return status;
}
 c03c6e0:	4620      	mov	r0, r4
 c03c6e2:	b00c      	add	sp, #48	@ 0x30
 c03c6e4:	bd70      	pop	{r4, r5, r6, pc}
        return PSA_ERROR_INVALID_ARGUMENT;
 c03c6e6:	f06f 0486 	mvn.w	r4, #134	@ 0x86
 c03c6ea:	e7f9      	b.n	c03c6e0 <psa_its_get+0x4e>
        return PSA_ERROR_GENERIC_ERROR;
 c03c6ec:	f06f 0483 	mvn.w	r4, #131	@ 0x83
 c03c6f0:	e7f6      	b.n	c03c6e0 <psa_its_get+0x4e>

0c03c6f2 <psa_its_get_info>:

psa_status_t psa_its_get_info(psa_storage_uid_t uid,
                              struct psa_storage_info_t *p_info)
{
 c03c6f2:	b530      	push	{r4, r5, lr}
 c03c6f4:	b089      	sub	sp, #36	@ 0x24
    psa_status_t status;
#ifdef TFM_PSA_API
    psa_handle_t handle;
#endif

    psa_invec in_vec[] = {
 c03c6f6:	ab02      	add	r3, sp, #8
 c03c6f8:	9304      	str	r3, [sp, #16]
 c03c6fa:	2308      	movs	r3, #8
        { .base = &uid, .len = sizeof(uid) }
    };

    psa_outvec out_vec[] = {
 c03c6fc:	e9cd 3205 	strd	r3, r2, [sp, #20]
 c03c700:	230c      	movs	r3, #12
{
 c03c702:	e9cd 0102 	strd	r0, r1, [sp, #8]
        { .base = p_info, .len = sizeof(*p_info) }
    };

#ifdef TFM_PSA_API
    handle = psa_connect(TFM_ITS_GET_INFO_SID, TFM_ITS_GET_INFO_VERSION);
 c03c706:	2101      	movs	r1, #1
 c03c708:	2072      	movs	r0, #114	@ 0x72
    psa_outvec out_vec[] = {
 c03c70a:	9307      	str	r3, [sp, #28]
    handle = psa_connect(TFM_ITS_GET_INFO_SID, TFM_ITS_GET_INFO_VERSION);
 c03c70c:	f000 f86c 	bl	c03c7e8 <psa_connect>
    if (!PSA_HANDLE_IS_VALID(handle)) {
 c03c710:	1e05      	subs	r5, r0, #0
 c03c712:	dd0e      	ble.n	c03c732 <psa_its_get_info+0x40>
        return PSA_ERROR_GENERIC_ERROR;
    }

    status = psa_call(handle, PSA_IPC_CALL, in_vec, IOVEC_LEN(in_vec), out_vec,
 c03c714:	2301      	movs	r3, #1
 c03c716:	aa06      	add	r2, sp, #24
 c03c718:	9200      	str	r2, [sp, #0]
 c03c71a:	2100      	movs	r1, #0
 c03c71c:	9301      	str	r3, [sp, #4]
 c03c71e:	aa04      	add	r2, sp, #16
 c03c720:	f000 f864 	bl	c03c7ec <psa_call>
 c03c724:	4604      	mov	r4, r0
                      IOVEC_LEN(out_vec));

    psa_close(handle);
 c03c726:	4628      	mov	r0, r5
 c03c728:	f000 f86c 	bl	c03c804 <psa_close>
        return PSA_ERROR_INVALID_ARGUMENT;
    }
#endif

    return status;
}
 c03c72c:	4620      	mov	r0, r4
 c03c72e:	b009      	add	sp, #36	@ 0x24
 c03c730:	bd30      	pop	{r4, r5, pc}
        return PSA_ERROR_GENERIC_ERROR;
 c03c732:	f06f 0483 	mvn.w	r4, #131	@ 0x83
 c03c736:	e7f9      	b.n	c03c72c <psa_its_get_info+0x3a>

0c03c738 <psa_its_remove>:

psa_status_t psa_its_remove(psa_storage_uid_t uid)
{
 c03c738:	b530      	push	{r4, r5, lr}
 c03c73a:	b087      	sub	sp, #28
    psa_status_t status;
#ifdef TFM_PSA_API
    psa_handle_t handle;
#endif

    psa_invec in_vec[] = {
 c03c73c:	ab02      	add	r3, sp, #8
 c03c73e:	9304      	str	r3, [sp, #16]
 c03c740:	2308      	movs	r3, #8
{
 c03c742:	e9cd 0102 	strd	r0, r1, [sp, #8]
        { .base = &uid, .len = sizeof(uid) }
    };

#ifdef TFM_PSA_API
    handle = psa_connect(TFM_ITS_REMOVE_SID, TFM_ITS_REMOVE_VERSION);
 c03c746:	2101      	movs	r1, #1
 c03c748:	2073      	movs	r0, #115	@ 0x73
    psa_invec in_vec[] = {
 c03c74a:	9305      	str	r3, [sp, #20]
    handle = psa_connect(TFM_ITS_REMOVE_SID, TFM_ITS_REMOVE_VERSION);
 c03c74c:	f000 f84c 	bl	c03c7e8 <psa_connect>
    if (!PSA_HANDLE_IS_VALID(handle)) {
 c03c750:	1e05      	subs	r5, r0, #0
 c03c752:	dd0d      	ble.n	c03c770 <psa_its_remove+0x38>
        return PSA_ERROR_GENERIC_ERROR;
    }

    status = psa_call(handle, PSA_IPC_CALL, in_vec, IOVEC_LEN(in_vec), NULL, 0);
 c03c754:	2100      	movs	r1, #0
 c03c756:	2301      	movs	r3, #1
 c03c758:	e9cd 1100 	strd	r1, r1, [sp]
 c03c75c:	aa04      	add	r2, sp, #16
 c03c75e:	f000 f845 	bl	c03c7ec <psa_call>
 c03c762:	4604      	mov	r4, r0

    psa_close(handle);
 c03c764:	4628      	mov	r0, r5
 c03c766:	f000 f84d 	bl	c03c804 <psa_close>
#else
    status = tfm_tfm_its_remove_req_veneer(in_vec, IOVEC_LEN(in_vec), NULL, 0);
#endif

    return status;
}
 c03c76a:	4620      	mov	r0, r4
 c03c76c:	b007      	add	sp, #28
 c03c76e:	bd30      	pop	{r4, r5, pc}
        return PSA_ERROR_GENERIC_ERROR;
 c03c770:	f06f 0483 	mvn.w	r4, #131	@ 0x83
 c03c774:	e7f9      	b.n	c03c76a <psa_its_remove+0x32>

0c03c776 <tfm_platform_system_reset>:
#ifdef TFM_PSA_API
#include "psa_manifest/sid.h"
#endif

enum tfm_platform_err_t tfm_platform_system_reset(void)
{
 c03c776:	b537      	push	{r0, r1, r2, r4, r5, lr}
#ifdef TFM_PSA_API
    psa_status_t status = PSA_ERROR_CONNECTION_REFUSED;
    psa_handle_t handle = PSA_NULL_HANDLE;

    handle = psa_connect(TFM_SP_PLATFORM_SYSTEM_RESET_SID,
 c03c778:	2101      	movs	r1, #1
 c03c77a:	2040      	movs	r0, #64	@ 0x40
 c03c77c:	f000 f834 	bl	c03c7e8 <psa_connect>
                         TFM_SP_PLATFORM_SYSTEM_RESET_VERSION);
    if (handle <= 0) {
 c03c780:	1e05      	subs	r5, r0, #0
 c03c782:	dc02      	bgt.n	c03c78a <tfm_platform_system_reset+0x14>
        return TFM_PLATFORM_ERR_SYSTEM_ERROR;
 c03c784:	2001      	movs	r0, #1
    }
#else /* TFM_PSA_API */
    return (enum tfm_platform_err_t) tfm_platform_sp_system_reset_veneer(
                                                              NULL, 0, NULL, 0);
#endif /* TFM_PSA_API */
}
 c03c786:	b003      	add	sp, #12
 c03c788:	bd30      	pop	{r4, r5, pc}
    status = psa_call(handle, PSA_IPC_CALL,
 c03c78a:	2300      	movs	r3, #0
 c03c78c:	461a      	mov	r2, r3
 c03c78e:	4619      	mov	r1, r3
 c03c790:	e9cd 3300 	strd	r3, r3, [sp]
 c03c794:	f000 f82a 	bl	c03c7ec <psa_call>
 c03c798:	4604      	mov	r4, r0
    psa_close(handle);
 c03c79a:	4628      	mov	r0, r5
 c03c79c:	f000 f832 	bl	c03c804 <psa_close>
    if (status < PSA_SUCCESS) {
 c03c7a0:	2c00      	cmp	r4, #0
 c03c7a2:	dbef      	blt.n	c03c784 <tfm_platform_system_reset+0xe>
        return (enum tfm_platform_err_t) status;
 c03c7a4:	4620      	mov	r0, r4
 c03c7a6:	e7ee      	b.n	c03c786 <tfm_platform_system_reset+0x10>

0c03c7a8 <tfm_core_get_boot_data>:
__attribute__((naked))
int32_t tfm_core_get_boot_data(uint8_t major_type,
                               struct tfm_boot_data *boot_status,
                               uint32_t len)
{
    __ASM volatile(
 c03c7a8:	df04      	svc	4
 c03c7aa:	4770      	bx	lr

0c03c7ac <tfm_core_get_boot_value>:
__attribute__((naked))
int32_t tfm_core_get_boot_value(uint16_t tlv_value,
                               void *ptr,
                               uint32_t len)
{
    __ASM volatile(
 c03c7ac:	df1c      	svc	28
 c03c7ae:	4770      	bx	lr

0c03c7b0 <tfm_nspm_thread_entry>:
 * given during non-secure partition initialization.
 */
__attribute__((naked, section("SFN")))
void tfm_nspm_thread_entry(void)
{
    __ASM volatile(
 c03c7b0:	4604      	mov	r4, r0
 c03c7b2:	2201      	movs	r2, #1
 c03c7b4:	4394      	bics	r4, r2
 c03c7b6:	4620      	mov	r0, r4
 c03c7b8:	4621      	mov	r1, r4
 c03c7ba:	4622      	mov	r2, r4
 c03c7bc:	4623      	mov	r3, r4
 c03c7be:	4625      	mov	r5, r4
 c03c7c0:	4626      	mov	r6, r4
 c03c7c2:	4627      	mov	r7, r4
 c03c7c4:	46a0      	mov	r8, r4
 c03c7c6:	46a1      	mov	r9, r4
 c03c7c8:	46a2      	mov	sl, r4
 c03c7ca:	46a3      	mov	fp, r4
 c03c7cc:	46a4      	mov	ip, r4
 c03c7ce:	4704      	bxns	r0

0c03c7d0 <__acle_se_tfm_psa_framework_version_veneer>:
#endif

__tfm_psa_secure_gateway_attributes__
uint32_t tfm_psa_framework_version_veneer(void)
{
    __ASM volatile("SVC %0           \n"
 c03c7d0:	df0a      	svc	10
 c03c7d2:	4774      	bxns	lr

0c03c7d4 <__acle_se_tfm_psa_version_veneer>:
}

__tfm_psa_secure_gateway_attributes__
uint32_t tfm_psa_version_veneer(uint32_t sid)
{
    __ASM volatile("SVC %0           \n"
 c03c7d4:	df0b      	svc	11
 c03c7d6:	4774      	bxns	lr

0c03c7d8 <__acle_se_tfm_psa_connect_veneer>:
}

__tfm_psa_secure_gateway_attributes__
psa_handle_t tfm_psa_connect_veneer(uint32_t sid, uint32_t version)
{
    __ASM volatile("SVC %0           \n"
 c03c7d8:	df0c      	svc	12
 c03c7da:	4774      	bxns	lr

0c03c7dc <__acle_se_tfm_psa_call_veneer>:
psa_status_t tfm_psa_call_veneer(psa_handle_t handle,
                               const struct tfm_control_parameter_t *ctrl_param,
                               const psa_invec *in_vec,
                               psa_outvec *out_vec)
{
    __ASM volatile("SVC %0           \n"
 c03c7dc:	df0d      	svc	13
 c03c7de:	4774      	bxns	lr

0c03c7e0 <__acle_se_tfm_psa_close_veneer>:
}

__tfm_psa_secure_gateway_attributes__
void tfm_psa_close_veneer(psa_handle_t handle)
{
    __ASM volatile("SVC %0           \n"
 c03c7e0:	df0e      	svc	14
 c03c7e2:	4774      	bxns	lr

0c03c7e4 <psa_call_param_pack>:
__attribute__((naked))
static psa_status_t psa_call_param_pack(psa_handle_t handle,
                                   struct tfm_control_parameter_t *ctrl_param,
                                   const psa_invec *in_vec, psa_outvec *out_vec)
{
    __ASM volatile("SVC %0           \n"
 c03c7e4:	df0d      	svc	13
 c03c7e6:	4770      	bx	lr

0c03c7e8 <psa_connect>:
    __ASM volatile("SVC %0           \n"
 c03c7e8:	df0c      	svc	12
 c03c7ea:	4770      	bx	lr

0c03c7ec <psa_call>:
                      int32_t type,
                      const psa_invec *in_vec,
                      size_t in_len,
                      psa_outvec *out_vec,
                      size_t out_len)
{
 c03c7ec:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    struct tfm_control_parameter_t ctrl_param;
    ctrl_param.type = type;
    ctrl_param.in_len = in_len;
 c03c7ee:	e9cd 1301 	strd	r1, r3, [sp, #4]
    ctrl_param.out_len = out_len;
 c03c7f2:	9b07      	ldr	r3, [sp, #28]

    return psa_call_param_pack(handle, &ctrl_param, in_vec, out_vec);
 c03c7f4:	a901      	add	r1, sp, #4
    ctrl_param.out_len = out_len;
 c03c7f6:	9303      	str	r3, [sp, #12]
    return psa_call_param_pack(handle, &ctrl_param, in_vec, out_vec);
 c03c7f8:	9b06      	ldr	r3, [sp, #24]
 c03c7fa:	f7ff fff3 	bl	c03c7e4 <psa_call_param_pack>
}
 c03c7fe:	b005      	add	sp, #20
 c03c800:	f85d fb04 	ldr.w	pc, [sp], #4

0c03c804 <psa_close>:

__attribute__((naked))
void psa_close(psa_handle_t handle)
{
    __ASM volatile("SVC %0           \n"
 c03c804:	df0e      	svc	14
 c03c806:	4770      	bx	lr

0c03c808 <psa_wait>:

__attribute__((naked))
psa_signal_t psa_wait(psa_signal_t signal_mask, uint32_t timeout)

{
    __ASM volatile("SVC %0           \n"
 c03c808:	df07      	svc	7
 c03c80a:	4770      	bx	lr

0c03c80c <psa_get>:
}

__attribute__((naked))
psa_status_t psa_get(psa_signal_t signal, psa_msg_t *msg)
{
    __ASM volatile("SVC %0           \n"
 c03c80c:	df0f      	svc	15
 c03c80e:	4770      	bx	lr

0c03c810 <psa_read>:
__attribute__((naked))
size_t psa_read(psa_handle_t msg_handle, uint32_t invec_idx,
                void *buffer, size_t num_bytes)

{
    __ASM volatile("SVC %0           \n"
 c03c810:	df11      	svc	17
 c03c812:	4770      	bx	lr

0c03c814 <psa_write>:

__attribute__((naked))
void psa_write(psa_handle_t msg_handle, uint32_t outvec_idx,
               const void *buffer, size_t num_bytes)
{
    __ASM volatile("SVC %0           \n"
 c03c814:	df13      	svc	19
 c03c816:	4770      	bx	lr

0c03c818 <psa_reply>:
}

__attribute__((naked))
void psa_reply(psa_handle_t msg_handle, psa_status_t retval)
{
    __ASM volatile("SVC %0           \n"
 c03c818:	df14      	svc	20
 c03c81a:	4770      	bx	lr

0c03c81c <psa_panic>:
}

__attribute__((naked))
void psa_panic(void)
{
    __ASM volatile("SVC %0           \n"
 c03c81c:	df17      	svc	23
 c03c81e:	4770      	bx	lr

0c03c820 <_tfm_flush_formatted_buffer>:
                              '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};
 
static void _tfm_flush_formatted_buffer(struct formatted_buffer_t *pb,
                                        uint8_t data)
{
    pb->buf[pb->pos++] = data;
 c03c820:	6803      	ldr	r3, [r0, #0]
 c03c822:	1c5a      	adds	r2, r3, #1
    if (pb->pos >= PRINT_BUFF_SIZE) {
 c03c824:	2a1f      	cmp	r2, #31
    pb->buf[pb->pos++] = data;
 c03c826:	4403      	add	r3, r0
 c03c828:	6002      	str	r2, [r0, #0]
 c03c82a:	7119      	strb	r1, [r3, #4]
    if (pb->pos >= PRINT_BUFF_SIZE) {
 c03c82c:	d905      	bls.n	c03c83a <_tfm_flush_formatted_buffer+0x1a>
        pb->pos = 0;
 c03c82e:	2300      	movs	r3, #0
        /* uart flush and print here. */
        stdio_output_string(pb->buf, PRINT_BUFF_SIZE);
 c03c830:	2120      	movs	r1, #32
        pb->pos = 0;
 c03c832:	f840 3b04 	str.w	r3, [r0], #4
        stdio_output_string(pb->buf, PRINT_BUFF_SIZE);
 c03c836:	f021 bf29 	b.w	c05e68c <stdio_output_string>
    }
}
 c03c83a:	4770      	bx	lr

0c03c83c <_tfm_dec_num_output>:
    return count;
}

static int _tfm_dec_num_output(struct formatted_buffer_t *pb,
                               int32_t num, uint8_t sign)
{
 c03c83c:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
    int count = 0;
    uint8_t num_buff[NUM_BUFF_SIZE] = {0};
 c03c840:	2400      	movs	r4, #0
    uint32_t number = (uint32_t)num;
    uint32_t k = 0;

    if (sign == 'd' && num < 0) {
 c03c842:	2a64      	cmp	r2, #100	@ 0x64
{
 c03c844:	4607      	mov	r7, r0
    uint32_t number = (uint32_t)num;
 c03c846:	460d      	mov	r5, r1
    uint8_t num_buff[NUM_BUFF_SIZE] = {0};
 c03c848:	e9cd 4401 	strd	r4, r4, [sp, #4]
 c03c84c:	9403      	str	r4, [sp, #12]
    if (sign == 'd' && num < 0) {
 c03c84e:	d106      	bne.n	c03c85e <_tfm_dec_num_output+0x22>
 c03c850:	42a1      	cmp	r1, r4
 c03c852:	da04      	bge.n	c03c85e <_tfm_dec_num_output+0x22>
        _tfm_flush_formatted_buffer(pb, '-');
 c03c854:	212d      	movs	r1, #45	@ 0x2d
 c03c856:	f7ff ffe3 	bl	c03c820 <_tfm_flush_formatted_buffer>
        count++;
 c03c85a:	2401      	movs	r4, #1
        number = -num;
 c03c85c:	426d      	negs	r5, r5
 c03c85e:	ab01      	add	r3, sp, #4
    int count = 0;
 c03c860:	2600      	movs	r6, #0
 c03c862:	4698      	mov	r8, r3
    }

    do {
        num_buff[k++] = '0' + number % 10;
 c03c864:	200a      	movs	r0, #10
 c03c866:	fbb5 f1f0 	udiv	r1, r5, r0
 c03c86a:	fb00 5211 	mls	r2, r0, r1, r5
 c03c86e:	3230      	adds	r2, #48	@ 0x30
 c03c870:	f803 2b01 	strb.w	r2, [r3], #1
 c03c874:	462a      	mov	r2, r5
        number /= 10;
    } while (number);
 c03c876:	2a09      	cmp	r2, #9
        number /= 10;
 c03c878:	460d      	mov	r5, r1
        num_buff[k++] = '0' + number % 10;
 c03c87a:	f106 0601 	add.w	r6, r6, #1
    } while (number);
 c03c87e:	d8f2      	bhi.n	c03c866 <_tfm_dec_num_output+0x2a>
        num_buff[k++] = '0' + number % 10;
 c03c880:	4635      	mov	r5, r6

    while (k) {
        _tfm_flush_formatted_buffer(pb, num_buff[--k]);
 c03c882:	3d01      	subs	r5, #1
 c03c884:	4638      	mov	r0, r7
 c03c886:	f818 1005 	ldrb.w	r1, [r8, r5]
 c03c88a:	f7ff ffc9 	bl	c03c820 <_tfm_flush_formatted_buffer>
    while (k) {
 c03c88e:	2d00      	cmp	r5, #0
 c03c890:	d1f7      	bne.n	c03c882 <_tfm_dec_num_output+0x46>
        count++;
    }

    return count;
}
 c03c892:	19a0      	adds	r0, r4, r6
 c03c894:	b004      	add	sp, #16
 c03c896:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0c03c89a <_tfm_hex_num_output>:

static int _tfm_hex_num_output(struct formatted_buffer_t *pb, uint32_t num,
                               const char *hex_digits)
{
 c03c89a:	b5f0      	push	{r4, r5, r6, r7, lr}
    int count = 0;
    uint8_t num_buff[NUM_BUFF_SIZE] = {0};
 c03c89c:	2400      	movs	r4, #0
{
 c03c89e:	b085      	sub	sp, #20
 c03c8a0:	ab01      	add	r3, sp, #4
 c03c8a2:	4606      	mov	r6, r0
 c03c8a4:	461f      	mov	r7, r3
    uint8_t num_buff[NUM_BUFF_SIZE] = {0};
 c03c8a6:	e9cd 4401 	strd	r4, r4, [sp, #4]
 c03c8aa:	9403      	str	r4, [sp, #12]
    uint32_t k = 0;

    do {
        num_buff[k++] = hex_digits[num & 0x0f];
 c03c8ac:	f001 000f 	and.w	r0, r1, #15
 c03c8b0:	5c10      	ldrb	r0, [r2, r0]
        num >>= 4;
    } while (num);
 c03c8b2:	0909      	lsrs	r1, r1, #4
        num_buff[k++] = hex_digits[num & 0x0f];
 c03c8b4:	f104 0401 	add.w	r4, r4, #1
 c03c8b8:	f803 0b01 	strb.w	r0, [r3], #1
    } while (num);
 c03c8bc:	d1f6      	bne.n	c03c8ac <_tfm_hex_num_output+0x12>
        num_buff[k++] = hex_digits[num & 0x0f];
 c03c8be:	4625      	mov	r5, r4

    while (k) {
        _tfm_flush_formatted_buffer(pb, num_buff[--k]);
 c03c8c0:	3d01      	subs	r5, #1
 c03c8c2:	4630      	mov	r0, r6
 c03c8c4:	5d79      	ldrb	r1, [r7, r5]
 c03c8c6:	f7ff ffab 	bl	c03c820 <_tfm_flush_formatted_buffer>
    while (k) {
 c03c8ca:	2d00      	cmp	r5, #0
 c03c8cc:	d1f8      	bne.n	c03c8c0 <_tfm_hex_num_output+0x26>
        count++;
    }

    return count;
}
 c03c8ce:	4620      	mov	r0, r4
 c03c8d0:	b005      	add	sp, #20
 c03c8d2:	bdf0      	pop	{r4, r5, r6, r7, pc}

0c03c8d4 <_tfm_string_output>:
{
 c03c8d4:	b570      	push	{r4, r5, r6, lr}
 c03c8d6:	4606      	mov	r6, r0
 c03c8d8:	460d      	mov	r5, r1
    int count = 0;
 c03c8da:	2400      	movs	r4, #0
    while (*str) {
 c03c8dc:	5d29      	ldrb	r1, [r5, r4]
 c03c8de:	b909      	cbnz	r1, c03c8e4 <_tfm_string_output+0x10>
}
 c03c8e0:	4620      	mov	r0, r4
 c03c8e2:	bd70      	pop	{r4, r5, r6, pc}
        _tfm_flush_formatted_buffer(pb, *str++);
 c03c8e4:	4630      	mov	r0, r6
 c03c8e6:	f7ff ff9b 	bl	c03c820 <_tfm_flush_formatted_buffer>
        count++;
 c03c8ea:	3401      	adds	r4, #1
 c03c8ec:	e7f6      	b.n	c03c8dc <_tfm_string_output+0x8>
	...

0c03c8f0 <tfm_log_printf>:

    return count;
}

int tfm_log_printf(const char *fmt, ...)
{
 c03c8f0:	b40f      	push	{r0, r1, r2, r3}
 c03c8f2:	b5f0      	push	{r4, r5, r6, r7, lr}
    outputbuf.pos = 0;
 c03c8f4:	2600      	movs	r6, #0
{
 c03c8f6:	b08b      	sub	sp, #44	@ 0x2c
 c03c8f8:	ac10      	add	r4, sp, #64	@ 0x40
 c03c8fa:	f854 5b04 	ldr.w	r5, [r4], #4
    outputbuf.pos = 0;
 c03c8fe:	9601      	str	r6, [sp, #4]
    int count = 0;
    va_list ap;

    va_start(ap, fmt);
 c03c900:	9400      	str	r4, [sp, #0]
    while (*fmt) {
 c03c902:	7829      	ldrb	r1, [r5, #0]
 c03c904:	b959      	cbnz	r1, c03c91e <tfm_log_printf+0x2e>
    if (outputbuf.pos) {
 c03c906:	9901      	ldr	r1, [sp, #4]
 c03c908:	b119      	cbz	r1, c03c912 <tfm_log_printf+0x22>
        count += stdio_output_string(outputbuf.buf, outputbuf.pos);
 c03c90a:	a802      	add	r0, sp, #8
 c03c90c:	f021 febe 	bl	c05e68c <stdio_output_string>
 c03c910:	4406      	add	r6, r0
    count = _tfm_log_vprintf(fmt, ap);
    va_end(ap);

    return count;
}
 c03c912:	4630      	mov	r0, r6
 c03c914:	b00b      	add	sp, #44	@ 0x2c
 c03c916:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
 c03c91a:	b004      	add	sp, #16
 c03c91c:	4770      	bx	lr
        if (*fmt == '%') {
 c03c91e:	2925      	cmp	r1, #37	@ 0x25
            switch (*(++fmt)) {
 c03c920:	f105 0701 	add.w	r7, r5, #1
        if (*fmt == '%') {
 c03c924:	d155      	bne.n	c03c9d2 <tfm_log_printf+0xe2>
            switch (*(++fmt)) {
 c03c926:	7869      	ldrb	r1, [r5, #1]
 c03c928:	2969      	cmp	r1, #105	@ 0x69
 c03c92a:	d010      	beq.n	c03c94e <tfm_log_printf+0x5e>
 c03c92c:	d818      	bhi.n	c03c960 <tfm_log_printf+0x70>
 c03c92e:	2958      	cmp	r1, #88	@ 0x58
 c03c930:	d034      	beq.n	c03c99c <tfm_log_printf+0xac>
 c03c932:	d808      	bhi.n	c03c946 <tfm_log_printf+0x56>
 c03c934:	2925      	cmp	r1, #37	@ 0x25
 c03c936:	d047      	beq.n	c03c9c8 <tfm_log_printf+0xd8>
                count += _tfm_string_output(&outputbuf, "[Unsupported Tag]");
 c03c938:	4928      	ldr	r1, [pc, #160]	@ (c03c9dc <tfm_log_printf+0xec>)
 c03c93a:	a801      	add	r0, sp, #4
 c03c93c:	f7ff ffca 	bl	c03c8d4 <_tfm_string_output>
 c03c940:	4406      	add	r6, r0
                                            (uint8_t)va_arg(ap, int32_t));
 c03c942:	463d      	mov	r5, r7
 c03c944:	e7dd      	b.n	c03c902 <tfm_log_printf+0x12>
            switch (*(++fmt)) {
 c03c946:	2963      	cmp	r1, #99	@ 0x63
 c03c948:	d03c      	beq.n	c03c9c4 <tfm_log_printf+0xd4>
 c03c94a:	2964      	cmp	r1, #100	@ 0x64
 c03c94c:	d1f4      	bne.n	c03c938 <tfm_log_printf+0x48>
                count += _tfm_dec_num_output(&outputbuf,
 c03c94e:	2264      	movs	r2, #100	@ 0x64
                count += _tfm_dec_num_output(&outputbuf,
 c03c950:	f854 1b04 	ldr.w	r1, [r4], #4
 c03c954:	a801      	add	r0, sp, #4
 c03c956:	f7ff ff71 	bl	c03c83c <_tfm_dec_num_output>
 c03c95a:	4406      	add	r6, r0
            fmt++;
 c03c95c:	1caf      	adds	r7, r5, #2
 c03c95e:	e7f0      	b.n	c03c942 <tfm_log_printf+0x52>
            switch (*(++fmt)) {
 c03c960:	3970      	subs	r1, #112	@ 0x70
 c03c962:	b2cb      	uxtb	r3, r1
 c03c964:	2b08      	cmp	r3, #8
 c03c966:	d8e7      	bhi.n	c03c938 <tfm_log_printf+0x48>
 c03c968:	2908      	cmp	r1, #8
 c03c96a:	d8e5      	bhi.n	c03c938 <tfm_log_printf+0x48>
 c03c96c:	a301      	add	r3, pc, #4	@ (adr r3, c03c974 <tfm_log_printf+0x84>)
 c03c96e:	f853 f021 	ldr.w	pc, [r3, r1, lsl #2]
 c03c972:	bf00      	nop
 c03c974:	0c03c9ab 	.word	0x0c03c9ab
 c03c978:	0c03c939 	.word	0x0c03c939
 c03c97c:	0c03c939 	.word	0x0c03c939
 c03c980:	0c03c9b9 	.word	0x0c03c9b9
 c03c984:	0c03c939 	.word	0x0c03c939
 c03c988:	0c03c999 	.word	0x0c03c999
 c03c98c:	0c03c939 	.word	0x0c03c939
 c03c990:	0c03c939 	.word	0x0c03c939
 c03c994:	0c03c9b5 	.word	0x0c03c9b5
                count += _tfm_dec_num_output(&outputbuf,
 c03c998:	2275      	movs	r2, #117	@ 0x75
 c03c99a:	e7d9      	b.n	c03c950 <tfm_log_printf+0x60>
                count += _tfm_hex_num_output(&outputbuf, va_arg(ap, uint32_t),
 c03c99c:	4a10      	ldr	r2, [pc, #64]	@ (c03c9e0 <tfm_log_printf+0xf0>)
                count += _tfm_hex_num_output(&outputbuf, va_arg(ap, uint32_t),
 c03c99e:	f854 1b04 	ldr.w	r1, [r4], #4
 c03c9a2:	a801      	add	r0, sp, #4
 c03c9a4:	f7ff ff79 	bl	c03c89a <_tfm_hex_num_output>
 c03c9a8:	e7d7      	b.n	c03c95a <tfm_log_printf+0x6a>
                count += _tfm_string_output(&outputbuf, "0x");
 c03c9aa:	490e      	ldr	r1, [pc, #56]	@ (c03c9e4 <tfm_log_printf+0xf4>)
 c03c9ac:	a801      	add	r0, sp, #4
 c03c9ae:	f7ff ff91 	bl	c03c8d4 <_tfm_string_output>
 c03c9b2:	4406      	add	r6, r0
                count += _tfm_hex_num_output(&outputbuf, va_arg(ap, uint32_t),
 c03c9b4:	4a0c      	ldr	r2, [pc, #48]	@ (c03c9e8 <tfm_log_printf+0xf8>)
 c03c9b6:	e7f2      	b.n	c03c99e <tfm_log_printf+0xae>
                count += _tfm_string_output(&outputbuf, va_arg(ap, char*));
 c03c9b8:	f854 1b04 	ldr.w	r1, [r4], #4
 c03c9bc:	a801      	add	r0, sp, #4
 c03c9be:	f7ff ff89 	bl	c03c8d4 <_tfm_string_output>
 c03c9c2:	e7ca      	b.n	c03c95a <tfm_log_printf+0x6a>
                _tfm_flush_formatted_buffer(&outputbuf,
 c03c9c4:	f814 1b04 	ldrb.w	r1, [r4], #4
                _tfm_flush_formatted_buffer(&outputbuf, '%');
 c03c9c8:	a801      	add	r0, sp, #4
 c03c9ca:	f7ff ff29 	bl	c03c820 <_tfm_flush_formatted_buffer>
                count++;
 c03c9ce:	3601      	adds	r6, #1
                break;
 c03c9d0:	e7c4      	b.n	c03c95c <tfm_log_printf+0x6c>
            _tfm_flush_formatted_buffer(&outputbuf, *fmt++);
 c03c9d2:	a801      	add	r0, sp, #4
 c03c9d4:	f7ff ff24 	bl	c03c820 <_tfm_flush_formatted_buffer>
            count++;
 c03c9d8:	3601      	adds	r6, #1
 c03c9da:	e7b2      	b.n	c03c942 <tfm_log_printf+0x52>
 c03c9dc:	0c062046 	.word	0x0c062046
 c03c9e0:	0c062058 	.word	0x0c062058
 c03c9e4:	0c062043 	.word	0x0c062043
 c03c9e8:	0c062068 	.word	0x0c062068

0c03c9ec <HAL_MspInit>:
__weak void HAL_MspInit(void)
{
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_MspInit could be implemented in the user file
   */
}
 c03c9ec:	4770      	bx	lr
	...

0c03c9f0 <HAL_Init>:
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 c03c9f0:	4a0f      	ldr	r2, [pc, #60]	@ (c03ca30 <HAL_Init+0x40>)
{
 c03c9f2:	b510      	push	{r4, lr}
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 c03c9f4:	6813      	ldr	r3, [r2, #0]
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 c03c9f6:	2003      	movs	r0, #3
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 c03c9f8:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 c03c9fc:	6013      	str	r3, [r2, #0]
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 c03c9fe:	f000 f831 	bl	c03ca64 <HAL_NVIC_SetPriorityGrouping>
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR2 & RCC_CFGR2_HPRE) >> RCC_CFGR2_HPRE_Pos];
 c03ca02:	f003 fb69 	bl	c0400d8 <HAL_RCC_GetSysClockFreq>
 c03ca06:	4b0b      	ldr	r3, [pc, #44]	@ (c03ca34 <HAL_Init+0x44>)
 c03ca08:	4a0b      	ldr	r2, [pc, #44]	@ (c03ca38 <HAL_Init+0x48>)
 c03ca0a:	6a1b      	ldr	r3, [r3, #32]
 c03ca0c:	f003 030f 	and.w	r3, r3, #15
 c03ca10:	5cd3      	ldrb	r3, [r2, r3]
 c03ca12:	40d8      	lsrs	r0, r3
 c03ca14:	4b09      	ldr	r3, [pc, #36]	@ (c03ca3c <HAL_Init+0x4c>)
 c03ca16:	6018      	str	r0, [r3, #0]
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
 c03ca18:	200f      	movs	r0, #15
 c03ca1a:	f007 f957 	bl	c043ccc <HAL_InitTick>
 c03ca1e:	4604      	mov	r4, r0
 c03ca20:	b918      	cbnz	r0, c03ca2a <HAL_Init+0x3a>
  HAL_MspInit();
 c03ca22:	f7ff ffe3 	bl	c03c9ec <HAL_MspInit>
}
 c03ca26:	4620      	mov	r0, r4
 c03ca28:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
 c03ca2a:	2401      	movs	r4, #1
 c03ca2c:	e7fb      	b.n	c03ca26 <HAL_Init+0x36>
 c03ca2e:	bf00      	nop
 c03ca30:	50022000 	.word	0x50022000
 c03ca34:	56020c00 	.word	0x56020c00
 c03ca38:	0c05fadc 	.word	0x0c05fadc
 c03ca3c:	300308e4 	.word	0x300308e4

0c03ca40 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay  specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 c03ca40:	b538      	push	{r3, r4, r5, lr}
 c03ca42:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
 c03ca44:	f007 f950 	bl	c043ce8 <HAL_GetTick>
 c03ca48:	4605      	mov	r5, r0
  uint32_t wait = Delay;

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
 c03ca4a:	1c63      	adds	r3, r4, #1
  {
    wait += (uint32_t)(uwTickFreq);
 c03ca4c:	bf1e      	ittt	ne
 c03ca4e:	4b04      	ldrne	r3, [pc, #16]	@ (c03ca60 <HAL_Delay+0x20>)
 c03ca50:	781b      	ldrbne	r3, [r3, #0]
 c03ca52:	18e4      	addne	r4, r4, r3
  }

  while ((HAL_GetTick() - tickstart) < wait)
 c03ca54:	f007 f948 	bl	c043ce8 <HAL_GetTick>
 c03ca58:	1b43      	subs	r3, r0, r5
 c03ca5a:	42a3      	cmp	r3, r4
 c03ca5c:	d3fa      	bcc.n	c03ca54 <HAL_Delay+0x14>
  {
  }
}
 c03ca5e:	bd38      	pop	{r3, r4, r5, pc}
 c03ca60:	300308e8 	.word	0x300308e8

0c03ca64 <HAL_NVIC_SetPriorityGrouping>:
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 c03ca64:	4907      	ldr	r1, [pc, #28]	@ (c03ca84 <HAL_NVIC_SetPriorityGrouping+0x20>)
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 c03ca66:	0203      	lsls	r3, r0, #8
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 c03ca68:	68ca      	ldr	r2, [r1, #12]
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 c03ca6a:	f403 63e0 	and.w	r3, r3, #1792	@ 0x700
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 c03ca6e:	f422 62e0 	bic.w	r2, r2, #1792	@ 0x700
 c03ca72:	0412      	lsls	r2, r2, #16
 c03ca74:	0c12      	lsrs	r2, r2, #16
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 c03ca76:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
 c03ca78:	f043 63bf 	orr.w	r3, r3, #100139008	@ 0x5f80000
 c03ca7c:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
  SCB->AIRCR =  reg_value;
 c03ca80:	60cb      	str	r3, [r1, #12]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
}
 c03ca82:	4770      	bx	lr
 c03ca84:	e000ed00 	.word	0xe000ed00

0c03ca88 <CRYP_SetKey>:
  * @note   If pKey is NULL, the Key registers are not written.
  * @retval None
  */
static void CRYP_SetKey(CRYP_HandleTypeDef *hcryp, uint32_t KeySize)
{
  if (hcryp->Init.pKey != NULL)
 c03ca88:	68c3      	ldr	r3, [r0, #12]
 c03ca8a:	b1a3      	cbz	r3, c03cab6 <CRYP_SetKey+0x2e>
  {
    switch (KeySize)
 c03ca8c:	b1a1      	cbz	r1, c03cab8 <CRYP_SetKey+0x30>
 c03ca8e:	f5b1 2f80 	cmp.w	r1, #262144	@ 0x40000
 c03ca92:	d110      	bne.n	c03cab6 <CRYP_SetKey+0x2e>
    {
      case CRYP_KEYSIZE_256B:
        hcryp->Instance->KEYR7 = *(uint32_t *)(hcryp->Init.pKey);
 c03ca94:	6819      	ldr	r1, [r3, #0]
 c03ca96:	6802      	ldr	r2, [r0, #0]
 c03ca98:	63d1      	str	r1, [r2, #60]	@ 0x3c
        hcryp->Instance->KEYR6 = *(uint32_t *)(hcryp->Init.pKey + 1U);
 c03ca9a:	6859      	ldr	r1, [r3, #4]
 c03ca9c:	6391      	str	r1, [r2, #56]	@ 0x38
        hcryp->Instance->KEYR5 = *(uint32_t *)(hcryp->Init.pKey + 2U);
 c03ca9e:	6899      	ldr	r1, [r3, #8]
 c03caa0:	6351      	str	r1, [r2, #52]	@ 0x34
        hcryp->Instance->KEYR4 = *(uint32_t *)(hcryp->Init.pKey + 3U);
 c03caa2:	68d9      	ldr	r1, [r3, #12]
 c03caa4:	6311      	str	r1, [r2, #48]	@ 0x30
        hcryp->Instance->KEYR3 = *(uint32_t *)(hcryp->Init.pKey + 4U);
 c03caa6:	6919      	ldr	r1, [r3, #16]
 c03caa8:	61d1      	str	r1, [r2, #28]
        hcryp->Instance->KEYR2 = *(uint32_t *)(hcryp->Init.pKey + 5U);
 c03caaa:	6959      	ldr	r1, [r3, #20]
 c03caac:	6191      	str	r1, [r2, #24]
        hcryp->Instance->KEYR1 = *(uint32_t *)(hcryp->Init.pKey + 6U);
 c03caae:	6999      	ldr	r1, [r3, #24]
 c03cab0:	6151      	str	r1, [r2, #20]
        hcryp->Instance->KEYR0 = *(uint32_t *)(hcryp->Init.pKey + 7U);
 c03cab2:	69db      	ldr	r3, [r3, #28]
        break;
      case CRYP_KEYSIZE_128B:
        hcryp->Instance->KEYR3 = *(uint32_t *)(hcryp->Init.pKey);
        hcryp->Instance->KEYR2 = *(uint32_t *)(hcryp->Init.pKey + 1U);
        hcryp->Instance->KEYR1 = *(uint32_t *)(hcryp->Init.pKey + 2U);
        hcryp->Instance->KEYR0 = *(uint32_t *)(hcryp->Init.pKey + 3U);
 c03cab4:	6113      	str	r3, [r2, #16]
        break;
      default:
        break;
    }
  }
}
 c03cab6:	4770      	bx	lr
        hcryp->Instance->KEYR3 = *(uint32_t *)(hcryp->Init.pKey);
 c03cab8:	6819      	ldr	r1, [r3, #0]
 c03caba:	6802      	ldr	r2, [r0, #0]
 c03cabc:	61d1      	str	r1, [r2, #28]
        hcryp->Instance->KEYR2 = *(uint32_t *)(hcryp->Init.pKey + 1U);
 c03cabe:	6859      	ldr	r1, [r3, #4]
 c03cac0:	6191      	str	r1, [r2, #24]
        hcryp->Instance->KEYR1 = *(uint32_t *)(hcryp->Init.pKey + 2U);
 c03cac2:	6899      	ldr	r1, [r3, #8]
 c03cac4:	6151      	str	r1, [r2, #20]
        hcryp->Instance->KEYR0 = *(uint32_t *)(hcryp->Init.pKey + 3U);
 c03cac6:	68db      	ldr	r3, [r3, #12]
 c03cac8:	e7f4      	b.n	c03cab4 <CRYP_SetKey+0x2c>

0c03caca <CRYP_SetIV>:
  * @note   If IV is NULL, the IV registers are not written.
  * @retval None
  */
static void CRYP_SetIV(CRYP_HandleTypeDef *hcryp)
{
  if (hcryp->Init.pInitVect != NULL)
 c03caca:	6903      	ldr	r3, [r0, #16]
 c03cacc:	b143      	cbz	r3, c03cae0 <CRYP_SetIV+0x16>
  {
    /* Set the Initialization Vector*/
    hcryp->Instance->IVR3 = *(uint32_t *)(hcryp->Init.pInitVect);
 c03cace:	6819      	ldr	r1, [r3, #0]
 c03cad0:	6802      	ldr	r2, [r0, #0]
 c03cad2:	62d1      	str	r1, [r2, #44]	@ 0x2c
    hcryp->Instance->IVR2 = *(uint32_t *)(hcryp->Init.pInitVect + 1U);
 c03cad4:	6859      	ldr	r1, [r3, #4]
 c03cad6:	6291      	str	r1, [r2, #40]	@ 0x28
    hcryp->Instance->IVR1 = *(uint32_t *)(hcryp->Init.pInitVect + 2U);
 c03cad8:	6899      	ldr	r1, [r3, #8]
 c03cada:	6251      	str	r1, [r2, #36]	@ 0x24
    hcryp->Instance->IVR0 = *(uint32_t *)(hcryp->Init.pInitVect + 3U);
 c03cadc:	68db      	ldr	r3, [r3, #12]
 c03cade:	6213      	str	r3, [r2, #32]
  }
}
 c03cae0:	4770      	bx	lr

0c03cae2 <CRYP_WaitOnCCFlag>:
  * @param  Timeout Timeout duration.
  * @note   This function can only be used in thread mode.
  * @retval HAL status
  */
static HAL_StatusTypeDef CRYP_WaitOnCCFlag(CRYP_HandleTypeDef *hcryp, uint32_t Timeout)
{
 c03cae2:	b570      	push	{r4, r5, r6, lr}
 c03cae4:	4604      	mov	r4, r0
 c03cae6:	460d      	mov	r5, r1
  uint32_t tickstart;

  /* Get timeout */
  tickstart = HAL_GetTick();
 c03cae8:	f007 f8fe 	bl	c043ce8 <HAL_GetTick>
 c03caec:	4606      	mov	r6, r0

  while (HAL_IS_BIT_CLR(hcryp->Instance->SR, AES_SR_CCF))
 c03caee:	6822      	ldr	r2, [r4, #0]
 c03caf0:	6853      	ldr	r3, [r2, #4]
 c03caf2:	07db      	lsls	r3, r3, #31
 c03caf4:	d501      	bpl.n	c03cafa <CRYP_WaitOnCCFlag+0x18>
        __HAL_UNLOCK(hcryp);
        return HAL_ERROR;
      }
    }
  }
  return HAL_OK;
 c03caf6:	2000      	movs	r0, #0
 c03caf8:	e017      	b.n	c03cb2a <CRYP_WaitOnCCFlag+0x48>
    if (Timeout != HAL_MAX_DELAY)
 c03cafa:	1c69      	adds	r1, r5, #1
 c03cafc:	d0f8      	beq.n	c03caf0 <CRYP_WaitOnCCFlag+0xe>
      if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
 c03cafe:	f007 f8f3 	bl	c043ce8 <HAL_GetTick>
 c03cb02:	1b80      	subs	r0, r0, r6
 c03cb04:	42a8      	cmp	r0, r5
 c03cb06:	d801      	bhi.n	c03cb0c <CRYP_WaitOnCCFlag+0x2a>
 c03cb08:	2d00      	cmp	r5, #0
 c03cb0a:	d1f0      	bne.n	c03caee <CRYP_WaitOnCCFlag+0xc>
        __HAL_CRYP_DISABLE(hcryp);
 c03cb0c:	6822      	ldr	r2, [r4, #0]
        hcryp->State = HAL_CRYP_STATE_READY;
 c03cb0e:	2001      	movs	r0, #1
        __HAL_CRYP_DISABLE(hcryp);
 c03cb10:	6813      	ldr	r3, [r2, #0]
 c03cb12:	f023 0301 	bic.w	r3, r3, #1
 c03cb16:	6013      	str	r3, [r2, #0]
        hcryp->ErrorCode |= HAL_CRYP_ERROR_TIMEOUT;
 c03cb18:	6de3      	ldr	r3, [r4, #92]	@ 0x5c
 c03cb1a:	f043 0310 	orr.w	r3, r3, #16
 c03cb1e:	65e3      	str	r3, [r4, #92]	@ 0x5c
        __HAL_UNLOCK(hcryp);
 c03cb20:	2300      	movs	r3, #0
        hcryp->State = HAL_CRYP_STATE_READY;
 c03cb22:	f884 0059 	strb.w	r0, [r4, #89]	@ 0x59
        __HAL_UNLOCK(hcryp);
 c03cb26:	f884 3058 	strb.w	r3, [r4, #88]	@ 0x58
}
 c03cb2a:	bd70      	pop	{r4, r5, r6, pc}

0c03cb2c <CRYP_GCMCCM_SetHeaderPhase>:
{
 c03cb2c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 c03cb30:	b08c      	sub	sp, #48	@ 0x30
  uint32_t mask[12] = {0x0U, 0xFF000000U, 0xFFFF0000U, 0xFFFFFF00U,  /* 32-bit data type */
 c03cb32:	466d      	mov	r5, sp
{
 c03cb34:	4604      	mov	r4, r0
  uint32_t mask[12] = {0x0U, 0xFF000000U, 0xFFFF0000U, 0xFFFFFF00U,  /* 32-bit data type */
 c03cb36:	4e81      	ldr	r6, [pc, #516]	@ (c03cd3c <CRYP_GCMCCM_SetHeaderPhase+0x210>)
{
 c03cb38:	460f      	mov	r7, r1
  uint32_t mask[12] = {0x0U, 0xFF000000U, 0xFFFF0000U, 0xFFFFFF00U,  /* 32-bit data type */
 c03cb3a:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 c03cb3c:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 c03cb3e:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 c03cb40:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 c03cb42:	e896 000f 	ldmia.w	r6, {r0, r1, r2, r3}
 c03cb46:	e885 000f 	stmia.w	r5, {r0, r1, r2, r3}
  if (hcryp->Init.HeaderWidthUnit == CRYP_HEADERWIDTHUNIT_WORD)
 c03cb4a:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
    size_in_bytes = hcryp->Init.HeaderSize * 4U;
 c03cb4c:	69e5      	ldr	r5, [r4, #28]
  if (hcryp->Init.HeaderWidthUnit == CRYP_HEADERWIDTHUNIT_WORD)
 c03cb4e:	b903      	cbnz	r3, c03cb52 <CRYP_GCMCCM_SetHeaderPhase+0x26>
    size_in_bytes = hcryp->Init.HeaderSize * 4U;
 c03cb50:	00ad      	lsls	r5, r5, #2
    CRYP_SET_PHASE(hcryp, CRYP_PHASE_HEADER);
 c03cb52:	6823      	ldr	r3, [r4, #0]
 c03cb54:	681a      	ldr	r2, [r3, #0]
  if ((size_in_bytes != 0U))
 c03cb56:	2d00      	cmp	r5, #0
 c03cb58:	f000 80e0 	beq.w	c03cd1c <CRYP_GCMCCM_SetHeaderPhase+0x1f0>
    CRYP_SET_PHASE(hcryp, CRYP_PHASE_HEADER);
 c03cb5c:	f422 42c0 	bic.w	r2, r2, #24576	@ 0x6000
 c03cb60:	f442 5200 	orr.w	r2, r2, #8192	@ 0x2000
 c03cb64:	601a      	str	r2, [r3, #0]
    __HAL_CRYP_ENABLE(hcryp);
 c03cb66:	681a      	ldr	r2, [r3, #0]
    if ((size_in_bytes % 16U) == 0U)
 c03cb68:	f015 060f 	ands.w	r6, r5, #15
    __HAL_CRYP_ENABLE(hcryp);
 c03cb6c:	f042 0201 	orr.w	r2, r2, #1
 c03cb70:	601a      	str	r2, [r3, #0]
    if ((size_in_bytes % 16U) == 0U)
 c03cb72:	d023      	beq.n	c03cbbc <CRYP_GCMCCM_SetHeaderPhase+0x90>
      for (loopcounter = 0U; (loopcounter < ((size_in_bytes / 16U) * 4U)); loopcounter += 4U)
 c03cb74:	2600      	movs	r6, #0
 c03cb76:	ea4f 1815 	mov.w	r8, r5, lsr #4
 c03cb7a:	ea4f 0888 	mov.w	r8, r8, lsl #2
 c03cb7e:	45b0      	cmp	r8, r6
        hcryp->Instance->DINR = *(uint32_t *)(hcryp->Init.Header + hcryp->CrypHeaderCount);
 c03cb80:	6823      	ldr	r3, [r4, #0]
      for (loopcounter = 0U; (loopcounter < ((size_in_bytes / 16U) * 4U)); loopcounter += 4U)
 c03cb82:	d864      	bhi.n	c03cc4e <CRYP_GCMCCM_SetHeaderPhase+0x122>
      for (loopcounter = 0U; (loopcounter < ((size_in_bytes / 4U) % 4U)); loopcounter++)
 c03cb84:	2100      	movs	r1, #0
 c03cb86:	f3c5 0281 	ubfx	r2, r5, #2, #2
 c03cb8a:	428a      	cmp	r2, r1
 c03cb8c:	f040 809f 	bne.w	c03ccce <CRYP_GCMCCM_SetHeaderPhase+0x1a2>
      if ((size_in_bytes % 4U) == 0U)
 c03cb90:	f015 0503 	ands.w	r5, r5, #3
 c03cb94:	f040 80aa 	bne.w	c03ccec <CRYP_GCMCCM_SetHeaderPhase+0x1c0>
          loopcounter++;
 c03cb98:	3101      	adds	r1, #1
        while (loopcounter < 4U)
 c03cb9a:	2904      	cmp	r1, #4
          hcryp->Instance->DINR = 0x0U;
 c03cb9c:	609d      	str	r5, [r3, #8]
        while (loopcounter < 4U)
 c03cb9e:	d1fb      	bne.n	c03cb98 <CRYP_GCMCCM_SetHeaderPhase+0x6c>
      if (CRYP_WaitOnCCFlag(hcryp, Timeout) != HAL_OK)
 c03cba0:	4639      	mov	r1, r7
 c03cba2:	4620      	mov	r0, r4
 c03cba4:	f7ff ff9d 	bl	c03cae2 <CRYP_WaitOnCCFlag>
 c03cba8:	2800      	cmp	r0, #0
 c03cbaa:	d143      	bne.n	c03cc34 <CRYP_GCMCCM_SetHeaderPhase+0x108>
      __HAL_CRYP_CLEAR_FLAG(hcryp, CRYP_CLEAR_CCF);
 c03cbac:	6822      	ldr	r2, [r4, #0]
 c03cbae:	f8d2 3308 	ldr.w	r3, [r2, #776]	@ 0x308
 c03cbb2:	f043 0301 	orr.w	r3, r3, #1
 c03cbb6:	f8c2 3308 	str.w	r3, [r2, #776]	@ 0x308
 c03cbba:	e002      	b.n	c03cbc2 <CRYP_GCMCCM_SetHeaderPhase+0x96>
      for (loopcounter = 0U; (loopcounter < (size_in_bytes / 4U)); loopcounter += 4U)
 c03cbbc:	08ad      	lsrs	r5, r5, #2
 c03cbbe:	42b5      	cmp	r5, r6
 c03cbc0:	d801      	bhi.n	c03cbc6 <CRYP_GCMCCM_SetHeaderPhase+0x9a>
  return HAL_OK;
 c03cbc2:	2000      	movs	r0, #0
 c03cbc4:	e037      	b.n	c03cc36 <CRYP_GCMCCM_SetHeaderPhase+0x10a>
        hcryp->Instance->DINR = *(uint32_t *)(hcryp->Init.Header + hcryp->CrypHeaderCount);
 c03cbc6:	f8b4 3044 	ldrh.w	r3, [r4, #68]	@ 0x44
 c03cbca:	69a1      	ldr	r1, [r4, #24]
 c03cbcc:	b29b      	uxth	r3, r3
 c03cbce:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 c03cbd2:	6822      	ldr	r2, [r4, #0]
        if (CRYP_WaitOnCCFlag(hcryp, Timeout) != HAL_OK)
 c03cbd4:	4620      	mov	r0, r4
        hcryp->Instance->DINR = *(uint32_t *)(hcryp->Init.Header + hcryp->CrypHeaderCount);
 c03cbd6:	6093      	str	r3, [r2, #8]
        hcryp->CrypHeaderCount++;
 c03cbd8:	f8b4 3044 	ldrh.w	r3, [r4, #68]	@ 0x44
 c03cbdc:	3301      	adds	r3, #1
 c03cbde:	b29b      	uxth	r3, r3
 c03cbe0:	f8a4 3044 	strh.w	r3, [r4, #68]	@ 0x44
        hcryp->Instance->DINR = *(uint32_t *)(hcryp->Init.Header + hcryp->CrypHeaderCount);
 c03cbe4:	f8b4 3044 	ldrh.w	r3, [r4, #68]	@ 0x44
 c03cbe8:	b29b      	uxth	r3, r3
 c03cbea:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 c03cbee:	6093      	str	r3, [r2, #8]
        hcryp->CrypHeaderCount++;
 c03cbf0:	f8b4 3044 	ldrh.w	r3, [r4, #68]	@ 0x44
 c03cbf4:	3301      	adds	r3, #1
 c03cbf6:	b29b      	uxth	r3, r3
 c03cbf8:	f8a4 3044 	strh.w	r3, [r4, #68]	@ 0x44
        hcryp->Instance->DINR  = *(uint32_t *)(hcryp->Init.Header + hcryp->CrypHeaderCount);
 c03cbfc:	f8b4 3044 	ldrh.w	r3, [r4, #68]	@ 0x44
 c03cc00:	b29b      	uxth	r3, r3
 c03cc02:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 c03cc06:	6093      	str	r3, [r2, #8]
        hcryp->CrypHeaderCount++;
 c03cc08:	f8b4 3044 	ldrh.w	r3, [r4, #68]	@ 0x44
 c03cc0c:	3301      	adds	r3, #1
 c03cc0e:	b29b      	uxth	r3, r3
 c03cc10:	f8a4 3044 	strh.w	r3, [r4, #68]	@ 0x44
        hcryp->Instance->DINR = *(uint32_t *)(hcryp->Init.Header + hcryp->CrypHeaderCount);
 c03cc14:	f8b4 3044 	ldrh.w	r3, [r4, #68]	@ 0x44
 c03cc18:	b29b      	uxth	r3, r3
 c03cc1a:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
        if (CRYP_WaitOnCCFlag(hcryp, Timeout) != HAL_OK)
 c03cc1e:	4639      	mov	r1, r7
        hcryp->Instance->DINR = *(uint32_t *)(hcryp->Init.Header + hcryp->CrypHeaderCount);
 c03cc20:	6093      	str	r3, [r2, #8]
        hcryp->CrypHeaderCount++;
 c03cc22:	f8b4 3044 	ldrh.w	r3, [r4, #68]	@ 0x44
 c03cc26:	3301      	adds	r3, #1
 c03cc28:	b29b      	uxth	r3, r3
 c03cc2a:	f8a4 3044 	strh.w	r3, [r4, #68]	@ 0x44
        if (CRYP_WaitOnCCFlag(hcryp, Timeout) != HAL_OK)
 c03cc2e:	f7ff ff58 	bl	c03cae2 <CRYP_WaitOnCCFlag>
 c03cc32:	b118      	cbz	r0, c03cc3c <CRYP_GCMCCM_SetHeaderPhase+0x110>
          return HAL_ERROR;
 c03cc34:	2001      	movs	r0, #1
}
 c03cc36:	b00c      	add	sp, #48	@ 0x30
 c03cc38:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        __HAL_CRYP_CLEAR_FLAG(hcryp, CRYP_CLEAR_CCF);
 c03cc3c:	6822      	ldr	r2, [r4, #0]
      for (loopcounter = 0U; (loopcounter < (size_in_bytes / 4U)); loopcounter += 4U)
 c03cc3e:	3604      	adds	r6, #4
        __HAL_CRYP_CLEAR_FLAG(hcryp, CRYP_CLEAR_CCF);
 c03cc40:	f8d2 3308 	ldr.w	r3, [r2, #776]	@ 0x308
 c03cc44:	f043 0301 	orr.w	r3, r3, #1
 c03cc48:	f8c2 3308 	str.w	r3, [r2, #776]	@ 0x308
      for (loopcounter = 0U; (loopcounter < (size_in_bytes / 4U)); loopcounter += 4U)
 c03cc4c:	e7b7      	b.n	c03cbbe <CRYP_GCMCCM_SetHeaderPhase+0x92>
        hcryp->Instance->DINR = *(uint32_t *)(hcryp->Init.Header + hcryp->CrypHeaderCount);
 c03cc4e:	f8b4 2044 	ldrh.w	r2, [r4, #68]	@ 0x44
 c03cc52:	69a1      	ldr	r1, [r4, #24]
 c03cc54:	b292      	uxth	r2, r2
 c03cc56:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
        if (CRYP_WaitOnCCFlag(hcryp, Timeout) != HAL_OK)
 c03cc5a:	4620      	mov	r0, r4
        hcryp->Instance->DINR = *(uint32_t *)(hcryp->Init.Header + hcryp->CrypHeaderCount);
 c03cc5c:	609a      	str	r2, [r3, #8]
        hcryp->CrypHeaderCount++;
 c03cc5e:	f8b4 2044 	ldrh.w	r2, [r4, #68]	@ 0x44
 c03cc62:	3201      	adds	r2, #1
 c03cc64:	b292      	uxth	r2, r2
 c03cc66:	f8a4 2044 	strh.w	r2, [r4, #68]	@ 0x44
        hcryp->Instance->DINR = *(uint32_t *)(hcryp->Init.Header + hcryp->CrypHeaderCount);
 c03cc6a:	f8b4 2044 	ldrh.w	r2, [r4, #68]	@ 0x44
 c03cc6e:	b292      	uxth	r2, r2
 c03cc70:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
 c03cc74:	609a      	str	r2, [r3, #8]
        hcryp->CrypHeaderCount++;
 c03cc76:	f8b4 2044 	ldrh.w	r2, [r4, #68]	@ 0x44
 c03cc7a:	3201      	adds	r2, #1
 c03cc7c:	b292      	uxth	r2, r2
 c03cc7e:	f8a4 2044 	strh.w	r2, [r4, #68]	@ 0x44
        hcryp->Instance->DINR  = *(uint32_t *)(hcryp->Init.Header + hcryp->CrypHeaderCount);
 c03cc82:	f8b4 2044 	ldrh.w	r2, [r4, #68]	@ 0x44
 c03cc86:	b292      	uxth	r2, r2
 c03cc88:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
 c03cc8c:	609a      	str	r2, [r3, #8]
        hcryp->CrypHeaderCount++;
 c03cc8e:	f8b4 2044 	ldrh.w	r2, [r4, #68]	@ 0x44
 c03cc92:	3201      	adds	r2, #1
 c03cc94:	b292      	uxth	r2, r2
 c03cc96:	f8a4 2044 	strh.w	r2, [r4, #68]	@ 0x44
        hcryp->Instance->DINR = *(uint32_t *)(hcryp->Init.Header + hcryp->CrypHeaderCount);
 c03cc9a:	f8b4 2044 	ldrh.w	r2, [r4, #68]	@ 0x44
 c03cc9e:	b292      	uxth	r2, r2
 c03cca0:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
        if (CRYP_WaitOnCCFlag(hcryp, Timeout) != HAL_OK)
 c03cca4:	4639      	mov	r1, r7
        hcryp->Instance->DINR = *(uint32_t *)(hcryp->Init.Header + hcryp->CrypHeaderCount);
 c03cca6:	609a      	str	r2, [r3, #8]
        hcryp->CrypHeaderCount++;
 c03cca8:	f8b4 3044 	ldrh.w	r3, [r4, #68]	@ 0x44
 c03ccac:	3301      	adds	r3, #1
 c03ccae:	b29b      	uxth	r3, r3
 c03ccb0:	f8a4 3044 	strh.w	r3, [r4, #68]	@ 0x44
        if (CRYP_WaitOnCCFlag(hcryp, Timeout) != HAL_OK)
 c03ccb4:	f7ff ff15 	bl	c03cae2 <CRYP_WaitOnCCFlag>
 c03ccb8:	2800      	cmp	r0, #0
 c03ccba:	d1bb      	bne.n	c03cc34 <CRYP_GCMCCM_SetHeaderPhase+0x108>
        __HAL_CRYP_CLEAR_FLAG(hcryp, CRYP_CLEAR_CCF);
 c03ccbc:	6822      	ldr	r2, [r4, #0]
      for (loopcounter = 0U; (loopcounter < ((size_in_bytes / 16U) * 4U)); loopcounter += 4U)
 c03ccbe:	3604      	adds	r6, #4
        __HAL_CRYP_CLEAR_FLAG(hcryp, CRYP_CLEAR_CCF);
 c03ccc0:	f8d2 3308 	ldr.w	r3, [r2, #776]	@ 0x308
 c03ccc4:	f043 0301 	orr.w	r3, r3, #1
 c03ccc8:	f8c2 3308 	str.w	r3, [r2, #776]	@ 0x308
      for (loopcounter = 0U; (loopcounter < ((size_in_bytes / 16U) * 4U)); loopcounter += 4U)
 c03cccc:	e757      	b.n	c03cb7e <CRYP_GCMCCM_SetHeaderPhase+0x52>
        hcryp->Instance->DINR = *(uint32_t *)(hcryp->Init.Header + hcryp->CrypHeaderCount);
 c03ccce:	f8b4 0044 	ldrh.w	r0, [r4, #68]	@ 0x44
 c03ccd2:	69a6      	ldr	r6, [r4, #24]
 c03ccd4:	b280      	uxth	r0, r0
 c03ccd6:	f856 0020 	ldr.w	r0, [r6, r0, lsl #2]
 c03ccda:	3101      	adds	r1, #1
 c03ccdc:	6098      	str	r0, [r3, #8]
        hcryp->CrypHeaderCount++;
 c03ccde:	f8b4 0044 	ldrh.w	r0, [r4, #68]	@ 0x44
 c03cce2:	3001      	adds	r0, #1
 c03cce4:	b280      	uxth	r0, r0
 c03cce6:	f8a4 0044 	strh.w	r0, [r4, #68]	@ 0x44
      for (loopcounter = 0U; (loopcounter < ((size_in_bytes / 4U) % 4U)); loopcounter++)
 c03ccea:	e74e      	b.n	c03cb8a <CRYP_GCMCCM_SetHeaderPhase+0x5e>
        tmp =  *(uint32_t *)(hcryp->Init.Header + hcryp->CrypHeaderCount);
 c03ccec:	f8b4 1044 	ldrh.w	r1, [r4, #68]	@ 0x44
 c03ccf0:	69a0      	ldr	r0, [r4, #24]
 c03ccf2:	b289      	uxth	r1, r1
 c03ccf4:	f850 1021 	ldr.w	r1, [r0, r1, lsl #2]
        tmp &= mask[(hcryp->Init.DataType * 2U) + (size_in_bytes % 4U)];
 c03ccf8:	6860      	ldr	r0, [r4, #4]
      for (loopcounter = 0U; (loopcounter < ((size_in_bytes / 4U) % 4U)); loopcounter++)
 c03ccfa:	3201      	adds	r2, #1
        tmp &= mask[(hcryp->Init.DataType * 2U) + (size_in_bytes % 4U)];
 c03ccfc:	eb05 0540 	add.w	r5, r5, r0, lsl #1
 c03cd00:	a80c      	add	r0, sp, #48	@ 0x30
 c03cd02:	eb00 0585 	add.w	r5, r0, r5, lsl #2
 c03cd06:	f855 0c30 	ldr.w	r0, [r5, #-48]
 c03cd0a:	4001      	ands	r1, r0
        hcryp->Instance->DINR = tmp;
 c03cd0c:	6099      	str	r1, [r3, #8]
          hcryp->Instance->DINR = 0x0U;
 c03cd0e:	2100      	movs	r1, #0
        while (loopcounter < 4U)
 c03cd10:	2a04      	cmp	r2, #4
 c03cd12:	f43f af45 	beq.w	c03cba0 <CRYP_GCMCCM_SetHeaderPhase+0x74>
          hcryp->Instance->DINR = 0x0U;
 c03cd16:	6099      	str	r1, [r3, #8]
          loopcounter++;
 c03cd18:	3201      	adds	r2, #1
 c03cd1a:	e7f9      	b.n	c03cd10 <CRYP_GCMCCM_SetHeaderPhase+0x1e4>
    MODIFY_REG(hcryp->Instance->CR, AES_CR_DATATYPE, hcryp->Init.DataType);
 c03cd1c:	6861      	ldr	r1, [r4, #4]
 c03cd1e:	f022 0206 	bic.w	r2, r2, #6
 c03cd22:	430a      	orrs	r2, r1
 c03cd24:	601a      	str	r2, [r3, #0]
    CRYP_SET_PHASE(hcryp, CRYP_PHASE_HEADER);
 c03cd26:	681a      	ldr	r2, [r3, #0]
 c03cd28:	f422 42c0 	bic.w	r2, r2, #24576	@ 0x6000
 c03cd2c:	f442 5200 	orr.w	r2, r2, #8192	@ 0x2000
 c03cd30:	601a      	str	r2, [r3, #0]
    __HAL_CRYP_ENABLE(hcryp);
 c03cd32:	681a      	ldr	r2, [r3, #0]
 c03cd34:	f042 0201 	orr.w	r2, r2, #1
 c03cd38:	601a      	str	r2, [r3, #0]
 c03cd3a:	e742      	b.n	c03cbc2 <CRYP_GCMCCM_SetHeaderPhase+0x96>
 c03cd3c:	0c05faec 	.word	0x0c05faec

0c03cd40 <HAL_CRYP_SetConfig>:
  if ((hcryp == NULL) || (pConf == NULL))
 c03cd40:	4603      	mov	r3, r0
{
 c03cd42:	b5f0      	push	{r4, r5, r6, r7, lr}
  if ((hcryp == NULL) || (pConf == NULL))
 c03cd44:	2800      	cmp	r0, #0
 c03cd46:	d05d      	beq.n	c03ce04 <HAL_CRYP_SetConfig+0xc4>
 c03cd48:	2900      	cmp	r1, #0
 c03cd4a:	d05b      	beq.n	c03ce04 <HAL_CRYP_SetConfig+0xc4>
  if (hcryp->State == HAL_CRYP_STATE_READY)
 c03cd4c:	f890 2059 	ldrb.w	r2, [r0, #89]	@ 0x59
 c03cd50:	2a01      	cmp	r2, #1
 c03cd52:	b2d4      	uxtb	r4, r2
 c03cd54:	d152      	bne.n	c03cdfc <HAL_CRYP_SetConfig+0xbc>
    hcryp->State = HAL_CRYP_STATE_BUSY;
 c03cd56:	2002      	movs	r0, #2
    __HAL_LOCK(hcryp);
 c03cd58:	f893 2058 	ldrb.w	r2, [r3, #88]	@ 0x58
    hcryp->State = HAL_CRYP_STATE_BUSY;
 c03cd5c:	f883 0059 	strb.w	r0, [r3, #89]	@ 0x59
    __HAL_LOCK(hcryp);
 c03cd60:	2a01      	cmp	r2, #1
 c03cd62:	d033      	beq.n	c03cdcc <HAL_CRYP_SetConfig+0x8c>
 c03cd64:	f883 4058 	strb.w	r4, [r3, #88]	@ 0x58
    hcryp->Init.pKey       = pConf->pKey;
 c03cd68:	688a      	ldr	r2, [r1, #8]
    hcryp->Init.pInitVect  = pConf->pInitVect;
 c03cd6a:	68c8      	ldr	r0, [r1, #12]
    hcryp->Init.DataType   = pConf->DataType;
 c03cd6c:	680c      	ldr	r4, [r1, #0]
    hcryp->Init.Algorithm  = pConf->Algorithm;
 c03cd6e:	690e      	ldr	r6, [r1, #16]
    hcryp->Init.pKey       = pConf->pKey;
 c03cd70:	60da      	str	r2, [r3, #12]
    hcryp->Init.KeySize    = pConf->KeySize;
 c03cd72:	684a      	ldr	r2, [r1, #4]
    hcryp->Init.pInitVect  = pConf->pInitVect;
 c03cd74:	6118      	str	r0, [r3, #16]
    hcryp->Init.Header     = pConf->Header;
 c03cd76:	6948      	ldr	r0, [r1, #20]
    hcryp->Init.KeyMode = pConf->KeyMode;
 c03cd78:	6acd      	ldr	r5, [r1, #44]	@ 0x2c
    hcryp->Init.Header     = pConf->Header;
 c03cd7a:	6198      	str	r0, [r3, #24]
    hcryp->Init.HeaderSize = pConf->HeaderSize;
 c03cd7c:	6988      	ldr	r0, [r1, #24]
    hcryp->Init.DataType   = pConf->DataType;
 c03cd7e:	605c      	str	r4, [r3, #4]
    hcryp->Init.HeaderSize = pConf->HeaderSize;
 c03cd80:	61d8      	str	r0, [r3, #28]
    hcryp->Init.B0         = pConf->B0;
 c03cd82:	69c8      	ldr	r0, [r1, #28]
    hcryp->Init.Algorithm  = pConf->Algorithm;
 c03cd84:	615e      	str	r6, [r3, #20]
    hcryp->Init.B0         = pConf->B0;
 c03cd86:	6218      	str	r0, [r3, #32]
    hcryp->Init.DataWidthUnit = pConf->DataWidthUnit;
 c03cd88:	6a08      	ldr	r0, [r1, #32]
 c03cd8a:	4334      	orrs	r4, r6
 c03cd8c:	6258      	str	r0, [r3, #36]	@ 0x24
    hcryp->Init.HeaderWidthUnit = pConf->HeaderWidthUnit;
 c03cd8e:	6a48      	ldr	r0, [r1, #36]	@ 0x24
    if (hcryp->Instance == AES)
 c03cd90:	4e1d      	ldr	r6, [pc, #116]	@ (c03ce08 <HAL_CRYP_SetConfig+0xc8>)
    hcryp->Init.HeaderWidthUnit = pConf->HeaderWidthUnit;
 c03cd92:	6298      	str	r0, [r3, #40]	@ 0x28
    hcryp->Init.KeyIVConfigSkip = pConf->KeyIVConfigSkip;
 c03cd94:	6a88      	ldr	r0, [r1, #40]	@ 0x28
    hcryp->Init.KeySize    = pConf->KeySize;
 c03cd96:	609a      	str	r2, [r3, #8]
    hcryp->Init.KeyIVConfigSkip = pConf->KeyIVConfigSkip;
 c03cd98:	62d8      	str	r0, [r3, #44]	@ 0x2c
    if (hcryp->Instance == AES)
 c03cd9a:	6818      	ldr	r0, [r3, #0]
    hcryp->Init.KeyMode = pConf->KeyMode;
 c03cd9c:	631d      	str	r5, [r3, #48]	@ 0x30
    if (hcryp->Instance == AES)
 c03cd9e:	42b0      	cmp	r0, r6
 c03cda0:	d115      	bne.n	c03cdce <HAL_CRYP_SetConfig+0x8e>
      MODIFY_REG(hcryp->Instance->CR, AES_CR_DATATYPE | AES_CR_KEYSIZE | AES_CR_CHMOD | AES_CR_KMOD,
 c03cda2:	6806      	ldr	r6, [r0, #0]
 c03cda4:	4919      	ldr	r1, [pc, #100]	@ (c03ce0c <HAL_CRYP_SetConfig+0xcc>)
 c03cda6:	4315      	orrs	r5, r2
 c03cda8:	4031      	ands	r1, r6
 c03cdaa:	4329      	orrs	r1, r5
 c03cdac:	4321      	orrs	r1, r4
 c03cdae:	6001      	str	r1, [r0, #0]
    __HAL_CRYP_CLEAR_FLAG(hcryp, CRYP_CLEAR_RWEIF);
 c03cdb0:	f8d0 2308 	ldr.w	r2, [r0, #776]	@ 0x308
 c03cdb4:	f042 0202 	orr.w	r2, r2, #2
 c03cdb8:	f8c0 2308 	str.w	r2, [r0, #776]	@ 0x308
    __HAL_UNLOCK(hcryp);
 c03cdbc:	2000      	movs	r0, #0
    hcryp->State = HAL_CRYP_STATE_READY;
 c03cdbe:	2201      	movs	r2, #1
    hcryp->ErrorCode = HAL_CRYP_ERROR_NONE;
 c03cdc0:	65d8      	str	r0, [r3, #92]	@ 0x5c
    __HAL_UNLOCK(hcryp);
 c03cdc2:	f883 0058 	strb.w	r0, [r3, #88]	@ 0x58
    hcryp->State = HAL_CRYP_STATE_READY;
 c03cdc6:	f883 2059 	strb.w	r2, [r3, #89]	@ 0x59
    hcryp->Phase = CRYP_PHASE_READY;
 c03cdca:	64da      	str	r2, [r3, #76]	@ 0x4c
}
 c03cdcc:	bdf0      	pop	{r4, r5, r6, r7, pc}
      hcryp->Init.KeySelect        = pConf->KeySelect;
 c03cdce:	6b0e      	ldr	r6, [r1, #48]	@ 0x30
      hcryp->Init.KeyProtection    = pConf->KeyProtection;
 c03cdd0:	6b4f      	ldr	r7, [r1, #52]	@ 0x34
      hcryp->Init.KeySelect        = pConf->KeySelect;
 c03cdd2:	635e      	str	r6, [r3, #52]	@ 0x34
      hcryp->Init.KeyProtection    = pConf->KeyProtection;
 c03cdd4:	639f      	str	r7, [r3, #56]	@ 0x38
      if ((hcryp->Init.KeySelect != CRYP_KEYSEL_NORMAL) && (hcryp->Init.KeyMode == CRYP_KEYMODE_WRAPPED))
 c03cdd6:	b146      	cbz	r6, c03cdea <HAL_CRYP_SetConfig+0xaa>
 c03cdd8:	f1b5 7f80 	cmp.w	r5, #16777216	@ 0x1000000
        MODIFY_REG(hcryp->Instance->CR, AES_CR_KMOD, CRYP_KEYMODE_WRAPPED);
 c03cddc:	bf01      	itttt	eq
 c03cdde:	6801      	ldreq	r1, [r0, #0]
 c03cde0:	f021 7140 	biceq.w	r1, r1, #50331648	@ 0x3000000
 c03cde4:	f041 7180 	orreq.w	r1, r1, #16777216	@ 0x1000000
 c03cde8:	6001      	streq	r1, [r0, #0]
      MODIFY_REG(hcryp->Instance->CR, AES_CR_DATATYPE | AES_CR_KEYSIZE | AES_CR_CHMOD | \
 c03cdea:	6805      	ldr	r5, [r0, #0]
 c03cdec:	4908      	ldr	r1, [pc, #32]	@ (c03ce10 <HAL_CRYP_SetConfig+0xd0>)
 c03cdee:	4332      	orrs	r2, r6
 c03cdf0:	433a      	orrs	r2, r7
 c03cdf2:	4322      	orrs	r2, r4
 c03cdf4:	4029      	ands	r1, r5
 c03cdf6:	430a      	orrs	r2, r1
 c03cdf8:	6002      	str	r2, [r0, #0]
 c03cdfa:	e7d9      	b.n	c03cdb0 <HAL_CRYP_SetConfig+0x70>
    hcryp->ErrorCode |= HAL_CRYP_ERROR_BUSY;
 c03cdfc:	6dc2      	ldr	r2, [r0, #92]	@ 0x5c
 c03cdfe:	f042 0208 	orr.w	r2, r2, #8
 c03ce02:	65c2      	str	r2, [r0, #92]	@ 0x5c
    return HAL_ERROR;
 c03ce04:	2001      	movs	r0, #1
 c03ce06:	e7e1      	b.n	c03cdcc <HAL_CRYP_SetConfig+0x8c>
 c03ce08:	520c0000 	.word	0x520c0000
 c03ce0c:	fcfaff99 	.word	0xfcfaff99
 c03ce10:	8ff2ff99 	.word	0x8ff2ff99

0c03ce14 <HAL_CRYP_MspInit>:
}
 c03ce14:	4770      	bx	lr
	...

0c03ce18 <HAL_CRYP_Init>:
{
 c03ce18:	b538      	push	{r3, r4, r5, lr}
  if (hcryp == NULL)
 c03ce1a:	4604      	mov	r4, r0
 c03ce1c:	2800      	cmp	r0, #0
 c03ce1e:	d04a      	beq.n	c03ceb6 <HAL_CRYP_Init+0x9e>
  if (hcryp->State == HAL_CRYP_STATE_RESET)
 c03ce20:	f890 3059 	ldrb.w	r3, [r0, #89]	@ 0x59
 c03ce24:	f003 02ff 	and.w	r2, r3, #255	@ 0xff
 c03ce28:	b91b      	cbnz	r3, c03ce32 <HAL_CRYP_Init+0x1a>
    hcryp->Lock = HAL_UNLOCKED;
 c03ce2a:	f880 2058 	strb.w	r2, [r0, #88]	@ 0x58
    HAL_CRYP_MspInit(hcryp);
 c03ce2e:	f7ff fff1 	bl	c03ce14 <HAL_CRYP_MspInit>
  if (hcryp->Instance == AES)
 c03ce32:	6822      	ldr	r2, [r4, #0]
 c03ce34:	4b21      	ldr	r3, [pc, #132]	@ (c03cebc <HAL_CRYP_Init+0xa4>)
 c03ce36:	429a      	cmp	r2, r3
 c03ce38:	d113      	bne.n	c03ce62 <HAL_CRYP_Init+0x4a>
    cr_value = (uint32_t)(hcryp->Init.DataType | hcryp->Init.KeySize | hcryp->Init.Algorithm | hcryp->Init.KeyMode);
 c03ce3a:	e9d4 3101 	ldrd	r3, r1, [r4, #4]
    MODIFY_REG(hcryp->Instance->CR, AES_CR_KMOD | AES_CR_DATATYPE | AES_CR_KEYSIZE | AES_CR_CHMOD, cr_value);
 c03ce3e:	6810      	ldr	r0, [r2, #0]
    cr_value = (uint32_t)(hcryp->Init.DataType | hcryp->Init.KeySize | hcryp->Init.Algorithm | hcryp->Init.KeyMode);
 c03ce40:	430b      	orrs	r3, r1
    MODIFY_REG(hcryp->Instance->CR, AES_CR_KMOD | AES_CR_DATATYPE | AES_CR_KEYSIZE | AES_CR_CHMOD, cr_value);
 c03ce42:	491f      	ldr	r1, [pc, #124]	@ (c03cec0 <HAL_CRYP_Init+0xa8>)
 c03ce44:	4001      	ands	r1, r0
 c03ce46:	430b      	orrs	r3, r1
 c03ce48:	6961      	ldr	r1, [r4, #20]
 c03ce4a:	430b      	orrs	r3, r1
 c03ce4c:	6b21      	ldr	r1, [r4, #48]	@ 0x30
    MODIFY_REG(hcryp->Instance->CR, AES_CR_KMOD | AES_CR_DATATYPE | AES_CR_KEYSIZE | AES_CR_CHMOD | AES_CR_KEYSEL |
 c03ce4e:	430b      	orrs	r3, r1
 c03ce50:	6013      	str	r3, [r2, #0]
  hcryp->ErrorCode = HAL_CRYP_ERROR_NONE;
 c03ce52:	2000      	movs	r0, #0
  hcryp->State = HAL_CRYP_STATE_READY;
 c03ce54:	2301      	movs	r3, #1
  hcryp->ErrorCode = HAL_CRYP_ERROR_NONE;
 c03ce56:	65e0      	str	r0, [r4, #92]	@ 0x5c
  hcryp->KeyIVConfig = 0U;
 c03ce58:	6620      	str	r0, [r4, #96]	@ 0x60
  hcryp->State = HAL_CRYP_STATE_READY;
 c03ce5a:	f884 3059 	strb.w	r3, [r4, #89]	@ 0x59
  hcryp->Phase = CRYP_PHASE_READY;
 c03ce5e:	64e3      	str	r3, [r4, #76]	@ 0x4c
  return HAL_OK;
 c03ce60:	e02a      	b.n	c03ceb8 <HAL_CRYP_Init+0xa0>
    tickstart = HAL_GetTick();
 c03ce62:	f006 ff41 	bl	c043ce8 <HAL_GetTick>
 c03ce66:	4605      	mov	r5, r0
    while (HAL_IS_BIT_SET(hcryp->Instance->SR, CRYP_FLAG_BUSY))
 c03ce68:	6822      	ldr	r2, [r4, #0]
 c03ce6a:	6853      	ldr	r3, [r2, #4]
 c03ce6c:	071b      	lsls	r3, r3, #28
 c03ce6e:	d40e      	bmi.n	c03ce8e <HAL_CRYP_Init+0x76>
    cr_value = (uint32_t)(hcryp->Init.KeyMode | hcryp->Init.DataType | hcryp->Init.KeySize | \
 c03ce70:	6861      	ldr	r1, [r4, #4]
 c03ce72:	6b23      	ldr	r3, [r4, #48]	@ 0x30
    MODIFY_REG(hcryp->Instance->CR, AES_CR_KMOD | AES_CR_DATATYPE | AES_CR_KEYSIZE | AES_CR_CHMOD | AES_CR_KEYSEL |
 c03ce74:	6810      	ldr	r0, [r2, #0]
    cr_value = (uint32_t)(hcryp->Init.KeyMode | hcryp->Init.DataType | hcryp->Init.KeySize | \
 c03ce76:	430b      	orrs	r3, r1
 c03ce78:	68a1      	ldr	r1, [r4, #8]
 c03ce7a:	430b      	orrs	r3, r1
 c03ce7c:	6961      	ldr	r1, [r4, #20]
 c03ce7e:	430b      	orrs	r3, r1
                          hcryp->Init.Algorithm | hcryp->Init.KeySelect | hcryp->Init.KeyProtection);
 c03ce80:	6b61      	ldr	r1, [r4, #52]	@ 0x34
 c03ce82:	430b      	orrs	r3, r1
    cr_value = (uint32_t)(hcryp->Init.KeyMode | hcryp->Init.DataType | hcryp->Init.KeySize | \
 c03ce84:	6ba1      	ldr	r1, [r4, #56]	@ 0x38
 c03ce86:	430b      	orrs	r3, r1
    MODIFY_REG(hcryp->Instance->CR, AES_CR_KMOD | AES_CR_DATATYPE | AES_CR_KEYSIZE | AES_CR_CHMOD | AES_CR_KEYSEL |
 c03ce88:	490e      	ldr	r1, [pc, #56]	@ (c03cec4 <HAL_CRYP_Init+0xac>)
 c03ce8a:	4001      	ands	r1, r0
 c03ce8c:	e7df      	b.n	c03ce4e <HAL_CRYP_Init+0x36>
      if ((HAL_GetTick() - tickstart) > CRYP_GENERAL_TIMEOUT)
 c03ce8e:	f006 ff2b 	bl	c043ce8 <HAL_GetTick>
 c03ce92:	1b40      	subs	r0, r0, r5
 c03ce94:	2852      	cmp	r0, #82	@ 0x52
 c03ce96:	d9e7      	bls.n	c03ce68 <HAL_CRYP_Init+0x50>
        __HAL_CRYP_DISABLE(hcryp);
 c03ce98:	6822      	ldr	r2, [r4, #0]
 c03ce9a:	6813      	ldr	r3, [r2, #0]
 c03ce9c:	f023 0301 	bic.w	r3, r3, #1
 c03cea0:	6013      	str	r3, [r2, #0]
        hcryp->ErrorCode |= HAL_CRYP_ERROR_TIMEOUT;
 c03cea2:	6de3      	ldr	r3, [r4, #92]	@ 0x5c
 c03cea4:	f043 0310 	orr.w	r3, r3, #16
 c03cea8:	65e3      	str	r3, [r4, #92]	@ 0x5c
        hcryp->State = HAL_CRYP_STATE_READY;
 c03ceaa:	2301      	movs	r3, #1
 c03ceac:	f884 3059 	strb.w	r3, [r4, #89]	@ 0x59
        __HAL_UNLOCK(hcryp);
 c03ceb0:	2300      	movs	r3, #0
 c03ceb2:	f884 3058 	strb.w	r3, [r4, #88]	@ 0x58
    return HAL_ERROR;
 c03ceb6:	2001      	movs	r0, #1
}
 c03ceb8:	bd38      	pop	{r3, r4, r5, pc}
 c03ceba:	bf00      	nop
 c03cebc:	520c0000 	.word	0x520c0000
 c03cec0:	fcfaff99 	.word	0xfcfaff99
 c03cec4:	8cf2ff99 	.word	0x8cf2ff99

0c03cec8 <HAL_CRYP_MspDeInit>:
__weak void HAL_CRYP_MspDeInit(CRYP_HandleTypeDef *hcryp)
 c03cec8:	4770      	bx	lr

0c03ceca <HAL_CRYP_DeInit>:
{
 c03ceca:	b538      	push	{r3, r4, r5, lr}
  if (hcryp == NULL)
 c03cecc:	4605      	mov	r5, r0
 c03cece:	2401      	movs	r4, #1
 c03ced0:	b1d0      	cbz	r0, c03cf08 <HAL_CRYP_DeInit+0x3e>
  hcryp->Phase = CRYP_PHASE_READY;
 c03ced2:	64c4      	str	r4, [r0, #76]	@ 0x4c
  hcryp->CrypInCount = 0;
 c03ced4:	2400      	movs	r4, #0
  __HAL_CRYP_DISABLE(hcryp);
 c03ced6:	6803      	ldr	r3, [r0, #0]
  hcryp->CrypInCount = 0;
 c03ced8:	f8a0 4046 	strh.w	r4, [r0, #70]	@ 0x46
  hcryp->CrypOutCount = 0;
 c03cedc:	f8a0 4048 	strh.w	r4, [r0, #72]	@ 0x48
  hcryp->CrypHeaderCount = 0;
 c03cee0:	f8a0 4044 	strh.w	r4, [r0, #68]	@ 0x44
  __HAL_CRYP_DISABLE(hcryp);
 c03cee4:	681a      	ldr	r2, [r3, #0]
 c03cee6:	f022 0201 	bic.w	r2, r2, #1
 c03ceea:	601a      	str	r2, [r3, #0]
  SET_BIT(hcryp->Instance->CR, AES_CR_IPRST);
 c03ceec:	681a      	ldr	r2, [r3, #0]
 c03ceee:	f042 4200 	orr.w	r2, r2, #2147483648	@ 0x80000000
 c03cef2:	601a      	str	r2, [r3, #0]
  CLEAR_BIT(hcryp->Instance->CR, AES_CR_IPRST);
 c03cef4:	681a      	ldr	r2, [r3, #0]
 c03cef6:	f022 4200 	bic.w	r2, r2, #2147483648	@ 0x80000000
 c03cefa:	601a      	str	r2, [r3, #0]
  HAL_CRYP_MspDeInit(hcryp);
 c03cefc:	f7ff ffe4 	bl	c03cec8 <HAL_CRYP_MspDeInit>
  hcryp->State = HAL_CRYP_STATE_RESET;
 c03cf00:	f885 4059 	strb.w	r4, [r5, #89]	@ 0x59
  __HAL_UNLOCK(hcryp);
 c03cf04:	f885 4058 	strb.w	r4, [r5, #88]	@ 0x58
    return HAL_ERROR;
 c03cf08:	4620      	mov	r0, r4
}
 c03cf0a:	bd38      	pop	{r3, r4, r5, pc}

0c03cf0c <HAL_CRYP_ErrorCallback>:
__weak void HAL_CRYP_ErrorCallback(CRYP_HandleTypeDef *hcryp)
 c03cf0c:	4770      	bx	lr

0c03cf0e <CRYP_AES_ProcessData>:
{
 c03cf0e:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
  hcryp->Instance->DINR  = *(uint32_t *)(hcryp->pCrypInBuffPtr + hcryp->CrypInCount);
 c03cf10:	f8b0 3046 	ldrh.w	r3, [r0, #70]	@ 0x46
 c03cf14:	6bc5      	ldr	r5, [r0, #60]	@ 0x3c
 c03cf16:	b29b      	uxth	r3, r3
 c03cf18:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
 c03cf1c:	6802      	ldr	r2, [r0, #0]
{
 c03cf1e:	4604      	mov	r4, r0
  hcryp->Instance->DINR  = *(uint32_t *)(hcryp->pCrypInBuffPtr + hcryp->CrypInCount);
 c03cf20:	6093      	str	r3, [r2, #8]
  hcryp->CrypInCount++;
 c03cf22:	f8b0 3046 	ldrh.w	r3, [r0, #70]	@ 0x46
 c03cf26:	3301      	adds	r3, #1
 c03cf28:	b29b      	uxth	r3, r3
 c03cf2a:	f8a0 3046 	strh.w	r3, [r0, #70]	@ 0x46
  hcryp->Instance->DINR  = *(uint32_t *)(hcryp->pCrypInBuffPtr + hcryp->CrypInCount);
 c03cf2e:	f8b0 3046 	ldrh.w	r3, [r0, #70]	@ 0x46
 c03cf32:	b29b      	uxth	r3, r3
 c03cf34:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
 c03cf38:	6093      	str	r3, [r2, #8]
  hcryp->CrypInCount++;
 c03cf3a:	f8b0 3046 	ldrh.w	r3, [r0, #70]	@ 0x46
 c03cf3e:	3301      	adds	r3, #1
 c03cf40:	b29b      	uxth	r3, r3
 c03cf42:	f8a0 3046 	strh.w	r3, [r0, #70]	@ 0x46
  hcryp->Instance->DINR  = *(uint32_t *)(hcryp->pCrypInBuffPtr + hcryp->CrypInCount);
 c03cf46:	f8b0 3046 	ldrh.w	r3, [r0, #70]	@ 0x46
 c03cf4a:	b29b      	uxth	r3, r3
 c03cf4c:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
 c03cf50:	6093      	str	r3, [r2, #8]
  hcryp->CrypInCount++;
 c03cf52:	f8b0 3046 	ldrh.w	r3, [r0, #70]	@ 0x46
 c03cf56:	3301      	adds	r3, #1
 c03cf58:	b29b      	uxth	r3, r3
 c03cf5a:	f8a0 3046 	strh.w	r3, [r0, #70]	@ 0x46
  hcryp->Instance->DINR  = *(uint32_t *)(hcryp->pCrypInBuffPtr + hcryp->CrypInCount);
 c03cf5e:	f8b0 3046 	ldrh.w	r3, [r0, #70]	@ 0x46
 c03cf62:	b29b      	uxth	r3, r3
 c03cf64:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
 c03cf68:	6093      	str	r3, [r2, #8]
  hcryp->CrypInCount++;
 c03cf6a:	f8b0 3046 	ldrh.w	r3, [r0, #70]	@ 0x46
 c03cf6e:	3301      	adds	r3, #1
 c03cf70:	b29b      	uxth	r3, r3
 c03cf72:	f8a0 3046 	strh.w	r3, [r0, #70]	@ 0x46
  if (CRYP_WaitOnCCFlag(hcryp, Timeout) != HAL_OK)
 c03cf76:	f7ff fdb4 	bl	c03cae2 <CRYP_WaitOnCCFlag>
 c03cf7a:	b110      	cbz	r0, c03cf82 <CRYP_AES_ProcessData+0x74>
    HAL_CRYP_ErrorCallback(hcryp);
 c03cf7c:	4620      	mov	r0, r4
 c03cf7e:	f7ff ffc5 	bl	c03cf0c <HAL_CRYP_ErrorCallback>
  __HAL_CRYP_CLEAR_FLAG(hcryp, CRYP_CLEAR_CCF);
 c03cf82:	4668      	mov	r0, sp
  i = 0U;
 c03cf84:	2100      	movs	r1, #0
  __HAL_CRYP_CLEAR_FLAG(hcryp, CRYP_CLEAR_CCF);
 c03cf86:	6823      	ldr	r3, [r4, #0]
 c03cf88:	f8d3 2308 	ldr.w	r2, [r3, #776]	@ 0x308
 c03cf8c:	f042 0201 	orr.w	r2, r2, #1
 c03cf90:	f8c3 2308 	str.w	r2, [r3, #776]	@ 0x308
    temp[i] = hcryp->Instance->DOUTR;
 c03cf94:	68da      	ldr	r2, [r3, #12]
 c03cf96:	9200      	str	r2, [sp, #0]
 c03cf98:	68da      	ldr	r2, [r3, #12]
 c03cf9a:	9201      	str	r2, [sp, #4]
 c03cf9c:	68da      	ldr	r2, [r3, #12]
 c03cf9e:	68db      	ldr	r3, [r3, #12]
 c03cfa0:	9202      	str	r2, [sp, #8]
 c03cfa2:	9303      	str	r3, [sp, #12]
  while ((hcryp->CrypOutCount < ((hcryp->Size + 3U) / 4U)) && (i < 4U))
 c03cfa4:	f8b4 304a 	ldrh.w	r3, [r4, #74]	@ 0x4a
 c03cfa8:	3303      	adds	r3, #3
 c03cfaa:	089b      	lsrs	r3, r3, #2
 c03cfac:	f8b4 2048 	ldrh.w	r2, [r4, #72]	@ 0x48
 c03cfb0:	b292      	uxth	r2, r2
 c03cfb2:	429a      	cmp	r2, r3
 c03cfb4:	d201      	bcs.n	c03cfba <CRYP_AES_ProcessData+0xac>
 c03cfb6:	2904      	cmp	r1, #4
 c03cfb8:	d101      	bne.n	c03cfbe <CRYP_AES_ProcessData+0xb0>
}
 c03cfba:	b004      	add	sp, #16
 c03cfbc:	bd70      	pop	{r4, r5, r6, pc}
    *(uint32_t *)(hcryp->pCrypOutBuffPtr + hcryp->CrypOutCount) = temp[i];
 c03cfbe:	f8b4 2048 	ldrh.w	r2, [r4, #72]	@ 0x48
 c03cfc2:	f850 6b04 	ldr.w	r6, [r0], #4
 c03cfc6:	6c25      	ldr	r5, [r4, #64]	@ 0x40
 c03cfc8:	b292      	uxth	r2, r2
 c03cfca:	f845 6022 	str.w	r6, [r5, r2, lsl #2]
    hcryp->CrypOutCount++;
 c03cfce:	f8b4 2048 	ldrh.w	r2, [r4, #72]	@ 0x48
    i++;
 c03cfd2:	3101      	adds	r1, #1
    hcryp->CrypOutCount++;
 c03cfd4:	3201      	adds	r2, #1
 c03cfd6:	b292      	uxth	r2, r2
 c03cfd8:	f8a4 2048 	strh.w	r2, [r4, #72]	@ 0x48
    i++;
 c03cfdc:	e7e6      	b.n	c03cfac <CRYP_AES_ProcessData+0x9e>

0c03cfde <CRYP_AESCCM_Process>:
{
 c03cfde:	b5f0      	push	{r4, r5, r6, r7, lr}
  if (hcryp->Init.KeyIVConfigSkip == CRYP_KEYIVCONFIG_ONCE)
 c03cfe0:	6ac3      	ldr	r3, [r0, #44]	@ 0x2c
{
 c03cfe2:	4604      	mov	r4, r0
  if (hcryp->Init.KeyIVConfigSkip == CRYP_KEYIVCONFIG_ONCE)
 c03cfe4:	2b01      	cmp	r3, #1
{
 c03cfe6:	460e      	mov	r6, r1
  uint32_t wordsize = ((uint32_t)hcryp->Size / 4U);
 c03cfe8:	f8b0 704a 	ldrh.w	r7, [r0, #74]	@ 0x4a
{
 c03cfec:	b085      	sub	sp, #20
  if (hcryp->Init.KeyIVConfigSkip == CRYP_KEYIVCONFIG_ONCE)
 c03cfee:	d121      	bne.n	c03d034 <CRYP_AESCCM_Process+0x56>
    if (hcryp->KeyIVConfig == 1U)
 c03cff0:	6e02      	ldr	r2, [r0, #96]	@ 0x60
 c03cff2:	2a01      	cmp	r2, #1
 c03cff4:	d11d      	bne.n	c03d032 <CRYP_AESCCM_Process+0x54>
      hcryp->SizesSum += hcryp->Size; /* Compute message total payload length */
 c03cff6:	6e43      	ldr	r3, [r0, #100]	@ 0x64
 c03cff8:	443b      	add	r3, r7
 c03cffa:	6643      	str	r3, [r0, #100]	@ 0x64
  if ((hcryp->Size % 16U) != 0U)
 c03cffc:	f8b4 304a 	ldrh.w	r3, [r4, #74]	@ 0x4a
  uint32_t wordsize = ((uint32_t)hcryp->Size / 4U);
 c03d000:	08bd      	lsrs	r5, r7, #2
  if ((hcryp->Size % 16U) != 0U)
 c03d002:	0718      	lsls	r0, r3, #28
    wordsize = ((wordsize / 4U) * 4U);
 c03d004:	bf18      	it	ne
 c03d006:	f025 0503 	bicne.w	r5, r5, #3
  tickstart = HAL_GetTick();
 c03d00a:	f006 fe6d 	bl	c043ce8 <HAL_GetTick>
 c03d00e:	4607      	mov	r7, r0
    incount = hcryp->CrypInCount;
 c03d010:	f8b4 2046 	ldrh.w	r2, [r4, #70]	@ 0x46
    outcount = hcryp->CrypOutCount;
 c03d014:	f8b4 3048 	ldrh.w	r3, [r4, #72]	@ 0x48
    incount = hcryp->CrypInCount;
 c03d018:	b292      	uxth	r2, r2
  while ((incount < wordsize) && (outcount < wordsize))
 c03d01a:	4295      	cmp	r5, r2
    outcount = hcryp->CrypOutCount;
 c03d01c:	b29b      	uxth	r3, r3
  while ((incount < wordsize) && (outcount < wordsize))
 c03d01e:	d901      	bls.n	c03d024 <CRYP_AESCCM_Process+0x46>
 c03d020:	429d      	cmp	r5, r3
 c03d022:	d84a      	bhi.n	c03d0ba <CRYP_AESCCM_Process+0xdc>
  if ((hcryp->Size % 16U) != 0U)
 c03d024:	f8b4 504a 	ldrh.w	r5, [r4, #74]	@ 0x4a
 c03d028:	072a      	lsls	r2, r5, #28
 c03d02a:	d164      	bne.n	c03d0f6 <CRYP_AESCCM_Process+0x118>
  return HAL_OK;
 c03d02c:	2000      	movs	r0, #0
}
 c03d02e:	b005      	add	sp, #20
 c03d030:	bdf0      	pop	{r4, r5, r6, r7, pc}
      hcryp->KeyIVConfig = 1U;
 c03d032:	6603      	str	r3, [r0, #96]	@ 0x60
    hcryp->CrypHeaderCount = 0U;
 c03d034:	2300      	movs	r3, #0
    CRYP_SET_PHASE(hcryp, CRYP_PHASE_INIT);
 c03d036:	6825      	ldr	r5, [r4, #0]
    hcryp->CrypHeaderCount = 0U;
 c03d038:	f8a4 3044 	strh.w	r3, [r4, #68]	@ 0x44
    CRYP_SET_PHASE(hcryp, CRYP_PHASE_INIT);
 c03d03c:	682b      	ldr	r3, [r5, #0]
    hcryp->SizesSum = hcryp->Size;
 c03d03e:	6667      	str	r7, [r4, #100]	@ 0x64
    CRYP_SET_PHASE(hcryp, CRYP_PHASE_INIT);
 c03d040:	f423 43c0 	bic.w	r3, r3, #24576	@ 0x6000
 c03d044:	602b      	str	r3, [r5, #0]
    if (hcryp->Init.KeyMode != CRYP_KEYMODE_SHARED)
 c03d046:	6b23      	ldr	r3, [r4, #48]	@ 0x30
 c03d048:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
 c03d04c:	d030      	beq.n	c03d0b0 <CRYP_AESCCM_Process+0xd2>
      CRYP_SetKey(hcryp, hcryp->Init.KeySize);
 c03d04e:	4620      	mov	r0, r4
 c03d050:	68a1      	ldr	r1, [r4, #8]
 c03d052:	f7ff fd19 	bl	c03ca88 <CRYP_SetKey>
    hcryp->Instance->IVR3 = *(uint32_t *)(hcryp->Init.B0);
 c03d056:	6a23      	ldr	r3, [r4, #32]
    if (CRYP_WaitOnCCFlag(hcryp, Timeout) != HAL_OK)
 c03d058:	4631      	mov	r1, r6
    hcryp->Instance->IVR3 = *(uint32_t *)(hcryp->Init.B0);
 c03d05a:	681a      	ldr	r2, [r3, #0]
    if (CRYP_WaitOnCCFlag(hcryp, Timeout) != HAL_OK)
 c03d05c:	4620      	mov	r0, r4
    hcryp->Instance->IVR3 = *(uint32_t *)(hcryp->Init.B0);
 c03d05e:	62ea      	str	r2, [r5, #44]	@ 0x2c
    hcryp->Instance->IVR2 = *(uint32_t *)(hcryp->Init.B0 + 1U);
 c03d060:	685a      	ldr	r2, [r3, #4]
 c03d062:	62aa      	str	r2, [r5, #40]	@ 0x28
    hcryp->Instance->IVR1 = *(uint32_t *)(hcryp->Init.B0 + 2U);
 c03d064:	689a      	ldr	r2, [r3, #8]
 c03d066:	626a      	str	r2, [r5, #36]	@ 0x24
    hcryp->Instance->IVR0 = *(uint32_t *)(hcryp->Init.B0 + 3U);
 c03d068:	68db      	ldr	r3, [r3, #12]
 c03d06a:	622b      	str	r3, [r5, #32]
    __HAL_CRYP_ENABLE(hcryp);
 c03d06c:	682b      	ldr	r3, [r5, #0]
 c03d06e:	f043 0301 	orr.w	r3, r3, #1
 c03d072:	602b      	str	r3, [r5, #0]
    if (CRYP_WaitOnCCFlag(hcryp, Timeout) != HAL_OK)
 c03d074:	f7ff fd35 	bl	c03cae2 <CRYP_WaitOnCCFlag>
 c03d078:	2800      	cmp	r0, #0
 c03d07a:	d13a      	bne.n	c03d0f2 <CRYP_AESCCM_Process+0x114>
    __HAL_CRYP_CLEAR_FLAG(hcryp, CRYP_CLEAR_CCF);
 c03d07c:	6822      	ldr	r2, [r4, #0]
    if (CRYP_GCMCCM_SetHeaderPhase(hcryp,  Timeout) != HAL_OK)
 c03d07e:	4631      	mov	r1, r6
    __HAL_CRYP_CLEAR_FLAG(hcryp, CRYP_CLEAR_CCF);
 c03d080:	f8d2 3308 	ldr.w	r3, [r2, #776]	@ 0x308
    if (CRYP_GCMCCM_SetHeaderPhase(hcryp,  Timeout) != HAL_OK)
 c03d084:	4620      	mov	r0, r4
    __HAL_CRYP_CLEAR_FLAG(hcryp, CRYP_CLEAR_CCF);
 c03d086:	f043 0301 	orr.w	r3, r3, #1
 c03d08a:	f8c2 3308 	str.w	r3, [r2, #776]	@ 0x308
    if (CRYP_GCMCCM_SetHeaderPhase(hcryp,  Timeout) != HAL_OK)
 c03d08e:	f7ff fd4d 	bl	c03cb2c <CRYP_GCMCCM_SetHeaderPhase>
 c03d092:	bb70      	cbnz	r0, c03d0f2 <CRYP_AESCCM_Process+0x114>
    hcryp->Phase = CRYP_PHASE_PROCESS;
 c03d094:	2302      	movs	r3, #2
    MODIFY_REG(hcryp->Instance->CR, AES_CR_GCMPH, CRYP_PHASE_PAYLOAD);
 c03d096:	6822      	ldr	r2, [r4, #0]
    hcryp->Phase = CRYP_PHASE_PROCESS;
 c03d098:	64e3      	str	r3, [r4, #76]	@ 0x4c
    MODIFY_REG(hcryp->Instance->CR, AES_CR_GCMPH, CRYP_PHASE_PAYLOAD);
 c03d09a:	6813      	ldr	r3, [r2, #0]
 c03d09c:	f423 43c0 	bic.w	r3, r3, #24576	@ 0x6000
 c03d0a0:	f443 4380 	orr.w	r3, r3, #16384	@ 0x4000
 c03d0a4:	6013      	str	r3, [r2, #0]
    MODIFY_REG(hcryp->Instance->CR, AES_CR_NPBLB, 0U);
 c03d0a6:	6813      	ldr	r3, [r2, #0]
 c03d0a8:	f423 0370 	bic.w	r3, r3, #15728640	@ 0xf00000
 c03d0ac:	6013      	str	r3, [r2, #0]
 c03d0ae:	e7a5      	b.n	c03cffc <CRYP_AESCCM_Process+0x1e>
      hcryp->Instance->CR &=  ~CRYP_KEYMODE_SHARED;
 c03d0b0:	682b      	ldr	r3, [r5, #0]
 c03d0b2:	f023 7300 	bic.w	r3, r3, #33554432	@ 0x2000000
 c03d0b6:	602b      	str	r3, [r5, #0]
 c03d0b8:	e7cd      	b.n	c03d056 <CRYP_AESCCM_Process+0x78>
    CRYP_AES_ProcessData(hcryp, Timeout);
 c03d0ba:	4631      	mov	r1, r6
 c03d0bc:	4620      	mov	r0, r4
 c03d0be:	f7ff ff26 	bl	c03cf0e <CRYP_AES_ProcessData>
    if (Timeout != HAL_MAX_DELAY)
 c03d0c2:	1c71      	adds	r1, r6, #1
 c03d0c4:	d0a4      	beq.n	c03d010 <CRYP_AESCCM_Process+0x32>
      if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
 c03d0c6:	f006 fe0f 	bl	c043ce8 <HAL_GetTick>
 c03d0ca:	1bc0      	subs	r0, r0, r7
 c03d0cc:	42b0      	cmp	r0, r6
 c03d0ce:	d801      	bhi.n	c03d0d4 <CRYP_AESCCM_Process+0xf6>
 c03d0d0:	2e00      	cmp	r6, #0
 c03d0d2:	d19d      	bne.n	c03d010 <CRYP_AESCCM_Process+0x32>
        __HAL_CRYP_DISABLE(hcryp);
 c03d0d4:	6822      	ldr	r2, [r4, #0]
 c03d0d6:	6813      	ldr	r3, [r2, #0]
 c03d0d8:	f023 0301 	bic.w	r3, r3, #1
 c03d0dc:	6013      	str	r3, [r2, #0]
        hcryp->ErrorCode |= HAL_CRYP_ERROR_TIMEOUT;
 c03d0de:	6de3      	ldr	r3, [r4, #92]	@ 0x5c
 c03d0e0:	f043 0310 	orr.w	r3, r3, #16
 c03d0e4:	65e3      	str	r3, [r4, #92]	@ 0x5c
        hcryp->State = HAL_CRYP_STATE_READY;
 c03d0e6:	2301      	movs	r3, #1
 c03d0e8:	f884 3059 	strb.w	r3, [r4, #89]	@ 0x59
        __HAL_UNLOCK(hcryp);
 c03d0ec:	2300      	movs	r3, #0
 c03d0ee:	f884 3058 	strb.w	r3, [r4, #88]	@ 0x58
      return HAL_ERROR;
 c03d0f2:	2001      	movs	r0, #1
 c03d0f4:	e79b      	b.n	c03d02e <CRYP_AESCCM_Process+0x50>
    if ((hcryp->Instance->CR & AES_CR_MODE) == CRYP_OPERATINGMODE_DECRYPT)
 c03d0f6:	6822      	ldr	r2, [r4, #0]
    npblb = ((((uint32_t)hcryp->Size / 16U) + 1U) * 16U) - ((uint32_t)hcryp->Size);
 c03d0f8:	092b      	lsrs	r3, r5, #4
    if ((hcryp->Instance->CR & AES_CR_MODE) == CRYP_OPERATINGMODE_DECRYPT)
 c03d0fa:	6811      	ldr	r1, [r2, #0]
    npblb = ((((uint32_t)hcryp->Size / 16U) + 1U) * 16U) - ((uint32_t)hcryp->Size);
 c03d0fc:	3301      	adds	r3, #1
    if ((hcryp->Instance->CR & AES_CR_MODE) == CRYP_OPERATINGMODE_DECRYPT)
 c03d0fe:	f001 0118 	and.w	r1, r1, #24
 c03d102:	2910      	cmp	r1, #16
      MODIFY_REG(hcryp->Instance->CR, AES_CR_NPBLB, npblb << 20);
 c03d104:	bf08      	it	eq
 c03d106:	6811      	ldreq	r1, [r2, #0]
    npblb = ((((uint32_t)hcryp->Size / 16U) + 1U) * 16U) - ((uint32_t)hcryp->Size);
 c03d108:	ea4f 1003 	mov.w	r0, r3, lsl #4
      MODIFY_REG(hcryp->Instance->CR, AES_CR_NPBLB, npblb << 20);
 c03d10c:	bf08      	it	eq
 c03d10e:	f421 0170 	biceq.w	r1, r1, #15728640	@ 0xf00000
    npblb = ((((uint32_t)hcryp->Size / 16U) + 1U) * 16U) - ((uint32_t)hcryp->Size);
 c03d112:	ebc5 1303 	rsb	r3, r5, r3, lsl #4
      MODIFY_REG(hcryp->Instance->CR, AES_CR_NPBLB, npblb << 20);
 c03d116:	bf04      	itt	eq
 c03d118:	ea41 5103 	orreq.w	r1, r1, r3, lsl #20
 c03d11c:	6011      	streq	r1, [r2, #0]
    for (loopcounter = 0U; loopcounter < lastwordsize; loopcounter ++)
 c03d11e:	2100      	movs	r1, #0
      lastwordsize = (16U - npblb) / 4U;
 c03d120:	3510      	adds	r5, #16
 c03d122:	1a2d      	subs	r5, r5, r0
 c03d124:	08ad      	lsrs	r5, r5, #2
    if ((npblb % 4U) == 0U)
 c03d126:	079b      	lsls	r3, r3, #30
      lastwordsize = ((16U - npblb) / 4U) + 1U;
 c03d128:	bf18      	it	ne
 c03d12a:	3501      	addne	r5, #1
    for (loopcounter = 0U; loopcounter < lastwordsize; loopcounter ++)
 c03d12c:	42a9      	cmp	r1, r5
 c03d12e:	d12c      	bne.n	c03d18a <CRYP_AESCCM_Process+0x1ac>
 c03d130:	462b      	mov	r3, r5
      hcryp->Instance->DINR  = 0U;
 c03d132:	2100      	movs	r1, #0
    while (loopcounter < 4U)
 c03d134:	2b03      	cmp	r3, #3
 c03d136:	d937      	bls.n	c03d1a8 <CRYP_AESCCM_Process+0x1ca>
    if (CRYP_WaitOnCCFlag(hcryp, Timeout) != HAL_OK)
 c03d138:	4631      	mov	r1, r6
 c03d13a:	4620      	mov	r0, r4
 c03d13c:	f7ff fcd1 	bl	c03cae2 <CRYP_WaitOnCCFlag>
 c03d140:	2800      	cmp	r0, #0
 c03d142:	d1d6      	bne.n	c03d0f2 <CRYP_AESCCM_Process+0x114>
    __HAL_CRYP_CLEAR_FLAG(hcryp, CRYP_CLEAR_CCF);
 c03d144:	6823      	ldr	r3, [r4, #0]
 c03d146:	f8d3 2308 	ldr.w	r2, [r3, #776]	@ 0x308
 c03d14a:	f042 0201 	orr.w	r2, r2, #1
 c03d14e:	f8c3 2308 	str.w	r2, [r3, #776]	@ 0x308
      temp[loopcounter] = hcryp->Instance->DOUTR;
 c03d152:	68da      	ldr	r2, [r3, #12]
 c03d154:	9200      	str	r2, [sp, #0]
 c03d156:	68da      	ldr	r2, [r3, #12]
 c03d158:	9201      	str	r2, [sp, #4]
 c03d15a:	68da      	ldr	r2, [r3, #12]
 c03d15c:	68db      	ldr	r3, [r3, #12]
 c03d15e:	9202      	str	r2, [sp, #8]
 c03d160:	466a      	mov	r2, sp
 c03d162:	9303      	str	r3, [sp, #12]
    for (loopcounter = 0U; loopcounter < lastwordsize; loopcounter++)
 c03d164:	42a8      	cmp	r0, r5
 c03d166:	f43f af61 	beq.w	c03d02c <CRYP_AESCCM_Process+0x4e>
      *(uint32_t *)(hcryp->pCrypOutBuffPtr + hcryp->CrypOutCount) = temp[loopcounter];
 c03d16a:	f8b4 3048 	ldrh.w	r3, [r4, #72]	@ 0x48
 c03d16e:	f852 6b04 	ldr.w	r6, [r2], #4
 c03d172:	6c21      	ldr	r1, [r4, #64]	@ 0x40
 c03d174:	b29b      	uxth	r3, r3
 c03d176:	f841 6023 	str.w	r6, [r1, r3, lsl #2]
      hcryp->CrypOutCount++;
 c03d17a:	f8b4 3048 	ldrh.w	r3, [r4, #72]	@ 0x48
    for (loopcounter = 0U; loopcounter < lastwordsize; loopcounter++)
 c03d17e:	3001      	adds	r0, #1
      hcryp->CrypOutCount++;
 c03d180:	3301      	adds	r3, #1
 c03d182:	b29b      	uxth	r3, r3
 c03d184:	f8a4 3048 	strh.w	r3, [r4, #72]	@ 0x48
    for (loopcounter = 0U; loopcounter < lastwordsize; loopcounter++)
 c03d188:	e7ec      	b.n	c03d164 <CRYP_AESCCM_Process+0x186>
      hcryp->Instance->DINR  = *(uint32_t *)(hcryp->pCrypInBuffPtr + hcryp->CrypInCount);
 c03d18a:	f8b4 3046 	ldrh.w	r3, [r4, #70]	@ 0x46
 c03d18e:	6be0      	ldr	r0, [r4, #60]	@ 0x3c
 c03d190:	b29b      	uxth	r3, r3
 c03d192:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
    for (loopcounter = 0U; loopcounter < lastwordsize; loopcounter ++)
 c03d196:	3101      	adds	r1, #1
      hcryp->Instance->DINR  = *(uint32_t *)(hcryp->pCrypInBuffPtr + hcryp->CrypInCount);
 c03d198:	6093      	str	r3, [r2, #8]
      hcryp->CrypInCount++;
 c03d19a:	f8b4 3046 	ldrh.w	r3, [r4, #70]	@ 0x46
 c03d19e:	3301      	adds	r3, #1
 c03d1a0:	b29b      	uxth	r3, r3
 c03d1a2:	f8a4 3046 	strh.w	r3, [r4, #70]	@ 0x46
    for (loopcounter = 0U; loopcounter < lastwordsize; loopcounter ++)
 c03d1a6:	e7c1      	b.n	c03d12c <CRYP_AESCCM_Process+0x14e>
      hcryp->Instance->DINR  = 0U;
 c03d1a8:	6091      	str	r1, [r2, #8]
      loopcounter++;
 c03d1aa:	3301      	adds	r3, #1
 c03d1ac:	e7c2      	b.n	c03d134 <CRYP_AESCCM_Process+0x156>

0c03d1ae <CRYP_AESGCM_Process>:
{
 c03d1ae:	b5f0      	push	{r4, r5, r6, r7, lr}
  if (hcryp->Init.KeyIVConfigSkip == CRYP_KEYIVCONFIG_ONCE)
 c03d1b0:	6ac3      	ldr	r3, [r0, #44]	@ 0x2c
{
 c03d1b2:	4604      	mov	r4, r0
  if (hcryp->Init.KeyIVConfigSkip == CRYP_KEYIVCONFIG_ONCE)
 c03d1b4:	2b01      	cmp	r3, #1
{
 c03d1b6:	460e      	mov	r6, r1
  uint32_t wordsize = ((uint32_t)hcryp->Size / 4U);
 c03d1b8:	f8b0 504a 	ldrh.w	r5, [r0, #74]	@ 0x4a
{
 c03d1bc:	b085      	sub	sp, #20
  if (hcryp->Init.KeyIVConfigSkip == CRYP_KEYIVCONFIG_ONCE)
 c03d1be:	d121      	bne.n	c03d204 <CRYP_AESGCM_Process+0x56>
    if (hcryp->KeyIVConfig == 1U)
 c03d1c0:	6e02      	ldr	r2, [r0, #96]	@ 0x60
 c03d1c2:	2a01      	cmp	r2, #1
 c03d1c4:	d11d      	bne.n	c03d202 <CRYP_AESGCM_Process+0x54>
      hcryp->SizesSum += hcryp->Size; /* Compute message total payload length */
 c03d1c6:	6e43      	ldr	r3, [r0, #100]	@ 0x64
 c03d1c8:	442b      	add	r3, r5
 c03d1ca:	6643      	str	r3, [r0, #100]	@ 0x64
  if ((hcryp->Size % 16U) != 0U)
 c03d1cc:	f8b4 304a 	ldrh.w	r3, [r4, #74]	@ 0x4a
  uint32_t wordsize = ((uint32_t)hcryp->Size / 4U);
 c03d1d0:	08ad      	lsrs	r5, r5, #2
  if ((hcryp->Size % 16U) != 0U)
 c03d1d2:	0718      	lsls	r0, r3, #28
    wordsize = ((wordsize / 4U) * 4U);
 c03d1d4:	bf18      	it	ne
 c03d1d6:	f025 0503 	bicne.w	r5, r5, #3
  tickstart = HAL_GetTick();
 c03d1da:	f006 fd85 	bl	c043ce8 <HAL_GetTick>
 c03d1de:	4607      	mov	r7, r0
    incount = hcryp->CrypInCount;
 c03d1e0:	f8b4 2046 	ldrh.w	r2, [r4, #70]	@ 0x46
    outcount = hcryp->CrypOutCount;
 c03d1e4:	f8b4 3048 	ldrh.w	r3, [r4, #72]	@ 0x48
    incount = hcryp->CrypInCount;
 c03d1e8:	b292      	uxth	r2, r2
  while ((incount < wordsize) && (outcount < wordsize))
 c03d1ea:	4295      	cmp	r5, r2
    outcount = hcryp->CrypOutCount;
 c03d1ec:	b29b      	uxth	r3, r3
  while ((incount < wordsize) && (outcount < wordsize))
 c03d1ee:	d901      	bls.n	c03d1f4 <CRYP_AESGCM_Process+0x46>
 c03d1f0:	429d      	cmp	r5, r3
 c03d1f2:	d843      	bhi.n	c03d27c <CRYP_AESGCM_Process+0xce>
  if ((hcryp->Size % 16U) != 0U)
 c03d1f4:	f8b4 504a 	ldrh.w	r5, [r4, #74]	@ 0x4a
 c03d1f8:	072a      	lsls	r2, r5, #28
 c03d1fa:	d15d      	bne.n	c03d2b8 <CRYP_AESGCM_Process+0x10a>
  return HAL_OK;
 c03d1fc:	2000      	movs	r0, #0
}
 c03d1fe:	b005      	add	sp, #20
 c03d200:	bdf0      	pop	{r4, r5, r6, r7, pc}
      hcryp->KeyIVConfig = 1U;
 c03d202:	6603      	str	r3, [r0, #96]	@ 0x60
    hcryp->CrypHeaderCount = 0U;
 c03d204:	2300      	movs	r3, #0
    CRYP_SET_PHASE(hcryp, CRYP_PHASE_INIT);
 c03d206:	6827      	ldr	r7, [r4, #0]
    hcryp->CrypHeaderCount = 0U;
 c03d208:	f8a4 3044 	strh.w	r3, [r4, #68]	@ 0x44
    CRYP_SET_PHASE(hcryp, CRYP_PHASE_INIT);
 c03d20c:	683b      	ldr	r3, [r7, #0]
    hcryp->SizesSum = hcryp->Size;
 c03d20e:	6665      	str	r5, [r4, #100]	@ 0x64
    CRYP_SET_PHASE(hcryp, CRYP_PHASE_INIT);
 c03d210:	f423 43c0 	bic.w	r3, r3, #24576	@ 0x6000
 c03d214:	603b      	str	r3, [r7, #0]
    if (hcryp->Init.KeyMode != CRYP_KEYMODE_SHARED)
 c03d216:	6b23      	ldr	r3, [r4, #48]	@ 0x30
 c03d218:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
 c03d21c:	d029      	beq.n	c03d272 <CRYP_AESGCM_Process+0xc4>
      CRYP_SetKey(hcryp, hcryp->Init.KeySize);
 c03d21e:	4620      	mov	r0, r4
 c03d220:	68a1      	ldr	r1, [r4, #8]
 c03d222:	f7ff fc31 	bl	c03ca88 <CRYP_SetKey>
    CRYP_SetIV(hcryp);
 c03d226:	4620      	mov	r0, r4
 c03d228:	f7ff fc4f 	bl	c03caca <CRYP_SetIV>
    __HAL_CRYP_ENABLE(hcryp);
 c03d22c:	683b      	ldr	r3, [r7, #0]
    if (CRYP_WaitOnCCFlag(hcryp, Timeout) != HAL_OK)
 c03d22e:	4631      	mov	r1, r6
    __HAL_CRYP_ENABLE(hcryp);
 c03d230:	f043 0301 	orr.w	r3, r3, #1
 c03d234:	603b      	str	r3, [r7, #0]
    if (CRYP_WaitOnCCFlag(hcryp, Timeout) != HAL_OK)
 c03d236:	f7ff fc54 	bl	c03cae2 <CRYP_WaitOnCCFlag>
 c03d23a:	2800      	cmp	r0, #0
 c03d23c:	d13a      	bne.n	c03d2b4 <CRYP_AESGCM_Process+0x106>
    __HAL_CRYP_CLEAR_FLAG(hcryp, CRYP_CLEAR_CCF);
 c03d23e:	6822      	ldr	r2, [r4, #0]
    if (CRYP_GCMCCM_SetHeaderPhase(hcryp,  Timeout) != HAL_OK)
 c03d240:	4631      	mov	r1, r6
    __HAL_CRYP_CLEAR_FLAG(hcryp, CRYP_CLEAR_CCF);
 c03d242:	f8d2 3308 	ldr.w	r3, [r2, #776]	@ 0x308
    if (CRYP_GCMCCM_SetHeaderPhase(hcryp,  Timeout) != HAL_OK)
 c03d246:	4620      	mov	r0, r4
    __HAL_CRYP_CLEAR_FLAG(hcryp, CRYP_CLEAR_CCF);
 c03d248:	f043 0301 	orr.w	r3, r3, #1
 c03d24c:	f8c2 3308 	str.w	r3, [r2, #776]	@ 0x308
    if (CRYP_GCMCCM_SetHeaderPhase(hcryp,  Timeout) != HAL_OK)
 c03d250:	f7ff fc6c 	bl	c03cb2c <CRYP_GCMCCM_SetHeaderPhase>
 c03d254:	bb70      	cbnz	r0, c03d2b4 <CRYP_AESGCM_Process+0x106>
    hcryp->Phase = CRYP_PHASE_PROCESS;
 c03d256:	2302      	movs	r3, #2
    CRYP_SET_PHASE(hcryp, CRYP_PHASE_PAYLOAD);
 c03d258:	6822      	ldr	r2, [r4, #0]
    hcryp->Phase = CRYP_PHASE_PROCESS;
 c03d25a:	64e3      	str	r3, [r4, #76]	@ 0x4c
    CRYP_SET_PHASE(hcryp, CRYP_PHASE_PAYLOAD);
 c03d25c:	6813      	ldr	r3, [r2, #0]
 c03d25e:	f423 43c0 	bic.w	r3, r3, #24576	@ 0x6000
 c03d262:	f443 4380 	orr.w	r3, r3, #16384	@ 0x4000
 c03d266:	6013      	str	r3, [r2, #0]
    MODIFY_REG(hcryp->Instance->CR, AES_CR_NPBLB, 0U);
 c03d268:	6813      	ldr	r3, [r2, #0]
 c03d26a:	f423 0370 	bic.w	r3, r3, #15728640	@ 0xf00000
 c03d26e:	6013      	str	r3, [r2, #0]
 c03d270:	e7ac      	b.n	c03d1cc <CRYP_AESGCM_Process+0x1e>
      hcryp->Instance->CR &=  ~CRYP_KEYMODE_SHARED;
 c03d272:	683b      	ldr	r3, [r7, #0]
 c03d274:	f023 7300 	bic.w	r3, r3, #33554432	@ 0x2000000
 c03d278:	603b      	str	r3, [r7, #0]
 c03d27a:	e7d4      	b.n	c03d226 <CRYP_AESGCM_Process+0x78>
    CRYP_AES_ProcessData(hcryp, Timeout);
 c03d27c:	4631      	mov	r1, r6
 c03d27e:	4620      	mov	r0, r4
 c03d280:	f7ff fe45 	bl	c03cf0e <CRYP_AES_ProcessData>
    if (Timeout != HAL_MAX_DELAY)
 c03d284:	1c71      	adds	r1, r6, #1
 c03d286:	d0ab      	beq.n	c03d1e0 <CRYP_AESGCM_Process+0x32>
      if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
 c03d288:	f006 fd2e 	bl	c043ce8 <HAL_GetTick>
 c03d28c:	1bc0      	subs	r0, r0, r7
 c03d28e:	42b0      	cmp	r0, r6
 c03d290:	d801      	bhi.n	c03d296 <CRYP_AESGCM_Process+0xe8>
 c03d292:	2e00      	cmp	r6, #0
 c03d294:	d1a4      	bne.n	c03d1e0 <CRYP_AESGCM_Process+0x32>
        __HAL_CRYP_DISABLE(hcryp);
 c03d296:	6822      	ldr	r2, [r4, #0]
 c03d298:	6813      	ldr	r3, [r2, #0]
 c03d29a:	f023 0301 	bic.w	r3, r3, #1
 c03d29e:	6013      	str	r3, [r2, #0]
        hcryp->ErrorCode |= HAL_CRYP_ERROR_TIMEOUT;
 c03d2a0:	6de3      	ldr	r3, [r4, #92]	@ 0x5c
 c03d2a2:	f043 0310 	orr.w	r3, r3, #16
 c03d2a6:	65e3      	str	r3, [r4, #92]	@ 0x5c
        hcryp->State = HAL_CRYP_STATE_READY;
 c03d2a8:	2301      	movs	r3, #1
 c03d2aa:	f884 3059 	strb.w	r3, [r4, #89]	@ 0x59
        __HAL_UNLOCK(hcryp);
 c03d2ae:	2300      	movs	r3, #0
 c03d2b0:	f884 3058 	strb.w	r3, [r4, #88]	@ 0x58
      return HAL_ERROR;
 c03d2b4:	2001      	movs	r0, #1
 c03d2b6:	e7a2      	b.n	c03d1fe <CRYP_AESGCM_Process+0x50>
    if ((hcryp->Instance->CR & AES_CR_MODE) == CRYP_OPERATINGMODE_ENCRYPT)
 c03d2b8:	6822      	ldr	r2, [r4, #0]
    npblb = ((((uint32_t)hcryp->Size / 16U) + 1U) * 16U) - ((uint32_t)hcryp->Size);
 c03d2ba:	092b      	lsrs	r3, r5, #4
    if ((hcryp->Instance->CR & AES_CR_MODE) == CRYP_OPERATINGMODE_ENCRYPT)
 c03d2bc:	6811      	ldr	r1, [r2, #0]
    npblb = ((((uint32_t)hcryp->Size / 16U) + 1U) * 16U) - ((uint32_t)hcryp->Size);
 c03d2be:	3301      	adds	r3, #1
    if ((hcryp->Instance->CR & AES_CR_MODE) == CRYP_OPERATINGMODE_ENCRYPT)
 c03d2c0:	f011 0f18 	tst.w	r1, #24
      MODIFY_REG(hcryp->Instance->CR, AES_CR_NPBLB, npblb << 20U);
 c03d2c4:	bf08      	it	eq
 c03d2c6:	6811      	ldreq	r1, [r2, #0]
    npblb = ((((uint32_t)hcryp->Size / 16U) + 1U) * 16U) - ((uint32_t)hcryp->Size);
 c03d2c8:	ea4f 1003 	mov.w	r0, r3, lsl #4
      MODIFY_REG(hcryp->Instance->CR, AES_CR_NPBLB, npblb << 20U);
 c03d2cc:	bf08      	it	eq
 c03d2ce:	f421 0170 	biceq.w	r1, r1, #15728640	@ 0xf00000
    npblb = ((((uint32_t)hcryp->Size / 16U) + 1U) * 16U) - ((uint32_t)hcryp->Size);
 c03d2d2:	ebc5 1303 	rsb	r3, r5, r3, lsl #4
      MODIFY_REG(hcryp->Instance->CR, AES_CR_NPBLB, npblb << 20U);
 c03d2d6:	bf04      	itt	eq
 c03d2d8:	ea41 5103 	orreq.w	r1, r1, r3, lsl #20
 c03d2dc:	6011      	streq	r1, [r2, #0]
    for (index = 0U; index < lastwordsize; index ++)
 c03d2de:	2100      	movs	r1, #0
      lastwordsize = (16U - npblb) / 4U;
 c03d2e0:	3510      	adds	r5, #16
 c03d2e2:	1a2d      	subs	r5, r5, r0
 c03d2e4:	08ad      	lsrs	r5, r5, #2
    if ((npblb % 4U) == 0U)
 c03d2e6:	079b      	lsls	r3, r3, #30
      lastwordsize = ((16U - npblb) / 4U) + 1U;
 c03d2e8:	bf18      	it	ne
 c03d2ea:	3501      	addne	r5, #1
    for (index = 0U; index < lastwordsize; index ++)
 c03d2ec:	42a9      	cmp	r1, r5
 c03d2ee:	d12f      	bne.n	c03d350 <CRYP_AESGCM_Process+0x1a2>
 c03d2f0:	462b      	mov	r3, r5
      hcryp->Instance->DINR  = 0U;
 c03d2f2:	2100      	movs	r1, #0
    while (index < 4U)
 c03d2f4:	2b03      	cmp	r3, #3
 c03d2f6:	d93a      	bls.n	c03d36e <CRYP_AESGCM_Process+0x1c0>
    if (CRYP_WaitOnCCFlag(hcryp, Timeout) != HAL_OK)
 c03d2f8:	4631      	mov	r1, r6
 c03d2fa:	4620      	mov	r0, r4
 c03d2fc:	f7ff fbf1 	bl	c03cae2 <CRYP_WaitOnCCFlag>
 c03d300:	b110      	cbz	r0, c03d308 <CRYP_AESGCM_Process+0x15a>
      HAL_CRYP_ErrorCallback(hcryp);
 c03d302:	4620      	mov	r0, r4
 c03d304:	f7ff fe02 	bl	c03cf0c <HAL_CRYP_ErrorCallback>
    __HAL_CRYP_CLEAR_FLAG(hcryp, CRYP_CLEAR_CCF);
 c03d308:	6823      	ldr	r3, [r4, #0]
 c03d30a:	4669      	mov	r1, sp
 c03d30c:	f8d3 2308 	ldr.w	r2, [r3, #776]	@ 0x308
 c03d310:	f042 0201 	orr.w	r2, r2, #1
 c03d314:	f8c3 2308 	str.w	r2, [r3, #776]	@ 0x308
      temp[index] = hcryp->Instance->DOUTR;
 c03d318:	68da      	ldr	r2, [r3, #12]
 c03d31a:	9200      	str	r2, [sp, #0]
 c03d31c:	68da      	ldr	r2, [r3, #12]
 c03d31e:	9201      	str	r2, [sp, #4]
 c03d320:	68da      	ldr	r2, [r3, #12]
 c03d322:	68db      	ldr	r3, [r3, #12]
 c03d324:	9202      	str	r2, [sp, #8]
    for (index = 0U; index < lastwordsize; index++)
 c03d326:	2200      	movs	r2, #0
      temp[index] = hcryp->Instance->DOUTR;
 c03d328:	9303      	str	r3, [sp, #12]
    for (index = 0U; index < lastwordsize; index++)
 c03d32a:	42aa      	cmp	r2, r5
 c03d32c:	f43f af66 	beq.w	c03d1fc <CRYP_AESGCM_Process+0x4e>
      *(uint32_t *)(hcryp->pCrypOutBuffPtr + (hcryp->CrypOutCount)) = temp[index];
 c03d330:	f8b4 3048 	ldrh.w	r3, [r4, #72]	@ 0x48
 c03d334:	f851 6b04 	ldr.w	r6, [r1], #4
 c03d338:	6c20      	ldr	r0, [r4, #64]	@ 0x40
 c03d33a:	b29b      	uxth	r3, r3
 c03d33c:	f840 6023 	str.w	r6, [r0, r3, lsl #2]
      hcryp->CrypOutCount++;
 c03d340:	f8b4 3048 	ldrh.w	r3, [r4, #72]	@ 0x48
    for (index = 0U; index < lastwordsize; index++)
 c03d344:	3201      	adds	r2, #1
      hcryp->CrypOutCount++;
 c03d346:	3301      	adds	r3, #1
 c03d348:	b29b      	uxth	r3, r3
 c03d34a:	f8a4 3048 	strh.w	r3, [r4, #72]	@ 0x48
    for (index = 0U; index < lastwordsize; index++)
 c03d34e:	e7ec      	b.n	c03d32a <CRYP_AESGCM_Process+0x17c>
      hcryp->Instance->DINR  = *(uint32_t *)(hcryp->pCrypInBuffPtr + hcryp->CrypInCount);
 c03d350:	f8b4 3046 	ldrh.w	r3, [r4, #70]	@ 0x46
 c03d354:	6be0      	ldr	r0, [r4, #60]	@ 0x3c
 c03d356:	b29b      	uxth	r3, r3
 c03d358:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
    for (index = 0U; index < lastwordsize; index ++)
 c03d35c:	3101      	adds	r1, #1
      hcryp->Instance->DINR  = *(uint32_t *)(hcryp->pCrypInBuffPtr + hcryp->CrypInCount);
 c03d35e:	6093      	str	r3, [r2, #8]
      hcryp->CrypInCount++;
 c03d360:	f8b4 3046 	ldrh.w	r3, [r4, #70]	@ 0x46
 c03d364:	3301      	adds	r3, #1
 c03d366:	b29b      	uxth	r3, r3
 c03d368:	f8a4 3046 	strh.w	r3, [r4, #70]	@ 0x46
    for (index = 0U; index < lastwordsize; index ++)
 c03d36c:	e7be      	b.n	c03d2ec <CRYP_AESGCM_Process+0x13e>
      hcryp->Instance->DINR  = 0U;
 c03d36e:	6091      	str	r1, [r2, #8]
      index++;
 c03d370:	3301      	adds	r3, #1
 c03d372:	e7bf      	b.n	c03d2f4 <CRYP_AESGCM_Process+0x146>

0c03d374 <HAL_CRYP_Encrypt>:
{
 c03d374:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 c03d376:	4604      	mov	r4, r0
  if (hcryp->State == HAL_CRYP_STATE_READY)
 c03d378:	f890 0059 	ldrb.w	r0, [r0, #89]	@ 0x59
{
 c03d37c:	9d06      	ldr	r5, [sp, #24]
  if (hcryp->State == HAL_CRYP_STATE_READY)
 c03d37e:	2801      	cmp	r0, #1
 c03d380:	b2c6      	uxtb	r6, r0
 c03d382:	f040 80bc 	bne.w	c03d4fe <HAL_CRYP_Encrypt+0x18a>
    hcryp->State = HAL_CRYP_STATE_BUSY;
 c03d386:	2002      	movs	r0, #2
    __HAL_LOCK(hcryp);
 c03d388:	f894 7058 	ldrb.w	r7, [r4, #88]	@ 0x58
    hcryp->State = HAL_CRYP_STATE_BUSY;
 c03d38c:	f884 0059 	strb.w	r0, [r4, #89]	@ 0x59
    __HAL_LOCK(hcryp);
 c03d390:	2f01      	cmp	r7, #1
 c03d392:	f000 80a7 	beq.w	c03d4e4 <HAL_CRYP_Encrypt+0x170>
    hcryp->CrypInCount = 0U;
 c03d396:	2000      	movs	r0, #0
    hcryp->pCrypOutBuffPtr = pOutput;
 c03d398:	e9c4 130f 	strd	r1, r3, [r4, #60]	@ 0x3c
    if (hcryp->Init.DataWidthUnit == CRYP_DATAWIDTHUNIT_WORD)
 c03d39c:	6a63      	ldr	r3, [r4, #36]	@ 0x24
    hcryp->CrypInCount = 0U;
 c03d39e:	f8a4 0046 	strh.w	r0, [r4, #70]	@ 0x46
    __HAL_LOCK(hcryp);
 c03d3a2:	f884 6058 	strb.w	r6, [r4, #88]	@ 0x58
    hcryp->CrypOutCount = 0U;
 c03d3a6:	f8a4 0048 	strh.w	r0, [r4, #72]	@ 0x48
    if (hcryp->Init.DataWidthUnit == CRYP_DATAWIDTHUNIT_WORD)
 c03d3aa:	b90b      	cbnz	r3, c03d3b0 <HAL_CRYP_Encrypt+0x3c>
      hcryp->Size = Size * 4U;
 c03d3ac:	0092      	lsls	r2, r2, #2
 c03d3ae:	b292      	uxth	r2, r2
    if (hcryp->Instance == AES)
 c03d3b0:	6823      	ldr	r3, [r4, #0]
 c03d3b2:	f8a4 204a 	strh.w	r2, [r4, #74]	@ 0x4a
 c03d3b6:	4a54      	ldr	r2, [pc, #336]	@ (c03d508 <HAL_CRYP_Encrypt+0x194>)
 c03d3b8:	4293      	cmp	r3, r2
      MODIFY_REG(hcryp->Instance->CR, AES_CR_MODE, CRYP_OPERATINGMODE_ENCRYPT);
 c03d3ba:	681a      	ldr	r2, [r3, #0]
      MODIFY_REG(hcryp->Instance->CR, AES_CR_MODE | AES_CR_KMOD, CRYP_OPERATINGMODE_ENCRYPT | CRYP_KEYMODE_NORMAL);
 c03d3bc:	bf18      	it	ne
 c03d3be:	f022 7240 	bicne.w	r2, r2, #50331648	@ 0x3000000
 c03d3c2:	f022 0218 	bic.w	r2, r2, #24
 c03d3c6:	601a      	str	r2, [r3, #0]
    algo = hcryp->Instance->CR & AES_CR_CHMOD;
 c03d3c8:	6818      	ldr	r0, [r3, #0]
 c03d3ca:	4a50      	ldr	r2, [pc, #320]	@ (c03d50c <HAL_CRYP_Encrypt+0x198>)
 c03d3cc:	4002      	ands	r2, r0
    switch (algo)
 c03d3ce:	2a60      	cmp	r2, #96	@ 0x60
 c03d3d0:	f000 808e 	beq.w	c03d4f0 <HAL_CRYP_Encrypt+0x17c>
 c03d3d4:	d809      	bhi.n	c03d3ea <HAL_CRYP_Encrypt+0x76>
 c03d3d6:	494e      	ldr	r1, [pc, #312]	@ (c03d510 <HAL_CRYP_Encrypt+0x19c>)
 c03d3d8:	4001      	ands	r1, r0
 c03d3da:	b171      	cbz	r1, c03d3fa <HAL_CRYP_Encrypt+0x86>
 c03d3dc:	2a40      	cmp	r2, #64	@ 0x40
 c03d3de:	d00c      	beq.n	c03d3fa <HAL_CRYP_Encrypt+0x86>
        hcryp->ErrorCode |= HAL_CRYP_ERROR_NOT_SUPPORTED;
 c03d3e0:	6de3      	ldr	r3, [r4, #92]	@ 0x5c
 c03d3e2:	f043 0320 	orr.w	r3, r3, #32
 c03d3e6:	65e3      	str	r3, [r4, #92]	@ 0x5c
    if (status == HAL_OK)
 c03d3e8:	e07b      	b.n	c03d4e2 <HAL_CRYP_Encrypt+0x16e>
    switch (algo)
 c03d3ea:	f5b2 3f80 	cmp.w	r2, #65536	@ 0x10000
 c03d3ee:	d1f7      	bne.n	c03d3e0 <HAL_CRYP_Encrypt+0x6c>
        status = CRYP_AESCCM_Process(hcryp, Timeout);
 c03d3f0:	4629      	mov	r1, r5
 c03d3f2:	4620      	mov	r0, r4
 c03d3f4:	f7ff fdf3 	bl	c03cfde <CRYP_AESCCM_Process>
        break;
 c03d3f8:	e07e      	b.n	c03d4f8 <HAL_CRYP_Encrypt+0x184>
  if (hcryp->Init.KeyIVConfigSkip == CRYP_KEYIVCONFIG_ONCE)
 c03d3fa:	6ae2      	ldr	r2, [r4, #44]	@ 0x2c
 c03d3fc:	2a01      	cmp	r2, #1
 c03d3fe:	d13b      	bne.n	c03d478 <HAL_CRYP_Encrypt+0x104>
    if (hcryp->KeyIVConfig == 1U)
 c03d400:	6e21      	ldr	r1, [r4, #96]	@ 0x60
 c03d402:	2901      	cmp	r1, #1
 c03d404:	d013      	beq.n	c03d42e <HAL_CRYP_Encrypt+0xba>
      hcryp->KeyIVConfig = 1U;
 c03d406:	6622      	str	r2, [r4, #96]	@ 0x60
    if (hcryp->Instance == AES)
 c03d408:	4a3f      	ldr	r2, [pc, #252]	@ (c03d508 <HAL_CRYP_Encrypt+0x194>)
 c03d40a:	4293      	cmp	r3, r2
 c03d40c:	d142      	bne.n	c03d494 <HAL_CRYP_Encrypt+0x120>
      if (hcryp->Init.KeyMode != CRYP_KEYMODE_SHARED)
 c03d40e:	6b22      	ldr	r2, [r4, #48]	@ 0x30
 c03d410:	f1b2 7f00 	cmp.w	r2, #33554432	@ 0x2000000
 c03d414:	d039      	beq.n	c03d48a <HAL_CRYP_Encrypt+0x116>
        CRYP_SetKey(hcryp, hcryp->Init.KeySize);
 c03d416:	4620      	mov	r0, r4
 c03d418:	68a1      	ldr	r1, [r4, #8]
 c03d41a:	f7ff fb35 	bl	c03ca88 <CRYP_SetKey>
    if (hcryp->Init.Algorithm != CRYP_AES_ECB)
 c03d41e:	6963      	ldr	r3, [r4, #20]
 c03d420:	b113      	cbz	r3, c03d428 <HAL_CRYP_Encrypt+0xb4>
      CRYP_SetIV(hcryp);
 c03d422:	4620      	mov	r0, r4
 c03d424:	f7ff fb51 	bl	c03caca <CRYP_SetIV>
  if (hcryp->Init.KeyIVConfigSkip == CRYP_KEYNOCONFIG)
 c03d428:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
 c03d42a:	2b02      	cmp	r3, #2
 c03d42c:	d026      	beq.n	c03d47c <HAL_CRYP_Encrypt+0x108>
  hcryp->Phase = CRYP_PHASE_PROCESS;
 c03d42e:	2302      	movs	r3, #2
  __HAL_CRYP_ENABLE(hcryp);
 c03d430:	6822      	ldr	r2, [r4, #0]
  hcryp->Phase = CRYP_PHASE_PROCESS;
 c03d432:	64e3      	str	r3, [r4, #76]	@ 0x4c
  __HAL_CRYP_ENABLE(hcryp);
 c03d434:	6813      	ldr	r3, [r2, #0]
 c03d436:	f043 0301 	orr.w	r3, r3, #1
 c03d43a:	6013      	str	r3, [r2, #0]
    incount = hcryp->CrypInCount;
 c03d43c:	f8b4 2046 	ldrh.w	r2, [r4, #70]	@ 0x46
  while ((incount < (hcryp->Size / 4U)) && (outcount < (hcryp->Size / 4U)))
 c03d440:	f8b4 104a 	ldrh.w	r1, [r4, #74]	@ 0x4a
    outcount = hcryp->CrypOutCount;
 c03d444:	f8b4 3048 	ldrh.w	r3, [r4, #72]	@ 0x48
    incount = hcryp->CrypInCount;
 c03d448:	b292      	uxth	r2, r2
  while ((incount < (hcryp->Size / 4U)) && (outcount < (hcryp->Size / 4U)))
 c03d44a:	ebb2 0f91 	cmp.w	r2, r1, lsr #2
    outcount = hcryp->CrypOutCount;
 c03d44e:	b29b      	uxth	r3, r3
  while ((incount < (hcryp->Size / 4U)) && (outcount < (hcryp->Size / 4U)))
 c03d450:	ea4f 0091 	mov.w	r0, r1, lsr #2
 c03d454:	d201      	bcs.n	c03d45a <HAL_CRYP_Encrypt+0xe6>
 c03d456:	4298      	cmp	r0, r3
 c03d458:	d845      	bhi.n	c03d4e6 <HAL_CRYP_Encrypt+0x172>
  __HAL_CRYP_DISABLE(hcryp);
 c03d45a:	6822      	ldr	r2, [r4, #0]
 c03d45c:	6813      	ldr	r3, [r2, #0]
 c03d45e:	f023 0301 	bic.w	r3, r3, #1
 c03d462:	6013      	str	r3, [r2, #0]
  hcryp->State = HAL_CRYP_STATE_READY;
 c03d464:	2301      	movs	r3, #1
 c03d466:	f884 3059 	strb.w	r3, [r4, #89]	@ 0x59
      hcryp->State = HAL_CRYP_STATE_READY;
 c03d46a:	2301      	movs	r3, #1
      __HAL_UNLOCK(hcryp);
 c03d46c:	2000      	movs	r0, #0
      hcryp->State = HAL_CRYP_STATE_READY;
 c03d46e:	f884 3059 	strb.w	r3, [r4, #89]	@ 0x59
      __HAL_UNLOCK(hcryp);
 c03d472:	f884 0058 	strb.w	r0, [r4, #88]	@ 0x58
 c03d476:	e035      	b.n	c03d4e4 <HAL_CRYP_Encrypt+0x170>
  if ((dokeyivconfig == 1U) && (hcryp->Init.KeyIVConfigSkip != CRYP_KEYNOCONFIG))
 c03d478:	2a02      	cmp	r2, #2
 c03d47a:	d1c5      	bne.n	c03d408 <HAL_CRYP_Encrypt+0x94>
    if (hcryp->Init.Algorithm == CRYP_AES_CBC)
 c03d47c:	6963      	ldr	r3, [r4, #20]
 c03d47e:	2b20      	cmp	r3, #32
 c03d480:	d1d5      	bne.n	c03d42e <HAL_CRYP_Encrypt+0xba>
      CRYP_SetIV(hcryp);
 c03d482:	4620      	mov	r0, r4
 c03d484:	f7ff fb21 	bl	c03caca <CRYP_SetIV>
 c03d488:	e7d1      	b.n	c03d42e <HAL_CRYP_Encrypt+0xba>
        hcryp->Instance->CR &=  ~CRYP_KEYMODE_SHARED;
 c03d48a:	681a      	ldr	r2, [r3, #0]
 c03d48c:	f022 7200 	bic.w	r2, r2, #33554432	@ 0x2000000
 c03d490:	601a      	str	r2, [r3, #0]
 c03d492:	e7c4      	b.n	c03d41e <HAL_CRYP_Encrypt+0xaa>
      if ((hcryp->Init.KeySelect == CRYP_KEYSEL_NORMAL) && (hcryp->Init.KeyMode == CRYP_KEYMODE_NORMAL))
 c03d494:	6b63      	ldr	r3, [r4, #52]	@ 0x34
 c03d496:	b92b      	cbnz	r3, c03d4a4 <HAL_CRYP_Encrypt+0x130>
 c03d498:	6b23      	ldr	r3, [r4, #48]	@ 0x30
 c03d49a:	b91b      	cbnz	r3, c03d4a4 <HAL_CRYP_Encrypt+0x130>
        CRYP_SetKey(hcryp, hcryp->Init.KeySize);
 c03d49c:	4620      	mov	r0, r4
 c03d49e:	68a1      	ldr	r1, [r4, #8]
 c03d4a0:	f7ff faf2 	bl	c03ca88 <CRYP_SetKey>
      tickstart = HAL_GetTick();
 c03d4a4:	f006 fc20 	bl	c043ce8 <HAL_GetTick>
 c03d4a8:	4606      	mov	r6, r0
      while (HAL_IS_BIT_CLR(hcryp->Instance->SR, CRYP_FLAG_KEYVALID))
 c03d4aa:	6822      	ldr	r2, [r4, #0]
 c03d4ac:	6853      	ldr	r3, [r2, #4]
 c03d4ae:	061b      	lsls	r3, r3, #24
 c03d4b0:	d4b5      	bmi.n	c03d41e <HAL_CRYP_Encrypt+0xaa>
        if (Timeout != HAL_MAX_DELAY)
 c03d4b2:	1c69      	adds	r1, r5, #1
 c03d4b4:	d0fa      	beq.n	c03d4ac <HAL_CRYP_Encrypt+0x138>
          if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
 c03d4b6:	f006 fc17 	bl	c043ce8 <HAL_GetTick>
 c03d4ba:	1b80      	subs	r0, r0, r6
 c03d4bc:	4285      	cmp	r5, r0
 c03d4be:	d301      	bcc.n	c03d4c4 <HAL_CRYP_Encrypt+0x150>
 c03d4c0:	2d00      	cmp	r5, #0
 c03d4c2:	d1f2      	bne.n	c03d4aa <HAL_CRYP_Encrypt+0x136>
            __HAL_CRYP_DISABLE(hcryp);
 c03d4c4:	6822      	ldr	r2, [r4, #0]
 c03d4c6:	6813      	ldr	r3, [r2, #0]
 c03d4c8:	f023 0301 	bic.w	r3, r3, #1
 c03d4cc:	6013      	str	r3, [r2, #0]
            hcryp->ErrorCode |= HAL_CRYP_ERROR_TIMEOUT;
 c03d4ce:	6de3      	ldr	r3, [r4, #92]	@ 0x5c
 c03d4d0:	f043 0310 	orr.w	r3, r3, #16
 c03d4d4:	65e3      	str	r3, [r4, #92]	@ 0x5c
            hcryp->State = HAL_CRYP_STATE_READY;
 c03d4d6:	2301      	movs	r3, #1
 c03d4d8:	f884 3059 	strb.w	r3, [r4, #89]	@ 0x59
            __HAL_UNLOCK(hcryp);
 c03d4dc:	2300      	movs	r3, #0
 c03d4de:	f884 3058 	strb.w	r3, [r4, #88]	@ 0x58
    status = HAL_ERROR;
 c03d4e2:	2001      	movs	r0, #1
}
 c03d4e4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    CRYP_AES_ProcessData(hcryp, Timeout);
 c03d4e6:	4629      	mov	r1, r5
 c03d4e8:	4620      	mov	r0, r4
 c03d4ea:	f7ff fd10 	bl	c03cf0e <CRYP_AES_ProcessData>
 c03d4ee:	e7a5      	b.n	c03d43c <HAL_CRYP_Encrypt+0xc8>
        status = CRYP_AESGCM_Process(hcryp, Timeout);
 c03d4f0:	4629      	mov	r1, r5
 c03d4f2:	4620      	mov	r0, r4
 c03d4f4:	f7ff fe5b 	bl	c03d1ae <CRYP_AESGCM_Process>
    if (status == HAL_OK)
 c03d4f8:	2800      	cmp	r0, #0
 c03d4fa:	d1f3      	bne.n	c03d4e4 <HAL_CRYP_Encrypt+0x170>
 c03d4fc:	e7b5      	b.n	c03d46a <HAL_CRYP_Encrypt+0xf6>
    hcryp->ErrorCode |= HAL_CRYP_ERROR_BUSY;
 c03d4fe:	6de3      	ldr	r3, [r4, #92]	@ 0x5c
 c03d500:	f043 0308 	orr.w	r3, r3, #8
 c03d504:	e76f      	b.n	c03d3e6 <HAL_CRYP_Encrypt+0x72>
 c03d506:	bf00      	nop
 c03d508:	520c0000 	.word	0x520c0000
 c03d50c:	00010060 	.word	0x00010060
 c03d510:	00010040 	.word	0x00010040

0c03d514 <HAL_CRYP_Decrypt>:
{
 c03d514:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 c03d516:	4604      	mov	r4, r0
  if (hcryp->State == HAL_CRYP_STATE_READY)
 c03d518:	f890 0059 	ldrb.w	r0, [r0, #89]	@ 0x59
{
 c03d51c:	9e06      	ldr	r6, [sp, #24]
  if (hcryp->State == HAL_CRYP_STATE_READY)
 c03d51e:	2801      	cmp	r0, #1
 c03d520:	b2c5      	uxtb	r5, r0
 c03d522:	f040 80d6 	bne.w	c03d6d2 <HAL_CRYP_Decrypt+0x1be>
    hcryp->State = HAL_CRYP_STATE_BUSY;
 c03d526:	2002      	movs	r0, #2
    __HAL_LOCK(hcryp);
 c03d528:	f894 7058 	ldrb.w	r7, [r4, #88]	@ 0x58
    hcryp->State = HAL_CRYP_STATE_BUSY;
 c03d52c:	f884 0059 	strb.w	r0, [r4, #89]	@ 0x59
    __HAL_LOCK(hcryp);
 c03d530:	2f01      	cmp	r7, #1
 c03d532:	d026      	beq.n	c03d582 <HAL_CRYP_Decrypt+0x6e>
    hcryp->CrypInCount = 0U;
 c03d534:	2000      	movs	r0, #0
    hcryp->pCrypOutBuffPtr = pOutput;
 c03d536:	e9c4 130f 	strd	r1, r3, [r4, #60]	@ 0x3c
    if (hcryp->Init.DataWidthUnit == CRYP_DATAWIDTHUNIT_WORD)
 c03d53a:	6a63      	ldr	r3, [r4, #36]	@ 0x24
    hcryp->CrypInCount = 0U;
 c03d53c:	f8a4 0046 	strh.w	r0, [r4, #70]	@ 0x46
    __HAL_LOCK(hcryp);
 c03d540:	f884 5058 	strb.w	r5, [r4, #88]	@ 0x58
    hcryp->CrypOutCount = 0U;
 c03d544:	f8a4 0048 	strh.w	r0, [r4, #72]	@ 0x48
    if (hcryp->Init.DataWidthUnit == CRYP_DATAWIDTHUNIT_WORD)
 c03d548:	b90b      	cbnz	r3, c03d54e <HAL_CRYP_Decrypt+0x3a>
      hcryp->Size = Size * 4U;
 c03d54a:	0092      	lsls	r2, r2, #2
 c03d54c:	b292      	uxth	r2, r2
    MODIFY_REG(hcryp->Instance->CR, AES_CR_MODE, CRYP_OPERATINGMODE_DECRYPT);
 c03d54e:	6825      	ldr	r5, [r4, #0]
 c03d550:	f8a4 204a 	strh.w	r2, [r4, #74]	@ 0x4a
 c03d554:	682b      	ldr	r3, [r5, #0]
 c03d556:	f023 0318 	bic.w	r3, r3, #24
 c03d55a:	f043 0310 	orr.w	r3, r3, #16
 c03d55e:	602b      	str	r3, [r5, #0]
    algo = hcryp->Instance->CR & AES_CR_CHMOD;
 c03d560:	6829      	ldr	r1, [r5, #0]
 c03d562:	4b5e      	ldr	r3, [pc, #376]	@ (c03d6dc <HAL_CRYP_Decrypt+0x1c8>)
 c03d564:	400b      	ands	r3, r1
    switch (algo)
 c03d566:	2b60      	cmp	r3, #96	@ 0x60
 c03d568:	f000 80ab 	beq.w	c03d6c2 <HAL_CRYP_Decrypt+0x1ae>
 c03d56c:	d80a      	bhi.n	c03d584 <HAL_CRYP_Decrypt+0x70>
 c03d56e:	4a5c      	ldr	r2, [pc, #368]	@ (c03d6e0 <HAL_CRYP_Decrypt+0x1cc>)
 c03d570:	400a      	ands	r2, r1
 c03d572:	b17a      	cbz	r2, c03d594 <HAL_CRYP_Decrypt+0x80>
 c03d574:	2b40      	cmp	r3, #64	@ 0x40
 c03d576:	d00d      	beq.n	c03d594 <HAL_CRYP_Decrypt+0x80>
        hcryp->ErrorCode |= HAL_CRYP_ERROR_NOT_SUPPORTED;
 c03d578:	6de3      	ldr	r3, [r4, #92]	@ 0x5c
 c03d57a:	f043 0320 	orr.w	r3, r3, #32
 c03d57e:	65e3      	str	r3, [r4, #92]	@ 0x5c
    status = HAL_ERROR;
 c03d580:	2001      	movs	r0, #1
}
 c03d582:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    switch (algo)
 c03d584:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 c03d588:	d1f6      	bne.n	c03d578 <HAL_CRYP_Decrypt+0x64>
        status = CRYP_AESCCM_Process(hcryp, Timeout);
 c03d58a:	4631      	mov	r1, r6
 c03d58c:	4620      	mov	r0, r4
 c03d58e:	f7ff fd26 	bl	c03cfde <CRYP_AESCCM_Process>
        break;
 c03d592:	e09a      	b.n	c03d6ca <HAL_CRYP_Decrypt+0x1b6>
  if (hcryp->Init.KeyIVConfigSkip == CRYP_KEYIVCONFIG_ONCE)
 c03d594:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
 c03d596:	2b01      	cmp	r3, #1
 c03d598:	d103      	bne.n	c03d5a2 <HAL_CRYP_Decrypt+0x8e>
    if (hcryp->KeyIVConfig == 1U)
 c03d59a:	6e22      	ldr	r2, [r4, #96]	@ 0x60
 c03d59c:	2a01      	cmp	r2, #1
 c03d59e:	d035      	beq.n	c03d60c <HAL_CRYP_Decrypt+0xf8>
      hcryp->KeyIVConfig = 1U;
 c03d5a0:	6623      	str	r3, [r4, #96]	@ 0x60
    if (hcryp->Instance == AES)
 c03d5a2:	4a50      	ldr	r2, [pc, #320]	@ (c03d6e4 <HAL_CRYP_Decrypt+0x1d0>)
 c03d5a4:	4295      	cmp	r5, r2
 c03d5a6:	d16e      	bne.n	c03d686 <HAL_CRYP_Decrypt+0x172>
      if (hcryp->Init.Algorithm != CRYP_AES_CTR)   /*ECB or CBC*/
 c03d5a8:	6962      	ldr	r2, [r4, #20]
 c03d5aa:	2a40      	cmp	r2, #64	@ 0x40
 c03d5ac:	d058      	beq.n	c03d660 <HAL_CRYP_Decrypt+0x14c>
        MODIFY_REG(hcryp->Instance->CR, AES_CR_KMOD, CRYP_KEYMODE_NORMAL);
 c03d5ae:	682a      	ldr	r2, [r5, #0]
        if (hcryp->Init.KeyIVConfigSkip != CRYP_KEYNOCONFIG)
 c03d5b0:	2b02      	cmp	r3, #2
        MODIFY_REG(hcryp->Instance->CR, AES_CR_KMOD, CRYP_KEYMODE_NORMAL);
 c03d5b2:	f022 7240 	bic.w	r2, r2, #50331648	@ 0x3000000
 c03d5b6:	602a      	str	r2, [r5, #0]
        MODIFY_REG(hcryp->Instance->CR, AES_CR_MODE, CRYP_OPERATINGMODE_KEYDERIVATION);
 c03d5b8:	682a      	ldr	r2, [r5, #0]
 c03d5ba:	f022 0218 	bic.w	r2, r2, #24
 c03d5be:	f042 0208 	orr.w	r2, r2, #8
 c03d5c2:	602a      	str	r2, [r5, #0]
        if (hcryp->Init.KeyIVConfigSkip != CRYP_KEYNOCONFIG)
 c03d5c4:	d007      	beq.n	c03d5d6 <HAL_CRYP_Decrypt+0xc2>
          if (hcryp->Init.KeyMode != CRYP_KEYMODE_SHARED)
 c03d5c6:	6b23      	ldr	r3, [r4, #48]	@ 0x30
 c03d5c8:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
 c03d5cc:	d043      	beq.n	c03d656 <HAL_CRYP_Decrypt+0x142>
            CRYP_SetKey(hcryp, hcryp->Init.KeySize);
 c03d5ce:	4620      	mov	r0, r4
 c03d5d0:	68a1      	ldr	r1, [r4, #8]
 c03d5d2:	f7ff fa59 	bl	c03ca88 <CRYP_SetKey>
        __HAL_CRYP_ENABLE(hcryp);
 c03d5d6:	4a43      	ldr	r2, [pc, #268]	@ (c03d6e4 <HAL_CRYP_Decrypt+0x1d0>)
 c03d5d8:	6813      	ldr	r3, [r2, #0]
 c03d5da:	f043 0301 	orr.w	r3, r3, #1
 c03d5de:	6013      	str	r3, [r2, #0]
      if (CRYP_WaitOnCCFlag(hcryp, Timeout) != HAL_OK)
 c03d5e0:	4631      	mov	r1, r6
 c03d5e2:	4620      	mov	r0, r4
 c03d5e4:	f7ff fa7d 	bl	c03cae2 <CRYP_WaitOnCCFlag>
 c03d5e8:	2800      	cmp	r0, #0
 c03d5ea:	d1c9      	bne.n	c03d580 <HAL_CRYP_Decrypt+0x6c>
      __HAL_CRYP_CLEAR_FLAG(hcryp, CRYP_CLEAR_CCF);
 c03d5ec:	6822      	ldr	r2, [r4, #0]
 c03d5ee:	f8d2 3308 	ldr.w	r3, [r2, #776]	@ 0x308
 c03d5f2:	f043 0301 	orr.w	r3, r3, #1
 c03d5f6:	f8c2 3308 	str.w	r3, [r2, #776]	@ 0x308
      MODIFY_REG(hcryp->Instance->CR, AES_CR_MODE, CRYP_OPERATINGMODE_DECRYPT);
 c03d5fa:	6813      	ldr	r3, [r2, #0]
 c03d5fc:	f023 0318 	bic.w	r3, r3, #24
 c03d600:	f043 0310 	orr.w	r3, r3, #16
 c03d604:	6013      	str	r3, [r2, #0]
    if (hcryp->Init.Algorithm != CRYP_AES_ECB)
 c03d606:	6963      	ldr	r3, [r4, #20]
 c03d608:	2b00      	cmp	r3, #0
 c03d60a:	d133      	bne.n	c03d674 <HAL_CRYP_Decrypt+0x160>
  hcryp->Phase = CRYP_PHASE_PROCESS;
 c03d60c:	2302      	movs	r3, #2
  __HAL_CRYP_ENABLE(hcryp);
 c03d60e:	6822      	ldr	r2, [r4, #0]
  hcryp->Phase = CRYP_PHASE_PROCESS;
 c03d610:	64e3      	str	r3, [r4, #76]	@ 0x4c
  __HAL_CRYP_ENABLE(hcryp);
 c03d612:	6813      	ldr	r3, [r2, #0]
 c03d614:	f043 0301 	orr.w	r3, r3, #1
 c03d618:	6013      	str	r3, [r2, #0]
    incount = hcryp->CrypInCount;
 c03d61a:	f8b4 2046 	ldrh.w	r2, [r4, #70]	@ 0x46
  while ((incount < (hcryp->Size / 4U)) && (outcount < (hcryp->Size / 4U)))
 c03d61e:	f8b4 104a 	ldrh.w	r1, [r4, #74]	@ 0x4a
    outcount = hcryp->CrypOutCount;
 c03d622:	f8b4 3048 	ldrh.w	r3, [r4, #72]	@ 0x48
    incount = hcryp->CrypInCount;
 c03d626:	b292      	uxth	r2, r2
  while ((incount < (hcryp->Size / 4U)) && (outcount < (hcryp->Size / 4U)))
 c03d628:	ebb2 0f91 	cmp.w	r2, r1, lsr #2
    outcount = hcryp->CrypOutCount;
 c03d62c:	b29b      	uxth	r3, r3
  while ((incount < (hcryp->Size / 4U)) && (outcount < (hcryp->Size / 4U)))
 c03d62e:	ea4f 0091 	mov.w	r0, r1, lsr #2
 c03d632:	d201      	bcs.n	c03d638 <HAL_CRYP_Decrypt+0x124>
 c03d634:	4298      	cmp	r0, r3
 c03d636:	d83f      	bhi.n	c03d6b8 <HAL_CRYP_Decrypt+0x1a4>
  __HAL_CRYP_DISABLE(hcryp);
 c03d638:	6822      	ldr	r2, [r4, #0]
 c03d63a:	6813      	ldr	r3, [r2, #0]
 c03d63c:	f023 0301 	bic.w	r3, r3, #1
 c03d640:	6013      	str	r3, [r2, #0]
  hcryp->State = HAL_CRYP_STATE_READY;
 c03d642:	2301      	movs	r3, #1
 c03d644:	f884 3059 	strb.w	r3, [r4, #89]	@ 0x59
      hcryp->State = HAL_CRYP_STATE_READY;
 c03d648:	2301      	movs	r3, #1
      __HAL_UNLOCK(hcryp);
 c03d64a:	2000      	movs	r0, #0
      hcryp->State = HAL_CRYP_STATE_READY;
 c03d64c:	f884 3059 	strb.w	r3, [r4, #89]	@ 0x59
      __HAL_UNLOCK(hcryp);
 c03d650:	f884 0058 	strb.w	r0, [r4, #88]	@ 0x58
 c03d654:	e795      	b.n	c03d582 <HAL_CRYP_Decrypt+0x6e>
            hcryp->Instance->CR &=  ~CRYP_KEYMODE_SHARED;
 c03d656:	682b      	ldr	r3, [r5, #0]
 c03d658:	f023 7300 	bic.w	r3, r3, #33554432	@ 0x2000000
 c03d65c:	602b      	str	r3, [r5, #0]
 c03d65e:	e7ba      	b.n	c03d5d6 <HAL_CRYP_Decrypt+0xc2>
        if (hcryp->Init.KeyIVConfigSkip != CRYP_KEYNOCONFIG)
 c03d660:	2b02      	cmp	r3, #2
 c03d662:	d007      	beq.n	c03d674 <HAL_CRYP_Decrypt+0x160>
          if (hcryp->Init.KeyMode != CRYP_KEYMODE_SHARED)
 c03d664:	6b23      	ldr	r3, [r4, #48]	@ 0x30
 c03d666:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
 c03d66a:	d007      	beq.n	c03d67c <HAL_CRYP_Decrypt+0x168>
            CRYP_SetKey(hcryp, hcryp->Init.KeySize);
 c03d66c:	4620      	mov	r0, r4
 c03d66e:	68a1      	ldr	r1, [r4, #8]
 c03d670:	f7ff fa0a 	bl	c03ca88 <CRYP_SetKey>
      CRYP_SetIV(hcryp);
 c03d674:	4620      	mov	r0, r4
 c03d676:	f7ff fa28 	bl	c03caca <CRYP_SetIV>
 c03d67a:	e7c7      	b.n	c03d60c <HAL_CRYP_Decrypt+0xf8>
            hcryp->Instance->CR &=  ~CRYP_KEYMODE_SHARED;
 c03d67c:	682b      	ldr	r3, [r5, #0]
 c03d67e:	f023 7300 	bic.w	r3, r3, #33554432	@ 0x2000000
 c03d682:	602b      	str	r3, [r5, #0]
 c03d684:	e7f6      	b.n	c03d674 <HAL_CRYP_Decrypt+0x160>
      MODIFY_REG(hcryp->Instance->CR, AES_CR_KMOD, CRYP_KEYMODE_NORMAL);
 c03d686:	682a      	ldr	r2, [r5, #0]
 c03d688:	f022 7240 	bic.w	r2, r2, #50331648	@ 0x3000000
 c03d68c:	602a      	str	r2, [r5, #0]
      MODIFY_REG(hcryp->Instance->CR, AES_CR_MODE, CRYP_OPERATINGMODE_KEYDERIVATION);
 c03d68e:	682a      	ldr	r2, [r5, #0]
 c03d690:	f022 0218 	bic.w	r2, r2, #24
 c03d694:	f042 0208 	orr.w	r2, r2, #8
 c03d698:	602a      	str	r2, [r5, #0]
      if ((hcryp->Init.KeySelect == CRYP_KEYSEL_NORMAL) && (hcryp->Init.KeyMode == CRYP_KEYMODE_NORMAL))
 c03d69a:	6b62      	ldr	r2, [r4, #52]	@ 0x34
 c03d69c:	b93a      	cbnz	r2, c03d6ae <HAL_CRYP_Decrypt+0x19a>
 c03d69e:	6b22      	ldr	r2, [r4, #48]	@ 0x30
 c03d6a0:	b92a      	cbnz	r2, c03d6ae <HAL_CRYP_Decrypt+0x19a>
        if (hcryp->Init.KeyIVConfigSkip != CRYP_KEYNOCONFIG)
 c03d6a2:	2b02      	cmp	r3, #2
 c03d6a4:	d003      	beq.n	c03d6ae <HAL_CRYP_Decrypt+0x19a>
          CRYP_SetKey(hcryp, hcryp->Init.KeySize);
 c03d6a6:	4620      	mov	r0, r4
 c03d6a8:	68a1      	ldr	r1, [r4, #8]
 c03d6aa:	f7ff f9ed 	bl	c03ca88 <CRYP_SetKey>
      __HAL_CRYP_ENABLE(hcryp);
 c03d6ae:	682b      	ldr	r3, [r5, #0]
 c03d6b0:	f043 0301 	orr.w	r3, r3, #1
 c03d6b4:	602b      	str	r3, [r5, #0]
 c03d6b6:	e793      	b.n	c03d5e0 <HAL_CRYP_Decrypt+0xcc>
    CRYP_AES_ProcessData(hcryp, Timeout);
 c03d6b8:	4631      	mov	r1, r6
 c03d6ba:	4620      	mov	r0, r4
 c03d6bc:	f7ff fc27 	bl	c03cf0e <CRYP_AES_ProcessData>
 c03d6c0:	e7ab      	b.n	c03d61a <HAL_CRYP_Decrypt+0x106>
        status = CRYP_AESGCM_Process(hcryp, Timeout);
 c03d6c2:	4631      	mov	r1, r6
 c03d6c4:	4620      	mov	r0, r4
 c03d6c6:	f7ff fd72 	bl	c03d1ae <CRYP_AESGCM_Process>
    if (status == HAL_OK)
 c03d6ca:	2800      	cmp	r0, #0
 c03d6cc:	f47f af59 	bne.w	c03d582 <HAL_CRYP_Decrypt+0x6e>
 c03d6d0:	e7ba      	b.n	c03d648 <HAL_CRYP_Decrypt+0x134>
    hcryp->ErrorCode |= HAL_CRYP_ERROR_BUSY;
 c03d6d2:	6de3      	ldr	r3, [r4, #92]	@ 0x5c
 c03d6d4:	f043 0308 	orr.w	r3, r3, #8
 c03d6d8:	e751      	b.n	c03d57e <HAL_CRYP_Decrypt+0x6a>
 c03d6da:	bf00      	nop
 c03d6dc:	00010060 	.word	0x00010060
 c03d6e0:	00010040 	.word	0x00010040
 c03d6e4:	520c0000 	.word	0x520c0000

0c03d6e8 <HAL_CRYPEx_AESCCM_GenerateAuthTAG>:
  *         buffer which correspond exactly to TAG length.
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_CRYPEx_AESCCM_GenerateAuthTAG(CRYP_HandleTypeDef *hcryp, uint32_t *pAuthTag, uint32_t Timeout)
{
 c03d6e8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint32_t tagaddr = (uint32_t)pAuthTag;
  uint32_t i;
  uint32_t tickstart;

  if (hcryp->State == HAL_CRYP_STATE_READY)
 c03d6ea:	f890 3059 	ldrb.w	r3, [r0, #89]	@ 0x59
{
 c03d6ee:	460d      	mov	r5, r1
  if (hcryp->State == HAL_CRYP_STATE_READY)
 c03d6f0:	2b01      	cmp	r3, #1
{
 c03d6f2:	4604      	mov	r4, r0
 c03d6f4:	4616      	mov	r6, r2
  if (hcryp->State == HAL_CRYP_STATE_READY)
 c03d6f6:	b2d9      	uxtb	r1, r3
 c03d6f8:	d161      	bne.n	c03d7be <HAL_CRYPEx_AESCCM_GenerateAuthTAG+0xd6>
  {
    __HAL_LOCK(hcryp);
 c03d6fa:	f890 3058 	ldrb.w	r3, [r0, #88]	@ 0x58
 c03d6fe:	2b01      	cmp	r3, #1
 c03d700:	d060      	beq.n	c03d7c4 <HAL_CRYPEx_AESCCM_GenerateAuthTAG+0xdc>

    /* Disable interrupts in case they were kept enabled to proceed
       a single message in several iterations */
    __HAL_CRYP_DISABLE_IT(hcryp, CRYP_IT_CCFIE | CRYP_IT_RWEIE | CRYP_IT_KEIE);
 c03d702:	6803      	ldr	r3, [r0, #0]
    __HAL_LOCK(hcryp);
 c03d704:	f880 1058 	strb.w	r1, [r0, #88]	@ 0x58
    __HAL_CRYP_DISABLE_IT(hcryp, CRYP_IT_CCFIE | CRYP_IT_RWEIE | CRYP_IT_KEIE);
 c03d708:	f8d3 2300 	ldr.w	r2, [r3, #768]	@ 0x300
 c03d70c:	f022 0207 	bic.w	r2, r2, #7
 c03d710:	f8c3 2300 	str.w	r2, [r3, #768]	@ 0x300

    /* Change the CRYP peripheral state */
    hcryp->State = HAL_CRYP_STATE_BUSY;
 c03d714:	2202      	movs	r2, #2
 c03d716:	f880 2059 	strb.w	r2, [r0, #89]	@ 0x59

    /* Check if initialization phase has already been performed */
    if (hcryp->Phase == CRYPEx_PHASE_PROCESS)
 c03d71a:	6cc2      	ldr	r2, [r0, #76]	@ 0x4c
 c03d71c:	2a02      	cmp	r2, #2
 c03d71e:	d143      	bne.n	c03d7a8 <HAL_CRYPEx_AESCCM_GenerateAuthTAG+0xc0>
    {
      /* Change the CRYP phase */
      hcryp->Phase = CRYPEx_PHASE_FINAL;
 c03d720:	2203      	movs	r2, #3
 c03d722:	64c2      	str	r2, [r0, #76]	@ 0x4c
      /* Select final phase */
      MODIFY_REG(hcryp->Instance->CR, AES_CR_GCMPH, CRYP_PHASE_FINAL);
 c03d724:	681a      	ldr	r2, [r3, #0]
 c03d726:	f442 42c0 	orr.w	r2, r2, #24576	@ 0x6000
 c03d72a:	601a      	str	r2, [r3, #0]

      /* Set encrypt  operating mode */
      MODIFY_REG(hcryp->Instance->CR, AES_CR_MODE, CRYP_OPERATINGMODE_ENCRYPT);
 c03d72c:	681a      	ldr	r2, [r3, #0]
 c03d72e:	f022 0218 	bic.w	r2, r2, #24
 c03d732:	601a      	str	r2, [r3, #0]

      /* Wait for CCF flag to be raised */
      tickstart = HAL_GetTick();
 c03d734:	f006 fad8 	bl	c043ce8 <HAL_GetTick>
 c03d738:	4607      	mov	r7, r0
      while (HAL_IS_BIT_CLR(hcryp->Instance->SR, AES_SR_CCF))
 c03d73a:	6823      	ldr	r3, [r4, #0]
 c03d73c:	685a      	ldr	r2, [r3, #4]
 c03d73e:	07d2      	lsls	r2, r2, #31
 c03d740:	d518      	bpl.n	c03d774 <HAL_CRYPEx_AESCCM_GenerateAuthTAG+0x8c>
  uint32_t tagaddr = (uint32_t)pAuthTag;
 c03d742:	4629      	mov	r1, r5
          }
        }
      }

      /* Read the authentication TAG in the output FIFO */
      for (i = 0U; i < 4U; i++)
 c03d744:	f105 0210 	add.w	r2, r5, #16
      {
        *(uint32_t *)(tagaddr) = hcryp->Instance->DOUTR;
 c03d748:	68d8      	ldr	r0, [r3, #12]
 c03d74a:	f841 0b04 	str.w	r0, [r1], #4
      for (i = 0U; i < 4U; i++)
 c03d74e:	428a      	cmp	r2, r1
 c03d750:	d1fa      	bne.n	c03d748 <HAL_CRYPEx_AESCCM_GenerateAuthTAG+0x60>
        tagaddr += 4U;
      }

      /* Clear CCF Flag */
      __HAL_CRYP_CLEAR_FLAG(hcryp, CRYP_CLEAR_CCF);
 c03d752:	f8d3 2308 	ldr.w	r2, [r3, #776]	@ 0x308

      /* Change the CRYP peripheral state */
      hcryp->State = HAL_CRYP_STATE_READY;
      __HAL_UNLOCK(hcryp);
 c03d756:	2000      	movs	r0, #0
      __HAL_CRYP_CLEAR_FLAG(hcryp, CRYP_CLEAR_CCF);
 c03d758:	f042 0201 	orr.w	r2, r2, #1
 c03d75c:	f8c3 2308 	str.w	r2, [r3, #776]	@ 0x308
      hcryp->State = HAL_CRYP_STATE_READY;
 c03d760:	2201      	movs	r2, #1
      __HAL_UNLOCK(hcryp);
 c03d762:	f884 0058 	strb.w	r0, [r4, #88]	@ 0x58
      hcryp->State = HAL_CRYP_STATE_READY;
 c03d766:	f884 2059 	strb.w	r2, [r4, #89]	@ 0x59

      /* Disable CRYP */
      __HAL_CRYP_DISABLE(hcryp);
 c03d76a:	681a      	ldr	r2, [r3, #0]
 c03d76c:	f022 0201 	bic.w	r2, r2, #1
 c03d770:	601a      	str	r2, [r3, #0]
    hcryp->ErrorCode = HAL_CRYP_ERROR_BUSY;
    return HAL_ERROR;
  }
  /* Return function status */
  return HAL_OK;
}
 c03d772:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        if (Timeout != HAL_MAX_DELAY)
 c03d774:	1c71      	adds	r1, r6, #1
 c03d776:	d0e1      	beq.n	c03d73c <HAL_CRYPEx_AESCCM_GenerateAuthTAG+0x54>
          if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
 c03d778:	f006 fab6 	bl	c043ce8 <HAL_GetTick>
 c03d77c:	1bc0      	subs	r0, r0, r7
 c03d77e:	42b0      	cmp	r0, r6
 c03d780:	d801      	bhi.n	c03d786 <HAL_CRYPEx_AESCCM_GenerateAuthTAG+0x9e>
 c03d782:	2e00      	cmp	r6, #0
 c03d784:	d1d9      	bne.n	c03d73a <HAL_CRYPEx_AESCCM_GenerateAuthTAG+0x52>
            __HAL_CRYP_DISABLE(hcryp);
 c03d786:	6822      	ldr	r2, [r4, #0]
 c03d788:	6813      	ldr	r3, [r2, #0]
 c03d78a:	f023 0301 	bic.w	r3, r3, #1
 c03d78e:	6013      	str	r3, [r2, #0]
            hcryp->ErrorCode |= HAL_CRYP_ERROR_TIMEOUT;
 c03d790:	6de3      	ldr	r3, [r4, #92]	@ 0x5c
 c03d792:	f043 0310 	orr.w	r3, r3, #16
 c03d796:	65e3      	str	r3, [r4, #92]	@ 0x5c
            hcryp->State = HAL_CRYP_STATE_READY;
 c03d798:	2301      	movs	r3, #1
 c03d79a:	f884 3059 	strb.w	r3, [r4, #89]	@ 0x59
      __HAL_UNLOCK(hcryp);
 c03d79e:	2300      	movs	r3, #0
 c03d7a0:	f884 3058 	strb.w	r3, [r4, #88]	@ 0x58
            return HAL_ERROR;
 c03d7a4:	2001      	movs	r0, #1
 c03d7a6:	e7e4      	b.n	c03d772 <HAL_CRYPEx_AESCCM_GenerateAuthTAG+0x8a>
      __HAL_CRYP_DISABLE(hcryp);
 c03d7a8:	681a      	ldr	r2, [r3, #0]
 c03d7aa:	f022 0201 	bic.w	r2, r2, #1
 c03d7ae:	601a      	str	r2, [r3, #0]
      hcryp->ErrorCode |= HAL_CRYP_ERROR_AUTH_TAG_SEQUENCE;
 c03d7b0:	6dc3      	ldr	r3, [r0, #92]	@ 0x5c
 c03d7b2:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 c03d7b6:	65c3      	str	r3, [r0, #92]	@ 0x5c
      hcryp->State = HAL_CRYP_STATE_READY;
 c03d7b8:	f880 1059 	strb.w	r1, [r0, #89]	@ 0x59
 c03d7bc:	e7ef      	b.n	c03d79e <HAL_CRYPEx_AESCCM_GenerateAuthTAG+0xb6>
    hcryp->ErrorCode = HAL_CRYP_ERROR_BUSY;
 c03d7be:	2308      	movs	r3, #8
 c03d7c0:	65c3      	str	r3, [r0, #92]	@ 0x5c
    return HAL_ERROR;
 c03d7c2:	e7ef      	b.n	c03d7a4 <HAL_CRYPEx_AESCCM_GenerateAuthTAG+0xbc>
    __HAL_LOCK(hcryp);
 c03d7c4:	2002      	movs	r0, #2
 c03d7c6:	e7d4      	b.n	c03d772 <HAL_CRYPEx_AESCCM_GenerateAuthTAG+0x8a>

0c03d7c8 <HAL_DMA_Init>:
  * @param  hdma : Pointer to a DMA_HandleTypeDef structure that contains the configuration information for the
  *                specified DMA Channel.
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *const hdma)
{
 c03d7c8:	b538      	push	{r3, r4, r5, lr}
 c03d7ca:	4604      	mov	r4, r0
  /* Get tick number */
  uint32_t tickstart = HAL_GetTick();
 c03d7cc:	f006 fa8c 	bl	c043ce8 <HAL_GetTick>
 c03d7d0:	4605      	mov	r5, r0

  /* Check the DMA peripheral handle parameter */
  if (hdma == NULL)
 c03d7d2:	2c00      	cmp	r4, #0
 c03d7d4:	f000 81a6 	beq.w	c03db24 <HAL_DMA_Init+0x35c>
    assert_param(IS_DMA_BURST_LENGTH(hdma->Init.DestBurstLength));
    assert_param(IS_DMA_TRANSFER_ALLOCATED_PORT(hdma->Init.TransferAllocatedPort));
  }

  /* Allocate lock resource */
  __HAL_UNLOCK(hdma);
 c03d7d8:	2300      	movs	r3, #0
 c03d7da:	f884 304c 	strb.w	r3, [r4, #76]	@ 0x4c

  /* Update the DMA channel state */
  hdma->State = HAL_DMA_STATE_BUSY;
 c03d7de:	2302      	movs	r3, #2
  if (IS_GPDMA_INSTANCE(hdma->Instance) != 0U)
 c03d7e0:	6822      	ldr	r2, [r4, #0]
  hdma->State = HAL_DMA_STATE_BUSY;
 c03d7e2:	f884 3054 	strb.w	r3, [r4, #84]	@ 0x54

  /* Disable the DMA channel */
  __HAL_DMA_DISABLE(hdma);
 c03d7e6:	6953      	ldr	r3, [r2, #20]
 c03d7e8:	f043 0306 	orr.w	r3, r3, #6
 c03d7ec:	6153      	str	r3, [r2, #20]

  /* Check if the DMA channel is effectively disabled */
  while ((hdma->Instance->CCR & DMA_CCR_EN) != 0U)
 c03d7ee:	6823      	ldr	r3, [r4, #0]
 c03d7f0:	695a      	ldr	r2, [r3, #20]
 c03d7f2:	07d2      	lsls	r2, r2, #31
 c03d7f4:	f100 818b 	bmi.w	c03db0e <HAL_DMA_Init+0x346>

  /* Prepare DMA Channel Control Register (CCR) value *****************************************************************/
  tmpreg = hdma->Init.Priority;

  /* Write DMA Channel Control Register (CCR) */
  MODIFY_REG(hdma->Instance->CCR, DMA_CCR_PRIO | DMA_CCR_LAP | DMA_CCR_LSM, tmpreg);
 c03d7f8:	695a      	ldr	r2, [r3, #20]
 c03d7fa:	6a21      	ldr	r1, [r4, #32]
 c03d7fc:	f422 0243 	bic.w	r2, r2, #12779520	@ 0xc30000
 c03d800:	430a      	orrs	r2, r1
 c03d802:	615a      	str	r2, [r3, #20]


  /* Prepare DMA Channel Transfer Register (CTR1) value ***************************************************************/
  tmpreg = hdma->Init.DestInc | hdma->Init.DestDataWidth | hdma->Init.SrcInc | hdma->Init.SrcDataWidth;
 c03d804:	69e1      	ldr	r1, [r4, #28]
 c03d806:	6962      	ldr	r2, [r4, #20]

  /* Add parameters specific to GPDMA */
  if (IS_GPDMA_INSTANCE(hdma->Instance) != 0U)
 c03d808:	4db0      	ldr	r5, [pc, #704]	@ (c03dacc <HAL_DMA_Init+0x304>)
  tmpreg = hdma->Init.DestInc | hdma->Init.DestDataWidth | hdma->Init.SrcInc | hdma->Init.SrcDataWidth;
 c03d80a:	430a      	orrs	r2, r1
 c03d80c:	6921      	ldr	r1, [r4, #16]
  if (IS_GPDMA_INSTANCE(hdma->Instance) != 0U)
 c03d80e:	42ab      	cmp	r3, r5
  tmpreg = hdma->Init.DestInc | hdma->Init.DestDataWidth | hdma->Init.SrcInc | hdma->Init.SrcDataWidth;
 c03d810:	ea42 0201 	orr.w	r2, r2, r1
 c03d814:	69a1      	ldr	r1, [r4, #24]
 c03d816:	48ae      	ldr	r0, [pc, #696]	@ (c03dad0 <HAL_DMA_Init+0x308>)
 c03d818:	ea42 0201 	orr.w	r2, r2, r1
  if (IS_GPDMA_INSTANCE(hdma->Instance) != 0U)
 c03d81c:	f000 8087 	beq.w	c03d92e <HAL_DMA_Init+0x166>
 c03d820:	49ac      	ldr	r1, [pc, #688]	@ (c03dad4 <HAL_DMA_Init+0x30c>)
 c03d822:	428b      	cmp	r3, r1
 c03d824:	f000 8083 	beq.w	c03d92e <HAL_DMA_Init+0x166>
 c03d828:	f101 4170 	add.w	r1, r1, #4026531840	@ 0xf0000000
 c03d82c:	3180      	adds	r1, #128	@ 0x80
 c03d82e:	428b      	cmp	r3, r1
 c03d830:	d07d      	beq.n	c03d92e <HAL_DMA_Init+0x166>
 c03d832:	f101 5180 	add.w	r1, r1, #268435456	@ 0x10000000
 c03d836:	428b      	cmp	r3, r1
 c03d838:	d079      	beq.n	c03d92e <HAL_DMA_Init+0x166>
 c03d83a:	f101 4170 	add.w	r1, r1, #4026531840	@ 0xf0000000
 c03d83e:	3180      	adds	r1, #128	@ 0x80
 c03d840:	428b      	cmp	r3, r1
 c03d842:	d074      	beq.n	c03d92e <HAL_DMA_Init+0x166>
 c03d844:	f101 5180 	add.w	r1, r1, #268435456	@ 0x10000000
 c03d848:	428b      	cmp	r3, r1
 c03d84a:	d070      	beq.n	c03d92e <HAL_DMA_Init+0x166>
 c03d84c:	f101 4170 	add.w	r1, r1, #4026531840	@ 0xf0000000
 c03d850:	3180      	adds	r1, #128	@ 0x80
 c03d852:	428b      	cmp	r3, r1
 c03d854:	d06b      	beq.n	c03d92e <HAL_DMA_Init+0x166>
 c03d856:	f101 5180 	add.w	r1, r1, #268435456	@ 0x10000000
 c03d85a:	428b      	cmp	r3, r1
 c03d85c:	d067      	beq.n	c03d92e <HAL_DMA_Init+0x166>
 c03d85e:	f101 4170 	add.w	r1, r1, #4026531840	@ 0xf0000000
 c03d862:	3180      	adds	r1, #128	@ 0x80
 c03d864:	428b      	cmp	r3, r1
 c03d866:	d062      	beq.n	c03d92e <HAL_DMA_Init+0x166>
 c03d868:	f101 5180 	add.w	r1, r1, #268435456	@ 0x10000000
 c03d86c:	428b      	cmp	r3, r1
 c03d86e:	d05e      	beq.n	c03d92e <HAL_DMA_Init+0x166>
 c03d870:	f101 4170 	add.w	r1, r1, #4026531840	@ 0xf0000000
 c03d874:	3180      	adds	r1, #128	@ 0x80
 c03d876:	428b      	cmp	r3, r1
 c03d878:	d059      	beq.n	c03d92e <HAL_DMA_Init+0x166>
 c03d87a:	f101 5180 	add.w	r1, r1, #268435456	@ 0x10000000
 c03d87e:	428b      	cmp	r3, r1
 c03d880:	d055      	beq.n	c03d92e <HAL_DMA_Init+0x166>
 c03d882:	f101 4170 	add.w	r1, r1, #4026531840	@ 0xf0000000
 c03d886:	3180      	adds	r1, #128	@ 0x80
 c03d888:	428b      	cmp	r3, r1
 c03d88a:	d050      	beq.n	c03d92e <HAL_DMA_Init+0x166>
 c03d88c:	f101 5180 	add.w	r1, r1, #268435456	@ 0x10000000
 c03d890:	428b      	cmp	r3, r1
 c03d892:	d04c      	beq.n	c03d92e <HAL_DMA_Init+0x166>
 c03d894:	f101 4170 	add.w	r1, r1, #4026531840	@ 0xf0000000
 c03d898:	3180      	adds	r1, #128	@ 0x80
 c03d89a:	428b      	cmp	r3, r1
 c03d89c:	d047      	beq.n	c03d92e <HAL_DMA_Init+0x166>
 c03d89e:	f101 5180 	add.w	r1, r1, #268435456	@ 0x10000000
 c03d8a2:	428b      	cmp	r3, r1
 c03d8a4:	d043      	beq.n	c03d92e <HAL_DMA_Init+0x166>
 c03d8a6:	f101 4170 	add.w	r1, r1, #4026531840	@ 0xf0000000
 c03d8aa:	3180      	adds	r1, #128	@ 0x80
 c03d8ac:	428b      	cmp	r3, r1
 c03d8ae:	d03e      	beq.n	c03d92e <HAL_DMA_Init+0x166>
 c03d8b0:	f101 5180 	add.w	r1, r1, #268435456	@ 0x10000000
 c03d8b4:	428b      	cmp	r3, r1
 c03d8b6:	d03a      	beq.n	c03d92e <HAL_DMA_Init+0x166>
 c03d8b8:	f101 4170 	add.w	r1, r1, #4026531840	@ 0xf0000000
 c03d8bc:	3180      	adds	r1, #128	@ 0x80
 c03d8be:	428b      	cmp	r3, r1
 c03d8c0:	d035      	beq.n	c03d92e <HAL_DMA_Init+0x166>
 c03d8c2:	f101 5180 	add.w	r1, r1, #268435456	@ 0x10000000
 c03d8c6:	428b      	cmp	r3, r1
 c03d8c8:	d031      	beq.n	c03d92e <HAL_DMA_Init+0x166>
 c03d8ca:	f101 4170 	add.w	r1, r1, #4026531840	@ 0xf0000000
 c03d8ce:	3180      	adds	r1, #128	@ 0x80
 c03d8d0:	428b      	cmp	r3, r1
 c03d8d2:	d02c      	beq.n	c03d92e <HAL_DMA_Init+0x166>
 c03d8d4:	f101 5180 	add.w	r1, r1, #268435456	@ 0x10000000
 c03d8d8:	428b      	cmp	r3, r1
 c03d8da:	d028      	beq.n	c03d92e <HAL_DMA_Init+0x166>
 c03d8dc:	f101 4170 	add.w	r1, r1, #4026531840	@ 0xf0000000
 c03d8e0:	3180      	adds	r1, #128	@ 0x80
 c03d8e2:	428b      	cmp	r3, r1
 c03d8e4:	d023      	beq.n	c03d92e <HAL_DMA_Init+0x166>
 c03d8e6:	f101 5180 	add.w	r1, r1, #268435456	@ 0x10000000
 c03d8ea:	428b      	cmp	r3, r1
 c03d8ec:	d01f      	beq.n	c03d92e <HAL_DMA_Init+0x166>
 c03d8ee:	4283      	cmp	r3, r0
 c03d8f0:	d01d      	beq.n	c03d92e <HAL_DMA_Init+0x166>
 c03d8f2:	3180      	adds	r1, #128	@ 0x80
 c03d8f4:	428b      	cmp	r3, r1
 c03d8f6:	d01a      	beq.n	c03d92e <HAL_DMA_Init+0x166>
 c03d8f8:	f101 4170 	add.w	r1, r1, #4026531840	@ 0xf0000000
 c03d8fc:	3180      	adds	r1, #128	@ 0x80
 c03d8fe:	428b      	cmp	r3, r1
 c03d900:	d015      	beq.n	c03d92e <HAL_DMA_Init+0x166>
 c03d902:	f101 5180 	add.w	r1, r1, #268435456	@ 0x10000000
 c03d906:	428b      	cmp	r3, r1
 c03d908:	d011      	beq.n	c03d92e <HAL_DMA_Init+0x166>
 c03d90a:	f101 4170 	add.w	r1, r1, #4026531840	@ 0xf0000000
 c03d90e:	3180      	adds	r1, #128	@ 0x80
 c03d910:	428b      	cmp	r3, r1
 c03d912:	d00c      	beq.n	c03d92e <HAL_DMA_Init+0x166>
 c03d914:	f101 5180 	add.w	r1, r1, #268435456	@ 0x10000000
 c03d918:	428b      	cmp	r3, r1
 c03d91a:	d008      	beq.n	c03d92e <HAL_DMA_Init+0x166>
 c03d91c:	f101 4170 	add.w	r1, r1, #4026531840	@ 0xf0000000
 c03d920:	3180      	adds	r1, #128	@ 0x80
 c03d922:	428b      	cmp	r3, r1
 c03d924:	d003      	beq.n	c03d92e <HAL_DMA_Init+0x166>
 c03d926:	f101 5180 	add.w	r1, r1, #268435456	@ 0x10000000
 c03d92a:	428b      	cmp	r3, r1
 c03d92c:	d10d      	bne.n	c03d94a <HAL_DMA_Init+0x182>
  {
    tmpreg |= (hdma->Init.TransferAllocatedPort                                             |
               (((hdma->Init.DestBurstLength - 1U) << DMA_CTR1_DBL_1_Pos) & DMA_CTR1_DBL_1) |
 c03d92e:	6aa1      	ldr	r1, [r4, #40]	@ 0x28
 c03d930:	3901      	subs	r1, #1
 c03d932:	0509      	lsls	r1, r1, #20
 c03d934:	f001 717c 	and.w	r1, r1, #66060288	@ 0x3f00000
 c03d938:	4311      	orrs	r1, r2
 c03d93a:	6ae2      	ldr	r2, [r4, #44]	@ 0x2c
 c03d93c:	4311      	orrs	r1, r2
               (((hdma->Init.SrcBurstLength - 1U) << DMA_CTR1_SBL_1_Pos) & DMA_CTR1_SBL_1));
 c03d93e:	6a62      	ldr	r2, [r4, #36]	@ 0x24
 c03d940:	3a01      	subs	r2, #1
 c03d942:	0112      	lsls	r2, r2, #4
 c03d944:	f402 727c 	and.w	r2, r2, #1008	@ 0x3f0
    tmpreg |= (hdma->Init.TransferAllocatedPort                                             |
 c03d948:	430a      	orrs	r2, r1
  }

  /* Write DMA Channel Transfer Register 1 (CTR1) */
  MODIFY_REG(hdma->Instance->CTR1, ~(DMA_CTR1_SSEC | DMA_CTR1_DSEC), tmpreg);
 c03d94a:	6c19      	ldr	r1, [r3, #64]	@ 0x40
 c03d94c:	f001 2180 	and.w	r1, r1, #2147516416	@ 0x80008000
 c03d950:	430a      	orrs	r2, r1
 c03d952:	641a      	str	r2, [r3, #64]	@ 0x40

  /* Prepare DMA Channel Transfer Register 2 (CTR2) value *************************************************************/
  tmpreg = hdma->Init.BlkHWRequest | (hdma->Init.Request & DMA_CTR2_REQSEL) | hdma->Init.TransferEventMode;
 c03d954:	68a1      	ldr	r1, [r4, #8]
 c03d956:	6b22      	ldr	r2, [r4, #48]	@ 0x30
 c03d958:	4311      	orrs	r1, r2
 c03d95a:	6862      	ldr	r2, [r4, #4]
 c03d95c:	f002 027f 	and.w	r2, r2, #127	@ 0x7f
 c03d960:	4311      	orrs	r1, r2

  /* Memory to Peripheral Transfer */
  if ((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
 c03d962:	68e2      	ldr	r2, [r4, #12]
 c03d964:	f5b2 6f80 	cmp.w	r2, #1024	@ 0x400
 c03d968:	f040 80de 	bne.w	c03db28 <HAL_DMA_Init+0x360>
  {
    if (IS_GPDMA_INSTANCE(hdma->Instance) != 0U)
 c03d96c:	42ab      	cmp	r3, r5
 c03d96e:	f000 8087 	beq.w	c03da80 <HAL_DMA_Init+0x2b8>
 c03d972:	4a58      	ldr	r2, [pc, #352]	@ (c03dad4 <HAL_DMA_Init+0x30c>)
 c03d974:	4293      	cmp	r3, r2
 c03d976:	f000 8083 	beq.w	c03da80 <HAL_DMA_Init+0x2b8>
 c03d97a:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
 c03d97e:	3280      	adds	r2, #128	@ 0x80
 c03d980:	4293      	cmp	r3, r2
 c03d982:	d07d      	beq.n	c03da80 <HAL_DMA_Init+0x2b8>
 c03d984:	f102 5280 	add.w	r2, r2, #268435456	@ 0x10000000
 c03d988:	4293      	cmp	r3, r2
 c03d98a:	d079      	beq.n	c03da80 <HAL_DMA_Init+0x2b8>
 c03d98c:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
 c03d990:	3280      	adds	r2, #128	@ 0x80
 c03d992:	4293      	cmp	r3, r2
 c03d994:	d074      	beq.n	c03da80 <HAL_DMA_Init+0x2b8>
 c03d996:	f102 5280 	add.w	r2, r2, #268435456	@ 0x10000000
 c03d99a:	4293      	cmp	r3, r2
 c03d99c:	d070      	beq.n	c03da80 <HAL_DMA_Init+0x2b8>
 c03d99e:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
 c03d9a2:	3280      	adds	r2, #128	@ 0x80
 c03d9a4:	4293      	cmp	r3, r2
 c03d9a6:	d06b      	beq.n	c03da80 <HAL_DMA_Init+0x2b8>
 c03d9a8:	f102 5280 	add.w	r2, r2, #268435456	@ 0x10000000
 c03d9ac:	4293      	cmp	r3, r2
 c03d9ae:	d067      	beq.n	c03da80 <HAL_DMA_Init+0x2b8>
 c03d9b0:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
 c03d9b4:	3280      	adds	r2, #128	@ 0x80
 c03d9b6:	4293      	cmp	r3, r2
 c03d9b8:	d062      	beq.n	c03da80 <HAL_DMA_Init+0x2b8>
 c03d9ba:	f102 5280 	add.w	r2, r2, #268435456	@ 0x10000000
 c03d9be:	4293      	cmp	r3, r2
 c03d9c0:	d05e      	beq.n	c03da80 <HAL_DMA_Init+0x2b8>
 c03d9c2:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
 c03d9c6:	3280      	adds	r2, #128	@ 0x80
 c03d9c8:	4293      	cmp	r3, r2
 c03d9ca:	d059      	beq.n	c03da80 <HAL_DMA_Init+0x2b8>
 c03d9cc:	f102 5280 	add.w	r2, r2, #268435456	@ 0x10000000
 c03d9d0:	4293      	cmp	r3, r2
 c03d9d2:	d055      	beq.n	c03da80 <HAL_DMA_Init+0x2b8>
 c03d9d4:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
 c03d9d8:	3280      	adds	r2, #128	@ 0x80
 c03d9da:	4293      	cmp	r3, r2
 c03d9dc:	d050      	beq.n	c03da80 <HAL_DMA_Init+0x2b8>
 c03d9de:	f102 5280 	add.w	r2, r2, #268435456	@ 0x10000000
 c03d9e2:	4293      	cmp	r3, r2
 c03d9e4:	d04c      	beq.n	c03da80 <HAL_DMA_Init+0x2b8>
 c03d9e6:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
 c03d9ea:	3280      	adds	r2, #128	@ 0x80
 c03d9ec:	4293      	cmp	r3, r2
 c03d9ee:	d047      	beq.n	c03da80 <HAL_DMA_Init+0x2b8>
 c03d9f0:	f102 5280 	add.w	r2, r2, #268435456	@ 0x10000000
 c03d9f4:	4293      	cmp	r3, r2
 c03d9f6:	d043      	beq.n	c03da80 <HAL_DMA_Init+0x2b8>
 c03d9f8:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
 c03d9fc:	3280      	adds	r2, #128	@ 0x80
 c03d9fe:	4293      	cmp	r3, r2
 c03da00:	d03e      	beq.n	c03da80 <HAL_DMA_Init+0x2b8>
 c03da02:	f102 5280 	add.w	r2, r2, #268435456	@ 0x10000000
 c03da06:	4293      	cmp	r3, r2
 c03da08:	d03a      	beq.n	c03da80 <HAL_DMA_Init+0x2b8>
 c03da0a:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
 c03da0e:	3280      	adds	r2, #128	@ 0x80
 c03da10:	4293      	cmp	r3, r2
 c03da12:	d035      	beq.n	c03da80 <HAL_DMA_Init+0x2b8>
 c03da14:	f102 5280 	add.w	r2, r2, #268435456	@ 0x10000000
 c03da18:	4293      	cmp	r3, r2
 c03da1a:	d031      	beq.n	c03da80 <HAL_DMA_Init+0x2b8>
 c03da1c:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
 c03da20:	3280      	adds	r2, #128	@ 0x80
 c03da22:	4293      	cmp	r3, r2
 c03da24:	d02c      	beq.n	c03da80 <HAL_DMA_Init+0x2b8>
 c03da26:	f102 5280 	add.w	r2, r2, #268435456	@ 0x10000000
 c03da2a:	4293      	cmp	r3, r2
 c03da2c:	d028      	beq.n	c03da80 <HAL_DMA_Init+0x2b8>
 c03da2e:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
 c03da32:	3280      	adds	r2, #128	@ 0x80
 c03da34:	4293      	cmp	r3, r2
 c03da36:	d023      	beq.n	c03da80 <HAL_DMA_Init+0x2b8>
 c03da38:	f102 5280 	add.w	r2, r2, #268435456	@ 0x10000000
 c03da3c:	4293      	cmp	r3, r2
 c03da3e:	d01f      	beq.n	c03da80 <HAL_DMA_Init+0x2b8>
 c03da40:	4283      	cmp	r3, r0
 c03da42:	d01d      	beq.n	c03da80 <HAL_DMA_Init+0x2b8>
 c03da44:	3280      	adds	r2, #128	@ 0x80
 c03da46:	4293      	cmp	r3, r2
 c03da48:	d01a      	beq.n	c03da80 <HAL_DMA_Init+0x2b8>
 c03da4a:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
 c03da4e:	3280      	adds	r2, #128	@ 0x80
 c03da50:	4293      	cmp	r3, r2
 c03da52:	d015      	beq.n	c03da80 <HAL_DMA_Init+0x2b8>
 c03da54:	f102 5280 	add.w	r2, r2, #268435456	@ 0x10000000
 c03da58:	4293      	cmp	r3, r2
 c03da5a:	d011      	beq.n	c03da80 <HAL_DMA_Init+0x2b8>
 c03da5c:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
 c03da60:	3280      	adds	r2, #128	@ 0x80
 c03da62:	4293      	cmp	r3, r2
 c03da64:	d00c      	beq.n	c03da80 <HAL_DMA_Init+0x2b8>
 c03da66:	f102 5280 	add.w	r2, r2, #268435456	@ 0x10000000
 c03da6a:	4293      	cmp	r3, r2
 c03da6c:	d008      	beq.n	c03da80 <HAL_DMA_Init+0x2b8>
 c03da6e:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
 c03da72:	3280      	adds	r2, #128	@ 0x80
 c03da74:	4293      	cmp	r3, r2
 c03da76:	d003      	beq.n	c03da80 <HAL_DMA_Init+0x2b8>
 c03da78:	f102 5280 	add.w	r2, r2, #268435456	@ 0x10000000
 c03da7c:	4293      	cmp	r3, r2
 c03da7e:	d101      	bne.n	c03da84 <HAL_DMA_Init+0x2bc>
    {
      tmpreg |= DMA_CTR2_DREQ;
 c03da80:	f441 6180 	orr.w	r1, r1, #1024	@ 0x400
  {
    /* Nothing to do */
  }

  /* Write DMA Channel Transfer Register 2 (CTR2) */
  MODIFY_REG(hdma->Instance->CTR2, (DMA_CTR2_TCEM  | DMA_CTR2_TRIGPOL | DMA_CTR2_TRIGSEL | DMA_CTR2_TRIGM |
 c03da84:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
  /* Write DMA Channel Block Register 1 (CBR1) ************************************************************************/
  WRITE_REG(hdma->Instance->CBR1, 0U);


  /* If 2D Addressing is supported by current channel */
  if (IS_DMA_2D_ADDRESSING_INSTANCE(hdma->Instance) != 0U)
 c03da86:	4283      	cmp	r3, r0
  MODIFY_REG(hdma->Instance->CTR2, (DMA_CTR2_TCEM  | DMA_CTR2_TRIGPOL | DMA_CTR2_TRIGSEL | DMA_CTR2_TRIGM |
 c03da88:	f022 4243 	bic.w	r2, r2, #3271557120	@ 0xc3000000
 c03da8c:	f422 127f 	bic.w	r2, r2, #4177920	@ 0x3fc000
 c03da90:	f422 6267 	bic.w	r2, r2, #3696	@ 0xe70
 c03da94:	f022 020f 	bic.w	r2, r2, #15
 c03da98:	ea42 0201 	orr.w	r2, r2, r1
 c03da9c:	645a      	str	r2, [r3, #68]	@ 0x44
  WRITE_REG(hdma->Instance->CBR1, 0U);
 c03da9e:	f04f 0200 	mov.w	r2, #0
 c03daa2:	649a      	str	r2, [r3, #72]	@ 0x48
  if (IS_DMA_2D_ADDRESSING_INSTANCE(hdma->Instance) != 0U)
 c03daa4:	d027      	beq.n	c03daf6 <HAL_DMA_Init+0x32e>
 c03daa6:	4a0c      	ldr	r2, [pc, #48]	@ (c03dad8 <HAL_DMA_Init+0x310>)
 c03daa8:	4293      	cmp	r3, r2
 c03daaa:	d024      	beq.n	c03daf6 <HAL_DMA_Init+0x32e>
 c03daac:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
 c03dab0:	3280      	adds	r2, #128	@ 0x80
 c03dab2:	4293      	cmp	r3, r2
 c03dab4:	d01f      	beq.n	c03daf6 <HAL_DMA_Init+0x32e>
 c03dab6:	f102 5280 	add.w	r2, r2, #268435456	@ 0x10000000
 c03daba:	4293      	cmp	r3, r2
 c03dabc:	d01b      	beq.n	c03daf6 <HAL_DMA_Init+0x32e>
 c03dabe:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
 c03dac2:	3280      	adds	r2, #128	@ 0x80
 c03dac4:	4293      	cmp	r3, r2
 c03dac6:	d016      	beq.n	c03daf6 <HAL_DMA_Init+0x32e>
 c03dac8:	e008      	b.n	c03dadc <HAL_DMA_Init+0x314>
 c03daca:	bf00      	nop
 c03dacc:	40020050 	.word	0x40020050
 c03dad0:	40020650 	.word	0x40020650
 c03dad4:	50020050 	.word	0x50020050
 c03dad8:	50020650 	.word	0x50020650
 c03dadc:	f102 5280 	add.w	r2, r2, #268435456	@ 0x10000000
 c03dae0:	4293      	cmp	r3, r2
 c03dae2:	d008      	beq.n	c03daf6 <HAL_DMA_Init+0x32e>
 c03dae4:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
 c03dae8:	3280      	adds	r2, #128	@ 0x80
 c03daea:	4293      	cmp	r3, r2
 c03daec:	d003      	beq.n	c03daf6 <HAL_DMA_Init+0x32e>
 c03daee:	f102 5280 	add.w	r2, r2, #268435456	@ 0x10000000
 c03daf2:	4293      	cmp	r3, r2
 c03daf4:	d102      	bne.n	c03dafc <HAL_DMA_Init+0x334>
  {
    /* Write DMA Channel Transfer Register 3 (CTR3) *******************************************************************/
    WRITE_REG(hdma->Instance->CTR3, 0U);
 c03daf6:	2200      	movs	r2, #0
 c03daf8:	655a      	str	r2, [r3, #84]	@ 0x54


    /* Write DMA Channel Block Register 2 (CBR2) **********************************************************************/
    WRITE_REG(hdma->Instance->CBR2, 0U);
 c03dafa:	659a      	str	r2, [r3, #88]	@ 0x58
  }


  /* Write DMA Channel linked-list address register (CLLR) ************************************************************/
  WRITE_REG(hdma->Instance->CLLR, 0U);
 c03dafc:	2000      	movs	r0, #0
 c03dafe:	67d8      	str	r0, [r3, #124]	@ 0x7c
  hdma->Mode = hdma->Init.Mode;
 c03db00:	6b63      	ldr	r3, [r4, #52]	@ 0x34
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 c03db02:	65a0      	str	r0, [r4, #88]	@ 0x58
  hdma->Mode = hdma->Init.Mode;
 c03db04:	6523      	str	r3, [r4, #80]	@ 0x50
  hdma->State = HAL_DMA_STATE_READY;
 c03db06:	2301      	movs	r3, #1
 c03db08:	f884 3054 	strb.w	r3, [r4, #84]	@ 0x54
  return HAL_OK;
 c03db0c:	e00b      	b.n	c03db26 <HAL_DMA_Init+0x35e>
    if ((HAL_GetTick() - tickstart) > HAL_TIMEOUT_DMA_ABORT)
 c03db0e:	f006 f8eb 	bl	c043ce8 <HAL_GetTick>
 c03db12:	1b40      	subs	r0, r0, r5
 c03db14:	2805      	cmp	r0, #5
 c03db16:	f67f ae6a 	bls.w	c03d7ee <HAL_DMA_Init+0x26>
      hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
 c03db1a:	2310      	movs	r3, #16
 c03db1c:	65a3      	str	r3, [r4, #88]	@ 0x58
      hdma->State = HAL_DMA_STATE_ERROR;
 c03db1e:	2303      	movs	r3, #3
 c03db20:	f884 3054 	strb.w	r3, [r4, #84]	@ 0x54
    return HAL_ERROR;
 c03db24:	2001      	movs	r0, #1
}
 c03db26:	bd38      	pop	{r3, r4, r5, pc}
  else if ((hdma->Init.Direction) == DMA_MEMORY_TO_MEMORY)
 c03db28:	f5b2 7f00 	cmp.w	r2, #512	@ 0x200
    tmpreg |= DMA_CTR2_SWREQ;
 c03db2c:	bf08      	it	eq
 c03db2e:	f441 7100 	orreq.w	r1, r1, #512	@ 0x200
 c03db32:	e7a7      	b.n	c03da84 <HAL_DMA_Init+0x2bc>

0c03db34 <HAL_DMA_Start>:
{
 c03db34:	b530      	push	{r4, r5, lr}
  if (hdma == NULL)
 c03db36:	b330      	cbz	r0, c03db86 <HAL_DMA_Start+0x52>
  __HAL_LOCK(hdma);
 c03db38:	f890 404c 	ldrb.w	r4, [r0, #76]	@ 0x4c
 c03db3c:	2c01      	cmp	r4, #1
 c03db3e:	d024      	beq.n	c03db8a <HAL_DMA_Start+0x56>
 c03db40:	2401      	movs	r4, #1
 c03db42:	f880 404c 	strb.w	r4, [r0, #76]	@ 0x4c
  if (hdma->State == HAL_DMA_STATE_READY)
 c03db46:	f890 4054 	ldrb.w	r4, [r0, #84]	@ 0x54
 c03db4a:	2c01      	cmp	r4, #1
 c03db4c:	f04f 0400 	mov.w	r4, #0
 c03db50:	d115      	bne.n	c03db7e <HAL_DMA_Start+0x4a>
    hdma->State = HAL_DMA_STATE_BUSY;
 c03db52:	2502      	movs	r5, #2
 c03db54:	f880 5054 	strb.w	r5, [r0, #84]	@ 0x54
    hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 c03db58:	6584      	str	r4, [r0, #88]	@ 0x58
  MODIFY_REG(hdma->Instance->CBR1, DMA_CBR1_BNDT, (SrcDataSize & DMA_CBR1_BNDT));
 c03db5a:	6800      	ldr	r0, [r0, #0]
 c03db5c:	b29b      	uxth	r3, r3
 c03db5e:	6c85      	ldr	r5, [r0, #72]	@ 0x48
 c03db60:	0c2d      	lsrs	r5, r5, #16
 c03db62:	042d      	lsls	r5, r5, #16
 c03db64:	431d      	orrs	r5, r3
  __HAL_DMA_CLEAR_FLAG(hdma, DMA_FLAG_TC | DMA_FLAG_HT | DMA_FLAG_DTE | DMA_FLAG_ULE | DMA_FLAG_USE | DMA_FLAG_SUSP |
 c03db66:	f44f 43fe 	mov.w	r3, #32512	@ 0x7f00
  MODIFY_REG(hdma->Instance->CBR1, DMA_CBR1_BNDT, (SrcDataSize & DMA_CBR1_BNDT));
 c03db6a:	6485      	str	r5, [r0, #72]	@ 0x48
  __HAL_DMA_CLEAR_FLAG(hdma, DMA_FLAG_TC | DMA_FLAG_HT | DMA_FLAG_DTE | DMA_FLAG_ULE | DMA_FLAG_USE | DMA_FLAG_SUSP |
 c03db6c:	60c3      	str	r3, [r0, #12]
  hdma->Instance->CSAR = SrcAddress;
 c03db6e:	64c1      	str	r1, [r0, #76]	@ 0x4c
  hdma->Instance->CDAR = DstAddress;
 c03db70:	6502      	str	r2, [r0, #80]	@ 0x50
    __HAL_DMA_ENABLE(hdma);
 c03db72:	6943      	ldr	r3, [r0, #20]
 c03db74:	f043 0301 	orr.w	r3, r3, #1
 c03db78:	6143      	str	r3, [r0, #20]
  return HAL_OK;
 c03db7a:	4620      	mov	r0, r4
}
 c03db7c:	bd30      	pop	{r4, r5, pc}
    hdma->ErrorCode = HAL_DMA_ERROR_BUSY;
 c03db7e:	2340      	movs	r3, #64	@ 0x40
    __HAL_UNLOCK(hdma);
 c03db80:	f880 404c 	strb.w	r4, [r0, #76]	@ 0x4c
    hdma->ErrorCode = HAL_DMA_ERROR_BUSY;
 c03db84:	6583      	str	r3, [r0, #88]	@ 0x58
    return HAL_ERROR;
 c03db86:	2001      	movs	r0, #1
 c03db88:	e7f8      	b.n	c03db7c <HAL_DMA_Start+0x48>
  __HAL_LOCK(hdma);
 c03db8a:	2002      	movs	r0, #2
 c03db8c:	e7f6      	b.n	c03db7c <HAL_DMA_Start+0x48>

0c03db8e <HAL_DMA_Abort>:
{
 c03db8e:	b538      	push	{r3, r4, r5, lr}
 c03db90:	4604      	mov	r4, r0
  uint32_t tickstart =  HAL_GetTick();
 c03db92:	f006 f8a9 	bl	c043ce8 <HAL_GetTick>
 c03db96:	4605      	mov	r5, r0
  if (hdma == NULL)
 c03db98:	b144      	cbz	r4, c03dbac <HAL_DMA_Abort+0x1e>
  if (hdma->State != HAL_DMA_STATE_BUSY)
 c03db9a:	f894 3054 	ldrb.w	r3, [r4, #84]	@ 0x54
 c03db9e:	2b02      	cmp	r3, #2
 c03dba0:	d006      	beq.n	c03dbb0 <HAL_DMA_Abort+0x22>
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 c03dba2:	2320      	movs	r3, #32
 c03dba4:	65a3      	str	r3, [r4, #88]	@ 0x58
    __HAL_UNLOCK(hdma);
 c03dba6:	2300      	movs	r3, #0
 c03dba8:	f884 304c 	strb.w	r3, [r4, #76]	@ 0x4c
    return HAL_ERROR;
 c03dbac:	2001      	movs	r0, #1
}
 c03dbae:	bd38      	pop	{r3, r4, r5, pc}
    hdma->Instance->CCR |= DMA_CCR_SUSP;
 c03dbb0:	6822      	ldr	r2, [r4, #0]
 c03dbb2:	6953      	ldr	r3, [r2, #20]
 c03dbb4:	f043 0304 	orr.w	r3, r3, #4
 c03dbb8:	6153      	str	r3, [r2, #20]
    hdma->State = HAL_DMA_STATE_SUSPEND;
 c03dbba:	2305      	movs	r3, #5
 c03dbbc:	f884 3054 	strb.w	r3, [r4, #84]	@ 0x54
    while ((hdma->Instance->CSR & DMA_CSR_SUSPF) == 0U)
 c03dbc0:	6823      	ldr	r3, [r4, #0]
 c03dbc2:	691a      	ldr	r2, [r3, #16]
 c03dbc4:	0490      	lsls	r0, r2, #18
 c03dbc6:	d519      	bpl.n	c03dbfc <HAL_DMA_Abort+0x6e>
    hdma->Instance->CCR |= DMA_CCR_RESET;
 c03dbc8:	695a      	ldr	r2, [r3, #20]
    if ((hdma->Mode & DMA_LINKEDLIST) == DMA_LINKEDLIST)
 c03dbca:	6d21      	ldr	r1, [r4, #80]	@ 0x50
    hdma->Instance->CCR |= DMA_CCR_RESET;
 c03dbcc:	f042 0202 	orr.w	r2, r2, #2
 c03dbd0:	615a      	str	r2, [r3, #20]
    hdma->State = HAL_DMA_STATE_ABORT;
 c03dbd2:	2204      	movs	r2, #4
 c03dbd4:	f884 2054 	strb.w	r2, [r4, #84]	@ 0x54
    __HAL_DMA_CLEAR_FLAG(hdma, (DMA_FLAG_TC | DMA_FLAG_HT | DMA_FLAG_DTE | DMA_FLAG_ULE | DMA_FLAG_USE | DMA_FLAG_SUSP |
 c03dbd8:	f44f 42fe 	mov.w	r2, #32512	@ 0x7f00
 c03dbdc:	60da      	str	r2, [r3, #12]
    hdma->State = HAL_DMA_STATE_READY;
 c03dbde:	2201      	movs	r2, #1
    if ((hdma->Mode & DMA_LINKEDLIST) == DMA_LINKEDLIST)
 c03dbe0:	0609      	lsls	r1, r1, #24
      hdma->LinkedListQueue->State = HAL_DMA_QUEUE_STATE_READY;
 c03dbe2:	bf48      	it	mi
 c03dbe4:	6f61      	ldrmi	r1, [r4, #116]	@ 0x74
    hdma->State = HAL_DMA_STATE_READY;
 c03dbe6:	f884 2054 	strb.w	r2, [r4, #84]	@ 0x54
    __HAL_UNLOCK(hdma);
 c03dbea:	f04f 0000 	mov.w	r0, #0
      hdma->LinkedListQueue->State = HAL_DMA_QUEUE_STATE_READY;
 c03dbee:	bf42      	ittt	mi
 c03dbf0:	730a      	strbmi	r2, [r1, #12]
      hdma->Instance->CBR1 = 0U;
 c03dbf2:	2200      	movmi	r2, #0
 c03dbf4:	649a      	strmi	r2, [r3, #72]	@ 0x48
    __HAL_UNLOCK(hdma);
 c03dbf6:	f884 004c 	strb.w	r0, [r4, #76]	@ 0x4c
  return HAL_OK;
 c03dbfa:	e7d8      	b.n	c03dbae <HAL_DMA_Abort+0x20>
      if ((HAL_GetTick() - tickstart) > HAL_TIMEOUT_DMA_ABORT)
 c03dbfc:	f006 f874 	bl	c043ce8 <HAL_GetTick>
 c03dc00:	1b40      	subs	r0, r0, r5
 c03dc02:	2805      	cmp	r0, #5
 c03dc04:	d9dc      	bls.n	c03dbc0 <HAL_DMA_Abort+0x32>
        hdma->ErrorCode |= HAL_DMA_ERROR_TIMEOUT;
 c03dc06:	6da3      	ldr	r3, [r4, #88]	@ 0x58
 c03dc08:	f043 0310 	orr.w	r3, r3, #16
 c03dc0c:	65a3      	str	r3, [r4, #88]	@ 0x58
        hdma->State = HAL_DMA_STATE_ERROR;
 c03dc0e:	2303      	movs	r3, #3
 c03dc10:	f884 3054 	strb.w	r3, [r4, #84]	@ 0x54
        if ((hdma->Mode & DMA_LINKEDLIST) == DMA_LINKEDLIST)
 c03dc14:	6d23      	ldr	r3, [r4, #80]	@ 0x50
 c03dc16:	061d      	lsls	r5, r3, #24
 c03dc18:	d5c5      	bpl.n	c03dba6 <HAL_DMA_Abort+0x18>
          hdma->LinkedListQueue->State = HAL_DMA_QUEUE_STATE_READY;
 c03dc1a:	2201      	movs	r2, #1
 c03dc1c:	6f63      	ldr	r3, [r4, #116]	@ 0x74
 c03dc1e:	731a      	strb	r2, [r3, #12]
        __HAL_UNLOCK(hdma);
 c03dc20:	e7c1      	b.n	c03dba6 <HAL_DMA_Abort+0x18>

0c03dc22 <HAL_DMA_PollForTransfer>:
{
 c03dc22:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 c03dc26:	4604      	mov	r4, r0
 c03dc28:	460d      	mov	r5, r1
 c03dc2a:	4616      	mov	r6, r2
  uint32_t tickstart = HAL_GetTick();
 c03dc2c:	f006 f85c 	bl	c043ce8 <HAL_GetTick>
 c03dc30:	4607      	mov	r7, r0
  if (hdma == NULL)
 c03dc32:	b18c      	cbz	r4, c03dc58 <HAL_DMA_PollForTransfer+0x36>
  if (hdma->State != HAL_DMA_STATE_BUSY)
 c03dc34:	f894 3054 	ldrb.w	r3, [r4, #84]	@ 0x54
 c03dc38:	2b02      	cmp	r3, #2
 c03dc3a:	d005      	beq.n	c03dc48 <HAL_DMA_PollForTransfer+0x26>
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 c03dc3c:	2320      	movs	r3, #32
 c03dc3e:	65a3      	str	r3, [r4, #88]	@ 0x58
    __HAL_UNLOCK(hdma);
 c03dc40:	2300      	movs	r3, #0
 c03dc42:	f884 304c 	strb.w	r3, [r4, #76]	@ 0x4c
    return HAL_ERROR;
 c03dc46:	e007      	b.n	c03dc58 <HAL_DMA_PollForTransfer+0x36>
  if ((hdma->Mode & DMA_LINKEDLIST_CIRCULAR) == DMA_LINKEDLIST_CIRCULAR)
 c03dc48:	6d23      	ldr	r3, [r4, #80]	@ 0x50
 c03dc4a:	f003 0381 	and.w	r3, r3, #129	@ 0x81
 c03dc4e:	2b81      	cmp	r3, #129	@ 0x81
 c03dc50:	d104      	bne.n	c03dc5c <HAL_DMA_PollForTransfer+0x3a>
    hdma->ErrorCode = HAL_DMA_ERROR_NOT_SUPPORTED;
 c03dc52:	f44f 7380 	mov.w	r3, #256	@ 0x100
 c03dc56:	65a3      	str	r3, [r4, #88]	@ 0x58
    return HAL_ERROR;
 c03dc58:	2001      	movs	r0, #1
 c03dc5a:	e058      	b.n	c03dd0e <HAL_DMA_PollForTransfer+0xec>
  level_flag = ((CompleteLevel == HAL_DMA_FULL_TRANSFER) ? DMA_FLAG_IDLE : DMA_FLAG_HT);
 c03dc5c:	2d00      	cmp	r5, #0
 c03dc5e:	bf0c      	ite	eq
 c03dc60:	f04f 0801 	moveq.w	r8, #1
 c03dc64:	f44f 7800 	movne.w	r8, #512	@ 0x200
    tmp_csr = hdma->Instance->CSR;
 c03dc68:	6823      	ldr	r3, [r4, #0]
 c03dc6a:	691b      	ldr	r3, [r3, #16]
  while ((tmp_csr & level_flag) == 0U)
 c03dc6c:	ea13 0f08 	tst.w	r3, r8
 c03dc70:	d035      	beq.n	c03dcde <HAL_DMA_PollForTransfer+0xbc>
  if ((tmp_csr & DMA_FLAG_TO) != 0U)
 c03dc72:	045f      	lsls	r7, r3, #17
 c03dc74:	d507      	bpl.n	c03dc86 <HAL_DMA_PollForTransfer+0x64>
    __HAL_DMA_CLEAR_FLAG(hdma, DMA_FLAG_TO);
 c03dc76:	f44f 4180 	mov.w	r1, #16384	@ 0x4000
    hdma->ErrorCode |= HAL_DMA_ERROR_TO;
 c03dc7a:	6da2      	ldr	r2, [r4, #88]	@ 0x58
 c03dc7c:	f042 0208 	orr.w	r2, r2, #8
 c03dc80:	65a2      	str	r2, [r4, #88]	@ 0x58
    __HAL_DMA_CLEAR_FLAG(hdma, DMA_FLAG_TO);
 c03dc82:	6822      	ldr	r2, [r4, #0]
 c03dc84:	60d1      	str	r1, [r2, #12]
  if ((tmp_csr & (DMA_FLAG_DTE | DMA_FLAG_ULE | DMA_FLAG_USE)) != 0U)
 c03dc86:	f413 5fe0 	tst.w	r3, #7168	@ 0x1c00
 c03dc8a:	d039      	beq.n	c03dd00 <HAL_DMA_PollForTransfer+0xde>
    if ((tmp_csr & DMA_FLAG_DTE) != 0U)
 c03dc8c:	055e      	lsls	r6, r3, #21
      __HAL_DMA_CLEAR_FLAG(hdma, DMA_FLAG_DTE);
 c03dc8e:	6822      	ldr	r2, [r4, #0]
    if ((tmp_csr & DMA_FLAG_DTE) != 0U)
 c03dc90:	d506      	bpl.n	c03dca0 <HAL_DMA_PollForTransfer+0x7e>
      hdma->ErrorCode |= HAL_DMA_ERROR_DTE;
 c03dc92:	6da1      	ldr	r1, [r4, #88]	@ 0x58
 c03dc94:	f041 0101 	orr.w	r1, r1, #1
 c03dc98:	65a1      	str	r1, [r4, #88]	@ 0x58
      __HAL_DMA_CLEAR_FLAG(hdma, DMA_FLAG_DTE);
 c03dc9a:	f44f 6180 	mov.w	r1, #1024	@ 0x400
 c03dc9e:	60d1      	str	r1, [r2, #12]
    if ((tmp_csr & DMA_FLAG_ULE) != 0U)
 c03dca0:	051d      	lsls	r5, r3, #20
 c03dca2:	d506      	bpl.n	c03dcb2 <HAL_DMA_PollForTransfer+0x90>
      hdma->ErrorCode |= HAL_DMA_ERROR_ULE;
 c03dca4:	6da1      	ldr	r1, [r4, #88]	@ 0x58
 c03dca6:	f041 0102 	orr.w	r1, r1, #2
 c03dcaa:	65a1      	str	r1, [r4, #88]	@ 0x58
      __HAL_DMA_CLEAR_FLAG(hdma, DMA_FLAG_ULE);
 c03dcac:	f44f 6100 	mov.w	r1, #2048	@ 0x800
 c03dcb0:	60d1      	str	r1, [r2, #12]
    if ((tmp_csr & DMA_FLAG_USE) != 0U)
 c03dcb2:	04d8      	lsls	r0, r3, #19
 c03dcb4:	d506      	bpl.n	c03dcc4 <HAL_DMA_PollForTransfer+0xa2>
      hdma->ErrorCode |= HAL_DMA_ERROR_USE;
 c03dcb6:	6da3      	ldr	r3, [r4, #88]	@ 0x58
 c03dcb8:	f043 0304 	orr.w	r3, r3, #4
 c03dcbc:	65a3      	str	r3, [r4, #88]	@ 0x58
      __HAL_DMA_CLEAR_FLAG(hdma, DMA_FLAG_USE);
 c03dcbe:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
 c03dcc2:	60d3      	str	r3, [r2, #12]
    hdma->Instance->CCR |= DMA_CCR_RESET;
 c03dcc4:	6953      	ldr	r3, [r2, #20]
 c03dcc6:	f043 0302 	orr.w	r3, r3, #2
 c03dcca:	6153      	str	r3, [r2, #20]
    hdma->State = HAL_DMA_STATE_READY;
 c03dccc:	2301      	movs	r3, #1
    if ((hdma->Mode & DMA_LINKEDLIST) == DMA_LINKEDLIST)
 c03dcce:	6d22      	ldr	r2, [r4, #80]	@ 0x50
    hdma->State = HAL_DMA_STATE_READY;
 c03dcd0:	f884 3054 	strb.w	r3, [r4, #84]	@ 0x54
    if ((hdma->Mode & DMA_LINKEDLIST) == DMA_LINKEDLIST)
 c03dcd4:	0611      	lsls	r1, r2, #24
      hdma->LinkedListQueue->State = HAL_DMA_QUEUE_STATE_READY;
 c03dcd6:	bf44      	itt	mi
 c03dcd8:	6f62      	ldrmi	r2, [r4, #116]	@ 0x74
 c03dcda:	7313      	strbmi	r3, [r2, #12]
 c03dcdc:	e7b0      	b.n	c03dc40 <HAL_DMA_PollForTransfer+0x1e>
    if (Timeout != HAL_MAX_DELAY)
 c03dcde:	1c73      	adds	r3, r6, #1
 c03dce0:	d0c2      	beq.n	c03dc68 <HAL_DMA_PollForTransfer+0x46>
      if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
 c03dce2:	f006 f801 	bl	c043ce8 <HAL_GetTick>
 c03dce6:	1bc0      	subs	r0, r0, r7
 c03dce8:	42b0      	cmp	r0, r6
 c03dcea:	d801      	bhi.n	c03dcf0 <HAL_DMA_PollForTransfer+0xce>
 c03dcec:	2e00      	cmp	r6, #0
 c03dcee:	d1bb      	bne.n	c03dc68 <HAL_DMA_PollForTransfer+0x46>
        hdma->ErrorCode |= HAL_DMA_ERROR_TIMEOUT;
 c03dcf0:	6da3      	ldr	r3, [r4, #88]	@ 0x58
        (void)HAL_DMA_Abort(hdma);
 c03dcf2:	4620      	mov	r0, r4
        hdma->ErrorCode |= HAL_DMA_ERROR_TIMEOUT;
 c03dcf4:	f043 0310 	orr.w	r3, r3, #16
 c03dcf8:	65a3      	str	r3, [r4, #88]	@ 0x58
        (void)HAL_DMA_Abort(hdma);
 c03dcfa:	f7ff ff48 	bl	c03db8e <HAL_DMA_Abort>
        return HAL_ERROR;
 c03dcfe:	e7ab      	b.n	c03dc58 <HAL_DMA_PollForTransfer+0x36>
  if (CompleteLevel == HAL_DMA_HALF_TRANSFER)
 c03dd00:	2d01      	cmp	r5, #1
 c03dd02:	d106      	bne.n	c03dd12 <HAL_DMA_PollForTransfer+0xf0>
    __HAL_DMA_CLEAR_FLAG(hdma, DMA_FLAG_HT);
 c03dd04:	f44f 7200 	mov.w	r2, #512	@ 0x200
 c03dd08:	6823      	ldr	r3, [r4, #0]
 c03dd0a:	60da      	str	r2, [r3, #12]
  return HAL_OK;
 c03dd0c:	2000      	movs	r0, #0
}
 c03dd0e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  else if (CompleteLevel == HAL_DMA_FULL_TRANSFER)
 c03dd12:	2d00      	cmp	r5, #0
 c03dd14:	d1a0      	bne.n	c03dc58 <HAL_DMA_PollForTransfer+0x36>
    __HAL_DMA_CLEAR_FLAG(hdma, (DMA_FLAG_TC | DMA_FLAG_HT));
 c03dd16:	f44f 7240 	mov.w	r2, #768	@ 0x300
 c03dd1a:	6823      	ldr	r3, [r4, #0]
 c03dd1c:	60da      	str	r2, [r3, #12]
    hdma->State = HAL_DMA_STATE_READY;
 c03dd1e:	2301      	movs	r3, #1
    if ((hdma->Mode & DMA_LINKEDLIST) == DMA_LINKEDLIST)
 c03dd20:	6d22      	ldr	r2, [r4, #80]	@ 0x50
    hdma->State = HAL_DMA_STATE_READY;
 c03dd22:	f884 3054 	strb.w	r3, [r4, #84]	@ 0x54
    if ((hdma->Mode & DMA_LINKEDLIST) == DMA_LINKEDLIST)
 c03dd26:	0612      	lsls	r2, r2, #24
      hdma->LinkedListQueue->State = HAL_DMA_QUEUE_STATE_READY;
 c03dd28:	bf44      	itt	mi
 c03dd2a:	6f62      	ldrmi	r2, [r4, #116]	@ 0x74
 c03dd2c:	7313      	strbmi	r3, [r2, #12]
    __HAL_UNLOCK(hdma);
 c03dd2e:	2300      	movs	r3, #0
 c03dd30:	f884 304c 	strb.w	r3, [r4, #76]	@ 0x4c
 c03dd34:	e7ea      	b.n	c03dd0c <HAL_DMA_PollForTransfer+0xea>

0c03dd36 <HAL_DMA_ConfigChannelAttributes>:
{
 c03dd36:	b510      	push	{r4, lr}
  if (hdma == NULL)
 c03dd38:	2800      	cmp	r0, #0
 c03dd3a:	d03b      	beq.n	c03ddb4 <HAL_DMA_ConfigChannelAttributes+0x7e>
  p_dma_instance = GET_DMA_INSTANCE(hdma);
 c03dd3c:	6803      	ldr	r3, [r0, #0]
  channel_idx = 1UL << (GET_DMA_CHANNEL(hdma) & 0x1FU);
 c03dd3e:	2001      	movs	r0, #1
 c03dd40:	f3c3 040b 	ubfx	r4, r3, #0, #12
 c03dd44:	3c50      	subs	r4, #80	@ 0x50
 c03dd46:	f3c4 14c4 	ubfx	r4, r4, #7, #5
  p_dma_instance = GET_DMA_INSTANCE(hdma);
 c03dd4a:	f423 627f 	bic.w	r2, r3, #4080	@ 0xff0
  channel_idx = 1UL << (GET_DMA_CHANNEL(hdma) & 0x1FU);
 c03dd4e:	40a0      	lsls	r0, r4
  if ((ChannelAttributes & DMA_CHANNEL_ATTR_PRIV_MASK) == DMA_CHANNEL_ATTR_PRIV_MASK)
 c03dd50:	06cc      	lsls	r4, r1, #27
  p_dma_instance = GET_DMA_INSTANCE(hdma);
 c03dd52:	f022 020f 	bic.w	r2, r2, #15
  if ((ChannelAttributes & DMA_CHANNEL_ATTR_PRIV_MASK) == DMA_CHANNEL_ATTR_PRIV_MASK)
 c03dd56:	d507      	bpl.n	c03dd68 <HAL_DMA_ConfigChannelAttributes+0x32>
    if ((ChannelAttributes & DMA_CHANNEL_PRIV) == DMA_CHANNEL_PRIV)
 c03dd58:	f001 0411 	and.w	r4, r1, #17
 c03dd5c:	2c11      	cmp	r4, #17
      p_dma_instance->PRIVCFGR |= channel_idx;
 c03dd5e:	6854      	ldr	r4, [r2, #4]
 c03dd60:	bf0c      	ite	eq
 c03dd62:	4304      	orreq	r4, r0
      p_dma_instance->PRIVCFGR &= (~channel_idx);
 c03dd64:	4384      	bicne	r4, r0
 c03dd66:	6054      	str	r4, [r2, #4]
  if ((ChannelAttributes & DMA_CHANNEL_ATTR_SEC_MASK) == DMA_CHANNEL_ATTR_SEC_MASK)
 c03dd68:	068c      	lsls	r4, r1, #26
 c03dd6a:	d508      	bpl.n	c03dd7e <HAL_DMA_ConfigChannelAttributes+0x48>
    if ((ChannelAttributes & DMA_CHANNEL_SEC) == DMA_CHANNEL_SEC)
 c03dd6c:	f001 0422 	and.w	r4, r1, #34	@ 0x22
 c03dd70:	2c22      	cmp	r4, #34	@ 0x22
      p_dma_instance->SECCFGR |= channel_idx;
 c03dd72:	6814      	ldr	r4, [r2, #0]
 c03dd74:	bf0c      	ite	eq
 c03dd76:	4320      	orreq	r0, r4
      p_dma_instance->SECCFGR &= (~channel_idx);
 c03dd78:	ea24 0000 	bicne.w	r0, r4, r0
 c03dd7c:	6010      	str	r0, [r2, #0]
  if ((ChannelAttributes & DMA_CHANNEL_ATTR_SEC_SRC_MASK) == DMA_CHANNEL_ATTR_SEC_SRC_MASK)
 c03dd7e:	0648      	lsls	r0, r1, #25
 c03dd80:	d509      	bpl.n	c03dd96 <HAL_DMA_ConfigChannelAttributes+0x60>
    if ((ChannelAttributes & DMA_CHANNEL_SRC_SEC) == DMA_CHANNEL_SRC_SEC)
 c03dd82:	f001 0244 	and.w	r2, r1, #68	@ 0x44
 c03dd86:	2a44      	cmp	r2, #68	@ 0x44
      hdma->Instance->CTR1 |= DMA_CTR1_SSEC;
 c03dd88:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
 c03dd8a:	bf0c      	ite	eq
 c03dd8c:	f442 4200 	orreq.w	r2, r2, #32768	@ 0x8000
      hdma->Instance->CTR1 &= (~DMA_CTR1_SSEC);
 c03dd90:	f422 4200 	bicne.w	r2, r2, #32768	@ 0x8000
 c03dd94:	641a      	str	r2, [r3, #64]	@ 0x40
  if ((ChannelAttributes & DMA_CHANNEL_ATTR_SEC_DEST_MASK) == DMA_CHANNEL_ATTR_SEC_DEST_MASK)
 c03dd96:	060a      	lsls	r2, r1, #24
 c03dd98:	d401      	bmi.n	c03dd9e <HAL_DMA_ConfigChannelAttributes+0x68>
  return HAL_OK;
 c03dd9a:	2000      	movs	r0, #0
}
 c03dd9c:	bd10      	pop	{r4, pc}
      hdma->Instance->CTR1 |= DMA_CTR1_DSEC;
 c03dd9e:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
    if ((ChannelAttributes & DMA_CHANNEL_DEST_SEC) == DMA_CHANNEL_DEST_SEC)
 c03dda0:	f001 0188 	and.w	r1, r1, #136	@ 0x88
 c03dda4:	2988      	cmp	r1, #136	@ 0x88
      hdma->Instance->CTR1 |= DMA_CTR1_DSEC;
 c03dda6:	bf0c      	ite	eq
 c03dda8:	f042 4200 	orreq.w	r2, r2, #2147483648	@ 0x80000000
      hdma->Instance->CTR1 &= (~DMA_CTR1_DSEC);
 c03ddac:	f022 4200 	bicne.w	r2, r2, #2147483648	@ 0x80000000
 c03ddb0:	641a      	str	r2, [r3, #64]	@ 0x40
 c03ddb2:	e7f2      	b.n	c03dd9a <HAL_DMA_ConfigChannelAttributes+0x64>
    return HAL_ERROR;
 c03ddb4:	2001      	movs	r0, #1
 c03ddb6:	e7f1      	b.n	c03dd9c <HAL_DMA_ConfigChannelAttributes+0x66>

0c03ddb8 <FLASH_Program_QuadWord>:

  /* Check the parameters */
  assert_param(IS_FLASH_PROGRAM_ADDRESS(Address));

  /* Access to SECCR or NSCR registers depends on operation type */
  reg_cr = IS_FLASH_SECURE_OPERATION() ? &(FLASH->SECCR) : &(FLASH_NS->NSCR);
 c03ddb8:	4b0c      	ldr	r3, [pc, #48]	@ (c03ddec <FLASH_Program_QuadWord+0x34>)
{
 c03ddba:	b510      	push	{r4, lr}
  reg_cr = IS_FLASH_SECURE_OPERATION() ? &(FLASH->SECCR) : &(FLASH_NS->NSCR);
 c03ddbc:	4a0c      	ldr	r2, [pc, #48]	@ (c03ddf0 <FLASH_Program_QuadWord+0x38>)
 c03ddbe:	689c      	ldr	r4, [r3, #8]
 c03ddc0:	4b0c      	ldr	r3, [pc, #48]	@ (c03ddf4 <FLASH_Program_QuadWord+0x3c>)
 c03ddc2:	ea13 0324 	ands.w	r3, r3, r4, asr #32
 c03ddc6:	bf38      	it	cc
 c03ddc8:	4613      	movcc	r3, r2

  /* Set PG bit */
  SET_BIT((*reg_cr), FLASH_NSCR_PG);
 c03ddca:	681a      	ldr	r2, [r3, #0]
 c03ddcc:	f042 0201 	orr.w	r2, r2, #1
 c03ddd0:	601a      	str	r2, [r3, #0]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 c03ddd2:	f3ef 8210 	mrs	r2, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 c03ddd6:	b672      	cpsid	i
}
 c03ddd8:	2300      	movs	r3, #0
  __disable_irq();

  /* Program the quad-word */
  do
  {
    *dest_addr = *src_addr;
 c03ddda:	58cc      	ldr	r4, [r1, r3]
 c03dddc:	50c4      	str	r4, [r0, r3]
    dest_addr++;
    src_addr++;
    index--;
  } while (index != 0U);
 c03ddde:	3304      	adds	r3, #4
 c03dde0:	2b10      	cmp	r3, #16
 c03dde2:	d1fa      	bne.n	c03ddda <FLASH_Program_QuadWord+0x22>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 c03dde4:	f382 8810 	msr	PRIMASK, r2

  /* Exit critical section: restore previous priority mask */
  __set_PRIMASK(primask_bit);
}
 c03dde8:	bd10      	pop	{r4, pc}
 c03ddea:	bf00      	nop
 c03ddec:	300308ec 	.word	0x300308ec
 c03ddf0:	5002202c 	.word	0x5002202c
 c03ddf4:	40022028 	.word	0x40022028

0c03ddf8 <FLASH_Program_Burst>:

  /* Check the parameters */
  assert_param(IS_FLASH_MAIN_MEM_ADDRESS(Address));

  /* Access to SECCR or NSCR registers depends on operation type */
  reg_cr = IS_FLASH_SECURE_OPERATION() ? &(FLASH->SECCR) : &(FLASH_NS->NSCR);
 c03ddf8:	4b0d      	ldr	r3, [pc, #52]	@ (c03de30 <FLASH_Program_Burst+0x38>)
{
 c03ddfa:	b510      	push	{r4, lr}
  reg_cr = IS_FLASH_SECURE_OPERATION() ? &(FLASH->SECCR) : &(FLASH_NS->NSCR);
 c03ddfc:	4a0d      	ldr	r2, [pc, #52]	@ (c03de34 <FLASH_Program_Burst+0x3c>)
 c03ddfe:	689c      	ldr	r4, [r3, #8]
 c03de00:	4b0d      	ldr	r3, [pc, #52]	@ (c03de38 <FLASH_Program_Burst+0x40>)
 c03de02:	ea12 0224 	ands.w	r2, r2, r4, asr #32
 c03de06:	bf38      	it	cc
 c03de08:	461a      	movcc	r2, r3

  /* Set PG and BWR bits */
  SET_BIT((*reg_cr), (FLASH_NSCR_PG | FLASH_NSCR_BWR));
 c03de0a:	6813      	ldr	r3, [r2, #0]
 c03de0c:	f443 4380 	orr.w	r3, r3, #16384	@ 0x4000
 c03de10:	f043 0301 	orr.w	r3, r3, #1
 c03de14:	6013      	str	r3, [r2, #0]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 c03de16:	f3ef 8210 	mrs	r2, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 c03de1a:	b672      	cpsid	i
}
 c03de1c:	2300      	movs	r3, #0
  __disable_irq();

  /* Program the burst */
  do
  {
    *dest_addr = *src_addr;
 c03de1e:	58cc      	ldr	r4, [r1, r3]
 c03de20:	50c4      	str	r4, [r0, r3]
    dest_addr++;
    src_addr++;
    burst_index--;
  } while (burst_index != 0U);
 c03de22:	3304      	adds	r3, #4
 c03de24:	2b80      	cmp	r3, #128	@ 0x80
 c03de26:	d1fa      	bne.n	c03de1e <FLASH_Program_Burst+0x26>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 c03de28:	f382 8810 	msr	PRIMASK, r2

  /* Exit critical section: restore previous priority mask */
  __set_PRIMASK(primask_bit);
}
 c03de2c:	bd10      	pop	{r4, pc}
 c03de2e:	bf00      	nop
 c03de30:	300308ec 	.word	0x300308ec
 c03de34:	40022028 	.word	0x40022028
 c03de38:	5002202c 	.word	0x5002202c

0c03de3c <HAL_FLASH_Unlock>:
  if (READ_BIT(FLASH->NSCR, FLASH_NSCR_LOCK) != 0U)
 c03de3c:	4b0d      	ldr	r3, [pc, #52]	@ (c03de74 <HAL_FLASH_Unlock+0x38>)
 c03de3e:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
 c03de40:	2a00      	cmp	r2, #0
 c03de42:	db04      	blt.n	c03de4e <HAL_FLASH_Unlock+0x12>
    if (READ_BIT(FLASH->SECCR, FLASH_SECCR_LOCK) != 0U)
 c03de44:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 c03de46:	2a00      	cmp	r2, #0
 c03de48:	db0b      	blt.n	c03de62 <HAL_FLASH_Unlock+0x26>
 c03de4a:	2000      	movs	r0, #0
 c03de4c:	4770      	bx	lr
    WRITE_REG(FLASH->NSKEYR, FLASH_KEY1);
 c03de4e:	4a0a      	ldr	r2, [pc, #40]	@ (c03de78 <HAL_FLASH_Unlock+0x3c>)
 c03de50:	609a      	str	r2, [r3, #8]
    WRITE_REG(FLASH->NSKEYR, FLASH_KEY2);
 c03de52:	f102 3288 	add.w	r2, r2, #2290649224	@ 0x88888888
 c03de56:	609a      	str	r2, [r3, #8]
    if (READ_BIT(FLASH->NSCR, FLASH_NSCR_LOCK) != 0U)
 c03de58:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
 c03de5a:	2a00      	cmp	r2, #0
 c03de5c:	daf2      	bge.n	c03de44 <HAL_FLASH_Unlock+0x8>
      status = HAL_ERROR;
 c03de5e:	2001      	movs	r0, #1
}
 c03de60:	4770      	bx	lr
      WRITE_REG(FLASH->SECKEYR, FLASH_KEY1);
 c03de62:	4a05      	ldr	r2, [pc, #20]	@ (c03de78 <HAL_FLASH_Unlock+0x3c>)
 c03de64:	60da      	str	r2, [r3, #12]
      WRITE_REG(FLASH->SECKEYR, FLASH_KEY2);
 c03de66:	f102 3288 	add.w	r2, r2, #2290649224	@ 0x88888888
 c03de6a:	60da      	str	r2, [r3, #12]
      if (READ_BIT(FLASH->SECCR, FLASH_SECCR_LOCK) != 0U)
 c03de6c:	6ad8      	ldr	r0, [r3, #44]	@ 0x2c
 c03de6e:	0fc0      	lsrs	r0, r0, #31
 c03de70:	4770      	bx	lr
 c03de72:	bf00      	nop
 c03de74:	50022000 	.word	0x50022000
 c03de78:	45670123 	.word	0x45670123

0c03de7c <HAL_FLASH_Lock>:
  SET_BIT(FLASH->NSCR, FLASH_NSCR_LOCK);
 c03de7c:	4b08      	ldr	r3, [pc, #32]	@ (c03dea0 <HAL_FLASH_Lock+0x24>)
 c03de7e:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
 c03de80:	f042 4200 	orr.w	r2, r2, #2147483648	@ 0x80000000
 c03de84:	629a      	str	r2, [r3, #40]	@ 0x28
  if (READ_BIT(FLASH->NSCR, FLASH_NSCR_LOCK) != 0U)
 c03de86:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
 c03de88:	2a00      	cmp	r2, #0
    SET_BIT(FLASH->SECCR, FLASH_SECCR_LOCK);
 c03de8a:	bfbf      	itttt	lt
 c03de8c:	6ada      	ldrlt	r2, [r3, #44]	@ 0x2c
    status = HAL_OK;
 c03de8e:	2000      	movlt	r0, #0
    SET_BIT(FLASH->SECCR, FLASH_SECCR_LOCK);
 c03de90:	f042 4200 	orrlt.w	r2, r2, #2147483648	@ 0x80000000
 c03de94:	62da      	strlt	r2, [r3, #44]	@ 0x2c
  HAL_StatusTypeDef status = HAL_ERROR;
 c03de96:	bfac      	ite	ge
 c03de98:	2001      	movge	r0, #1
    if (READ_BIT(FLASH->SECCR, FLASH_SECCR_LOCK) != 0U)
 c03de9a:	6adb      	ldrlt	r3, [r3, #44]	@ 0x2c
}
 c03de9c:	4770      	bx	lr
 c03de9e:	bf00      	nop
 c03dea0:	50022000 	.word	0x50022000

0c03dea4 <HAL_FLASH_GetError>:
}
 c03dea4:	4b01      	ldr	r3, [pc, #4]	@ (c03deac <HAL_FLASH_GetError+0x8>)
 c03dea6:	6858      	ldr	r0, [r3, #4]
 c03dea8:	4770      	bx	lr
 c03deaa:	bf00      	nop
 c03deac:	300308ec 	.word	0x300308ec

0c03deb0 <FLASH_WaitForLastOperation>:
{
 c03deb0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  reg_sr = IS_FLASH_SECURE_OPERATION() ? &(FLASH->SECSR) : &(FLASH_NS->NSSR);
 c03deb2:	4e1a      	ldr	r6, [pc, #104]	@ (c03df1c <FLASH_WaitForLastOperation+0x6c>)
{
 c03deb4:	4605      	mov	r5, r0
  reg_sr = IS_FLASH_SECURE_OPERATION() ? &(FLASH->SECSR) : &(FLASH_NS->NSSR);
 c03deb6:	4c1a      	ldr	r4, [pc, #104]	@ (c03df20 <FLASH_WaitForLastOperation+0x70>)
  uint32_t timeout = HAL_GetTick() + Timeout;
 c03deb8:	f005 ff16 	bl	c043ce8 <HAL_GetTick>
  reg_sr = IS_FLASH_SECURE_OPERATION() ? &(FLASH->SECSR) : &(FLASH_NS->NSSR);
 c03debc:	68b2      	ldr	r2, [r6, #8]
 c03debe:	4b19      	ldr	r3, [pc, #100]	@ (c03df24 <FLASH_WaitForLastOperation+0x74>)
  uint32_t timeout = HAL_GetTick() + Timeout;
 c03dec0:	1947      	adds	r7, r0, r5
  reg_sr = IS_FLASH_SECURE_OPERATION() ? &(FLASH->SECSR) : &(FLASH_NS->NSSR);
 c03dec2:	ea14 0422 	ands.w	r4, r4, r2, asr #32
 c03dec6:	bf38      	it	cc
 c03dec8:	461c      	movcc	r4, r3
  while (((*reg_sr) & (FLASH_FLAG_BSY | FLASH_FLAG_WDW)) != 0U)
 c03deca:	6823      	ldr	r3, [r4, #0]
 c03decc:	f413 3f40 	tst.w	r3, #196608	@ 0x30000
 c03ded0:	d113      	bne.n	c03defa <FLASH_WaitForLastOperation+0x4a>
  error |= (FLASH->NSSR & FLASH_FLAG_OPTWERR);
 c03ded2:	4915      	ldr	r1, [pc, #84]	@ (c03df28 <FLASH_WaitForLastOperation+0x78>)
  error = ((*reg_sr) & FLASH_FLAG_SR_ERRORS);
 c03ded4:	6822      	ldr	r2, [r4, #0]
  error |= (FLASH->NSSR & FLASH_FLAG_OPTWERR);
 c03ded6:	6a0b      	ldr	r3, [r1, #32]
  error = ((*reg_sr) & FLASH_FLAG_SR_ERRORS);
 c03ded8:	f002 02fa 	and.w	r2, r2, #250	@ 0xfa
  error |= (FLASH->NSSR & FLASH_FLAG_OPTWERR);
 c03dedc:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
  if (error != 0U)
 c03dee0:	4313      	orrs	r3, r2
 c03dee2:	d012      	beq.n	c03df0a <FLASH_WaitForLastOperation+0x5a>
    pFlash.ErrorCode |= error;
 c03dee4:	6872      	ldr	r2, [r6, #4]
 c03dee6:	431a      	orrs	r2, r3
 c03dee8:	6072      	str	r2, [r6, #4]
    if ((error & FLASH_FLAG_OPTWERR) != 0U)
 c03deea:	049a      	lsls	r2, r3, #18
    (*reg_sr) = error;
 c03deec:	6023      	str	r3, [r4, #0]
    if ((error & FLASH_FLAG_OPTWERR) != 0U)
 c03deee:	d502      	bpl.n	c03def6 <FLASH_WaitForLastOperation+0x46>
      FLASH->NSSR = FLASH_FLAG_OPTWERR;
 c03def0:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
 c03def4:	620b      	str	r3, [r1, #32]
    return HAL_ERROR;
 c03def6:	2001      	movs	r0, #1
 c03def8:	e00b      	b.n	c03df12 <FLASH_WaitForLastOperation+0x62>
    if (Timeout != HAL_MAX_DELAY)
 c03defa:	1c69      	adds	r1, r5, #1
 c03defc:	d0e5      	beq.n	c03deca <FLASH_WaitForLastOperation+0x1a>
      if (HAL_GetTick() >= timeout)
 c03defe:	f005 fef3 	bl	c043ce8 <HAL_GetTick>
 c03df02:	42b8      	cmp	r0, r7
 c03df04:	d3e1      	bcc.n	c03deca <FLASH_WaitForLastOperation+0x1a>
        return HAL_TIMEOUT;
 c03df06:	2003      	movs	r0, #3
 c03df08:	e003      	b.n	c03df12 <FLASH_WaitForLastOperation+0x62>
  if (((*reg_sr) & FLASH_FLAG_EOP) != 0U)
 c03df0a:	6823      	ldr	r3, [r4, #0]
 c03df0c:	07db      	lsls	r3, r3, #31
 c03df0e:	d401      	bmi.n	c03df14 <FLASH_WaitForLastOperation+0x64>
  return HAL_OK;
 c03df10:	2000      	movs	r0, #0
}
 c03df12:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    (*reg_sr) = FLASH_FLAG_EOP;
 c03df14:	2301      	movs	r3, #1
 c03df16:	6023      	str	r3, [r4, #0]
 c03df18:	e7fa      	b.n	c03df10 <FLASH_WaitForLastOperation+0x60>
 c03df1a:	bf00      	nop
 c03df1c:	300308ec 	.word	0x300308ec
 c03df20:	40022020 	.word	0x40022020
 c03df24:	50022024 	.word	0x50022024
 c03df28:	50022000 	.word	0x50022000

0c03df2c <HAL_FLASH_Program>:
{
 c03df2c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  __HAL_LOCK(&pFlash);
 c03df30:	4d17      	ldr	r5, [pc, #92]	@ (c03df90 <HAL_FLASH_Program+0x64>)
{
 c03df32:	4604      	mov	r4, r0
  __HAL_LOCK(&pFlash);
 c03df34:	782b      	ldrb	r3, [r5, #0]
{
 c03df36:	460f      	mov	r7, r1
  __HAL_LOCK(&pFlash);
 c03df38:	2b01      	cmp	r3, #1
{
 c03df3a:	4690      	mov	r8, r2
  __HAL_LOCK(&pFlash);
 c03df3c:	d026      	beq.n	c03df8c <HAL_FLASH_Program+0x60>
 c03df3e:	2301      	movs	r3, #1
 c03df40:	702b      	strb	r3, [r5, #0]
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 c03df42:	2300      	movs	r3, #0
  status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 c03df44:	f44f 707a 	mov.w	r0, #1000	@ 0x3e8
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 c03df48:	606b      	str	r3, [r5, #4]
  status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 c03df4a:	f7ff ffb1 	bl	c03deb0 <FLASH_WaitForLastOperation>
  if (status == HAL_OK)
 c03df4e:	b9b0      	cbnz	r0, c03df7e <HAL_FLASH_Program+0x52>
    reg_cr = IS_FLASH_SECURE_OPERATION() ? &(FLASH->SECCR) : &(FLASH_NS->NSCR);
 c03df50:	4e10      	ldr	r6, [pc, #64]	@ (c03df94 <HAL_FLASH_Program+0x68>)
 c03df52:	4b11      	ldr	r3, [pc, #68]	@ (c03df98 <HAL_FLASH_Program+0x6c>)
    pFlash.ProcedureOnGoing = TypeProgram;
 c03df54:	60ac      	str	r4, [r5, #8]
    reg_cr = IS_FLASH_SECURE_OPERATION() ? &(FLASH->SECCR) : &(FLASH_NS->NSCR);
 c03df56:	ea36 0624 	bics.w	r6, r6, r4, asr #32
 c03df5a:	bf28      	it	cs
 c03df5c:	461e      	movcs	r6, r3
    if ((TypeProgram & (~FLASH_NON_SECURE_MASK)) == FLASH_TYPEPROGRAM_QUADWORD)
 c03df5e:	f024 4400 	bic.w	r4, r4, #2147483648	@ 0x80000000
 c03df62:	2c01      	cmp	r4, #1
      FLASH_Program_QuadWord(Address, DataAddress);
 c03df64:	4641      	mov	r1, r8
 c03df66:	4638      	mov	r0, r7
    if ((TypeProgram & (~FLASH_NON_SECURE_MASK)) == FLASH_TYPEPROGRAM_QUADWORD)
 c03df68:	d10d      	bne.n	c03df86 <HAL_FLASH_Program+0x5a>
      FLASH_Program_QuadWord(Address, DataAddress);
 c03df6a:	f7ff ff25 	bl	c03ddb8 <FLASH_Program_QuadWord>
    status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 c03df6e:	f44f 707a 	mov.w	r0, #1000	@ 0x3e8
 c03df72:	f7ff ff9d 	bl	c03deb0 <FLASH_WaitForLastOperation>
    CLEAR_BIT((*reg_cr), (TypeProgram & ~(FLASH_NON_SECURE_MASK)));
 c03df76:	6833      	ldr	r3, [r6, #0]
 c03df78:	ea23 0304 	bic.w	r3, r3, r4
 c03df7c:	6033      	str	r3, [r6, #0]
  __HAL_UNLOCK(&pFlash);
 c03df7e:	2300      	movs	r3, #0
 c03df80:	702b      	strb	r3, [r5, #0]
}
 c03df82:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      FLASH_Program_Burst(Address, DataAddress);
 c03df86:	f7ff ff37 	bl	c03ddf8 <FLASH_Program_Burst>
 c03df8a:	e7f0      	b.n	c03df6e <HAL_FLASH_Program+0x42>
  __HAL_LOCK(&pFlash);
 c03df8c:	2002      	movs	r0, #2
 c03df8e:	e7f8      	b.n	c03df82 <HAL_FLASH_Program+0x56>
 c03df90:	300308ec 	.word	0x300308ec
 c03df94:	5002202c 	.word	0x5002202c
 c03df98:	40022028 	.word	0x40022028

0c03df9c <FLASH_MassErase>:

  /* Check the parameters */
  assert_param(IS_FLASH_BANK(Banks));

  /* Access to SECCR or NSCR registers depends on operation type */
  reg_cr = IS_FLASH_SECURE_OPERATION() ? &(FLASH->SECCR) : &(FLASH_NS->NSCR);
 c03df9c:	4b0b      	ldr	r3, [pc, #44]	@ (c03dfcc <FLASH_MassErase+0x30>)
 c03df9e:	4a0c      	ldr	r2, [pc, #48]	@ (c03dfd0 <FLASH_MassErase+0x34>)
 c03dfa0:	6899      	ldr	r1, [r3, #8]
 c03dfa2:	4b0c      	ldr	r3, [pc, #48]	@ (c03dfd4 <FLASH_MassErase+0x38>)
 c03dfa4:	ea13 0321 	ands.w	r3, r3, r1, asr #32
 c03dfa8:	bf38      	it	cc
 c03dfaa:	4613      	movcc	r3, r2

  /* Set the Mass Erase Bit for the bank 1 and proceed to erase */
  if ((Banks & FLASH_BANK_1) != 0U)
 c03dfac:	07c1      	lsls	r1, r0, #31
  {
    SET_BIT((*reg_cr), FLASH_NSCR_MER1 | FLASH_NSCR_STRT);
 c03dfae:	bf41      	itttt	mi
 c03dfb0:	681a      	ldrmi	r2, [r3, #0]
 c03dfb2:	f442 3280 	orrmi.w	r2, r2, #65536	@ 0x10000
 c03dfb6:	f042 0204 	orrmi.w	r2, r2, #4
 c03dfba:	601a      	strmi	r2, [r3, #0]
  }

  /* Set the Mass Erase Bit for the bank 2 and proceed to erase */
  if ((Banks & FLASH_BANK_2) != 0U)
 c03dfbc:	0782      	lsls	r2, r0, #30
  {
    SET_BIT((*reg_cr), FLASH_NSCR_MER2 | FLASH_NSCR_STRT);
 c03dfbe:	bf42      	ittt	mi
 c03dfc0:	681a      	ldrmi	r2, [r3, #0]
 c03dfc2:	f442 32c0 	orrmi.w	r2, r2, #98304	@ 0x18000
 c03dfc6:	601a      	strmi	r2, [r3, #0]
  }
}
 c03dfc8:	4770      	bx	lr
 c03dfca:	bf00      	nop
 c03dfcc:	300308ec 	.word	0x300308ec
 c03dfd0:	5002202c 	.word	0x5002202c
 c03dfd4:	40022028 	.word	0x40022028

0c03dfd8 <FLASH_PageErase>:
  /* Check the parameters */
  assert_param(IS_FLASH_PAGE(Page));
  assert_param(IS_FLASH_BANK_EXCLUSIVE(Banks));

  /* Access to SECCR or NSCR registers depends on operation type */
  reg_cr = IS_FLASH_SECURE_OPERATION() ? &(FLASH->SECCR) : &(FLASH_NS->NSCR);
 c03dfd8:	4b0e      	ldr	r3, [pc, #56]	@ (c03e014 <FLASH_PageErase+0x3c>)
{
 c03dfda:	b510      	push	{r4, lr}
  reg_cr = IS_FLASH_SECURE_OPERATION() ? &(FLASH->SECCR) : &(FLASH_NS->NSCR);
 c03dfdc:	4a0e      	ldr	r2, [pc, #56]	@ (c03e018 <FLASH_PageErase+0x40>)
 c03dfde:	689c      	ldr	r4, [r3, #8]
 c03dfe0:	4b0e      	ldr	r3, [pc, #56]	@ (c03e01c <FLASH_PageErase+0x44>)
 c03dfe2:	ea12 0224 	ands.w	r2, r2, r4, asr #32
 c03dfe6:	bf38      	it	cc
 c03dfe8:	461a      	movcc	r2, r3

  if ((Banks & FLASH_BANK_1) != 0U)
  {
    CLEAR_BIT((*reg_cr), FLASH_NSCR_BKER);
 c03dfea:	6813      	ldr	r3, [r2, #0]
  if ((Banks & FLASH_BANK_1) != 0U)
 c03dfec:	07c9      	lsls	r1, r1, #31
    CLEAR_BIT((*reg_cr), FLASH_NSCR_BKER);
 c03dfee:	bf4c      	ite	mi
 c03dff0:	f423 6300 	bicmi.w	r3, r3, #2048	@ 0x800
  }
  else
  {
    SET_BIT((*reg_cr), FLASH_NSCR_BKER);
 c03dff4:	f443 6300 	orrpl.w	r3, r3, #2048	@ 0x800
 c03dff8:	6013      	str	r3, [r2, #0]
  }

  /* Proceed to erase the page */
  MODIFY_REG((*reg_cr), (FLASH_NSCR_PNB | FLASH_NSCR_PER | FLASH_NSCR_STRT), \
 c03dffa:	6813      	ldr	r3, [r2, #0]
 c03dffc:	f423 3381 	bic.w	r3, r3, #66048	@ 0x10200
 c03e000:	f423 73fd 	bic.w	r3, r3, #506	@ 0x1fa
 c03e004:	ea43 00c0 	orr.w	r0, r3, r0, lsl #3
 c03e008:	f440 3080 	orr.w	r0, r0, #65536	@ 0x10000
 c03e00c:	f040 0002 	orr.w	r0, r0, #2
 c03e010:	6010      	str	r0, [r2, #0]
             ((Page << FLASH_NSCR_PNB_Pos) | FLASH_NSCR_PER | FLASH_NSCR_STRT));
}
 c03e012:	bd10      	pop	{r4, pc}
 c03e014:	300308ec 	.word	0x300308ec
 c03e018:	40022028 	.word	0x40022028
 c03e01c:	5002202c 	.word	0x5002202c

0c03e020 <HAL_FLASHEx_Erase>:
{
 c03e020:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  __HAL_LOCK(&pFlash);
 c03e024:	4e26      	ldr	r6, [pc, #152]	@ (c03e0c0 <HAL_FLASHEx_Erase+0xa0>)
{
 c03e026:	4605      	mov	r5, r0
  __HAL_LOCK(&pFlash);
 c03e028:	7833      	ldrb	r3, [r6, #0]
{
 c03e02a:	4689      	mov	r9, r1
  __HAL_LOCK(&pFlash);
 c03e02c:	2b01      	cmp	r3, #1
 c03e02e:	d045      	beq.n	c03e0bc <HAL_FLASHEx_Erase+0x9c>
 c03e030:	2301      	movs	r3, #1
 c03e032:	7033      	strb	r3, [r6, #0]
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 c03e034:	2300      	movs	r3, #0
  status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 c03e036:	f44f 707a 	mov.w	r0, #1000	@ 0x3e8
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 c03e03a:	6073      	str	r3, [r6, #4]
  status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 c03e03c:	f7ff ff38 	bl	c03deb0 <FLASH_WaitForLastOperation>
  if (status == HAL_OK)
 c03e040:	4604      	mov	r4, r0
 c03e042:	b9f0      	cbnz	r0, c03e082 <HAL_FLASHEx_Erase+0x62>
    pFlash.ProcedureOnGoing = pEraseInit->TypeErase;
 c03e044:	682b      	ldr	r3, [r5, #0]
    reg_cr = IS_FLASH_SECURE_OPERATION() ? &(FLASH->SECCR) : &(FLASH->NSCR);
 c03e046:	4a1f      	ldr	r2, [pc, #124]	@ (c03e0c4 <HAL_FLASHEx_Erase+0xa4>)
 c03e048:	491f      	ldr	r1, [pc, #124]	@ (c03e0c8 <HAL_FLASHEx_Erase+0xa8>)
    pFlash.ProcedureOnGoing = pEraseInit->TypeErase;
 c03e04a:	60b3      	str	r3, [r6, #8]
    reg_cr = IS_FLASH_SECURE_OPERATION() ? &(FLASH->SECCR) : &(FLASH->NSCR);
 c03e04c:	ea31 0823 	bics.w	r8, r1, r3, asr #32
 c03e050:	bf28      	it	cs
 c03e052:	4690      	movcs	r8, r2
    if ((pEraseInit->TypeErase & (~FLASH_NON_SECURE_MASK)) == FLASH_TYPEERASE_MASSERASE)
 c03e054:	f248 0204 	movw	r2, #32772	@ 0x8004
 c03e058:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
 c03e05c:	4293      	cmp	r3, r2
 c03e05e:	d115      	bne.n	c03e08c <HAL_FLASHEx_Erase+0x6c>
      FLASH_MassErase(pEraseInit->Banks);
 c03e060:	6868      	ldr	r0, [r5, #4]
 c03e062:	f7ff ff9b 	bl	c03df9c <FLASH_MassErase>
      status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 c03e066:	f44f 707a 	mov.w	r0, #1000	@ 0x3e8
 c03e06a:	f7ff ff21 	bl	c03deb0 <FLASH_WaitForLastOperation>
        status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 c03e06e:	4604      	mov	r4, r0
    CLEAR_BIT((*reg_cr), (pEraseInit->TypeErase) & (~(FLASH_NON_SECURE_MASK)));
 c03e070:	682a      	ldr	r2, [r5, #0]
 c03e072:	f8d8 3000 	ldr.w	r3, [r8]
 c03e076:	f022 4200 	bic.w	r2, r2, #2147483648	@ 0x80000000
 c03e07a:	ea23 0302 	bic.w	r3, r3, r2
 c03e07e:	f8c8 3000 	str.w	r3, [r8]
  __HAL_UNLOCK(&pFlash);
 c03e082:	2300      	movs	r3, #0
 c03e084:	7033      	strb	r3, [r6, #0]
}
 c03e086:	4620      	mov	r0, r4
 c03e088:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      *PageError = 0xFFFFFFFFU;
 c03e08c:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 c03e090:	f8c9 3000 	str.w	r3, [r9]
      for (page_index = pEraseInit->Page; page_index < (pEraseInit->Page + pEraseInit->NbPages); page_index++)
 c03e094:	68af      	ldr	r7, [r5, #8]
 c03e096:	e9d5 3202 	ldrd	r3, r2, [r5, #8]
 c03e09a:	4413      	add	r3, r2
 c03e09c:	42bb      	cmp	r3, r7
 c03e09e:	d9e7      	bls.n	c03e070 <HAL_FLASHEx_Erase+0x50>
        FLASH_PageErase(page_index, pEraseInit->Banks);
 c03e0a0:	4638      	mov	r0, r7
 c03e0a2:	6869      	ldr	r1, [r5, #4]
 c03e0a4:	f7ff ff98 	bl	c03dfd8 <FLASH_PageErase>
        status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 c03e0a8:	f44f 707a 	mov.w	r0, #1000	@ 0x3e8
 c03e0ac:	f7ff ff00 	bl	c03deb0 <FLASH_WaitForLastOperation>
        if (status != HAL_OK)
 c03e0b0:	b110      	cbz	r0, c03e0b8 <HAL_FLASHEx_Erase+0x98>
          *PageError = page_index;
 c03e0b2:	f8c9 7000 	str.w	r7, [r9]
 c03e0b6:	e7da      	b.n	c03e06e <HAL_FLASHEx_Erase+0x4e>
      for (page_index = pEraseInit->Page; page_index < (pEraseInit->Page + pEraseInit->NbPages); page_index++)
 c03e0b8:	3701      	adds	r7, #1
 c03e0ba:	e7ec      	b.n	c03e096 <HAL_FLASHEx_Erase+0x76>
  __HAL_LOCK(&pFlash);
 c03e0bc:	2402      	movs	r4, #2
 c03e0be:	e7e2      	b.n	c03e086 <HAL_FLASHEx_Erase+0x66>
 c03e0c0:	300308ec 	.word	0x300308ec
 c03e0c4:	50022028 	.word	0x50022028
 c03e0c8:	5002202c 	.word	0x5002202c

0c03e0cc <HAL_GPIO_Init>:
  * @param  pGPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, const GPIO_InitTypeDef *pGPIO_Init)
{
 c03e0cc:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
      /* Configure the External Interrupt or event for the current IO */
      if ((pGPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
      {
        tmp = EXTI->EXTICR[position >> 2U];
        tmp &= ~((0x0FUL) << (8U * (position & 0x03U)));
        tmp |= (GPIO_GET_INDEX(GPIOx) << (8U * (position & 0x03U)));
 c03e0d0:	4b83      	ldr	r3, [pc, #524]	@ (c03e2e0 <HAL_GPIO_Init+0x214>)
  uint32_t position = 0U;
 c03e0d2:	2200      	movs	r2, #0
        tmp |= (GPIO_GET_INDEX(GPIOx) << (8U * (position & 0x03U)));
 c03e0d4:	ea03 2390 	and.w	r3, r3, r0, lsr #10
 c03e0d8:	9301      	str	r3, [sp, #4]
 c03e0da:	4b82      	ldr	r3, [pc, #520]	@ (c03e2e4 <HAL_GPIO_Init+0x218>)
        tmp &= ~(GPIO_PUPDR_PUPD0 << (pin_position * 2U));
 c03e0dc:	f04f 0e03 	mov.w	lr, #3
 c03e0e0:	9300      	str	r3, [sp, #0]
  while (((pGPIO_Init->Pin) >> position) != 0U)
 c03e0e2:	4603      	mov	r3, r0
        EXTI->EXTICR[position >> 2U] = tmp;

        /* Clear Rising Falling edge configuration */
        tmp = EXTI->RTSR1;
 c03e0e4:	4f80      	ldr	r7, [pc, #512]	@ (c03e2e8 <HAL_GPIO_Init+0x21c>)
  while (((pGPIO_Init->Pin) >> position) != 0U)
 c03e0e6:	680e      	ldr	r6, [r1, #0]
 c03e0e8:	fa36 f402 	lsrs.w	r4, r6, r2
 c03e0ec:	d102      	bne.n	c03e0f4 <HAL_GPIO_Init+0x28>
        EXTI->IMR1 = tmp;
      }
    }
    position++;
  }
}
 c03e0ee:	b003      	add	sp, #12
 c03e0f0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    iocurrent = (pGPIO_Init->Pin) & (1UL << position);
 c03e0f4:	2401      	movs	r4, #1
 c03e0f6:	fa04 fc02 	lsl.w	ip, r4, r2
    if (iocurrent != 0U)
 c03e0fa:	ea1c 0606 	ands.w	r6, ip, r6
 c03e0fe:	f000 8091 	beq.w	c03e224 <HAL_GPIO_Init+0x158>
      if (GPIOx == LPGPIO1)
 c03e102:	4c7a      	ldr	r4, [pc, #488]	@ (c03e2ec <HAL_GPIO_Init+0x220>)
        tmp |= ((pGPIO_Init->Mode & GPIO_MODE_OUTPUT_PP) << position);
 c03e104:	684d      	ldr	r5, [r1, #4]
      if (GPIOx == LPGPIO1)
 c03e106:	42a0      	cmp	r0, r4
      else if ((pGPIO_Init->Mode == GPIO_MODE_AF_PP) || (pGPIO_Init->Mode == GPIO_MODE_AF_OD))
 c03e108:	f025 0810 	bic.w	r8, r5, #16
      if (GPIOx == LPGPIO1)
 c03e10c:	f040 808f 	bne.w	c03e22e <HAL_GPIO_Init+0x162>
        tmp &= ~(0x0FUL << (((pin_position) & 0x07U) * 4U));
 c03e110:	f04f 0a0f 	mov.w	sl, #15
        tmp = GPIOx->MODER;
 c03e114:	6804      	ldr	r4, [r0, #0]
        tmp |= ((pGPIO_Init->Mode & GPIO_MODE_OUTPUT_PP) << position);
 c03e116:	f005 0301 	and.w	r3, r5, #1
        tmp &= ~(LPGPIO_MODER_MOD0 << position);
 c03e11a:	ea24 040c 	bic.w	r4, r4, ip
        tmp |= ((pGPIO_Init->Mode & GPIO_MODE_OUTPUT_PP) << position);
 c03e11e:	4093      	lsls	r3, r2
 c03e120:	4323      	orrs	r3, r4
        pin_position = LPGPIO_Map[position].Pin_Pos;
 c03e122:	9c00      	ldr	r4, [sp, #0]
        GPIOx->MODER = tmp;
 c03e124:	6003      	str	r3, [r0, #0]
        p_gpio = LPGPIO_Map[position].GPIO_PORT;
 c03e126:	9b00      	ldr	r3, [sp, #0]
        pin_position = LPGPIO_Map[position].Pin_Pos;
 c03e128:	6864      	ldr	r4, [r4, #4]
        p_gpio = LPGPIO_Map[position].GPIO_PORT;
 c03e12a:	681b      	ldr	r3, [r3, #0]
        tmp = p_gpio->AFR[(pin_position) >> 3U];
 c03e12c:	ea4f 09d4 	mov.w	r9, r4, lsr #3
 c03e130:	eb03 0989 	add.w	r9, r3, r9, lsl #2
        tmp &= ~(0x0FUL << (((pin_position) & 0x07U) * 4U));
 c03e134:	f004 0c07 	and.w	ip, r4, #7
        tmp = p_gpio->AFR[(pin_position) >> 3U];
 c03e138:	f8d9 b020 	ldr.w	fp, [r9, #32]
        tmp &= ~(0x0FUL << (((pin_position) & 0x07U) * 4U));
 c03e13c:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
 c03e140:	fa0a fa0c 	lsl.w	sl, sl, ip
 c03e144:	ea2b 0a0a 	bic.w	sl, fp, sl
        tmp |= ((GPIO_AF11_LPGPIO1 & 0x0FUL) << (((pin_position) & 0x07U) * 4U));
 c03e148:	f04f 0b0b 	mov.w	fp, #11
 c03e14c:	fa0b fc0c 	lsl.w	ip, fp, ip
 c03e150:	ea4c 0c0a 	orr.w	ip, ip, sl
        p_gpio->AFR[(pin_position) >> 3U] = tmp;
 c03e154:	f8c9 c020 	str.w	ip, [r9, #32]
        tmp = p_gpio->MODER;
 c03e158:	f8d3 9000 	ldr.w	r9, [r3]
        tmp &= ~(GPIO_MODER_MODE0 << (pin_position * 2U));
 c03e15c:	ea4f 0c44 	mov.w	ip, r4, lsl #1
 c03e160:	fa0e fa0c 	lsl.w	sl, lr, ip
 c03e164:	ea29 090a 	bic.w	r9, r9, sl
        tmp |= ((GPIO_MODE_AF_PP & 0x0FUL) << (pin_position * 2U));
 c03e168:	f04f 0a02 	mov.w	sl, #2
 c03e16c:	fa0a fc0c 	lsl.w	ip, sl, ip
 c03e170:	ea4c 0c09 	orr.w	ip, ip, r9
        p_gpio->MODER = tmp;
 c03e174:	f8c3 c000 	str.w	ip, [r3]
      if ((pGPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (pGPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 c03e178:	f108 38ff 	add.w	r8, r8, #4294967295	@ 0xffffffff
 c03e17c:	f1b8 0f01 	cmp.w	r8, #1
 c03e180:	f240 8084 	bls.w	c03e28c <HAL_GPIO_Init+0x1c0>
      if (pGPIO_Init->Mode != GPIO_MODE_ANALOG)
 c03e184:	2d03      	cmp	r5, #3
 c03e186:	d04d      	beq.n	c03e224 <HAL_GPIO_Init+0x158>
        tmp = p_gpio->PUPDR;
 c03e188:	f8d3 800c 	ldr.w	r8, [r3, #12]
        tmp &= ~(GPIO_PUPDR_PUPD0 << (pin_position * 2U));
 c03e18c:	0064      	lsls	r4, r4, #1
 c03e18e:	fa0e fc04 	lsl.w	ip, lr, r4
 c03e192:	ea28 0c0c 	bic.w	ip, r8, ip
        tmp |= ((pGPIO_Init->Pull) << (pin_position * 2U));
 c03e196:	f8d1 8008 	ldr.w	r8, [r1, #8]
 c03e19a:	fa08 f404 	lsl.w	r4, r8, r4
 c03e19e:	ea44 040c 	orr.w	r4, r4, ip
        p_gpio->PUPDR = tmp;
 c03e1a2:	60dc      	str	r4, [r3, #12]
      if ((pGPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 c03e1a4:	00ec      	lsls	r4, r5, #3
 c03e1a6:	d53d      	bpl.n	c03e224 <HAL_GPIO_Init+0x158>
        tmp &= ~((0x0FUL) << (8U * (position & 0x03U)));
 c03e1a8:	f04f 080f 	mov.w	r8, #15
 c03e1ac:	f022 0c03 	bic.w	ip, r2, #3
 c03e1b0:	f10c 4cac 	add.w	ip, ip, #1442840576	@ 0x56000000
 c03e1b4:	f50c 3c08 	add.w	ip, ip, #139264	@ 0x22000
 c03e1b8:	f002 0403 	and.w	r4, r2, #3
        tmp = EXTI->EXTICR[position >> 2U];
 c03e1bc:	f8dc 9060 	ldr.w	r9, [ip, #96]	@ 0x60
        tmp &= ~((0x0FUL) << (8U * (position & 0x03U)));
 c03e1c0:	00e4      	lsls	r4, r4, #3
 c03e1c2:	fa08 f804 	lsl.w	r8, r8, r4
 c03e1c6:	ea29 0808 	bic.w	r8, r9, r8
        tmp |= (GPIO_GET_INDEX(GPIOx) << (8U * (position & 0x03U)));
 c03e1ca:	f8dd 9004 	ldr.w	r9, [sp, #4]
        if ((pGPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 c03e1ce:	f415 1f80 	tst.w	r5, #1048576	@ 0x100000
        tmp |= (GPIO_GET_INDEX(GPIOx) << (8U * (position & 0x03U)));
 c03e1d2:	fa09 f404 	lsl.w	r4, r9, r4
 c03e1d6:	ea44 0408 	orr.w	r4, r4, r8
        EXTI->EXTICR[position >> 2U] = tmp;
 c03e1da:	f8cc 4060 	str.w	r4, [ip, #96]	@ 0x60
        tmp &= ~((uint32_t)iocurrent);
 c03e1de:	ea6f 0c06 	mvn.w	ip, r6
        tmp = EXTI->RTSR1;
 c03e1e2:	683c      	ldr	r4, [r7, #0]
        tmp &= ~((uint32_t)iocurrent);
 c03e1e4:	bf0c      	ite	eq
 c03e1e6:	ea0c 0404 	andeq.w	r4, ip, r4
          tmp |= iocurrent;
 c03e1ea:	4334      	orrne	r4, r6
        EXTI->RTSR1 = tmp;
 c03e1ec:	603c      	str	r4, [r7, #0]
        tmp = EXTI->FTSR1;
 c03e1ee:	687c      	ldr	r4, [r7, #4]
        if ((pGPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 c03e1f0:	f415 1f00 	tst.w	r5, #2097152	@ 0x200000
        tmp &= ~((uint32_t)iocurrent);
 c03e1f4:	bf0c      	ite	eq
 c03e1f6:	ea0c 0404 	andeq.w	r4, ip, r4
          tmp |= iocurrent;
 c03e1fa:	4334      	orrne	r4, r6
        EXTI->FTSR1 = tmp;
 c03e1fc:	607c      	str	r4, [r7, #4]
        tmp = EXTI->EMR1;
 c03e1fe:	f8d7 4084 	ldr.w	r4, [r7, #132]	@ 0x84
        if ((pGPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 c03e202:	f415 3f00 	tst.w	r5, #131072	@ 0x20000
        tmp &= ~((uint32_t)iocurrent);
 c03e206:	bf0c      	ite	eq
 c03e208:	ea0c 0404 	andeq.w	r4, ip, r4
          tmp |= iocurrent;
 c03e20c:	4334      	orrne	r4, r6
        EXTI->EMR1 = tmp;
 c03e20e:	f8c7 4084 	str.w	r4, [r7, #132]	@ 0x84
        tmp = EXTI->IMR1;
 c03e212:	f8d7 4080 	ldr.w	r4, [r7, #128]	@ 0x80
        if ((pGPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 c03e216:	03ed      	lsls	r5, r5, #15
        tmp &= ~((uint32_t)iocurrent);
 c03e218:	bf54      	ite	pl
 c03e21a:	ea0c 0404 	andpl.w	r4, ip, r4
          tmp |= iocurrent;
 c03e21e:	4334      	orrmi	r4, r6
        EXTI->IMR1 = tmp;
 c03e220:	f8c7 4080 	str.w	r4, [r7, #128]	@ 0x80
    position++;
 c03e224:	9c00      	ldr	r4, [sp, #0]
 c03e226:	3201      	adds	r2, #1
 c03e228:	3408      	adds	r4, #8
 c03e22a:	9400      	str	r4, [sp, #0]
 c03e22c:	e75b      	b.n	c03e0e6 <HAL_GPIO_Init+0x1a>
      else if ((pGPIO_Init->Mode == GPIO_MODE_AF_PP) || (pGPIO_Init->Mode == GPIO_MODE_AF_OD))
 c03e22e:	ea4f 0942 	mov.w	r9, r2, lsl #1
        tmp &= ~(GPIO_MODER_MODE0 << (pin_position * 2U));
 c03e232:	fa0e f409 	lsl.w	r4, lr, r9
        tmp |= ((pGPIO_Init->Mode & GPIO_MODE) << (pin_position * 2U));
 c03e236:	f005 0c03 	and.w	ip, r5, #3
      else if ((pGPIO_Init->Mode == GPIO_MODE_AF_PP) || (pGPIO_Init->Mode == GPIO_MODE_AF_OD))
 c03e23a:	f1b8 0f02 	cmp.w	r8, #2
        tmp &= ~(GPIO_MODER_MODE0 << (pin_position * 2U));
 c03e23e:	ea6f 0404 	mvn.w	r4, r4
        tmp |= ((pGPIO_Init->Mode & GPIO_MODE) << (pin_position * 2U));
 c03e242:	fa0c fc09 	lsl.w	ip, ip, r9
      else if ((pGPIO_Init->Mode == GPIO_MODE_AF_PP) || (pGPIO_Init->Mode == GPIO_MODE_AF_OD))
 c03e246:	d142      	bne.n	c03e2ce <HAL_GPIO_Init+0x202>
        tmp &= ~(0x0FUL << ((position & 0x07U) * 4U));
 c03e248:	f04f 0b0f 	mov.w	fp, #15
        tmp = GPIOx->AFR[position >> 3U];
 c03e24c:	ea4f 08d2 	mov.w	r8, r2, lsr #3
 c03e250:	eb00 0888 	add.w	r8, r0, r8, lsl #2
        tmp &= ~(0x0FUL << ((position & 0x07U) * 4U));
 c03e254:	f002 0907 	and.w	r9, r2, #7
        tmp = GPIOx->AFR[position >> 3U];
 c03e258:	f8d8 a020 	ldr.w	sl, [r8, #32]
        tmp &= ~(0x0FUL << ((position & 0x07U) * 4U));
 c03e25c:	ea4f 0989 	mov.w	r9, r9, lsl #2
 c03e260:	fa0b fb09 	lsl.w	fp, fp, r9
 c03e264:	ea2a 0a0b 	bic.w	sl, sl, fp
        tmp |= ((pGPIO_Init->Alternate & 0x0FUL) << ((position & 0x07U) * 4U));
 c03e268:	f8d1 b010 	ldr.w	fp, [r1, #16]
 c03e26c:	f00b 0b0f 	and.w	fp, fp, #15
 c03e270:	fa0b fb09 	lsl.w	fp, fp, r9
 c03e274:	ea4b 0b0a 	orr.w	fp, fp, sl
        GPIOx->AFR[position >> 3U] = tmp;
 c03e278:	f8c8 b020 	str.w	fp, [r8, #32]
        tmp = p_gpio->MODER;
 c03e27c:	f8d3 8000 	ldr.w	r8, [r3]
        tmp &= ~(GPIO_MODER_MODE0 << (pin_position * 2U));
 c03e280:	ea04 0808 	and.w	r8, r4, r8
        tmp |= ((pGPIO_Init->Mode & GPIO_MODE) << (pin_position * 2U));
 c03e284:	ea48 040c 	orr.w	r4, r8, ip
        p_gpio->MODER = tmp;
 c03e288:	601c      	str	r4, [r3, #0]
    pin_position = position;
 c03e28a:	4614      	mov	r4, r2
        tmp = p_gpio->OSPEEDR;
 c03e28c:	f8d3 c008 	ldr.w	ip, [r3, #8]
        tmp &= ~(GPIO_OSPEEDR_OSPEED0 << (pin_position * 2U));
 c03e290:	ea4f 0844 	mov.w	r8, r4, lsl #1
 c03e294:	fa0e f908 	lsl.w	r9, lr, r8
 c03e298:	ea2c 0c09 	bic.w	ip, ip, r9
        tmp |= (pGPIO_Init->Speed << (pin_position * 2U));
 c03e29c:	f8d1 900c 	ldr.w	r9, [r1, #12]
 c03e2a0:	fa09 f808 	lsl.w	r8, r9, r8
 c03e2a4:	ea48 080c 	orr.w	r8, r8, ip
        tmp &= ~(GPIO_OTYPER_OT0 << pin_position);
 c03e2a8:	f04f 0c01 	mov.w	ip, #1
        p_gpio->OSPEEDR = tmp;
 c03e2ac:	f8c3 8008 	str.w	r8, [r3, #8]
        tmp = p_gpio->OTYPER;
 c03e2b0:	f8d3 8004 	ldr.w	r8, [r3, #4]
        tmp &= ~(GPIO_OTYPER_OT0 << pin_position);
 c03e2b4:	fa0c fc04 	lsl.w	ip, ip, r4
 c03e2b8:	ea28 080c 	bic.w	r8, r8, ip
        tmp |= (((pGPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << pin_position);
 c03e2bc:	f3c5 1c00 	ubfx	ip, r5, #4, #1
 c03e2c0:	fa0c fc04 	lsl.w	ip, ip, r4
 c03e2c4:	ea4c 0c08 	orr.w	ip, ip, r8
        p_gpio->OTYPER = tmp;
 c03e2c8:	f8c3 c004 	str.w	ip, [r3, #4]
 c03e2cc:	e75a      	b.n	c03e184 <HAL_GPIO_Init+0xb8>
        tmp = p_gpio->MODER;
 c03e2ce:	f8d3 9000 	ldr.w	r9, [r3]
        tmp &= ~(GPIO_MODER_MODE0 << (pin_position * 2U));
 c03e2d2:	ea04 0409 	and.w	r4, r4, r9
        tmp |= ((pGPIO_Init->Mode & GPIO_MODE) << (pin_position * 2U));
 c03e2d6:	ea44 040c 	orr.w	r4, r4, ip
        p_gpio->MODER = tmp;
 c03e2da:	601c      	str	r4, [r3, #0]
    pin_position = position;
 c03e2dc:	4614      	mov	r4, r2
 c03e2de:	e74b      	b.n	c03e178 <HAL_GPIO_Init+0xac>
 c03e2e0:	002b7f7f 	.word	0x002b7f7f
 c03e2e4:	0c05fb1c 	.word	0x0c05fb1c
 c03e2e8:	56022000 	.word	0x56022000
 c03e2ec:	56020000 	.word	0x56020000

0c03e2f0 <HAL_GPIO_DeInit>:

        /*------------------------- EXTI Mode Configuration --------------------*/
        /* Clear the External Interrupt or Event for the current IO */
        tmp = EXTI->EXTICR[position >> 2U];
        tmp &= ((0x0FUL) << (8U * (position & 0x03U)));
        if (tmp == (GPIO_GET_INDEX(GPIOx) << (8U * (position & 0x03U))))
 c03e2f0:	4b3c      	ldr	r3, [pc, #240]	@ (c03e3e4 <HAL_GPIO_DeInit+0xf4>)
{
 c03e2f2:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    iocurrent = (GPIO_Pin) & (1UL << position);
 c03e2f6:	f04f 0c01 	mov.w	ip, #1
        if (tmp == (GPIO_GET_INDEX(GPIOx) << (8U * (position & 0x03U))))
 c03e2fa:	ea03 2890 	and.w	r8, r3, r0, lsr #10
  uint32_t position = 0U;
 c03e2fe:	2400      	movs	r4, #0
  while ((GPIO_Pin >> position) != 0U)
 c03e300:	4603      	mov	r3, r0
        }
      }

      /*------------------------- GPIO Mode Configuration --------------------*/
      /* Configure IO in Analog Mode */
      p_gpio->MODER |= (GPIO_MODER_MODE0 << (pin_position * 2U));
 c03e302:	f04f 0903 	mov.w	r9, #3

      /* Configure the default Alternate Function in current IO */
      p_gpio->AFR[pin_position >> 3U] &= ~(0x0FUL << ((pin_position & 0x07U) * 4U));
 c03e306:	f04f 0e0f 	mov.w	lr, #15
 c03e30a:	4f37      	ldr	r7, [pc, #220]	@ (c03e3e8 <HAL_GPIO_DeInit+0xf8>)
  while ((GPIO_Pin >> position) != 0U)
 c03e30c:	fa31 f204 	lsrs.w	r2, r1, r4
 c03e310:	d101      	bne.n	c03e316 <HAL_GPIO_DeInit+0x26>
      p_gpio->PUPDR &= ~(GPIO_PUPDR_PUPD0 << (pin_position * 2U));
    }

    position++;
  }
}
 c03e312:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    iocurrent = (GPIO_Pin) & (1UL << position);
 c03e316:	fa0c f604 	lsl.w	r6, ip, r4
    if (iocurrent != 0U)
 c03e31a:	400e      	ands	r6, r1
 c03e31c:	d02d      	beq.n	c03e37a <HAL_GPIO_DeInit+0x8a>
      if (GPIOx == LPGPIO1)
 c03e31e:	4a33      	ldr	r2, [pc, #204]	@ (c03e3ec <HAL_GPIO_DeInit+0xfc>)
 c03e320:	4290      	cmp	r0, r2
 c03e322:	d12d      	bne.n	c03e380 <HAL_GPIO_DeInit+0x90>
        pin_position = LPGPIO_Map[position].Pin_Pos;
 c03e324:	e9d7 3200 	ldrd	r3, r2, [r7]
        LPGPIO1->MODER &= ~(1U << pin_position);
 c03e328:	6805      	ldr	r5, [r0, #0]
 c03e32a:	fa0c f602 	lsl.w	r6, ip, r2
 c03e32e:	ea25 0506 	bic.w	r5, r5, r6
 c03e332:	6005      	str	r5, [r0, #0]
      p_gpio->MODER |= (GPIO_MODER_MODE0 << (pin_position * 2U));
 c03e334:	681e      	ldr	r6, [r3, #0]
 c03e336:	0055      	lsls	r5, r2, #1
 c03e338:	fa09 f505 	lsl.w	r5, r9, r5
 c03e33c:	432e      	orrs	r6, r5
      p_gpio->AFR[pin_position >> 3U] &= ~(0x0FUL << ((pin_position & 0x07U) * 4U));
 c03e33e:	ea4f 0ad2 	mov.w	sl, r2, lsr #3
      p_gpio->MODER |= (GPIO_MODER_MODE0 << (pin_position * 2U));
 c03e342:	601e      	str	r6, [r3, #0]
      p_gpio->AFR[pin_position >> 3U] &= ~(0x0FUL << ((pin_position & 0x07U) * 4U));
 c03e344:	eb03 0a8a 	add.w	sl, r3, sl, lsl #2
 c03e348:	f002 0607 	and.w	r6, r2, #7
 c03e34c:	f8da b020 	ldr.w	fp, [sl, #32]
 c03e350:	00b6      	lsls	r6, r6, #2
 c03e352:	fa0e f606 	lsl.w	r6, lr, r6
 c03e356:	ea2b 0606 	bic.w	r6, fp, r6
 c03e35a:	f8ca 6020 	str.w	r6, [sl, #32]
      p_gpio->OSPEEDR &= ~(GPIO_OSPEEDR_OSPEED0 << (pin_position * 2U));
 c03e35e:	689e      	ldr	r6, [r3, #8]
      p_gpio->OTYPER  &= ~(GPIO_OTYPER_OT0 << pin_position);
 c03e360:	fa0c f202 	lsl.w	r2, ip, r2
      p_gpio->OSPEEDR &= ~(GPIO_OSPEEDR_OSPEED0 << (pin_position * 2U));
 c03e364:	ea26 0605 	bic.w	r6, r6, r5
 c03e368:	609e      	str	r6, [r3, #8]
      p_gpio->OTYPER  &= ~(GPIO_OTYPER_OT0 << pin_position);
 c03e36a:	685e      	ldr	r6, [r3, #4]
 c03e36c:	ea26 0202 	bic.w	r2, r6, r2
 c03e370:	605a      	str	r2, [r3, #4]
      p_gpio->PUPDR &= ~(GPIO_PUPDR_PUPD0 << (pin_position * 2U));
 c03e372:	68da      	ldr	r2, [r3, #12]
 c03e374:	ea22 0205 	bic.w	r2, r2, r5
 c03e378:	60da      	str	r2, [r3, #12]
    position++;
 c03e37a:	3401      	adds	r4, #1
 c03e37c:	3708      	adds	r7, #8
 c03e37e:	e7c5      	b.n	c03e30c <HAL_GPIO_DeInit+0x1c>
        tmp = EXTI->EXTICR[position >> 2U];
 c03e380:	f024 0503 	bic.w	r5, r4, #3
 c03e384:	f105 45ac 	add.w	r5, r5, #1442840576	@ 0x56000000
 c03e388:	f505 3508 	add.w	r5, r5, #139264	@ 0x22000
        tmp &= ((0x0FUL) << (8U * (position & 0x03U)));
 c03e38c:	f004 0203 	and.w	r2, r4, #3
 c03e390:	00d2      	lsls	r2, r2, #3
        tmp = EXTI->EXTICR[position >> 2U];
 c03e392:	f8d5 b060 	ldr.w	fp, [r5, #96]	@ 0x60
        tmp &= ((0x0FUL) << (8U * (position & 0x03U)));
 c03e396:	fa0e fa02 	lsl.w	sl, lr, r2
 c03e39a:	ea0a 0b0b 	and.w	fp, sl, fp
        if (tmp == (GPIO_GET_INDEX(GPIOx) << (8U * (position & 0x03U))))
 c03e39e:	fa08 f202 	lsl.w	r2, r8, r2
 c03e3a2:	455a      	cmp	r2, fp
 c03e3a4:	d11b      	bne.n	c03e3de <HAL_GPIO_DeInit+0xee>
          EXTI->IMR1 &= ~(iocurrent);
 c03e3a6:	4a12      	ldr	r2, [pc, #72]	@ (c03e3f0 <HAL_GPIO_DeInit+0x100>)
 c03e3a8:	f8d2 b080 	ldr.w	fp, [r2, #128]	@ 0x80
 c03e3ac:	ea2b 0b06 	bic.w	fp, fp, r6
 c03e3b0:	f8c2 b080 	str.w	fp, [r2, #128]	@ 0x80
          EXTI->EMR1 &= ~(iocurrent);
 c03e3b4:	f8d2 b084 	ldr.w	fp, [r2, #132]	@ 0x84
 c03e3b8:	ea2b 0b06 	bic.w	fp, fp, r6
 c03e3bc:	f8c2 b084 	str.w	fp, [r2, #132]	@ 0x84
          EXTI->RTSR1 &= ~(iocurrent);
 c03e3c0:	f8d2 b000 	ldr.w	fp, [r2]
 c03e3c4:	ea2b 0b06 	bic.w	fp, fp, r6
 c03e3c8:	f8c2 b000 	str.w	fp, [r2]
          EXTI->FTSR1 &= ~(iocurrent);
 c03e3cc:	f8d2 b004 	ldr.w	fp, [r2, #4]
 c03e3d0:	ea2b 0606 	bic.w	r6, fp, r6
 c03e3d4:	6056      	str	r6, [r2, #4]
          EXTI->EXTICR[position >> 2U] &= ~tmp;
 c03e3d6:	6e2a      	ldr	r2, [r5, #96]	@ 0x60
 c03e3d8:	ea22 020a 	bic.w	r2, r2, sl
 c03e3dc:	662a      	str	r2, [r5, #96]	@ 0x60
    pin_position = position;
 c03e3de:	4622      	mov	r2, r4
 c03e3e0:	e7a8      	b.n	c03e334 <HAL_GPIO_DeInit+0x44>
 c03e3e2:	bf00      	nop
 c03e3e4:	002b7f7f 	.word	0x002b7f7f
 c03e3e8:	0c05fb1c 	.word	0x0c05fb1c
 c03e3ec:	56020000 	.word	0x56020000
 c03e3f0:	56022000 	.word	0x56022000

0c03e3f4 <HAL_GPIO_ReadPin>:
  GPIO_PinState bitstatus;

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  if ((GPIOx->IDR & GPIO_Pin) != 0U)
 c03e3f4:	6903      	ldr	r3, [r0, #16]
 c03e3f6:	4219      	tst	r1, r3
  {
    bitstatus = GPIO_PIN_RESET;
  }

  return bitstatus;
}
 c03e3f8:	bf14      	ite	ne
 c03e3fa:	2001      	movne	r0, #1
 c03e3fc:	2000      	moveq	r0, #0
 c03e3fe:	4770      	bx	lr

0c03e400 <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if (PinState != GPIO_PIN_RESET)
 c03e400:	b10a      	cbz	r2, c03e406 <HAL_GPIO_WritePin+0x6>
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
 c03e402:	6181      	str	r1, [r0, #24]
 c03e404:	4770      	bx	lr
  }
  else
  {
    GPIOx->BRR  = (uint32_t)GPIO_Pin;
 c03e406:	6281      	str	r1, [r0, #40]	@ 0x28
  }
}
 c03e408:	4770      	bx	lr
	...

0c03e40c <HAL_GTZC_TZSC_ConfigPeriphAttributes>:
                                                       uint32_t PeriphAttributes)
{
  uint32_t register_address;

  /* check entry parameters */
  if ((PeriphAttributes > (GTZC_TZSC_PERIPH_SEC | GTZC_TZSC_PERIPH_PRIV))
 c03e40c:	f5b1 7f41 	cmp.w	r1, #772	@ 0x304
{
 c03e410:	b570      	push	{r4, r5, r6, lr}
  if ((PeriphAttributes > (GTZC_TZSC_PERIPH_SEC | GTZC_TZSC_PERIPH_PRIV))
 c03e412:	f080 80c0 	bcs.w	c03e596 <HAL_GTZC_TZSC_ConfigPeriphAttributes+0x18a>
 c03e416:	f1b0 4f80 	cmp.w	r0, #1073741824	@ 0x40000000
      || (HAL_GTZC_TZSC_GET_ARRAY_INDEX(PeriphId) >= GTZC_TZSC_PERIPH_NUMBER)
 c03e41a:	ea4f 7310 	mov.w	r3, r0, lsr #28
 c03e41e:	f000 041f 	and.w	r4, r0, #31
 c03e422:	bf2a      	itet	cs
 c03e424:	f103 32ff 	addcs.w	r2, r3, #4294967295	@ 0xffffffff
 c03e428:	eb04 1243 	addcc.w	r2, r4, r3, lsl #5
 c03e42c:	eb04 1242 	addcs.w	r2, r4, r2, lsl #5
 c03e430:	2a6c      	cmp	r2, #108	@ 0x6c
 c03e432:	f200 80b0 	bhi.w	c03e596 <HAL_GTZC_TZSC_ConfigPeriphAttributes+0x18a>
      || (((PeriphId & GTZC_PERIPH_ALL) != 0U)
 c03e436:	0686      	lsls	r6, r0, #26
 c03e438:	d575      	bpl.n	c03e526 <HAL_GTZC_TZSC_ConfigPeriphAttributes+0x11a>
  if ((PeriphAttributes > (GTZC_TZSC_PERIPH_SEC | GTZC_TZSC_PERIPH_PRIV))
 c03e43a:	2b03      	cmp	r3, #3
 c03e43c:	f200 80ab 	bhi.w	c03e596 <HAL_GTZC_TZSC_ConfigPeriphAttributes+0x18a>
          && (HAL_GTZC_TZSC_GET_ARRAY_INDEX(PeriphId) != 0U)))
 c03e440:	eb04 1343 	add.w	r3, r4, r3, lsl #5
 c03e444:	2b00      	cmp	r3, #0
 c03e446:	f040 80a6 	bne.w	c03e596 <HAL_GTZC_TZSC_ConfigPeriphAttributes+0x18a>
  {
    /* special case where same attributes are applied to all peripherals */

#if defined(__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)
    /* secure configuration */
    if ((PeriphAttributes & GTZC_TZSC_PERIPH_SEC) == GTZC_TZSC_PERIPH_SEC)
 c03e44a:	f240 1301 	movw	r3, #257	@ 0x101
 c03e44e:	438b      	bics	r3, r1
 c03e450:	d139      	bne.n	c03e4c6 <HAL_GTZC_TZSC_ConfigPeriphAttributes+0xba>
    {
      SET_BIT(GTZC_TZSC1->SECCFGR1, TZSC1_SECCFGR1_ALL);
 c03e452:	4b52      	ldr	r3, [pc, #328]	@ (c03e59c <HAL_GTZC_TZSC_ConfigPeriphAttributes+0x190>)
 c03e454:	691a      	ldr	r2, [r3, #16]
 c03e456:	ea6f 5252 	mvn.w	r2, r2, lsr #21
 c03e45a:	ea6f 5242 	mvn.w	r2, r2, lsl #21
 c03e45e:	611a      	str	r2, [r3, #16]
      SET_BIT(GTZC_TZSC1->SECCFGR2, TZSC1_SECCFGR2_ALL);
 c03e460:	695a      	ldr	r2, [r3, #20]
 c03e462:	ea6f 2252 	mvn.w	r2, r2, lsr #9
 c03e466:	ea6f 2242 	mvn.w	r2, r2, lsl #9
 c03e46a:	615a      	str	r2, [r3, #20]
      SET_BIT(GTZC_TZSC1->SECCFGR3, TZSC1_SECCFGR3_ALL);
 c03e46c:	699a      	ldr	r2, [r3, #24]
 c03e46e:	ea6f 52d2 	mvn.w	r2, r2, lsr #23
 c03e472:	ea6f 52c2 	mvn.w	r2, r2, lsl #23
 c03e476:	619a      	str	r2, [r3, #24]
      SET_BIT(GTZC_TZSC2->SECCFGR1, TZSC2_SECCFGR1_ALL);
 c03e478:	4a49      	ldr	r2, [pc, #292]	@ (c03e5a0 <HAL_GTZC_TZSC_ConfigPeriphAttributes+0x194>)
 c03e47a:	6913      	ldr	r3, [r2, #16]
 c03e47c:	f443 53df 	orr.w	r3, r3, #7136	@ 0x1be0
 c03e480:	f043 031f 	orr.w	r3, r3, #31
    else if ((PeriphAttributes & GTZC_TZSC_PERIPH_NSEC) == GTZC_TZSC_PERIPH_NSEC)
    {
      CLEAR_BIT(GTZC_TZSC1->SECCFGR1, TZSC1_SECCFGR1_ALL);
      CLEAR_BIT(GTZC_TZSC1->SECCFGR2, TZSC1_SECCFGR2_ALL);
      CLEAR_BIT(GTZC_TZSC1->SECCFGR3, TZSC1_SECCFGR3_ALL);
      CLEAR_BIT(GTZC_TZSC2->SECCFGR1, TZSC2_SECCFGR1_ALL);
 c03e484:	6113      	str	r3, [r2, #16]
      /* do nothing */
    }
#endif /* defined(__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U) */

    /* privilege configuration */
    if ((PeriphAttributes & GTZC_TZSC_PERIPH_PRIV) == GTZC_TZSC_PERIPH_PRIV)
 c03e486:	f240 2302 	movw	r3, #514	@ 0x202
 c03e48a:	438b      	bics	r3, r1
 c03e48c:	d133      	bne.n	c03e4f6 <HAL_GTZC_TZSC_ConfigPeriphAttributes+0xea>
    {
      SET_BIT(GTZC_TZSC1->PRIVCFGR1, TZSC1_PRIVCFGR1_ALL);
 c03e48e:	4b43      	ldr	r3, [pc, #268]	@ (c03e59c <HAL_GTZC_TZSC_ConfigPeriphAttributes+0x190>)
 c03e490:	6a1a      	ldr	r2, [r3, #32]
 c03e492:	ea6f 5252 	mvn.w	r2, r2, lsr #21
 c03e496:	ea6f 5242 	mvn.w	r2, r2, lsl #21
 c03e49a:	621a      	str	r2, [r3, #32]
      SET_BIT(GTZC_TZSC1->PRIVCFGR2, TZSC1_PRIVCFGR2_ALL);
 c03e49c:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 c03e49e:	ea6f 2252 	mvn.w	r2, r2, lsr #9
 c03e4a2:	ea6f 2242 	mvn.w	r2, r2, lsl #9
 c03e4a6:	625a      	str	r2, [r3, #36]	@ 0x24
      SET_BIT(GTZC_TZSC1->PRIVCFGR3, TZSC1_PRIVCFGR3_ALL);
 c03e4a8:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
 c03e4aa:	ea6f 52d2 	mvn.w	r2, r2, lsr #23
 c03e4ae:	ea6f 52c2 	mvn.w	r2, r2, lsl #23
 c03e4b2:	629a      	str	r2, [r3, #40]	@ 0x28
      SET_BIT(GTZC_TZSC2->PRIVCFGR1, TZSC2_PRIVCFGR1_ALL);
 c03e4b4:	4a3a      	ldr	r2, [pc, #232]	@ (c03e5a0 <HAL_GTZC_TZSC_ConfigPeriphAttributes+0x194>)
 c03e4b6:	6a13      	ldr	r3, [r2, #32]
 c03e4b8:	f443 53df 	orr.w	r3, r3, #7136	@ 0x1be0
 c03e4bc:	f043 031f 	orr.w	r3, r3, #31
    else if ((PeriphAttributes & GTZC_TZSC_PERIPH_NPRIV) == GTZC_TZSC_PERIPH_NPRIV)
    {
      CLEAR_BIT(GTZC_TZSC1->PRIVCFGR1, TZSC1_PRIVCFGR1_ALL);
      CLEAR_BIT(GTZC_TZSC1->PRIVCFGR2, TZSC1_PRIVCFGR2_ALL);
      CLEAR_BIT(GTZC_TZSC1->PRIVCFGR3, TZSC1_PRIVCFGR3_ALL);
      CLEAR_BIT(GTZC_TZSC2->PRIVCFGR1, TZSC2_PRIVCFGR1_ALL);
 c03e4c0:	6213      	str	r3, [r2, #32]
    else
    {
      /* do nothing */
    }
  }
  return HAL_OK;
 c03e4c2:	2000      	movs	r0, #0
}
 c03e4c4:	bd70      	pop	{r4, r5, r6, pc}
    else if ((PeriphAttributes & GTZC_TZSC_PERIPH_NSEC) == GTZC_TZSC_PERIPH_NSEC)
 c03e4c6:	05cd      	lsls	r5, r1, #23
 c03e4c8:	d5dd      	bpl.n	c03e486 <HAL_GTZC_TZSC_ConfigPeriphAttributes+0x7a>
      CLEAR_BIT(GTZC_TZSC1->SECCFGR1, TZSC1_SECCFGR1_ALL);
 c03e4ca:	4b34      	ldr	r3, [pc, #208]	@ (c03e59c <HAL_GTZC_TZSC_ConfigPeriphAttributes+0x190>)
 c03e4cc:	691a      	ldr	r2, [r3, #16]
 c03e4ce:	0d52      	lsrs	r2, r2, #21
 c03e4d0:	0552      	lsls	r2, r2, #21
 c03e4d2:	611a      	str	r2, [r3, #16]
      CLEAR_BIT(GTZC_TZSC1->SECCFGR2, TZSC1_SECCFGR2_ALL);
 c03e4d4:	695a      	ldr	r2, [r3, #20]
 c03e4d6:	f422 72ff 	bic.w	r2, r2, #510	@ 0x1fe
 c03e4da:	f022 0201 	bic.w	r2, r2, #1
 c03e4de:	615a      	str	r2, [r3, #20]
      CLEAR_BIT(GTZC_TZSC1->SECCFGR3, TZSC1_SECCFGR3_ALL);
 c03e4e0:	699a      	ldr	r2, [r3, #24]
 c03e4e2:	0dd2      	lsrs	r2, r2, #23
 c03e4e4:	05d2      	lsls	r2, r2, #23
 c03e4e6:	619a      	str	r2, [r3, #24]
      CLEAR_BIT(GTZC_TZSC2->SECCFGR1, TZSC2_SECCFGR1_ALL);
 c03e4e8:	4a2d      	ldr	r2, [pc, #180]	@ (c03e5a0 <HAL_GTZC_TZSC_ConfigPeriphAttributes+0x194>)
 c03e4ea:	6913      	ldr	r3, [r2, #16]
 c03e4ec:	f423 53df 	bic.w	r3, r3, #7136	@ 0x1be0
 c03e4f0:	f023 031f 	bic.w	r3, r3, #31
 c03e4f4:	e7c6      	b.n	c03e484 <HAL_GTZC_TZSC_ConfigPeriphAttributes+0x78>
    else if ((PeriphAttributes & GTZC_TZSC_PERIPH_NPRIV) == GTZC_TZSC_PERIPH_NPRIV)
 c03e4f6:	058c      	lsls	r4, r1, #22
 c03e4f8:	d5e3      	bpl.n	c03e4c2 <HAL_GTZC_TZSC_ConfigPeriphAttributes+0xb6>
      CLEAR_BIT(GTZC_TZSC1->PRIVCFGR1, TZSC1_PRIVCFGR1_ALL);
 c03e4fa:	4b28      	ldr	r3, [pc, #160]	@ (c03e59c <HAL_GTZC_TZSC_ConfigPeriphAttributes+0x190>)
 c03e4fc:	6a1a      	ldr	r2, [r3, #32]
 c03e4fe:	0d52      	lsrs	r2, r2, #21
 c03e500:	0552      	lsls	r2, r2, #21
 c03e502:	621a      	str	r2, [r3, #32]
      CLEAR_BIT(GTZC_TZSC1->PRIVCFGR2, TZSC1_PRIVCFGR2_ALL);
 c03e504:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 c03e506:	f422 72ff 	bic.w	r2, r2, #510	@ 0x1fe
 c03e50a:	f022 0201 	bic.w	r2, r2, #1
 c03e50e:	625a      	str	r2, [r3, #36]	@ 0x24
      CLEAR_BIT(GTZC_TZSC1->PRIVCFGR3, TZSC1_PRIVCFGR3_ALL);
 c03e510:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
 c03e512:	0dd2      	lsrs	r2, r2, #23
 c03e514:	05d2      	lsls	r2, r2, #23
 c03e516:	629a      	str	r2, [r3, #40]	@ 0x28
      CLEAR_BIT(GTZC_TZSC2->PRIVCFGR1, TZSC2_PRIVCFGR1_ALL);
 c03e518:	4a21      	ldr	r2, [pc, #132]	@ (c03e5a0 <HAL_GTZC_TZSC_ConfigPeriphAttributes+0x194>)
 c03e51a:	6a13      	ldr	r3, [r2, #32]
 c03e51c:	f423 53df 	bic.w	r3, r3, #7136	@ 0x1be0
 c03e520:	f023 031f 	bic.w	r3, r3, #31
 c03e524:	e7cc      	b.n	c03e4c0 <HAL_GTZC_TZSC_ConfigPeriphAttributes+0xb4>
    register_address = (uint32_t) &(HAL_GTZC_TZSC_GET_INSTANCE(PeriphId)->SECCFGR1)
 c03e526:	4d1e      	ldr	r5, [pc, #120]	@ (c03e5a0 <HAL_GTZC_TZSC_ConfigPeriphAttributes+0x194>)
 c03e528:	4a1c      	ldr	r2, [pc, #112]	@ (c03e59c <HAL_GTZC_TZSC_ConfigPeriphAttributes+0x190>)
                       + (4U * GTZC_GET_REG_INDEX_IN_INSTANCE(PeriphId));
 c03e52a:	f000 4070 	and.w	r0, r0, #4026531840	@ 0xf0000000
    register_address = (uint32_t) &(HAL_GTZC_TZSC_GET_INSTANCE(PeriphId)->SECCFGR1)
 c03e52e:	2b03      	cmp	r3, #3
 c03e530:	bf88      	it	hi
 c03e532:	462a      	movhi	r2, r5
                       + (4U * GTZC_GET_REG_INDEX_IN_INSTANCE(PeriphId));
 c03e534:	f1b0 5f40 	cmp.w	r0, #805306368	@ 0x30000000
    if ((PeriphAttributes & GTZC_TZSC_PERIPH_SEC) == GTZC_TZSC_PERIPH_SEC)
 c03e538:	f240 1001 	movw	r0, #257	@ 0x101
                       + (4U * GTZC_GET_REG_INDEX_IN_INSTANCE(PeriphId));
 c03e53c:	bf88      	it	hi
 c03e53e:	3b04      	subhi	r3, #4
    register_address = (uint32_t) &(HAL_GTZC_TZSC_GET_INSTANCE(PeriphId)->SECCFGR1)
 c03e540:	f102 0510 	add.w	r5, r2, #16
                       + (4U * GTZC_GET_REG_INDEX_IN_INSTANCE(PeriphId));
 c03e544:	009b      	lsls	r3, r3, #2
    if ((PeriphAttributes & GTZC_TZSC_PERIPH_SEC) == GTZC_TZSC_PERIPH_SEC)
 c03e546:	4388      	bics	r0, r1
    register_address = (uint32_t) &(HAL_GTZC_TZSC_GET_INSTANCE(PeriphId)->SECCFGR1)
 c03e548:	eb05 0603 	add.w	r6, r5, r3
    if ((PeriphAttributes & GTZC_TZSC_PERIPH_SEC) == GTZC_TZSC_PERIPH_SEC)
 c03e54c:	d111      	bne.n	c03e572 <HAL_GTZC_TZSC_ConfigPeriphAttributes+0x166>
      SET_BIT(*(__IO uint32_t *)register_address, 1UL << GTZC_GET_PERIPH_POS(PeriphId));
 c03e54e:	2001      	movs	r0, #1
 c03e550:	58ee      	ldr	r6, [r5, r3]
 c03e552:	40a0      	lsls	r0, r4
 c03e554:	4330      	orrs	r0, r6
 c03e556:	50e8      	str	r0, [r5, r3]
    if ((PeriphAttributes & GTZC_TZSC_PERIPH_PRIV) == GTZC_TZSC_PERIPH_PRIV)
 c03e558:	f240 2502 	movw	r5, #514	@ 0x202
    register_address = (uint32_t) &(HAL_GTZC_TZSC_GET_INSTANCE(PeriphId)->PRIVCFGR1)
 c03e55c:	3220      	adds	r2, #32
    if ((PeriphAttributes & GTZC_TZSC_PERIPH_PRIV) == GTZC_TZSC_PERIPH_PRIV)
 c03e55e:	438d      	bics	r5, r1
    register_address = (uint32_t) &(HAL_GTZC_TZSC_GET_INSTANCE(PeriphId)->PRIVCFGR1)
 c03e560:	eb02 0003 	add.w	r0, r2, r3
    if ((PeriphAttributes & GTZC_TZSC_PERIPH_PRIV) == GTZC_TZSC_PERIPH_PRIV)
 c03e564:	d10e      	bne.n	c03e584 <HAL_GTZC_TZSC_ConfigPeriphAttributes+0x178>
      SET_BIT(*(__IO uint32_t *)register_address, 1UL << GTZC_GET_PERIPH_POS(PeriphId));
 c03e566:	2101      	movs	r1, #1
 c03e568:	58d0      	ldr	r0, [r2, r3]
 c03e56a:	40a1      	lsls	r1, r4
 c03e56c:	4301      	orrs	r1, r0
 c03e56e:	50d1      	str	r1, [r2, r3]
 c03e570:	e7a7      	b.n	c03e4c2 <HAL_GTZC_TZSC_ConfigPeriphAttributes+0xb6>
    else if ((PeriphAttributes & GTZC_TZSC_PERIPH_NSEC) == GTZC_TZSC_PERIPH_NSEC)
 c03e572:	05c8      	lsls	r0, r1, #23
 c03e574:	d5f0      	bpl.n	c03e558 <HAL_GTZC_TZSC_ConfigPeriphAttributes+0x14c>
      CLEAR_BIT(*(__IO uint32_t *)register_address, 1UL << GTZC_GET_PERIPH_POS(PeriphId));
 c03e576:	2501      	movs	r5, #1
 c03e578:	6830      	ldr	r0, [r6, #0]
 c03e57a:	40a5      	lsls	r5, r4
 c03e57c:	ea20 0005 	bic.w	r0, r0, r5
 c03e580:	6030      	str	r0, [r6, #0]
 c03e582:	e7e9      	b.n	c03e558 <HAL_GTZC_TZSC_ConfigPeriphAttributes+0x14c>
    else if ((PeriphAttributes & GTZC_TZSC_PERIPH_NPRIV) == GTZC_TZSC_PERIPH_NPRIV)
 c03e584:	058b      	lsls	r3, r1, #22
 c03e586:	d59c      	bpl.n	c03e4c2 <HAL_GTZC_TZSC_ConfigPeriphAttributes+0xb6>
      CLEAR_BIT(*(__IO uint32_t *)register_address, 1UL << GTZC_GET_PERIPH_POS(PeriphId));
 c03e588:	2201      	movs	r2, #1
 c03e58a:	6803      	ldr	r3, [r0, #0]
 c03e58c:	40a2      	lsls	r2, r4
 c03e58e:	ea23 0302 	bic.w	r3, r3, r2
 c03e592:	6003      	str	r3, [r0, #0]
 c03e594:	e795      	b.n	c03e4c2 <HAL_GTZC_TZSC_ConfigPeriphAttributes+0xb6>
    return HAL_ERROR;
 c03e596:	2001      	movs	r0, #1
 c03e598:	e794      	b.n	c03e4c4 <HAL_GTZC_TZSC_ConfigPeriphAttributes+0xb8>
 c03e59a:	bf00      	nop
 c03e59c:	50032400 	.word	0x50032400
 c03e5a0:	56023000 	.word	0x56023000

0c03e5a4 <HAL_GTZC_TZSC_GetConfigPeriphAttributes>:
  *         GTZC_TZSC_PERIPH_NUMBER elements is to be provided.
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_GTZC_TZSC_GetConfigPeriphAttributes(uint32_t PeriphId,
                                                          uint32_t *PeriphAttributes)
{
 c03e5a4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t i;
  uint32_t reg_value;
  uint32_t register_address;

  /* check entry parameters */
  if ((PeriphAttributes == NULL)
 c03e5a8:	2900      	cmp	r1, #0
 c03e5aa:	f000 80f9 	beq.w	c03e7a0 <HAL_GTZC_TZSC_GetConfigPeriphAttributes+0x1fc>
 c03e5ae:	f1b0 4f80 	cmp.w	r0, #1073741824	@ 0x40000000
      || (HAL_GTZC_TZSC_GET_ARRAY_INDEX(PeriphId) >= GTZC_TZSC_PERIPH_NUMBER)
 c03e5b2:	ea4f 7310 	mov.w	r3, r0, lsr #28
 c03e5b6:	f000 041f 	and.w	r4, r0, #31
 c03e5ba:	bf2a      	itet	cs
 c03e5bc:	f103 32ff 	addcs.w	r2, r3, #4294967295	@ 0xffffffff
 c03e5c0:	eb04 1243 	addcc.w	r2, r4, r3, lsl #5
 c03e5c4:	eb04 1242 	addcs.w	r2, r4, r2, lsl #5
 c03e5c8:	2a6c      	cmp	r2, #108	@ 0x6c
 c03e5ca:	f200 80e9 	bhi.w	c03e7a0 <HAL_GTZC_TZSC_GetConfigPeriphAttributes+0x1fc>
      || (((PeriphId & GTZC_PERIPH_ALL) != 0U)
 c03e5ce:	0682      	lsls	r2, r0, #26
 c03e5d0:	f140 80c1 	bpl.w	c03e756 <HAL_GTZC_TZSC_GetConfigPeriphAttributes+0x1b2>
  if ((PeriphAttributes == NULL)
 c03e5d4:	2b03      	cmp	r3, #3
 c03e5d6:	f200 80e3 	bhi.w	c03e7a0 <HAL_GTZC_TZSC_GetConfigPeriphAttributes+0x1fc>
          && (HAL_GTZC_TZSC_GET_ARRAY_INDEX(PeriphId) != 0U)))
 c03e5da:	eb14 1343 	adds.w	r3, r4, r3, lsl #5
 c03e5de:	f040 80df 	bne.w	c03e7a0 <HAL_GTZC_TZSC_GetConfigPeriphAttributes+0x1fc>
  if ((PeriphId & GTZC_PERIPH_ALL) != 0U)
  {
    /* get secure configuration: read each register and deploy each bit value
     * of corresponding index in the destination array
     */
    reg_value = READ_REG(GTZC_TZSC1->SECCFGR1);
 c03e5e2:	4a70      	ldr	r2, [pc, #448]	@ (c03e7a4 <HAL_GTZC_TZSC_GetConfigPeriphAttributes+0x200>)
    for (i = 0U; i < 32U; i++)
    {
      if (((reg_value & (1UL << i)) >> i) != 0U)
 c03e5e4:	2601      	movs	r6, #1
    reg_value = READ_REG(GTZC_TZSC1->SECCFGR1);
 c03e5e6:	6915      	ldr	r5, [r2, #16]
      if (((reg_value & (1UL << i)) >> i) != 0U)
 c03e5e8:	f240 1401 	movw	r4, #257	@ 0x101
    for (i = 0U; i < 32U; i++)
 c03e5ec:	461a      	mov	r2, r3
      if (((reg_value & (1UL << i)) >> i) != 0U)
 c03e5ee:	fa06 f002 	lsl.w	r0, r6, r2
 c03e5f2:	4028      	ands	r0, r5
 c03e5f4:	40d0      	lsrs	r0, r2
 c03e5f6:	bf14      	ite	ne
 c03e5f8:	4620      	movne	r0, r4
 c03e5fa:	f44f 7080 	moveq.w	r0, #256	@ 0x100
      {
        PeriphAttributes[i] = GTZC_TZSC_PERIPH_SEC;
 c03e5fe:	f841 0022 	str.w	r0, [r1, r2, lsl #2]
    for (i = 0U; i < 32U; i++)
 c03e602:	3201      	adds	r2, #1
 c03e604:	2a20      	cmp	r2, #32
 c03e606:	d1f2      	bne.n	c03e5ee <HAL_GTZC_TZSC_GetConfigPeriphAttributes+0x4a>
      {
        PeriphAttributes[i] = GTZC_TZSC_PERIPH_NSEC;
      }
    }

    reg_value = READ_REG(GTZC_TZSC1->SECCFGR2);
 c03e608:	4a66      	ldr	r2, [pc, #408]	@ (c03e7a4 <HAL_GTZC_TZSC_GetConfigPeriphAttributes+0x200>)
 c03e60a:	f101 067c 	add.w	r6, r1, #124	@ 0x7c
 c03e60e:	6957      	ldr	r7, [r2, #20]
 c03e610:	4634      	mov	r4, r6
 c03e612:	2200      	movs	r2, #0
    for (i = 32U; i < 64U; i++)
    {
      if (((reg_value & (1UL << (i - 32U))) >> (i - 32U)) != 0U)
 c03e614:	f04f 0c01 	mov.w	ip, #1
 c03e618:	f240 1501 	movw	r5, #257	@ 0x101
 c03e61c:	fa0c f002 	lsl.w	r0, ip, r2
 c03e620:	4038      	ands	r0, r7
 c03e622:	40d0      	lsrs	r0, r2
 c03e624:	bf14      	ite	ne
 c03e626:	4628      	movne	r0, r5
 c03e628:	f44f 7080 	moveq.w	r0, #256	@ 0x100
    for (i = 32U; i < 64U; i++)
 c03e62c:	3201      	adds	r2, #1
 c03e62e:	2a20      	cmp	r2, #32
      {
        PeriphAttributes[i] = GTZC_TZSC_PERIPH_SEC;
 c03e630:	f844 0f04 	str.w	r0, [r4, #4]!
    for (i = 32U; i < 64U; i++)
 c03e634:	d1f2      	bne.n	c03e61c <HAL_GTZC_TZSC_GetConfigPeriphAttributes+0x78>
      {
        PeriphAttributes[i] = GTZC_TZSC_PERIPH_NSEC;
      }
    }

    reg_value = READ_REG(GTZC_TZSC1->SECCFGR3);
 c03e636:	4a5b      	ldr	r2, [pc, #364]	@ (c03e7a4 <HAL_GTZC_TZSC_GetConfigPeriphAttributes+0x200>)
 c03e638:	f101 05fc 	add.w	r5, r1, #252	@ 0xfc
 c03e63c:	f8d2 c018 	ldr.w	ip, [r2, #24]
 c03e640:	462c      	mov	r4, r5
 c03e642:	2200      	movs	r2, #0
    for (i = 64U; i < 96U; i++)
    {
      if (((reg_value & (1UL << (i - 64U))) >> (i - 64U)) != 0U)
 c03e644:	f04f 0e01 	mov.w	lr, #1
 c03e648:	f240 1701 	movw	r7, #257	@ 0x101
 c03e64c:	fa0e f002 	lsl.w	r0, lr, r2
 c03e650:	ea00 000c 	and.w	r0, r0, ip
 c03e654:	40d0      	lsrs	r0, r2
 c03e656:	bf14      	ite	ne
 c03e658:	4638      	movne	r0, r7
 c03e65a:	f44f 7080 	moveq.w	r0, #256	@ 0x100
    for (i = 64U; i < 96U; i++)
 c03e65e:	3201      	adds	r2, #1
 c03e660:	2a20      	cmp	r2, #32
      {
        PeriphAttributes[i] = GTZC_TZSC_PERIPH_SEC;
 c03e662:	f844 0f04 	str.w	r0, [r4, #4]!
    for (i = 64U; i < 96U; i++)
 c03e666:	d1f1      	bne.n	c03e64c <HAL_GTZC_TZSC_GetConfigPeriphAttributes+0xa8>
      {
        PeriphAttributes[i] = GTZC_TZSC_PERIPH_NSEC;
      }
    }

    reg_value = READ_REG(GTZC_TZSC2->SECCFGR1);
 c03e668:	4a4f      	ldr	r2, [pc, #316]	@ (c03e7a8 <HAL_GTZC_TZSC_GetConfigPeriphAttributes+0x204>)
 c03e66a:	f501 74be 	add.w	r4, r1, #380	@ 0x17c
 c03e66e:	f8d2 e010 	ldr.w	lr, [r2, #16]
 c03e672:	4627      	mov	r7, r4
 c03e674:	2200      	movs	r2, #0
    for (i = 96U; i < GTZC_TZSC_PERIPH_NUMBER; i++)
    {
      if (((reg_value & (1UL << (i - 96U))) >> (i - 96U)) != 0U)
 c03e676:	f04f 0801 	mov.w	r8, #1
 c03e67a:	f240 1c01 	movw	ip, #257	@ 0x101
 c03e67e:	fa08 f002 	lsl.w	r0, r8, r2
 c03e682:	ea00 000e 	and.w	r0, r0, lr
 c03e686:	40d0      	lsrs	r0, r2
 c03e688:	bf14      	ite	ne
 c03e68a:	4660      	movne	r0, ip
 c03e68c:	f44f 7080 	moveq.w	r0, #256	@ 0x100
    for (i = 96U; i < GTZC_TZSC_PERIPH_NUMBER; i++)
 c03e690:	3201      	adds	r2, #1
 c03e692:	2a0d      	cmp	r2, #13
      {
        PeriphAttributes[i] = GTZC_TZSC_PERIPH_SEC;
 c03e694:	f847 0f04 	str.w	r0, [r7, #4]!
    for (i = 96U; i < GTZC_TZSC_PERIPH_NUMBER; i++)
 c03e698:	d1f1      	bne.n	c03e67e <HAL_GTZC_TZSC_GetConfigPeriphAttributes+0xda>
    }

    /* get privilege configuration: read each register and deploy each bit value
     * of corresponding index in the destination array
     */
    reg_value = READ_REG(GTZC_TZSC1->PRIVCFGR1);
 c03e69a:	4a42      	ldr	r2, [pc, #264]	@ (c03e7a4 <HAL_GTZC_TZSC_GetConfigPeriphAttributes+0x200>)
    for (i = 0U; i < 32U; i++)
    {
      if (((reg_value & (1UL << i)) >> i) != 0U)
 c03e69c:	f04f 0e01 	mov.w	lr, #1
    reg_value = READ_REG(GTZC_TZSC1->PRIVCFGR1);
 c03e6a0:	f8d2 c020 	ldr.w	ip, [r2, #32]
      {
        PeriphAttributes[i] |= GTZC_TZSC_PERIPH_PRIV;
 c03e6a4:	f240 2802 	movw	r8, #514	@ 0x202
    for (i = 0U; i < 32U; i++)
 c03e6a8:	2200      	movs	r2, #0
 c03e6aa:	3904      	subs	r1, #4
      if (((reg_value & (1UL << i)) >> i) != 0U)
 c03e6ac:	fa0e f702 	lsl.w	r7, lr, r2
 c03e6b0:	ea07 070c 	and.w	r7, r7, ip
 c03e6b4:	40d7      	lsrs	r7, r2
        PeriphAttributes[i] |= GTZC_TZSC_PERIPH_PRIV;
 c03e6b6:	f851 0f04 	ldr.w	r0, [r1, #4]!
    for (i = 0U; i < 32U; i++)
 c03e6ba:	f102 0201 	add.w	r2, r2, #1
        PeriphAttributes[i] |= GTZC_TZSC_PERIPH_PRIV;
 c03e6be:	bf14      	ite	ne
 c03e6c0:	ea40 0008 	orrne.w	r0, r0, r8
      }
      else
      {
        PeriphAttributes[i] |= GTZC_TZSC_PERIPH_NPRIV;
 c03e6c4:	f440 7000 	orreq.w	r0, r0, #512	@ 0x200
    for (i = 0U; i < 32U; i++)
 c03e6c8:	2a20      	cmp	r2, #32
        PeriphAttributes[i] |= GTZC_TZSC_PERIPH_PRIV;
 c03e6ca:	6008      	str	r0, [r1, #0]
    for (i = 0U; i < 32U; i++)
 c03e6cc:	d1ee      	bne.n	c03e6ac <HAL_GTZC_TZSC_GetConfigPeriphAttributes+0x108>
      }
    }

    reg_value = READ_REG(GTZC_TZSC1->PRIVCFGR2);
 c03e6ce:	4a35      	ldr	r2, [pc, #212]	@ (c03e7a4 <HAL_GTZC_TZSC_GetConfigPeriphAttributes+0x200>)
    for (i = 32U; i < 64U; i++)
    {
      if (((reg_value & (1UL << (i - 32U))) >> (i - 32U)) != 0U)
 c03e6d0:	f04f 0c01 	mov.w	ip, #1
    reg_value = READ_REG(GTZC_TZSC1->PRIVCFGR2);
 c03e6d4:	6a57      	ldr	r7, [r2, #36]	@ 0x24
      {
        PeriphAttributes[i] |= GTZC_TZSC_PERIPH_PRIV;
 c03e6d6:	f240 2e02 	movw	lr, #514	@ 0x202
    reg_value = READ_REG(GTZC_TZSC1->PRIVCFGR2);
 c03e6da:	2200      	movs	r2, #0
      if (((reg_value & (1UL << (i - 32U))) >> (i - 32U)) != 0U)
 c03e6dc:	fa0c f002 	lsl.w	r0, ip, r2
 c03e6e0:	4038      	ands	r0, r7
 c03e6e2:	40d0      	lsrs	r0, r2
        PeriphAttributes[i] |= GTZC_TZSC_PERIPH_PRIV;
 c03e6e4:	f856 1f04 	ldr.w	r1, [r6, #4]!
    for (i = 32U; i < 64U; i++)
 c03e6e8:	f102 0201 	add.w	r2, r2, #1
        PeriphAttributes[i] |= GTZC_TZSC_PERIPH_PRIV;
 c03e6ec:	bf14      	ite	ne
 c03e6ee:	ea41 010e 	orrne.w	r1, r1, lr
      }
      else
      {
        PeriphAttributes[i] |= GTZC_TZSC_PERIPH_NPRIV;
 c03e6f2:	f441 7100 	orreq.w	r1, r1, #512	@ 0x200
    for (i = 32U; i < 64U; i++)
 c03e6f6:	2a20      	cmp	r2, #32
        PeriphAttributes[i] |= GTZC_TZSC_PERIPH_PRIV;
 c03e6f8:	6031      	str	r1, [r6, #0]
    for (i = 32U; i < 64U; i++)
 c03e6fa:	d1ef      	bne.n	c03e6dc <HAL_GTZC_TZSC_GetConfigPeriphAttributes+0x138>
      }
    }

    reg_value = READ_REG(GTZC_TZSC1->PRIVCFGR3);
 c03e6fc:	4a29      	ldr	r2, [pc, #164]	@ (c03e7a4 <HAL_GTZC_TZSC_GetConfigPeriphAttributes+0x200>)
    for (i = 64U; i < 96U; i++)
    {
      if (((reg_value & (1UL << (i - 64U))) >> (i - 64U)) != 0U)
 c03e6fe:	2701      	movs	r7, #1
    reg_value = READ_REG(GTZC_TZSC1->PRIVCFGR3);
 c03e700:	6a96      	ldr	r6, [r2, #40]	@ 0x28
      {
        PeriphAttributes[i] |= GTZC_TZSC_PERIPH_PRIV;
 c03e702:	f240 2c02 	movw	ip, #514	@ 0x202
    reg_value = READ_REG(GTZC_TZSC1->PRIVCFGR3);
 c03e706:	2200      	movs	r2, #0
      if (((reg_value & (1UL << (i - 64U))) >> (i - 64U)) != 0U)
 c03e708:	fa07 f002 	lsl.w	r0, r7, r2
 c03e70c:	4030      	ands	r0, r6
 c03e70e:	40d0      	lsrs	r0, r2
        PeriphAttributes[i] |= GTZC_TZSC_PERIPH_PRIV;
 c03e710:	f855 1f04 	ldr.w	r1, [r5, #4]!
    for (i = 64U; i < 96U; i++)
 c03e714:	f102 0201 	add.w	r2, r2, #1
        PeriphAttributes[i] |= GTZC_TZSC_PERIPH_PRIV;
 c03e718:	bf14      	ite	ne
 c03e71a:	ea41 010c 	orrne.w	r1, r1, ip
      }
      else
      {
        PeriphAttributes[i] |= GTZC_TZSC_PERIPH_NPRIV;
 c03e71e:	f441 7100 	orreq.w	r1, r1, #512	@ 0x200
    for (i = 64U; i < 96U; i++)
 c03e722:	2a20      	cmp	r2, #32
        PeriphAttributes[i] |= GTZC_TZSC_PERIPH_PRIV;
 c03e724:	6029      	str	r1, [r5, #0]
    for (i = 64U; i < 96U; i++)
 c03e726:	d1ef      	bne.n	c03e708 <HAL_GTZC_TZSC_GetConfigPeriphAttributes+0x164>
    }

    reg_value = READ_REG(GTZC_TZSC2->PRIVCFGR1);
    for (i = 96U; i < GTZC_TZSC_PERIPH_NUMBER; i++)
    {
      if (((reg_value & (1UL << (i - 96U))) >> (i - 96U)) != 0U)
 c03e728:	2501      	movs	r5, #1
      {
        PeriphAttributes[i] |= GTZC_TZSC_PERIPH_PRIV;
 c03e72a:	f240 2602 	movw	r6, #514	@ 0x202
    reg_value = READ_REG(GTZC_TZSC2->PRIVCFGR1);
 c03e72e:	4a1e      	ldr	r2, [pc, #120]	@ (c03e7a8 <HAL_GTZC_TZSC_GetConfigPeriphAttributes+0x204>)
 c03e730:	6a10      	ldr	r0, [r2, #32]
      if (((reg_value & (1UL << (i - 96U))) >> (i - 96U)) != 0U)
 c03e732:	fa05 f103 	lsl.w	r1, r5, r3
 c03e736:	4001      	ands	r1, r0
 c03e738:	40d9      	lsrs	r1, r3
        PeriphAttributes[i] |= GTZC_TZSC_PERIPH_PRIV;
 c03e73a:	f854 2f04 	ldr.w	r2, [r4, #4]!
    for (i = 96U; i < GTZC_TZSC_PERIPH_NUMBER; i++)
 c03e73e:	f103 0301 	add.w	r3, r3, #1
        PeriphAttributes[i] |= GTZC_TZSC_PERIPH_PRIV;
 c03e742:	bf14      	ite	ne
 c03e744:	4332      	orrne	r2, r6
      }
      else
      {
        PeriphAttributes[i] |= GTZC_TZSC_PERIPH_NPRIV;
 c03e746:	f442 7200 	orreq.w	r2, r2, #512	@ 0x200
    for (i = 96U; i < GTZC_TZSC_PERIPH_NUMBER; i++)
 c03e74a:	2b0d      	cmp	r3, #13
        PeriphAttributes[i] |= GTZC_TZSC_PERIPH_PRIV;
 c03e74c:	6022      	str	r2, [r4, #0]
    for (i = 96U; i < GTZC_TZSC_PERIPH_NUMBER; i++)
 c03e74e:	d1f0      	bne.n	c03e732 <HAL_GTZC_TZSC_GetConfigPeriphAttributes+0x18e>
    else
    {
      *PeriphAttributes |= GTZC_TZSC_PERIPH_NPRIV;
    }
  }
  return HAL_OK;
 c03e750:	2000      	movs	r0, #0
}
 c03e752:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    register_address = (uint32_t) &(HAL_GTZC_TZSC_GET_INSTANCE(PeriphId)->SECCFGR1)
 c03e756:	4a14      	ldr	r2, [pc, #80]	@ (c03e7a8 <HAL_GTZC_TZSC_GetConfigPeriphAttributes+0x204>)
 c03e758:	4d12      	ldr	r5, [pc, #72]	@ (c03e7a4 <HAL_GTZC_TZSC_GetConfigPeriphAttributes+0x200>)
                       + (4U * GTZC_GET_REG_INDEX_IN_INSTANCE(PeriphId));
 c03e75a:	f000 4070 	and.w	r0, r0, #4026531840	@ 0xf0000000
    register_address = (uint32_t) &(HAL_GTZC_TZSC_GET_INSTANCE(PeriphId)->SECCFGR1)
 c03e75e:	2b03      	cmp	r3, #3
 c03e760:	bf88      	it	hi
 c03e762:	4615      	movhi	r5, r2
                       + (4U * GTZC_GET_REG_INDEX_IN_INSTANCE(PeriphId));
 c03e764:	f1b0 5f40 	cmp.w	r0, #805306368	@ 0x30000000
    if (((READ_BIT(*(__IO uint32_t *)register_address,
 c03e768:	f04f 0001 	mov.w	r0, #1
                       + (4U * GTZC_GET_REG_INDEX_IN_INSTANCE(PeriphId));
 c03e76c:	bf88      	it	hi
 c03e76e:	3b04      	subhi	r3, #4
    register_address = (uint32_t) &(HAL_GTZC_TZSC_GET_INSTANCE(PeriphId)->SECCFGR1)
 c03e770:	f105 0210 	add.w	r2, r5, #16
                       + (4U * GTZC_GET_REG_INDEX_IN_INSTANCE(PeriphId));
 c03e774:	009b      	lsls	r3, r3, #2
    if (((READ_BIT(*(__IO uint32_t *)register_address,
 c03e776:	58d2      	ldr	r2, [r2, r3]
 c03e778:	40a0      	lsls	r0, r4
 c03e77a:	4002      	ands	r2, r0
      *PeriphAttributes = GTZC_TZSC_PERIPH_SEC;
 c03e77c:	40e2      	lsrs	r2, r4
 c03e77e:	f240 1201 	movw	r2, #257	@ 0x101
 c03e782:	bf08      	it	eq
 c03e784:	f44f 7280 	moveq.w	r2, #256	@ 0x100
    register_address = (uint32_t) &(HAL_GTZC_TZSC_GET_INSTANCE(PeriphId)->PRIVCFGR1)
 c03e788:	3520      	adds	r5, #32
 c03e78a:	600a      	str	r2, [r1, #0]
    if (((READ_BIT(*(__IO uint32_t *)register_address,
 c03e78c:	58eb      	ldr	r3, [r5, r3]
      *PeriphAttributes |= GTZC_TZSC_PERIPH_PRIV;
 c03e78e:	f442 7200 	orr.w	r2, r2, #512	@ 0x200
    if (((READ_BIT(*(__IO uint32_t *)register_address,
 c03e792:	4018      	ands	r0, r3
 c03e794:	40e0      	lsrs	r0, r4
      *PeriphAttributes |= GTZC_TZSC_PERIPH_PRIV;
 c03e796:	bf18      	it	ne
 c03e798:	f042 0202 	orrne.w	r2, r2, #2
      *PeriphAttributes |= GTZC_TZSC_PERIPH_NPRIV;
 c03e79c:	600a      	str	r2, [r1, #0]
 c03e79e:	e7d7      	b.n	c03e750 <HAL_GTZC_TZSC_GetConfigPeriphAttributes+0x1ac>
    return HAL_ERROR;
 c03e7a0:	2001      	movs	r0, #1
 c03e7a2:	e7d6      	b.n	c03e752 <HAL_GTZC_TZSC_GetConfigPeriphAttributes+0x1ae>
 c03e7a4:	50032400 	.word	0x50032400
 c03e7a8:	56023000 	.word	0x56023000

0c03e7ac <HAL_GTZC_TZSC_Lock>:
  *         registers until next reset
  * @param  TZSC_Instance TZSC sub-block instance.
  */
void HAL_GTZC_TZSC_Lock(GTZC_TZSC_TypeDef *TZSC_Instance)
{
  SET_BIT(TZSC_Instance->CR, GTZC_TZSC_CR_LCK_Msk);
 c03e7ac:	6803      	ldr	r3, [r0, #0]
 c03e7ae:	f043 0301 	orr.w	r3, r3, #1
 c03e7b2:	6003      	str	r3, [r0, #0]
}
 c03e7b4:	4770      	bx	lr
	...

0c03e7b8 <HAL_GTZC_MPCBB_ConfigMem>:
  uint32_t mem_size;
  uint32_t size_in_superblocks;
  uint32_t i;

  /* check entry parameters */
  if ((!(IS_GTZC_BASE_ADDRESS(SRAM1, MemBaseAddress))
 c03e7b8:	f020 5380 	bic.w	r3, r0, #268435456	@ 0x10000000
 c03e7bc:	f423 2380 	bic.w	r3, r3, #262144	@ 0x40000
 c03e7c0:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
{
 c03e7c4:	b5f0      	push	{r4, r5, r6, r7, lr}
  if ((!(IS_GTZC_BASE_ADDRESS(SRAM1, MemBaseAddress))
 c03e7c6:	d007      	beq.n	c03e7d8 <HAL_GTZC_MPCBB_ConfigMem+0x20>
       &&  !(IS_GTZC_BASE_ADDRESS(SRAM2, MemBaseAddress))
 c03e7c8:	4a2d      	ldr	r2, [pc, #180]	@ (c03e880 <HAL_GTZC_MPCBB_ConfigMem+0xc8>)
 c03e7ca:	f020 5380 	bic.w	r3, r0, #268435456	@ 0x10000000
 c03e7ce:	4293      	cmp	r3, r2
 c03e7d0:	d002      	beq.n	c03e7d8 <HAL_GTZC_MPCBB_ConfigMem+0x20>
#if defined (SRAM3_BASE)
       &&  !(IS_GTZC_BASE_ADDRESS(SRAM3, MemBaseAddress))
#endif /* SRAM3_BASE */
       &&  !(IS_GTZC_BASE_ADDRESS(SRAM4, MemBaseAddress))
 c03e7d2:	f1b3 5f20 	cmp.w	r3, #671088640	@ 0x28000000
 c03e7d6:	d150      	bne.n	c03e87a <HAL_GTZC_MPCBB_ConfigMem+0xc2>
#endif /* SRAM5_BASE */
#if defined (SRAM6_BASE)
       &&  !(IS_GTZC_BASE_ADDRESS(SRAM6, MemBaseAddress))
#endif /* SRAM6_BASE */
      )
      || ((pMPCBB_desc->SecureRWIllegalMode != GTZC_MPCBB_SRWILADIS_ENABLE)
 c03e7d8:	680c      	ldr	r4, [r1, #0]
 c03e7da:	f034 4300 	bics.w	r3, r4, #2147483648	@ 0x80000000
 c03e7de:	d14c      	bne.n	c03e87a <HAL_GTZC_MPCBB_ConfigMem+0xc2>
          && (pMPCBB_desc->SecureRWIllegalMode != GTZC_MPCBB_SRWILADIS_DISABLE))
      || ((pMPCBB_desc->InvertSecureState != GTZC_MPCBB_INVSECSTATE_NOT_INVERTED)
 c03e7e0:	684d      	ldr	r5, [r1, #4]
 c03e7e2:	f035 4680 	bics.w	r6, r5, #1073741824	@ 0x40000000
 c03e7e6:	d148      	bne.n	c03e87a <HAL_GTZC_MPCBB_ConfigMem+0xc2>
          && (pMPCBB_desc->InvertSecureState != GTZC_MPCBB_INVSECSTATE_INVERTED)))
  {
    return HAL_ERROR;
  }

  if (IS_GTZC_BASE_ADDRESS(SRAM1, MemBaseAddress))
 c03e7e8:	f020 5080 	bic.w	r0, r0, #268435456	@ 0x10000000
 c03e7ec:	f1b0 5f00 	cmp.w	r0, #536870912	@ 0x20000000
 c03e7f0:	d037      	beq.n	c03e862 <HAL_GTZC_MPCBB_ConfigMem+0xaa>
  {
    mpcbb_ptr = GTZC_MPCBB1;
    mem_size = GTZC_MEM_SIZE(SRAM1);
  }
  else if (IS_GTZC_BASE_ADDRESS(SRAM2, MemBaseAddress))
 c03e7f2:	4b23      	ldr	r3, [pc, #140]	@ (c03e880 <HAL_GTZC_MPCBB_ConfigMem+0xc8>)
 c03e7f4:	4298      	cmp	r0, r3
 c03e7f6:	d038      	beq.n	c03e86a <HAL_GTZC_MPCBB_ConfigMem+0xb2>
  {
    mpcbb_ptr = GTZC_MPCBB2;
    mem_size = GTZC_MEM_SIZE(SRAM2);
  }
#if defined (SRAM3_BASE)
  else if (IS_GTZC_BASE_ADDRESS(SRAM3, MemBaseAddress))
 c03e7f8:	f503 3380 	add.w	r3, r3, #65536	@ 0x10000
 c03e7fc:	4298      	cmp	r0, r3
 c03e7fe:	d038      	beq.n	c03e872 <HAL_GTZC_MPCBB_ConfigMem+0xba>
  {
    mpcbb_ptr = GTZC_MPCBB3;
    mem_size = GTZC_MEM_SIZE(SRAM3);
  }
#endif /* SRAM3_BASE */
  else if (IS_GTZC_BASE_ADDRESS(SRAM4, MemBaseAddress))
 c03e800:	f1b0 5f20 	cmp.w	r0, #671088640	@ 0x28000000
 c03e804:	d139      	bne.n	c03e87a <HAL_GTZC_MPCBB_ConfigMem+0xc2>
  {
    mpcbb_ptr = GTZC_MPCBB4;
    mem_size = GTZC_MEM_SIZE(SRAM4);
 c03e806:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
    mpcbb_ptr = GTZC_MPCBB4;
 c03e80a:	4a1e      	ldr	r2, [pc, #120]	@ (c03e884 <HAL_GTZC_MPCBB_ConfigMem+0xcc>)

  /* translate mem_size in number of super-blocks  */
  size_in_superblocks = (mem_size / GTZC_MPCBB_SUPERBLOCK_SIZE);

  /* write PRIVCFGR register information */
  for (i = 0U; i < size_in_superblocks; i++)
 c03e80c:	2000      	movs	r0, #0
  size_in_superblocks = (mem_size / GTZC_MPCBB_SUPERBLOCK_SIZE);
 c03e80e:	0b9b      	lsrs	r3, r3, #14
  for (i = 0U; i < size_in_superblocks; i++)
 c03e810:	f101 0784 	add.w	r7, r1, #132	@ 0x84
  {
    WRITE_REG(mpcbb_ptr->PRIVCFGR[i],
 c03e814:	f100 0c80 	add.w	ip, r0, #128	@ 0x80
 c03e818:	f857 ef04 	ldr.w	lr, [r7, #4]!
  for (i = 0U; i < size_in_superblocks; i++)
 c03e81c:	3001      	adds	r0, #1
 c03e81e:	4283      	cmp	r3, r0
    WRITE_REG(mpcbb_ptr->PRIVCFGR[i],
 c03e820:	f842 e02c 	str.w	lr, [r2, ip, lsl #2]
  for (i = 0U; i < size_in_superblocks; i++)
 c03e824:	d1f6      	bne.n	c03e814 <HAL_GTZC_MPCBB_ConfigMem+0x5c>
 c03e826:	1d08      	adds	r0, r1, #4
  uint32_t reg_value;

  /* write SECCFGR register information */
  for (i = 0U; i < size_in_superblocks; i++)
  {
    WRITE_REG(mpcbb_ptr->SECCFGR[i],
 c03e828:	f106 0740 	add.w	r7, r6, #64	@ 0x40
 c03e82c:	f850 cf04 	ldr.w	ip, [r0, #4]!
  for (i = 0U; i < size_in_superblocks; i++)
 c03e830:	3601      	adds	r6, #1
 c03e832:	42b3      	cmp	r3, r6
    WRITE_REG(mpcbb_ptr->SECCFGR[i],
 c03e834:	f842 c027 	str.w	ip, [r2, r7, lsl #2]
  for (i = 0U; i < size_in_superblocks; i++)
 c03e838:	d1f6      	bne.n	c03e828 <HAL_GTZC_MPCBB_ConfigMem+0x70>
    MODIFY_REG(mpcbb_ptr->CFGLOCKR2, 0x000FFFFFUL, pMPCBB_desc->AttributeConfig.MPCBB_LockConfig_array[1]);
  }
  else
#endif /* GTZC_MPCBB_CFGLOCKR2_SPLCK32_Msk */
  {
    size_mask = (1UL << (size_in_superblocks & 0x1FU)) - 1U;
 c03e83a:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 c03e83e:	f003 031f 	and.w	r3, r3, #31
  }
  /* limitation: code not portable with memory > 512K */
  MODIFY_REG(mpcbb_ptr->CFGLOCKR1, size_mask, pMPCBB_desc->AttributeConfig.MPCBB_LockConfig_array[0]);
 c03e842:	fa00 f303 	lsl.w	r3, r0, r3
  /* write configuration and lock register information */
  MODIFY_REG(mpcbb_ptr->CR,
             GTZC_MPCBB_CR_INVSECSTATE_Msk | GTZC_MPCBB_CR_SRWILADIS_Msk, reg_value);
#endif /* defined(__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U) */

  return HAL_OK;
 c03e846:	2000      	movs	r0, #0
  MODIFY_REG(mpcbb_ptr->CFGLOCKR1, size_mask, pMPCBB_desc->AttributeConfig.MPCBB_LockConfig_array[0]);
 c03e848:	6916      	ldr	r6, [r2, #16]
 c03e84a:	f8d1 1108 	ldr.w	r1, [r1, #264]	@ 0x108
 c03e84e:	4033      	ands	r3, r6
 c03e850:	430b      	orrs	r3, r1
 c03e852:	6113      	str	r3, [r2, #16]
  MODIFY_REG(mpcbb_ptr->CR,
 c03e854:	6813      	ldr	r3, [r2, #0]
  reg_value |= pMPCBB_desc->SecureRWIllegalMode;
 c03e856:	432c      	orrs	r4, r5
  MODIFY_REG(mpcbb_ptr->CR,
 c03e858:	f023 4340 	bic.w	r3, r3, #3221225472	@ 0xc0000000
 c03e85c:	4323      	orrs	r3, r4
 c03e85e:	6013      	str	r3, [r2, #0]
}
 c03e860:	bdf0      	pop	{r4, r5, r6, r7, pc}
    mem_size = GTZC_MEM_SIZE(SRAM1);
 c03e862:	f44f 3340 	mov.w	r3, #196608	@ 0x30000
    mpcbb_ptr = GTZC_MPCBB1;
 c03e866:	4a08      	ldr	r2, [pc, #32]	@ (c03e888 <HAL_GTZC_MPCBB_ConfigMem+0xd0>)
 c03e868:	e7d0      	b.n	c03e80c <HAL_GTZC_MPCBB_ConfigMem+0x54>
    mem_size = GTZC_MEM_SIZE(SRAM2);
 c03e86a:	f44f 3380 	mov.w	r3, #65536	@ 0x10000
    mpcbb_ptr = GTZC_MPCBB2;
 c03e86e:	4a07      	ldr	r2, [pc, #28]	@ (c03e88c <HAL_GTZC_MPCBB_ConfigMem+0xd4>)
 c03e870:	e7cc      	b.n	c03e80c <HAL_GTZC_MPCBB_ConfigMem+0x54>
    mem_size = GTZC_MEM_SIZE(SRAM3);
 c03e872:	f44f 2300 	mov.w	r3, #524288	@ 0x80000
    mpcbb_ptr = GTZC_MPCBB3;
 c03e876:	4a06      	ldr	r2, [pc, #24]	@ (c03e890 <HAL_GTZC_MPCBB_ConfigMem+0xd8>)
 c03e878:	e7c8      	b.n	c03e80c <HAL_GTZC_MPCBB_ConfigMem+0x54>
    return HAL_ERROR;
 c03e87a:	2001      	movs	r0, #1
 c03e87c:	e7f0      	b.n	c03e860 <HAL_GTZC_MPCBB_ConfigMem+0xa8>
 c03e87e:	bf00      	nop
 c03e880:	20030000 	.word	0x20030000
 c03e884:	56023800 	.word	0x56023800
 c03e888:	50032c00 	.word	0x50032c00
 c03e88c:	50033000 	.word	0x50033000
 c03e890:	50033400 	.word	0x50033400

0c03e894 <HAL_GTZC_MPCBB_GetConfigMem>:
  uint32_t mem_size;
  uint32_t size_in_superblocks;
  uint32_t i;

  /* check entry parameters */
  if (!(IS_GTZC_BASE_ADDRESS(SRAM1, MemBaseAddress))
 c03e894:	f020 5080 	bic.w	r0, r0, #268435456	@ 0x10000000
 c03e898:	f1b0 5f00 	cmp.w	r0, #536870912	@ 0x20000000
{
 c03e89c:	b530      	push	{r4, r5, lr}
  if (!(IS_GTZC_BASE_ADDRESS(SRAM1, MemBaseAddress))
 c03e89e:	d035      	beq.n	c03e90c <HAL_GTZC_MPCBB_GetConfigMem+0x78>
      && !(IS_GTZC_BASE_ADDRESS(SRAM2, MemBaseAddress))
 c03e8a0:	4b21      	ldr	r3, [pc, #132]	@ (c03e928 <HAL_GTZC_MPCBB_GetConfigMem+0x94>)
 c03e8a2:	4298      	cmp	r0, r3
 c03e8a4:	d036      	beq.n	c03e914 <HAL_GTZC_MPCBB_GetConfigMem+0x80>
#if defined (SRAM3_BASE)
      && !(IS_GTZC_BASE_ADDRESS(SRAM3, MemBaseAddress))
 c03e8a6:	f503 3380 	add.w	r3, r3, #65536	@ 0x10000
 c03e8aa:	4298      	cmp	r0, r3
 c03e8ac:	d036      	beq.n	c03e91c <HAL_GTZC_MPCBB_GetConfigMem+0x88>
#endif /* SRAM3_BASE */
      && !(IS_GTZC_BASE_ADDRESS(SRAM4, MemBaseAddress))
 c03e8ae:	f1b0 5f20 	cmp.w	r0, #671088640	@ 0x28000000
 c03e8b2:	d137      	bne.n	c03e924 <HAL_GTZC_MPCBB_GetConfigMem+0x90>
  }
#endif /* SRAM3_BASE */
  else if (IS_GTZC_BASE_ADDRESS(SRAM4, MemBaseAddress))
  {
    mpcbb_ptr = GTZC_MPCBB4;
    mem_size = GTZC_MEM_SIZE(SRAM4);
 c03e8b4:	f44f 4280 	mov.w	r2, #16384	@ 0x4000
    mpcbb_ptr = GTZC_MPCBB4;
 c03e8b8:	4b1c      	ldr	r3, [pc, #112]	@ (c03e92c <HAL_GTZC_MPCBB_GetConfigMem+0x98>)

  /* read configuration and lock register information */
  reg_value = READ_REG(mpcbb_ptr->CR);
  pMPCBB_desc->InvertSecureState = (reg_value & GTZC_MPCBB_CR_INVSECSTATE_Msk);
  pMPCBB_desc->SecureRWIllegalMode = (reg_value & GTZC_MPCBB_CR_SRWILADIS_Msk);
  if (size_in_superblocks >= 32U)
 c03e8ba:	f5b2 2f00 	cmp.w	r2, #524288	@ 0x80000
  size_in_superblocks = (mem_size / GTZC_MPCBB_SUPERBLOCK_SIZE);
 c03e8be:	ea4f 3492 	mov.w	r4, r2, lsr #14
                                                             & 0x000FFFFFUL;
#endif /* GTZC_MPCBB_CFGLOCKR2_SPLCK32_Msk */
  }
  else
  {
    size_mask = (1UL << size_in_superblocks) - 1U;
 c03e8c2:	bf14      	ite	ne
 c03e8c4:	2201      	movne	r2, #1
    size_mask = 0xFFFFFFFFU;
 c03e8c6:	f04f 32ff 	moveq.w	r2, #4294967295	@ 0xffffffff
  reg_value = READ_REG(mpcbb_ptr->CR);
 c03e8ca:	6818      	ldr	r0, [r3, #0]
    size_mask = (1UL << size_in_superblocks) - 1U;
 c03e8cc:	bf18      	it	ne
 c03e8ce:	40a2      	lslne	r2, r4
  pMPCBB_desc->InvertSecureState = (reg_value & GTZC_MPCBB_CR_INVSECSTATE_Msk);
 c03e8d0:	f000 4580 	and.w	r5, r0, #1073741824	@ 0x40000000
  pMPCBB_desc->SecureRWIllegalMode = (reg_value & GTZC_MPCBB_CR_SRWILADIS_Msk);
 c03e8d4:	f000 4000 	and.w	r0, r0, #2147483648	@ 0x80000000
 c03e8d8:	6008      	str	r0, [r1, #0]
  }
  /* limitation: code not portable with memory > 512K */
  pMPCBB_desc->AttributeConfig.MPCBB_LockConfig_array[0] = READ_REG(mpcbb_ptr->CFGLOCKR1)
 c03e8da:	6918      	ldr	r0, [r3, #16]
    size_mask = (1UL << size_in_superblocks) - 1U;
 c03e8dc:	bf18      	it	ne
 c03e8de:	f102 32ff 	addne.w	r2, r2, #4294967295	@ 0xffffffff
                                                           & size_mask;
 c03e8e2:	4002      	ands	r2, r0
  pMPCBB_desc->AttributeConfig.MPCBB_LockConfig_array[0] = READ_REG(mpcbb_ptr->CFGLOCKR1)
 c03e8e4:	f8c1 2108 	str.w	r2, [r1, #264]	@ 0x108
#endif /* defined(__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U) */

  /* read SECCFGR / PRIVCFGR registers information */
  for (i = 0U; i < size_in_superblocks; i++)
 c03e8e8:	2200      	movs	r2, #0
  pMPCBB_desc->InvertSecureState = (reg_value & GTZC_MPCBB_CR_INVSECSTATE_Msk);
 c03e8ea:	604d      	str	r5, [r1, #4]
  for (i = 0U; i < size_in_superblocks; i++)
 c03e8ec:	3104      	adds	r1, #4
  {
    pMPCBB_desc->AttributeConfig.MPCBB_SecConfig_array[i] = mpcbb_ptr->SECCFGR[i];
 c03e8ee:	eb03 0082 	add.w	r0, r3, r2, lsl #2
 c03e8f2:	f8d0 5100 	ldr.w	r5, [r0, #256]	@ 0x100
  for (i = 0U; i < size_in_superblocks; i++)
 c03e8f6:	3201      	adds	r2, #1
    pMPCBB_desc->AttributeConfig.MPCBB_SecConfig_array[i] = mpcbb_ptr->SECCFGR[i];
 c03e8f8:	f841 5f04 	str.w	r5, [r1, #4]!
    pMPCBB_desc->AttributeConfig.MPCBB_PrivConfig_array[i] = mpcbb_ptr->PRIVCFGR[i];
 c03e8fc:	f8d0 0200 	ldr.w	r0, [r0, #512]	@ 0x200
  for (i = 0U; i < size_in_superblocks; i++)
 c03e900:	4294      	cmp	r4, r2
    pMPCBB_desc->AttributeConfig.MPCBB_PrivConfig_array[i] = mpcbb_ptr->PRIVCFGR[i];
 c03e902:	f8c1 0080 	str.w	r0, [r1, #128]	@ 0x80
  for (i = 0U; i < size_in_superblocks; i++)
 c03e906:	d1f2      	bne.n	c03e8ee <HAL_GTZC_MPCBB_GetConfigMem+0x5a>
  }

  return HAL_OK;
 c03e908:	2000      	movs	r0, #0
}
 c03e90a:	bd30      	pop	{r4, r5, pc}
    mem_size = GTZC_MEM_SIZE(SRAM1);
 c03e90c:	f44f 3240 	mov.w	r2, #196608	@ 0x30000
    mpcbb_ptr = GTZC_MPCBB1;
 c03e910:	4b07      	ldr	r3, [pc, #28]	@ (c03e930 <HAL_GTZC_MPCBB_GetConfigMem+0x9c>)
 c03e912:	e7d2      	b.n	c03e8ba <HAL_GTZC_MPCBB_GetConfigMem+0x26>
    mem_size = GTZC_MEM_SIZE(SRAM2);
 c03e914:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
    mpcbb_ptr = GTZC_MPCBB2;
 c03e918:	4b06      	ldr	r3, [pc, #24]	@ (c03e934 <HAL_GTZC_MPCBB_GetConfigMem+0xa0>)
 c03e91a:	e7ce      	b.n	c03e8ba <HAL_GTZC_MPCBB_GetConfigMem+0x26>
    mem_size = GTZC_MEM_SIZE(SRAM3);
 c03e91c:	f44f 2200 	mov.w	r2, #524288	@ 0x80000
    mpcbb_ptr = GTZC_MPCBB3;
 c03e920:	4b05      	ldr	r3, [pc, #20]	@ (c03e938 <HAL_GTZC_MPCBB_GetConfigMem+0xa4>)
 c03e922:	e7ca      	b.n	c03e8ba <HAL_GTZC_MPCBB_GetConfigMem+0x26>
    return HAL_ERROR;
 c03e924:	2001      	movs	r0, #1
 c03e926:	e7f0      	b.n	c03e90a <HAL_GTZC_MPCBB_GetConfigMem+0x76>
 c03e928:	20030000 	.word	0x20030000
 c03e92c:	56023800 	.word	0x56023800
 c03e930:	50032c00 	.word	0x50032c00
 c03e934:	50033000 	.word	0x50033000
 c03e938:	50033400 	.word	0x50033400

0c03e93c <HAL_GTZC_TZIC_EnableIT>:
  *         This parameter can be a value of @ref GTZC_TZSC_TZIC_PeriphId.
  *         Use GTZC_PERIPH_ALL to select all peripherals.
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_GTZC_TZIC_EnableIT(uint32_t PeriphId)
{
 c03e93c:	b510      	push	{r4, lr}
  uint32_t register_address;

  /* check entry parameters */
  if ((HAL_GTZC_TZIC_GET_ARRAY_INDEX(PeriphId) >= GTZC_TZIC_PERIPH_NUMBER)
 c03e93e:	0f03      	lsrs	r3, r0, #28
 c03e940:	f000 041f 	and.w	r4, r0, #31
 c03e944:	eb04 1243 	add.w	r2, r4, r3, lsl #5
 c03e948:	2ab9      	cmp	r2, #185	@ 0xb9
 c03e94a:	d826      	bhi.n	c03e99a <HAL_GTZC_TZIC_EnableIT+0x5e>
      || (((PeriphId & GTZC_PERIPH_ALL) != 0U)
 c03e94c:	0681      	lsls	r1, r0, #26
 c03e94e:	d512      	bpl.n	c03e976 <HAL_GTZC_TZIC_EnableIT+0x3a>
          && (HAL_GTZC_TZIC_GET_ARRAY_INDEX(PeriphId) != 0U)))
 c03e950:	bb1a      	cbnz	r2, c03e99a <HAL_GTZC_TZIC_EnableIT+0x5e>
  }

  if ((PeriphId & GTZC_PERIPH_ALL) != 0U)
  {
    /* same configuration is applied to all peripherals */
    WRITE_REG(GTZC_TZIC1->IER1, TZIC1_IER1_ALL);
 c03e952:	4b13      	ldr	r3, [pc, #76]	@ (c03e9a0 <HAL_GTZC_TZIC_EnableIT+0x64>)
 c03e954:	4a13      	ldr	r2, [pc, #76]	@ (c03e9a4 <HAL_GTZC_TZIC_EnableIT+0x68>)
 c03e956:	601a      	str	r2, [r3, #0]
    WRITE_REG(GTZC_TZIC1->IER2, TZIC1_IER2_ALL);
 c03e958:	f240 12ff 	movw	r2, #511	@ 0x1ff
 c03e95c:	605a      	str	r2, [r3, #4]
    WRITE_REG(GTZC_TZIC1->IER3, TZIC1_IER3_ALL);
 c03e95e:	4a12      	ldr	r2, [pc, #72]	@ (c03e9a8 <HAL_GTZC_TZIC_EnableIT+0x6c>)
 c03e960:	609a      	str	r2, [r3, #8]
    WRITE_REG(GTZC_TZIC1->IER4, TZIC1_IER4_ALL);
 c03e962:	4a12      	ldr	r2, [pc, #72]	@ (c03e9ac <HAL_GTZC_TZIC_EnableIT+0x70>)
 c03e964:	60da      	str	r2, [r3, #12]
    WRITE_REG(GTZC_TZIC2->IER1, TZIC2_IER1_ALL);
 c03e966:	f641 32ff 	movw	r2, #7167	@ 0x1bff
 c03e96a:	4b11      	ldr	r3, [pc, #68]	@ (c03e9b0 <HAL_GTZC_TZIC_EnableIT+0x74>)
 c03e96c:	601a      	str	r2, [r3, #0]
    WRITE_REG(GTZC_TZIC2->IER2, TZIC2_IER2_ALL);
 c03e96e:	4a11      	ldr	r2, [pc, #68]	@ (c03e9b4 <HAL_GTZC_TZIC_EnableIT+0x78>)
 c03e970:	605a      	str	r2, [r3, #4]
    register_address = (uint32_t) &(HAL_GTZC_TZIC_GET_INSTANCE(PeriphId)->IER1)
                       + (4U * GTZC_GET_REG_INDEX_IN_INSTANCE(PeriphId));
    SET_BIT(*(__IO uint32_t *)register_address, 1UL << GTZC_GET_PERIPH_POS(PeriphId));
  }

  return HAL_OK;
 c03e972:	2000      	movs	r0, #0
}
 c03e974:	bd10      	pop	{r4, pc}
    register_address = (uint32_t) &(HAL_GTZC_TZIC_GET_INSTANCE(PeriphId)->IER1)
 c03e976:	4a0e      	ldr	r2, [pc, #56]	@ (c03e9b0 <HAL_GTZC_TZIC_EnableIT+0x74>)
 c03e978:	4909      	ldr	r1, [pc, #36]	@ (c03e9a0 <HAL_GTZC_TZIC_EnableIT+0x64>)
                       + (4U * GTZC_GET_REG_INDEX_IN_INSTANCE(PeriphId));
 c03e97a:	f000 4070 	and.w	r0, r0, #4026531840	@ 0xf0000000
    register_address = (uint32_t) &(HAL_GTZC_TZIC_GET_INSTANCE(PeriphId)->IER1)
 c03e97e:	2b03      	cmp	r3, #3
 c03e980:	bf88      	it	hi
 c03e982:	4611      	movhi	r1, r2
    SET_BIT(*(__IO uint32_t *)register_address, 1UL << GTZC_GET_PERIPH_POS(PeriphId));
 c03e984:	2201      	movs	r2, #1
                       + (4U * GTZC_GET_REG_INDEX_IN_INSTANCE(PeriphId));
 c03e986:	f1b0 5f40 	cmp.w	r0, #805306368	@ 0x30000000
 c03e98a:	bf88      	it	hi
 c03e98c:	3b04      	subhi	r3, #4
 c03e98e:	009b      	lsls	r3, r3, #2
    SET_BIT(*(__IO uint32_t *)register_address, 1UL << GTZC_GET_PERIPH_POS(PeriphId));
 c03e990:	58c8      	ldr	r0, [r1, r3]
 c03e992:	40a2      	lsls	r2, r4
 c03e994:	4302      	orrs	r2, r0
 c03e996:	50ca      	str	r2, [r1, r3]
 c03e998:	e7eb      	b.n	c03e972 <HAL_GTZC_TZIC_EnableIT+0x36>
    return HAL_ERROR;
 c03e99a:	2001      	movs	r0, #1
 c03e99c:	e7ea      	b.n	c03e974 <HAL_GTZC_TZIC_EnableIT+0x38>
 c03e99e:	bf00      	nop
 c03e9a0:	50032800 	.word	0x50032800
 c03e9a4:	001fffff 	.word	0x001fffff
 c03e9a8:	007fffff 	.word	0x007fffff
 c03e9ac:	3f0fc01f 	.word	0x3f0fc01f
 c03e9b0:	56023400 	.word	0x56023400
 c03e9b4:	0300c07f 	.word	0x0300c07f

0c03e9b8 <HASH_GetDigest>:
  */
static void HASH_GetDigest(uint8_t *pMsgDigest, uint8_t Size)
{
  uint32_t msgdigest = (uint32_t)pMsgDigest;

  switch (Size)
 c03e9b8:	291c      	cmp	r1, #28
 c03e9ba:	d027      	beq.n	c03ea0c <HASH_GetDigest+0x54>
 c03e9bc:	d804      	bhi.n	c03e9c8 <HASH_GetDigest+0x10>
 c03e9be:	2910      	cmp	r1, #16
 c03e9c0:	d005      	beq.n	c03e9ce <HASH_GetDigest+0x16>
 c03e9c2:	2914      	cmp	r1, #20
 c03e9c4:	d011      	beq.n	c03e9ea <HASH_GetDigest+0x32>
 c03e9c6:	4770      	bx	lr
 c03e9c8:	2920      	cmp	r1, #32
 c03e9ca:	d037      	beq.n	c03ea3c <HASH_GetDigest+0x84>
 c03e9cc:	4770      	bx	lr
  {
    /* Read the message digest */
    case 16:  /* MD5 */
      *(uint32_t *)(msgdigest) = __REV(HASH->HR[0]);
 c03e9ce:	4b29      	ldr	r3, [pc, #164]	@ (c03ea74 <HASH_GetDigest+0xbc>)
 c03e9d0:	68da      	ldr	r2, [r3, #12]
  \return               Reversed value
 */
__STATIC_FORCEINLINE uint32_t __REV(uint32_t value)
{
#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 5)
  return __builtin_bswap32(value);
 c03e9d2:	ba12      	rev	r2, r2
 c03e9d4:	6002      	str	r2, [r0, #0]
      msgdigest += 4U;
      *(uint32_t *)(msgdigest) = __REV(HASH->HR[1]);
 c03e9d6:	691a      	ldr	r2, [r3, #16]
 c03e9d8:	ba12      	rev	r2, r2
 c03e9da:	6042      	str	r2, [r0, #4]
      msgdigest += 4U;
      *(uint32_t *)(msgdigest) = __REV(HASH->HR[2]);
 c03e9dc:	695a      	ldr	r2, [r3, #20]
 c03e9de:	ba12      	rev	r2, r2
 c03e9e0:	6082      	str	r2, [r0, #8]
      msgdigest += 4U;
      *(uint32_t *)(msgdigest) = __REV(HASH->HR[3]);
 c03e9e2:	699b      	ldr	r3, [r3, #24]
 c03e9e4:	ba1b      	rev	r3, r3
 c03e9e6:	60c3      	str	r3, [r0, #12]
      break;
 c03e9e8:	4770      	bx	lr
    case 20:  /* SHA1 */
      *(uint32_t *)(msgdigest) = __REV(HASH->HR[0]);
 c03e9ea:	4b22      	ldr	r3, [pc, #136]	@ (c03ea74 <HASH_GetDigest+0xbc>)
 c03e9ec:	68da      	ldr	r2, [r3, #12]
 c03e9ee:	ba12      	rev	r2, r2
 c03e9f0:	6002      	str	r2, [r0, #0]
      msgdigest += 4U;
      *(uint32_t *)(msgdigest) = __REV(HASH->HR[1]);
 c03e9f2:	691a      	ldr	r2, [r3, #16]
 c03e9f4:	ba12      	rev	r2, r2
 c03e9f6:	6042      	str	r2, [r0, #4]
      msgdigest += 4U;
      *(uint32_t *)(msgdigest) = __REV(HASH->HR[2]);
 c03e9f8:	695a      	ldr	r2, [r3, #20]
 c03e9fa:	ba12      	rev	r2, r2
 c03e9fc:	6082      	str	r2, [r0, #8]
      msgdigest += 4U;
      *(uint32_t *)(msgdigest) = __REV(HASH->HR[3]);
 c03e9fe:	699a      	ldr	r2, [r3, #24]
 c03ea00:	ba12      	rev	r2, r2
 c03ea02:	60c2      	str	r2, [r0, #12]
      msgdigest += 4U;
      *(uint32_t *)(msgdigest) = __REV(HASH->HR[4]);
 c03ea04:	69db      	ldr	r3, [r3, #28]
 c03ea06:	ba1b      	rev	r3, r3
 c03ea08:	6103      	str	r3, [r0, #16]
      break;
 c03ea0a:	4770      	bx	lr
    case 28:  /* SHA224 */
      *(uint32_t *)(msgdigest) = __REV(HASH->HR[0]);
 c03ea0c:	4b19      	ldr	r3, [pc, #100]	@ (c03ea74 <HASH_GetDigest+0xbc>)
 c03ea0e:	68da      	ldr	r2, [r3, #12]
 c03ea10:	ba12      	rev	r2, r2
 c03ea12:	6002      	str	r2, [r0, #0]
      msgdigest += 4U;
      *(uint32_t *)(msgdigest) = __REV(HASH->HR[1]);
 c03ea14:	691a      	ldr	r2, [r3, #16]
 c03ea16:	ba12      	rev	r2, r2
 c03ea18:	6042      	str	r2, [r0, #4]
      msgdigest += 4U;
      *(uint32_t *)(msgdigest) = __REV(HASH->HR[2]);
 c03ea1a:	695a      	ldr	r2, [r3, #20]
 c03ea1c:	ba12      	rev	r2, r2
 c03ea1e:	6082      	str	r2, [r0, #8]
      msgdigest += 4U;
      *(uint32_t *)(msgdigest) = __REV(HASH->HR[3]);
 c03ea20:	699a      	ldr	r2, [r3, #24]
 c03ea22:	ba12      	rev	r2, r2
 c03ea24:	60c2      	str	r2, [r0, #12]
      msgdigest += 4U;
      *(uint32_t *)(msgdigest) = __REV(HASH->HR[4]);
 c03ea26:	69db      	ldr	r3, [r3, #28]
      msgdigest += 4U;
      *(uint32_t *)(msgdigest) = __REV(HASH_DIGEST->HR[5]);
 c03ea28:	4a13      	ldr	r2, [pc, #76]	@ (c03ea78 <HASH_GetDigest+0xc0>)
 c03ea2a:	ba1b      	rev	r3, r3
      *(uint32_t *)(msgdigest) = __REV(HASH->HR[4]);
 c03ea2c:	6103      	str	r3, [r0, #16]
      *(uint32_t *)(msgdigest) = __REV(HASH_DIGEST->HR[5]);
 c03ea2e:	6a53      	ldr	r3, [r2, #36]	@ 0x24
 c03ea30:	ba1b      	rev	r3, r3
 c03ea32:	6143      	str	r3, [r0, #20]
      msgdigest += 4U;
      *(uint32_t *)(msgdigest) = __REV(HASH_DIGEST->HR[6]);
 c03ea34:	6a93      	ldr	r3, [r2, #40]	@ 0x28
 c03ea36:	ba1b      	rev	r3, r3
 c03ea38:	6183      	str	r3, [r0, #24]
      break;
 c03ea3a:	4770      	bx	lr
    case 32:   /* SHA256 */
      *(uint32_t *)(msgdigest) = __REV(HASH->HR[0]);
 c03ea3c:	4b0d      	ldr	r3, [pc, #52]	@ (c03ea74 <HASH_GetDigest+0xbc>)
 c03ea3e:	68da      	ldr	r2, [r3, #12]
 c03ea40:	ba12      	rev	r2, r2
 c03ea42:	6002      	str	r2, [r0, #0]
      msgdigest += 4U;
      *(uint32_t *)(msgdigest) = __REV(HASH->HR[1]);
 c03ea44:	691a      	ldr	r2, [r3, #16]
 c03ea46:	ba12      	rev	r2, r2
 c03ea48:	6042      	str	r2, [r0, #4]
      msgdigest += 4U;
      *(uint32_t *)(msgdigest) = __REV(HASH->HR[2]);
 c03ea4a:	695a      	ldr	r2, [r3, #20]
 c03ea4c:	ba12      	rev	r2, r2
 c03ea4e:	6082      	str	r2, [r0, #8]
      msgdigest += 4U;
      *(uint32_t *)(msgdigest) = __REV(HASH->HR[3]);
 c03ea50:	699a      	ldr	r2, [r3, #24]
 c03ea52:	ba12      	rev	r2, r2
 c03ea54:	60c2      	str	r2, [r0, #12]
      msgdigest += 4U;
      *(uint32_t *)(msgdigest) = __REV(HASH->HR[4]);
 c03ea56:	69db      	ldr	r3, [r3, #28]
 c03ea58:	ba1b      	rev	r3, r3
 c03ea5a:	6103      	str	r3, [r0, #16]
      msgdigest += 4U;
      *(uint32_t *)(msgdigest) = __REV(HASH_DIGEST->HR[5]);
 c03ea5c:	4b06      	ldr	r3, [pc, #24]	@ (c03ea78 <HASH_GetDigest+0xc0>)
 c03ea5e:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 c03ea60:	ba12      	rev	r2, r2
 c03ea62:	6142      	str	r2, [r0, #20]
      msgdigest += 4U;
      *(uint32_t *)(msgdigest) = __REV(HASH_DIGEST->HR[6]);
 c03ea64:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
 c03ea66:	ba12      	rev	r2, r2
 c03ea68:	6182      	str	r2, [r0, #24]
      msgdigest += 4U;
      *(uint32_t *)(msgdigest) = __REV(HASH_DIGEST->HR[7]);
 c03ea6a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 c03ea6c:	ba1b      	rev	r3, r3
 c03ea6e:	61c3      	str	r3, [r0, #28]
      break;
    default:
      break;
  }
}
 c03ea70:	4770      	bx	lr
 c03ea72:	bf00      	nop
 c03ea74:	520c0400 	.word	0x520c0400
 c03ea78:	520c0700 	.word	0x520c0700

0c03ea7c <HASH_WaitOnFlagUntilTimeout>:
  * @param  Timeout Timeout duration.
  * @retval HAL status
  */
static HAL_StatusTypeDef HASH_WaitOnFlagUntilTimeout(HASH_HandleTypeDef *hhash, uint32_t Flag, FlagStatus Status,
                                                     uint32_t Timeout)
{
 c03ea7c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 c03ea80:	4605      	mov	r5, r0
 c03ea82:	460e      	mov	r6, r1
 c03ea84:	4691      	mov	r9, r2
 c03ea86:	461c      	mov	r4, r3
  uint32_t tickstart = HAL_GetTick();
 c03ea88:	f005 f92e 	bl	c043ce8 <HAL_GetTick>
 c03ea8c:	f8df 805c 	ldr.w	r8, [pc, #92]	@ c03eaec <HASH_WaitOnFlagUntilTimeout+0x70>
 c03ea90:	4607      	mov	r7, r0

  /* Wait until flag is set */
  if (Status == RESET)
 c03ea92:	f1b9 0f00 	cmp.w	r9, #0
 c03ea96:	d020      	beq.n	c03eada <HASH_WaitOnFlagUntilTimeout+0x5e>
      }
    }
  }
  else
  {
    while (__HAL_HASH_GET_FLAG(Flag) != RESET)
 c03ea98:	f8d8 3024 	ldr.w	r3, [r8, #36]	@ 0x24
 c03ea9c:	ea36 0303 	bics.w	r3, r6, r3
 c03eaa0:	d120      	bne.n	c03eae4 <HASH_WaitOnFlagUntilTimeout+0x68>
    {
      /* Check for the Timeout */
      if (Timeout != HAL_MAX_DELAY)
 c03eaa2:	1c63      	adds	r3, r4, #1
 c03eaa4:	d0f8      	beq.n	c03ea98 <HASH_WaitOnFlagUntilTimeout+0x1c>
      {
        if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
 c03eaa6:	f005 f91f 	bl	c043ce8 <HAL_GetTick>
 c03eaaa:	1bc0      	subs	r0, r0, r7
 c03eaac:	42a0      	cmp	r0, r4
 c03eaae:	d80a      	bhi.n	c03eac6 <HASH_WaitOnFlagUntilTimeout+0x4a>
 c03eab0:	2c00      	cmp	r4, #0
 c03eab2:	d1f1      	bne.n	c03ea98 <HASH_WaitOnFlagUntilTimeout+0x1c>
 c03eab4:	e007      	b.n	c03eac6 <HASH_WaitOnFlagUntilTimeout+0x4a>
      if (Timeout != HAL_MAX_DELAY)
 c03eab6:	1c62      	adds	r2, r4, #1
 c03eab8:	d00f      	beq.n	c03eada <HASH_WaitOnFlagUntilTimeout+0x5e>
        if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
 c03eaba:	f005 f915 	bl	c043ce8 <HAL_GetTick>
 c03eabe:	1bc0      	subs	r0, r0, r7
 c03eac0:	42a0      	cmp	r0, r4
 c03eac2:	d800      	bhi.n	c03eac6 <HASH_WaitOnFlagUntilTimeout+0x4a>
 c03eac4:	b94c      	cbnz	r4, c03eada <HASH_WaitOnFlagUntilTimeout+0x5e>
        {
          /* Set State to Ready to be able to restart later on */
          hhash->State  = HAL_HASH_STATE_READY;
 c03eac6:	2301      	movs	r3, #1
          /* Store time out issue in handle status */
          hhash->Status = HAL_TIMEOUT;
 c03eac8:	2003      	movs	r0, #3
          hhash->State  = HAL_HASH_STATE_READY;
 c03eaca:	f885 3035 	strb.w	r3, [r5, #53]	@ 0x35

          /* Process Unlocked */
          __HAL_UNLOCK(hhash);
 c03eace:	2300      	movs	r3, #0
          hhash->Status = HAL_TIMEOUT;
 c03ead0:	f885 002c 	strb.w	r0, [r5, #44]	@ 0x2c
          __HAL_UNLOCK(hhash);
 c03ead4:	f885 3034 	strb.w	r3, [r5, #52]	@ 0x34
 c03ead8:	e005      	b.n	c03eae6 <HASH_WaitOnFlagUntilTimeout+0x6a>
    while (__HAL_HASH_GET_FLAG(Flag) == RESET)
 c03eada:	f8d8 3024 	ldr.w	r3, [r8, #36]	@ 0x24
 c03eade:	ea36 0303 	bics.w	r3, r6, r3
 c03eae2:	d1e8      	bne.n	c03eab6 <HASH_WaitOnFlagUntilTimeout+0x3a>
          return HAL_TIMEOUT;
        }
      }
    }
  }
  return HAL_OK;
 c03eae4:	2000      	movs	r0, #0
}
 c03eae6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 c03eaea:	bf00      	nop
 c03eaec:	520c0400 	.word	0x520c0400

0c03eaf0 <HASH_WriteData>:
{
 c03eaf0:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 c03eaf4:	4606      	mov	r6, r0
 c03eaf6:	4614      	mov	r4, r2
  for (buffercounter = 0U; buffercounter < Size; buffercounter += 4U)
 c03eaf8:	2700      	movs	r7, #0
    HASH->DIN = *(uint32_t *)inputaddr;
 c03eafa:	f8df 8098 	ldr.w	r8, [pc, #152]	@ c03eb94 <HASH_WriteData+0xa4>
  __IO uint32_t inputaddr = (uint32_t) pInBuffer;
 c03eafe:	9101      	str	r1, [sp, #4]
  for (buffercounter = 0U; buffercounter < Size; buffercounter += 4U)
 c03eb00:	42a7      	cmp	r7, r4
 c03eb02:	d225      	bcs.n	c03eb50 <HASH_WriteData+0x60>
    HASH->DIN = *(uint32_t *)inputaddr;
 c03eb04:	9b01      	ldr	r3, [sp, #4]
    if ((hhash->SuspendRequest == HAL_HASH_SUSPEND) && ((buffercounter + 4U) < Size))
 c03eb06:	f107 0904 	add.w	r9, r7, #4
    HASH->DIN = *(uint32_t *)inputaddr;
 c03eb0a:	681b      	ldr	r3, [r3, #0]
 c03eb0c:	f8c8 3004 	str.w	r3, [r8, #4]
    inputaddr += 4U;
 c03eb10:	9b01      	ldr	r3, [sp, #4]
    if ((hhash->SuspendRequest == HAL_HASH_SUSPEND) && ((buffercounter + 4U) < Size))
 c03eb12:	f896 5036 	ldrb.w	r5, [r6, #54]	@ 0x36
    inputaddr += 4U;
 c03eb16:	3304      	adds	r3, #4
    if ((hhash->SuspendRequest == HAL_HASH_SUSPEND) && ((buffercounter + 4U) < Size))
 c03eb18:	2d01      	cmp	r5, #1
    inputaddr += 4U;
 c03eb1a:	9301      	str	r3, [sp, #4]
    if ((hhash->SuspendRequest == HAL_HASH_SUSPEND) && ((buffercounter + 4U) < Size))
 c03eb1c:	d138      	bne.n	c03eb90 <HASH_WriteData+0xa0>
 c03eb1e:	45a1      	cmp	r9, r4
 c03eb20:	d236      	bcs.n	c03eb90 <HASH_WriteData+0xa0>
      if (buffercounter >= 64U)
 c03eb22:	2f3f      	cmp	r7, #63	@ 0x3f
 c03eb24:	d816      	bhi.n	c03eb54 <HASH_WriteData+0x64>
      if (__HAL_HASH_GET_FLAG(HASH_FLAG_DINIS))
 c03eb26:	f8d8 3024 	ldr.w	r3, [r8, #36]	@ 0x24
 c03eb2a:	07db      	lsls	r3, r3, #31
 c03eb2c:	d530      	bpl.n	c03eb90 <HASH_WriteData+0xa0>
        hhash->SuspendRequest = HAL_HASH_SUSPEND_NONE;
 c03eb2e:	2200      	movs	r2, #0
        if ((hhash->Phase == HAL_HASH_PHASE_PROCESS) || (hhash->Phase == HAL_HASH_PHASE_HMAC_STEP_2))
 c03eb30:	f896 302d 	ldrb.w	r3, [r6, #45]	@ 0x2d
        hhash->SuspendRequest = HAL_HASH_SUSPEND_NONE;
 c03eb34:	f886 2036 	strb.w	r2, [r6, #54]	@ 0x36
        if ((hhash->Phase == HAL_HASH_PHASE_PROCESS) || (hhash->Phase == HAL_HASH_PHASE_HMAC_STEP_2))
 c03eb38:	2b02      	cmp	r3, #2
 c03eb3a:	d001      	beq.n	c03eb40 <HASH_WriteData+0x50>
 c03eb3c:	2b04      	cmp	r3, #4
 c03eb3e:	d114      	bne.n	c03eb6a <HASH_WriteData+0x7a>
          hhash->pHashInBuffPtr = (uint8_t *)inputaddr;
 c03eb40:	9b01      	ldr	r3, [sp, #4]
          hhash->HashInCount    =  Size - (buffercounter + 4U);
 c03eb42:	3c04      	subs	r4, #4
 c03eb44:	1be4      	subs	r4, r4, r7
          hhash->pHashInBuffPtr = (uint8_t *)inputaddr;
 c03eb46:	60f3      	str	r3, [r6, #12]
          hhash->HashInCount    =  Size - (buffercounter + 4U);
 c03eb48:	6234      	str	r4, [r6, #32]
        hhash->State = HAL_HASH_STATE_SUSPENDED;
 c03eb4a:	2308      	movs	r3, #8
 c03eb4c:	f886 3035 	strb.w	r3, [r6, #53]	@ 0x35
        return HAL_OK;
 c03eb50:	2500      	movs	r5, #0
 c03eb52:	e019      	b.n	c03eb88 <HASH_WriteData+0x98>
        if (HASH_WaitOnFlagUntilTimeout(hhash, HASH_FLAG_BUSY, SET, HASH_TIMEOUTVALUE) != HAL_OK)
 c03eb54:	f44f 737a 	mov.w	r3, #1000	@ 0x3e8
 c03eb58:	462a      	mov	r2, r5
 c03eb5a:	2108      	movs	r1, #8
 c03eb5c:	4630      	mov	r0, r6
 c03eb5e:	f7ff ff8d 	bl	c03ea7c <HASH_WaitOnFlagUntilTimeout>
 c03eb62:	2800      	cmp	r0, #0
 c03eb64:	d0df      	beq.n	c03eb26 <HASH_WriteData+0x36>
          return HAL_TIMEOUT;
 c03eb66:	2503      	movs	r5, #3
 c03eb68:	e00e      	b.n	c03eb88 <HASH_WriteData+0x98>
        else if ((hhash->Phase == HAL_HASH_PHASE_HMAC_STEP_1) || (hhash->Phase == HAL_HASH_PHASE_HMAC_STEP_3))
 c03eb6a:	2b03      	cmp	r3, #3
 c03eb6c:	d001      	beq.n	c03eb72 <HASH_WriteData+0x82>
 c03eb6e:	2b05      	cmp	r3, #5
 c03eb70:	d105      	bne.n	c03eb7e <HASH_WriteData+0x8e>
          hhash->pHashKeyBuffPtr  = (uint8_t *)inputaddr;
 c03eb72:	9b01      	ldr	r3, [sp, #4]
          hhash->HashKeyCount  =  Size - (buffercounter + 4U);
 c03eb74:	3c04      	subs	r4, #4
 c03eb76:	1be4      	subs	r4, r4, r7
          hhash->pHashKeyBuffPtr  = (uint8_t *)inputaddr;
 c03eb78:	6173      	str	r3, [r6, #20]
          hhash->HashKeyCount  =  Size - (buffercounter + 4U);
 c03eb7a:	62b4      	str	r4, [r6, #40]	@ 0x28
 c03eb7c:	e7e5      	b.n	c03eb4a <HASH_WriteData+0x5a>
          hhash->State = HAL_HASH_STATE_READY;
 c03eb7e:	2301      	movs	r3, #1
          __HAL_UNLOCK(hhash);
 c03eb80:	f886 2034 	strb.w	r2, [r6, #52]	@ 0x34
          hhash->State = HAL_HASH_STATE_READY;
 c03eb84:	f886 3035 	strb.w	r3, [r6, #53]	@ 0x35
}
 c03eb88:	4628      	mov	r0, r5
 c03eb8a:	b003      	add	sp, #12
 c03eb8c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  for (buffercounter = 0U; buffercounter < Size; buffercounter += 4U)
 c03eb90:	464f      	mov	r7, r9
 c03eb92:	e7b5      	b.n	c03eb00 <HASH_WriteData+0x10>
 c03eb94:	520c0400 	.word	0x520c0400

0c03eb98 <HAL_HASH_MspInit>:
}
 c03eb98:	4770      	bx	lr
	...

0c03eb9c <HAL_HASH_Init>:
{
 c03eb9c:	b538      	push	{r3, r4, r5, lr}
  if (hhash == NULL)
 c03eb9e:	4604      	mov	r4, r0
 c03eba0:	b328      	cbz	r0, c03ebee <HAL_HASH_Init+0x52>
  if (hhash->State == HAL_HASH_STATE_RESET)
 c03eba2:	f890 3035 	ldrb.w	r3, [r0, #53]	@ 0x35
 c03eba6:	f003 02ff 	and.w	r2, r3, #255	@ 0xff
 c03ebaa:	b91b      	cbnz	r3, c03ebb4 <HAL_HASH_Init+0x18>
    hhash->Lock = HAL_UNLOCKED;
 c03ebac:	f880 2034 	strb.w	r2, [r0, #52]	@ 0x34
    HAL_HASH_MspInit(hhash);
 c03ebb0:	f7ff fff2 	bl	c03eb98 <HAL_HASH_MspInit>
  hhash->HashInCount = 0;
 c03ebb4:	2000      	movs	r0, #0
  hhash->State = HAL_HASH_STATE_BUSY;
 c03ebb6:	2302      	movs	r3, #2
  hhash->Phase = HAL_HASH_PHASE_READY;
 c03ebb8:	2101      	movs	r1, #1
  MODIFY_REG(HASH->CR, HASH_CR_DATATYPE, hhash->Init.DataType);
 c03ebba:	4a0e      	ldr	r2, [pc, #56]	@ (c03ebf4 <HAL_HASH_Init+0x58>)
  hhash->State = HAL_HASH_STATE_BUSY;
 c03ebbc:	f884 3035 	strb.w	r3, [r4, #53]	@ 0x35
  hhash->HashBuffSize = 0;
 c03ebc0:	61e0      	str	r0, [r4, #28]
  hhash->HashInCount = 0;
 c03ebc2:	6220      	str	r0, [r4, #32]
  hhash->Phase = HAL_HASH_PHASE_READY;
 c03ebc4:	f884 102d 	strb.w	r1, [r4, #45]	@ 0x2d
  hhash->HashITCounter = 0;
 c03ebc8:	6260      	str	r0, [r4, #36]	@ 0x24
  hhash->SuspendRequest = HAL_HASH_SUSPEND_NONE;
 c03ebca:	86e0      	strh	r0, [r4, #54]	@ 0x36
  hhash->NbWordsAlreadyPushed = 0;
 c03ebcc:	63a0      	str	r0, [r4, #56]	@ 0x38
  MODIFY_REG(HASH->CR, HASH_CR_DATATYPE, hhash->Init.DataType);
 c03ebce:	6813      	ldr	r3, [r2, #0]
 c03ebd0:	6825      	ldr	r5, [r4, #0]
 c03ebd2:	f023 0330 	bic.w	r3, r3, #48	@ 0x30
 c03ebd6:	432b      	orrs	r3, r5
 c03ebd8:	6013      	str	r3, [r2, #0]
  __HAL_HASH_RESET_MDMAT();
 c03ebda:	6813      	ldr	r3, [r2, #0]
 c03ebdc:	f423 5300 	bic.w	r3, r3, #8192	@ 0x2000
 c03ebe0:	6013      	str	r3, [r2, #0]
  hhash->State = HAL_HASH_STATE_READY;
 c03ebe2:	f884 1035 	strb.w	r1, [r4, #53]	@ 0x35
  hhash->Status = HAL_OK;
 c03ebe6:	f884 002c 	strb.w	r0, [r4, #44]	@ 0x2c
  hhash->ErrorCode = HAL_HASH_ERROR_NONE;
 c03ebea:	63e0      	str	r0, [r4, #60]	@ 0x3c
}
 c03ebec:	bd38      	pop	{r3, r4, r5, pc}
    return HAL_ERROR;
 c03ebee:	2001      	movs	r0, #1
 c03ebf0:	e7fc      	b.n	c03ebec <HAL_HASH_Init+0x50>
 c03ebf2:	bf00      	nop
 c03ebf4:	520c0400 	.word	0x520c0400

0c03ebf8 <HAL_HASH_MspDeInit>:
__weak void HAL_HASH_MspDeInit(HASH_HandleTypeDef *hhash)
 c03ebf8:	4770      	bx	lr

0c03ebfa <HAL_HASH_DeInit>:
{
 c03ebfa:	b538      	push	{r3, r4, r5, lr}
  if (hhash == NULL)
 c03ebfc:	4605      	mov	r5, r0
 c03ebfe:	2401      	movs	r4, #1
 c03ec00:	b190      	cbz	r0, c03ec28 <HAL_HASH_DeInit+0x2e>
  hhash->State = HAL_HASH_STATE_BUSY;
 c03ec02:	2302      	movs	r3, #2
  hhash->Phase = HAL_HASH_PHASE_READY;
 c03ec04:	f880 402d 	strb.w	r4, [r0, #45]	@ 0x2d
  hhash->HashInCount = 0;
 c03ec08:	2400      	movs	r4, #0
  hhash->State = HAL_HASH_STATE_BUSY;
 c03ec0a:	f880 3035 	strb.w	r3, [r0, #53]	@ 0x35
  hhash->HashBuffSize = 0;
 c03ec0e:	61c4      	str	r4, [r0, #28]
  hhash->HashInCount = 0;
 c03ec10:	6204      	str	r4, [r0, #32]
  hhash->DigestCalculationDisable = RESET;
 c03ec12:	f880 4037 	strb.w	r4, [r0, #55]	@ 0x37
  hhash->HashITCounter = 0;
 c03ec16:	6244      	str	r4, [r0, #36]	@ 0x24
  HAL_HASH_MspDeInit(hhash);
 c03ec18:	f7ff ffee 	bl	c03ebf8 <HAL_HASH_MspDeInit>
  hhash->State = HAL_HASH_STATE_RESET;
 c03ec1c:	f885 4035 	strb.w	r4, [r5, #53]	@ 0x35
  hhash->Status = HAL_OK;
 c03ec20:	f885 402c 	strb.w	r4, [r5, #44]	@ 0x2c
  hhash->ErrorCode = HAL_HASH_ERROR_NONE;
 c03ec24:	63ec      	str	r4, [r5, #60]	@ 0x3c
  hhash->Accumulation = 0U;
 c03ec26:	642c      	str	r4, [r5, #64]	@ 0x40
    return HAL_ERROR;
 c03ec28:	4620      	mov	r0, r4
}
 c03ec2a:	bd38      	pop	{r3, r4, r5, pc}

0c03ec2c <HAL_HASH_ContextSaving>:
  *(uint32_t *)(mem_ptr) = READ_BIT(HASH->IMR, HASH_IT_DINI | HASH_IT_DCI);
 c03ec2c:	4b0f      	ldr	r3, [pc, #60]	@ (c03ec6c <HAL_HASH_ContextSaving+0x40>)
  mem_ptr += 4U;
 c03ec2e:	310c      	adds	r1, #12
  *(uint32_t *)(mem_ptr) = READ_BIT(HASH->IMR, HASH_IT_DINI | HASH_IT_DCI);
 c03ec30:	6a1a      	ldr	r2, [r3, #32]
 c03ec32:	f002 0203 	and.w	r2, r2, #3
 c03ec36:	f841 2c0c 	str.w	r2, [r1, #-12]
  *(uint32_t *)(mem_ptr) = READ_BIT(HASH->STR, HASH_STR_NBLW);
 c03ec3a:	689a      	ldr	r2, [r3, #8]
 c03ec3c:	f002 021f 	and.w	r2, r2, #31
 c03ec40:	f841 2c08 	str.w	r2, [r1, #-8]
  *(uint32_t *)(mem_ptr) = READ_BIT(HASH->CR, HASH_CR_DMAE | HASH_CR_DATATYPE | HASH_CR_MODE | HASH_CR_ALGO |
 c03ec44:	681b      	ldr	r3, [r3, #0]
  for (i = HASH_NUMBER_OF_CSR_REGISTERS; i > 0U; i--)
 c03ec46:	4a0a      	ldr	r2, [pc, #40]	@ (c03ec70 <HAL_HASH_ContextSaving+0x44>)
  *(uint32_t *)(mem_ptr) = READ_BIT(HASH->CR, HASH_CR_DMAE | HASH_CR_DATATYPE | HASH_CR_MODE | HASH_CR_ALGO |
 c03ec48:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
 c03ec4c:	f423 0378 	bic.w	r3, r3, #16252928	@ 0xf80000
 c03ec50:	f423 435f 	bic.w	r3, r3, #57088	@ 0xdf00
 c03ec54:	f023 0387 	bic.w	r3, r3, #135	@ 0x87
 c03ec58:	f841 3c04 	str.w	r3, [r1, #-4]
  uint32_t csr_ptr = (uint32_t)HASH->CSR;
 c03ec5c:	4b05      	ldr	r3, [pc, #20]	@ (c03ec74 <HAL_HASH_ContextSaving+0x48>)
    *(uint32_t *)(mem_ptr) = *(uint32_t *)(csr_ptr);
 c03ec5e:	f853 0b04 	ldr.w	r0, [r3], #4
  for (i = HASH_NUMBER_OF_CSR_REGISTERS; i > 0U; i--)
 c03ec62:	4293      	cmp	r3, r2
    *(uint32_t *)(mem_ptr) = *(uint32_t *)(csr_ptr);
 c03ec64:	f841 0b04 	str.w	r0, [r1], #4
  for (i = HASH_NUMBER_OF_CSR_REGISTERS; i > 0U; i--)
 c03ec68:	d1f9      	bne.n	c03ec5e <HAL_HASH_ContextSaving+0x32>
}
 c03ec6a:	4770      	bx	lr
 c03ec6c:	520c0400 	.word	0x520c0400
 c03ec70:	520c05d0 	.word	0x520c05d0
 c03ec74:	520c04f8 	.word	0x520c04f8

0c03ec78 <HAL_HASH_ContextRestoring>:
  WRITE_REG(HASH->IMR, (*(uint32_t *)(mem_ptr)));
 c03ec78:	680a      	ldr	r2, [r1, #0]
 c03ec7a:	4b0d      	ldr	r3, [pc, #52]	@ (c03ecb0 <HAL_HASH_ContextRestoring+0x38>)
  mem_ptr += 4U;
 c03ec7c:	310c      	adds	r1, #12
  WRITE_REG(HASH->IMR, (*(uint32_t *)(mem_ptr)));
 c03ec7e:	621a      	str	r2, [r3, #32]
  WRITE_REG(HASH->STR, (*(uint32_t *)(mem_ptr)));
 c03ec80:	f851 2c08 	ldr.w	r2, [r1, #-8]
  uint32_t csr_ptr = (uint32_t)HASH->CSR;
 c03ec84:	33f8      	adds	r3, #248	@ 0xf8
  WRITE_REG(HASH->STR, (*(uint32_t *)(mem_ptr)));
 c03ec86:	f843 2cf0 	str.w	r2, [r3, #-240]
  WRITE_REG(HASH->CR, (*(uint32_t *)(mem_ptr)));
 c03ec8a:	f851 2c04 	ldr.w	r2, [r1, #-4]
 c03ec8e:	f843 2cf8 	str.w	r2, [r3, #-248]
  __HAL_HASH_INIT();
 c03ec92:	f853 2cf8 	ldr.w	r2, [r3, #-248]
 c03ec96:	f042 0204 	orr.w	r2, r2, #4
 c03ec9a:	f843 2cf8 	str.w	r2, [r3, #-248]
  for (i = HASH_NUMBER_OF_CSR_REGISTERS; i > 0U; i--)
 c03ec9e:	4a05      	ldr	r2, [pc, #20]	@ (c03ecb4 <HAL_HASH_ContextRestoring+0x3c>)
    WRITE_REG((*(uint32_t *)(csr_ptr)), (*(uint32_t *)(mem_ptr)));
 c03eca0:	f851 0b04 	ldr.w	r0, [r1], #4
 c03eca4:	f843 0b04 	str.w	r0, [r3], #4
  for (i = HASH_NUMBER_OF_CSR_REGISTERS; i > 0U; i--)
 c03eca8:	4293      	cmp	r3, r2
 c03ecaa:	d1f9      	bne.n	c03eca0 <HAL_HASH_ContextRestoring+0x28>
}
 c03ecac:	4770      	bx	lr
 c03ecae:	bf00      	nop
 c03ecb0:	520c0400 	.word	0x520c0400
 c03ecb4:	520c05d0 	.word	0x520c05d0

0c03ecb8 <HASH_Start>:
  * @param  Algorithm HASH algorithm.
  * @retval HAL status
  */
HAL_StatusTypeDef HASH_Start(HASH_HandleTypeDef *hhash, uint8_t *pInBuffer, uint32_t Size, uint8_t *pOutBuffer,
                             uint32_t Timeout, uint32_t Algorithm)
{
 c03ecb8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 c03ecba:	461e      	mov	r6, r3
  uint8_t *pInBuffer_tmp;  /* input data address, input parameter of HASH_WriteData()         */
  uint32_t Size_tmp; /* input data size (in bytes), input parameter of HASH_WriteData() */
  HAL_HASH_StateTypeDef State_tmp = hhash->State;
 c03ecbc:	f890 3035 	ldrb.w	r3, [r0, #53]	@ 0x35
{
 c03ecc0:	4604      	mov	r4, r0


  /* Initiate HASH processing in case of start or resumption */
  if ((State_tmp == HAL_HASH_STATE_READY) || (State_tmp == HAL_HASH_STATE_SUSPENDED))
 c03ecc2:	2b01      	cmp	r3, #1
  HAL_HASH_StateTypeDef State_tmp = hhash->State;
 c03ecc4:	b2d8      	uxtb	r0, r3
  if ((State_tmp == HAL_HASH_STATE_READY) || (State_tmp == HAL_HASH_STATE_SUSPENDED))
 c03ecc6:	d002      	beq.n	c03ecce <HASH_Start+0x16>
 c03ecc8:	2808      	cmp	r0, #8
 c03ecca:	f040 8084 	bne.w	c03edd6 <HASH_Start+0x11e>
  {
    /* Check input parameters */
    if ((pInBuffer == NULL) || (pOutBuffer == NULL))
 c03ecce:	b101      	cbz	r1, c03ecd2 <HASH_Start+0x1a>
 c03ecd0:	b92e      	cbnz	r6, c03ecde <HASH_Start+0x26>
    {
      hhash->State = HAL_HASH_STATE_READY;
 c03ecd2:	2301      	movs	r3, #1
 c03ecd4:	f884 3035 	strb.w	r3, [r4, #53]	@ 0x35
      return  HAL_ERROR;
 c03ecd8:	2501      	movs	r5, #1
  }
  else
  {
    return HAL_BUSY;
  }
}
 c03ecda:	4628      	mov	r0, r5
 c03ecdc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    __HAL_LOCK(hhash);
 c03ecde:	f894 3034 	ldrb.w	r3, [r4, #52]	@ 0x34
 c03ece2:	2b01      	cmp	r3, #1
 c03ece4:	d077      	beq.n	c03edd6 <HASH_Start+0x11e>
 c03ece6:	2301      	movs	r3, #1
    if (hhash->Phase == HAL_HASH_PHASE_READY)
 c03ece8:	f894 002d 	ldrb.w	r0, [r4, #45]	@ 0x2d
    __HAL_LOCK(hhash);
 c03ecec:	f884 3034 	strb.w	r3, [r4, #52]	@ 0x34
    if (hhash->Phase == HAL_HASH_PHASE_READY)
 c03ecf0:	4298      	cmp	r0, r3
 c03ecf2:	d14e      	bne.n	c03ed92 <HASH_Start+0xda>
      hhash->State = HAL_HASH_STATE_BUSY;
 c03ecf4:	2702      	movs	r7, #2
      MODIFY_REG(HASH->CR, HASH_CR_LKEY | HASH_CR_ALGO | HASH_CR_MODE | HASH_CR_INIT, Algorithm | HASH_CR_INIT);
 c03ecf6:	483a      	ldr	r0, [pc, #232]	@ (c03ede0 <HASH_Start+0x128>)
      hhash->State = HAL_HASH_STATE_BUSY;
 c03ecf8:	f884 7035 	strb.w	r7, [r4, #53]	@ 0x35
      MODIFY_REG(HASH->CR, HASH_CR_LKEY | HASH_CR_ALGO | HASH_CR_MODE | HASH_CR_INIT, Algorithm | HASH_CR_INIT);
 c03ecfc:	6805      	ldr	r5, [r0, #0]
 c03ecfe:	9b07      	ldr	r3, [sp, #28]
 c03ed00:	f425 25e0 	bic.w	r5, r5, #458752	@ 0x70000
 c03ed04:	f025 0544 	bic.w	r5, r5, #68	@ 0x44
 c03ed08:	431d      	orrs	r5, r3
 c03ed0a:	f045 0504 	orr.w	r5, r5, #4
 c03ed0e:	6005      	str	r5, [r0, #0]
      __HAL_HASH_SET_NBVALIDBITS(Size);
 c03ed10:	6883      	ldr	r3, [r0, #8]
 c03ed12:	f002 0503 	and.w	r5, r2, #3
 c03ed16:	f023 031f 	bic.w	r3, r3, #31
 c03ed1a:	ea43 03c5 	orr.w	r3, r3, r5, lsl #3
 c03ed1e:	6083      	str	r3, [r0, #8]
      hhash->Phase = HAL_HASH_PHASE_PROCESS;
 c03ed20:	f884 702d 	strb.w	r7, [r4, #45]	@ 0x2d
    hhash->Status = HASH_WriteData(hhash, pInBuffer_tmp, Size_tmp);
 c03ed24:	4620      	mov	r0, r4
 c03ed26:	f7ff fee3 	bl	c03eaf0 <HASH_WriteData>
 c03ed2a:	4605      	mov	r5, r0
 c03ed2c:	f884 002c 	strb.w	r0, [r4, #44]	@ 0x2c
    if (hhash->Status != HAL_OK)
 c03ed30:	2800      	cmp	r0, #0
 c03ed32:	d1d2      	bne.n	c03ecda <HASH_Start+0x22>
    if (hhash->State != HAL_HASH_STATE_SUSPENDED)
 c03ed34:	f894 3035 	ldrb.w	r3, [r4, #53]	@ 0x35
 c03ed38:	2b08      	cmp	r3, #8
 c03ed3a:	d026      	beq.n	c03ed8a <HASH_Start+0xd2>
      __HAL_HASH_START_DIGEST();
 c03ed3c:	4f28      	ldr	r7, [pc, #160]	@ (c03ede0 <HASH_Start+0x128>)
      if (HASH_WaitOnFlagUntilTimeout(hhash, HASH_FLAG_DCIS, RESET, Timeout) != HAL_OK)
 c03ed3e:	4602      	mov	r2, r0
      __HAL_HASH_START_DIGEST();
 c03ed40:	68bb      	ldr	r3, [r7, #8]
      if (HASH_WaitOnFlagUntilTimeout(hhash, HASH_FLAG_DCIS, RESET, Timeout) != HAL_OK)
 c03ed42:	2102      	movs	r1, #2
      __HAL_HASH_START_DIGEST();
 c03ed44:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 c03ed48:	60bb      	str	r3, [r7, #8]
      if (HASH_WaitOnFlagUntilTimeout(hhash, HASH_FLAG_DCIS, RESET, Timeout) != HAL_OK)
 c03ed4a:	4620      	mov	r0, r4
 c03ed4c:	9b06      	ldr	r3, [sp, #24]
 c03ed4e:	f7ff fe95 	bl	c03ea7c <HASH_WaitOnFlagUntilTimeout>
 c03ed52:	2800      	cmp	r0, #0
 c03ed54:	d141      	bne.n	c03edda <HASH_Start+0x122>
      HASH_GetDigest(pOutBuffer, HASH_DIGEST_LENGTH());
 c03ed56:	683b      	ldr	r3, [r7, #0]
 c03ed58:	f413 2fc0 	tst.w	r3, #393216	@ 0x60000
 c03ed5c:	d037      	beq.n	c03edce <HASH_Start+0x116>
 c03ed5e:	683b      	ldr	r3, [r7, #0]
 c03ed60:	f403 23c0 	and.w	r3, r3, #393216	@ 0x60000
 c03ed64:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
 c03ed68:	d033      	beq.n	c03edd2 <HASH_Start+0x11a>
 c03ed6a:	683b      	ldr	r3, [r7, #0]
 c03ed6c:	f403 23c0 	and.w	r3, r3, #393216	@ 0x60000
 c03ed70:	f5b3 2fc0 	cmp.w	r3, #393216	@ 0x60000
 c03ed74:	bf14      	ite	ne
 c03ed76:	2110      	movne	r1, #16
 c03ed78:	2120      	moveq	r1, #32
 c03ed7a:	4630      	mov	r0, r6
 c03ed7c:	f7ff fe1c 	bl	c03e9b8 <HASH_GetDigest>
      hhash->State = HAL_HASH_STATE_READY;
 c03ed80:	2301      	movs	r3, #1
 c03ed82:	f884 3035 	strb.w	r3, [r4, #53]	@ 0x35
      hhash->Phase = HAL_HASH_PHASE_READY;
 c03ed86:	f884 302d 	strb.w	r3, [r4, #45]	@ 0x2d
    __HAL_UNLOCK(hhash);
 c03ed8a:	2300      	movs	r3, #0
 c03ed8c:	f884 3034 	strb.w	r3, [r4, #52]	@ 0x34
    return HAL_OK;
 c03ed90:	e7a3      	b.n	c03ecda <HASH_Start+0x22>
    else if (hhash->Phase == HAL_HASH_PHASE_PROCESS)
 c03ed92:	2802      	cmp	r0, #2
 c03ed94:	d115      	bne.n	c03edc2 <HASH_Start+0x10a>
      if (hhash->State == HAL_HASH_STATE_SUSPENDED)
 c03ed96:	f894 3035 	ldrb.w	r3, [r4, #53]	@ 0x35
 c03ed9a:	2b08      	cmp	r3, #8
        __HAL_HASH_SET_NBVALIDBITS(Size);
 c03ed9c:	bf1d      	ittte	ne
 c03ed9e:	4d10      	ldrne	r5, [pc, #64]	@ (c03ede0 <HASH_Start+0x128>)
 c03eda0:	f002 0003 	andne.w	r0, r2, #3
 c03eda4:	68ab      	ldrne	r3, [r5, #8]
        Size_tmp = hhash->HashInCount;
 c03eda6:	6a22      	ldreq	r2, [r4, #32]
        __HAL_HASH_SET_NBVALIDBITS(Size);
 c03eda8:	bf1e      	ittt	ne
 c03edaa:	f023 031f 	bicne.w	r3, r3, #31
 c03edae:	ea43 03c0 	orrne.w	r3, r3, r0, lsl #3
 c03edb2:	60ab      	strne	r3, [r5, #8]
      hhash->State = HAL_HASH_STATE_BUSY;
 c03edb4:	f04f 0302 	mov.w	r3, #2
        pInBuffer_tmp = hhash->pHashInBuffPtr;
 c03edb8:	bf08      	it	eq
 c03edba:	68e1      	ldreq	r1, [r4, #12]
      hhash->State = HAL_HASH_STATE_BUSY;
 c03edbc:	f884 3035 	strb.w	r3, [r4, #53]	@ 0x35
 c03edc0:	e7b0      	b.n	c03ed24 <HASH_Start+0x6c>
      hhash->State = HAL_HASH_STATE_READY;
 c03edc2:	f884 3035 	strb.w	r3, [r4, #53]	@ 0x35
      __HAL_UNLOCK(hhash);
 c03edc6:	2300      	movs	r3, #0
 c03edc8:	f884 3034 	strb.w	r3, [r4, #52]	@ 0x34
      return HAL_ERROR;
 c03edcc:	e784      	b.n	c03ecd8 <HASH_Start+0x20>
      HASH_GetDigest(pOutBuffer, HASH_DIGEST_LENGTH());
 c03edce:	2114      	movs	r1, #20
 c03edd0:	e7d3      	b.n	c03ed7a <HASH_Start+0xc2>
 c03edd2:	211c      	movs	r1, #28
 c03edd4:	e7d1      	b.n	c03ed7a <HASH_Start+0xc2>
    __HAL_LOCK(hhash);
 c03edd6:	2502      	movs	r5, #2
 c03edd8:	e77f      	b.n	c03ecda <HASH_Start+0x22>
        return HAL_TIMEOUT;
 c03edda:	2503      	movs	r5, #3
 c03eddc:	e77d      	b.n	c03ecda <HASH_Start+0x22>
 c03edde:	bf00      	nop
 c03ede0:	520c0400 	.word	0x520c0400

0c03ede4 <HASH_Accumulate>:
  * @param  Size length of the input buffer in bytes, must be a multiple of 4.
  * @param  Algorithm HASH algorithm.
  * @retval HAL status
  */
HAL_StatusTypeDef HASH_Accumulate(HASH_HandleTypeDef *hhash, uint8_t *pInBuffer, uint32_t Size, uint32_t Algorithm)
{
 c03ede4:	b538      	push	{r3, r4, r5, lr}
 c03ede6:	4604      	mov	r4, r0
  uint8_t *pInBuffer_tmp;   /* input data address, input parameter of HASH_WriteData()         */
  uint32_t Size_tmp;  /* input data size (in bytes), input parameter of HASH_WriteData() */
  HAL_HASH_StateTypeDef State_tmp = hhash->State;
 c03ede8:	f890 0035 	ldrb.w	r0, [r0, #53]	@ 0x35

  /* Make sure the input buffer size (in bytes) is a multiple of 4 */
  if ((Size % 4U) != 0U)
 c03edec:	0795      	lsls	r5, r2, #30
  HAL_HASH_StateTypeDef State_tmp = hhash->State;
 c03edee:	b2c0      	uxtb	r0, r0
  if ((Size % 4U) != 0U)
 c03edf0:	d108      	bne.n	c03ee04 <HASH_Accumulate+0x20>
  {
    return  HAL_ERROR;
  }

  /* Initiate HASH processing in case of start or resumption */
  if ((State_tmp == HAL_HASH_STATE_READY) || (State_tmp == HAL_HASH_STATE_SUSPENDED))
 c03edf2:	2801      	cmp	r0, #1
 c03edf4:	d001      	beq.n	c03edfa <HASH_Accumulate+0x16>
 c03edf6:	2808      	cmp	r0, #8
 c03edf8:	d13b      	bne.n	c03ee72 <HASH_Accumulate+0x8e>
  {
    /* Check input parameters */
    if ((pInBuffer == NULL) || (Size == 0U))
 c03edfa:	b101      	cbz	r1, c03edfe <HASH_Accumulate+0x1a>
 c03edfc:	b922      	cbnz	r2, c03ee08 <HASH_Accumulate+0x24>
    {
      hhash->State = HAL_HASH_STATE_READY;
 c03edfe:	2301      	movs	r3, #1
 c03ee00:	f884 3035 	strb.w	r3, [r4, #53]	@ 0x35
    return  HAL_ERROR;
 c03ee04:	2001      	movs	r0, #1
  {
    return HAL_BUSY;
  }


}
 c03ee06:	bd38      	pop	{r3, r4, r5, pc}
    __HAL_LOCK(hhash);
 c03ee08:	f894 0034 	ldrb.w	r0, [r4, #52]	@ 0x34
 c03ee0c:	2801      	cmp	r0, #1
 c03ee0e:	d030      	beq.n	c03ee72 <HASH_Accumulate+0x8e>
 c03ee10:	2001      	movs	r0, #1
 c03ee12:	f884 0034 	strb.w	r0, [r4, #52]	@ 0x34
    if (hhash->State == HAL_HASH_STATE_SUSPENDED)
 c03ee16:	f894 0035 	ldrb.w	r0, [r4, #53]	@ 0x35
 c03ee1a:	2808      	cmp	r0, #8
 c03ee1c:	f04f 0002 	mov.w	r0, #2
      hhash->State = HAL_HASH_STATE_BUSY;
 c03ee20:	f884 0035 	strb.w	r0, [r4, #53]	@ 0x35
    if (hhash->State == HAL_HASH_STATE_SUSPENDED)
 c03ee24:	d113      	bne.n	c03ee4e <HASH_Accumulate+0x6a>
      pInBuffer_tmp = hhash->pHashInBuffPtr;  /* pInBuffer_tmp is set to the input data address */
 c03ee26:	68e1      	ldr	r1, [r4, #12]
      Size_tmp = hhash->HashInCount;          /* Size_tmp contains the input data size in bytes */
 c03ee28:	6a22      	ldr	r2, [r4, #32]
    hhash->Status = HASH_WriteData(hhash, pInBuffer_tmp, Size_tmp);
 c03ee2a:	4620      	mov	r0, r4
 c03ee2c:	f7ff fe60 	bl	c03eaf0 <HASH_WriteData>
 c03ee30:	f884 002c 	strb.w	r0, [r4, #44]	@ 0x2c
    if (hhash->Status != HAL_OK)
 c03ee34:	2800      	cmp	r0, #0
 c03ee36:	d1e6      	bne.n	c03ee06 <HASH_Accumulate+0x22>
    if (hhash->State != HAL_HASH_STATE_SUSPENDED)
 c03ee38:	f894 3035 	ldrb.w	r3, [r4, #53]	@ 0x35
 c03ee3c:	2b08      	cmp	r3, #8
      hhash->State = HAL_HASH_STATE_READY;
 c03ee3e:	bf1c      	itt	ne
 c03ee40:	2301      	movne	r3, #1
 c03ee42:	f884 3035 	strbne.w	r3, [r4, #53]	@ 0x35
    __HAL_UNLOCK(hhash);
 c03ee46:	2300      	movs	r3, #0
 c03ee48:	f884 3034 	strb.w	r3, [r4, #52]	@ 0x34
    return HAL_OK;
 c03ee4c:	e7db      	b.n	c03ee06 <HASH_Accumulate+0x22>
      if (hhash->Phase == HAL_HASH_PHASE_READY)
 c03ee4e:	f894 002d 	ldrb.w	r0, [r4, #45]	@ 0x2d
 c03ee52:	2801      	cmp	r0, #1
 c03ee54:	d109      	bne.n	c03ee6a <HASH_Accumulate+0x86>
        MODIFY_REG(HASH->CR, HASH_CR_LKEY | HASH_CR_ALGO | HASH_CR_MODE | HASH_CR_INIT, Algorithm | HASH_CR_INIT);
 c03ee56:	4d08      	ldr	r5, [pc, #32]	@ (c03ee78 <HASH_Accumulate+0x94>)
 c03ee58:	6828      	ldr	r0, [r5, #0]
 c03ee5a:	f420 20e0 	bic.w	r0, r0, #458752	@ 0x70000
 c03ee5e:	f020 0044 	bic.w	r0, r0, #68	@ 0x44
 c03ee62:	4318      	orrs	r0, r3
 c03ee64:	f040 0004 	orr.w	r0, r0, #4
 c03ee68:	6028      	str	r0, [r5, #0]
      hhash->Phase = HAL_HASH_PHASE_PROCESS;
 c03ee6a:	2302      	movs	r3, #2
 c03ee6c:	f884 302d 	strb.w	r3, [r4, #45]	@ 0x2d
 c03ee70:	e7db      	b.n	c03ee2a <HASH_Accumulate+0x46>
    __HAL_LOCK(hhash);
 c03ee72:	2002      	movs	r0, #2
 c03ee74:	e7c7      	b.n	c03ee06 <HASH_Accumulate+0x22>
 c03ee76:	bf00      	nop
 c03ee78:	520c0400 	.word	0x520c0400

0c03ee7c <HAL_HASHEx_SHA224_Start>:
  * @param  Timeout Timeout value
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_HASHEx_SHA224_Start(HASH_HandleTypeDef *hhash, uint8_t *pInBuffer, uint32_t Size,
                                          uint8_t *pOutBuffer, uint32_t Timeout)
{
 c03ee7c:	b513      	push	{r0, r1, r4, lr}
  return HASH_Start(hhash, pInBuffer, Size, pOutBuffer, Timeout, HASH_ALGOSELECTION_SHA224);
 c03ee7e:	f44f 2480 	mov.w	r4, #262144	@ 0x40000
 c03ee82:	9401      	str	r4, [sp, #4]
 c03ee84:	9c04      	ldr	r4, [sp, #16]
 c03ee86:	9400      	str	r4, [sp, #0]
 c03ee88:	f7ff ff16 	bl	c03ecb8 <HASH_Start>
}
 c03ee8c:	b002      	add	sp, #8
 c03ee8e:	bd10      	pop	{r4, pc}

0c03ee90 <HAL_HASHEx_SHA224_Accmlt>:
  * @param  Size length of the input buffer in bytes, must be a multiple of 4.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_HASHEx_SHA224_Accmlt(HASH_HandleTypeDef *hhash, uint8_t *pInBuffer, uint32_t Size)
{
  return  HASH_Accumulate(hhash, pInBuffer, Size, HASH_ALGOSELECTION_SHA224);
 c03ee90:	f44f 2380 	mov.w	r3, #262144	@ 0x40000
 c03ee94:	f7ff bfa6 	b.w	c03ede4 <HASH_Accumulate>

0c03ee98 <HAL_HASHEx_SHA224_Accmlt_End>:
  * @param  Size length of the input buffer in bytes.
  * @param  pOutBuffer pointer to the computed digest. Digest size is 28 bytes.
  * @param  Timeout Timeout value
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_HASHEx_SHA224_Accmlt_End(HASH_HandleTypeDef *hhash, uint8_t *pInBuffer, uint32_t Size,
 c03ee98:	f7ff bff0 	b.w	c03ee7c <HAL_HASHEx_SHA224_Start>

0c03ee9c <HAL_HASHEx_SHA256_Start>:
  * @param  Timeout Timeout value
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_HASHEx_SHA256_Start(HASH_HandleTypeDef *hhash, uint8_t *pInBuffer, uint32_t Size,
                                          uint8_t *pOutBuffer, uint32_t Timeout)
{
 c03ee9c:	b513      	push	{r0, r1, r4, lr}
  return HASH_Start(hhash, pInBuffer, Size, pOutBuffer, Timeout, HASH_ALGOSELECTION_SHA256);
 c03ee9e:	f44f 24c0 	mov.w	r4, #393216	@ 0x60000
 c03eea2:	9401      	str	r4, [sp, #4]
 c03eea4:	9c04      	ldr	r4, [sp, #16]
 c03eea6:	9400      	str	r4, [sp, #0]
 c03eea8:	f7ff ff06 	bl	c03ecb8 <HASH_Start>
}
 c03eeac:	b002      	add	sp, #8
 c03eeae:	bd10      	pop	{r4, pc}

0c03eeb0 <HAL_HASHEx_SHA256_Accmlt>:
  * @param  Size length of the input buffer in bytes, must be a multiple of 4.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_HASHEx_SHA256_Accmlt(HASH_HandleTypeDef *hhash, uint8_t *pInBuffer, uint32_t Size)
{
  return  HASH_Accumulate(hhash, pInBuffer, Size, HASH_ALGOSELECTION_SHA256);
 c03eeb0:	f44f 23c0 	mov.w	r3, #393216	@ 0x60000
 c03eeb4:	f7ff bf96 	b.w	c03ede4 <HASH_Accumulate>

0c03eeb8 <HAL_HASHEx_SHA256_Accmlt_End>:
  * @param  Size length of the input buffer in bytes.
  * @param  pOutBuffer pointer to the computed digest. Digest size is 32 bytes.
  * @param  Timeout Timeout value
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_HASHEx_SHA256_Accmlt_End(HASH_HandleTypeDef *hhash, uint8_t *pInBuffer, uint32_t Size,
 c03eeb8:	f7ff bff0 	b.w	c03ee9c <HAL_HASHEx_SHA256_Start>

0c03eebc <I2C_Flush_TXDR>:
  */
static void I2C_Flush_TXDR(I2C_HandleTypeDef *hi2c)
{
  /* If a pending TXIS flag is set */
  /* Write a dummy data in TXDR to clear it */
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
 c03eebc:	6803      	ldr	r3, [r0, #0]
 c03eebe:	699a      	ldr	r2, [r3, #24]
 c03eec0:	0791      	lsls	r1, r2, #30
  {
    hi2c->Instance->TXDR = 0x00U;
 c03eec2:	bf44      	itt	mi
 c03eec4:	2200      	movmi	r2, #0
 c03eec6:	629a      	strmi	r2, [r3, #40]	@ 0x28
  }

  /* Flush TX register if not empty */
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
 c03eec8:	699a      	ldr	r2, [r3, #24]
 c03eeca:	07d2      	lsls	r2, r2, #31
  {
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
 c03eecc:	bf5e      	ittt	pl
 c03eece:	699a      	ldrpl	r2, [r3, #24]
 c03eed0:	f042 0201 	orrpl.w	r2, r2, #1
 c03eed4:	619a      	strpl	r2, [r3, #24]
  }
}
 c03eed6:	4770      	bx	lr

0c03eed8 <I2C_TransferConfig>:
  *     @arg @ref I2C_GENERATE_START_WRITE Generate Restart for write request.
  * @retval None
  */
static void I2C_TransferConfig(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t Size, uint32_t Mode,
                               uint32_t Request)
{
 c03eed8:	b530      	push	{r4, r5, lr}
 c03eeda:	9d03      	ldr	r5, [sp, #12]
  uint32_t tmp = ((uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | \
                             (((uint32_t)Size << I2C_CR2_NBYTES_Pos) & I2C_CR2_NBYTES) | \
                             (uint32_t)Mode | (uint32_t)Request) & (~0x80000000U));

  /* update CR2 register */
  MODIFY_REG(hi2c->Instance->CR2, \
 c03eedc:	6804      	ldr	r4, [r0, #0]
  uint32_t tmp = ((uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | \
 c03eede:	432b      	orrs	r3, r5
 c03eee0:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
  MODIFY_REG(hi2c->Instance->CR2, \
 c03eee4:	4a06      	ldr	r2, [pc, #24]	@ (c03ef00 <I2C_TransferConfig+0x28>)
 c03eee6:	6860      	ldr	r0, [r4, #4]
  uint32_t tmp = ((uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | \
 c03eee8:	f3c1 0109 	ubfx	r1, r1, #0, #10
 c03eeec:	430b      	orrs	r3, r1
  MODIFY_REG(hi2c->Instance->CR2, \
 c03eeee:	ea42 5255 	orr.w	r2, r2, r5, lsr #21
  uint32_t tmp = ((uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | \
 c03eef2:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
  MODIFY_REG(hi2c->Instance->CR2, \
 c03eef6:	ea20 0002 	bic.w	r0, r0, r2
 c03eefa:	4303      	orrs	r3, r0
 c03eefc:	6063      	str	r3, [r4, #4]
             ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | \
               (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | \
               I2C_CR2_START | I2C_CR2_STOP)), tmp);
}
 c03eefe:	bd30      	pop	{r4, r5, pc}
 c03ef00:	03ff63ff 	.word	0x03ff63ff

0c03ef04 <I2C_IsErrorOccurred>:
  uint32_t itflag   = hi2c->Instance->ISR;
 c03ef04:	6803      	ldr	r3, [r0, #0]
{
 c03ef06:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t itflag   = hi2c->Instance->ISR;
 c03ef0a:	699c      	ldr	r4, [r3, #24]
{
 c03ef0c:	4605      	mov	r5, r0
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_AF))
 c03ef0e:	f014 0410 	ands.w	r4, r4, #16
{
 c03ef12:	460f      	mov	r7, r1
 c03ef14:	4616      	mov	r6, r2
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_AF))
 c03ef16:	d06f      	beq.n	c03eff8 <I2C_IsErrorOccurred+0xf4>
  uint32_t error_code = 0;
 c03ef18:	2400      	movs	r4, #0
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 c03ef1a:	2210      	movs	r2, #16
  HAL_StatusTypeDef status = HAL_OK;
 c03ef1c:	46a0      	mov	r8, r4
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 c03ef1e:	61da      	str	r2, [r3, #28]
    while ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET) && (status == HAL_OK))
 c03ef20:	682b      	ldr	r3, [r5, #0]
 c03ef22:	699a      	ldr	r2, [r3, #24]
 c03ef24:	0690      	lsls	r0, r2, #26
 c03ef26:	d461      	bmi.n	c03efec <I2C_IsErrorOccurred+0xe8>
 c03ef28:	f1b8 0f00 	cmp.w	r8, #0
 c03ef2c:	d035      	beq.n	c03ef9a <I2C_IsErrorOccurred+0x96>
    status = HAL_ERROR;
 c03ef2e:	2001      	movs	r0, #1
    error_code |= HAL_I2C_ERROR_AF;
 c03ef30:	f044 0404 	orr.w	r4, r4, #4
  itflag = hi2c->Instance->ISR;
 c03ef34:	682e      	ldr	r6, [r5, #0]
 c03ef36:	69b3      	ldr	r3, [r6, #24]
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_BERR))
 c03ef38:	05d9      	lsls	r1, r3, #23
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_BERR);
 c03ef3a:	bf41      	itttt	mi
 c03ef3c:	f44f 7280 	movmi.w	r2, #256	@ 0x100
    status = HAL_ERROR;
 c03ef40:	2001      	movmi	r0, #1
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_BERR);
 c03ef42:	61f2      	strmi	r2, [r6, #28]
    error_code |= HAL_I2C_ERROR_BERR;
 c03ef44:	f044 0401 	orrmi.w	r4, r4, #1
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_OVR))
 c03ef48:	055a      	lsls	r2, r3, #21
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_OVR);
 c03ef4a:	bf41      	itttt	mi
 c03ef4c:	f44f 6280 	movmi.w	r2, #1024	@ 0x400
    status = HAL_ERROR;
 c03ef50:	2001      	movmi	r0, #1
    error_code |= HAL_I2C_ERROR_OVR;
 c03ef52:	f044 0408 	orrmi.w	r4, r4, #8
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_OVR);
 c03ef56:	61f2      	strmi	r2, [r6, #28]
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_ARLO))
 c03ef58:	059b      	lsls	r3, r3, #22
 c03ef5a:	d54f      	bpl.n	c03effc <I2C_IsErrorOccurred+0xf8>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ARLO);
 c03ef5c:	f44f 7300 	mov.w	r3, #512	@ 0x200
    error_code |= HAL_I2C_ERROR_ARLO;
 c03ef60:	f044 0402 	orr.w	r4, r4, #2
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ARLO);
 c03ef64:	61f3      	str	r3, [r6, #28]
    I2C_Flush_TXDR(hi2c);
 c03ef66:	4628      	mov	r0, r5
 c03ef68:	f7ff ffa8 	bl	c03eebc <I2C_Flush_TXDR>
    I2C_RESET_CR2(hi2c);
 c03ef6c:	6873      	ldr	r3, [r6, #4]
    __HAL_UNLOCK(hi2c);
 c03ef6e:	2001      	movs	r0, #1
    I2C_RESET_CR2(hi2c);
 c03ef70:	f023 73ff 	bic.w	r3, r3, #33423360	@ 0x1fe0000
 c03ef74:	f423 338b 	bic.w	r3, r3, #71168	@ 0x11600
 c03ef78:	f423 73ff 	bic.w	r3, r3, #510	@ 0x1fe
 c03ef7c:	f023 0301 	bic.w	r3, r3, #1
 c03ef80:	6073      	str	r3, [r6, #4]
    hi2c->ErrorCode |= error_code;
 c03ef82:	6c6b      	ldr	r3, [r5, #68]	@ 0x44
 c03ef84:	4323      	orrs	r3, r4
 c03ef86:	646b      	str	r3, [r5, #68]	@ 0x44
    hi2c->State = HAL_I2C_STATE_READY;
 c03ef88:	2320      	movs	r3, #32
 c03ef8a:	f885 3041 	strb.w	r3, [r5, #65]	@ 0x41
    hi2c->Mode = HAL_I2C_MODE_NONE;
 c03ef8e:	2300      	movs	r3, #0
 c03ef90:	f885 3042 	strb.w	r3, [r5, #66]	@ 0x42
    __HAL_UNLOCK(hi2c);
 c03ef94:	f885 3040 	strb.w	r3, [r5, #64]	@ 0x40
 c03ef98:	e032      	b.n	c03f000 <I2C_IsErrorOccurred+0xfc>
      if (Timeout != HAL_MAX_DELAY)
 c03ef9a:	1c7a      	adds	r2, r7, #1
 c03ef9c:	d0c1      	beq.n	c03ef22 <I2C_IsErrorOccurred+0x1e>
        if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
 c03ef9e:	f004 fea3 	bl	c043ce8 <HAL_GetTick>
 c03efa2:	1b80      	subs	r0, r0, r6
 c03efa4:	42b8      	cmp	r0, r7
 c03efa6:	d801      	bhi.n	c03efac <I2C_IsErrorOccurred+0xa8>
 c03efa8:	2f00      	cmp	r7, #0
 c03efaa:	d1b9      	bne.n	c03ef20 <I2C_IsErrorOccurred+0x1c>
          tmp1 = (uint32_t)(hi2c->Instance->CR2 & I2C_CR2_STOP);
 c03efac:	682b      	ldr	r3, [r5, #0]
 c03efae:	6859      	ldr	r1, [r3, #4]
          tmp2 = hi2c->Mode;
 c03efb0:	f895 2042 	ldrb.w	r2, [r5, #66]	@ 0x42
          if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET) && \
 c03efb4:	6998      	ldr	r0, [r3, #24]
          tmp2 = hi2c->Mode;
 c03efb6:	b2d2      	uxtb	r2, r2
          if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET) && \
 c03efb8:	0400      	lsls	r0, r0, #16
 c03efba:	d50a      	bpl.n	c03efd2 <I2C_IsErrorOccurred+0xce>
 c03efbc:	0449      	lsls	r1, r1, #17
 c03efbe:	d408      	bmi.n	c03efd2 <I2C_IsErrorOccurred+0xce>
              (tmp1 != I2C_CR2_STOP) && \
 c03efc0:	2a20      	cmp	r2, #32
 c03efc2:	d006      	beq.n	c03efd2 <I2C_IsErrorOccurred+0xce>
            hi2c->Instance->CR2 |= I2C_CR2_STOP;
 c03efc4:	685a      	ldr	r2, [r3, #4]
 c03efc6:	f442 4280 	orr.w	r2, r2, #16384	@ 0x4000
 c03efca:	605a      	str	r2, [r3, #4]
            tickstart = HAL_GetTick();
 c03efcc:	f004 fe8c 	bl	c043ce8 <HAL_GetTick>
 c03efd0:	4606      	mov	r6, r0
          while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 c03efd2:	682b      	ldr	r3, [r5, #0]
 c03efd4:	699b      	ldr	r3, [r3, #24]
 c03efd6:	069b      	lsls	r3, r3, #26
 c03efd8:	d4a2      	bmi.n	c03ef20 <I2C_IsErrorOccurred+0x1c>
            if ((HAL_GetTick() - tickstart) > I2C_TIMEOUT_STOPF)
 c03efda:	f004 fe85 	bl	c043ce8 <HAL_GetTick>
 c03efde:	1b80      	subs	r0, r0, r6
 c03efe0:	2819      	cmp	r0, #25
 c03efe2:	d9f6      	bls.n	c03efd2 <I2C_IsErrorOccurred+0xce>
              error_code |= HAL_I2C_ERROR_TIMEOUT;
 c03efe4:	2420      	movs	r4, #32
              status = HAL_ERROR;
 c03efe6:	f04f 0801 	mov.w	r8, #1
 c03efea:	e799      	b.n	c03ef20 <I2C_IsErrorOccurred+0x1c>
    if (status == HAL_OK)
 c03efec:	f1b8 0f00 	cmp.w	r8, #0
 c03eff0:	d19d      	bne.n	c03ef2e <I2C_IsErrorOccurred+0x2a>
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 c03eff2:	2220      	movs	r2, #32
 c03eff4:	61da      	str	r2, [r3, #28]
 c03eff6:	e79a      	b.n	c03ef2e <I2C_IsErrorOccurred+0x2a>
  HAL_StatusTypeDef status = HAL_OK;
 c03eff8:	4620      	mov	r0, r4
 c03effa:	e79b      	b.n	c03ef34 <I2C_IsErrorOccurred+0x30>
  if (status != HAL_OK)
 c03effc:	2800      	cmp	r0, #0
 c03effe:	d1b2      	bne.n	c03ef66 <I2C_IsErrorOccurred+0x62>
}
 c03f000:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0c03f004 <I2C_WaitOnTXISFlagUntilTimeout>:
{
 c03f004:	b570      	push	{r4, r5, r6, lr}
 c03f006:	4604      	mov	r4, r0
 c03f008:	460d      	mov	r5, r1
 c03f00a:	4616      	mov	r6, r2
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
 c03f00c:	6823      	ldr	r3, [r4, #0]
 c03f00e:	699b      	ldr	r3, [r3, #24]
 c03f010:	079b      	lsls	r3, r3, #30
 c03f012:	d501      	bpl.n	c03f018 <I2C_WaitOnTXISFlagUntilTimeout+0x14>
  return HAL_OK;
 c03f014:	2000      	movs	r0, #0
 c03f016:	e01f      	b.n	c03f058 <I2C_WaitOnTXISFlagUntilTimeout+0x54>
    if (I2C_IsErrorOccurred(hi2c, Timeout, Tickstart) != HAL_OK)
 c03f018:	4632      	mov	r2, r6
 c03f01a:	4629      	mov	r1, r5
 c03f01c:	4620      	mov	r0, r4
 c03f01e:	f7ff ff71 	bl	c03ef04 <I2C_IsErrorOccurred>
 c03f022:	b9c0      	cbnz	r0, c03f056 <I2C_WaitOnTXISFlagUntilTimeout+0x52>
    if (Timeout != HAL_MAX_DELAY)
 c03f024:	1c6a      	adds	r2, r5, #1
 c03f026:	d0f1      	beq.n	c03f00c <I2C_WaitOnTXISFlagUntilTimeout+0x8>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 c03f028:	f004 fe5e 	bl	c043ce8 <HAL_GetTick>
 c03f02c:	1b80      	subs	r0, r0, r6
 c03f02e:	42a8      	cmp	r0, r5
 c03f030:	d801      	bhi.n	c03f036 <I2C_WaitOnTXISFlagUntilTimeout+0x32>
 c03f032:	2d00      	cmp	r5, #0
 c03f034:	d1ea      	bne.n	c03f00c <I2C_WaitOnTXISFlagUntilTimeout+0x8>
        if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET))
 c03f036:	6823      	ldr	r3, [r4, #0]
 c03f038:	699b      	ldr	r3, [r3, #24]
 c03f03a:	f013 0302 	ands.w	r3, r3, #2
 c03f03e:	d1e5      	bne.n	c03f00c <I2C_WaitOnTXISFlagUntilTimeout+0x8>
          hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 c03f040:	6c62      	ldr	r2, [r4, #68]	@ 0x44
          __HAL_UNLOCK(hi2c);
 c03f042:	f884 3040 	strb.w	r3, [r4, #64]	@ 0x40
          hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 c03f046:	f042 0220 	orr.w	r2, r2, #32
 c03f04a:	6462      	str	r2, [r4, #68]	@ 0x44
          hi2c->State = HAL_I2C_STATE_READY;
 c03f04c:	2220      	movs	r2, #32
 c03f04e:	f884 2041 	strb.w	r2, [r4, #65]	@ 0x41
          hi2c->Mode = HAL_I2C_MODE_NONE;
 c03f052:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
      return HAL_ERROR;
 c03f056:	2001      	movs	r0, #1
}
 c03f058:	bd70      	pop	{r4, r5, r6, pc}

0c03f05a <I2C_WaitOnFlagUntilTimeout>:
{
 c03f05a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 c03f05e:	4604      	mov	r4, r0
 c03f060:	4688      	mov	r8, r1
 c03f062:	4616      	mov	r6, r2
 c03f064:	461d      	mov	r5, r3
 c03f066:	9f06      	ldr	r7, [sp, #24]
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 c03f068:	6822      	ldr	r2, [r4, #0]
 c03f06a:	6993      	ldr	r3, [r2, #24]
 c03f06c:	ea38 0303 	bics.w	r3, r8, r3
 c03f070:	bf0c      	ite	eq
 c03f072:	2301      	moveq	r3, #1
 c03f074:	2300      	movne	r3, #0
 c03f076:	42b3      	cmp	r3, r6
 c03f078:	d001      	beq.n	c03f07e <I2C_WaitOnFlagUntilTimeout+0x24>
  return HAL_OK;
 c03f07a:	2000      	movs	r0, #0
 c03f07c:	e01e      	b.n	c03f0bc <I2C_WaitOnFlagUntilTimeout+0x62>
    if (Timeout != HAL_MAX_DELAY)
 c03f07e:	1c6b      	adds	r3, r5, #1
 c03f080:	d0f3      	beq.n	c03f06a <I2C_WaitOnFlagUntilTimeout+0x10>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 c03f082:	f004 fe31 	bl	c043ce8 <HAL_GetTick>
 c03f086:	1bc0      	subs	r0, r0, r7
 c03f088:	42a8      	cmp	r0, r5
 c03f08a:	d801      	bhi.n	c03f090 <I2C_WaitOnFlagUntilTimeout+0x36>
 c03f08c:	2d00      	cmp	r5, #0
 c03f08e:	d1eb      	bne.n	c03f068 <I2C_WaitOnFlagUntilTimeout+0xe>
        if ((__HAL_I2C_GET_FLAG(hi2c, Flag) == Status))
 c03f090:	6823      	ldr	r3, [r4, #0]
 c03f092:	699b      	ldr	r3, [r3, #24]
 c03f094:	ea38 0303 	bics.w	r3, r8, r3
 c03f098:	bf0c      	ite	eq
 c03f09a:	2301      	moveq	r3, #1
 c03f09c:	2300      	movne	r3, #0
 c03f09e:	42b3      	cmp	r3, r6
 c03f0a0:	d1e2      	bne.n	c03f068 <I2C_WaitOnFlagUntilTimeout+0xe>
          hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 c03f0a2:	6c63      	ldr	r3, [r4, #68]	@ 0x44
          return HAL_ERROR;
 c03f0a4:	2001      	movs	r0, #1
          hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 c03f0a6:	f043 0320 	orr.w	r3, r3, #32
 c03f0aa:	6463      	str	r3, [r4, #68]	@ 0x44
          hi2c->State = HAL_I2C_STATE_READY;
 c03f0ac:	2320      	movs	r3, #32
 c03f0ae:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
          hi2c->Mode = HAL_I2C_MODE_NONE;
 c03f0b2:	2300      	movs	r3, #0
 c03f0b4:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
          __HAL_UNLOCK(hi2c);
 c03f0b8:	f884 3040 	strb.w	r3, [r4, #64]	@ 0x40
}
 c03f0bc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0c03f0c0 <I2C_WaitOnSTOPFlagUntilTimeout>:
{
 c03f0c0:	b570      	push	{r4, r5, r6, lr}
 c03f0c2:	4604      	mov	r4, r0
 c03f0c4:	460d      	mov	r5, r1
 c03f0c6:	4616      	mov	r6, r2
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 c03f0c8:	6823      	ldr	r3, [r4, #0]
 c03f0ca:	699b      	ldr	r3, [r3, #24]
 c03f0cc:	069b      	lsls	r3, r3, #26
 c03f0ce:	d501      	bpl.n	c03f0d4 <I2C_WaitOnSTOPFlagUntilTimeout+0x14>
  return HAL_OK;
 c03f0d0:	2000      	movs	r0, #0
 c03f0d2:	e01d      	b.n	c03f110 <I2C_WaitOnSTOPFlagUntilTimeout+0x50>
    if (I2C_IsErrorOccurred(hi2c, Timeout, Tickstart) != HAL_OK)
 c03f0d4:	4632      	mov	r2, r6
 c03f0d6:	4629      	mov	r1, r5
 c03f0d8:	4620      	mov	r0, r4
 c03f0da:	f7ff ff13 	bl	c03ef04 <I2C_IsErrorOccurred>
 c03f0de:	b9b0      	cbnz	r0, c03f10e <I2C_WaitOnSTOPFlagUntilTimeout+0x4e>
    if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 c03f0e0:	f004 fe02 	bl	c043ce8 <HAL_GetTick>
 c03f0e4:	1b80      	subs	r0, r0, r6
 c03f0e6:	42a8      	cmp	r0, r5
 c03f0e8:	d801      	bhi.n	c03f0ee <I2C_WaitOnSTOPFlagUntilTimeout+0x2e>
 c03f0ea:	2d00      	cmp	r5, #0
 c03f0ec:	d1ec      	bne.n	c03f0c8 <I2C_WaitOnSTOPFlagUntilTimeout+0x8>
      if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET))
 c03f0ee:	6823      	ldr	r3, [r4, #0]
 c03f0f0:	699b      	ldr	r3, [r3, #24]
 c03f0f2:	f013 0320 	ands.w	r3, r3, #32
 c03f0f6:	d1e7      	bne.n	c03f0c8 <I2C_WaitOnSTOPFlagUntilTimeout+0x8>
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 c03f0f8:	6c62      	ldr	r2, [r4, #68]	@ 0x44
        __HAL_UNLOCK(hi2c);
 c03f0fa:	f884 3040 	strb.w	r3, [r4, #64]	@ 0x40
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 c03f0fe:	f042 0220 	orr.w	r2, r2, #32
 c03f102:	6462      	str	r2, [r4, #68]	@ 0x44
        hi2c->State = HAL_I2C_STATE_READY;
 c03f104:	2220      	movs	r2, #32
 c03f106:	f884 2041 	strb.w	r2, [r4, #65]	@ 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
 c03f10a:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
      return HAL_ERROR;
 c03f10e:	2001      	movs	r0, #1
}
 c03f110:	bd70      	pop	{r4, r5, r6, pc}

0c03f112 <I2C_WaitOnRXNEFlagUntilTimeout>:
{
 c03f112:	b570      	push	{r4, r5, r6, lr}
 c03f114:	4604      	mov	r4, r0
 c03f116:	460d      	mov	r5, r1
 c03f118:	4616      	mov	r6, r2
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == RESET)
 c03f11a:	6823      	ldr	r3, [r4, #0]
 c03f11c:	699b      	ldr	r3, [r3, #24]
 c03f11e:	075b      	lsls	r3, r3, #29
 c03f120:	d40e      	bmi.n	c03f140 <I2C_WaitOnRXNEFlagUntilTimeout+0x2e>
    if (I2C_IsErrorOccurred(hi2c, Timeout, Tickstart) != HAL_OK)
 c03f122:	4632      	mov	r2, r6
 c03f124:	4629      	mov	r1, r5
 c03f126:	4620      	mov	r0, r4
 c03f128:	f7ff feec 	bl	c03ef04 <I2C_IsErrorOccurred>
 c03f12c:	bb30      	cbnz	r0, c03f17c <I2C_WaitOnRXNEFlagUntilTimeout+0x6a>
    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == SET)
 c03f12e:	6823      	ldr	r3, [r4, #0]
 c03f130:	699a      	ldr	r2, [r3, #24]
 c03f132:	0690      	lsls	r0, r2, #26
 c03f134:	d524      	bpl.n	c03f180 <I2C_WaitOnRXNEFlagUntilTimeout+0x6e>
      if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET) && (hi2c->XferSize > 0U))
 c03f136:	699a      	ldr	r2, [r3, #24]
 c03f138:	0751      	lsls	r1, r2, #29
 c03f13a:	d503      	bpl.n	c03f144 <I2C_WaitOnRXNEFlagUntilTimeout+0x32>
 c03f13c:	8d22      	ldrh	r2, [r4, #40]	@ 0x28
 c03f13e:	b10a      	cbz	r2, c03f144 <I2C_WaitOnRXNEFlagUntilTimeout+0x32>
        return HAL_OK;
 c03f140:	2000      	movs	r0, #0
}
 c03f142:	bd70      	pop	{r4, r5, r6, pc}
        if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 c03f144:	699a      	ldr	r2, [r3, #24]
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 c03f146:	2120      	movs	r1, #32
        if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 c03f148:	f012 0210 	ands.w	r2, r2, #16
          __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 c03f14c:	bf1e      	ittt	ne
 c03f14e:	2210      	movne	r2, #16
 c03f150:	61da      	strne	r2, [r3, #28]
          hi2c->ErrorCode = HAL_I2C_ERROR_AF;
 c03f152:	2204      	movne	r2, #4
          hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 c03f154:	6462      	str	r2, [r4, #68]	@ 0x44
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 c03f156:	61d9      	str	r1, [r3, #28]
        I2C_RESET_CR2(hi2c);
 c03f158:	685a      	ldr	r2, [r3, #4]
 c03f15a:	f022 72ff 	bic.w	r2, r2, #33423360	@ 0x1fe0000
 c03f15e:	f422 328b 	bic.w	r2, r2, #71168	@ 0x11600
 c03f162:	f422 72ff 	bic.w	r2, r2, #510	@ 0x1fe
 c03f166:	f022 0201 	bic.w	r2, r2, #1
 c03f16a:	605a      	str	r2, [r3, #4]
        hi2c->Mode = HAL_I2C_MODE_NONE;
 c03f16c:	2300      	movs	r3, #0
        hi2c->State = HAL_I2C_STATE_READY;
 c03f16e:	f884 1041 	strb.w	r1, [r4, #65]	@ 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
 c03f172:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
        __HAL_UNLOCK(hi2c);
 c03f176:	2300      	movs	r3, #0
 c03f178:	f884 3040 	strb.w	r3, [r4, #64]	@ 0x40
      return HAL_ERROR;
 c03f17c:	2001      	movs	r0, #1
 c03f17e:	e7e0      	b.n	c03f142 <I2C_WaitOnRXNEFlagUntilTimeout+0x30>
    if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 c03f180:	f004 fdb2 	bl	c043ce8 <HAL_GetTick>
 c03f184:	1b80      	subs	r0, r0, r6
 c03f186:	42a8      	cmp	r0, r5
 c03f188:	d801      	bhi.n	c03f18e <I2C_WaitOnRXNEFlagUntilTimeout+0x7c>
 c03f18a:	2d00      	cmp	r5, #0
 c03f18c:	d1c5      	bne.n	c03f11a <I2C_WaitOnRXNEFlagUntilTimeout+0x8>
      if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == RESET))
 c03f18e:	6823      	ldr	r3, [r4, #0]
 c03f190:	699b      	ldr	r3, [r3, #24]
 c03f192:	075a      	lsls	r2, r3, #29
 c03f194:	d4c1      	bmi.n	c03f11a <I2C_WaitOnRXNEFlagUntilTimeout+0x8>
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 c03f196:	6c63      	ldr	r3, [r4, #68]	@ 0x44
 c03f198:	f043 0320 	orr.w	r3, r3, #32
 c03f19c:	6463      	str	r3, [r4, #68]	@ 0x44
        hi2c->State = HAL_I2C_STATE_READY;
 c03f19e:	2320      	movs	r3, #32
 c03f1a0:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
        return HAL_ERROR;
 c03f1a4:	e7e7      	b.n	c03f176 <I2C_WaitOnRXNEFlagUntilTimeout+0x64>

0c03f1a6 <HAL_I2C_MspInit>:
}
 c03f1a6:	4770      	bx	lr

0c03f1a8 <HAL_I2C_Init>:
{
 c03f1a8:	b510      	push	{r4, lr}
  if (hi2c == NULL)
 c03f1aa:	4604      	mov	r4, r0
 c03f1ac:	2800      	cmp	r0, #0
 c03f1ae:	d04a      	beq.n	c03f246 <HAL_I2C_Init+0x9e>
  if (hi2c->State == HAL_I2C_STATE_RESET)
 c03f1b0:	f890 3041 	ldrb.w	r3, [r0, #65]	@ 0x41
 c03f1b4:	f003 02ff 	and.w	r2, r3, #255	@ 0xff
 c03f1b8:	b91b      	cbnz	r3, c03f1c2 <HAL_I2C_Init+0x1a>
    hi2c->Lock = HAL_UNLOCKED;
 c03f1ba:	f880 2040 	strb.w	r2, [r0, #64]	@ 0x40
    HAL_I2C_MspInit(hi2c);
 c03f1be:	f7ff fff2 	bl	c03f1a6 <HAL_I2C_MspInit>
  hi2c->State = HAL_I2C_STATE_BUSY;
 c03f1c2:	2324      	movs	r3, #36	@ 0x24
 c03f1c4:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
  __HAL_I2C_DISABLE(hi2c);
 c03f1c8:	6823      	ldr	r3, [r4, #0]
 c03f1ca:	681a      	ldr	r2, [r3, #0]
 c03f1cc:	f022 0201 	bic.w	r2, r2, #1
 c03f1d0:	601a      	str	r2, [r3, #0]
  hi2c->Instance->TIMINGR = hi2c->Init.Timing & TIMING_CLEAR_MASK;
 c03f1d2:	6862      	ldr	r2, [r4, #4]
 c03f1d4:	f022 6270 	bic.w	r2, r2, #251658240	@ 0xf000000
 c03f1d8:	611a      	str	r2, [r3, #16]
  hi2c->Instance->OAR1 &= ~I2C_OAR1_OA1EN;
 c03f1da:	689a      	ldr	r2, [r3, #8]
 c03f1dc:	f422 4200 	bic.w	r2, r2, #32768	@ 0x8000
 c03f1e0:	609a      	str	r2, [r3, #8]
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | hi2c->Init.OwnAddress1);
 c03f1e2:	e9d4 2102 	ldrd	r2, r1, [r4, #8]
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
 c03f1e6:	2901      	cmp	r1, #1
 c03f1e8:	d124      	bne.n	c03f234 <HAL_I2C_Init+0x8c>
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | hi2c->Init.OwnAddress1);
 c03f1ea:	f442 4200 	orr.w	r2, r2, #32768	@ 0x8000
 c03f1ee:	609a      	str	r2, [r3, #8]
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
 c03f1f0:	685a      	ldr	r2, [r3, #4]
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 c03f1f2:	2000      	movs	r0, #0
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
 c03f1f4:	f042 7200 	orr.w	r2, r2, #33554432	@ 0x2000000
 c03f1f8:	f442 4200 	orr.w	r2, r2, #32768	@ 0x8000
 c03f1fc:	605a      	str	r2, [r3, #4]
  hi2c->Instance->OAR2 &= ~I2C_DUALADDRESS_ENABLE;
 c03f1fe:	68da      	ldr	r2, [r3, #12]
 c03f200:	f422 4200 	bic.w	r2, r2, #32768	@ 0x8000
 c03f204:	60da      	str	r2, [r3, #12]
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | \
 c03f206:	e9d4 2104 	ldrd	r2, r1, [r4, #16]
 c03f20a:	430a      	orrs	r2, r1
                          (hi2c->Init.OwnAddress2Masks << 8));
 c03f20c:	69a1      	ldr	r1, [r4, #24]
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | \
 c03f20e:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 c03f212:	60da      	str	r2, [r3, #12]
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
 c03f214:	e9d4 2107 	ldrd	r2, r1, [r4, #28]
 c03f218:	430a      	orrs	r2, r1
 c03f21a:	601a      	str	r2, [r3, #0]
  __HAL_I2C_ENABLE(hi2c);
 c03f21c:	681a      	ldr	r2, [r3, #0]
 c03f21e:	f042 0201 	orr.w	r2, r2, #1
 c03f222:	601a      	str	r2, [r3, #0]
  hi2c->State = HAL_I2C_STATE_READY;
 c03f224:	2320      	movs	r3, #32
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 c03f226:	6460      	str	r0, [r4, #68]	@ 0x44
  hi2c->State = HAL_I2C_STATE_READY;
 c03f228:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
  hi2c->PreviousState = I2C_STATE_NONE;
 c03f22c:	6320      	str	r0, [r4, #48]	@ 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
 c03f22e:	f884 0042 	strb.w	r0, [r4, #66]	@ 0x42
}
 c03f232:	bd10      	pop	{r4, pc}
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);
 c03f234:	f442 4204 	orr.w	r2, r2, #33792	@ 0x8400
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
 c03f238:	2902      	cmp	r1, #2
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);
 c03f23a:	609a      	str	r2, [r3, #8]
    hi2c->Instance->CR2 = (I2C_CR2_ADD10);
 c03f23c:	bf04      	itt	eq
 c03f23e:	f44f 6200 	moveq.w	r2, #2048	@ 0x800
 c03f242:	605a      	streq	r2, [r3, #4]
 c03f244:	e7d4      	b.n	c03f1f0 <HAL_I2C_Init+0x48>
    return HAL_ERROR;
 c03f246:	2001      	movs	r0, #1
 c03f248:	e7f3      	b.n	c03f232 <HAL_I2C_Init+0x8a>

0c03f24a <HAL_I2C_MspDeInit>:
__weak void HAL_I2C_MspDeInit(I2C_HandleTypeDef *hi2c)
 c03f24a:	4770      	bx	lr

0c03f24c <HAL_I2C_DeInit>:
{
 c03f24c:	b510      	push	{r4, lr}
  if (hi2c == NULL)
 c03f24e:	4604      	mov	r4, r0
 c03f250:	b198      	cbz	r0, c03f27a <HAL_I2C_DeInit+0x2e>
  hi2c->State = HAL_I2C_STATE_BUSY;
 c03f252:	2324      	movs	r3, #36	@ 0x24
  __HAL_I2C_DISABLE(hi2c);
 c03f254:	6802      	ldr	r2, [r0, #0]
  hi2c->State = HAL_I2C_STATE_BUSY;
 c03f256:	f880 3041 	strb.w	r3, [r0, #65]	@ 0x41
  __HAL_I2C_DISABLE(hi2c);
 c03f25a:	6813      	ldr	r3, [r2, #0]
 c03f25c:	f023 0301 	bic.w	r3, r3, #1
 c03f260:	6013      	str	r3, [r2, #0]
  HAL_I2C_MspDeInit(hi2c);
 c03f262:	f7ff fff2 	bl	c03f24a <HAL_I2C_MspDeInit>
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 c03f266:	2000      	movs	r0, #0
 c03f268:	6460      	str	r0, [r4, #68]	@ 0x44
  __HAL_UNLOCK(hi2c);
 c03f26a:	f884 0040 	strb.w	r0, [r4, #64]	@ 0x40
  hi2c->State = HAL_I2C_STATE_RESET;
 c03f26e:	f884 0041 	strb.w	r0, [r4, #65]	@ 0x41
  hi2c->PreviousState = I2C_STATE_NONE;
 c03f272:	6320      	str	r0, [r4, #48]	@ 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
 c03f274:	f884 0042 	strb.w	r0, [r4, #66]	@ 0x42
}
 c03f278:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
 c03f27a:	2001      	movs	r0, #1
 c03f27c:	e7fc      	b.n	c03f278 <HAL_I2C_DeInit+0x2c>
	...

0c03f280 <HAL_I2C_Master_Transmit>:
{
 c03f280:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
 c03f284:	4698      	mov	r8, r3
  if (hi2c->State == HAL_I2C_STATE_READY)
 c03f286:	f890 3041 	ldrb.w	r3, [r0, #65]	@ 0x41
{
 c03f28a:	4604      	mov	r4, r0
  if (hi2c->State == HAL_I2C_STATE_READY)
 c03f28c:	2b20      	cmp	r3, #32
{
 c03f28e:	460e      	mov	r6, r1
 c03f290:	4691      	mov	r9, r2
 c03f292:	9f0a      	ldr	r7, [sp, #40]	@ 0x28
  if (hi2c->State == HAL_I2C_STATE_READY)
 c03f294:	f040 8086 	bne.w	c03f3a4 <HAL_I2C_Master_Transmit+0x124>
    __HAL_LOCK(hi2c);
 c03f298:	f890 3040 	ldrb.w	r3, [r0, #64]	@ 0x40
 c03f29c:	2b01      	cmp	r3, #1
 c03f29e:	f000 8081 	beq.w	c03f3a4 <HAL_I2C_Master_Transmit+0x124>
 c03f2a2:	f04f 0a01 	mov.w	sl, #1
 c03f2a6:	f880 a040 	strb.w	sl, [r0, #64]	@ 0x40
    tickstart = HAL_GetTick();
 c03f2aa:	f004 fd1d 	bl	c043ce8 <HAL_GetTick>
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
 c03f2ae:	2319      	movs	r3, #25
    tickstart = HAL_GetTick();
 c03f2b0:	4605      	mov	r5, r0
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
 c03f2b2:	9000      	str	r0, [sp, #0]
 c03f2b4:	4652      	mov	r2, sl
 c03f2b6:	f44f 4100 	mov.w	r1, #32768	@ 0x8000
 c03f2ba:	4620      	mov	r0, r4
 c03f2bc:	f7ff fecd 	bl	c03f05a <I2C_WaitOnFlagUntilTimeout>
 c03f2c0:	b118      	cbz	r0, c03f2ca <HAL_I2C_Master_Transmit+0x4a>
      return HAL_ERROR;
 c03f2c2:	2001      	movs	r0, #1
}
 c03f2c4:	b002      	add	sp, #8
 c03f2c6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
 c03f2ca:	2321      	movs	r3, #33	@ 0x21
 c03f2cc:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
    hi2c->Mode      = HAL_I2C_MODE_MASTER;
 c03f2d0:	2310      	movs	r3, #16
 c03f2d2:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 c03f2d6:	6460      	str	r0, [r4, #68]	@ 0x44
    hi2c->XferCount = Size;
 c03f2d8:	f8a4 802a 	strh.w	r8, [r4, #42]	@ 0x2a
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 c03f2dc:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
    hi2c->pBuffPtr  = pData;
 c03f2de:	f8c4 9024 	str.w	r9, [r4, #36]	@ 0x24
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 c03f2e2:	b29b      	uxth	r3, r3
 c03f2e4:	2bff      	cmp	r3, #255	@ 0xff
    hi2c->XferISR   = NULL;
 c03f2e6:	6360      	str	r0, [r4, #52]	@ 0x34
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 c03f2e8:	4b2f      	ldr	r3, [pc, #188]	@ (c03f3a8 <HAL_I2C_Master_Transmit+0x128>)
 c03f2ea:	d926      	bls.n	c03f33a <HAL_I2C_Master_Transmit+0xba>
      hi2c->XferSize = MAX_NBYTE_SIZE;
 c03f2ec:	22ff      	movs	r2, #255	@ 0xff
 c03f2ee:	8522      	strh	r2, [r4, #40]	@ 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE,
 c03f2f0:	9300      	str	r3, [sp, #0]
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE,
 c03f2f2:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
 c03f2f6:	4631      	mov	r1, r6
 c03f2f8:	4620      	mov	r0, r4
 c03f2fa:	f7ff fded 	bl	c03eed8 <I2C_TransferConfig>
    while (hi2c->XferCount > 0U)
 c03f2fe:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
      if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 c03f300:	462a      	mov	r2, r5
    while (hi2c->XferCount > 0U)
 c03f302:	b29b      	uxth	r3, r3
      if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 c03f304:	4639      	mov	r1, r7
 c03f306:	4620      	mov	r0, r4
    while (hi2c->XferCount > 0U)
 c03f308:	b9fb      	cbnz	r3, c03f34a <HAL_I2C_Master_Transmit+0xca>
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 c03f30a:	f7ff fed9 	bl	c03f0c0 <I2C_WaitOnSTOPFlagUntilTimeout>
 c03f30e:	2800      	cmp	r0, #0
 c03f310:	d1d7      	bne.n	c03f2c2 <HAL_I2C_Master_Transmit+0x42>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 c03f312:	2120      	movs	r1, #32
 c03f314:	6823      	ldr	r3, [r4, #0]
 c03f316:	61d9      	str	r1, [r3, #28]
    I2C_RESET_CR2(hi2c);
 c03f318:	685a      	ldr	r2, [r3, #4]
 c03f31a:	f022 72ff 	bic.w	r2, r2, #33423360	@ 0x1fe0000
 c03f31e:	f422 328b 	bic.w	r2, r2, #71168	@ 0x11600
 c03f322:	f422 72ff 	bic.w	r2, r2, #510	@ 0x1fe
 c03f326:	f022 0201 	bic.w	r2, r2, #1
 c03f32a:	605a      	str	r2, [r3, #4]
    hi2c->State = HAL_I2C_STATE_READY;
 c03f32c:	f884 1041 	strb.w	r1, [r4, #65]	@ 0x41
    __HAL_UNLOCK(hi2c);
 c03f330:	f884 0040 	strb.w	r0, [r4, #64]	@ 0x40
    hi2c->Mode  = HAL_I2C_MODE_NONE;
 c03f334:	f884 0042 	strb.w	r0, [r4, #66]	@ 0x42
    return HAL_OK;
 c03f338:	e7c4      	b.n	c03f2c4 <HAL_I2C_Master_Transmit+0x44>
      hi2c->XferSize = hi2c->XferCount;
 c03f33a:	8d62      	ldrh	r2, [r4, #42]	@ 0x2a
 c03f33c:	b292      	uxth	r2, r2
 c03f33e:	8522      	strh	r2, [r4, #40]	@ 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
 c03f340:	9300      	str	r3, [sp, #0]
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
 c03f342:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
 c03f346:	b2d2      	uxtb	r2, r2
 c03f348:	e7d5      	b.n	c03f2f6 <HAL_I2C_Master_Transmit+0x76>
      if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 c03f34a:	f7ff fe5b 	bl	c03f004 <I2C_WaitOnTXISFlagUntilTimeout>
 c03f34e:	2800      	cmp	r0, #0
 c03f350:	d1b7      	bne.n	c03f2c2 <HAL_I2C_Master_Transmit+0x42>
      hi2c->Instance->TXDR = *hi2c->pBuffPtr;
 c03f352:	6a63      	ldr	r3, [r4, #36]	@ 0x24
 c03f354:	6822      	ldr	r2, [r4, #0]
 c03f356:	f813 1b01 	ldrb.w	r1, [r3], #1
 c03f35a:	6291      	str	r1, [r2, #40]	@ 0x28
      hi2c->pBuffPtr++;
 c03f35c:	6263      	str	r3, [r4, #36]	@ 0x24
      hi2c->XferCount--;
 c03f35e:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
      hi2c->XferSize--;
 c03f360:	8d22      	ldrh	r2, [r4, #40]	@ 0x28
      hi2c->XferCount--;
 c03f362:	3b01      	subs	r3, #1
 c03f364:	b29b      	uxth	r3, r3
 c03f366:	8563      	strh	r3, [r4, #42]	@ 0x2a
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
 c03f368:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
      hi2c->XferSize--;
 c03f36a:	3a01      	subs	r2, #1
 c03f36c:	b292      	uxth	r2, r2
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
 c03f36e:	b29b      	uxth	r3, r3
      hi2c->XferSize--;
 c03f370:	8522      	strh	r2, [r4, #40]	@ 0x28
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
 c03f372:	2b00      	cmp	r3, #0
 c03f374:	d0c3      	beq.n	c03f2fe <HAL_I2C_Master_Transmit+0x7e>
 c03f376:	2a00      	cmp	r2, #0
 c03f378:	d1c1      	bne.n	c03f2fe <HAL_I2C_Master_Transmit+0x7e>
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
 c03f37a:	463b      	mov	r3, r7
 c03f37c:	2180      	movs	r1, #128	@ 0x80
 c03f37e:	4620      	mov	r0, r4
 c03f380:	9500      	str	r5, [sp, #0]
 c03f382:	f7ff fe6a 	bl	c03f05a <I2C_WaitOnFlagUntilTimeout>
 c03f386:	2800      	cmp	r0, #0
 c03f388:	d19b      	bne.n	c03f2c2 <HAL_I2C_Master_Transmit+0x42>
        if (hi2c->XferCount > MAX_NBYTE_SIZE)
 c03f38a:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
 c03f38c:	b29b      	uxth	r3, r3
 c03f38e:	2bff      	cmp	r3, #255	@ 0xff
 c03f390:	d903      	bls.n	c03f39a <HAL_I2C_Master_Transmit+0x11a>
          hi2c->XferSize = MAX_NBYTE_SIZE;
 c03f392:	22ff      	movs	r2, #255	@ 0xff
 c03f394:	8522      	strh	r2, [r4, #40]	@ 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE,
 c03f396:	9000      	str	r0, [sp, #0]
 c03f398:	e7ab      	b.n	c03f2f2 <HAL_I2C_Master_Transmit+0x72>
          hi2c->XferSize = hi2c->XferCount;
 c03f39a:	8d62      	ldrh	r2, [r4, #42]	@ 0x2a
 c03f39c:	b292      	uxth	r2, r2
 c03f39e:	8522      	strh	r2, [r4, #40]	@ 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
 c03f3a0:	9000      	str	r0, [sp, #0]
 c03f3a2:	e7ce      	b.n	c03f342 <HAL_I2C_Master_Transmit+0xc2>
    __HAL_LOCK(hi2c);
 c03f3a4:	2002      	movs	r0, #2
 c03f3a6:	e78d      	b.n	c03f2c4 <HAL_I2C_Master_Transmit+0x44>
 c03f3a8:	80002000 	.word	0x80002000

0c03f3ac <HAL_I2C_Master_Receive>:
{
 c03f3ac:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
 c03f3b0:	4698      	mov	r8, r3
  if (hi2c->State == HAL_I2C_STATE_READY)
 c03f3b2:	f890 3041 	ldrb.w	r3, [r0, #65]	@ 0x41
{
 c03f3b6:	4604      	mov	r4, r0
  if (hi2c->State == HAL_I2C_STATE_READY)
 c03f3b8:	2b20      	cmp	r3, #32
{
 c03f3ba:	460e      	mov	r6, r1
 c03f3bc:	4691      	mov	r9, r2
 c03f3be:	9f0a      	ldr	r7, [sp, #40]	@ 0x28
  if (hi2c->State == HAL_I2C_STATE_READY)
 c03f3c0:	f040 8087 	bne.w	c03f4d2 <HAL_I2C_Master_Receive+0x126>
    __HAL_LOCK(hi2c);
 c03f3c4:	f890 3040 	ldrb.w	r3, [r0, #64]	@ 0x40
 c03f3c8:	2b01      	cmp	r3, #1
 c03f3ca:	f000 8082 	beq.w	c03f4d2 <HAL_I2C_Master_Receive+0x126>
 c03f3ce:	f04f 0a01 	mov.w	sl, #1
 c03f3d2:	f880 a040 	strb.w	sl, [r0, #64]	@ 0x40
    tickstart = HAL_GetTick();
 c03f3d6:	f004 fc87 	bl	c043ce8 <HAL_GetTick>
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
 c03f3da:	2319      	movs	r3, #25
    tickstart = HAL_GetTick();
 c03f3dc:	4605      	mov	r5, r0
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
 c03f3de:	9000      	str	r0, [sp, #0]
 c03f3e0:	4652      	mov	r2, sl
 c03f3e2:	f44f 4100 	mov.w	r1, #32768	@ 0x8000
 c03f3e6:	4620      	mov	r0, r4
 c03f3e8:	f7ff fe37 	bl	c03f05a <I2C_WaitOnFlagUntilTimeout>
 c03f3ec:	b118      	cbz	r0, c03f3f6 <HAL_I2C_Master_Receive+0x4a>
      return HAL_ERROR;
 c03f3ee:	2001      	movs	r0, #1
}
 c03f3f0:	b002      	add	sp, #8
 c03f3f2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
 c03f3f6:	2322      	movs	r3, #34	@ 0x22
 c03f3f8:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
    hi2c->Mode      = HAL_I2C_MODE_MASTER;
 c03f3fc:	2310      	movs	r3, #16
 c03f3fe:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 c03f402:	6460      	str	r0, [r4, #68]	@ 0x44
    hi2c->XferCount = Size;
 c03f404:	f8a4 802a 	strh.w	r8, [r4, #42]	@ 0x2a
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 c03f408:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
    hi2c->pBuffPtr  = pData;
 c03f40a:	f8c4 9024 	str.w	r9, [r4, #36]	@ 0x24
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 c03f40e:	b29b      	uxth	r3, r3
 c03f410:	2bff      	cmp	r3, #255	@ 0xff
    hi2c->XferISR   = NULL;
 c03f412:	6360      	str	r0, [r4, #52]	@ 0x34
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 c03f414:	4b30      	ldr	r3, [pc, #192]	@ (c03f4d8 <HAL_I2C_Master_Receive+0x12c>)
 c03f416:	d926      	bls.n	c03f466 <HAL_I2C_Master_Receive+0xba>
      hi2c->XferSize = MAX_NBYTE_SIZE;
 c03f418:	22ff      	movs	r2, #255	@ 0xff
 c03f41a:	8522      	strh	r2, [r4, #40]	@ 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE,
 c03f41c:	9300      	str	r3, [sp, #0]
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE,
 c03f41e:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
 c03f422:	4631      	mov	r1, r6
 c03f424:	4620      	mov	r0, r4
 c03f426:	f7ff fd57 	bl	c03eed8 <I2C_TransferConfig>
    while (hi2c->XferCount > 0U)
 c03f42a:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
      if (I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 c03f42c:	462a      	mov	r2, r5
    while (hi2c->XferCount > 0U)
 c03f42e:	b29b      	uxth	r3, r3
      if (I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 c03f430:	4639      	mov	r1, r7
 c03f432:	4620      	mov	r0, r4
    while (hi2c->XferCount > 0U)
 c03f434:	b9fb      	cbnz	r3, c03f476 <HAL_I2C_Master_Receive+0xca>
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 c03f436:	f7ff fe43 	bl	c03f0c0 <I2C_WaitOnSTOPFlagUntilTimeout>
 c03f43a:	2800      	cmp	r0, #0
 c03f43c:	d1d7      	bne.n	c03f3ee <HAL_I2C_Master_Receive+0x42>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 c03f43e:	2120      	movs	r1, #32
 c03f440:	6823      	ldr	r3, [r4, #0]
 c03f442:	61d9      	str	r1, [r3, #28]
    I2C_RESET_CR2(hi2c);
 c03f444:	685a      	ldr	r2, [r3, #4]
 c03f446:	f022 72ff 	bic.w	r2, r2, #33423360	@ 0x1fe0000
 c03f44a:	f422 328b 	bic.w	r2, r2, #71168	@ 0x11600
 c03f44e:	f422 72ff 	bic.w	r2, r2, #510	@ 0x1fe
 c03f452:	f022 0201 	bic.w	r2, r2, #1
 c03f456:	605a      	str	r2, [r3, #4]
    hi2c->State = HAL_I2C_STATE_READY;
 c03f458:	f884 1041 	strb.w	r1, [r4, #65]	@ 0x41
    __HAL_UNLOCK(hi2c);
 c03f45c:	f884 0040 	strb.w	r0, [r4, #64]	@ 0x40
    hi2c->Mode  = HAL_I2C_MODE_NONE;
 c03f460:	f884 0042 	strb.w	r0, [r4, #66]	@ 0x42
    return HAL_OK;
 c03f464:	e7c4      	b.n	c03f3f0 <HAL_I2C_Master_Receive+0x44>
      hi2c->XferSize = hi2c->XferCount;
 c03f466:	8d62      	ldrh	r2, [r4, #42]	@ 0x2a
 c03f468:	b292      	uxth	r2, r2
 c03f46a:	8522      	strh	r2, [r4, #40]	@ 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
 c03f46c:	9300      	str	r3, [sp, #0]
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
 c03f46e:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
 c03f472:	b2d2      	uxtb	r2, r2
 c03f474:	e7d5      	b.n	c03f422 <HAL_I2C_Master_Receive+0x76>
      if (I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 c03f476:	f7ff fe4c 	bl	c03f112 <I2C_WaitOnRXNEFlagUntilTimeout>
 c03f47a:	2800      	cmp	r0, #0
 c03f47c:	d1b7      	bne.n	c03f3ee <HAL_I2C_Master_Receive+0x42>
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
 c03f47e:	6823      	ldr	r3, [r4, #0]
 c03f480:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 c03f482:	6a63      	ldr	r3, [r4, #36]	@ 0x24
 c03f484:	701a      	strb	r2, [r3, #0]
      hi2c->pBuffPtr++;
 c03f486:	6a63      	ldr	r3, [r4, #36]	@ 0x24
      hi2c->XferSize--;
 c03f488:	8d22      	ldrh	r2, [r4, #40]	@ 0x28
      hi2c->pBuffPtr++;
 c03f48a:	3301      	adds	r3, #1
 c03f48c:	6263      	str	r3, [r4, #36]	@ 0x24
      hi2c->XferCount--;
 c03f48e:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
      hi2c->XferSize--;
 c03f490:	3a01      	subs	r2, #1
      hi2c->XferCount--;
 c03f492:	3b01      	subs	r3, #1
 c03f494:	b29b      	uxth	r3, r3
 c03f496:	8563      	strh	r3, [r4, #42]	@ 0x2a
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
 c03f498:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
      hi2c->XferSize--;
 c03f49a:	b292      	uxth	r2, r2
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
 c03f49c:	b29b      	uxth	r3, r3
      hi2c->XferSize--;
 c03f49e:	8522      	strh	r2, [r4, #40]	@ 0x28
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
 c03f4a0:	2b00      	cmp	r3, #0
 c03f4a2:	d0c2      	beq.n	c03f42a <HAL_I2C_Master_Receive+0x7e>
 c03f4a4:	2a00      	cmp	r2, #0
 c03f4a6:	d1c0      	bne.n	c03f42a <HAL_I2C_Master_Receive+0x7e>
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
 c03f4a8:	463b      	mov	r3, r7
 c03f4aa:	2180      	movs	r1, #128	@ 0x80
 c03f4ac:	4620      	mov	r0, r4
 c03f4ae:	9500      	str	r5, [sp, #0]
 c03f4b0:	f7ff fdd3 	bl	c03f05a <I2C_WaitOnFlagUntilTimeout>
 c03f4b4:	2800      	cmp	r0, #0
 c03f4b6:	d19a      	bne.n	c03f3ee <HAL_I2C_Master_Receive+0x42>
        if (hi2c->XferCount > MAX_NBYTE_SIZE)
 c03f4b8:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
 c03f4ba:	b29b      	uxth	r3, r3
 c03f4bc:	2bff      	cmp	r3, #255	@ 0xff
 c03f4be:	d903      	bls.n	c03f4c8 <HAL_I2C_Master_Receive+0x11c>
          hi2c->XferSize = MAX_NBYTE_SIZE;
 c03f4c0:	22ff      	movs	r2, #255	@ 0xff
 c03f4c2:	8522      	strh	r2, [r4, #40]	@ 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE,
 c03f4c4:	9000      	str	r0, [sp, #0]
 c03f4c6:	e7aa      	b.n	c03f41e <HAL_I2C_Master_Receive+0x72>
          hi2c->XferSize = hi2c->XferCount;
 c03f4c8:	8d62      	ldrh	r2, [r4, #42]	@ 0x2a
 c03f4ca:	b292      	uxth	r2, r2
 c03f4cc:	8522      	strh	r2, [r4, #40]	@ 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
 c03f4ce:	9000      	str	r0, [sp, #0]
 c03f4d0:	e7cd      	b.n	c03f46e <HAL_I2C_Master_Receive+0xc2>
    __HAL_LOCK(hi2c);
 c03f4d2:	2002      	movs	r0, #2
 c03f4d4:	e78c      	b.n	c03f3f0 <HAL_I2C_Master_Receive+0x44>
 c03f4d6:	bf00      	nop
 c03f4d8:	80002400 	.word	0x80002400

0c03f4dc <HAL_I2C_GetState>:
  return hi2c->State;
 c03f4dc:	f890 0041 	ldrb.w	r0, [r0, #65]	@ 0x41
}
 c03f4e0:	4770      	bx	lr

0c03f4e2 <HAL_I2C_GetError>:
  return hi2c->ErrorCode;
 c03f4e2:	6c40      	ldr	r0, [r0, #68]	@ 0x44
}
 c03f4e4:	4770      	bx	lr

0c03f4e6 <HAL_I2CEx_ConfigAnalogFilter>:
  *                the configuration information for the specified I2Cx peripheral.
  * @param  AnalogFilter New state of the Analog filter.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_ConfigAnalogFilter(I2C_HandleTypeDef *hi2c, uint32_t AnalogFilter)
{
 c03f4e6:	b510      	push	{r4, lr}
  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_I2C_ANALOG_FILTER(AnalogFilter));

  if (hi2c->State == HAL_I2C_STATE_READY)
 c03f4e8:	f890 2041 	ldrb.w	r2, [r0, #65]	@ 0x41
{
 c03f4ec:	4603      	mov	r3, r0
  if (hi2c->State == HAL_I2C_STATE_READY)
 c03f4ee:	2a20      	cmp	r2, #32
 c03f4f0:	b2d4      	uxtb	r4, r2
 c03f4f2:	d11c      	bne.n	c03f52e <HAL_I2CEx_ConfigAnalogFilter+0x48>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
 c03f4f4:	f890 2040 	ldrb.w	r2, [r0, #64]	@ 0x40
 c03f4f8:	2a01      	cmp	r2, #1
 c03f4fa:	d018      	beq.n	c03f52e <HAL_I2CEx_ConfigAnalogFilter+0x48>

    hi2c->State = HAL_I2C_STATE_BUSY;
 c03f4fc:	2224      	movs	r2, #36	@ 0x24
 c03f4fe:	f880 2041 	strb.w	r2, [r0, #65]	@ 0x41

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
 c03f502:	6802      	ldr	r2, [r0, #0]
 c03f504:	6810      	ldr	r0, [r2, #0]
 c03f506:	f020 0001 	bic.w	r0, r0, #1
 c03f50a:	6010      	str	r0, [r2, #0]

    /* Reset I2Cx ANOFF bit */
    hi2c->Instance->CR1 &= ~(I2C_CR1_ANFOFF);
 c03f50c:	6810      	ldr	r0, [r2, #0]
 c03f50e:	f420 5080 	bic.w	r0, r0, #4096	@ 0x1000
 c03f512:	6010      	str	r0, [r2, #0]

    /* Set analog filter bit*/
    hi2c->Instance->CR1 |= AnalogFilter;
 c03f514:	6810      	ldr	r0, [r2, #0]
 c03f516:	4301      	orrs	r1, r0
    __HAL_I2C_ENABLE(hi2c);

    hi2c->State = HAL_I2C_STATE_READY;

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 c03f518:	2000      	movs	r0, #0
    hi2c->Instance->CR1 |= AnalogFilter;
 c03f51a:	6011      	str	r1, [r2, #0]
    __HAL_I2C_ENABLE(hi2c);
 c03f51c:	6811      	ldr	r1, [r2, #0]
 c03f51e:	f041 0101 	orr.w	r1, r1, #1
 c03f522:	6011      	str	r1, [r2, #0]
    hi2c->State = HAL_I2C_STATE_READY;
 c03f524:	f883 4041 	strb.w	r4, [r3, #65]	@ 0x41
    __HAL_UNLOCK(hi2c);
 c03f528:	f883 0040 	strb.w	r0, [r3, #64]	@ 0x40
  }
  else
  {
    return HAL_BUSY;
  }
}
 c03f52c:	bd10      	pop	{r4, pc}
    __HAL_LOCK(hi2c);
 c03f52e:	2002      	movs	r0, #2
 c03f530:	e7fc      	b.n	c03f52c <HAL_I2CEx_ConfigAnalogFilter+0x46>

0c03f532 <HAL_I2CEx_ConfigDigitalFilter>:
  *                the configuration information for the specified I2Cx peripheral.
  * @param  DigitalFilter Coefficient of digital noise filter between Min_Data=0x00 and Max_Data=0x0F.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_ConfigDigitalFilter(I2C_HandleTypeDef *hi2c, uint32_t DigitalFilter)
{
 c03f532:	b510      	push	{r4, lr}

  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_I2C_DIGITAL_FILTER(DigitalFilter));

  if (hi2c->State == HAL_I2C_STATE_READY)
 c03f534:	f890 2041 	ldrb.w	r2, [r0, #65]	@ 0x41
{
 c03f538:	4603      	mov	r3, r0
  if (hi2c->State == HAL_I2C_STATE_READY)
 c03f53a:	2a20      	cmp	r2, #32
 c03f53c:	b2d4      	uxtb	r4, r2
 c03f53e:	d11b      	bne.n	c03f578 <HAL_I2CEx_ConfigDigitalFilter+0x46>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
 c03f540:	f890 2040 	ldrb.w	r2, [r0, #64]	@ 0x40
 c03f544:	2a01      	cmp	r2, #1
 c03f546:	d017      	beq.n	c03f578 <HAL_I2CEx_ConfigDigitalFilter+0x46>

    hi2c->State = HAL_I2C_STATE_BUSY;
 c03f548:	2224      	movs	r2, #36	@ 0x24
 c03f54a:	f880 2041 	strb.w	r2, [r0, #65]	@ 0x41

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
 c03f54e:	6802      	ldr	r2, [r0, #0]
 c03f550:	6810      	ldr	r0, [r2, #0]
 c03f552:	f020 0001 	bic.w	r0, r0, #1
 c03f556:	6010      	str	r0, [r2, #0]

    /* Get the old register value */
    tmpreg = hi2c->Instance->CR1;
 c03f558:	6810      	ldr	r0, [r2, #0]

    /* Reset I2Cx DNF bits [11:8] */
    tmpreg &= ~(I2C_CR1_DNF);
 c03f55a:	f420 6070 	bic.w	r0, r0, #3840	@ 0xf00

    /* Set I2Cx DNF coefficient */
    tmpreg |= DigitalFilter << 8U;
 c03f55e:	ea40 2101 	orr.w	r1, r0, r1, lsl #8
    __HAL_I2C_ENABLE(hi2c);

    hi2c->State = HAL_I2C_STATE_READY;

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 c03f562:	2000      	movs	r0, #0
    hi2c->Instance->CR1 = tmpreg;
 c03f564:	6011      	str	r1, [r2, #0]
    __HAL_I2C_ENABLE(hi2c);
 c03f566:	6811      	ldr	r1, [r2, #0]
 c03f568:	f041 0101 	orr.w	r1, r1, #1
 c03f56c:	6011      	str	r1, [r2, #0]
    hi2c->State = HAL_I2C_STATE_READY;
 c03f56e:	f883 4041 	strb.w	r4, [r3, #65]	@ 0x41
    __HAL_UNLOCK(hi2c);
 c03f572:	f883 0040 	strb.w	r0, [r3, #64]	@ 0x40
  }
  else
  {
    return HAL_BUSY;
  }
}
 c03f576:	bd10      	pop	{r4, pc}
    __HAL_LOCK(hi2c);
 c03f578:	2002      	movs	r0, #2
 c03f57a:	e7fc      	b.n	c03f576 <HAL_I2CEx_ConfigDigitalFilter+0x44>

0c03f57c <HAL_PKA_MspInit>:
  UNUSED(hpka);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_PKA_MspInit can be implemented in the user file
   */
}
 c03f57c:	4770      	bx	lr

0c03f57e <HAL_PKA_MspDeInit>:
/**
  * @brief  DeInitialize the PKA MSP.
  * @param  hpka PKA handle
  * @retval None
  */
__weak void HAL_PKA_MspDeInit(PKA_HandleTypeDef *hpka)
 c03f57e:	4770      	bx	lr

0c03f580 <HAL_PKA_DeInit>:
{
 c03f580:	b538      	push	{r3, r4, r5, lr}
  if (hpka != NULL)
 c03f582:	4605      	mov	r5, r0
 c03f584:	b170      	cbz	r0, c03f5a4 <HAL_PKA_DeInit+0x24>
    hpka->State = HAL_PKA_STATE_BUSY;
 c03f586:	2302      	movs	r3, #2
    hpka->Instance->CR = 0;
 c03f588:	2400      	movs	r4, #0
    hpka->State = HAL_PKA_STATE_BUSY;
 c03f58a:	7103      	strb	r3, [r0, #4]
    hpka->Instance->CR = 0;
 c03f58c:	6803      	ldr	r3, [r0, #0]
 c03f58e:	601c      	str	r4, [r3, #0]
    SET_BIT(hpka->Instance->CLRFR, PKA_CLRFR_PROCENDFC | PKA_CLRFR_RAMERRFC | PKA_CLRFR_ADDRERRFC | PKA_CLRFR_OPERRFC);
 c03f590:	689a      	ldr	r2, [r3, #8]
 c03f592:	f442 1268 	orr.w	r2, r2, #3801088	@ 0x3a0000
 c03f596:	609a      	str	r2, [r3, #8]
    HAL_PKA_MspDeInit(hpka);
 c03f598:	f7ff fff1 	bl	c03f57e <HAL_PKA_MspDeInit>
  HAL_StatusTypeDef err = HAL_OK;
 c03f59c:	4620      	mov	r0, r4
    hpka->ErrorCode = HAL_PKA_ERROR_NONE;
 c03f59e:	60ac      	str	r4, [r5, #8]
    hpka->State = HAL_PKA_STATE_RESET;
 c03f5a0:	712c      	strb	r4, [r5, #4]
}
 c03f5a2:	bd38      	pop	{r3, r4, r5, pc}
    err = HAL_ERROR;
 c03f5a4:	2001      	movs	r0, #1
 c03f5a6:	e7fc      	b.n	c03f5a2 <HAL_PKA_DeInit+0x22>

0c03f5a8 <HAL_PKA_ECDSAVerif_IsValidSignature>:
  * @param  hpka PKA handle
  * @retval 1 if signature is verified, 0 in other case
  */
uint32_t HAL_PKA_ECDSAVerif_IsValidSignature(PKA_HandleTypeDef const *const hpka)
{
  return (hpka->Instance->RAM[PKA_ECDSA_VERIF_OUT_RESULT] == 0xD60DU) ? 1UL : 0UL;
 c03f5a8:	6803      	ldr	r3, [r0, #0]
 c03f5aa:	f8d3 05d0 	ldr.w	r0, [r3, #1488]	@ 0x5d0
}
 c03f5ae:	f24d 630d 	movw	r3, #54797	@ 0xd60d
 c03f5b2:	1ac3      	subs	r3, r0, r3
 c03f5b4:	4258      	negs	r0, r3
 c03f5b6:	4158      	adcs	r0, r3
 c03f5b8:	4770      	bx	lr

0c03f5ba <HAL_PKA_PointCheck_IsOnCurve>:
  */
uint32_t HAL_PKA_PointCheck_IsOnCurve(PKA_HandleTypeDef const *const hpka)
{
#define PKA_POINT_IS_ON_CURVE 0xD60DUL
  /* Invert the value of the PKA RAM containing the result of the operation */
  return (hpka->Instance->RAM[PKA_POINT_CHECK_OUT_ERROR] == PKA_POINT_IS_ON_CURVE) ? 1UL : 0UL;
 c03f5ba:	6803      	ldr	r3, [r0, #0]
 c03f5bc:	f8d3 0680 	ldr.w	r0, [r3, #1664]	@ 0x680
}
 c03f5c0:	f24d 630d 	movw	r3, #54797	@ 0xd60d
 c03f5c4:	1ac3      	subs	r3, r0, r3
 c03f5c6:	4258      	negs	r0, r3
 c03f5c8:	4158      	adcs	r0, r3
 c03f5ca:	4770      	bx	lr

0c03f5cc <HAL_PKA_RAMReset>:
void HAL_PKA_RAMReset(PKA_HandleTypeDef *hpka)
{
  uint32_t index;

  /* For each element in the PKA RAM */
  for (index = 0; index < PKA_RAM_SIZE; index++)
 c03f5cc:	2300      	movs	r3, #0
{
 c03f5ce:	b510      	push	{r4, lr}
  for (index = 0; index < PKA_RAM_SIZE; index++)
 c03f5d0:	f240 5236 	movw	r2, #1334	@ 0x536
  {
    /* Clear the content */
    hpka->Instance->RAM[index] = 0UL;
 c03f5d4:	461c      	mov	r4, r3
 c03f5d6:	6801      	ldr	r1, [r0, #0]
 c03f5d8:	f503 7080 	add.w	r0, r3, #256	@ 0x100
  for (index = 0; index < PKA_RAM_SIZE; index++)
 c03f5dc:	3301      	adds	r3, #1
 c03f5de:	4293      	cmp	r3, r2
    hpka->Instance->RAM[index] = 0UL;
 c03f5e0:	f841 4020 	str.w	r4, [r1, r0, lsl #2]
  for (index = 0; index < PKA_RAM_SIZE; index++)
 c03f5e4:	d1f8      	bne.n	c03f5d8 <HAL_PKA_RAMReset+0xc>
  }
}
 c03f5e6:	bd10      	pop	{r4, pc}

0c03f5e8 <HAL_PKA_GetState>:
  * @retval HAL status
  */
HAL_PKA_StateTypeDef HAL_PKA_GetState(const PKA_HandleTypeDef *hpka)
{
  /* Return PKA handle state */
  return hpka->State;
 c03f5e8:	7900      	ldrb	r0, [r0, #4]
}
 c03f5ea:	4770      	bx	lr

0c03f5ec <PKA_PollEndOfOperation>:
  * @param  Timeout Timeout duration in millisecond.
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
HAL_StatusTypeDef PKA_PollEndOfOperation(const PKA_HandleTypeDef *hpka, uint32_t Timeout, uint32_t Tickstart)
{
 c03f5ec:	b570      	push	{r4, r5, r6, lr}
 c03f5ee:	4605      	mov	r5, r0
 c03f5f0:	460c      	mov	r4, r1
 c03f5f2:	4616      	mov	r6, r2
  /* Wait for the end of operation or timeout */
  while ((hpka->Instance->SR & PKA_SR_PROCENDF) == 0UL)
 c03f5f4:	682a      	ldr	r2, [r5, #0]
 c03f5f6:	6853      	ldr	r3, [r2, #4]
 c03f5f8:	039b      	lsls	r3, r3, #14
 c03f5fa:	d501      	bpl.n	c03f600 <PKA_PollEndOfOperation+0x14>
      {
        return HAL_TIMEOUT;
      }
    }
  }
  return HAL_OK;
 c03f5fc:	2000      	movs	r0, #0
}
 c03f5fe:	bd70      	pop	{r4, r5, r6, pc}
    if (Timeout != HAL_MAX_DELAY)
 c03f600:	1c61      	adds	r1, r4, #1
 c03f602:	d0f8      	beq.n	c03f5f6 <PKA_PollEndOfOperation+0xa>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0UL))
 c03f604:	f004 fb70 	bl	c043ce8 <HAL_GetTick>
 c03f608:	1b80      	subs	r0, r0, r6
 c03f60a:	42a0      	cmp	r0, r4
 c03f60c:	d801      	bhi.n	c03f612 <PKA_PollEndOfOperation+0x26>
 c03f60e:	2c00      	cmp	r4, #0
 c03f610:	d1f0      	bne.n	c03f5f4 <PKA_PollEndOfOperation+0x8>
        return HAL_TIMEOUT;
 c03f612:	2003      	movs	r0, #3
 c03f614:	e7f3      	b.n	c03f5fe <PKA_PollEndOfOperation+0x12>

0c03f616 <PKA_CheckError>:
uint32_t PKA_CheckError(const PKA_HandleTypeDef *hpka, uint32_t mode)
{
  uint32_t err = HAL_PKA_ERROR_NONE;

  /* Check RAMERR error */
  if (__HAL_PKA_GET_FLAG(hpka, PKA_FLAG_RAMERR) == SET)
 c03f616:	6803      	ldr	r3, [r0, #0]
 c03f618:	6858      	ldr	r0, [r3, #4]
  {
    err |= HAL_PKA_ERROR_RAMERR;
  }

  /* Check ADDRERR error */
  if (__HAL_PKA_GET_FLAG(hpka, PKA_FLAG_ADDRERR) == SET)
 c03f61a:	685a      	ldr	r2, [r3, #4]
  if (__HAL_PKA_GET_FLAG(hpka, PKA_FLAG_RAMERR) == SET)
 c03f61c:	f3c0 40c0 	ubfx	r0, r0, #19, #1
  if (__HAL_PKA_GET_FLAG(hpka, PKA_FLAG_ADDRERR) == SET)
 c03f620:	02d2      	lsls	r2, r2, #11
  {
    err |= HAL_PKA_ERROR_ADDRERR;
  }

  /* Check OPEERR error */
  if (__HAL_PKA_GET_FLAG(hpka, PKA_FLAG_OPERR) == SET)
 c03f622:	685a      	ldr	r2, [r3, #4]
  if (__HAL_PKA_GET_FLAG(hpka, PKA_FLAG_RAMERR) == SET)
 c03f624:	ea4f 0040 	mov.w	r0, r0, lsl #1
    err |= HAL_PKA_ERROR_ADDRERR;
 c03f628:	bf48      	it	mi
 c03f62a:	f040 0001 	orrmi.w	r0, r0, #1
  if (__HAL_PKA_GET_FLAG(hpka, PKA_FLAG_OPERR) == SET)
 c03f62e:	0292      	lsls	r2, r2, #10
  {
    err |= HAL_PKA_ERROR_OPERATION;
 c03f630:	bf48      	it	mi
 c03f632:	f040 0008 	orrmi.w	r0, r0, #8
  }

  /* Check the operation success in case of ECDSA signature */
  if (mode == PKA_MODE_ECDSA_SIGNATURE)
 c03f636:	2924      	cmp	r1, #36	@ 0x24
 c03f638:	d108      	bne.n	c03f64c <PKA_CheckError+0x36>
  {
#define EDCSA_SIGN_NOERROR PKA_NO_ERROR
    /* If error output result is different from no error, ecsa sign operation need to be repeated */
    if (hpka->Instance->RAM[PKA_ECDSA_SIGN_OUT_ERROR] != EDCSA_SIGN_NOERROR)
 c03f63a:	f8d3 2fe0 	ldr.w	r2, [r3, #4064]	@ 0xfe0

  /* Check the operation success in case of protected modular exponentiation*/
  if (mode == PKA_MODE_MODULAR_EXP_PROTECT)
  {
    /* If error output result is different from no error, PKA operation need to be repeated */
    if (hpka->Instance->RAM[PKA_MODULAR_EXP_OUT_ERROR] != PKA_NO_ERROR)
 c03f63e:	f24d 630d 	movw	r3, #54797	@ 0xd60d
 c03f642:	429a      	cmp	r2, r3
    {
      err |= HAL_PKA_ERROR_OPERATION;
 c03f644:	bf18      	it	ne
 c03f646:	f040 0008 	orrne.w	r0, r0, #8
    }
  }

  return err;
}
 c03f64a:	4770      	bx	lr
  if (mode == PKA_MODE_DOUBLE_BASE_LADDER)
 c03f64c:	2927      	cmp	r1, #39	@ 0x27
 c03f64e:	d102      	bne.n	c03f656 <PKA_CheckError+0x40>
    if (hpka->Instance->RAM[PKA_ECC_DOUBLE_LADDER_OUT_ERROR] != PKA_NO_ERROR)
 c03f650:	f8d3 2520 	ldr.w	r2, [r3, #1312]	@ 0x520
 c03f654:	e7f3      	b.n	c03f63e <PKA_CheckError+0x28>
  if (mode == PKA_MODE_ECC_PROJECTIVE_AFF)
 c03f656:	292f      	cmp	r1, #47	@ 0x2f
 c03f658:	d102      	bne.n	c03f660 <PKA_CheckError+0x4a>
    if (hpka->Instance->RAM[PKA_ECC_SCALAR_MUL_OUT_ERROR] != PKA_NO_ERROR)
 c03f65a:	f8d3 2680 	ldr.w	r2, [r3, #1664]	@ 0x680
 c03f65e:	e7ee      	b.n	c03f63e <PKA_CheckError+0x28>
  if (mode == PKA_MODE_ECC_MUL)
 c03f660:	2920      	cmp	r1, #32
 c03f662:	d0fa      	beq.n	c03f65a <PKA_CheckError+0x44>
  if (mode == PKA_MODE_MODULAR_EXP_PROTECT)
 c03f664:	2903      	cmp	r1, #3
 c03f666:	d1f0      	bne.n	c03f64a <PKA_CheckError+0x34>
    if (hpka->Instance->RAM[PKA_MODULAR_EXP_OUT_ERROR] != PKA_NO_ERROR)
 c03f668:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 c03f66c:	f8d3 2298 	ldr.w	r2, [r3, #664]	@ 0x298
 c03f670:	e7e5      	b.n	c03f63e <PKA_CheckError+0x28>

0c03f672 <PKA_GetOptBitSize_u8>:
     optimisations using the logic "value was passed to __builtin_clz, so it
     is non-zero".
     ARM GCC 7.3 and possibly earlier will optimise this test away, leaving a
     single CLZ instruction.
   */
  if (value == 0U)
 c03f672:	b129      	cbz	r1, c03f680 <PKA_GetOptBitSize_u8+0xe>
  {
    return 32U;
  }
  return __builtin_clz(value);
 c03f674:	fab1 f181 	clz	r1, r1
{
  uint32_t position;

  position = 32UL - __CLZ(msb);

  return (((byteNumber - 1UL) * 8UL) + position);
 c03f678:	ebc1 00c0 	rsb	r0, r1, r0, lsl #3
}
 c03f67c:	3018      	adds	r0, #24
 c03f67e:	4770      	bx	lr
    return 32U;
 c03f680:	2120      	movs	r1, #32
 c03f682:	e7f9      	b.n	c03f678 <PKA_GetOptBitSize_u8+0x6>

0c03f684 <PKA_Memcpy_u32_to_u8>:
  * @param  src Pointer to source
  * @param  n Number of uint8_t to copy
  * @retval dst
  */
void PKA_Memcpy_u32_to_u8(uint8_t dst[], __IO const uint32_t src[], size_t n)
{
 c03f684:	b5f0      	push	{r4, r5, r6, r7, lr}
  if (dst != NULL)
 c03f686:	b178      	cbz	r0, c03f6a8 <PKA_Memcpy_u32_to_u8+0x24>
  {
    if (src != NULL)
 c03f688:	b171      	cbz	r1, c03f6a8 <PKA_Memcpy_u32_to_u8+0x24>
 c03f68a:	460c      	mov	r4, r1
 c03f68c:	f022 0603 	bic.w	r6, r2, #3
 c03f690:	1885      	adds	r5, r0, r2
    {
      uint32_t index_uint32_t = 0UL; /* This index is used outside of the loop */

      for (; index_uint32_t < (n / 4UL); index_uint32_t++)
 c03f692:	0893      	lsrs	r3, r2, #2
 c03f694:	440e      	add	r6, r1
 c03f696:	42b4      	cmp	r4, r6
 c03f698:	d107      	bne.n	c03f6aa <PKA_Memcpy_u32_to_u8+0x26>
        dst[index_uint8_t + 1UL] = (uint8_t)((src[index_uint32_t] & 0x00FF0000U) >> 16UL);
        dst[index_uint8_t + 0UL] = (uint8_t)((src[index_uint32_t] & 0xFF000000U) >> 24UL);
      }

      /* Manage the buffers not aligned on uint32_t */
      if ((n % 4UL) == 1UL)
 c03f69a:	f002 0203 	and.w	r2, r2, #3
 c03f69e:	2a01      	cmp	r2, #1
 c03f6a0:	d114      	bne.n	c03f6cc <PKA_Memcpy_u32_to_u8+0x48>
      {
        dst[0UL] = (uint8_t)((src[index_uint32_t] & 0x000000FFU));
 c03f6a2:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
      }
      else if ((n % 4UL) == 3UL)
      {
        dst[2UL] = (uint8_t)((src[index_uint32_t] & 0x000000FFU));
        dst[1UL] = (uint8_t)((src[index_uint32_t] & 0x0000FF00U) >> 8UL);
        dst[0UL] = (uint8_t)((src[index_uint32_t] & 0x00FF0000U) >> 16UL);
 c03f6a6:	7003      	strb	r3, [r0, #0]
      {
        /* The last element is already handle in the loop */
      }
    }
  }
}
 c03f6a8:	bdf0      	pop	{r4, r5, r6, r7, pc}
        dst[index_uint8_t + 3UL] = (uint8_t)((src[index_uint32_t] & 0x000000FFU));
 c03f6aa:	6827      	ldr	r7, [r4, #0]
 c03f6ac:	f805 7c01 	strb.w	r7, [r5, #-1]
        dst[index_uint8_t + 2UL] = (uint8_t)((src[index_uint32_t] & 0x0000FF00U) >> 8UL);
 c03f6b0:	6827      	ldr	r7, [r4, #0]
 c03f6b2:	0a3f      	lsrs	r7, r7, #8
 c03f6b4:	f805 7c02 	strb.w	r7, [r5, #-2]
        dst[index_uint8_t + 1UL] = (uint8_t)((src[index_uint32_t] & 0x00FF0000U) >> 16UL);
 c03f6b8:	6827      	ldr	r7, [r4, #0]
 c03f6ba:	0c3f      	lsrs	r7, r7, #16
 c03f6bc:	f805 7c03 	strb.w	r7, [r5, #-3]
        dst[index_uint8_t + 0UL] = (uint8_t)((src[index_uint32_t] & 0xFF000000U) >> 24UL);
 c03f6c0:	f854 7b04 	ldr.w	r7, [r4], #4
 c03f6c4:	0e3f      	lsrs	r7, r7, #24
 c03f6c6:	f805 7d04 	strb.w	r7, [r5, #-4]!
      for (; index_uint32_t < (n / 4UL); index_uint32_t++)
 c03f6ca:	e7e4      	b.n	c03f696 <PKA_Memcpy_u32_to_u8+0x12>
      else if ((n % 4UL) == 2UL)
 c03f6cc:	2a02      	cmp	r2, #2
 c03f6ce:	d106      	bne.n	c03f6de <PKA_Memcpy_u32_to_u8+0x5a>
        dst[1UL] = (uint8_t)((src[index_uint32_t] & 0x000000FFU));
 c03f6d0:	f851 2023 	ldr.w	r2, [r1, r3, lsl #2]
 c03f6d4:	7042      	strb	r2, [r0, #1]
        dst[0UL] = (uint8_t)((src[index_uint32_t] & 0x0000FF00U) >> 8UL);
 c03f6d6:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 c03f6da:	0a1b      	lsrs	r3, r3, #8
 c03f6dc:	e7e3      	b.n	c03f6a6 <PKA_Memcpy_u32_to_u8+0x22>
      else if ((n % 4UL) == 3UL)
 c03f6de:	2a03      	cmp	r2, #3
 c03f6e0:	d1e2      	bne.n	c03f6a8 <PKA_Memcpy_u32_to_u8+0x24>
        dst[2UL] = (uint8_t)((src[index_uint32_t] & 0x000000FFU));
 c03f6e2:	f851 2023 	ldr.w	r2, [r1, r3, lsl #2]
 c03f6e6:	7082      	strb	r2, [r0, #2]
        dst[1UL] = (uint8_t)((src[index_uint32_t] & 0x0000FF00U) >> 8UL);
 c03f6e8:	f851 2023 	ldr.w	r2, [r1, r3, lsl #2]
 c03f6ec:	0a12      	lsrs	r2, r2, #8
 c03f6ee:	7042      	strb	r2, [r0, #1]
        dst[0UL] = (uint8_t)((src[index_uint32_t] & 0x00FF0000U) >> 16UL);
 c03f6f0:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 c03f6f4:	0c1b      	lsrs	r3, r3, #16
 c03f6f6:	e7d6      	b.n	c03f6a6 <PKA_Memcpy_u32_to_u8+0x22>

0c03f6f8 <HAL_PKA_ModExp_GetResult>:
{
 c03f6f8:	460b      	mov	r3, r1
  PKA_Memcpy_u32_to_u8(pRes, &hpka->Instance->RAM[PKA_MODULAR_EXP_OUT_RESULT], size);
 c03f6fa:	4a04      	ldr	r2, [pc, #16]	@ (c03f70c <HAL_PKA_ModExp_GetResult+0x14>)
 c03f6fc:	6801      	ldr	r1, [r0, #0]
 c03f6fe:	6812      	ldr	r2, [r2, #0]
 c03f700:	4618      	mov	r0, r3
 c03f702:	f601 0138 	addw	r1, r1, #2104	@ 0x838
 c03f706:	f7ff bfbd 	b.w	c03f684 <PKA_Memcpy_u32_to_u8>
 c03f70a:	bf00      	nop
 c03f70c:	30030ee0 	.word	0x30030ee0

0c03f710 <HAL_PKA_ECDSASign_GetResult>:
{
 c03f710:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  size = primeordersize;
 c03f712:	4b13      	ldr	r3, [pc, #76]	@ (c03f760 <HAL_PKA_ECDSASign_GetResult+0x50>)
{
 c03f714:	4604      	mov	r4, r0
 c03f716:	4615      	mov	r5, r2
  if (out != NULL)
 c03f718:	460e      	mov	r6, r1
  size = primeordersize;
 c03f71a:	681f      	ldr	r7, [r3, #0]
  if (out != NULL)
 c03f71c:	b169      	cbz	r1, c03f73a <HAL_PKA_ECDSASign_GetResult+0x2a>
    PKA_Memcpy_u32_to_u8(out->RSign, &hpka->Instance->RAM[PKA_ECDSA_SIGN_OUT_SIGNATURE_R], size);
 c03f71e:	6801      	ldr	r1, [r0, #0]
 c03f720:	463a      	mov	r2, r7
 c03f722:	6830      	ldr	r0, [r6, #0]
 c03f724:	f501 61e6 	add.w	r1, r1, #1840	@ 0x730
 c03f728:	f7ff ffac 	bl	c03f684 <PKA_Memcpy_u32_to_u8>
    PKA_Memcpy_u32_to_u8(out->SSign, &hpka->Instance->RAM[PKA_ECDSA_SIGN_OUT_SIGNATURE_S], size);
 c03f72c:	6821      	ldr	r1, [r4, #0]
 c03f72e:	463a      	mov	r2, r7
 c03f730:	6870      	ldr	r0, [r6, #4]
 c03f732:	f501 61f1 	add.w	r1, r1, #1928	@ 0x788
 c03f736:	f7ff ffa5 	bl	c03f684 <PKA_Memcpy_u32_to_u8>
  if (outExt != NULL)
 c03f73a:	b185      	cbz	r5, c03f75e <HAL_PKA_ECDSASign_GetResult+0x4e>
    PKA_Memcpy_u32_to_u8(outExt->ptX, &hpka->Instance->RAM[PKA_ECDSA_SIGN_OUT_FINAL_POINT_X], size);
 c03f73c:	6821      	ldr	r1, [r4, #0]
 c03f73e:	463a      	mov	r2, r7
 c03f740:	6828      	ldr	r0, [r5, #0]
 c03f742:	f501 51a0 	add.w	r1, r1, #5120	@ 0x1400
 c03f746:	f7ff ff9d 	bl	c03f684 <PKA_Memcpy_u32_to_u8>
    PKA_Memcpy_u32_to_u8(outExt->ptY, &hpka->Instance->RAM[PKA_ECDSA_SIGN_OUT_FINAL_POINT_Y], size);
 c03f74a:	6821      	ldr	r1, [r4, #0]
 c03f74c:	463a      	mov	r2, r7
 c03f74e:	f501 51a2 	add.w	r1, r1, #5184	@ 0x1440
 c03f752:	6868      	ldr	r0, [r5, #4]
 c03f754:	3118      	adds	r1, #24
}
 c03f756:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    PKA_Memcpy_u32_to_u8(outExt->ptY, &hpka->Instance->RAM[PKA_ECDSA_SIGN_OUT_FINAL_POINT_Y], size);
 c03f75a:	f7ff bf93 	b.w	c03f684 <PKA_Memcpy_u32_to_u8>
}
 c03f75e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 c03f760:	30030ee4 	.word	0x30030ee4

0c03f764 <HAL_PKA_RSACRTExp_GetResult>:
{
 c03f764:	460b      	mov	r3, r1
  size = (hpka->Instance->RAM[PKA_RSA_CRT_EXP_IN_MOD_NB_BITS] + 7UL) / 8UL;
 c03f766:	6801      	ldr	r1, [r0, #0]
  PKA_Memcpy_u32_to_u8(pRes, &hpka->Instance->RAM[PKA_RSA_CRT_EXP_OUT_RESULT], size);
 c03f768:	4618      	mov	r0, r3
  size = (hpka->Instance->RAM[PKA_RSA_CRT_EXP_IN_MOD_NB_BITS] + 7UL) / 8UL;
 c03f76a:	f8d1 2408 	ldr.w	r2, [r1, #1032]	@ 0x408
  PKA_Memcpy_u32_to_u8(pRes, &hpka->Instance->RAM[PKA_RSA_CRT_EXP_OUT_RESULT], size);
 c03f76e:	f601 0138 	addw	r1, r1, #2104	@ 0x838
  size = (hpka->Instance->RAM[PKA_RSA_CRT_EXP_IN_MOD_NB_BITS] + 7UL) / 8UL;
 c03f772:	3207      	adds	r2, #7
  PKA_Memcpy_u32_to_u8(pRes, &hpka->Instance->RAM[PKA_RSA_CRT_EXP_OUT_RESULT], size);
 c03f774:	08d2      	lsrs	r2, r2, #3
 c03f776:	f7ff bf85 	b.w	c03f684 <PKA_Memcpy_u32_to_u8>
	...

0c03f77c <HAL_PKA_ECCMul_GetResult>:
{
 c03f77c:	b570      	push	{r4, r5, r6, lr}
 c03f77e:	4605      	mov	r5, r0
  if (out != NULL)
 c03f780:	460c      	mov	r4, r1
 c03f782:	b189      	cbz	r1, c03f7a8 <HAL_PKA_ECCMul_GetResult+0x2c>
  size = modulussize;
 c03f784:	4b09      	ldr	r3, [pc, #36]	@ (c03f7ac <HAL_PKA_ECCMul_GetResult+0x30>)
    PKA_Memcpy_u32_to_u8(out->ptX, &hpka->Instance->RAM[PKA_ECC_SCALAR_MUL_OUT_RESULT_X], size);
 c03f786:	6801      	ldr	r1, [r0, #0]
  size = modulussize;
 c03f788:	681e      	ldr	r6, [r3, #0]
    PKA_Memcpy_u32_to_u8(out->ptX, &hpka->Instance->RAM[PKA_ECC_SCALAR_MUL_OUT_RESULT_X], size);
 c03f78a:	6820      	ldr	r0, [r4, #0]
 c03f78c:	4632      	mov	r2, r6
 c03f78e:	f501 61af 	add.w	r1, r1, #1400	@ 0x578
 c03f792:	f7ff ff77 	bl	c03f684 <PKA_Memcpy_u32_to_u8>
    PKA_Memcpy_u32_to_u8(out->ptY, &hpka->Instance->RAM[PKA_ECC_SCALAR_MUL_OUT_RESULT_Y], size);
 c03f796:	6829      	ldr	r1, [r5, #0]
 c03f798:	4632      	mov	r2, r6
 c03f79a:	6860      	ldr	r0, [r4, #4]
 c03f79c:	f501 61ba 	add.w	r1, r1, #1488	@ 0x5d0
}
 c03f7a0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    PKA_Memcpy_u32_to_u8(out->ptY, &hpka->Instance->RAM[PKA_ECC_SCALAR_MUL_OUT_RESULT_Y], size);
 c03f7a4:	f7ff bf6e 	b.w	c03f684 <PKA_Memcpy_u32_to_u8>
}
 c03f7a8:	bd70      	pop	{r4, r5, r6, pc}
 c03f7aa:	bf00      	nop
 c03f7ac:	30030edc 	.word	0x30030edc

0c03f7b0 <PKA_Memcpy_u8_to_u32>:
  * @param  src Pointer to source
  * @param  n Number of uint8_t to copy (must be multiple of 4)
  * @retval dst
  */
void PKA_Memcpy_u8_to_u32(__IO uint32_t dst[], const uint8_t src[], size_t n)
{
 c03f7b0:	b5f0      	push	{r4, r5, r6, r7, lr}
  if (dst != NULL)
 c03f7b2:	b190      	cbz	r0, c03f7da <PKA_Memcpy_u8_to_u32+0x2a>
  {
    if (src != NULL)
 c03f7b4:	b189      	cbz	r1, c03f7da <PKA_Memcpy_u8_to_u32+0x2a>
 c03f7b6:	4607      	mov	r7, r0
 c03f7b8:	f022 0603 	bic.w	r6, r2, #3
 c03f7bc:	188d      	adds	r5, r1, r2
    {
      uint32_t index = 0UL; /* This index is used outside of the loop */

      for (; index < (n / 4UL); index++)
 c03f7be:	0894      	lsrs	r4, r2, #2
 c03f7c0:	eb06 0c00 	add.w	ip, r6, r0
 c03f7c4:	4567      	cmp	r7, ip
 c03f7c6:	d109      	bne.n	c03f7dc <PKA_Memcpy_u8_to_u32+0x2c>
                     | ((uint32_t)src[(n - (index * 4UL) - 3UL)] << 16UL) \
                     | ((uint32_t)src[(n - (index * 4UL) - 4UL)] << 24UL);
      }

      /* Manage the buffers not aligned on uint32_t */
      if ((n % 4UL) == 1UL)
 c03f7c8:	f002 0303 	and.w	r3, r2, #3
 c03f7cc:	2b01      	cmp	r3, #1
 c03f7ce:	d117      	bne.n	c03f800 <PKA_Memcpy_u8_to_u32+0x50>
      {
        dst[index] = (uint32_t)src[(n - (index * 4UL) - 1UL)];
 c03f7d0:	3a01      	subs	r2, #1
 c03f7d2:	1b92      	subs	r2, r2, r6
 c03f7d4:	5c8b      	ldrb	r3, [r1, r2]
        dst[index] = ((uint32_t)src[(n - (index * 4UL) - 1UL)]) \
                     | ((uint32_t)src[(n - (index * 4UL) - 2UL)] << 8UL);
      }
      else if ((n % 4UL) == 3UL)
      {
        dst[index] = ((uint32_t)src[(n - (index * 4UL) - 1UL)]) \
 c03f7d6:	f840 3024 	str.w	r3, [r0, r4, lsl #2]
      {
        /* The last element is already handle in the loop */
      }
    }
  }
}
 c03f7da:	bdf0      	pop	{r4, r5, r6, r7, pc}
                     | ((uint32_t)src[(n - (index * 4UL) - 3UL)] << 16UL) \
 c03f7dc:	f815 3c03 	ldrb.w	r3, [r5, #-3]
                     | ((uint32_t)src[(n - (index * 4UL) - 2UL)] << 8UL) \
 c03f7e0:	f815 ec02 	ldrb.w	lr, [r5, #-2]
                     | ((uint32_t)src[(n - (index * 4UL) - 3UL)] << 16UL) \
 c03f7e4:	041b      	lsls	r3, r3, #16
 c03f7e6:	ea43 230e 	orr.w	r3, r3, lr, lsl #8
        dst[index] = ((uint32_t)src[(n - (index * 4UL) - 1UL)]) \
 c03f7ea:	f815 ec01 	ldrb.w	lr, [r5, #-1]
                     | ((uint32_t)src[(n - (index * 4UL) - 3UL)] << 16UL) \
 c03f7ee:	ea43 030e 	orr.w	r3, r3, lr
                     | ((uint32_t)src[(n - (index * 4UL) - 4UL)] << 24UL);
 c03f7f2:	f815 ed04 	ldrb.w	lr, [r5, #-4]!
 c03f7f6:	ea43 630e 	orr.w	r3, r3, lr, lsl #24
        dst[index] = ((uint32_t)src[(n - (index * 4UL) - 1UL)]) \
 c03f7fa:	f847 3b04 	str.w	r3, [r7], #4
      for (; index < (n / 4UL); index++)
 c03f7fe:	e7e1      	b.n	c03f7c4 <PKA_Memcpy_u8_to_u32+0x14>
      else if ((n % 4UL) == 2UL)
 c03f800:	2b02      	cmp	r3, #2
 c03f802:	d108      	bne.n	c03f816 <PKA_Memcpy_u8_to_u32+0x66>
        dst[index] = ((uint32_t)src[(n - (index * 4UL) - 1UL)]) \
 c03f804:	1b92      	subs	r2, r2, r6
                     | ((uint32_t)src[(n - (index * 4UL) - 2UL)] << 8UL);
 c03f806:	4411      	add	r1, r2
 c03f808:	f811 2c02 	ldrb.w	r2, [r1, #-2]
        dst[index] = ((uint32_t)src[(n - (index * 4UL) - 1UL)]) \
 c03f80c:	f811 3c01 	ldrb.w	r3, [r1, #-1]
                     | ((uint32_t)src[(n - (index * 4UL) - 2UL)] << 8UL);
 c03f810:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 c03f814:	e7df      	b.n	c03f7d6 <PKA_Memcpy_u8_to_u32+0x26>
      else if ((n % 4UL) == 3UL)
 c03f816:	2b03      	cmp	r3, #3
 c03f818:	d1df      	bne.n	c03f7da <PKA_Memcpy_u8_to_u32+0x2a>
        dst[index] = ((uint32_t)src[(n - (index * 4UL) - 1UL)]) \
 c03f81a:	1b92      	subs	r2, r2, r6
                     | ((uint32_t)src[(n - (index * 4UL) - 2UL)] << 8UL) \
 c03f81c:	4411      	add	r1, r2
                     | ((uint32_t)src[(n - (index * 4UL) - 3UL)] << 16UL);
 c03f81e:	f811 3c03 	ldrb.w	r3, [r1, #-3]
                     | ((uint32_t)src[(n - (index * 4UL) - 2UL)] << 8UL) \
 c03f822:	f811 2c02 	ldrb.w	r2, [r1, #-2]
                     | ((uint32_t)src[(n - (index * 4UL) - 3UL)] << 16UL);
 c03f826:	041b      	lsls	r3, r3, #16
 c03f828:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
        dst[index] = ((uint32_t)src[(n - (index * 4UL) - 1UL)]) \
 c03f82c:	f811 2c01 	ldrb.w	r2, [r1, #-1]
                     | ((uint32_t)src[(n - (index * 4UL) - 3UL)] << 16UL);
 c03f830:	4313      	orrs	r3, r2
 c03f832:	e7d0      	b.n	c03f7d6 <PKA_Memcpy_u8_to_u32+0x26>

0c03f834 <PKA_Memcpy_u32_to_u32>:
  * @param  src Pointer to source
  * @param  n Number of u32 to be handled
  * @retval dst
  */
void PKA_Memcpy_u32_to_u32(__IO uint32_t dst[], __IO const uint32_t src[], size_t n)
{
 c03f834:	b510      	push	{r4, lr}
  /* If a destination buffer is provided */
  if (dst != NULL)
 c03f836:	b120      	cbz	r0, c03f842 <PKA_Memcpy_u32_to_u32+0xe>
  {
    /* If a source buffer is provided */
    if (src != NULL)
 c03f838:	b119      	cbz	r1, c03f842 <PKA_Memcpy_u32_to_u32+0xe>
 c03f83a:	2300      	movs	r3, #0
 c03f83c:	0092      	lsls	r2, r2, #2
    {
      /* For each element in the array */
      for (uint32_t index = 0UL; index < n; index++)
 c03f83e:	4293      	cmp	r3, r2
 c03f840:	d100      	bne.n	c03f844 <PKA_Memcpy_u32_to_u32+0x10>
        /* Copy the content */
        dst[index] = src[index];
      }
    }
  }
}
 c03f842:	bd10      	pop	{r4, pc}
        dst[index] = src[index];
 c03f844:	58cc      	ldr	r4, [r1, r3]
 c03f846:	50c4      	str	r4, [r0, r3]
      for (uint32_t index = 0UL; index < n; index++)
 c03f848:	3304      	adds	r3, #4
 c03f84a:	e7f8      	b.n	c03f83e <PKA_Memcpy_u32_to_u32+0xa>

0c03f84c <HAL_PKA_Arithmetic_GetResult>:
{
 c03f84c:	4603      	mov	r3, r0
 c03f84e:	4608      	mov	r0, r1
  uint32_t mode = (hpka->Instance->CR & PKA_CR_MODE_Msk) >> PKA_CR_MODE_Pos;
 c03f850:	6819      	ldr	r1, [r3, #0]
{
 c03f852:	b410      	push	{r4}
  uint32_t mode = (hpka->Instance->CR & PKA_CR_MODE_Msk) >> PKA_CR_MODE_Pos;
 c03f854:	680b      	ldr	r3, [r1, #0]
 c03f856:	f3c3 2305 	ubfx	r3, r3, #8, #6
  switch (mode)
 c03f85a:	1e5a      	subs	r2, r3, #1
 c03f85c:	2a0f      	cmp	r2, #15
 c03f85e:	d828      	bhi.n	c03f8b2 <HAL_PKA_Arithmetic_GetResult+0x66>
 c03f860:	e8df f002 	tbb	[pc, r2]
 c03f864:	27272708 	.word	0x27272708
 c03f868:	08272727 	.word	0x08272727
 c03f86c:	291c0811 	.word	0x291c0811
 c03f870:	08110808 	.word	0x08110808
      size = hpka->Instance->RAM[2] / 32UL;
 c03f874:	f8d1 2408 	ldr.w	r2, [r1, #1032]	@ 0x408
 c03f878:	0952      	lsrs	r2, r2, #5
  if (pRes != NULL)
 c03f87a:	b110      	cbz	r0, c03f882 <HAL_PKA_Arithmetic_GetResult+0x36>
    switch (mode)
 c03f87c:	3b08      	subs	r3, #8
 c03f87e:	2b08      	cmp	r3, #8
 c03f880:	d912      	bls.n	c03f8a8 <HAL_PKA_Arithmetic_GetResult+0x5c>
}
 c03f882:	bc10      	pop	{r4}
 c03f884:	4770      	bx	lr
      size = hpka->Instance->RAM[PKA_ARITHMETIC_ALL_OPS_NB_BITS] / 32UL;
 c03f886:	f8d1 2408 	ldr.w	r2, [r1, #1032]	@ 0x408
 c03f88a:	0952      	lsrs	r2, r2, #5
      if (hpka->Instance->RAM[PKA_ARITHMETIC_ALL_OPS_OUT_RESULT + size] != 0UL)
 c03f88c:	f202 349e 	addw	r4, r2, #926	@ 0x39e
 c03f890:	f851 4024 	ldr.w	r4, [r1, r4, lsl #2]
 c03f894:	2c00      	cmp	r4, #0
 c03f896:	d0f0      	beq.n	c03f87a <HAL_PKA_Arithmetic_GetResult+0x2e>
        size += 1UL;
 c03f898:	3201      	adds	r2, #1
 c03f89a:	e7ee      	b.n	c03f87a <HAL_PKA_Arithmetic_GetResult+0x2e>
      size = hpka->Instance->RAM[PKA_ARITHMETIC_MUL_NB_BITS] / 32UL * 2UL;
 c03f89c:	f8d1 2408 	ldr.w	r2, [r1, #1032]	@ 0x408
  if (pRes != NULL)
 c03f8a0:	2800      	cmp	r0, #0
 c03f8a2:	d0ee      	beq.n	c03f882 <HAL_PKA_Arithmetic_GetResult+0x36>
      size = hpka->Instance->RAM[PKA_ARITHMETIC_MUL_NB_BITS] / 32UL * 2UL;
 c03f8a4:	0952      	lsrs	r2, r2, #5
 c03f8a6:	0052      	lsls	r2, r2, #1
}
 c03f8a8:	bc10      	pop	{r4}
        PKA_Memcpy_u32_to_u32(pRes, &hpka->Instance->RAM[PKA_ARITHMETIC_ALL_OPS_OUT_RESULT], size);
 c03f8aa:	f601 6178 	addw	r1, r1, #3704	@ 0xe78
 c03f8ae:	f7ff bfc1 	b.w	c03f834 <PKA_Memcpy_u32_to_u32>
  switch (mode)
 c03f8b2:	2200      	movs	r2, #0
 c03f8b4:	e7e1      	b.n	c03f87a <HAL_PKA_Arithmetic_GetResult+0x2e>
  if (pRes != NULL)
 c03f8b6:	2800      	cmp	r0, #0
 c03f8b8:	d0e3      	beq.n	c03f882 <HAL_PKA_Arithmetic_GetResult+0x36>
      size = 1;
 c03f8ba:	2201      	movs	r2, #1
 c03f8bc:	e7f4      	b.n	c03f8a8 <HAL_PKA_Arithmetic_GetResult+0x5c>

0c03f8be <PKA_Process>:
  * @param  mode PKA operation
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef PKA_Process(PKA_HandleTypeDef *hpka, uint32_t mode, uint32_t Timeout)
{
 c03f8be:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  HAL_StatusTypeDef err = HAL_OK;
  uint32_t tickstart;

  if (hpka->State == HAL_PKA_STATE_READY)
 c03f8c0:	7903      	ldrb	r3, [r0, #4]
{
 c03f8c2:	4604      	mov	r4, r0
  if (hpka->State == HAL_PKA_STATE_READY)
 c03f8c4:	2b01      	cmp	r3, #1
{
 c03f8c6:	460d      	mov	r5, r1
 c03f8c8:	4617      	mov	r7, r2
  if (hpka->State == HAL_PKA_STATE_READY)
 c03f8ca:	d138      	bne.n	c03f93e <PKA_Process+0x80>
  {
    /* Set the state to busy */
    hpka->State = HAL_PKA_STATE_BUSY;
 c03f8cc:	2302      	movs	r3, #2
 c03f8ce:	7103      	strb	r3, [r0, #4]

    /* Clear any pending error */
    hpka->ErrorCode = HAL_PKA_ERROR_NONE;
 c03f8d0:	2300      	movs	r3, #0
 c03f8d2:	6083      	str	r3, [r0, #8]

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
 c03f8d4:	f004 fa08 	bl	c043ce8 <HAL_GetTick>

    /* Set the mode and deactivate the interrupts */
    MODIFY_REG(hpka->Instance->CR, PKA_CR_MODE | PKA_CR_PROCENDIE | PKA_CR_RAMERRIE | PKA_CR_ADDRERRIE | PKA_CR_OPERRIE,
 c03f8d8:	6826      	ldr	r6, [r4, #0]
    tickstart = HAL_GetTick();
 c03f8da:	4602      	mov	r2, r0
    MODIFY_REG(hpka->Instance->CR, PKA_CR_MODE | PKA_CR_PROCENDIE | PKA_CR_RAMERRIE | PKA_CR_ADDRERRIE | PKA_CR_OPERRIE,
 c03f8dc:	6833      	ldr	r3, [r6, #0]

    /* Start the computation */
    hpka->Instance->CR |= PKA_CR_START;

    /* Wait for the end of operation or timeout */
    if (PKA_PollEndOfOperation(hpka, Timeout, tickstart) != HAL_OK)
 c03f8de:	4639      	mov	r1, r7
    MODIFY_REG(hpka->Instance->CR, PKA_CR_MODE | PKA_CR_PROCENDIE | PKA_CR_RAMERRIE | PKA_CR_ADDRERRIE | PKA_CR_OPERRIE,
 c03f8e0:	f423 1368 	bic.w	r3, r3, #3801088	@ 0x3a0000
 c03f8e4:	f423 537c 	bic.w	r3, r3, #16128	@ 0x3f00
 c03f8e8:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
 c03f8ec:	6033      	str	r3, [r6, #0]
    hpka->Instance->CR |= PKA_CR_START;
 c03f8ee:	6833      	ldr	r3, [r6, #0]
    if (PKA_PollEndOfOperation(hpka, Timeout, tickstart) != HAL_OK)
 c03f8f0:	4620      	mov	r0, r4
    hpka->Instance->CR |= PKA_CR_START;
 c03f8f2:	f043 0302 	orr.w	r3, r3, #2
 c03f8f6:	6033      	str	r3, [r6, #0]
    if (PKA_PollEndOfOperation(hpka, Timeout, tickstart) != HAL_OK)
 c03f8f8:	f7ff fe78 	bl	c03f5ec <PKA_PollEndOfOperation>
 c03f8fc:	b160      	cbz	r0, c03f918 <PKA_Process+0x5a>
    {
      /* Abort any ongoing operation */
      CLEAR_BIT(hpka->Instance->CR, PKA_CR_EN);
 c03f8fe:	6823      	ldr	r3, [r4, #0]
 c03f900:	681a      	ldr	r2, [r3, #0]
 c03f902:	f022 0201 	bic.w	r2, r2, #1
 c03f906:	601a      	str	r2, [r3, #0]

      hpka->ErrorCode |= HAL_PKA_ERROR_TIMEOUT;
 c03f908:	68a2      	ldr	r2, [r4, #8]
 c03f90a:	f042 0204 	orr.w	r2, r2, #4
 c03f90e:	60a2      	str	r2, [r4, #8]

      /* Make ready for the next operation */
      SET_BIT(hpka->Instance->CR, PKA_CR_EN);
 c03f910:	681a      	ldr	r2, [r3, #0]
 c03f912:	f042 0201 	orr.w	r2, r2, #1
 c03f916:	601a      	str	r2, [r3, #0]
    }

    /* Check error */
    hpka->ErrorCode |= PKA_CheckError(hpka, mode);
 c03f918:	4629      	mov	r1, r5
 c03f91a:	4620      	mov	r0, r4
 c03f91c:	f7ff fe7b 	bl	c03f616 <PKA_CheckError>
 c03f920:	68a3      	ldr	r3, [r4, #8]

    /* Clear all flags */
    hpka->Instance->CLRFR |= (PKA_CLRFR_PROCENDFC | PKA_CLRFR_RAMERRFC | PKA_CLRFR_ADDRERRFC | PKA_CLRFR_OPERRFC);
 c03f922:	6822      	ldr	r2, [r4, #0]
    hpka->ErrorCode |= PKA_CheckError(hpka, mode);
 c03f924:	4303      	orrs	r3, r0
 c03f926:	60a3      	str	r3, [r4, #8]
    hpka->Instance->CLRFR |= (PKA_CLRFR_PROCENDFC | PKA_CLRFR_RAMERRFC | PKA_CLRFR_ADDRERRFC | PKA_CLRFR_OPERRFC);
 c03f928:	6893      	ldr	r3, [r2, #8]
 c03f92a:	f443 1368 	orr.w	r3, r3, #3801088	@ 0x3a0000
 c03f92e:	6093      	str	r3, [r2, #8]

    /* Set the state to ready */
    hpka->State = HAL_PKA_STATE_READY;
 c03f930:	2301      	movs	r3, #1
 c03f932:	7123      	strb	r3, [r4, #4]

    /* Manage the result based on encountered errors */
    if (hpka->ErrorCode != HAL_PKA_ERROR_NONE)
 c03f934:	68a0      	ldr	r0, [r4, #8]
 c03f936:	3800      	subs	r0, #0
 c03f938:	bf18      	it	ne
 c03f93a:	2001      	movne	r0, #1
  else
  {
    err = HAL_ERROR;
  }
  return err;
}
 c03f93c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      err = HAL_ERROR;
 c03f93e:	2001      	movs	r0, #1
 c03f940:	e7fc      	b.n	c03f93c <PKA_Process+0x7e>

0c03f942 <PKA_ModExp_Set>:
  * @brief  Set input parameters.
  * @param  hpka PKA handle
  * @param  in Input information
  */
void PKA_ModExp_Set(PKA_HandleTypeDef *hpka, PKA_ModExpInTypeDef *in)
{
 c03f942:	b570      	push	{r4, r5, r6, lr}
 c03f944:	460d      	mov	r5, r1
  /* Get the number of bit of the exponent */
  hpka->Instance->RAM[PKA_MODULAR_EXP_IN_EXP_NB_BITS] = PKA_GetBitSize_u8(in->expSize);

  /* Move the input parameters pOp1 to PKA RAM */
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_MODULAR_EXP_IN_EXPONENT_BASE], in->pOp1, in->OpSize);
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_MODULAR_EXP_IN_EXPONENT_BASE + ((in->OpSize + 3UL) / 4UL));
 c03f946:	2600      	movs	r6, #0
  hpka->Instance->RAM[PKA_MODULAR_EXP_IN_OP_NB_BITS] = PKA_GetBitSize_u8(in->OpSize);
 c03f948:	684a      	ldr	r2, [r1, #4]
 c03f94a:	6804      	ldr	r4, [r0, #0]
  return byteNumber * 8UL;
 c03f94c:	00d3      	lsls	r3, r2, #3
  hpka->Instance->RAM[PKA_MODULAR_EXP_IN_OP_NB_BITS] = PKA_GetBitSize_u8(in->OpSize);
 c03f94e:	f8c4 3408 	str.w	r3, [r4, #1032]	@ 0x408
  return byteNumber * 8UL;
 c03f952:	680b      	ldr	r3, [r1, #0]
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_MODULAR_EXP_IN_EXPONENT_BASE], in->pOp1, in->OpSize);
 c03f954:	f604 4068 	addw	r0, r4, #3176	@ 0xc68
  return byteNumber * 8UL;
 c03f958:	00db      	lsls	r3, r3, #3
  hpka->Instance->RAM[PKA_MODULAR_EXP_IN_EXP_NB_BITS] = PKA_GetBitSize_u8(in->expSize);
 c03f95a:	f8c4 3400 	str.w	r3, [r4, #1024]	@ 0x400
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_MODULAR_EXP_IN_EXPONENT_BASE], in->pOp1, in->OpSize);
 c03f95e:	68c9      	ldr	r1, [r1, #12]
 c03f960:	f7ff ff26 	bl	c03f7b0 <PKA_Memcpy_u8_to_u32>
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_MODULAR_EXP_IN_EXPONENT_BASE + ((in->OpSize + 3UL) / 4UL));
 c03f964:	686b      	ldr	r3, [r5, #4]

  /* Move the exponent to PKA RAM */
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_MODULAR_EXP_IN_EXPONENT], in->pExp, in->expSize);
 c03f966:	f604 6078 	addw	r0, r4, #3704	@ 0xe78
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_MODULAR_EXP_IN_EXPONENT_BASE + ((in->OpSize + 3UL) / 4UL));
 c03f96a:	3303      	adds	r3, #3
 c03f96c:	f023 0303 	bic.w	r3, r3, #3
 c03f970:	4423      	add	r3, r4
 c03f972:	f8c3 6c68 	str.w	r6, [r3, #3176]	@ 0xc68
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_MODULAR_EXP_IN_EXPONENT], in->pExp, in->expSize);
 c03f976:	682a      	ldr	r2, [r5, #0]
 c03f978:	68a9      	ldr	r1, [r5, #8]
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_MODULAR_EXP_IN_EXPONENT_BASE + ((in->OpSize + 3UL) / 4UL));
 c03f97a:	f8c3 6c6c 	str.w	r6, [r3, #3180]	@ 0xc6c
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_MODULAR_EXP_IN_EXPONENT], in->pExp, in->expSize);
 c03f97e:	f7ff ff17 	bl	c03f7b0 <PKA_Memcpy_u8_to_u32>
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_MODULAR_EXP_IN_EXPONENT + ((in->expSize + 3UL) / 4UL));
 c03f982:	682b      	ldr	r3, [r5, #0]

  /* Move the modulus to PKA RAM */
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_MODULAR_EXP_IN_MODULUS], in->pMod, in->OpSize);
 c03f984:	f504 5084 	add.w	r0, r4, #4224	@ 0x1080
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_MODULAR_EXP_IN_EXPONENT + ((in->expSize + 3UL) / 4UL));
 c03f988:	3303      	adds	r3, #3
 c03f98a:	f023 0303 	bic.w	r3, r3, #3
 c03f98e:	4423      	add	r3, r4
 c03f990:	f8c3 6e78 	str.w	r6, [r3, #3704]	@ 0xe78
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_MODULAR_EXP_IN_MODULUS], in->pMod, in->OpSize);
 c03f994:	686a      	ldr	r2, [r5, #4]
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_MODULAR_EXP_IN_EXPONENT + ((in->expSize + 3UL) / 4UL));
 c03f996:	f8c3 6e7c 	str.w	r6, [r3, #3708]	@ 0xe7c
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_MODULAR_EXP_IN_MODULUS], in->pMod, in->OpSize);
 c03f99a:	6929      	ldr	r1, [r5, #16]
 c03f99c:	3008      	adds	r0, #8
 c03f99e:	f7ff ff07 	bl	c03f7b0 <PKA_Memcpy_u8_to_u32>
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_MODULAR_EXP_IN_MODULUS + ((in->OpSize + 3UL) / 4UL));
 c03f9a2:	686b      	ldr	r3, [r5, #4]
 c03f9a4:	3303      	adds	r3, #3
 c03f9a6:	f023 0303 	bic.w	r3, r3, #3
 c03f9aa:	441c      	add	r4, r3
 c03f9ac:	f504 5480 	add.w	r4, r4, #4096	@ 0x1000
 c03f9b0:	f8c4 6088 	str.w	r6, [r4, #136]	@ 0x88
 c03f9b4:	f8c4 608c 	str.w	r6, [r4, #140]	@ 0x8c
}
 c03f9b8:	bd70      	pop	{r4, r5, r6, pc}
	...

0c03f9bc <HAL_PKA_ModExp>:
{
 c03f9bc:	b570      	push	{r4, r5, r6, lr}
 c03f9be:	460e      	mov	r6, r1
 c03f9c0:	4615      	mov	r5, r2
 c03f9c2:	4604      	mov	r4, r0
  PKA_ModExp_Set(hpka, in);
 c03f9c4:	f7ff ffbd 	bl	c03f942 <PKA_ModExp_Set>
  opsize = in->OpSize;
 c03f9c8:	6872      	ldr	r2, [r6, #4]
 c03f9ca:	4b04      	ldr	r3, [pc, #16]	@ (c03f9dc <HAL_PKA_ModExp+0x20>)
  return PKA_Process(hpka, PKA_MODE_MODULAR_EXP, Timeout);
 c03f9cc:	4620      	mov	r0, r4
  opsize = in->OpSize;
 c03f9ce:	601a      	str	r2, [r3, #0]
  return PKA_Process(hpka, PKA_MODE_MODULAR_EXP, Timeout);
 c03f9d0:	2100      	movs	r1, #0
 c03f9d2:	462a      	mov	r2, r5
}
 c03f9d4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  return PKA_Process(hpka, PKA_MODE_MODULAR_EXP, Timeout);
 c03f9d8:	f7ff bf71 	b.w	c03f8be <PKA_Process>
 c03f9dc:	30030ee0 	.word	0x30030ee0

0c03f9e0 <PKA_ECDSASign_Set>:
  * @param  in Input information
  * @note   If the modulus size is bigger than the hash size (with a curve SECP521R1 when using a SHA256 hash
  *         for example)the hash value should be written at the end of the buffer with zeros padding at beginning.
  */
void PKA_ECDSASign_Set(PKA_HandleTypeDef *hpka, PKA_ECDSASignInTypeDef *in)
{
 c03f9e0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 c03f9e4:	460c      	mov	r4, r1
  /* Get the prime order n length */
  hpka->Instance->RAM[PKA_ECDSA_SIGN_IN_ORDER_NB_BITS] = PKA_GetOptBitSize_u8(in->primeOrderSize, *(in->primeOrder));
 c03f9e6:	6acf      	ldr	r7, [r1, #44]	@ 0x2c
 c03f9e8:	6805      	ldr	r5, [r0, #0]
 c03f9ea:	7839      	ldrb	r1, [r7, #0]
 c03f9ec:	6820      	ldr	r0, [r4, #0]
 c03f9ee:	f7ff fe40 	bl	c03f672 <PKA_GetOptBitSize_u8>

  /* Get the modulus p length */
  hpka->Instance->RAM[PKA_ECDSA_SIGN_IN_MOD_NB_BITS] = PKA_GetOptBitSize_u8(in->modulusSize, *(in->modulus));
 c03f9f2:	6862      	ldr	r2, [r4, #4]
 c03f9f4:	f8d4 8014 	ldr.w	r8, [r4, #20]
  hpka->Instance->RAM[PKA_ECDSA_SIGN_IN_ORDER_NB_BITS] = PKA_GetOptBitSize_u8(in->primeOrderSize, *(in->primeOrder));
 c03f9f8:	f8c5 0400 	str.w	r0, [r5, #1024]	@ 0x400
  hpka->Instance->RAM[PKA_ECDSA_SIGN_IN_MOD_NB_BITS] = PKA_GetOptBitSize_u8(in->modulusSize, *(in->modulus));
 c03f9fc:	f898 1000 	ldrb.w	r1, [r8]
 c03fa00:	4610      	mov	r0, r2
 c03fa02:	f7ff fe36 	bl	c03f672 <PKA_GetOptBitSize_u8>
  /* Get the coefficient a sign */
  hpka->Instance->RAM[PKA_ECDSA_SIGN_IN_A_COEFF_SIGN] = in->coefSign;

  /* Move the input parameters coefficient |a| to PKA RAM */
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECDSA_SIGN_IN_A_COEFF], in->coef, in->modulusSize);
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ECDSA_SIGN_IN_A_COEFF + ((in->modulusSize + 3UL) / 4UL));
 c03fa06:	2600      	movs	r6, #0
  hpka->Instance->RAM[PKA_ECDSA_SIGN_IN_A_COEFF_SIGN] = in->coefSign;
 c03fa08:	68a3      	ldr	r3, [r4, #8]
  hpka->Instance->RAM[PKA_ECDSA_SIGN_IN_MOD_NB_BITS] = PKA_GetOptBitSize_u8(in->modulusSize, *(in->modulus));
 c03fa0a:	f8c5 0408 	str.w	r0, [r5, #1032]	@ 0x408
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECDSA_SIGN_IN_A_COEFF], in->coef, in->modulusSize);
 c03fa0e:	68e1      	ldr	r1, [r4, #12]
  hpka->Instance->RAM[PKA_ECDSA_SIGN_IN_A_COEFF_SIGN] = in->coefSign;
 c03fa10:	f8c5 3410 	str.w	r3, [r5, #1040]	@ 0x410
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECDSA_SIGN_IN_A_COEFF], in->coef, in->modulusSize);
 c03fa14:	f505 6083 	add.w	r0, r5, #1048	@ 0x418
 c03fa18:	f7ff feca 	bl	c03f7b0 <PKA_Memcpy_u8_to_u32>
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ECDSA_SIGN_IN_A_COEFF + ((in->modulusSize + 3UL) / 4UL));
 c03fa1c:	6862      	ldr	r2, [r4, #4]

  /* Move the input parameters coefficient B to PKA RAM */
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECDSA_SIGN_IN_B_COEFF], in->coefB, in->modulusSize);
 c03fa1e:	f505 60a4 	add.w	r0, r5, #1312	@ 0x520
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ECDSA_SIGN_IN_A_COEFF + ((in->modulusSize + 3UL) / 4UL));
 c03fa22:	1cd3      	adds	r3, r2, #3
 c03fa24:	f023 0303 	bic.w	r3, r3, #3
 c03fa28:	442b      	add	r3, r5
 c03fa2a:	f8c3 6418 	str.w	r6, [r3, #1048]	@ 0x418
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECDSA_SIGN_IN_B_COEFF], in->coefB, in->modulusSize);
 c03fa2e:	6921      	ldr	r1, [r4, #16]
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ECDSA_SIGN_IN_A_COEFF + ((in->modulusSize + 3UL) / 4UL));
 c03fa30:	f8c3 641c 	str.w	r6, [r3, #1052]	@ 0x41c
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECDSA_SIGN_IN_B_COEFF], in->coefB, in->modulusSize);
 c03fa34:	f7ff febc 	bl	c03f7b0 <PKA_Memcpy_u8_to_u32>
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ECDSA_SIGN_IN_B_COEFF + ((in->modulusSize + 3UL) / 4UL));
 c03fa38:	6862      	ldr	r2, [r4, #4]

  /* Move the input parameters modulus value p to PKA RAM */
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECDSA_SIGN_IN_MOD_GF], in->modulus, in->modulusSize);
 c03fa3a:	f505 5084 	add.w	r0, r5, #4224	@ 0x1080
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ECDSA_SIGN_IN_B_COEFF + ((in->modulusSize + 3UL) / 4UL));
 c03fa3e:	1cd3      	adds	r3, r2, #3
 c03fa40:	f023 0303 	bic.w	r3, r3, #3
 c03fa44:	442b      	add	r3, r5
 c03fa46:	f8c3 6520 	str.w	r6, [r3, #1312]	@ 0x520
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECDSA_SIGN_IN_MOD_GF], in->modulus, in->modulusSize);
 c03fa4a:	4641      	mov	r1, r8
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ECDSA_SIGN_IN_B_COEFF + ((in->modulusSize + 3UL) / 4UL));
 c03fa4c:	f8c3 6524 	str.w	r6, [r3, #1316]	@ 0x524
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECDSA_SIGN_IN_MOD_GF], in->modulus, in->modulusSize);
 c03fa50:	3008      	adds	r0, #8
 c03fa52:	f7ff fead 	bl	c03f7b0 <PKA_Memcpy_u8_to_u32>
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ECDSA_SIGN_IN_MOD_GF + ((in->modulusSize + 3UL) / 4UL));
 c03fa56:	6863      	ldr	r3, [r4, #4]

  /* Move the input parameters integer k to PKA RAM */
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECDSA_SIGN_IN_K], in->integer, in->primeOrderSize);
 c03fa58:	f505 5095 	add.w	r0, r5, #4768	@ 0x12a0
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ECDSA_SIGN_IN_MOD_GF + ((in->modulusSize + 3UL) / 4UL));
 c03fa5c:	3303      	adds	r3, #3
 c03fa5e:	f023 0303 	bic.w	r3, r3, #3
 c03fa62:	442b      	add	r3, r5
 c03fa64:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 c03fa68:	f8c3 6088 	str.w	r6, [r3, #136]	@ 0x88
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECDSA_SIGN_IN_K], in->integer, in->primeOrderSize);
 c03fa6c:	6822      	ldr	r2, [r4, #0]
 c03fa6e:	69a1      	ldr	r1, [r4, #24]
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ECDSA_SIGN_IN_MOD_GF + ((in->modulusSize + 3UL) / 4UL));
 c03fa70:	f8c3 608c 	str.w	r6, [r3, #140]	@ 0x8c
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECDSA_SIGN_IN_K], in->integer, in->primeOrderSize);
 c03fa74:	f7ff fe9c 	bl	c03f7b0 <PKA_Memcpy_u8_to_u32>
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ECDSA_SIGN_IN_K + ((in->primeOrderSize + 3UL) / 4UL));
 c03fa78:	6823      	ldr	r3, [r4, #0]

  /* Move the input parameters base point G coordinate x to PKA RAM */
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECDSA_SIGN_IN_INITIAL_POINT_X], in->basePointX, in->modulusSize);
 c03fa7a:	f505 60af 	add.w	r0, r5, #1400	@ 0x578
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ECDSA_SIGN_IN_K + ((in->primeOrderSize + 3UL) / 4UL));
 c03fa7e:	3303      	adds	r3, #3
 c03fa80:	f023 0303 	bic.w	r3, r3, #3
 c03fa84:	442b      	add	r3, r5
 c03fa86:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 c03fa8a:	f8c3 62a0 	str.w	r6, [r3, #672]	@ 0x2a0
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECDSA_SIGN_IN_INITIAL_POINT_X], in->basePointX, in->modulusSize);
 c03fa8e:	6862      	ldr	r2, [r4, #4]
 c03fa90:	69e1      	ldr	r1, [r4, #28]
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ECDSA_SIGN_IN_K + ((in->primeOrderSize + 3UL) / 4UL));
 c03fa92:	f8c3 62a4 	str.w	r6, [r3, #676]	@ 0x2a4
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECDSA_SIGN_IN_INITIAL_POINT_X], in->basePointX, in->modulusSize);
 c03fa96:	f7ff fe8b 	bl	c03f7b0 <PKA_Memcpy_u8_to_u32>
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ECDSA_SIGN_IN_INITIAL_POINT_X + ((in->modulusSize + 3UL) / 4UL));
 c03fa9a:	6862      	ldr	r2, [r4, #4]

  /* Move the input parameters base point G coordinate y to PKA RAM */
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECDSA_SIGN_IN_INITIAL_POINT_Y], in->basePointY, in->modulusSize);
 c03fa9c:	f505 608e 	add.w	r0, r5, #1136	@ 0x470
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ECDSA_SIGN_IN_INITIAL_POINT_X + ((in->modulusSize + 3UL) / 4UL));
 c03faa0:	1cd3      	adds	r3, r2, #3
 c03faa2:	f023 0303 	bic.w	r3, r3, #3
 c03faa6:	442b      	add	r3, r5
 c03faa8:	f8c3 6578 	str.w	r6, [r3, #1400]	@ 0x578
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECDSA_SIGN_IN_INITIAL_POINT_Y], in->basePointY, in->modulusSize);
 c03faac:	6a21      	ldr	r1, [r4, #32]
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ECDSA_SIGN_IN_INITIAL_POINT_X + ((in->modulusSize + 3UL) / 4UL));
 c03faae:	f8c3 657c 	str.w	r6, [r3, #1404]	@ 0x57c
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECDSA_SIGN_IN_INITIAL_POINT_Y], in->basePointY, in->modulusSize);
 c03fab2:	f7ff fe7d 	bl	c03f7b0 <PKA_Memcpy_u8_to_u32>
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ECDSA_SIGN_IN_INITIAL_POINT_Y + ((in->modulusSize + 3UL) / 4UL));
 c03fab6:	6863      	ldr	r3, [r4, #4]

  /* Move the input parameters hash of message z to PKA RAM */
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECDSA_SIGN_IN_HASH_E], in->hash, in->primeOrderSize);
 c03fab8:	f605 70e8 	addw	r0, r5, #4072	@ 0xfe8
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ECDSA_SIGN_IN_INITIAL_POINT_Y + ((in->modulusSize + 3UL) / 4UL));
 c03fabc:	3303      	adds	r3, #3
 c03fabe:	f023 0303 	bic.w	r3, r3, #3
 c03fac2:	442b      	add	r3, r5
 c03fac4:	f8c3 6470 	str.w	r6, [r3, #1136]	@ 0x470
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECDSA_SIGN_IN_HASH_E], in->hash, in->primeOrderSize);
 c03fac8:	6822      	ldr	r2, [r4, #0]
 c03faca:	6a61      	ldr	r1, [r4, #36]	@ 0x24
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ECDSA_SIGN_IN_INITIAL_POINT_Y + ((in->modulusSize + 3UL) / 4UL));
 c03facc:	f8c3 6474 	str.w	r6, [r3, #1140]	@ 0x474
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECDSA_SIGN_IN_HASH_E], in->hash, in->primeOrderSize);
 c03fad0:	f7ff fe6e 	bl	c03f7b0 <PKA_Memcpy_u8_to_u32>
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ECDSA_SIGN_IN_HASH_E + ((in->primeOrderSize + 3UL) / 4UL));
 c03fad4:	6822      	ldr	r2, [r4, #0]

  /* Move the input parameters private key d to PKA RAM */
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECDSA_SIGN_IN_PRIVATE_KEY_D], in->privateKey, in->primeOrderSize);
 c03fad6:	f605 7028 	addw	r0, r5, #3880	@ 0xf28
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ECDSA_SIGN_IN_HASH_E + ((in->primeOrderSize + 3UL) / 4UL));
 c03fada:	1cd3      	adds	r3, r2, #3
 c03fadc:	f023 0303 	bic.w	r3, r3, #3
 c03fae0:	442b      	add	r3, r5
 c03fae2:	f8c3 6fe8 	str.w	r6, [r3, #4072]	@ 0xfe8
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECDSA_SIGN_IN_PRIVATE_KEY_D], in->privateKey, in->primeOrderSize);
 c03fae6:	6aa1      	ldr	r1, [r4, #40]	@ 0x28
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ECDSA_SIGN_IN_HASH_E + ((in->primeOrderSize + 3UL) / 4UL));
 c03fae8:	f8c3 6fec 	str.w	r6, [r3, #4076]	@ 0xfec
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECDSA_SIGN_IN_PRIVATE_KEY_D], in->privateKey, in->primeOrderSize);
 c03faec:	f7ff fe60 	bl	c03f7b0 <PKA_Memcpy_u8_to_u32>
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ECDSA_SIGN_IN_PRIVATE_KEY_D + ((in->primeOrderSize + 3UL) / 4UL));
 c03faf0:	6822      	ldr	r2, [r4, #0]

  /* Move the input parameters prime order n to PKA RAM */
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECDSA_SIGN_IN_ORDER_N], in->primeOrder, in->primeOrderSize);
 c03faf2:	f605 7088 	addw	r0, r5, #3976	@ 0xf88
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ECDSA_SIGN_IN_PRIVATE_KEY_D + ((in->primeOrderSize + 3UL) / 4UL));
 c03faf6:	1cd3      	adds	r3, r2, #3
 c03faf8:	f023 0303 	bic.w	r3, r3, #3
 c03fafc:	442b      	add	r3, r5
 c03fafe:	f8c3 6f28 	str.w	r6, [r3, #3880]	@ 0xf28
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECDSA_SIGN_IN_ORDER_N], in->primeOrder, in->primeOrderSize);
 c03fb02:	4639      	mov	r1, r7
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ECDSA_SIGN_IN_PRIVATE_KEY_D + ((in->primeOrderSize + 3UL) / 4UL));
 c03fb04:	f8c3 6f2c 	str.w	r6, [r3, #3884]	@ 0xf2c
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECDSA_SIGN_IN_ORDER_N], in->primeOrder, in->primeOrderSize);
 c03fb08:	f7ff fe52 	bl	c03f7b0 <PKA_Memcpy_u8_to_u32>
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ECDSA_SIGN_IN_ORDER_N + ((in->primeOrderSize + 3UL) / 4UL));
 c03fb0c:	6823      	ldr	r3, [r4, #0]
 c03fb0e:	3303      	adds	r3, #3
 c03fb10:	f023 0303 	bic.w	r3, r3, #3
 c03fb14:	441d      	add	r5, r3
 c03fb16:	f8c5 6f88 	str.w	r6, [r5, #3976]	@ 0xf88
 c03fb1a:	f8c5 6f8c 	str.w	r6, [r5, #3980]	@ 0xf8c
}
 c03fb1e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	...

0c03fb24 <HAL_PKA_ECDSASign>:
{
 c03fb24:	b570      	push	{r4, r5, r6, lr}
 c03fb26:	460e      	mov	r6, r1
 c03fb28:	4615      	mov	r5, r2
 c03fb2a:	4604      	mov	r4, r0
  PKA_ECDSASign_Set(hpka, in);
 c03fb2c:	f7ff ff58 	bl	c03f9e0 <PKA_ECDSASign_Set>
  primeordersize = in->primeOrderSize;
 c03fb30:	6832      	ldr	r2, [r6, #0]
 c03fb32:	4b04      	ldr	r3, [pc, #16]	@ (c03fb44 <HAL_PKA_ECDSASign+0x20>)
  return PKA_Process(hpka, PKA_MODE_ECDSA_SIGNATURE, Timeout);
 c03fb34:	4620      	mov	r0, r4
  primeordersize = in->primeOrderSize;
 c03fb36:	601a      	str	r2, [r3, #0]
  return PKA_Process(hpka, PKA_MODE_ECDSA_SIGNATURE, Timeout);
 c03fb38:	2124      	movs	r1, #36	@ 0x24
 c03fb3a:	462a      	mov	r2, r5
}
 c03fb3c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  return PKA_Process(hpka, PKA_MODE_ECDSA_SIGNATURE, Timeout);
 c03fb40:	f7ff bebd 	b.w	c03f8be <PKA_Process>
 c03fb44:	30030ee4 	.word	0x30030ee4

0c03fb48 <PKA_ECDSAVerif_Set>:
  * @brief  Set input parameters.
  * @param  hpka PKA handle
  * @param  in Input information
  */
void PKA_ECDSAVerif_Set(PKA_HandleTypeDef *hpka, PKA_ECDSAVerifInTypeDef *in)
{
 c03fb48:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 c03fb4c:	460d      	mov	r5, r1
  /* Get the prime order n length */
  hpka->Instance->RAM[PKA_ECDSA_VERIF_IN_ORDER_NB_BITS] = PKA_GetOptBitSize_u8(in->primeOrderSize, *(in->primeOrder));
 c03fb4e:	6b0f      	ldr	r7, [r1, #48]	@ 0x30
 c03fb50:	6804      	ldr	r4, [r0, #0]
 c03fb52:	7839      	ldrb	r1, [r7, #0]
 c03fb54:	6828      	ldr	r0, [r5, #0]
 c03fb56:	f7ff fd8c 	bl	c03f672 <PKA_GetOptBitSize_u8>

  /* Get the modulus p length */
  hpka->Instance->RAM[PKA_ECDSA_VERIF_IN_MOD_NB_BITS] = PKA_GetOptBitSize_u8(in->modulusSize, *(in->modulus));
 c03fb5a:	686a      	ldr	r2, [r5, #4]
 c03fb5c:	f8d5 8010 	ldr.w	r8, [r5, #16]
  hpka->Instance->RAM[PKA_ECDSA_VERIF_IN_ORDER_NB_BITS] = PKA_GetOptBitSize_u8(in->primeOrderSize, *(in->primeOrder));
 c03fb60:	f8c4 0408 	str.w	r0, [r4, #1032]	@ 0x408
  hpka->Instance->RAM[PKA_ECDSA_VERIF_IN_MOD_NB_BITS] = PKA_GetOptBitSize_u8(in->modulusSize, *(in->modulus));
 c03fb64:	f898 1000 	ldrb.w	r1, [r8]
 c03fb68:	4610      	mov	r0, r2
 c03fb6a:	f7ff fd82 	bl	c03f672 <PKA_GetOptBitSize_u8>
  /* Get the coefficient a sign */
  hpka->Instance->RAM[PKA_ECDSA_VERIF_IN_A_COEFF_SIGN] = in->coefSign;

  /* Move the input parameters coefficient |a| to PKA RAM */
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECDSA_VERIF_IN_A_COEFF], in->coef, in->modulusSize);
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ECDSA_VERIF_IN_A_COEFF + ((in->modulusSize + 3UL) / 4UL));
 c03fb6e:	2600      	movs	r6, #0
  hpka->Instance->RAM[PKA_ECDSA_VERIF_IN_A_COEFF_SIGN] = in->coefSign;
 c03fb70:	68ab      	ldr	r3, [r5, #8]
  hpka->Instance->RAM[PKA_ECDSA_VERIF_IN_MOD_NB_BITS] = PKA_GetOptBitSize_u8(in->modulusSize, *(in->modulus));
 c03fb72:	f8c4 04c8 	str.w	r0, [r4, #1224]	@ 0x4c8
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECDSA_VERIF_IN_A_COEFF], in->coef, in->modulusSize);
 c03fb76:	68e9      	ldr	r1, [r5, #12]
  hpka->Instance->RAM[PKA_ECDSA_VERIF_IN_A_COEFF_SIGN] = in->coefSign;
 c03fb78:	f8c4 3468 	str.w	r3, [r4, #1128]	@ 0x468
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECDSA_VERIF_IN_A_COEFF], in->coef, in->modulusSize);
 c03fb7c:	f504 608e 	add.w	r0, r4, #1136	@ 0x470
 c03fb80:	f7ff fe16 	bl	c03f7b0 <PKA_Memcpy_u8_to_u32>
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ECDSA_VERIF_IN_A_COEFF + ((in->modulusSize + 3UL) / 4UL));
 c03fb84:	686a      	ldr	r2, [r5, #4]

  /* Move the input parameters modulus value p to PKA RAM */
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECDSA_VERIF_IN_MOD_GF], in->modulus, in->modulusSize);
 c03fb86:	f504 609a 	add.w	r0, r4, #1232	@ 0x4d0
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ECDSA_VERIF_IN_A_COEFF + ((in->modulusSize + 3UL) / 4UL));
 c03fb8a:	1cd3      	adds	r3, r2, #3
 c03fb8c:	f023 0303 	bic.w	r3, r3, #3
 c03fb90:	4423      	add	r3, r4
 c03fb92:	f8c3 6470 	str.w	r6, [r3, #1136]	@ 0x470
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECDSA_VERIF_IN_MOD_GF], in->modulus, in->modulusSize);
 c03fb96:	4641      	mov	r1, r8
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ECDSA_VERIF_IN_A_COEFF + ((in->modulusSize + 3UL) / 4UL));
 c03fb98:	f8c3 6474 	str.w	r6, [r3, #1140]	@ 0x474
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECDSA_VERIF_IN_MOD_GF], in->modulus, in->modulusSize);
 c03fb9c:	f7ff fe08 	bl	c03f7b0 <PKA_Memcpy_u8_to_u32>
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ECDSA_VERIF_IN_MOD_GF + ((in->modulusSize + 3UL) / 4UL));
 c03fba0:	686a      	ldr	r2, [r5, #4]

  /* Move the input parameters base point G coordinate x to PKA RAM */
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECDSA_VERIF_IN_INITIAL_POINT_X], in->basePointX, in->modulusSize);
 c03fba2:	f504 60cf 	add.w	r0, r4, #1656	@ 0x678
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ECDSA_VERIF_IN_MOD_GF + ((in->modulusSize + 3UL) / 4UL));
 c03fba6:	1cd3      	adds	r3, r2, #3
 c03fba8:	f023 0303 	bic.w	r3, r3, #3
 c03fbac:	4423      	add	r3, r4
 c03fbae:	f8c3 64d0 	str.w	r6, [r3, #1232]	@ 0x4d0
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECDSA_VERIF_IN_INITIAL_POINT_X], in->basePointX, in->modulusSize);
 c03fbb2:	6969      	ldr	r1, [r5, #20]
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ECDSA_VERIF_IN_MOD_GF + ((in->modulusSize + 3UL) / 4UL));
 c03fbb4:	f8c3 64d4 	str.w	r6, [r3, #1236]	@ 0x4d4
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECDSA_VERIF_IN_INITIAL_POINT_X], in->basePointX, in->modulusSize);
 c03fbb8:	f7ff fdfa 	bl	c03f7b0 <PKA_Memcpy_u8_to_u32>
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ECDSA_VERIF_IN_INITIAL_POINT_X + ((in->modulusSize + 3UL) / 4UL));
 c03fbbc:	686a      	ldr	r2, [r5, #4]

  /* Move the input parameters base point G coordinate y to PKA RAM */
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECDSA_VERIF_IN_INITIAL_POINT_Y], in->basePointY, in->modulusSize);
 c03fbbe:	f504 60da 	add.w	r0, r4, #1744	@ 0x6d0
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ECDSA_VERIF_IN_INITIAL_POINT_X + ((in->modulusSize + 3UL) / 4UL));
 c03fbc2:	1cd3      	adds	r3, r2, #3
 c03fbc4:	f023 0303 	bic.w	r3, r3, #3
 c03fbc8:	4423      	add	r3, r4
 c03fbca:	f8c3 6678 	str.w	r6, [r3, #1656]	@ 0x678
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECDSA_VERIF_IN_INITIAL_POINT_Y], in->basePointY, in->modulusSize);
 c03fbce:	69a9      	ldr	r1, [r5, #24]
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ECDSA_VERIF_IN_INITIAL_POINT_X + ((in->modulusSize + 3UL) / 4UL));
 c03fbd0:	f8c3 667c 	str.w	r6, [r3, #1660]	@ 0x67c
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECDSA_VERIF_IN_INITIAL_POINT_Y], in->basePointY, in->modulusSize);
 c03fbd4:	f7ff fdec 	bl	c03f7b0 <PKA_Memcpy_u8_to_u32>
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ECDSA_VERIF_IN_INITIAL_POINT_Y + ((in->modulusSize + 3UL) / 4UL));
 c03fbd8:	686a      	ldr	r2, [r5, #4]

  /* Move the input parameters public-key curve point Q coordinate xQ to PKA RAM */
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECDSA_VERIF_IN_PUBLIC_KEY_POINT_X], in->pPubKeyCurvePtX,
 c03fbda:	f504 5097 	add.w	r0, r4, #4832	@ 0x12e0
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ECDSA_VERIF_IN_INITIAL_POINT_Y + ((in->modulusSize + 3UL) / 4UL));
 c03fbde:	1cd3      	adds	r3, r2, #3
 c03fbe0:	f023 0303 	bic.w	r3, r3, #3
 c03fbe4:	4423      	add	r3, r4
 c03fbe6:	f8c3 66d0 	str.w	r6, [r3, #1744]	@ 0x6d0
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECDSA_VERIF_IN_PUBLIC_KEY_POINT_X], in->pPubKeyCurvePtX,
 c03fbea:	69e9      	ldr	r1, [r5, #28]
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ECDSA_VERIF_IN_INITIAL_POINT_Y + ((in->modulusSize + 3UL) / 4UL));
 c03fbec:	f8c3 66d4 	str.w	r6, [r3, #1748]	@ 0x6d4
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECDSA_VERIF_IN_PUBLIC_KEY_POINT_X], in->pPubKeyCurvePtX,
 c03fbf0:	3018      	adds	r0, #24
 c03fbf2:	f7ff fddd 	bl	c03f7b0 <PKA_Memcpy_u8_to_u32>
                       in->modulusSize);
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ECDSA_VERIF_IN_PUBLIC_KEY_POINT_X + ((in->modulusSize + 3UL) / 4UL));
 c03fbf6:	686a      	ldr	r2, [r5, #4]

  /* Move the input parameters public-key curve point Q coordinate xQ to PKA RAM */
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECDSA_VERIF_IN_PUBLIC_KEY_POINT_Y], in->pPubKeyCurvePtY,
 c03fbf8:	f504 509a 	add.w	r0, r4, #4928	@ 0x1340
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ECDSA_VERIF_IN_PUBLIC_KEY_POINT_X + ((in->modulusSize + 3UL) / 4UL));
 c03fbfc:	1cd3      	adds	r3, r2, #3
 c03fbfe:	f023 0303 	bic.w	r3, r3, #3
 c03fc02:	4423      	add	r3, r4
 c03fc04:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 c03fc08:	f8c3 62f8 	str.w	r6, [r3, #760]	@ 0x2f8
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECDSA_VERIF_IN_PUBLIC_KEY_POINT_Y], in->pPubKeyCurvePtY,
 c03fc0c:	6a29      	ldr	r1, [r5, #32]
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ECDSA_VERIF_IN_PUBLIC_KEY_POINT_X + ((in->modulusSize + 3UL) / 4UL));
 c03fc0e:	f8c3 62fc 	str.w	r6, [r3, #764]	@ 0x2fc
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECDSA_VERIF_IN_PUBLIC_KEY_POINT_Y], in->pPubKeyCurvePtY,
 c03fc12:	3010      	adds	r0, #16
 c03fc14:	f7ff fdcc 	bl	c03f7b0 <PKA_Memcpy_u8_to_u32>
                       in->modulusSize);
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ECDSA_VERIF_IN_PUBLIC_KEY_POINT_Y + ((in->modulusSize + 3UL) / 4UL));
 c03fc18:	686b      	ldr	r3, [r5, #4]

  /* Move the input parameters signature part r to PKA RAM */
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECDSA_VERIF_IN_SIGNATURE_R], in->RSign, in->primeOrderSize);
 c03fc1a:	f504 5087 	add.w	r0, r4, #4320	@ 0x10e0
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ECDSA_VERIF_IN_PUBLIC_KEY_POINT_Y + ((in->modulusSize + 3UL) / 4UL));
 c03fc1e:	3303      	adds	r3, #3
 c03fc20:	f023 0303 	bic.w	r3, r3, #3
 c03fc24:	4423      	add	r3, r4
 c03fc26:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 c03fc2a:	f8c3 6350 	str.w	r6, [r3, #848]	@ 0x350
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECDSA_VERIF_IN_SIGNATURE_R], in->RSign, in->primeOrderSize);
 c03fc2e:	682a      	ldr	r2, [r5, #0]
 c03fc30:	6a69      	ldr	r1, [r5, #36]	@ 0x24
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ECDSA_VERIF_IN_PUBLIC_KEY_POINT_Y + ((in->modulusSize + 3UL) / 4UL));
 c03fc32:	f8c3 6354 	str.w	r6, [r3, #852]	@ 0x354
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECDSA_VERIF_IN_SIGNATURE_R], in->RSign, in->primeOrderSize);
 c03fc36:	f7ff fdbb 	bl	c03f7b0 <PKA_Memcpy_u8_to_u32>
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ECDSA_VERIF_IN_SIGNATURE_R + ((in->primeOrderSize + 3UL) / 4UL));
 c03fc3a:	682a      	ldr	r2, [r5, #0]

  /* Move the input parameters signature part s to PKA RAM */
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECDSA_VERIF_IN_SIGNATURE_S], in->SSign, in->primeOrderSize);
 c03fc3c:	f604 4068 	addw	r0, r4, #3176	@ 0xc68
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ECDSA_VERIF_IN_SIGNATURE_R + ((in->primeOrderSize + 3UL) / 4UL));
 c03fc40:	1cd3      	adds	r3, r2, #3
 c03fc42:	f023 0303 	bic.w	r3, r3, #3
 c03fc46:	4423      	add	r3, r4
 c03fc48:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 c03fc4c:	f8c3 60e0 	str.w	r6, [r3, #224]	@ 0xe0
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECDSA_VERIF_IN_SIGNATURE_S], in->SSign, in->primeOrderSize);
 c03fc50:	6aa9      	ldr	r1, [r5, #40]	@ 0x28
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ECDSA_VERIF_IN_SIGNATURE_R + ((in->primeOrderSize + 3UL) / 4UL));
 c03fc52:	f8c3 60e4 	str.w	r6, [r3, #228]	@ 0xe4
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECDSA_VERIF_IN_SIGNATURE_S], in->SSign, in->primeOrderSize);
 c03fc56:	f7ff fdab 	bl	c03f7b0 <PKA_Memcpy_u8_to_u32>
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ECDSA_VERIF_IN_SIGNATURE_S + ((in->primeOrderSize + 3UL) / 4UL));
 c03fc5a:	682a      	ldr	r2, [r5, #0]

  /* Move the input parameters hash of message z to PKA RAM */
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECDSA_VERIF_IN_HASH_E], in->hash, in->primeOrderSize);
 c03fc5c:	f504 509d 	add.w	r0, r4, #5024	@ 0x13a0
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ECDSA_VERIF_IN_SIGNATURE_S + ((in->primeOrderSize + 3UL) / 4UL));
 c03fc60:	1cd3      	adds	r3, r2, #3
 c03fc62:	f023 0303 	bic.w	r3, r3, #3
 c03fc66:	4423      	add	r3, r4
 c03fc68:	f8c3 6c68 	str.w	r6, [r3, #3176]	@ 0xc68
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECDSA_VERIF_IN_HASH_E], in->hash, in->primeOrderSize);
 c03fc6c:	6ae9      	ldr	r1, [r5, #44]	@ 0x2c
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ECDSA_VERIF_IN_SIGNATURE_S + ((in->primeOrderSize + 3UL) / 4UL));
 c03fc6e:	f8c3 6c6c 	str.w	r6, [r3, #3180]	@ 0xc6c
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECDSA_VERIF_IN_HASH_E], in->hash, in->primeOrderSize);
 c03fc72:	3008      	adds	r0, #8
 c03fc74:	f7ff fd9c 	bl	c03f7b0 <PKA_Memcpy_u8_to_u32>
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ECDSA_VERIF_IN_HASH_E + ((in->primeOrderSize + 3UL) / 4UL));
 c03fc78:	682a      	ldr	r2, [r5, #0]

  /* Move the input parameters curve prime order n to PKA RAM */
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECDSA_VERIF_IN_ORDER_N], in->primeOrder, in->primeOrderSize);
 c03fc7a:	f504 5084 	add.w	r0, r4, #4224	@ 0x1080
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ECDSA_VERIF_IN_HASH_E + ((in->primeOrderSize + 3UL) / 4UL));
 c03fc7e:	1cd3      	adds	r3, r2, #3
 c03fc80:	f023 0303 	bic.w	r3, r3, #3
 c03fc84:	4423      	add	r3, r4
 c03fc86:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 c03fc8a:	f8c3 63a8 	str.w	r6, [r3, #936]	@ 0x3a8
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECDSA_VERIF_IN_ORDER_N], in->primeOrder, in->primeOrderSize);
 c03fc8e:	4639      	mov	r1, r7
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ECDSA_VERIF_IN_HASH_E + ((in->primeOrderSize + 3UL) / 4UL));
 c03fc90:	f8c3 63ac 	str.w	r6, [r3, #940]	@ 0x3ac
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECDSA_VERIF_IN_ORDER_N], in->primeOrder, in->primeOrderSize);
 c03fc94:	3008      	adds	r0, #8
 c03fc96:	f7ff fd8b 	bl	c03f7b0 <PKA_Memcpy_u8_to_u32>
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ECDSA_VERIF_IN_ORDER_N + ((in->primeOrderSize + 3UL) / 4UL));
 c03fc9a:	682b      	ldr	r3, [r5, #0]
 c03fc9c:	3303      	adds	r3, #3
 c03fc9e:	f023 0303 	bic.w	r3, r3, #3
 c03fca2:	441c      	add	r4, r3
 c03fca4:	f504 5480 	add.w	r4, r4, #4096	@ 0x1000
 c03fca8:	f8c4 6088 	str.w	r6, [r4, #136]	@ 0x88
 c03fcac:	f8c4 608c 	str.w	r6, [r4, #140]	@ 0x8c
}
 c03fcb0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0c03fcb4 <HAL_PKA_ECDSAVerif>:
{
 c03fcb4:	b538      	push	{r3, r4, r5, lr}
 c03fcb6:	4604      	mov	r4, r0
 c03fcb8:	4615      	mov	r5, r2
  PKA_ECDSAVerif_Set(hpka, in);
 c03fcba:	f7ff ff45 	bl	c03fb48 <PKA_ECDSAVerif_Set>
  return PKA_Process(hpka, PKA_MODE_ECDSA_VERIFICATION, Timeout);
 c03fcbe:	462a      	mov	r2, r5
 c03fcc0:	4620      	mov	r0, r4
}
 c03fcc2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  return PKA_Process(hpka, PKA_MODE_ECDSA_VERIFICATION, Timeout);
 c03fcc6:	2126      	movs	r1, #38	@ 0x26
 c03fcc8:	f7ff bdf9 	b.w	c03f8be <PKA_Process>

0c03fccc <PKA_RSACRTExp_Set>:
  * @brief  Set input parameters.
  * @param  hpka PKA handle
  * @param  in Input information
  */
void PKA_RSACRTExp_Set(PKA_HandleTypeDef *hpka, PKA_RSACRTExpInTypeDef *in)
{
 c03fccc:	b570      	push	{r4, r5, r6, lr}
 c03fcce:	460d      	mov	r5, r1
  /* Get the operand length M */
  hpka->Instance->RAM[PKA_RSA_CRT_EXP_IN_MOD_NB_BITS] = PKA_GetBitSize_u8(in->size);

  /* Move the input parameters operand dP to PKA RAM */
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_RSA_CRT_EXP_IN_DP_CRT], in->pOpDp, in->size / 2UL);
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_RSA_CRT_EXP_IN_DP_CRT + (in->size / 8UL));
 c03fcd0:	2600      	movs	r6, #0
  hpka->Instance->RAM[PKA_RSA_CRT_EXP_IN_MOD_NB_BITS] = PKA_GetBitSize_u8(in->size);
 c03fcd2:	680a      	ldr	r2, [r1, #0]
 c03fcd4:	6804      	ldr	r4, [r0, #0]
  return byteNumber * 8UL;
 c03fcd6:	00d3      	lsls	r3, r2, #3
  hpka->Instance->RAM[PKA_RSA_CRT_EXP_IN_MOD_NB_BITS] = PKA_GetBitSize_u8(in->size);
 c03fcd8:	f8c4 3408 	str.w	r3, [r4, #1032]	@ 0x408
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_RSA_CRT_EXP_IN_DP_CRT], in->pOpDp, in->size / 2UL);
 c03fcdc:	f504 60e6 	add.w	r0, r4, #1840	@ 0x730
 c03fce0:	6849      	ldr	r1, [r1, #4]
 c03fce2:	0852      	lsrs	r2, r2, #1
 c03fce4:	f7ff fd64 	bl	c03f7b0 <PKA_Memcpy_u8_to_u32>
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_RSA_CRT_EXP_IN_DP_CRT + (in->size / 8UL));
 c03fce8:	682a      	ldr	r2, [r5, #0]

  /* Move the input parameters operand dQ to PKA RAM */
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_RSA_CRT_EXP_IN_DQ_CRT], in->pOpDq, in->size / 2UL);
 c03fcea:	f604 6078 	addw	r0, r4, #3704	@ 0xe78
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_RSA_CRT_EXP_IN_DP_CRT + (in->size / 8UL));
 c03fcee:	08d3      	lsrs	r3, r2, #3
 c03fcf0:	eb04 0383 	add.w	r3, r4, r3, lsl #2
 c03fcf4:	f8c3 6730 	str.w	r6, [r3, #1840]	@ 0x730
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_RSA_CRT_EXP_IN_DQ_CRT], in->pOpDq, in->size / 2UL);
 c03fcf8:	68a9      	ldr	r1, [r5, #8]
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_RSA_CRT_EXP_IN_DP_CRT + (in->size / 8UL));
 c03fcfa:	f8c3 6734 	str.w	r6, [r3, #1844]	@ 0x734
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_RSA_CRT_EXP_IN_DQ_CRT], in->pOpDq, in->size / 2UL);
 c03fcfe:	0852      	lsrs	r2, r2, #1
 c03fd00:	f7ff fd56 	bl	c03f7b0 <PKA_Memcpy_u8_to_u32>
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_RSA_CRT_EXP_IN_DQ_CRT + (in->size / 8UL));
 c03fd04:	682a      	ldr	r2, [r5, #0]

  /* Move the input parameters operand qinv to PKA RAM */
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_RSA_CRT_EXP_IN_QINV_CRT], in->pOpQinv, in->size / 2UL);
 c03fd06:	f604 1048 	addw	r0, r4, #2376	@ 0x948
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_RSA_CRT_EXP_IN_DQ_CRT + (in->size / 8UL));
 c03fd0a:	08d3      	lsrs	r3, r2, #3
 c03fd0c:	eb04 0383 	add.w	r3, r4, r3, lsl #2
 c03fd10:	f8c3 6e78 	str.w	r6, [r3, #3704]	@ 0xe78
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_RSA_CRT_EXP_IN_QINV_CRT], in->pOpQinv, in->size / 2UL);
 c03fd14:	68e9      	ldr	r1, [r5, #12]
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_RSA_CRT_EXP_IN_DQ_CRT + (in->size / 8UL));
 c03fd16:	f8c3 6e7c 	str.w	r6, [r3, #3708]	@ 0xe7c
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_RSA_CRT_EXP_IN_QINV_CRT], in->pOpQinv, in->size / 2UL);
 c03fd1a:	0852      	lsrs	r2, r2, #1
 c03fd1c:	f7ff fd48 	bl	c03f7b0 <PKA_Memcpy_u8_to_u32>
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_RSA_CRT_EXP_IN_QINV_CRT + (in->size / 8UL));
 c03fd20:	682a      	ldr	r2, [r5, #0]

  /* Move the input parameters prime p to PKA RAM */
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_RSA_CRT_EXP_IN_PRIME_P], in->pPrimeP, in->size / 2UL);
 c03fd22:	f504 6036 	add.w	r0, r4, #2912	@ 0xb60
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_RSA_CRT_EXP_IN_QINV_CRT + (in->size / 8UL));
 c03fd26:	08d3      	lsrs	r3, r2, #3
 c03fd28:	eb04 0383 	add.w	r3, r4, r3, lsl #2
 c03fd2c:	f8c3 6948 	str.w	r6, [r3, #2376]	@ 0x948
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_RSA_CRT_EXP_IN_PRIME_P], in->pPrimeP, in->size / 2UL);
 c03fd30:	6929      	ldr	r1, [r5, #16]
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_RSA_CRT_EXP_IN_QINV_CRT + (in->size / 8UL));
 c03fd32:	f8c3 694c 	str.w	r6, [r3, #2380]	@ 0x94c
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_RSA_CRT_EXP_IN_PRIME_P], in->pPrimeP, in->size / 2UL);
 c03fd36:	0852      	lsrs	r2, r2, #1
 c03fd38:	f7ff fd3a 	bl	c03f7b0 <PKA_Memcpy_u8_to_u32>
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_RSA_CRT_EXP_IN_PRIME_P + (in->size / 8UL));
 c03fd3c:	682a      	ldr	r2, [r5, #0]

  /* Move the input parameters prime q to PKA RAM */
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_RSA_CRT_EXP_IN_PRIME_Q], in->pPrimeQ, in->size / 2UL);
 c03fd3e:	f504 5084 	add.w	r0, r4, #4224	@ 0x1080
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_RSA_CRT_EXP_IN_PRIME_P + (in->size / 8UL));
 c03fd42:	08d3      	lsrs	r3, r2, #3
 c03fd44:	eb04 0383 	add.w	r3, r4, r3, lsl #2
 c03fd48:	f8c3 6b60 	str.w	r6, [r3, #2912]	@ 0xb60
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_RSA_CRT_EXP_IN_PRIME_Q], in->pPrimeQ, in->size / 2UL);
 c03fd4c:	6969      	ldr	r1, [r5, #20]
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_RSA_CRT_EXP_IN_PRIME_P + (in->size / 8UL));
 c03fd4e:	f8c3 6b64 	str.w	r6, [r3, #2916]	@ 0xb64
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_RSA_CRT_EXP_IN_PRIME_Q], in->pPrimeQ, in->size / 2UL);
 c03fd52:	0852      	lsrs	r2, r2, #1
 c03fd54:	3008      	adds	r0, #8
 c03fd56:	f7ff fd2b 	bl	c03f7b0 <PKA_Memcpy_u8_to_u32>
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_RSA_CRT_EXP_IN_PRIME_Q + (in->size / 8UL));
 c03fd5a:	682a      	ldr	r2, [r5, #0]

  /* Move the input parameters operand A to PKA RAM */
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_RSA_CRT_EXP_IN_EXPONENT_BASE], in->popA, in->size);
 c03fd5c:	f504 5095 	add.w	r0, r4, #4768	@ 0x12a0
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_RSA_CRT_EXP_IN_PRIME_Q + (in->size / 8UL));
 c03fd60:	08d3      	lsrs	r3, r2, #3
 c03fd62:	eb04 0383 	add.w	r3, r4, r3, lsl #2
 c03fd66:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 c03fd6a:	f8c3 6088 	str.w	r6, [r3, #136]	@ 0x88
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_RSA_CRT_EXP_IN_EXPONENT_BASE], in->popA, in->size);
 c03fd6e:	69a9      	ldr	r1, [r5, #24]
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_RSA_CRT_EXP_IN_PRIME_Q + (in->size / 8UL));
 c03fd70:	f8c3 608c 	str.w	r6, [r3, #140]	@ 0x8c
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_RSA_CRT_EXP_IN_EXPONENT_BASE], in->popA, in->size);
 c03fd74:	f7ff fd1c 	bl	c03f7b0 <PKA_Memcpy_u8_to_u32>
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_RSA_CRT_EXP_IN_EXPONENT_BASE + (in->size / 4UL));
 c03fd78:	682b      	ldr	r3, [r5, #0]
 c03fd7a:	f023 0303 	bic.w	r3, r3, #3
 c03fd7e:	441c      	add	r4, r3
 c03fd80:	f504 5480 	add.w	r4, r4, #4096	@ 0x1000
 c03fd84:	f8c4 62a0 	str.w	r6, [r4, #672]	@ 0x2a0
 c03fd88:	f8c4 62a4 	str.w	r6, [r4, #676]	@ 0x2a4
}
 c03fd8c:	bd70      	pop	{r4, r5, r6, pc}

0c03fd8e <HAL_PKA_RSACRTExp>:
{
 c03fd8e:	b538      	push	{r3, r4, r5, lr}
 c03fd90:	4604      	mov	r4, r0
 c03fd92:	4615      	mov	r5, r2
  PKA_RSACRTExp_Set(hpka, in);
 c03fd94:	f7ff ff9a 	bl	c03fccc <PKA_RSACRTExp_Set>
  return PKA_Process(hpka, PKA_MODE_RSA_CRT_EXP, Timeout);
 c03fd98:	462a      	mov	r2, r5
 c03fd9a:	4620      	mov	r0, r4
}
 c03fd9c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  return PKA_Process(hpka, PKA_MODE_RSA_CRT_EXP, Timeout);
 c03fda0:	2107      	movs	r1, #7
 c03fda2:	f7ff bd8c 	b.w	c03f8be <PKA_Process>

0c03fda6 <PKA_PointCheck_Set>:
  * @brief  Set input parameters.
  * @param  hpka PKA handle
  * @param  in Input information
  */
void PKA_PointCheck_Set(PKA_HandleTypeDef *hpka, PKA_PointCheckInTypeDef *in)
{
 c03fda6:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  /* Get the modulus length */
  hpka->Instance->RAM[PKA_POINT_CHECK_IN_MOD_NB_BITS] = PKA_GetOptBitSize_u8(in->modulusSize, *(in->modulus));
 c03fda8:	680a      	ldr	r2, [r1, #0]
 c03fdaa:	690f      	ldr	r7, [r1, #16]
{
 c03fdac:	460d      	mov	r5, r1
  hpka->Instance->RAM[PKA_POINT_CHECK_IN_MOD_NB_BITS] = PKA_GetOptBitSize_u8(in->modulusSize, *(in->modulus));
 c03fdae:	6804      	ldr	r4, [r0, #0]
 c03fdb0:	7839      	ldrb	r1, [r7, #0]
 c03fdb2:	4610      	mov	r0, r2
 c03fdb4:	f7ff fc5d 	bl	c03f672 <PKA_GetOptBitSize_u8>
  /* Get the coefficient a sign */
  hpka->Instance->RAM[PKA_POINT_CHECK_IN_A_COEFF_SIGN] = in->coefSign;

  /* Move the input parameters coefficient |a| to PKA RAM */
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_POINT_CHECK_IN_A_COEFF], in->coefA, in->modulusSize);
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_POINT_CHECK_IN_A_COEFF + ((in->modulusSize + 3UL) / 4UL));
 c03fdb8:	2600      	movs	r6, #0
  hpka->Instance->RAM[PKA_POINT_CHECK_IN_A_COEFF_SIGN] = in->coefSign;
 c03fdba:	686b      	ldr	r3, [r5, #4]
  hpka->Instance->RAM[PKA_POINT_CHECK_IN_MOD_NB_BITS] = PKA_GetOptBitSize_u8(in->modulusSize, *(in->modulus));
 c03fdbc:	f8c4 0408 	str.w	r0, [r4, #1032]	@ 0x408
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_POINT_CHECK_IN_A_COEFF], in->coefA, in->modulusSize);
 c03fdc0:	68a9      	ldr	r1, [r5, #8]
  hpka->Instance->RAM[PKA_POINT_CHECK_IN_A_COEFF_SIGN] = in->coefSign;
 c03fdc2:	f8c4 3410 	str.w	r3, [r4, #1040]	@ 0x410
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_POINT_CHECK_IN_A_COEFF], in->coefA, in->modulusSize);
 c03fdc6:	f504 6083 	add.w	r0, r4, #1048	@ 0x418
 c03fdca:	f7ff fcf1 	bl	c03f7b0 <PKA_Memcpy_u8_to_u32>
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_POINT_CHECK_IN_A_COEFF + ((in->modulusSize + 3UL) / 4UL));
 c03fdce:	682a      	ldr	r2, [r5, #0]

  /* Move the input parameters coefficient b to PKA RAM */
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_POINT_CHECK_IN_B_COEFF], in->coefB, in->modulusSize);
 c03fdd0:	f504 60a4 	add.w	r0, r4, #1312	@ 0x520
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_POINT_CHECK_IN_A_COEFF + ((in->modulusSize + 3UL) / 4UL));
 c03fdd4:	1cd3      	adds	r3, r2, #3
 c03fdd6:	f023 0303 	bic.w	r3, r3, #3
 c03fdda:	4423      	add	r3, r4
 c03fddc:	f8c3 6418 	str.w	r6, [r3, #1048]	@ 0x418
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_POINT_CHECK_IN_B_COEFF], in->coefB, in->modulusSize);
 c03fde0:	68e9      	ldr	r1, [r5, #12]
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_POINT_CHECK_IN_A_COEFF + ((in->modulusSize + 3UL) / 4UL));
 c03fde2:	f8c3 641c 	str.w	r6, [r3, #1052]	@ 0x41c
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_POINT_CHECK_IN_B_COEFF], in->coefB, in->modulusSize);
 c03fde6:	f7ff fce3 	bl	c03f7b0 <PKA_Memcpy_u8_to_u32>
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_POINT_CHECK_IN_B_COEFF + ((in->modulusSize + 3UL) / 4UL));
 c03fdea:	682a      	ldr	r2, [r5, #0]

  /* Move the input parameters modulus value p to PKA RAM */
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_POINT_CHECK_IN_MOD_GF], in->modulus, in->modulusSize);
 c03fdec:	f504 608e 	add.w	r0, r4, #1136	@ 0x470
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_POINT_CHECK_IN_B_COEFF + ((in->modulusSize + 3UL) / 4UL));
 c03fdf0:	1cd3      	adds	r3, r2, #3
 c03fdf2:	f023 0303 	bic.w	r3, r3, #3
 c03fdf6:	4423      	add	r3, r4
 c03fdf8:	f8c3 6520 	str.w	r6, [r3, #1312]	@ 0x520
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_POINT_CHECK_IN_MOD_GF], in->modulus, in->modulusSize);
 c03fdfc:	4639      	mov	r1, r7
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_POINT_CHECK_IN_B_COEFF + ((in->modulusSize + 3UL) / 4UL));
 c03fdfe:	f8c3 6524 	str.w	r6, [r3, #1316]	@ 0x524
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_POINT_CHECK_IN_MOD_GF], in->modulus, in->modulusSize);
 c03fe02:	f7ff fcd5 	bl	c03f7b0 <PKA_Memcpy_u8_to_u32>
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_POINT_CHECK_IN_MOD_GF + ((in->modulusSize + 3UL) / 4UL));
 c03fe06:	682a      	ldr	r2, [r5, #0]

  /* Move the input parameters Point P coordinate x to PKA RAM */
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_POINT_CHECK_IN_INITIAL_POINT_X], in->pointX, in->modulusSize);
 c03fe08:	f504 60af 	add.w	r0, r4, #1400	@ 0x578
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_POINT_CHECK_IN_MOD_GF + ((in->modulusSize + 3UL) / 4UL));
 c03fe0c:	1cd3      	adds	r3, r2, #3
 c03fe0e:	f023 0303 	bic.w	r3, r3, #3
 c03fe12:	4423      	add	r3, r4
 c03fe14:	f8c3 6470 	str.w	r6, [r3, #1136]	@ 0x470
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_POINT_CHECK_IN_INITIAL_POINT_X], in->pointX, in->modulusSize);
 c03fe18:	6969      	ldr	r1, [r5, #20]
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_POINT_CHECK_IN_MOD_GF + ((in->modulusSize + 3UL) / 4UL));
 c03fe1a:	f8c3 6474 	str.w	r6, [r3, #1140]	@ 0x474
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_POINT_CHECK_IN_INITIAL_POINT_X], in->pointX, in->modulusSize);
 c03fe1e:	f7ff fcc7 	bl	c03f7b0 <PKA_Memcpy_u8_to_u32>
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_POINT_CHECK_IN_INITIAL_POINT_X + ((in->modulusSize + 3UL) / 4UL));
 c03fe22:	682a      	ldr	r2, [r5, #0]

  /* Move the input parameters Point P coordinate y to PKA RAM */
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_POINT_CHECK_IN_INITIAL_POINT_Y], in->pointY, in->modulusSize);
 c03fe24:	f504 60ba 	add.w	r0, r4, #1488	@ 0x5d0
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_POINT_CHECK_IN_INITIAL_POINT_X + ((in->modulusSize + 3UL) / 4UL));
 c03fe28:	1cd3      	adds	r3, r2, #3
 c03fe2a:	f023 0303 	bic.w	r3, r3, #3
 c03fe2e:	4423      	add	r3, r4
 c03fe30:	f8c3 6578 	str.w	r6, [r3, #1400]	@ 0x578
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_POINT_CHECK_IN_INITIAL_POINT_Y], in->pointY, in->modulusSize);
 c03fe34:	69a9      	ldr	r1, [r5, #24]
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_POINT_CHECK_IN_INITIAL_POINT_X + ((in->modulusSize + 3UL) / 4UL));
 c03fe36:	f8c3 657c 	str.w	r6, [r3, #1404]	@ 0x57c
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_POINT_CHECK_IN_INITIAL_POINT_Y], in->pointY, in->modulusSize);
 c03fe3a:	f7ff fcb9 	bl	c03f7b0 <PKA_Memcpy_u8_to_u32>
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_POINT_CHECK_IN_INITIAL_POINT_Y + ((in->modulusSize + 3UL) / 4UL));
 c03fe3e:	682a      	ldr	r2, [r5, #0]

  /* Move the input parameters montgomery param R2 modulus N to PKA RAM */
  PKA_Memcpy_u32_to_u32(&hpka->Instance->RAM[PKA_POINT_CHECK_IN_MONTGOMERY_PARAM], in->pMontgomeryParam,
 c03fe40:	f504 6099 	add.w	r0, r4, #1224	@ 0x4c8
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_POINT_CHECK_IN_INITIAL_POINT_Y + ((in->modulusSize + 3UL) / 4UL));
 c03fe44:	1cd3      	adds	r3, r2, #3
 c03fe46:	f023 0303 	bic.w	r3, r3, #3
 c03fe4a:	4423      	add	r3, r4
 c03fe4c:	f8c3 65d0 	str.w	r6, [r3, #1488]	@ 0x5d0
  PKA_Memcpy_u32_to_u32(&hpka->Instance->RAM[PKA_POINT_CHECK_IN_MONTGOMERY_PARAM], in->pMontgomeryParam,
 c03fe50:	69e9      	ldr	r1, [r5, #28]
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_POINT_CHECK_IN_INITIAL_POINT_Y + ((in->modulusSize + 3UL) / 4UL));
 c03fe52:	f8c3 65d4 	str.w	r6, [r3, #1492]	@ 0x5d4
  PKA_Memcpy_u32_to_u32(&hpka->Instance->RAM[PKA_POINT_CHECK_IN_MONTGOMERY_PARAM], in->pMontgomeryParam,
 c03fe56:	0892      	lsrs	r2, r2, #2
 c03fe58:	f7ff fcec 	bl	c03f834 <PKA_Memcpy_u32_to_u32>
                        (in->modulusSize / 4UL));
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_POINT_CHECK_IN_MONTGOMERY_PARAM + ((in->modulusSize + 3UL) / 4UL));
 c03fe5c:	682b      	ldr	r3, [r5, #0]
 c03fe5e:	3303      	adds	r3, #3
 c03fe60:	f023 0303 	bic.w	r3, r3, #3
 c03fe64:	441c      	add	r4, r3
 c03fe66:	f8c4 64c8 	str.w	r6, [r4, #1224]	@ 0x4c8
 c03fe6a:	f8c4 64cc 	str.w	r6, [r4, #1228]	@ 0x4cc
}
 c03fe6e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0c03fe70 <HAL_PKA_PointCheck>:
{
 c03fe70:	b538      	push	{r3, r4, r5, lr}
 c03fe72:	4604      	mov	r4, r0
 c03fe74:	4615      	mov	r5, r2
  PKA_PointCheck_Set(hpka, in);
 c03fe76:	f7ff ff96 	bl	c03fda6 <PKA_PointCheck_Set>
  return PKA_Process(hpka, PKA_MODE_POINT_CHECK, Timeout);
 c03fe7a:	462a      	mov	r2, r5
 c03fe7c:	4620      	mov	r0, r4
}
 c03fe7e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  return PKA_Process(hpka, PKA_MODE_POINT_CHECK, Timeout);
 c03fe82:	2128      	movs	r1, #40	@ 0x28
 c03fe84:	f7ff bd1b 	b.w	c03f8be <PKA_Process>

0c03fe88 <PKA_ECCMul_Set>:
  * @brief  Set input parameters.
  * @param  hpka PKA handle
  * @param  in Input information
  */
void PKA_ECCMul_Set(PKA_HandleTypeDef *hpka, PKA_ECCMulInTypeDef *in)
{
 c03fe88:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 c03fe8c:	460c      	mov	r4, r1
  /* Get the prime order n length */
  hpka->Instance->RAM[PKA_ECC_SCALAR_MUL_IN_EXP_NB_BITS] = PKA_GetOptBitSize_u8(in->scalarMulSize, *(in->primeOrder));
 c03fe8e:	6a4f      	ldr	r7, [r1, #36]	@ 0x24
 c03fe90:	6805      	ldr	r5, [r0, #0]
 c03fe92:	7839      	ldrb	r1, [r7, #0]
 c03fe94:	6820      	ldr	r0, [r4, #0]
 c03fe96:	f7ff fbec 	bl	c03f672 <PKA_GetOptBitSize_u8>

  /* Get the modulus length */
  hpka->Instance->RAM[PKA_ECC_SCALAR_MUL_IN_OP_NB_BITS] = PKA_GetOptBitSize_u8(in->modulusSize, *(in->modulus));
 c03fe9a:	6862      	ldr	r2, [r4, #4]
 c03fe9c:	f8d4 8014 	ldr.w	r8, [r4, #20]
  hpka->Instance->RAM[PKA_ECC_SCALAR_MUL_IN_EXP_NB_BITS] = PKA_GetOptBitSize_u8(in->scalarMulSize, *(in->primeOrder));
 c03fea0:	f8c5 0400 	str.w	r0, [r5, #1024]	@ 0x400
  hpka->Instance->RAM[PKA_ECC_SCALAR_MUL_IN_OP_NB_BITS] = PKA_GetOptBitSize_u8(in->modulusSize, *(in->modulus));
 c03fea4:	f898 1000 	ldrb.w	r1, [r8]
 c03fea8:	4610      	mov	r0, r2
 c03feaa:	f7ff fbe2 	bl	c03f672 <PKA_GetOptBitSize_u8>
  /* Get the coefficient a sign */
  hpka->Instance->RAM[PKA_ECC_SCALAR_MUL_IN_A_COEFF_SIGN] = in->coefSign;

  /* Move the input parameters coefficient |a| to PKA RAM */
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECC_SCALAR_MUL_IN_A_COEFF], in->coefA, in->modulusSize);
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ECC_SCALAR_MUL_IN_A_COEFF + ((in->modulusSize + 3UL) / 4UL));
 c03feae:	2600      	movs	r6, #0
  hpka->Instance->RAM[PKA_ECC_SCALAR_MUL_IN_A_COEFF_SIGN] = in->coefSign;
 c03feb0:	68a3      	ldr	r3, [r4, #8]
  hpka->Instance->RAM[PKA_ECC_SCALAR_MUL_IN_OP_NB_BITS] = PKA_GetOptBitSize_u8(in->modulusSize, *(in->modulus));
 c03feb2:	f8c5 0408 	str.w	r0, [r5, #1032]	@ 0x408
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECC_SCALAR_MUL_IN_A_COEFF], in->coefA, in->modulusSize);
 c03feb6:	68e1      	ldr	r1, [r4, #12]
  hpka->Instance->RAM[PKA_ECC_SCALAR_MUL_IN_A_COEFF_SIGN] = in->coefSign;
 c03feb8:	f8c5 3410 	str.w	r3, [r5, #1040]	@ 0x410
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECC_SCALAR_MUL_IN_A_COEFF], in->coefA, in->modulusSize);
 c03febc:	f505 6083 	add.w	r0, r5, #1048	@ 0x418
 c03fec0:	f7ff fc76 	bl	c03f7b0 <PKA_Memcpy_u8_to_u32>
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ECC_SCALAR_MUL_IN_A_COEFF + ((in->modulusSize + 3UL) / 4UL));
 c03fec4:	6862      	ldr	r2, [r4, #4]

  /* Move the input parameters coefficient b to PKA RAM */
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECC_SCALAR_MUL_IN_B_COEFF], in->coefB, in->modulusSize);
 c03fec6:	f505 60a4 	add.w	r0, r5, #1312	@ 0x520
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ECC_SCALAR_MUL_IN_A_COEFF + ((in->modulusSize + 3UL) / 4UL));
 c03feca:	1cd3      	adds	r3, r2, #3
 c03fecc:	f023 0303 	bic.w	r3, r3, #3
 c03fed0:	442b      	add	r3, r5
 c03fed2:	f8c3 6418 	str.w	r6, [r3, #1048]	@ 0x418
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECC_SCALAR_MUL_IN_B_COEFF], in->coefB, in->modulusSize);
 c03fed6:	6921      	ldr	r1, [r4, #16]
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ECC_SCALAR_MUL_IN_A_COEFF + ((in->modulusSize + 3UL) / 4UL));
 c03fed8:	f8c3 641c 	str.w	r6, [r3, #1052]	@ 0x41c
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECC_SCALAR_MUL_IN_B_COEFF], in->coefB, in->modulusSize);
 c03fedc:	f7ff fc68 	bl	c03f7b0 <PKA_Memcpy_u8_to_u32>
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ECC_SCALAR_MUL_IN_B_COEFF + ((in->modulusSize + 3UL) / 4UL));
 c03fee0:	6862      	ldr	r2, [r4, #4]

  /* Move the input parameters modulus value p to PKA RAM */
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECC_SCALAR_MUL_IN_MOD_GF], in->modulus, in->modulusSize);
 c03fee2:	f505 5084 	add.w	r0, r5, #4224	@ 0x1080
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ECC_SCALAR_MUL_IN_B_COEFF + ((in->modulusSize + 3UL) / 4UL));
 c03fee6:	1cd3      	adds	r3, r2, #3
 c03fee8:	f023 0303 	bic.w	r3, r3, #3
 c03feec:	442b      	add	r3, r5
 c03feee:	f8c3 6520 	str.w	r6, [r3, #1312]	@ 0x520
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECC_SCALAR_MUL_IN_MOD_GF], in->modulus, in->modulusSize);
 c03fef2:	4641      	mov	r1, r8
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ECC_SCALAR_MUL_IN_B_COEFF + ((in->modulusSize + 3UL) / 4UL));
 c03fef4:	f8c3 6524 	str.w	r6, [r3, #1316]	@ 0x524
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECC_SCALAR_MUL_IN_MOD_GF], in->modulus, in->modulusSize);
 c03fef8:	3008      	adds	r0, #8
 c03fefa:	f7ff fc59 	bl	c03f7b0 <PKA_Memcpy_u8_to_u32>
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ECC_SCALAR_MUL_IN_MOD_GF + ((in->modulusSize + 3UL) / 4UL));
 c03fefe:	6863      	ldr	r3, [r4, #4]

  /* Move the input parameters scalar multiplier k to PKA RAM */
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECC_SCALAR_MUL_IN_K], in->scalarMul, in->scalarMulSize);
 c03ff00:	f505 5095 	add.w	r0, r5, #4768	@ 0x12a0
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ECC_SCALAR_MUL_IN_MOD_GF + ((in->modulusSize + 3UL) / 4UL));
 c03ff04:	3303      	adds	r3, #3
 c03ff06:	f023 0303 	bic.w	r3, r3, #3
 c03ff0a:	442b      	add	r3, r5
 c03ff0c:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 c03ff10:	f8c3 6088 	str.w	r6, [r3, #136]	@ 0x88
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECC_SCALAR_MUL_IN_K], in->scalarMul, in->scalarMulSize);
 c03ff14:	6822      	ldr	r2, [r4, #0]
 c03ff16:	6a21      	ldr	r1, [r4, #32]
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ECC_SCALAR_MUL_IN_MOD_GF + ((in->modulusSize + 3UL) / 4UL));
 c03ff18:	f8c3 608c 	str.w	r6, [r3, #140]	@ 0x8c
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECC_SCALAR_MUL_IN_K], in->scalarMul, in->scalarMulSize);
 c03ff1c:	f7ff fc48 	bl	c03f7b0 <PKA_Memcpy_u8_to_u32>
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ECC_SCALAR_MUL_IN_K + ((in->scalarMulSize + 3UL) / 4UL));
 c03ff20:	6823      	ldr	r3, [r4, #0]

  /* Move the input parameters Point P coordinate x to PKA RAM */
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECC_SCALAR_MUL_IN_INITIAL_POINT_X], in->pointX, in->modulusSize);
 c03ff22:	f505 60af 	add.w	r0, r5, #1400	@ 0x578
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ECC_SCALAR_MUL_IN_K + ((in->scalarMulSize + 3UL) / 4UL));
 c03ff26:	3303      	adds	r3, #3
 c03ff28:	f023 0303 	bic.w	r3, r3, #3
 c03ff2c:	442b      	add	r3, r5
 c03ff2e:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 c03ff32:	f8c3 62a0 	str.w	r6, [r3, #672]	@ 0x2a0
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECC_SCALAR_MUL_IN_INITIAL_POINT_X], in->pointX, in->modulusSize);
 c03ff36:	6862      	ldr	r2, [r4, #4]
 c03ff38:	69a1      	ldr	r1, [r4, #24]
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ECC_SCALAR_MUL_IN_K + ((in->scalarMulSize + 3UL) / 4UL));
 c03ff3a:	f8c3 62a4 	str.w	r6, [r3, #676]	@ 0x2a4
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECC_SCALAR_MUL_IN_INITIAL_POINT_X], in->pointX, in->modulusSize);
 c03ff3e:	f7ff fc37 	bl	c03f7b0 <PKA_Memcpy_u8_to_u32>
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ECC_SCALAR_MUL_IN_INITIAL_POINT_X + ((in->modulusSize + 3UL) / 4UL));
 c03ff42:	6862      	ldr	r2, [r4, #4]

  /* Move the input parameters Point P coordinate y to PKA RAM */
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECC_SCALAR_MUL_IN_INITIAL_POINT_Y], in->pointY, in->modulusSize);
 c03ff44:	f505 608e 	add.w	r0, r5, #1136	@ 0x470
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ECC_SCALAR_MUL_IN_INITIAL_POINT_X + ((in->modulusSize + 3UL) / 4UL));
 c03ff48:	1cd3      	adds	r3, r2, #3
 c03ff4a:	f023 0303 	bic.w	r3, r3, #3
 c03ff4e:	442b      	add	r3, r5
 c03ff50:	f8c3 6578 	str.w	r6, [r3, #1400]	@ 0x578
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECC_SCALAR_MUL_IN_INITIAL_POINT_Y], in->pointY, in->modulusSize);
 c03ff54:	69e1      	ldr	r1, [r4, #28]
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ECC_SCALAR_MUL_IN_INITIAL_POINT_X + ((in->modulusSize + 3UL) / 4UL));
 c03ff56:	f8c3 657c 	str.w	r6, [r3, #1404]	@ 0x57c
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECC_SCALAR_MUL_IN_INITIAL_POINT_Y], in->pointY, in->modulusSize);
 c03ff5a:	f7ff fc29 	bl	c03f7b0 <PKA_Memcpy_u8_to_u32>
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ECC_SCALAR_MUL_IN_INITIAL_POINT_Y + ((in->modulusSize + 3UL) / 4UL));
 c03ff5e:	6862      	ldr	r2, [r4, #4]

  /* Move the input parameters curve prime order N to PKA RAM */
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECC_SCALAR_MUL_IN_N_PRIME_ORDER], in->primeOrder, in->modulusSize);
 c03ff60:	f605 7088 	addw	r0, r5, #3976	@ 0xf88
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ECC_SCALAR_MUL_IN_INITIAL_POINT_Y + ((in->modulusSize + 3UL) / 4UL));
 c03ff64:	1cd3      	adds	r3, r2, #3
 c03ff66:	f023 0303 	bic.w	r3, r3, #3
 c03ff6a:	442b      	add	r3, r5
 c03ff6c:	f8c3 6470 	str.w	r6, [r3, #1136]	@ 0x470
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECC_SCALAR_MUL_IN_N_PRIME_ORDER], in->primeOrder, in->modulusSize);
 c03ff70:	4639      	mov	r1, r7
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ECC_SCALAR_MUL_IN_INITIAL_POINT_Y + ((in->modulusSize + 3UL) / 4UL));
 c03ff72:	f8c3 6474 	str.w	r6, [r3, #1140]	@ 0x474
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ECC_SCALAR_MUL_IN_N_PRIME_ORDER], in->primeOrder, in->modulusSize);
 c03ff76:	f7ff fc1b 	bl	c03f7b0 <PKA_Memcpy_u8_to_u32>
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ECC_SCALAR_MUL_IN_N_PRIME_ORDER + ((in->modulusSize + 3UL) / 4UL));
 c03ff7a:	6863      	ldr	r3, [r4, #4]
 c03ff7c:	3303      	adds	r3, #3
 c03ff7e:	f023 0303 	bic.w	r3, r3, #3
 c03ff82:	441d      	add	r5, r3
 c03ff84:	f8c5 6f88 	str.w	r6, [r5, #3976]	@ 0xf88
 c03ff88:	f8c5 6f8c 	str.w	r6, [r5, #3980]	@ 0xf8c
}
 c03ff8c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0c03ff90 <HAL_PKA_ECCMul>:
{
 c03ff90:	b570      	push	{r4, r5, r6, lr}
 c03ff92:	460e      	mov	r6, r1
 c03ff94:	4615      	mov	r5, r2
 c03ff96:	4604      	mov	r4, r0
  PKA_ECCMul_Set(hpka, in);
 c03ff98:	f7ff ff76 	bl	c03fe88 <PKA_ECCMul_Set>
  modulussize = in->modulusSize;
 c03ff9c:	6872      	ldr	r2, [r6, #4]
 c03ff9e:	4b04      	ldr	r3, [pc, #16]	@ (c03ffb0 <HAL_PKA_ECCMul+0x20>)
  return PKA_Process(hpka, PKA_MODE_ECC_MUL, Timeout);
 c03ffa0:	4620      	mov	r0, r4
  modulussize = in->modulusSize;
 c03ffa2:	601a      	str	r2, [r3, #0]
  return PKA_Process(hpka, PKA_MODE_ECC_MUL, Timeout);
 c03ffa4:	2120      	movs	r1, #32
 c03ffa6:	462a      	mov	r2, r5
}
 c03ffa8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  return PKA_Process(hpka, PKA_MODE_ECC_MUL, Timeout);
 c03ffac:	f7ff bc87 	b.w	c03f8be <PKA_Process>
 c03ffb0:	30030edc 	.word	0x30030edc

0c03ffb4 <PKA_ARI_Set>:
  * @param  pOp2 Generic pointer to input data
  * @param  pOp3 Generic pointer to input data
  */
void PKA_ARI_Set(PKA_HandleTypeDef *hpka, const uint32_t size, const uint32_t *pOp1, const uint32_t *pOp2,
                 const uint8_t *pOp3)
{
 c03ffb4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  /* Get the number of bit per operand */
  hpka->Instance->RAM[PKA_ARITHMETIC_ALL_OPS_NB_BITS] = PKA_GetBitSize_u32(size);
 c03ffb6:	6804      	ldr	r4, [r0, #0]
{
 c03ffb8:	461e      	mov	r6, r3
  return wordNumber * 32UL;
 c03ffba:	014b      	lsls	r3, r1, #5
{
 c03ffbc:	460d      	mov	r5, r1
 c03ffbe:	9f06      	ldr	r7, [sp, #24]

  if (pOp1 != NULL)
 c03ffc0:	4611      	mov	r1, r2
  hpka->Instance->RAM[PKA_ARITHMETIC_ALL_OPS_NB_BITS] = PKA_GetBitSize_u32(size);
 c03ffc2:	f8c4 3408 	str.w	r3, [r4, #1032]	@ 0x408
  if (pOp1 != NULL)
 c03ffc6:	b15a      	cbz	r2, c03ffe0 <PKA_ARI_Set+0x2c>
  {
    /* Move the input parameters pOp1 to PKA RAM */
    PKA_Memcpy_u32_to_u32(&hpka->Instance->RAM[PKA_ARITHMETIC_ALL_OPS_IN_OP1], pOp1, size);
 c03ffc8:	462a      	mov	r2, r5
 c03ffca:	f504 6025 	add.w	r0, r4, #2640	@ 0xa50
 c03ffce:	f7ff fc31 	bl	c03f834 <PKA_Memcpy_u32_to_u32>
    __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ARITHMETIC_ALL_OPS_IN_OP1 + size);
 c03ffd2:	2200      	movs	r2, #0
 c03ffd4:	eb04 0385 	add.w	r3, r4, r5, lsl #2
 c03ffd8:	f8c3 2a50 	str.w	r2, [r3, #2640]	@ 0xa50
 c03ffdc:	f8c3 2a54 	str.w	r2, [r3, #2644]	@ 0xa54
  }

  if (pOp2 != NULL)
 c03ffe0:	b166      	cbz	r6, c03fffc <PKA_ARI_Set+0x48>
  {
    /* Move the input parameters pOp2 to PKA RAM */
    PKA_Memcpy_u32_to_u32(&hpka->Instance->RAM[PKA_ARITHMETIC_ALL_OPS_IN_OP2], pOp2, size);
 c03ffe2:	462a      	mov	r2, r5
 c03ffe4:	4631      	mov	r1, r6
 c03ffe6:	f604 4068 	addw	r0, r4, #3176	@ 0xc68
 c03ffea:	f7ff fc23 	bl	c03f834 <PKA_Memcpy_u32_to_u32>
    __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ARITHMETIC_ALL_OPS_IN_OP2 + size);
 c03ffee:	2200      	movs	r2, #0
 c03fff0:	eb04 0385 	add.w	r3, r4, r5, lsl #2
 c03fff4:	f8c3 2c68 	str.w	r2, [r3, #3176]	@ 0xc68
 c03fff8:	f8c3 2c6c 	str.w	r2, [r3, #3180]	@ 0xc6c
  }

  if (pOp3 != NULL)
 c03fffc:	b17f      	cbz	r7, c04001e <PKA_ARI_Set+0x6a>
  {
    /* Move the input parameters pOp3 to PKA RAM */
    PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_ARITHMETIC_ALL_OPS_IN_OP3], pOp3, size * 4UL);
 c03fffe:	00ad      	lsls	r5, r5, #2
 c040000:	f504 5084 	add.w	r0, r4, #4224	@ 0x1080
 c040004:	462a      	mov	r2, r5
 c040006:	4639      	mov	r1, r7
 c040008:	3008      	adds	r0, #8
 c04000a:	f7ff fbd1 	bl	c03f7b0 <PKA_Memcpy_u8_to_u32>
    __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_ARITHMETIC_ALL_OPS_IN_OP3 + size);
 c04000e:	2300      	movs	r3, #0
 c040010:	442c      	add	r4, r5
 c040012:	f504 5480 	add.w	r4, r4, #4096	@ 0x1000
 c040016:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
 c04001a:	f8c4 308c 	str.w	r3, [r4, #140]	@ 0x8c
  }
}
 c04001e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0c040020 <HAL_PKA_Mul>:
  PKA_ARI_Set(hpka, in->size, in->pOp1, in->pOp2, NULL);
 c040020:	2300      	movs	r3, #0
{
 c040022:	b537      	push	{r0, r1, r2, r4, r5, lr}
 c040024:	4604      	mov	r4, r0
 c040026:	4615      	mov	r5, r2
  PKA_ARI_Set(hpka, in->size, in->pOp1, in->pOp2, NULL);
 c040028:	9300      	str	r3, [sp, #0]
 c04002a:	e9d1 2301 	ldrd	r2, r3, [r1, #4]
 c04002e:	6809      	ldr	r1, [r1, #0]
 c040030:	f7ff ffc0 	bl	c03ffb4 <PKA_ARI_Set>
  return PKA_Process(hpka, PKA_MODE_ARITHMETIC_MUL, Timeout);
 c040034:	462a      	mov	r2, r5
 c040036:	210b      	movs	r1, #11
 c040038:	4620      	mov	r0, r4
}
 c04003a:	b003      	add	sp, #12
 c04003c:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
  return PKA_Process(hpka, PKA_MODE_ARITHMETIC_MUL, Timeout);
 c040040:	f7ff bc3d 	b.w	c03f8be <PKA_Process>

0c040044 <PKA_WaitOnFlagUntilTimeout>:
  * @param  Timeout   Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef PKA_WaitOnFlagUntilTimeout(PKA_HandleTypeDef *hpka, uint32_t Flag, FlagStatus Status,
                                             uint32_t Tickstart, uint32_t Timeout)
{
 c040044:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 c040048:	4604      	mov	r4, r0
 c04004a:	460e      	mov	r6, r1
 c04004c:	4615      	mov	r5, r2
 c04004e:	461f      	mov	r7, r3
 c040050:	f8dd 8018 	ldr.w	r8, [sp, #24]
  /* Wait until flag is set */
  while (__HAL_PKA_GET_FLAG(hpka, Flag) == Status)
 c040054:	6822      	ldr	r2, [r4, #0]
 c040056:	6853      	ldr	r3, [r2, #4]
 c040058:	ea36 0303 	bics.w	r3, r6, r3
 c04005c:	bf0c      	ite	eq
 c04005e:	2301      	moveq	r3, #1
 c040060:	2300      	movne	r3, #0
 c040062:	42ab      	cmp	r3, r5
 c040064:	d001      	beq.n	c04006a <PKA_WaitOnFlagUntilTimeout+0x26>

        return HAL_TIMEOUT;
      }
    }
  }
  return HAL_OK;
 c040066:	2000      	movs	r0, #0
 c040068:	e00f      	b.n	c04008a <PKA_WaitOnFlagUntilTimeout+0x46>
    if (Timeout != HAL_MAX_DELAY)
 c04006a:	f1b8 3fff 	cmp.w	r8, #4294967295	@ 0xffffffff
 c04006e:	d0f2      	beq.n	c040056 <PKA_WaitOnFlagUntilTimeout+0x12>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 c040070:	f003 fe3a 	bl	c043ce8 <HAL_GetTick>
 c040074:	1bc0      	subs	r0, r0, r7
 c040076:	4540      	cmp	r0, r8
 c040078:	d802      	bhi.n	c040080 <PKA_WaitOnFlagUntilTimeout+0x3c>
 c04007a:	f1b8 0f00 	cmp.w	r8, #0
 c04007e:	d1e9      	bne.n	c040054 <PKA_WaitOnFlagUntilTimeout+0x10>
        hpka->State = HAL_PKA_STATE_READY;
 c040080:	2301      	movs	r3, #1
 c040082:	7123      	strb	r3, [r4, #4]
        hpka->ErrorCode = HAL_PKA_ERROR_TIMEOUT;
 c040084:	2304      	movs	r3, #4
        return HAL_TIMEOUT;
 c040086:	2003      	movs	r0, #3
        hpka->ErrorCode = HAL_PKA_ERROR_TIMEOUT;
 c040088:	60a3      	str	r3, [r4, #8]
}
 c04008a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0c04008e <HAL_PKA_Init>:
{
 c04008e:	b537      	push	{r0, r1, r2, r4, r5, lr}
  if (hpka != NULL)
 c040090:	4604      	mov	r4, r0
 c040092:	b1e8      	cbz	r0, c0400d0 <HAL_PKA_Init+0x42>
    if (hpka->State == HAL_PKA_STATE_RESET)
 c040094:	7903      	ldrb	r3, [r0, #4]
 c040096:	b90b      	cbnz	r3, c04009c <HAL_PKA_Init+0xe>
      HAL_PKA_MspInit(hpka);
 c040098:	f7ff fa70 	bl	c03f57c <HAL_PKA_MspInit>
    hpka->State = HAL_PKA_STATE_BUSY;
 c04009c:	2302      	movs	r3, #2
    hpka->Instance->CR = PKA_CR_EN;
 c04009e:	2501      	movs	r5, #1
    hpka->State = HAL_PKA_STATE_BUSY;
 c0400a0:	7123      	strb	r3, [r4, #4]
    hpka->Instance->CR = PKA_CR_EN;
 c0400a2:	6823      	ldr	r3, [r4, #0]
 c0400a4:	601d      	str	r5, [r3, #0]
    tickstart = HAL_GetTick();
 c0400a6:	f003 fe1f 	bl	c043ce8 <HAL_GetTick>
    if (PKA_WaitOnFlagUntilTimeout(hpka, PKA_SR_INITOK, RESET, tickstart, 5000) != HAL_OK)
 c0400aa:	f241 3288 	movw	r2, #5000	@ 0x1388
    tickstart = HAL_GetTick();
 c0400ae:	4603      	mov	r3, r0
    if (PKA_WaitOnFlagUntilTimeout(hpka, PKA_SR_INITOK, RESET, tickstart, 5000) != HAL_OK)
 c0400b0:	9200      	str	r2, [sp, #0]
 c0400b2:	4629      	mov	r1, r5
 c0400b4:	2200      	movs	r2, #0
 c0400b6:	4620      	mov	r0, r4
 c0400b8:	f7ff ffc4 	bl	c040044 <PKA_WaitOnFlagUntilTimeout>
 c0400bc:	b950      	cbnz	r0, c0400d4 <HAL_PKA_Init+0x46>
    SET_BIT(hpka->Instance->CLRFR, PKA_CLRFR_PROCENDFC | PKA_CLRFR_RAMERRFC | PKA_CLRFR_ADDRERRFC | PKA_CLRFR_OPERRFC);
 c0400be:	6822      	ldr	r2, [r4, #0]
 c0400c0:	6893      	ldr	r3, [r2, #8]
 c0400c2:	f443 1368 	orr.w	r3, r3, #3801088	@ 0x3a0000
 c0400c6:	6093      	str	r3, [r2, #8]
    hpka->ErrorCode = HAL_PKA_ERROR_NONE;
 c0400c8:	60a0      	str	r0, [r4, #8]
    hpka->State = HAL_PKA_STATE_READY;
 c0400ca:	7125      	strb	r5, [r4, #4]
}
 c0400cc:	b003      	add	sp, #12
 c0400ce:	bd30      	pop	{r4, r5, pc}
    err = HAL_ERROR;
 c0400d0:	2001      	movs	r0, #1
 c0400d2:	e7fb      	b.n	c0400cc <HAL_PKA_Init+0x3e>
      return HAL_TIMEOUT;
 c0400d4:	2003      	movs	r0, #3
 c0400d6:	e7f9      	b.n	c0400cc <HAL_PKA_Init+0x3e>

0c0400d8 <HAL_RCC_GetSysClockFreq>:
  uint32_t sysclk_source;
  uint32_t pll_oscsource;
  float_t fracn1;
  float_t pllvco;

  sysclk_source = __HAL_RCC_GET_SYSCLK_SOURCE();
 c0400d8:	4a4a      	ldr	r2, [pc, #296]	@ (c040204 <HAL_RCC_GetSysClockFreq+0x12c>)
{
 c0400da:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  sysclk_source = __HAL_RCC_GET_SYSCLK_SOURCE();
 c0400de:	69d3      	ldr	r3, [r2, #28]
  pll_oscsource = __HAL_RCC_GET_PLL_OSCSOURCE();
 c0400e0:	6a91      	ldr	r1, [r2, #40]	@ 0x28

  if ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_MSI) ||
 c0400e2:	f013 030c 	ands.w	r3, r3, #12
 c0400e6:	d005      	beq.n	c0400f4 <HAL_RCC_GetSysClockFreq+0x1c>
 c0400e8:	2b0c      	cmp	r3, #12
 c0400ea:	d14c      	bne.n	c040186 <HAL_RCC_GetSysClockFreq+0xae>
  pll_oscsource = __HAL_RCC_GET_PLL_OSCSOURCE();
 c0400ec:	f001 0103 	and.w	r1, r1, #3
      ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (pll_oscsource == RCC_PLLSOURCE_MSI)))
 c0400f0:	2901      	cmp	r1, #1
 c0400f2:	d148      	bne.n	c040186 <HAL_RCC_GetSysClockFreq+0xae>
  {
    /* MSI or PLL with MSI source used as system clock source */

    /* Get SYSCLK source */
    if (READ_BIT(RCC->ICSCR1, RCC_ICSCR1_MSIRGSEL) == 0U)
 c0400f4:	6891      	ldr	r1, [r2, #8]
 c0400f6:	0209      	lsls	r1, r1, #8
    {
      /* MSISRANGE from RCC_CSR applies */
      msirange = (RCC->CSR & RCC_CSR_MSISSRANGE) >> RCC_CSR_MSISSRANGE_Pos;
 c0400f8:	bf54      	ite	pl
 c0400fa:	f8d2 20f4 	ldrpl.w	r2, [r2, #244]	@ 0xf4
    }
    else
    {
      /* MSIRANGE from RCC_CR applies */
      msirange = (RCC->ICSCR1 & RCC_ICSCR1_MSISRANGE) >> RCC_ICSCR1_MSISRANGE_Pos;
 c0400fe:	6892      	ldrmi	r2, [r2, #8]
    }
    /*MSI frequency range in HZ*/
    msirange = MSIRangeTable[msirange];
 c040100:	4941      	ldr	r1, [pc, #260]	@ (c040208 <HAL_RCC_GetSysClockFreq+0x130>)
      msirange = (RCC->CSR & RCC_CSR_MSISSRANGE) >> RCC_CSR_MSISSRANGE_Pos;
 c040102:	bf54      	ite	pl
 c040104:	f3c2 3203 	ubfxpl	r2, r2, #12, #4
      msirange = (RCC->ICSCR1 & RCC_ICSCR1_MSISRANGE) >> RCC_ICSCR1_MSISRANGE_Pos;
 c040108:	0f12      	lsrmi	r2, r2, #28
    msirange = MSIRangeTable[msirange];
 c04010a:	f851 6022 	ldr.w	r6, [r1, r2, lsl #2]

    if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_MSI)
 c04010e:	2b00      	cmp	r3, #0
 c040110:	d075      	beq.n	c0401fe <HAL_RCC_GetSysClockFreq+0x126>
  uint32_t sysclockfreq = 0U;
 c040112:	2000      	movs	r0, #0
  else
  {
    /* Nothing to do */
  }

  if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 c040114:	2b0c      	cmp	r3, #12
 c040116:	d16f      	bne.n	c0401f8 <HAL_RCC_GetSysClockFreq+0x120>
  {
    /* PLL used as system clock  source
       PLL_VCO = (HSE_VALUE or HSI_VALUE or MSI_VALUE/ PLLM) * PLLN
       SYSCLK = PLL_VCO / PLLR
    */
    pllsource = (RCC->PLL1CFGR & RCC_PLL1CFGR_PLL1SRC);
 c040118:	4d3a      	ldr	r5, [pc, #232]	@ (c040204 <HAL_RCC_GetSysClockFreq+0x12c>)
 c04011a:	6aab      	ldr	r3, [r5, #40]	@ 0x28
    pllm = ((RCC->PLL1CFGR & RCC_PLL1CFGR_PLL1M) >> RCC_PLL1CFGR_PLL1M_Pos) + 1U;
 c04011c:	6aac      	ldr	r4, [r5, #40]	@ 0x28
    pllsource = (RCC->PLL1CFGR & RCC_PLL1CFGR_PLL1SRC);
 c04011e:	f003 0803 	and.w	r8, r3, #3
    pllfracen = ((RCC->PLL1CFGR & RCC_PLL1CFGR_PLL1FRACEN) >> RCC_PLL1CFGR_PLL1FRACEN_Pos);
 c040122:	6aa8      	ldr	r0, [r5, #40]	@ 0x28
    fracn1 = (float_t)(uint32_t)(pllfracen * ((RCC->PLL1FRACR & RCC_PLL1FRACR_PLL1FRACN) >> \
 c040124:	6bab      	ldr	r3, [r5, #56]	@ 0x38
    pllfracen = ((RCC->PLL1CFGR & RCC_PLL1CFGR_PLL1FRACEN) >> RCC_PLL1CFGR_PLL1FRACEN_Pos);
 c040126:	f3c0 1000 	ubfx	r0, r0, #4, #1
    fracn1 = (float_t)(uint32_t)(pllfracen * ((RCC->PLL1FRACR & RCC_PLL1FRACR_PLL1FRACN) >> \
 c04012a:	f3c3 03cc 	ubfx	r3, r3, #3, #13
 c04012e:	4358      	muls	r0, r3
 c040130:	f003 fa78 	bl	c043624 <__aeabi_ui2f>
    pllm = ((RCC->PLL1CFGR & RCC_PLL1CFGR_PLL1M) >> RCC_PLL1CFGR_PLL1M_Pos) + 1U;
 c040134:	f3c4 2403 	ubfx	r4, r4, #8, #4
                                              RCC_PLL1FRACR_PLL1FRACN_Pos));

    if (pllm != 0U)
    {
      switch (pllsource)
 c040138:	f1b8 0f02 	cmp.w	r8, #2
    fracn1 = (float_t)(uint32_t)(pllfracen * ((RCC->PLL1FRACR & RCC_PLL1FRACR_PLL1FRACN) >> \
 c04013c:	4607      	mov	r7, r0
    pllm = ((RCC->PLL1CFGR & RCC_PLL1CFGR_PLL1M) >> RCC_PLL1CFGR_PLL1M_Pos) + 1U;
 c04013e:	f104 0401 	add.w	r4, r4, #1
      switch (pllsource)
 c040142:	d02c      	beq.n	c04019e <HAL_RCC_GetSysClockFreq+0xc6>
 c040144:	f1b8 0f03 	cmp.w	r8, #3
 c040148:	d029      	beq.n	c04019e <HAL_RCC_GetSysClockFreq+0xc6>
                                                           (fracn1 / (float_t)0x2000) + (float_t)1U);
          break;

        case RCC_PLLSOURCE_MSI:  /* MSI used as PLL clock source */
        default:
          pllvco = ((float_t) msirange / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N) + \
 c04014a:	6b68      	ldr	r0, [r5, #52]	@ 0x34
 c04014c:	f3c0 0008 	ubfx	r0, r0, #0, #9
 c040150:	f003 fa68 	bl	c043624 <__aeabi_ui2f>
                                                           (fracn1 / (float_t)0x2000) + (float_t)1U);
 c040154:	f04f 5164 	mov.w	r1, #956301312	@ 0x39000000
          pllvco = ((float_t) msirange / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N) + \
 c040158:	4605      	mov	r5, r0
                                                           (fracn1 / (float_t)0x2000) + (float_t)1U);
 c04015a:	4638      	mov	r0, r7
 c04015c:	f003 faba 	bl	c0436d4 <__aeabi_fmul>
 c040160:	4601      	mov	r1, r0
          pllvco = ((float_t) msirange / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N) + \
 c040162:	4628      	mov	r0, r5
 c040164:	f003 f9ae 	bl	c0434c4 <__addsf3>
                                                           (fracn1 / (float_t)0x2000) + (float_t)1U);
 c040168:	f04f 517e 	mov.w	r1, #1065353216	@ 0x3f800000
 c04016c:	f003 f9aa 	bl	c0434c4 <__addsf3>
 c040170:	4605      	mov	r5, r0
          pllvco = ((float_t) msirange / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N) + \
 c040172:	4630      	mov	r0, r6
 c040174:	f003 fa56 	bl	c043624 <__aeabi_ui2f>
 c040178:	4606      	mov	r6, r0
 c04017a:	4620      	mov	r0, r4
 c04017c:	f003 fa52 	bl	c043624 <__aeabi_ui2f>
 c040180:	4601      	mov	r1, r0
 c040182:	4630      	mov	r0, r6
 c040184:	e024      	b.n	c0401d0 <HAL_RCC_GetSysClockFreq+0xf8>
  else if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI)
 c040186:	69d2      	ldr	r2, [r2, #28]
 c040188:	f002 020c 	and.w	r2, r2, #12
 c04018c:	2a04      	cmp	r2, #4
 c04018e:	d004      	beq.n	c04019a <HAL_RCC_GetSysClockFreq+0xc2>
  else if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSE)
 c040190:	2b08      	cmp	r3, #8
 c040192:	d033      	beq.n	c0401fc <HAL_RCC_GetSysClockFreq+0x124>
  uint32_t sysclockfreq = 0U;
 c040194:	2000      	movs	r0, #0
  uint32_t msirange = 0U;
 c040196:	2600      	movs	r6, #0
 c040198:	e7bc      	b.n	c040114 <HAL_RCC_GetSysClockFreq+0x3c>
    sysclockfreq = HSI_VALUE;
 c04019a:	481c      	ldr	r0, [pc, #112]	@ (c04020c <HAL_RCC_GetSysClockFreq+0x134>)
 c04019c:	e7fb      	b.n	c040196 <HAL_RCC_GetSysClockFreq+0xbe>
          pllvco = ((float_t)HSE_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N) + \
 c04019e:	6b68      	ldr	r0, [r5, #52]	@ 0x34
 c0401a0:	f3c0 0008 	ubfx	r0, r0, #0, #9
 c0401a4:	f003 fa3e 	bl	c043624 <__aeabi_ui2f>
                                                           (fracn1 / (float_t)0x2000) + (float_t)1U);
 c0401a8:	f04f 5164 	mov.w	r1, #956301312	@ 0x39000000
          pllvco = ((float_t)HSE_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N) + \
 c0401ac:	4605      	mov	r5, r0
                                                           (fracn1 / (float_t)0x2000) + (float_t)1U);
 c0401ae:	4638      	mov	r0, r7
 c0401b0:	f003 fa90 	bl	c0436d4 <__aeabi_fmul>
 c0401b4:	4601      	mov	r1, r0
          pllvco = ((float_t)HSE_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N) + \
 c0401b6:	4628      	mov	r0, r5
 c0401b8:	f003 f984 	bl	c0434c4 <__addsf3>
                                                           (fracn1 / (float_t)0x2000) + (float_t)1U);
 c0401bc:	f04f 517e 	mov.w	r1, #1065353216	@ 0x3f800000
 c0401c0:	f003 f980 	bl	c0434c4 <__addsf3>
 c0401c4:	4605      	mov	r5, r0
          pllvco = ((float_t)HSE_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N) + \
 c0401c6:	4620      	mov	r0, r4
 c0401c8:	f003 fa2c 	bl	c043624 <__aeabi_ui2f>
 c0401cc:	4601      	mov	r1, r0
 c0401ce:	4810      	ldr	r0, [pc, #64]	@ (c040210 <HAL_RCC_GetSysClockFreq+0x138>)
          pllvco = ((float_t) msirange / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N) + \
 c0401d0:	f003 fb34 	bl	c04383c <__aeabi_fdiv>
 c0401d4:	4601      	mov	r1, r0
 c0401d6:	4628      	mov	r0, r5
 c0401d8:	f003 fa7c 	bl	c0436d4 <__aeabi_fmul>
          break;
      }

      pllr = (((RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1R) >> RCC_PLL1DIVR_PLL1R_Pos) + 1U);
 c0401dc:	4b09      	ldr	r3, [pc, #36]	@ (c040204 <HAL_RCC_GetSysClockFreq+0x12c>)
          pllvco = ((float_t) msirange / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N) + \
 c0401de:	4604      	mov	r4, r0
      pllr = (((RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1R) >> RCC_PLL1DIVR_PLL1R_Pos) + 1U);
 c0401e0:	6b58      	ldr	r0, [r3, #52]	@ 0x34
 c0401e2:	f3c0 6006 	ubfx	r0, r0, #24, #7
      sysclockfreq = (uint32_t)(float_t)((float_t)pllvco / (float_t)pllr);
 c0401e6:	3001      	adds	r0, #1
 c0401e8:	f003 fa1c 	bl	c043624 <__aeabi_ui2f>
 c0401ec:	4601      	mov	r1, r0
 c0401ee:	4620      	mov	r0, r4
 c0401f0:	f003 fb24 	bl	c04383c <__aeabi_fdiv>
 c0401f4:	f003 fbbe 	bl	c043974 <__aeabi_f2uiz>
      sysclockfreq = 0;
    }
  }

  return sysclockfreq;
}
 c0401f8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    sysclockfreq = HSE_VALUE;
 c0401fc:	4e03      	ldr	r6, [pc, #12]	@ (c04020c <HAL_RCC_GetSysClockFreq+0x134>)
  uint32_t msirange = 0U;
 c0401fe:	4630      	mov	r0, r6
 c040200:	e7fa      	b.n	c0401f8 <HAL_RCC_GetSysClockFreq+0x120>
 c040202:	bf00      	nop
 c040204:	56020c00 	.word	0x56020c00
 c040208:	0c05fa94 	.word	0x0c05fa94
 c04020c:	00f42400 	.word	0x00f42400
 c040210:	4b742400 	.word	0x4b742400

0c040214 <HAL_RCC_GetHCLKFreq>:
  *
  * @note   The SystemCoreClock CMSIS variable is used to store System Clock Frequency.
  * @retval HCLK frequency in Hz
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
 c040214:	b508      	push	{r3, lr}
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR2 & RCC_CFGR2_HPRE) >> RCC_CFGR2_HPRE_Pos];
 c040216:	f7ff ff5f 	bl	c0400d8 <HAL_RCC_GetSysClockFreq>
 c04021a:	4b05      	ldr	r3, [pc, #20]	@ (c040230 <HAL_RCC_GetHCLKFreq+0x1c>)
 c04021c:	4a05      	ldr	r2, [pc, #20]	@ (c040234 <HAL_RCC_GetHCLKFreq+0x20>)
 c04021e:	6a1b      	ldr	r3, [r3, #32]
 c040220:	f003 030f 	and.w	r3, r3, #15
 c040224:	5cd3      	ldrb	r3, [r2, r3]
 c040226:	40d8      	lsrs	r0, r3
 c040228:	4b03      	ldr	r3, [pc, #12]	@ (c040238 <HAL_RCC_GetHCLKFreq+0x24>)
 c04022a:	6018      	str	r0, [r3, #0]
  return SystemCoreClock;
}
 c04022c:	bd08      	pop	{r3, pc}
 c04022e:	bf00      	nop
 c040230:	56020c00 	.word	0x56020c00
 c040234:	0c05fadc 	.word	0x0c05fadc
 c040238:	300308e4 	.word	0x300308e4

0c04023c <HAL_RCC_GetPCLK1Freq>:
  * @note   Each time PCLK1 changes, this function must be called to update the
  *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency in Hz
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
 c04023c:	b508      	push	{r3, lr}
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR2 & RCC_CFGR2_PPRE1) >> RCC_CFGR2_PPRE1_Pos]);
 c04023e:	f7ff ffe9 	bl	c040214 <HAL_RCC_GetHCLKFreq>
 c040242:	4b04      	ldr	r3, [pc, #16]	@ (c040254 <HAL_RCC_GetPCLK1Freq+0x18>)
 c040244:	4a04      	ldr	r2, [pc, #16]	@ (c040258 <HAL_RCC_GetPCLK1Freq+0x1c>)
 c040246:	6a1b      	ldr	r3, [r3, #32]
 c040248:	f3c3 1302 	ubfx	r3, r3, #4, #3
 c04024c:	5cd3      	ldrb	r3, [r2, r3]
}
 c04024e:	40d8      	lsrs	r0, r3
 c040250:	bd08      	pop	{r3, pc}
 c040252:	bf00      	nop
 c040254:	56020c00 	.word	0x56020c00
 c040258:	0c05fad4 	.word	0x0c05fad4

0c04025c <HAL_RCC_GetPCLK2Freq>:
  * @note   Each time PCLK2 changes, this function must be called to update the
  *         right PCLK2 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK2 frequency in Hz
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
 c04025c:	b508      	push	{r3, lr}
  /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR2 & RCC_CFGR2_PPRE2) >> RCC_CFGR2_PPRE2_Pos]);
 c04025e:	f7ff ffd9 	bl	c040214 <HAL_RCC_GetHCLKFreq>
 c040262:	4b04      	ldr	r3, [pc, #16]	@ (c040274 <HAL_RCC_GetPCLK2Freq+0x18>)
 c040264:	4a04      	ldr	r2, [pc, #16]	@ (c040278 <HAL_RCC_GetPCLK2Freq+0x1c>)
 c040266:	6a1b      	ldr	r3, [r3, #32]
 c040268:	f3c3 2302 	ubfx	r3, r3, #8, #3
 c04026c:	5cd3      	ldrb	r3, [r2, r3]
}
 c04026e:	40d8      	lsrs	r0, r3
 c040270:	bd08      	pop	{r3, pc}
 c040272:	bf00      	nop
 c040274:	56020c00 	.word	0x56020c00
 c040278:	0c05fad4 	.word	0x0c05fad4

0c04027c <HAL_RCC_GetPCLK3Freq>:
  * @note   Each time PCLK3 changes, this function must be called to update the
  *         right PCLK3 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK3 frequency in Hz
  */
uint32_t HAL_RCC_GetPCLK3Freq(void)
{
 c04027c:	b508      	push	{r3, lr}
  /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR3 & RCC_CFGR3_PPRE3) >> RCC_CFGR3_PPRE3_Pos]);
 c04027e:	f7ff ffc9 	bl	c040214 <HAL_RCC_GetHCLKFreq>
 c040282:	4b04      	ldr	r3, [pc, #16]	@ (c040294 <HAL_RCC_GetPCLK3Freq+0x18>)
 c040284:	4a04      	ldr	r2, [pc, #16]	@ (c040298 <HAL_RCC_GetPCLK3Freq+0x1c>)
 c040286:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 c040288:	f3c3 1302 	ubfx	r3, r3, #4, #3
 c04028c:	5cd3      	ldrb	r3, [r2, r3]
}
 c04028e:	40d8      	lsrs	r0, r3
 c040290:	bd08      	pop	{r3, pc}
 c040292:	bf00      	nop
 c040294:	56020c00 	.word	0x56020c00
 c040298:	0c05fad4 	.word	0x0c05fad4

0c04029c <HAL_RCCEx_GetPLL1ClockFreq>:
  *         right PLL1CLK value. Otherwise, any configuration based on this function will be incorrect.
  * @param  PLL1_Clocks structure.
  * @retval None
  */
void HAL_RCCEx_GetPLL1ClockFreq(PLL1_ClocksTypeDef *PLL1_Clocks)
{
 c04029c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  uint32_t pll1n;
  uint32_t pll1fracen;
  float_t fracn1;
  float_t pll1vco;

  pll1n = (RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N);
 c0402a0:	4c53      	ldr	r4, [pc, #332]	@ (c0403f0 <HAL_RCCEx_GetPLL1ClockFreq+0x154>)
{
 c0402a2:	4606      	mov	r6, r0
  pll1n = (RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N);
 c0402a4:	6b63      	ldr	r3, [r4, #52]	@ 0x34
 c0402a6:	f3c3 0808 	ubfx	r8, r3, #0, #9
  pll1source = (RCC->PLL1CFGR & RCC_PLL1CFGR_PLL1SRC);
 c0402aa:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
  pll1m = ((RCC->PLL1CFGR & RCC_PLL1CFGR_PLL1M) >> RCC_PLL1CFGR_PLL1M_Pos) + 1U;
 c0402ac:	6aa5      	ldr	r5, [r4, #40]	@ 0x28
  pll1source = (RCC->PLL1CFGR & RCC_PLL1CFGR_PLL1SRC);
 c0402ae:	f003 0903 	and.w	r9, r3, #3
  pll1fracen = ((RCC->PLL1CFGR & RCC_PLL1CFGR_PLL1FRACEN) >> RCC_PLL1CFGR_PLL1FRACEN_Pos);
 c0402b2:	6aa0      	ldr	r0, [r4, #40]	@ 0x28
  fracn1 = (float_t)(uint32_t)(pll1fracen * ((RCC->PLL1FRACR & RCC_PLL1FRACR_PLL1FRACN) >> \
 c0402b4:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
  pll1fracen = ((RCC->PLL1CFGR & RCC_PLL1CFGR_PLL1FRACEN) >> RCC_PLL1CFGR_PLL1FRACEN_Pos);
 c0402b6:	f3c0 1000 	ubfx	r0, r0, #4, #1
  fracn1 = (float_t)(uint32_t)(pll1fracen * ((RCC->PLL1FRACR & RCC_PLL1FRACR_PLL1FRACN) >> \
 c0402ba:	f3c3 03cc 	ubfx	r3, r3, #3, #13
 c0402be:	4358      	muls	r0, r3
 c0402c0:	f003 f9b0 	bl	c043624 <__aeabi_ui2f>
  pll1m = ((RCC->PLL1CFGR & RCC_PLL1CFGR_PLL1M) >> RCC_PLL1CFGR_PLL1M_Pos) + 1U;
 c0402c4:	f3c5 2503 	ubfx	r5, r5, #8, #4
                                             RCC_PLL1FRACR_PLL1FRACN_Pos));

  if (pll1m != 0U)
  {
    switch (pll1source)
 c0402c8:	f1b9 0f02 	cmp.w	r9, #2
  fracn1 = (float_t)(uint32_t)(pll1fracen * ((RCC->PLL1FRACR & RCC_PLL1FRACR_PLL1FRACN) >> \
 c0402cc:	4607      	mov	r7, r0
  pll1m = ((RCC->PLL1CFGR & RCC_PLL1CFGR_PLL1M) >> RCC_PLL1CFGR_PLL1M_Pos) + 1U;
 c0402ce:	f105 0501 	add.w	r5, r5, #1
    switch (pll1source)
 c0402d2:	d070      	beq.n	c0403b6 <HAL_RCCEx_GetPLL1ClockFreq+0x11a>
 c0402d4:	f1b9 0f03 	cmp.w	r9, #3
 c0402d8:	d06d      	beq.n	c0403b6 <HAL_RCCEx_GetPLL1ClockFreq+0x11a>
      case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
        pll1vco = ((float_t)HSE_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N) + \
                                                           (fracn1 / (float_t)0x2000) + (float_t)1);
        break;
      default:
        pll1vco = ((float_t)MSIRangeTable[(__HAL_RCC_GET_MSI_RANGE() >> RCC_ICSCR1_MSISRANGE_Pos)] / (float_t)pll1m) * \
 c0402da:	68a3      	ldr	r3, [r4, #8]
 c0402dc:	4a45      	ldr	r2, [pc, #276]	@ (c0403f4 <HAL_RCCEx_GetPLL1ClockFreq+0x158>)
 c0402de:	021b      	lsls	r3, r3, #8
 c0402e0:	bf4b      	itete	mi
 c0402e2:	68a3      	ldrmi	r3, [r4, #8]
 c0402e4:	f8d4 30f4 	ldrpl.w	r3, [r4, #244]	@ 0xf4
 c0402e8:	0f1b      	lsrmi	r3, r3, #28
 c0402ea:	f3c3 3303 	ubfxpl	r3, r3, #12, #4
 c0402ee:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
 c0402f2:	f003 f997 	bl	c043624 <__aeabi_ui2f>
 c0402f6:	4604      	mov	r4, r0
 c0402f8:	4628      	mov	r0, r5
 c0402fa:	f003 f993 	bl	c043624 <__aeabi_ui2f>
 c0402fe:	4601      	mov	r1, r0
 c040300:	4620      	mov	r0, r4
 c040302:	f003 fa9b 	bl	c04383c <__aeabi_fdiv>
 c040306:	4604      	mov	r4, r0
                  ((float_t)pll1n + (fracn1 / (float_t)0x2000) + (float_t)1);
 c040308:	4640      	mov	r0, r8
 c04030a:	f003 f98b 	bl	c043624 <__aeabi_ui2f>
 c04030e:	f04f 5164 	mov.w	r1, #956301312	@ 0x39000000
 c040312:	4605      	mov	r5, r0
 c040314:	4638      	mov	r0, r7
 c040316:	f003 f9dd 	bl	c0436d4 <__aeabi_fmul>
 c04031a:	4601      	mov	r1, r0
 c04031c:	4628      	mov	r0, r5
 c04031e:	f003 f8d1 	bl	c0434c4 <__addsf3>
 c040322:	f04f 517e 	mov.w	r1, #1065353216	@ 0x3f800000
 c040326:	f003 f8cd 	bl	c0434c4 <__addsf3>
 c04032a:	4601      	mov	r1, r0
        pll1vco = ((float_t)MSIRangeTable[(__HAL_RCC_GET_MSI_RANGE() >> RCC_ICSCR1_MSISRANGE_Pos)] / (float_t)pll1m) * \
 c04032c:	4620      	mov	r0, r4
 c04032e:	f003 f9d1 	bl	c0436d4 <__aeabi_fmul>
        break;
    }

    if (__HAL_RCC_GET_PLLCLKOUT_CONFIG(RCC_PLL1_DIVP) != 0U)
 c040332:	4b2f      	ldr	r3, [pc, #188]	@ (c0403f0 <HAL_RCCEx_GetPLL1ClockFreq+0x154>)
        pll1vco = ((float_t)MSIRangeTable[(__HAL_RCC_GET_MSI_RANGE() >> RCC_ICSCR1_MSISRANGE_Pos)] / (float_t)pll1m) * \
 c040334:	4604      	mov	r4, r0
    if (__HAL_RCC_GET_PLLCLKOUT_CONFIG(RCC_PLL1_DIVP) != 0U)
 c040336:	6a98      	ldr	r0, [r3, #40]	@ 0x28
 c040338:	f410 3080 	ands.w	r0, r0, #65536	@ 0x10000
 c04033c:	d00e      	beq.n	c04035c <HAL_RCCEx_GetPLL1ClockFreq+0xc0>
    {
      PLL1_Clocks->PLL1_P_Frequency = (uint32_t)(float_t)(pll1vco / ((float_t)(uint32_t)((RCC->PLL1DIVR & \
 c04033e:	6b58      	ldr	r0, [r3, #52]	@ 0x34
 c040340:	f3c0 2046 	ubfx	r0, r0, #9, #7
 c040344:	f003 f96e 	bl	c043624 <__aeabi_ui2f>
                                                                     RCC_PLL1DIVR_PLL1P) >> RCC_PLL1DIVR_PLL1P_Pos) + \
 c040348:	f04f 517e 	mov.w	r1, #1065353216	@ 0x3f800000
 c04034c:	f003 f8ba 	bl	c0434c4 <__addsf3>
 c040350:	4601      	mov	r1, r0
      PLL1_Clocks->PLL1_P_Frequency = (uint32_t)(float_t)(pll1vco / ((float_t)(uint32_t)((RCC->PLL1DIVR & \
 c040352:	4620      	mov	r0, r4
 c040354:	f003 fa72 	bl	c04383c <__aeabi_fdiv>
 c040358:	f003 fb0c 	bl	c043974 <__aeabi_f2uiz>
    else
    {
      PLL1_Clocks->PLL1_P_Frequency = 0U;
    }

    if (__HAL_RCC_GET_PLLCLKOUT_CONFIG(RCC_PLL1_DIVQ) != 0U)
 c04035c:	4b24      	ldr	r3, [pc, #144]	@ (c0403f0 <HAL_RCCEx_GetPLL1ClockFreq+0x154>)
 c04035e:	6030      	str	r0, [r6, #0]
 c040360:	6a98      	ldr	r0, [r3, #40]	@ 0x28
 c040362:	f410 3000 	ands.w	r0, r0, #131072	@ 0x20000
 c040366:	d00e      	beq.n	c040386 <HAL_RCCEx_GetPLL1ClockFreq+0xea>
    {
      PLL1_Clocks->PLL1_Q_Frequency = (uint32_t)(float_t)(pll1vco / ((float_t)(uint32_t)((RCC->PLL1DIVR & \
 c040368:	6b58      	ldr	r0, [r3, #52]	@ 0x34
 c04036a:	f3c0 4006 	ubfx	r0, r0, #16, #7
 c04036e:	f003 f959 	bl	c043624 <__aeabi_ui2f>
                                                                     RCC_PLL1DIVR_PLL1Q) >> RCC_PLL1DIVR_PLL1Q_Pos) + \
 c040372:	f04f 517e 	mov.w	r1, #1065353216	@ 0x3f800000
 c040376:	f003 f8a5 	bl	c0434c4 <__addsf3>
 c04037a:	4601      	mov	r1, r0
      PLL1_Clocks->PLL1_Q_Frequency = (uint32_t)(float_t)(pll1vco / ((float_t)(uint32_t)((RCC->PLL1DIVR & \
 c04037c:	4620      	mov	r0, r4
 c04037e:	f003 fa5d 	bl	c04383c <__aeabi_fdiv>
 c040382:	f003 faf7 	bl	c043974 <__aeabi_f2uiz>
    else
    {
      PLL1_Clocks->PLL1_Q_Frequency = 0U;
    }

    if (__HAL_RCC_GET_PLLCLKOUT_CONFIG(RCC_PLL1_DIVR) != 0U)
 c040386:	4a1a      	ldr	r2, [pc, #104]	@ (c0403f0 <HAL_RCCEx_GetPLL1ClockFreq+0x154>)
 c040388:	6070      	str	r0, [r6, #4]
 c04038a:	6a90      	ldr	r0, [r2, #40]	@ 0x28
 c04038c:	f410 2080 	ands.w	r0, r0, #262144	@ 0x40000
 c040390:	d00e      	beq.n	c0403b0 <HAL_RCCEx_GetPLL1ClockFreq+0x114>
    {
      PLL1_Clocks->PLL1_R_Frequency = (uint32_t)(float_t)(pll1vco / ((float_t)(uint32_t)((RCC->PLL1DIVR & \
 c040392:	6b50      	ldr	r0, [r2, #52]	@ 0x34
 c040394:	f3c0 6006 	ubfx	r0, r0, #24, #7
 c040398:	f003 f944 	bl	c043624 <__aeabi_ui2f>
                                                                     RCC_PLL1DIVR_PLL1R) >> RCC_PLL1DIVR_PLL1R_Pos) + \
 c04039c:	f04f 517e 	mov.w	r1, #1065353216	@ 0x3f800000
 c0403a0:	f003 f890 	bl	c0434c4 <__addsf3>
 c0403a4:	4601      	mov	r1, r0
      PLL1_Clocks->PLL1_R_Frequency = (uint32_t)(float_t)(pll1vco / ((float_t)(uint32_t)((RCC->PLL1DIVR & \
 c0403a6:	4620      	mov	r0, r4
 c0403a8:	f003 fa48 	bl	c04383c <__aeabi_fdiv>
 c0403ac:	f003 fae2 	bl	c043974 <__aeabi_f2uiz>
 c0403b0:	60b0      	str	r0, [r6, #8]
    PLL1_Clocks->PLL1_P_Frequency = 0U;
    PLL1_Clocks->PLL1_Q_Frequency = 0U;
    PLL1_Clocks->PLL1_R_Frequency = 0U;
  }

}
 c0403b2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        pll1vco = ((float_t)HSE_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N) + \
 c0403b6:	6b60      	ldr	r0, [r4, #52]	@ 0x34
 c0403b8:	f3c0 0008 	ubfx	r0, r0, #0, #9
 c0403bc:	f003 f932 	bl	c043624 <__aeabi_ui2f>
                                                           (fracn1 / (float_t)0x2000) + (float_t)1);
 c0403c0:	f04f 5164 	mov.w	r1, #956301312	@ 0x39000000
        pll1vco = ((float_t)HSE_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N) + \
 c0403c4:	4604      	mov	r4, r0
                                                           (fracn1 / (float_t)0x2000) + (float_t)1);
 c0403c6:	4638      	mov	r0, r7
 c0403c8:	f003 f984 	bl	c0436d4 <__aeabi_fmul>
 c0403cc:	4601      	mov	r1, r0
        pll1vco = ((float_t)HSE_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N) + \
 c0403ce:	4620      	mov	r0, r4
 c0403d0:	f003 f878 	bl	c0434c4 <__addsf3>
                                                           (fracn1 / (float_t)0x2000) + (float_t)1);
 c0403d4:	f04f 517e 	mov.w	r1, #1065353216	@ 0x3f800000
 c0403d8:	f003 f874 	bl	c0434c4 <__addsf3>
 c0403dc:	4604      	mov	r4, r0
        pll1vco = ((float_t)HSE_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N) + \
 c0403de:	4628      	mov	r0, r5
 c0403e0:	f003 f920 	bl	c043624 <__aeabi_ui2f>
 c0403e4:	4601      	mov	r1, r0
 c0403e6:	4804      	ldr	r0, [pc, #16]	@ (c0403f8 <HAL_RCCEx_GetPLL1ClockFreq+0x15c>)
 c0403e8:	f003 fa28 	bl	c04383c <__aeabi_fdiv>
 c0403ec:	e79d      	b.n	c04032a <HAL_RCCEx_GetPLL1ClockFreq+0x8e>
 c0403ee:	bf00      	nop
 c0403f0:	56020c00 	.word	0x56020c00
 c0403f4:	0c05fa94 	.word	0x0c05fa94
 c0403f8:	4b742400 	.word	0x4b742400

0c0403fc <HAL_RCCEx_GetPLL2ClockFreq>:
  *         right PLL2CLK value. Otherwise, any configuration based on this function will be incorrect.
  * @param  PLL2_Clocks structure.
  * @retval None
  */
void HAL_RCCEx_GetPLL2ClockFreq(PLL2_ClocksTypeDef *PLL2_Clocks)
{
 c0403fc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  float_t fracn2;
  float_t pll2vco;

  /* PLL_VCO = (HSE_VALUE or HSI_VALUE or CSI_VALUE/ PLL2M) * PLL2N
     PLL2xCLK = PLL2_VCO / PLL2x */
  pll2n = (RCC->PLL2DIVR & RCC_PLL2DIVR_PLL2N);
 c040400:	4c53      	ldr	r4, [pc, #332]	@ (c040550 <HAL_RCCEx_GetPLL2ClockFreq+0x154>)
{
 c040402:	4606      	mov	r6, r0
  pll2n = (RCC->PLL2DIVR & RCC_PLL2DIVR_PLL2N);
 c040404:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
 c040406:	f3c3 0808 	ubfx	r8, r3, #0, #9
  pll2source = (RCC->PLL2CFGR & RCC_PLL2CFGR_PLL2SRC);
 c04040a:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
  pll2m = ((RCC->PLL2CFGR & RCC_PLL2CFGR_PLL2M) >> RCC_PLL2CFGR_PLL2M_Pos) + 1U;
 c04040c:	6ae5      	ldr	r5, [r4, #44]	@ 0x2c
  pll2source = (RCC->PLL2CFGR & RCC_PLL2CFGR_PLL2SRC);
 c04040e:	f003 0903 	and.w	r9, r3, #3
  pll2fracen = ((RCC->PLL2CFGR & RCC_PLL2CFGR_PLL2FRACEN) >> RCC_PLL2CFGR_PLL2FRACEN_Pos);
 c040412:	6ae0      	ldr	r0, [r4, #44]	@ 0x2c
  fracn2 = (float_t)(uint32_t)(pll2fracen * ((RCC->PLL2FRACR & RCC_PLL2FRACR_PLL2FRACN) >> \
 c040414:	6c23      	ldr	r3, [r4, #64]	@ 0x40
  pll2fracen = ((RCC->PLL2CFGR & RCC_PLL2CFGR_PLL2FRACEN) >> RCC_PLL2CFGR_PLL2FRACEN_Pos);
 c040416:	f3c0 1000 	ubfx	r0, r0, #4, #1
  fracn2 = (float_t)(uint32_t)(pll2fracen * ((RCC->PLL2FRACR & RCC_PLL2FRACR_PLL2FRACN) >> \
 c04041a:	f3c3 03cc 	ubfx	r3, r3, #3, #13
 c04041e:	4358      	muls	r0, r3
 c040420:	f003 f900 	bl	c043624 <__aeabi_ui2f>
  pll2m = ((RCC->PLL2CFGR & RCC_PLL2CFGR_PLL2M) >> RCC_PLL2CFGR_PLL2M_Pos) + 1U;
 c040424:	f3c5 2503 	ubfx	r5, r5, #8, #4
                                             RCC_PLL2FRACR_PLL2FRACN_Pos));

  if (pll2m != 0U)
  {
    switch (pll2source)
 c040428:	f1b9 0f02 	cmp.w	r9, #2
  fracn2 = (float_t)(uint32_t)(pll2fracen * ((RCC->PLL2FRACR & RCC_PLL2FRACR_PLL2FRACN) >> \
 c04042c:	4607      	mov	r7, r0
  pll2m = ((RCC->PLL2CFGR & RCC_PLL2CFGR_PLL2M) >> RCC_PLL2CFGR_PLL2M_Pos) + 1U;
 c04042e:	f105 0501 	add.w	r5, r5, #1
    switch (pll2source)
 c040432:	d070      	beq.n	c040516 <HAL_RCCEx_GetPLL2ClockFreq+0x11a>
 c040434:	f1b9 0f03 	cmp.w	r9, #3
 c040438:	d06d      	beq.n	c040516 <HAL_RCCEx_GetPLL2ClockFreq+0x11a>
        pll2vco = ((float_t)HSE_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_PLL2N) + \
                                                           (fracn2 / (float_t)0x2000) + (float_t)1);
        break;

      default:
        pll2vco = ((float_t)MSIRangeTable[(__HAL_RCC_GET_MSI_RANGE() >> RCC_ICSCR1_MSISRANGE_Pos)] / (float_t) pll2m) \
 c04043a:	68a3      	ldr	r3, [r4, #8]
 c04043c:	4a45      	ldr	r2, [pc, #276]	@ (c040554 <HAL_RCCEx_GetPLL2ClockFreq+0x158>)
 c04043e:	021b      	lsls	r3, r3, #8
 c040440:	bf4b      	itete	mi
 c040442:	68a3      	ldrmi	r3, [r4, #8]
 c040444:	f8d4 30f4 	ldrpl.w	r3, [r4, #244]	@ 0xf4
 c040448:	0f1b      	lsrmi	r3, r3, #28
 c04044a:	f3c3 3303 	ubfxpl	r3, r3, #12, #4
 c04044e:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
 c040452:	f003 f8e7 	bl	c043624 <__aeabi_ui2f>
 c040456:	4604      	mov	r4, r0
 c040458:	4628      	mov	r0, r5
 c04045a:	f003 f8e3 	bl	c043624 <__aeabi_ui2f>
 c04045e:	4601      	mov	r1, r0
 c040460:	4620      	mov	r0, r4
 c040462:	f003 f9eb 	bl	c04383c <__aeabi_fdiv>
 c040466:	4604      	mov	r4, r0
                  * ((float_t)pll2n + (fracn2 / (float_t)0x2000) + (float_t)1);
 c040468:	4640      	mov	r0, r8
 c04046a:	f003 f8db 	bl	c043624 <__aeabi_ui2f>
 c04046e:	f04f 5164 	mov.w	r1, #956301312	@ 0x39000000
 c040472:	4605      	mov	r5, r0
 c040474:	4638      	mov	r0, r7
 c040476:	f003 f92d 	bl	c0436d4 <__aeabi_fmul>
 c04047a:	4601      	mov	r1, r0
 c04047c:	4628      	mov	r0, r5
 c04047e:	f003 f821 	bl	c0434c4 <__addsf3>
 c040482:	f04f 517e 	mov.w	r1, #1065353216	@ 0x3f800000
 c040486:	f003 f81d 	bl	c0434c4 <__addsf3>
 c04048a:	4601      	mov	r1, r0
        pll2vco = ((float_t)MSIRangeTable[(__HAL_RCC_GET_MSI_RANGE() >> RCC_ICSCR1_MSISRANGE_Pos)] / (float_t) pll2m) \
 c04048c:	4620      	mov	r0, r4
 c04048e:	f003 f921 	bl	c0436d4 <__aeabi_fmul>
        break;
    }
    if (__HAL_RCC_GET_PLL2CLKOUT_CONFIG(RCC_PLL2_DIVP) != 0U)
 c040492:	4b2f      	ldr	r3, [pc, #188]	@ (c040550 <HAL_RCCEx_GetPLL2ClockFreq+0x154>)
        pll2vco = ((float_t)MSIRangeTable[(__HAL_RCC_GET_MSI_RANGE() >> RCC_ICSCR1_MSISRANGE_Pos)] / (float_t) pll2m) \
 c040494:	4604      	mov	r4, r0
    if (__HAL_RCC_GET_PLL2CLKOUT_CONFIG(RCC_PLL2_DIVP) != 0U)
 c040496:	6ad8      	ldr	r0, [r3, #44]	@ 0x2c
 c040498:	f410 3080 	ands.w	r0, r0, #65536	@ 0x10000
 c04049c:	d00e      	beq.n	c0404bc <HAL_RCCEx_GetPLL2ClockFreq+0xc0>
    {
      PLL2_Clocks->PLL2_P_Frequency = (uint32_t)(float_t)(pll2vco / ((float_t)(uint32_t)((RCC->PLL2DIVR & \
 c04049e:	6bd8      	ldr	r0, [r3, #60]	@ 0x3c
 c0404a0:	f3c0 2046 	ubfx	r0, r0, #9, #7
 c0404a4:	f003 f8be 	bl	c043624 <__aeabi_ui2f>
                                                                     RCC_PLL2DIVR_PLL2P) >> RCC_PLL2DIVR_PLL2P_Pos) + \
 c0404a8:	f04f 517e 	mov.w	r1, #1065353216	@ 0x3f800000
 c0404ac:	f003 f80a 	bl	c0434c4 <__addsf3>
 c0404b0:	4601      	mov	r1, r0
      PLL2_Clocks->PLL2_P_Frequency = (uint32_t)(float_t)(pll2vco / ((float_t)(uint32_t)((RCC->PLL2DIVR & \
 c0404b2:	4620      	mov	r0, r4
 c0404b4:	f003 f9c2 	bl	c04383c <__aeabi_fdiv>
 c0404b8:	f003 fa5c 	bl	c043974 <__aeabi_f2uiz>
    }
    else
    {
      PLL2_Clocks->PLL2_P_Frequency = 0U;
    }
    if (__HAL_RCC_GET_PLL2CLKOUT_CONFIG(RCC_PLL2_DIVQ) != 0U)
 c0404bc:	4b24      	ldr	r3, [pc, #144]	@ (c040550 <HAL_RCCEx_GetPLL2ClockFreq+0x154>)
 c0404be:	6030      	str	r0, [r6, #0]
 c0404c0:	6ad8      	ldr	r0, [r3, #44]	@ 0x2c
 c0404c2:	f410 3000 	ands.w	r0, r0, #131072	@ 0x20000
 c0404c6:	d00e      	beq.n	c0404e6 <HAL_RCCEx_GetPLL2ClockFreq+0xea>
    {
      PLL2_Clocks->PLL2_Q_Frequency = (uint32_t)(float_t)(pll2vco / ((float_t)(uint32_t)((RCC->PLL2DIVR & \
 c0404c8:	6bd8      	ldr	r0, [r3, #60]	@ 0x3c
 c0404ca:	f3c0 4006 	ubfx	r0, r0, #16, #7
 c0404ce:	f003 f8a9 	bl	c043624 <__aeabi_ui2f>
                                                                     RCC_PLL2DIVR_PLL2Q) >> RCC_PLL2DIVR_PLL2Q_Pos) + \
 c0404d2:	f04f 517e 	mov.w	r1, #1065353216	@ 0x3f800000
 c0404d6:	f002 fff5 	bl	c0434c4 <__addsf3>
 c0404da:	4601      	mov	r1, r0
      PLL2_Clocks->PLL2_Q_Frequency = (uint32_t)(float_t)(pll2vco / ((float_t)(uint32_t)((RCC->PLL2DIVR & \
 c0404dc:	4620      	mov	r0, r4
 c0404de:	f003 f9ad 	bl	c04383c <__aeabi_fdiv>
 c0404e2:	f003 fa47 	bl	c043974 <__aeabi_f2uiz>
    }
    else
    {
      PLL2_Clocks->PLL2_Q_Frequency = 0U;
    }
    if (__HAL_RCC_GET_PLL2CLKOUT_CONFIG(RCC_PLL2_DIVR) != 0U)
 c0404e6:	4a1a      	ldr	r2, [pc, #104]	@ (c040550 <HAL_RCCEx_GetPLL2ClockFreq+0x154>)
 c0404e8:	6070      	str	r0, [r6, #4]
 c0404ea:	6ad0      	ldr	r0, [r2, #44]	@ 0x2c
 c0404ec:	f410 2080 	ands.w	r0, r0, #262144	@ 0x40000
 c0404f0:	d00e      	beq.n	c040510 <HAL_RCCEx_GetPLL2ClockFreq+0x114>
    {
      PLL2_Clocks->PLL2_R_Frequency = (uint32_t)(float_t)(pll2vco / ((float_t)(uint32_t)((RCC->PLL2DIVR & \
 c0404f2:	6bd0      	ldr	r0, [r2, #60]	@ 0x3c
 c0404f4:	f3c0 6006 	ubfx	r0, r0, #24, #7
 c0404f8:	f003 f894 	bl	c043624 <__aeabi_ui2f>
                                                                     RCC_PLL2DIVR_PLL2R) >> RCC_PLL2DIVR_PLL2R_Pos) + \
 c0404fc:	f04f 517e 	mov.w	r1, #1065353216	@ 0x3f800000
 c040500:	f002 ffe0 	bl	c0434c4 <__addsf3>
 c040504:	4601      	mov	r1, r0
      PLL2_Clocks->PLL2_R_Frequency = (uint32_t)(float_t)(pll2vco / ((float_t)(uint32_t)((RCC->PLL2DIVR & \
 c040506:	4620      	mov	r0, r4
 c040508:	f003 f998 	bl	c04383c <__aeabi_fdiv>
 c04050c:	f003 fa32 	bl	c043974 <__aeabi_f2uiz>
 c040510:	60b0      	str	r0, [r6, #8]
  {
    PLL2_Clocks->PLL2_P_Frequency = 0U;
    PLL2_Clocks->PLL2_Q_Frequency = 0U;
    PLL2_Clocks->PLL2_R_Frequency = 0U;
  }
}
 c040512:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        pll2vco = ((float_t)HSE_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_PLL2N) + \
 c040516:	6be0      	ldr	r0, [r4, #60]	@ 0x3c
 c040518:	f3c0 0008 	ubfx	r0, r0, #0, #9
 c04051c:	f003 f882 	bl	c043624 <__aeabi_ui2f>
                                                           (fracn2 / (float_t)0x2000) + (float_t)1);
 c040520:	f04f 5164 	mov.w	r1, #956301312	@ 0x39000000
        pll2vco = ((float_t)HSE_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_PLL2N) + \
 c040524:	4604      	mov	r4, r0
                                                           (fracn2 / (float_t)0x2000) + (float_t)1);
 c040526:	4638      	mov	r0, r7
 c040528:	f003 f8d4 	bl	c0436d4 <__aeabi_fmul>
 c04052c:	4601      	mov	r1, r0
        pll2vco = ((float_t)HSE_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_PLL2N) + \
 c04052e:	4620      	mov	r0, r4
 c040530:	f002 ffc8 	bl	c0434c4 <__addsf3>
                                                           (fracn2 / (float_t)0x2000) + (float_t)1);
 c040534:	f04f 517e 	mov.w	r1, #1065353216	@ 0x3f800000
 c040538:	f002 ffc4 	bl	c0434c4 <__addsf3>
 c04053c:	4604      	mov	r4, r0
        pll2vco = ((float_t)HSE_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_PLL2N) + \
 c04053e:	4628      	mov	r0, r5
 c040540:	f003 f870 	bl	c043624 <__aeabi_ui2f>
 c040544:	4601      	mov	r1, r0
 c040546:	4804      	ldr	r0, [pc, #16]	@ (c040558 <HAL_RCCEx_GetPLL2ClockFreq+0x15c>)
 c040548:	f003 f978 	bl	c04383c <__aeabi_fdiv>
 c04054c:	e79d      	b.n	c04048a <HAL_RCCEx_GetPLL2ClockFreq+0x8e>
 c04054e:	bf00      	nop
 c040550:	56020c00 	.word	0x56020c00
 c040554:	0c05fa94 	.word	0x0c05fa94
 c040558:	4b742400 	.word	0x4b742400

0c04055c <HAL_RCCEx_GetPLL3ClockFreq>:
  *         right PLL3CLK value. Otherwise, any configuration based on this function will be incorrect.
  * @param  PLL3_Clocks structure.
  * @retval None
  */
void HAL_RCCEx_GetPLL3ClockFreq(PLL3_ClocksTypeDef *PLL3_Clocks)
{
 c04055c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}

  /* PLL3_VCO = (HSE_VALUE or HSI_VALUE or CSI_VALUE/ PLL3M) * PLL3N
  PLL3xCLK = PLL3_VCO / PLLxR
  */

  pll3n = (RCC->PLL3DIVR & RCC_PLL3DIVR_PLL3N);
 c040560:	4c53      	ldr	r4, [pc, #332]	@ (c0406b0 <HAL_RCCEx_GetPLL3ClockFreq+0x154>)
{
 c040562:	4606      	mov	r6, r0
  pll3n = (RCC->PLL3DIVR & RCC_PLL3DIVR_PLL3N);
 c040564:	6c63      	ldr	r3, [r4, #68]	@ 0x44
 c040566:	f3c3 0808 	ubfx	r8, r3, #0, #9
  pll3source = (RCC->PLL3CFGR & RCC_PLL3CFGR_PLL3SRC);
 c04056a:	6b23      	ldr	r3, [r4, #48]	@ 0x30
  pll3m = ((RCC->PLL3CFGR & RCC_PLL3CFGR_PLL3M) >> RCC_PLL3CFGR_PLL3M_Pos) + 1U;
 c04056c:	6b25      	ldr	r5, [r4, #48]	@ 0x30
  pll3source = (RCC->PLL3CFGR & RCC_PLL3CFGR_PLL3SRC);
 c04056e:	f003 0903 	and.w	r9, r3, #3
  pll3fracen = ((RCC->PLL3CFGR & RCC_PLL3CFGR_PLL3FRACEN) >> RCC_PLL3CFGR_PLL3FRACEN_Pos);
 c040572:	6b20      	ldr	r0, [r4, #48]	@ 0x30
  fracn3 = (float_t)(uint32_t)(pll3fracen * ((RCC->PLL3FRACR & RCC_PLL3FRACR_PLL3FRACN) >> \
 c040574:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
  pll3fracen = ((RCC->PLL3CFGR & RCC_PLL3CFGR_PLL3FRACEN) >> RCC_PLL3CFGR_PLL3FRACEN_Pos);
 c040576:	f3c0 1000 	ubfx	r0, r0, #4, #1
  fracn3 = (float_t)(uint32_t)(pll3fracen * ((RCC->PLL3FRACR & RCC_PLL3FRACR_PLL3FRACN) >> \
 c04057a:	f3c3 03cc 	ubfx	r3, r3, #3, #13
 c04057e:	4358      	muls	r0, r3
 c040580:	f003 f850 	bl	c043624 <__aeabi_ui2f>
  pll3m = ((RCC->PLL3CFGR & RCC_PLL3CFGR_PLL3M) >> RCC_PLL3CFGR_PLL3M_Pos) + 1U;
 c040584:	f3c5 2503 	ubfx	r5, r5, #8, #4
                                             RCC_PLL3FRACR_PLL3FRACN_Pos));

  if (pll3m != 0U)
  {
    switch (pll3source)
 c040588:	f1b9 0f02 	cmp.w	r9, #2
  fracn3 = (float_t)(uint32_t)(pll3fracen * ((RCC->PLL3FRACR & RCC_PLL3FRACR_PLL3FRACN) >> \
 c04058c:	4607      	mov	r7, r0
  pll3m = ((RCC->PLL3CFGR & RCC_PLL3CFGR_PLL3M) >> RCC_PLL3CFGR_PLL3M_Pos) + 1U;
 c04058e:	f105 0501 	add.w	r5, r5, #1
    switch (pll3source)
 c040592:	d070      	beq.n	c040676 <HAL_RCCEx_GetPLL3ClockFreq+0x11a>
 c040594:	f1b9 0f03 	cmp.w	r9, #3
 c040598:	d06d      	beq.n	c040676 <HAL_RCCEx_GetPLL3ClockFreq+0x11a>
        pll3vco = ((float_t)HSE_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_PLL3N) + \
                                                           (fracn3 / (float_t)0x2000) + (float_t)1);
        break;

      default:
        pll3vco = ((float_t)MSIRangeTable[(__HAL_RCC_GET_MSI_RANGE() >> RCC_ICSCR1_MSISRANGE_Pos)] / (float_t)pll3m) * \
 c04059a:	68a3      	ldr	r3, [r4, #8]
 c04059c:	4a45      	ldr	r2, [pc, #276]	@ (c0406b4 <HAL_RCCEx_GetPLL3ClockFreq+0x158>)
 c04059e:	021b      	lsls	r3, r3, #8
 c0405a0:	bf4b      	itete	mi
 c0405a2:	68a3      	ldrmi	r3, [r4, #8]
 c0405a4:	f8d4 30f4 	ldrpl.w	r3, [r4, #244]	@ 0xf4
 c0405a8:	0f1b      	lsrmi	r3, r3, #28
 c0405aa:	f3c3 3303 	ubfxpl	r3, r3, #12, #4
 c0405ae:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
 c0405b2:	f003 f837 	bl	c043624 <__aeabi_ui2f>
 c0405b6:	4604      	mov	r4, r0
 c0405b8:	4628      	mov	r0, r5
 c0405ba:	f003 f833 	bl	c043624 <__aeabi_ui2f>
 c0405be:	4601      	mov	r1, r0
 c0405c0:	4620      	mov	r0, r4
 c0405c2:	f003 f93b 	bl	c04383c <__aeabi_fdiv>
 c0405c6:	4604      	mov	r4, r0
                  ((float_t)pll3n + (fracn3 / (float_t)0x2000) + (float_t)1);
 c0405c8:	4640      	mov	r0, r8
 c0405ca:	f003 f82b 	bl	c043624 <__aeabi_ui2f>
 c0405ce:	f04f 5164 	mov.w	r1, #956301312	@ 0x39000000
 c0405d2:	4605      	mov	r5, r0
 c0405d4:	4638      	mov	r0, r7
 c0405d6:	f003 f87d 	bl	c0436d4 <__aeabi_fmul>
 c0405da:	4601      	mov	r1, r0
 c0405dc:	4628      	mov	r0, r5
 c0405de:	f002 ff71 	bl	c0434c4 <__addsf3>
 c0405e2:	f04f 517e 	mov.w	r1, #1065353216	@ 0x3f800000
 c0405e6:	f002 ff6d 	bl	c0434c4 <__addsf3>
 c0405ea:	4601      	mov	r1, r0
        pll3vco = ((float_t)MSIRangeTable[(__HAL_RCC_GET_MSI_RANGE() >> RCC_ICSCR1_MSISRANGE_Pos)] / (float_t)pll3m) * \
 c0405ec:	4620      	mov	r0, r4
 c0405ee:	f003 f871 	bl	c0436d4 <__aeabi_fmul>
        break;
    }

    if (__HAL_RCC_GET_PLL3CLKOUT_CONFIG(RCC_PLL3_DIVP) != 0U)
 c0405f2:	4b2f      	ldr	r3, [pc, #188]	@ (c0406b0 <HAL_RCCEx_GetPLL3ClockFreq+0x154>)
        pll3vco = ((float_t)MSIRangeTable[(__HAL_RCC_GET_MSI_RANGE() >> RCC_ICSCR1_MSISRANGE_Pos)] / (float_t)pll3m) * \
 c0405f4:	4604      	mov	r4, r0
    if (__HAL_RCC_GET_PLL3CLKOUT_CONFIG(RCC_PLL3_DIVP) != 0U)
 c0405f6:	6b18      	ldr	r0, [r3, #48]	@ 0x30
 c0405f8:	f410 3080 	ands.w	r0, r0, #65536	@ 0x10000
 c0405fc:	d00e      	beq.n	c04061c <HAL_RCCEx_GetPLL3ClockFreq+0xc0>
    {
      PLL3_Clocks->PLL3_P_Frequency = (uint32_t)(float_t)(pll3vco / ((float_t)(uint32_t)((RCC->PLL3DIVR & \
 c0405fe:	6c58      	ldr	r0, [r3, #68]	@ 0x44
 c040600:	f3c0 2046 	ubfx	r0, r0, #9, #7
 c040604:	f003 f80e 	bl	c043624 <__aeabi_ui2f>
                                                                     RCC_PLL3DIVR_PLL3P) >> RCC_PLL3DIVR_PLL3P_Pos) + \
 c040608:	f04f 517e 	mov.w	r1, #1065353216	@ 0x3f800000
 c04060c:	f002 ff5a 	bl	c0434c4 <__addsf3>
 c040610:	4601      	mov	r1, r0
      PLL3_Clocks->PLL3_P_Frequency = (uint32_t)(float_t)(pll3vco / ((float_t)(uint32_t)((RCC->PLL3DIVR & \
 c040612:	4620      	mov	r0, r4
 c040614:	f003 f912 	bl	c04383c <__aeabi_fdiv>
 c040618:	f003 f9ac 	bl	c043974 <__aeabi_f2uiz>
    else
    {
      PLL3_Clocks->PLL3_P_Frequency = 0U;
    }

    if (__HAL_RCC_GET_PLL3CLKOUT_CONFIG(RCC_PLL3_DIVQ) != 0U)
 c04061c:	4b24      	ldr	r3, [pc, #144]	@ (c0406b0 <HAL_RCCEx_GetPLL3ClockFreq+0x154>)
 c04061e:	6030      	str	r0, [r6, #0]
 c040620:	6b18      	ldr	r0, [r3, #48]	@ 0x30
 c040622:	f410 3000 	ands.w	r0, r0, #131072	@ 0x20000
 c040626:	d00e      	beq.n	c040646 <HAL_RCCEx_GetPLL3ClockFreq+0xea>
    {
      PLL3_Clocks->PLL3_Q_Frequency = (uint32_t)(float_t)(pll3vco / ((float_t)(uint32_t)((RCC->PLL3DIVR & \
 c040628:	6c58      	ldr	r0, [r3, #68]	@ 0x44
 c04062a:	f3c0 4006 	ubfx	r0, r0, #16, #7
 c04062e:	f002 fff9 	bl	c043624 <__aeabi_ui2f>
                                                                     RCC_PLL3DIVR_PLL3Q) >> RCC_PLL3DIVR_PLL3Q_Pos) + \
 c040632:	f04f 517e 	mov.w	r1, #1065353216	@ 0x3f800000
 c040636:	f002 ff45 	bl	c0434c4 <__addsf3>
 c04063a:	4601      	mov	r1, r0
      PLL3_Clocks->PLL3_Q_Frequency = (uint32_t)(float_t)(pll3vco / ((float_t)(uint32_t)((RCC->PLL3DIVR & \
 c04063c:	4620      	mov	r0, r4
 c04063e:	f003 f8fd 	bl	c04383c <__aeabi_fdiv>
 c040642:	f003 f997 	bl	c043974 <__aeabi_f2uiz>
    else
    {
      PLL3_Clocks->PLL3_Q_Frequency = 0U;
    }

    if (__HAL_RCC_GET_PLL3CLKOUT_CONFIG(RCC_PLL3_DIVR) != 0U)
 c040646:	4a1a      	ldr	r2, [pc, #104]	@ (c0406b0 <HAL_RCCEx_GetPLL3ClockFreq+0x154>)
 c040648:	6070      	str	r0, [r6, #4]
 c04064a:	6b10      	ldr	r0, [r2, #48]	@ 0x30
 c04064c:	f410 2080 	ands.w	r0, r0, #262144	@ 0x40000
 c040650:	d00e      	beq.n	c040670 <HAL_RCCEx_GetPLL3ClockFreq+0x114>
    {
      PLL3_Clocks->PLL3_R_Frequency = (uint32_t)(float_t)(pll3vco / ((float_t)(uint32_t)((RCC->PLL3DIVR & \
 c040652:	6c50      	ldr	r0, [r2, #68]	@ 0x44
 c040654:	f3c0 6006 	ubfx	r0, r0, #24, #7
 c040658:	f002 ffe4 	bl	c043624 <__aeabi_ui2f>
                                                                     RCC_PLL3DIVR_PLL3R) >> RCC_PLL3DIVR_PLL3R_Pos) + \
 c04065c:	f04f 517e 	mov.w	r1, #1065353216	@ 0x3f800000
 c040660:	f002 ff30 	bl	c0434c4 <__addsf3>
 c040664:	4601      	mov	r1, r0
      PLL3_Clocks->PLL3_R_Frequency = (uint32_t)(float_t)(pll3vco / ((float_t)(uint32_t)((RCC->PLL3DIVR & \
 c040666:	4620      	mov	r0, r4
 c040668:	f003 f8e8 	bl	c04383c <__aeabi_fdiv>
 c04066c:	f003 f982 	bl	c043974 <__aeabi_f2uiz>
 c040670:	60b0      	str	r0, [r6, #8]
  {
    PLL3_Clocks->PLL3_P_Frequency = 0U;
    PLL3_Clocks->PLL3_Q_Frequency = 0U;
    PLL3_Clocks->PLL3_R_Frequency = 0U;
  }
}
 c040672:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        pll3vco = ((float_t)HSE_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_PLL3N) + \
 c040676:	6c60      	ldr	r0, [r4, #68]	@ 0x44
 c040678:	f3c0 0008 	ubfx	r0, r0, #0, #9
 c04067c:	f002 ffd2 	bl	c043624 <__aeabi_ui2f>
                                                           (fracn3 / (float_t)0x2000) + (float_t)1);
 c040680:	f04f 5164 	mov.w	r1, #956301312	@ 0x39000000
        pll3vco = ((float_t)HSE_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_PLL3N) + \
 c040684:	4604      	mov	r4, r0
                                                           (fracn3 / (float_t)0x2000) + (float_t)1);
 c040686:	4638      	mov	r0, r7
 c040688:	f003 f824 	bl	c0436d4 <__aeabi_fmul>
 c04068c:	4601      	mov	r1, r0
        pll3vco = ((float_t)HSE_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_PLL3N) + \
 c04068e:	4620      	mov	r0, r4
 c040690:	f002 ff18 	bl	c0434c4 <__addsf3>
                                                           (fracn3 / (float_t)0x2000) + (float_t)1);
 c040694:	f04f 517e 	mov.w	r1, #1065353216	@ 0x3f800000
 c040698:	f002 ff14 	bl	c0434c4 <__addsf3>
 c04069c:	4604      	mov	r4, r0
        pll3vco = ((float_t)HSE_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_PLL3N) + \
 c04069e:	4628      	mov	r0, r5
 c0406a0:	f002 ffc0 	bl	c043624 <__aeabi_ui2f>
 c0406a4:	4601      	mov	r1, r0
 c0406a6:	4804      	ldr	r0, [pc, #16]	@ (c0406b8 <HAL_RCCEx_GetPLL3ClockFreq+0x15c>)
 c0406a8:	f003 f8c8 	bl	c04383c <__aeabi_fdiv>
 c0406ac:	e79d      	b.n	c0405ea <HAL_RCCEx_GetPLL3ClockFreq+0x8e>
 c0406ae:	bf00      	nop
 c0406b0:	56020c00 	.word	0x56020c00
 c0406b4:	0c05fa94 	.word	0x0c05fa94
 c0406b8:	4b742400 	.word	0x4b742400

0c0406bc <HAL_RCCEx_GetPeriphCLKFreq>:
  * @retval Frequency in Hz
  *
  *        (*) value not defined in all devices.
  */
uint32_t HAL_RCCEx_GetPeriphCLKFreq(uint64_t PeriphClk)
{
 c0406bc:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 c0406be:	f5a0 4380 	sub.w	r3, r0, #16384	@ 0x4000
 c0406c2:	430b      	orrs	r3, r1
 c0406c4:	f000 8115 	beq.w	c0408f2 <HAL_RCCEx_GetPeriphCLKFreq+0x236>
 c0406c8:	f244 0301 	movw	r3, #16385	@ 0x4001
 c0406cc:	4298      	cmp	r0, r3
 c0406ce:	f171 0300 	sbcs.w	r3, r1, #0
 c0406d2:	d25f      	bcs.n	c040794 <HAL_RCCEx_GetPeriphCLKFreq+0xd8>
 c0406d4:	f1a0 0380 	sub.w	r3, r0, #128	@ 0x80
 c0406d8:	430b      	orrs	r3, r1
 c0406da:	f000 8362 	beq.w	c040da2 <HAL_RCCEx_GetPeriphCLKFreq+0x6e6>
 c0406de:	2881      	cmp	r0, #129	@ 0x81
 c0406e0:	f171 0300 	sbcs.w	r3, r1, #0
 c0406e4:	d22e      	bcs.n	c040744 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
 c0406e6:	2809      	cmp	r0, #9
 c0406e8:	f171 0300 	sbcs.w	r3, r1, #0
 c0406ec:	d218      	bcs.n	c040720 <HAL_RCCEx_GetPeriphCLKFreq+0x64>
 c0406ee:	ea50 0301 	orrs.w	r3, r0, r1
 c0406f2:	f000 85ba 	beq.w	c04126a <HAL_RCCEx_GetPeriphCLKFreq+0xbae>
 c0406f6:	3801      	subs	r0, #1
 c0406f8:	f141 31ff 	adc.w	r1, r1, #4294967295	@ 0xffffffff
 c0406fc:	2808      	cmp	r0, #8
 c0406fe:	f171 0100 	sbcs.w	r1, r1, #0
 c040702:	f080 85b5 	bcs.w	c041270 <HAL_RCCEx_GetPeriphCLKFreq+0xbb4>
 c040706:	2807      	cmp	r0, #7
 c040708:	f200 85b2 	bhi.w	c041270 <HAL_RCCEx_GetPeriphCLKFreq+0xbb4>
 c04070c:	e8df f010 	tbh	[pc, r0, lsl #1]
 c040710:	01d101aa 	.word	0x01d101aa
 c040714:	01f105b0 	.word	0x01f105b0
 c040718:	05b005b0 	.word	0x05b005b0
 c04071c:	020e05b0 	.word	0x020e05b0
 c040720:	f1a0 0320 	sub.w	r3, r0, #32
 c040724:	430b      	orrs	r3, r1
 c040726:	f000 823b 	beq.w	c040ba0 <HAL_RCCEx_GetPeriphCLKFreq+0x4e4>
 c04072a:	f1a0 0340 	sub.w	r3, r0, #64	@ 0x40
 c04072e:	430b      	orrs	r3, r1
 c040730:	f000 830c 	beq.w	c040d4c <HAL_RCCEx_GetPeriphCLKFreq+0x690>
 c040734:	3810      	subs	r0, #16
 c040736:	4308      	orrs	r0, r1
 c040738:	f000 8213 	beq.w	c040b62 <HAL_RCCEx_GetPeriphCLKFreq+0x4a6>
        {
          frequency = HSI_VALUE;
        }
        else
        {
          frequency = 0U;
 c04073c:	2000      	movs	r0, #0
  else
  {
    frequency = 0;
  }
  return (frequency);
}
 c04073e:	b005      	add	sp, #20
 c040740:	f85d fb04 	ldr.w	pc, [sp], #4
 c040744:	f5a0 6300 	sub.w	r3, r0, #2048	@ 0x800
 c040748:	430b      	orrs	r3, r1
 c04074a:	f000 83af 	beq.w	c040eac <HAL_RCCEx_GetPeriphCLKFreq+0x7f0>
 c04074e:	f640 0301 	movw	r3, #2049	@ 0x801
 c040752:	4298      	cmp	r0, r3
 c040754:	f171 0300 	sbcs.w	r3, r1, #0
 c040758:	d210      	bcs.n	c04077c <HAL_RCCEx_GetPeriphCLKFreq+0xc0>
 c04075a:	f5a0 7300 	sub.w	r3, r0, #512	@ 0x200
 c04075e:	430b      	orrs	r3, r1
 c040760:	f000 83e4 	beq.w	c040f2c <HAL_RCCEx_GetPeriphCLKFreq+0x870>
 c040764:	f5a0 6380 	sub.w	r3, r0, #1024	@ 0x400
 c040768:	430b      	orrs	r3, r1
 c04076a:	f000 8420 	beq.w	c040fae <HAL_RCCEx_GetPeriphCLKFreq+0x8f2>
 c04076e:	f5a0 7080 	sub.w	r0, r0, #256	@ 0x100
 c040772:	4308      	orrs	r0, r1
 c040774:	f000 8340 	beq.w	c040df8 <HAL_RCCEx_GetPeriphCLKFreq+0x73c>
          frequency = 0U;
 c040778:	2000      	movs	r0, #0
 c04077a:	e7e0      	b.n	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
 c04077c:	f5a0 5380 	sub.w	r3, r0, #4096	@ 0x1000
 c040780:	430b      	orrs	r3, r1
 c040782:	f000 80d5 	beq.w	c040930 <HAL_RCCEx_GetPeriphCLKFreq+0x274>
 c040786:	f5a0 5000 	sub.w	r0, r0, #8192	@ 0x2000
 c04078a:	4308      	orrs	r0, r1
 c04078c:	f000 8087 	beq.w	c04089e <HAL_RCCEx_GetPeriphCLKFreq+0x1e2>
 c040790:	2000      	movs	r0, #0
 c040792:	e7d4      	b.n	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
 c040794:	f5a0 0380 	sub.w	r3, r0, #4194304	@ 0x400000
 c040798:	430b      	orrs	r3, r1
 c04079a:	f000 835c 	beq.w	c040e56 <HAL_RCCEx_GetPeriphCLKFreq+0x79a>
 c04079e:	4ba8      	ldr	r3, [pc, #672]	@ (c040a40 <HAL_RCCEx_GetPeriphCLKFreq+0x384>)
 c0407a0:	4298      	cmp	r0, r3
 c0407a2:	f171 0300 	sbcs.w	r3, r1, #0
 c0407a6:	d22a      	bcs.n	c0407fe <HAL_RCCEx_GetPeriphCLKFreq+0x142>
 c0407a8:	f5a0 2380 	sub.w	r3, r0, #262144	@ 0x40000
 c0407ac:	430b      	orrs	r3, r1
 c0407ae:	d04d      	beq.n	c04084c <HAL_RCCEx_GetPeriphCLKFreq+0x190>
 c0407b0:	4ba4      	ldr	r3, [pc, #656]	@ (c040a44 <HAL_RCCEx_GetPeriphCLKFreq+0x388>)
 c0407b2:	4298      	cmp	r0, r3
 c0407b4:	f171 0300 	sbcs.w	r3, r1, #0
 c0407b8:	d210      	bcs.n	c0407dc <HAL_RCCEx_GetPeriphCLKFreq+0x120>
 c0407ba:	f5a0 3380 	sub.w	r3, r0, #65536	@ 0x10000
 c0407be:	430b      	orrs	r3, r1
 c0407c0:	f000 8262 	beq.w	c040c88 <HAL_RCCEx_GetPeriphCLKFreq+0x5cc>
 c0407c4:	f5a0 3300 	sub.w	r3, r0, #131072	@ 0x20000
 c0407c8:	430b      	orrs	r3, r1
 c0407ca:	f000 828c 	beq.w	c040ce6 <HAL_RCCEx_GetPeriphCLKFreq+0x62a>
 c0407ce:	f5a0 4000 	sub.w	r0, r0, #32768	@ 0x8000
 c0407d2:	4308      	orrs	r0, r1
 c0407d4:	f000 8217 	beq.w	c040c06 <HAL_RCCEx_GetPeriphCLKFreq+0x54a>
 c0407d8:	2000      	movs	r0, #0
 c0407da:	e7b0      	b.n	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
 c0407dc:	f5a0 1380 	sub.w	r3, r0, #1048576	@ 0x100000
 c0407e0:	430b      	orrs	r3, r1
 c0407e2:	f000 80ba 	beq.w	c04095a <HAL_RCCEx_GetPeriphCLKFreq+0x29e>
 c0407e6:	f5a0 1300 	sub.w	r3, r0, #2097152	@ 0x200000
 c0407ea:	430b      	orrs	r3, r1
 c0407ec:	f000 80e9 	beq.w	c0409c2 <HAL_RCCEx_GetPeriphCLKFreq+0x306>
 c0407f0:	f5a0 2000 	sub.w	r0, r0, #524288	@ 0x80000
 c0407f4:	4308      	orrs	r0, r1
 c0407f6:	f000 851a 	beq.w	c04122e <HAL_RCCEx_GetPeriphCLKFreq+0xb72>
 c0407fa:	2000      	movs	r0, #0
 c0407fc:	e79f      	b.n	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
 c0407fe:	f100 437c 	add.w	r3, r0, #4227858432	@ 0xfc000000
 c040802:	430b      	orrs	r3, r1
 c040804:	f000 84c4 	beq.w	c041190 <HAL_RCCEx_GetPeriphCLKFreq+0xad4>
 c040808:	4b8f      	ldr	r3, [pc, #572]	@ (c040a48 <HAL_RCCEx_GetPeriphCLKFreq+0x38c>)
 c04080a:	4298      	cmp	r0, r3
 c04080c:	f171 0300 	sbcs.w	r3, r1, #0
 c040810:	d210      	bcs.n	c040834 <HAL_RCCEx_GetPeriphCLKFreq+0x178>
 c040812:	f100 437f 	add.w	r3, r0, #4278190080	@ 0xff000000
 c040816:	430b      	orrs	r3, r1
 c040818:	f000 8451 	beq.w	c0410be <HAL_RCCEx_GetPeriphCLKFreq+0xa02>
 c04081c:	f100 437e 	add.w	r3, r0, #4261412864	@ 0xfe000000
 c040820:	430b      	orrs	r3, r1
 c040822:	f000 8482 	beq.w	c04112a <HAL_RCCEx_GetPeriphCLKFreq+0xa6e>
 c040826:	f5a0 0000 	sub.w	r0, r0, #8388608	@ 0x800000
 c04082a:	4308      	orrs	r0, r1
 c04082c:	f000 8411 	beq.w	c041052 <HAL_RCCEx_GetPeriphCLKFreq+0x996>
 c040830:	2000      	movs	r0, #0
 c040832:	e784      	b.n	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
 c040834:	f100 4378 	add.w	r3, r0, #4160749568	@ 0xf8000000
 c040838:	430b      	orrs	r3, r1
 c04083a:	f000 83ec 	beq.w	c041016 <HAL_RCCEx_GetPeriphCLKFreq+0x95a>
 c04083e:	f100 4070 	add.w	r0, r0, #4026531840	@ 0xf0000000
 c040842:	4308      	orrs	r0, r1
 c040844:	f000 84d4 	beq.w	c0411f0 <HAL_RCCEx_GetPeriphCLKFreq+0xb34>
 c040848:	2000      	movs	r0, #0
 c04084a:	e778      	b.n	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
    srcclk = __HAL_RCC_GET_RTC_SOURCE();
 c04084c:	4a7f      	ldr	r2, [pc, #508]	@ (c040a4c <HAL_RCCEx_GetPeriphCLKFreq+0x390>)
 c04084e:	f8d2 30f0 	ldr.w	r3, [r2, #240]	@ 0xf0
    if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_RTCCLKSOURCE_LSE))
 c040852:	f8d2 10f0 	ldr.w	r1, [r2, #240]	@ 0xf0
    srcclk = __HAL_RCC_GET_RTC_SOURCE();
 c040856:	f403 7340 	and.w	r3, r3, #768	@ 0x300
    if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_RTCCLKSOURCE_LSE))
 c04085a:	0789      	lsls	r1, r1, #30
 c04085c:	d503      	bpl.n	c040866 <HAL_RCCEx_GetPeriphCLKFreq+0x1aa>
 c04085e:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 c040862:	f000 8508 	beq.w	c041276 <HAL_RCCEx_GetPeriphCLKFreq+0xbba>
    else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIRDY)) && (srcclk == RCC_RTCCLKSOURCE_LSI))
 c040866:	f8d2 10f0 	ldr.w	r1, [r2, #240]	@ 0xf0
 c04086a:	0109      	lsls	r1, r1, #4
 c04086c:	d50b      	bpl.n	c040886 <HAL_RCCEx_GetPeriphCLKFreq+0x1ca>
 c04086e:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 c040872:	d108      	bne.n	c040886 <HAL_RCCEx_GetPeriphCLKFreq+0x1ca>
      if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIPREDIV))
 c040874:	f8d2 30f0 	ldr.w	r3, [r2, #240]	@ 0xf0
        frequency = LSI_VALUE / 128U;
 c040878:	f013 5f80 	tst.w	r3, #268435456	@ 0x10000000
 c04087c:	bf0c      	ite	eq
 c04087e:	f44f 40fa 	moveq.w	r0, #32000	@ 0x7d00
 c040882:	20fa      	movne	r0, #250	@ 0xfa
 c040884:	e75b      	b.n	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)) && (srcclk == RCC_RTCCLKSOURCE_HSE_DIV32))
 c040886:	4a71      	ldr	r2, [pc, #452]	@ (c040a4c <HAL_RCCEx_GetPeriphCLKFreq+0x390>)
 c040888:	6810      	ldr	r0, [r2, #0]
 c04088a:	f410 3000 	ands.w	r0, r0, #131072	@ 0x20000
 c04088e:	f43f af56 	beq.w	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
      frequency = HSE_VALUE / 32U;
 c040892:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
 c040896:	486e      	ldr	r0, [pc, #440]	@ (c040a50 <HAL_RCCEx_GetPeriphCLKFreq+0x394>)
 c040898:	bf18      	it	ne
 c04089a:	2000      	movne	r0, #0
 c04089c:	e74f      	b.n	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
    srcclk = __HAL_RCC_GET_SAI1_SOURCE();
 c04089e:	4a6b      	ldr	r2, [pc, #428]	@ (c040a4c <HAL_RCCEx_GetPeriphCLKFreq+0x390>)
 c0408a0:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
 c0408a4:	f003 03e0 	and.w	r3, r3, #224	@ 0xe0
    switch (srcclk)
 c0408a8:	2b40      	cmp	r3, #64	@ 0x40
 c0408aa:	d00c      	beq.n	c0408c6 <HAL_RCCEx_GetPeriphCLKFreq+0x20a>
 c0408ac:	d804      	bhi.n	c0408b8 <HAL_RCCEx_GetPeriphCLKFreq+0x1fc>
 c0408ae:	b17b      	cbz	r3, c0408d0 <HAL_RCCEx_GetPeriphCLKFreq+0x214>
 c0408b0:	2b20      	cmp	r3, #32
 c0408b2:	d012      	beq.n	c0408da <HAL_RCCEx_GetPeriphCLKFreq+0x21e>
          frequency = 0U;
 c0408b4:	2000      	movs	r0, #0
 c0408b6:	e742      	b.n	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
    switch (srcclk)
 c0408b8:	2b60      	cmp	r3, #96	@ 0x60
 c0408ba:	f000 84e0 	beq.w	c04127e <HAL_RCCEx_GetPeriphCLKFreq+0xbc2>
 c0408be:	2b80      	cmp	r3, #128	@ 0x80
 c0408c0:	d010      	beq.n	c0408e4 <HAL_RCCEx_GetPeriphCLKFreq+0x228>
          frequency = 0U;
 c0408c2:	2000      	movs	r0, #0
 c0408c4:	e73b      	b.n	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
        HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
 c0408c6:	a801      	add	r0, sp, #4
 c0408c8:	f7ff fce8 	bl	c04029c <HAL_RCCEx_GetPLL1ClockFreq>
        frequency = pll1_clocks.PLL1_P_Frequency;
 c0408cc:	9801      	ldr	r0, [sp, #4]
        break;
 c0408ce:	e736      	b.n	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
        HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 c0408d0:	a801      	add	r0, sp, #4
 c0408d2:	f7ff fd93 	bl	c0403fc <HAL_RCCEx_GetPLL2ClockFreq>
        frequency = pll2_clocks.PLL2_P_Frequency;
 c0408d6:	9801      	ldr	r0, [sp, #4]
        break;
 c0408d8:	e731      	b.n	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
        HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 c0408da:	a801      	add	r0, sp, #4
 c0408dc:	f7ff fe3e 	bl	c04055c <HAL_RCCEx_GetPLL3ClockFreq>
        frequency = pll3_clocks.PLL3_P_Frequency;
 c0408e0:	9801      	ldr	r0, [sp, #4]
        break;
 c0408e2:	e72c      	b.n	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
 c0408e4:	6810      	ldr	r0, [r2, #0]
          frequency = HSI_VALUE;
 c0408e6:	4b5b      	ldr	r3, [pc, #364]	@ (c040a54 <HAL_RCCEx_GetPeriphCLKFreq+0x398>)
 c0408e8:	f410 6080 	ands.w	r0, r0, #1024	@ 0x400
 c0408ec:	bf18      	it	ne
 c0408ee:	4618      	movne	r0, r3
 c0408f0:	e725      	b.n	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
    srcclk = __HAL_RCC_GET_SAI2_SOURCE();
 c0408f2:	4a56      	ldr	r2, [pc, #344]	@ (c040a4c <HAL_RCCEx_GetPeriphCLKFreq+0x390>)
 c0408f4:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
 c0408f8:	f403 63e0 	and.w	r3, r3, #1792	@ 0x700
    switch (srcclk)
 c0408fc:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 c040900:	d0e1      	beq.n	c0408c6 <HAL_RCCEx_GetPeriphCLKFreq+0x20a>
 c040902:	d806      	bhi.n	c040912 <HAL_RCCEx_GetPeriphCLKFreq+0x256>
 c040904:	2b00      	cmp	r3, #0
 c040906:	d0e3      	beq.n	c0408d0 <HAL_RCCEx_GetPeriphCLKFreq+0x214>
 c040908:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 c04090c:	d0e5      	beq.n	c0408da <HAL_RCCEx_GetPeriphCLKFreq+0x21e>
          frequency = 0U;
 c04090e:	2000      	movs	r0, #0
 c040910:	e715      	b.n	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
    switch (srcclk)
 c040912:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
 c040916:	f000 84b6 	beq.w	c041286 <HAL_RCCEx_GetPeriphCLKFreq+0xbca>
 c04091a:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 c04091e:	f040 84b6 	bne.w	c04128e <HAL_RCCEx_GetPeriphCLKFreq+0xbd2>
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
 c040922:	6810      	ldr	r0, [r2, #0]
          frequency = HSI_VALUE;
 c040924:	4b4b      	ldr	r3, [pc, #300]	@ (c040a54 <HAL_RCCEx_GetPeriphCLKFreq+0x398>)
 c040926:	f410 6080 	ands.w	r0, r0, #1024	@ 0x400
 c04092a:	bf18      	it	ne
 c04092c:	4618      	movne	r0, r3
 c04092e:	e706      	b.n	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
    srcclk = __HAL_RCC_GET_SAES_SOURCE();
 c040930:	4a46      	ldr	r2, [pc, #280]	@ (c040a4c <HAL_RCCEx_GetPeriphCLKFreq+0x390>)
 c040932:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
    if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY) && (srcclk == RCC_SAESCLKSOURCE_SHSI))
 c040936:	6811      	ldr	r1, [r2, #0]
    srcclk = __HAL_RCC_GET_SAES_SOURCE();
 c040938:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
    if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY) && (srcclk == RCC_SAESCLKSOURCE_SHSI))
 c04093c:	0549      	lsls	r1, r1, #21
 c04093e:	d502      	bpl.n	c040946 <HAL_RCCEx_GetPeriphCLKFreq+0x28a>
 c040940:	2b00      	cmp	r3, #0
 c040942:	f000 84a7 	beq.w	c041294 <HAL_RCCEx_GetPeriphCLKFreq+0xbd8>
    else if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY) && (srcclk == RCC_SAESCLKSOURCE_SHSI_DIV2))
 c040946:	6810      	ldr	r0, [r2, #0]
 c040948:	f410 6080 	ands.w	r0, r0, #1024	@ 0x400
 c04094c:	f43f aef7 	beq.w	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
      frequency = HSI_VALUE >> 1U;
 c040950:	2b00      	cmp	r3, #0
 c040952:	4841      	ldr	r0, [pc, #260]	@ (c040a58 <HAL_RCCEx_GetPeriphCLKFreq+0x39c>)
 c040954:	bf08      	it	eq
 c040956:	2000      	moveq	r0, #0
 c040958:	e6f1      	b.n	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
    srcclk = __HAL_RCC_GET_ICLK_SOURCE();
 c04095a:	4b3c      	ldr	r3, [pc, #240]	@ (c040a4c <HAL_RCCEx_GetPeriphCLKFreq+0x390>)
 c04095c:	f8d3 20e0 	ldr.w	r2, [r3, #224]	@ 0xe0
 c040960:	f002 6240 	and.w	r2, r2, #201326592	@ 0xc000000
    switch (srcclk)
 c040964:	f1b2 6f00 	cmp.w	r2, #134217728	@ 0x8000000
 c040968:	d00b      	beq.n	c040982 <HAL_RCCEx_GetPeriphCLKFreq+0x2c6>
 c04096a:	d805      	bhi.n	c040978 <HAL_RCCEx_GetPeriphCLKFreq+0x2bc>
 c04096c:	b172      	cbz	r2, c04098c <HAL_RCCEx_GetPeriphCLKFreq+0x2d0>
 c04096e:	f1b2 6f80 	cmp.w	r2, #67108864	@ 0x4000000
 c040972:	d039      	beq.n	c0409e8 <HAL_RCCEx_GetPeriphCLKFreq+0x32c>
          frequency = 0U;
 c040974:	2000      	movs	r0, #0
 c040976:	e6e2      	b.n	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
    switch (srcclk)
 c040978:	f1b2 6f40 	cmp.w	r2, #201326592	@ 0xc000000
 c04097c:	d00d      	beq.n	c04099a <HAL_RCCEx_GetPeriphCLKFreq+0x2de>
          frequency = 0U;
 c04097e:	2000      	movs	r0, #0
 c040980:	e6dd      	b.n	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
        HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
 c040982:	a801      	add	r0, sp, #4
 c040984:	f7ff fc8a 	bl	c04029c <HAL_RCCEx_GetPLL1ClockFreq>
        frequency = pll1_clocks.PLL1_Q_Frequency;
 c040988:	9802      	ldr	r0, [sp, #8]
        break;
 c04098a:	e6d8      	b.n	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSI48RDY))
 c04098c:	6818      	ldr	r0, [r3, #0]
          frequency = HSI48_VALUE;
 c04098e:	4b33      	ldr	r3, [pc, #204]	@ (c040a5c <HAL_RCCEx_GetPeriphCLKFreq+0x3a0>)
 c040990:	f410 5000 	ands.w	r0, r0, #8192	@ 0x2000
 c040994:	bf18      	it	ne
 c040996:	4618      	movne	r0, r3
 c040998:	e6d1      	b.n	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIKRDY))
 c04099a:	6818      	ldr	r0, [r3, #0]
 c04099c:	f010 0020 	ands.w	r0, r0, #32
 c0409a0:	f43f aecd 	beq.w	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
          frequency = MSIRangeTable[(__HAL_RCC_GET_MSIK_RANGE() >> RCC_ICSCR1_MSIKRANGE_Pos)];
 c0409a4:	689a      	ldr	r2, [r3, #8]
 c0409a6:	0210      	lsls	r0, r2, #8
 c0409a8:	bf4c      	ite	mi
 c0409aa:	689b      	ldrmi	r3, [r3, #8]
 c0409ac:	f8d3 30f4 	ldrpl.w	r3, [r3, #244]	@ 0xf4
 c0409b0:	4a2b      	ldr	r2, [pc, #172]	@ (c040a60 <HAL_RCCEx_GetPeriphCLKFreq+0x3a4>)
 c0409b2:	bf4c      	ite	mi
 c0409b4:	f3c3 6303 	ubfxmi	r3, r3, #24, #4
 c0409b8:	f3c3 2303 	ubfxpl	r3, r3, #8, #4
 c0409bc:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
 c0409c0:	e6bd      	b.n	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
    srcclk = __HAL_RCC_GET_SDMMC_SOURCE();
 c0409c2:	4b22      	ldr	r3, [pc, #136]	@ (c040a4c <HAL_RCCEx_GetPeriphCLKFreq+0x390>)
 c0409c4:	f8d3 00e4 	ldr.w	r0, [r3, #228]	@ 0xe4
    if (srcclk == RCC_SDMMCCLKSOURCE_CLK48)
 c0409c8:	f410 4080 	ands.w	r0, r0, #16384	@ 0x4000
 c0409cc:	d132      	bne.n	c040a34 <HAL_RCCEx_GetPeriphCLKFreq+0x378>
      srcclk = __HAL_RCC_GET_ICLK_SOURCE();
 c0409ce:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 c0409d2:	f003 6340 	and.w	r3, r3, #201326592	@ 0xc000000
      switch (srcclk)
 c0409d6:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
 c0409da:	d0d2      	beq.n	c040982 <HAL_RCCEx_GetPeriphCLKFreq+0x2c6>
 c0409dc:	d809      	bhi.n	c0409f2 <HAL_RCCEx_GetPeriphCLKFreq+0x336>
 c0409de:	b30b      	cbz	r3, c040a24 <HAL_RCCEx_GetPeriphCLKFreq+0x368>
 c0409e0:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
 c0409e4:	f47f aeab 	bne.w	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
        HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 c0409e8:	a801      	add	r0, sp, #4
 c0409ea:	f7ff fd07 	bl	c0403fc <HAL_RCCEx_GetPLL2ClockFreq>
        frequency = pll2_clocks.PLL2_Q_Frequency;
 c0409ee:	9802      	ldr	r0, [sp, #8]
        break;
 c0409f0:	e6a5      	b.n	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
      switch (srcclk)
 c0409f2:	f1b3 6f40 	cmp.w	r3, #201326592	@ 0xc000000
 c0409f6:	f47f aea2 	bne.w	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
          if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIKRDY))
 c0409fa:	4b14      	ldr	r3, [pc, #80]	@ (c040a4c <HAL_RCCEx_GetPeriphCLKFreq+0x390>)
 c0409fc:	6818      	ldr	r0, [r3, #0]
 c0409fe:	f010 0020 	ands.w	r0, r0, #32
 c040a02:	f43f ae9c 	beq.w	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
            frequency = MSIRangeTable[(__HAL_RCC_GET_MSIK_RANGE() >> RCC_ICSCR1_MSIKRANGE_Pos)];
 c040a06:	689a      	ldr	r2, [r3, #8]
 c040a08:	0211      	lsls	r1, r2, #8
 c040a0a:	bf4c      	ite	mi
 c040a0c:	689b      	ldrmi	r3, [r3, #8]
 c040a0e:	f8d3 30f4 	ldrpl.w	r3, [r3, #244]	@ 0xf4
 c040a12:	4a13      	ldr	r2, [pc, #76]	@ (c040a60 <HAL_RCCEx_GetPeriphCLKFreq+0x3a4>)
 c040a14:	bf4c      	ite	mi
 c040a16:	f3c3 6303 	ubfxmi	r3, r3, #24, #4
 c040a1a:	f3c3 2303 	ubfxpl	r3, r3, #8, #4
 c040a1e:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
 c040a22:	e68c      	b.n	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
          if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSI48RDY))
 c040a24:	4b09      	ldr	r3, [pc, #36]	@ (c040a4c <HAL_RCCEx_GetPeriphCLKFreq+0x390>)
 c040a26:	6818      	ldr	r0, [r3, #0]
          frequency = HSI48_VALUE;
 c040a28:	4b0c      	ldr	r3, [pc, #48]	@ (c040a5c <HAL_RCCEx_GetPeriphCLKFreq+0x3a0>)
 c040a2a:	f410 5000 	ands.w	r0, r0, #8192	@ 0x2000
 c040a2e:	bf18      	it	ne
 c040a30:	4618      	movne	r0, r3
 c040a32:	e684      	b.n	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
      HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
 c040a34:	a801      	add	r0, sp, #4
 c040a36:	f7ff fc31 	bl	c04029c <HAL_RCCEx_GetPLL1ClockFreq>
      frequency = pll1_clocks.PLL1_P_Frequency;
 c040a3a:	9801      	ldr	r0, [sp, #4]
 c040a3c:	e67f      	b.n	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
 c040a3e:	bf00      	nop
 c040a40:	00400001 	.word	0x00400001
 c040a44:	00040001 	.word	0x00040001
 c040a48:	04000001 	.word	0x04000001
 c040a4c:	56020c00 	.word	0x56020c00
 c040a50:	0007a120 	.word	0x0007a120
 c040a54:	00f42400 	.word	0x00f42400
 c040a58:	007a1200 	.word	0x007a1200
 c040a5c:	02dc6c00 	.word	0x02dc6c00
 c040a60:	0c05fa94 	.word	0x0c05fa94
    srcclk = __HAL_RCC_GET_USART1_SOURCE();
 c040a64:	4aa8      	ldr	r2, [pc, #672]	@ (c040d08 <HAL_RCCEx_GetPeriphCLKFreq+0x64c>)
 c040a66:	f8d2 30e0 	ldr.w	r3, [r2, #224]	@ 0xe0
    if (srcclk == RCC_USART1CLKSOURCE_PCLK2)
 c040a6a:	f013 0303 	ands.w	r3, r3, #3
 c040a6e:	d104      	bne.n	c040a7a <HAL_RCCEx_GetPeriphCLKFreq+0x3be>
}
 c040a70:	b005      	add	sp, #20
 c040a72:	f85d eb04 	ldr.w	lr, [sp], #4
        frequency = HAL_RCC_GetPCLK2Freq();
 c040a76:	f7ff bbf1 	b.w	c04025c <HAL_RCC_GetPCLK2Freq>
    else if (srcclk == RCC_USART1CLKSOURCE_SYSCLK)
 c040a7a:	2b01      	cmp	r3, #1
 c040a7c:	d104      	bne.n	c040a88 <HAL_RCCEx_GetPeriphCLKFreq+0x3cc>
}
 c040a7e:	b005      	add	sp, #20
 c040a80:	f85d eb04 	ldr.w	lr, [sp], #4
        frequency = HAL_RCC_GetSysClockFreq();
 c040a84:	f7ff bb28 	b.w	c0400d8 <HAL_RCC_GetSysClockFreq>
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_USART1CLKSOURCE_HSI))
 c040a88:	6812      	ldr	r2, [r2, #0]
 c040a8a:	0552      	lsls	r2, r2, #21
 c040a8c:	d502      	bpl.n	c040a94 <HAL_RCCEx_GetPeriphCLKFreq+0x3d8>
 c040a8e:	2b02      	cmp	r3, #2
 c040a90:	f000 8403 	beq.w	c04129a <HAL_RCCEx_GetPeriphCLKFreq+0xbde>
    else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_USART1CLKSOURCE_LSE))
 c040a94:	4a9c      	ldr	r2, [pc, #624]	@ (c040d08 <HAL_RCCEx_GetPeriphCLKFreq+0x64c>)
 c040a96:	f8d2 00f0 	ldr.w	r0, [r2, #240]	@ 0xf0
 c040a9a:	f010 0002 	ands.w	r0, r0, #2
 c040a9e:	f43f ae4e 	beq.w	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
 c040aa2:	f1a3 0c03 	sub.w	ip, r3, #3
 c040aa6:	f1dc 0300 	rsbs	r3, ip, #0
 c040aaa:	eb43 030c 	adc.w	r3, r3, ip
 c040aae:	03d8      	lsls	r0, r3, #15
 c040ab0:	e645      	b.n	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
    srcclk = __HAL_RCC_GET_USART2_SOURCE();
 c040ab2:	4a95      	ldr	r2, [pc, #596]	@ (c040d08 <HAL_RCCEx_GetPeriphCLKFreq+0x64c>)
 c040ab4:	f8d2 30e0 	ldr.w	r3, [r2, #224]	@ 0xe0
    if (srcclk == RCC_USART2CLKSOURCE_PCLK1)
 c040ab8:	f013 030c 	ands.w	r3, r3, #12
 c040abc:	d104      	bne.n	c040ac8 <HAL_RCCEx_GetPeriphCLKFreq+0x40c>
}
 c040abe:	b005      	add	sp, #20
 c040ac0:	f85d eb04 	ldr.w	lr, [sp], #4
        frequency = HAL_RCC_GetPCLK1Freq();
 c040ac4:	f7ff bbba 	b.w	c04023c <HAL_RCC_GetPCLK1Freq>
    else if (srcclk == RCC_USART2CLKSOURCE_SYSCLK)
 c040ac8:	2b04      	cmp	r3, #4
 c040aca:	d0d8      	beq.n	c040a7e <HAL_RCCEx_GetPeriphCLKFreq+0x3c2>
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_USART2CLKSOURCE_HSI))
 c040acc:	6812      	ldr	r2, [r2, #0]
 c040ace:	0550      	lsls	r0, r2, #21
 c040ad0:	d502      	bpl.n	c040ad8 <HAL_RCCEx_GetPeriphCLKFreq+0x41c>
 c040ad2:	2b08      	cmp	r3, #8
 c040ad4:	f000 83e4 	beq.w	c0412a0 <HAL_RCCEx_GetPeriphCLKFreq+0xbe4>
    else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_USART2CLKSOURCE_LSE))
 c040ad8:	4a8b      	ldr	r2, [pc, #556]	@ (c040d08 <HAL_RCCEx_GetPeriphCLKFreq+0x64c>)
 c040ada:	f8d2 00f0 	ldr.w	r0, [r2, #240]	@ 0xf0
 c040ade:	f010 0002 	ands.w	r0, r0, #2
 c040ae2:	f43f ae2c 	beq.w	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
 c040ae6:	f1a3 010c 	sub.w	r1, r3, #12
 c040aea:	424b      	negs	r3, r1
 c040aec:	414b      	adcs	r3, r1
 c040aee:	03d8      	lsls	r0, r3, #15
 c040af0:	e625      	b.n	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
    srcclk = __HAL_RCC_GET_USART3_SOURCE();
 c040af2:	4a85      	ldr	r2, [pc, #532]	@ (c040d08 <HAL_RCCEx_GetPeriphCLKFreq+0x64c>)
 c040af4:	f8d2 30e0 	ldr.w	r3, [r2, #224]	@ 0xe0
    if (srcclk == RCC_USART3CLKSOURCE_PCLK1)
 c040af8:	f013 0330 	ands.w	r3, r3, #48	@ 0x30
 c040afc:	d0df      	beq.n	c040abe <HAL_RCCEx_GetPeriphCLKFreq+0x402>
    else if (srcclk == RCC_USART3CLKSOURCE_SYSCLK)
 c040afe:	2b10      	cmp	r3, #16
 c040b00:	d0bd      	beq.n	c040a7e <HAL_RCCEx_GetPeriphCLKFreq+0x3c2>
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_USART3CLKSOURCE_HSI))
 c040b02:	6812      	ldr	r2, [r2, #0]
 c040b04:	0552      	lsls	r2, r2, #21
 c040b06:	d502      	bpl.n	c040b0e <HAL_RCCEx_GetPeriphCLKFreq+0x452>
 c040b08:	2b20      	cmp	r3, #32
 c040b0a:	f000 83cc 	beq.w	c0412a6 <HAL_RCCEx_GetPeriphCLKFreq+0xbea>
    else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_USART3CLKSOURCE_LSE))
 c040b0e:	4a7e      	ldr	r2, [pc, #504]	@ (c040d08 <HAL_RCCEx_GetPeriphCLKFreq+0x64c>)
 c040b10:	f8d2 00f0 	ldr.w	r0, [r2, #240]	@ 0xf0
 c040b14:	f010 0002 	ands.w	r0, r0, #2
 c040b18:	f43f ae11 	beq.w	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
 c040b1c:	f1a3 0c30 	sub.w	ip, r3, #48	@ 0x30
 c040b20:	f1dc 0300 	rsbs	r3, ip, #0
 c040b24:	eb43 030c 	adc.w	r3, r3, ip
 c040b28:	03d8      	lsls	r0, r3, #15
 c040b2a:	e608      	b.n	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
    srcclk = __HAL_RCC_GET_UART4_SOURCE();
 c040b2c:	4a76      	ldr	r2, [pc, #472]	@ (c040d08 <HAL_RCCEx_GetPeriphCLKFreq+0x64c>)
 c040b2e:	f8d2 30e0 	ldr.w	r3, [r2, #224]	@ 0xe0
    if (srcclk == RCC_UART4CLKSOURCE_PCLK1)
 c040b32:	f013 03c0 	ands.w	r3, r3, #192	@ 0xc0
 c040b36:	d0c2      	beq.n	c040abe <HAL_RCCEx_GetPeriphCLKFreq+0x402>
    else if (srcclk == RCC_UART4CLKSOURCE_SYSCLK)
 c040b38:	2b40      	cmp	r3, #64	@ 0x40
 c040b3a:	d0a0      	beq.n	c040a7e <HAL_RCCEx_GetPeriphCLKFreq+0x3c2>
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_UART4CLKSOURCE_HSI))
 c040b3c:	6812      	ldr	r2, [r2, #0]
 c040b3e:	0550      	lsls	r0, r2, #21
 c040b40:	d502      	bpl.n	c040b48 <HAL_RCCEx_GetPeriphCLKFreq+0x48c>
 c040b42:	2b80      	cmp	r3, #128	@ 0x80
 c040b44:	f000 83b2 	beq.w	c0412ac <HAL_RCCEx_GetPeriphCLKFreq+0xbf0>
    else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_UART4CLKSOURCE_LSE))
 c040b48:	4a6f      	ldr	r2, [pc, #444]	@ (c040d08 <HAL_RCCEx_GetPeriphCLKFreq+0x64c>)
 c040b4a:	f8d2 00f0 	ldr.w	r0, [r2, #240]	@ 0xf0
 c040b4e:	f010 0002 	ands.w	r0, r0, #2
 c040b52:	f43f adf4 	beq.w	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
 c040b56:	f1a3 01c0 	sub.w	r1, r3, #192	@ 0xc0
 c040b5a:	424b      	negs	r3, r1
 c040b5c:	414b      	adcs	r3, r1
 c040b5e:	03d8      	lsls	r0, r3, #15
 c040b60:	e5ed      	b.n	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
    srcclk = __HAL_RCC_GET_UART5_SOURCE();
 c040b62:	4a69      	ldr	r2, [pc, #420]	@ (c040d08 <HAL_RCCEx_GetPeriphCLKFreq+0x64c>)
 c040b64:	f8d2 30e0 	ldr.w	r3, [r2, #224]	@ 0xe0
    if (srcclk == RCC_UART5CLKSOURCE_PCLK1)
 c040b68:	f413 7340 	ands.w	r3, r3, #768	@ 0x300
 c040b6c:	d0a7      	beq.n	c040abe <HAL_RCCEx_GetPeriphCLKFreq+0x402>
    else if (srcclk == RCC_UART5CLKSOURCE_SYSCLK)
 c040b6e:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 c040b72:	d084      	beq.n	c040a7e <HAL_RCCEx_GetPeriphCLKFreq+0x3c2>
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_UART5CLKSOURCE_HSI))
 c040b74:	6812      	ldr	r2, [r2, #0]
 c040b76:	0552      	lsls	r2, r2, #21
 c040b78:	d503      	bpl.n	c040b82 <HAL_RCCEx_GetPeriphCLKFreq+0x4c6>
 c040b7a:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 c040b7e:	f000 8398 	beq.w	c0412b2 <HAL_RCCEx_GetPeriphCLKFreq+0xbf6>
    else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_UART5CLKSOURCE_LSE))
 c040b82:	4a61      	ldr	r2, [pc, #388]	@ (c040d08 <HAL_RCCEx_GetPeriphCLKFreq+0x64c>)
 c040b84:	f8d2 00f0 	ldr.w	r0, [r2, #240]	@ 0xf0
 c040b88:	f010 0002 	ands.w	r0, r0, #2
 c040b8c:	f43f add7 	beq.w	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
 c040b90:	f5a3 7c40 	sub.w	ip, r3, #768	@ 0x300
 c040b94:	f1dc 0300 	rsbs	r3, ip, #0
 c040b98:	eb43 030c 	adc.w	r3, r3, ip
 c040b9c:	03d8      	lsls	r0, r3, #15
 c040b9e:	e5ce      	b.n	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
    srcclk = __HAL_RCC_GET_LPUART1_SOURCE();
 c040ba0:	4a59      	ldr	r2, [pc, #356]	@ (c040d08 <HAL_RCCEx_GetPeriphCLKFreq+0x64c>)
 c040ba2:	f8d2 30e8 	ldr.w	r3, [r2, #232]	@ 0xe8
    if (srcclk == RCC_LPUART1CLKSOURCE_PCLK3)
 c040ba6:	f013 0307 	ands.w	r3, r3, #7
 c040baa:	d104      	bne.n	c040bb6 <HAL_RCCEx_GetPeriphCLKFreq+0x4fa>
}
 c040bac:	b005      	add	sp, #20
 c040bae:	f85d eb04 	ldr.w	lr, [sp], #4
        frequency = HAL_RCC_GetPCLK3Freq();
 c040bb2:	f7ff bb63 	b.w	c04027c <HAL_RCC_GetPCLK3Freq>
    else if (srcclk == RCC_LPUART1CLKSOURCE_SYSCLK)
 c040bb6:	2b01      	cmp	r3, #1
 c040bb8:	f43f af61 	beq.w	c040a7e <HAL_RCCEx_GetPeriphCLKFreq+0x3c2>
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_LPUART1CLKSOURCE_HSI))
 c040bbc:	6812      	ldr	r2, [r2, #0]
 c040bbe:	0550      	lsls	r0, r2, #21
 c040bc0:	d502      	bpl.n	c040bc8 <HAL_RCCEx_GetPeriphCLKFreq+0x50c>
 c040bc2:	2b02      	cmp	r3, #2
 c040bc4:	f000 8378 	beq.w	c0412b8 <HAL_RCCEx_GetPeriphCLKFreq+0xbfc>
    else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_LPUART1CLKSOURCE_LSE))
 c040bc8:	4a4f      	ldr	r2, [pc, #316]	@ (c040d08 <HAL_RCCEx_GetPeriphCLKFreq+0x64c>)
 c040bca:	f8d2 10f0 	ldr.w	r1, [r2, #240]	@ 0xf0
 c040bce:	0789      	lsls	r1, r1, #30
 c040bd0:	d502      	bpl.n	c040bd8 <HAL_RCCEx_GetPeriphCLKFreq+0x51c>
 c040bd2:	2b03      	cmp	r3, #3
 c040bd4:	f000 8373 	beq.w	c0412be <HAL_RCCEx_GetPeriphCLKFreq+0xc02>
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIKRDY)) && (srcclk == RCC_LPUART1CLKSOURCE_MSIK))
 c040bd8:	6810      	ldr	r0, [r2, #0]
 c040bda:	f010 0020 	ands.w	r0, r0, #32
 c040bde:	f43f adae 	beq.w	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
 c040be2:	2b04      	cmp	r3, #4
 c040be4:	f040 836f 	bne.w	c0412c6 <HAL_RCCEx_GetPeriphCLKFreq+0xc0a>
      frequency = MSIRangeTable[(__HAL_RCC_GET_MSIK_RANGE() >> RCC_ICSCR1_MSIKRANGE_Pos)];
 c040be8:	6893      	ldr	r3, [r2, #8]
 c040bea:	021b      	lsls	r3, r3, #8
 c040bec:	bf4c      	ite	mi
 c040bee:	6893      	ldrmi	r3, [r2, #8]
 c040bf0:	f8d2 30f4 	ldrpl.w	r3, [r2, #244]	@ 0xf4
 c040bf4:	4a45      	ldr	r2, [pc, #276]	@ (c040d0c <HAL_RCCEx_GetPeriphCLKFreq+0x650>)
 c040bf6:	bf4c      	ite	mi
 c040bf8:	f3c3 6303 	ubfxmi	r3, r3, #24, #4
 c040bfc:	f3c3 2303 	ubfxpl	r3, r3, #8, #4
 c040c00:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
 c040c04:	e59b      	b.n	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
    srcclk = __HAL_RCC_GET_ADCDAC_SOURCE();
 c040c06:	4a40      	ldr	r2, [pc, #256]	@ (c040d08 <HAL_RCCEx_GetPeriphCLKFreq+0x64c>)
 c040c08:	f8d2 30e8 	ldr.w	r3, [r2, #232]	@ 0xe8
 c040c0c:	f403 43e0 	and.w	r3, r3, #28672	@ 0x7000
    if (srcclk == RCC_ADCDACCLKSOURCE_SYSCLK)
 c040c10:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 c040c14:	f43f af33 	beq.w	c040a7e <HAL_RCCEx_GetPeriphCLKFreq+0x3c2>
    else if (srcclk == RCC_ADCDACCLKSOURCE_PLL2)
 c040c18:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 c040c1c:	d104      	bne.n	c040c28 <HAL_RCCEx_GetPeriphCLKFreq+0x56c>
      HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 c040c1e:	a801      	add	r0, sp, #4
 c040c20:	f7ff fbec 	bl	c0403fc <HAL_RCCEx_GetPLL2ClockFreq>
      frequency = pll2_clocks.PLL2_R_Frequency;
 c040c24:	9803      	ldr	r0, [sp, #12]
 c040c26:	e58a      	b.n	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
    else if (srcclk == RCC_ADCDACCLKSOURCE_HCLK)
 c040c28:	b923      	cbnz	r3, c040c34 <HAL_RCCEx_GetPeriphCLKFreq+0x578>
}
 c040c2a:	b005      	add	sp, #20
 c040c2c:	f85d eb04 	ldr.w	lr, [sp], #4
        frequency = HAL_RCC_GetHCLKFreq();
 c040c30:	f7ff baf0 	b.w	c040214 <HAL_RCC_GetHCLKFreq>
    else if (srcclk == RCC_ADCDACCLKSOURCE_MSIK)
 c040c34:	f5b3 4fa0 	cmp.w	r3, #20480	@ 0x5000
 c040c38:	d113      	bne.n	c040c62 <HAL_RCCEx_GetPeriphCLKFreq+0x5a6>
      if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIKRDY))
 c040c3a:	6810      	ldr	r0, [r2, #0]
 c040c3c:	f010 0020 	ands.w	r0, r0, #32
 c040c40:	f43f ad7d 	beq.w	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
        frequency = MSIRangeTable[(__HAL_RCC_GET_MSIK_RANGE() >> RCC_ICSCR1_MSIKRANGE_Pos)];
 c040c44:	6893      	ldr	r3, [r2, #8]
 c040c46:	0218      	lsls	r0, r3, #8
 c040c48:	bf4c      	ite	mi
 c040c4a:	6893      	ldrmi	r3, [r2, #8]
 c040c4c:	f8d2 30f4 	ldrpl.w	r3, [r2, #244]	@ 0xf4
 c040c50:	4a2e      	ldr	r2, [pc, #184]	@ (c040d0c <HAL_RCCEx_GetPeriphCLKFreq+0x650>)
 c040c52:	bf4c      	ite	mi
 c040c54:	f3c3 6303 	ubfxmi	r3, r3, #24, #4
 c040c58:	f3c3 2303 	ubfxpl	r3, r3, #8, #4
 c040c5c:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
 c040c60:	e56d      	b.n	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)) && (srcclk == RCC_ADCDACCLKSOURCE_HSE))
 c040c62:	6812      	ldr	r2, [r2, #0]
 c040c64:	0391      	lsls	r1, r2, #14
 c040c66:	d503      	bpl.n	c040c70 <HAL_RCCEx_GetPeriphCLKFreq+0x5b4>
 c040c68:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
 c040c6c:	f000 832e 	beq.w	c0412cc <HAL_RCCEx_GetPeriphCLKFreq+0xc10>
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_ADCDACCLKSOURCE_HSI))
 c040c70:	4a25      	ldr	r2, [pc, #148]	@ (c040d08 <HAL_RCCEx_GetPeriphCLKFreq+0x64c>)
 c040c72:	6810      	ldr	r0, [r2, #0]
 c040c74:	f410 6080 	ands.w	r0, r0, #1024	@ 0x400
 c040c78:	f43f ad61 	beq.w	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
          frequency = HSI_VALUE;
 c040c7c:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
 c040c80:	4823      	ldr	r0, [pc, #140]	@ (c040d10 <HAL_RCCEx_GetPeriphCLKFreq+0x654>)
 c040c82:	bf18      	it	ne
 c040c84:	2000      	movne	r0, #0
 c040c86:	e55a      	b.n	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
    srcclk = __HAL_RCC_GET_MDF1_SOURCE();
 c040c88:	4b1f      	ldr	r3, [pc, #124]	@ (c040d08 <HAL_RCCEx_GetPeriphCLKFreq+0x64c>)
 c040c8a:	f8d3 20e4 	ldr.w	r2, [r3, #228]	@ 0xe4
 c040c8e:	f002 0207 	and.w	r2, r2, #7
    switch (srcclk)
 c040c92:	2a04      	cmp	r2, #4
 c040c94:	d80c      	bhi.n	c040cb0 <HAL_RCCEx_GetPeriphCLKFreq+0x5f4>
 c040c96:	a101      	add	r1, pc, #4	@ (adr r1, c040c9c <HAL_RCCEx_GetPeriphCLKFreq+0x5e0>)
 c040c98:	f851 f022 	ldr.w	pc, [r1, r2, lsl #2]
 c040c9c:	0c040c2b 	.word	0x0c040c2b
 c040ca0:	0c0408c7 	.word	0x0c0408c7
 c040ca4:	0c040cb5 	.word	0x0c040cb5
 c040ca8:	0c0412d3 	.word	0x0c0412d3
 c040cac:	0c040cbf 	.word	0x0c040cbf
          frequency = 0U;
 c040cb0:	2000      	movs	r0, #0
 c040cb2:	e544      	b.n	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
        HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 c040cb4:	a801      	add	r0, sp, #4
 c040cb6:	f7ff fc51 	bl	c04055c <HAL_RCCEx_GetPLL3ClockFreq>
        frequency = pll3_clocks.PLL3_Q_Frequency;
 c040cba:	9802      	ldr	r0, [sp, #8]
        break;
 c040cbc:	e53f      	b.n	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIKRDY))
 c040cbe:	6818      	ldr	r0, [r3, #0]
 c040cc0:	f010 0020 	ands.w	r0, r0, #32
 c040cc4:	f43f ad3b 	beq.w	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
          frequency = MSIRangeTable[(__HAL_RCC_GET_MSIK_RANGE() >> RCC_ICSCR1_MSIKRANGE_Pos)];
 c040cc8:	689a      	ldr	r2, [r3, #8]
 c040cca:	0212      	lsls	r2, r2, #8
 c040ccc:	bf4c      	ite	mi
 c040cce:	689b      	ldrmi	r3, [r3, #8]
 c040cd0:	f8d3 30f4 	ldrpl.w	r3, [r3, #244]	@ 0xf4
 c040cd4:	4a0d      	ldr	r2, [pc, #52]	@ (c040d0c <HAL_RCCEx_GetPeriphCLKFreq+0x650>)
 c040cd6:	bf4c      	ite	mi
 c040cd8:	f3c3 6303 	ubfxmi	r3, r3, #24, #4
 c040cdc:	f3c3 2303 	ubfxpl	r3, r3, #8, #4
 c040ce0:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
 c040ce4:	e52b      	b.n	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
    srcclk = __HAL_RCC_GET_ADF1_SOURCE();
 c040ce6:	4a08      	ldr	r2, [pc, #32]	@ (c040d08 <HAL_RCCEx_GetPeriphCLKFreq+0x64c>)
 c040ce8:	f8d2 30e8 	ldr.w	r3, [r2, #232]	@ 0xe8
 c040cec:	f403 23e0 	and.w	r3, r3, #458752	@ 0x70000
    switch (srcclk)
 c040cf0:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 c040cf4:	d0de      	beq.n	c040cb4 <HAL_RCCEx_GetPeriphCLKFreq+0x5f8>
 c040cf6:	d80d      	bhi.n	c040d14 <HAL_RCCEx_GetPeriphCLKFreq+0x658>
 c040cf8:	2b00      	cmp	r3, #0
 c040cfa:	d096      	beq.n	c040c2a <HAL_RCCEx_GetPeriphCLKFreq+0x56e>
 c040cfc:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 c040d00:	f43f ade1 	beq.w	c0408c6 <HAL_RCCEx_GetPeriphCLKFreq+0x20a>
          frequency = 0U;
 c040d04:	2000      	movs	r0, #0
 c040d06:	e51a      	b.n	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
 c040d08:	56020c00 	.word	0x56020c00
 c040d0c:	0c05fa94 	.word	0x0c05fa94
 c040d10:	00f42400 	.word	0x00f42400
    switch (srcclk)
 c040d14:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
 c040d18:	f000 82df 	beq.w	c0412da <HAL_RCCEx_GetPeriphCLKFreq+0xc1e>
 c040d1c:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
 c040d20:	f040 82df 	bne.w	c0412e2 <HAL_RCCEx_GetPeriphCLKFreq+0xc26>
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIKRDY))
 c040d24:	6810      	ldr	r0, [r2, #0]
 c040d26:	f010 0020 	ands.w	r0, r0, #32
 c040d2a:	f43f ad08 	beq.w	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
          frequency = MSIRangeTable[(__HAL_RCC_GET_MSIK_RANGE() >> RCC_ICSCR1_MSIKRANGE_Pos)];
 c040d2e:	6893      	ldr	r3, [r2, #8]
 c040d30:	021b      	lsls	r3, r3, #8
 c040d32:	bf4c      	ite	mi
 c040d34:	6893      	ldrmi	r3, [r2, #8]
 c040d36:	f8d2 30f4 	ldrpl.w	r3, [r2, #244]	@ 0xf4
 c040d3a:	4aa9      	ldr	r2, [pc, #676]	@ (c040fe0 <HAL_RCCEx_GetPeriphCLKFreq+0x924>)
 c040d3c:	bf4c      	ite	mi
 c040d3e:	f3c3 6303 	ubfxmi	r3, r3, #24, #4
 c040d42:	f3c3 2303 	ubfxpl	r3, r3, #8, #4
 c040d46:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
 c040d4a:	e4f8      	b.n	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
    srcclk = __HAL_RCC_GET_I2C1_SOURCE();
 c040d4c:	4aa5      	ldr	r2, [pc, #660]	@ (c040fe4 <HAL_RCCEx_GetPeriphCLKFreq+0x928>)
 c040d4e:	f8d2 30e0 	ldr.w	r3, [r2, #224]	@ 0xe0
    if (srcclk == RCC_I2C1CLKSOURCE_PCLK1)
 c040d52:	f413 6340 	ands.w	r3, r3, #3072	@ 0xc00
 c040d56:	f43f aeb2 	beq.w	c040abe <HAL_RCCEx_GetPeriphCLKFreq+0x402>
    else if (srcclk == RCC_I2C1CLKSOURCE_SYSCLK)
 c040d5a:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 c040d5e:	f43f ae8e 	beq.w	c040a7e <HAL_RCCEx_GetPeriphCLKFreq+0x3c2>
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_I2C1CLKSOURCE_HSI))
 c040d62:	6812      	ldr	r2, [r2, #0]
 c040d64:	0550      	lsls	r0, r2, #21
 c040d66:	d503      	bpl.n	c040d70 <HAL_RCCEx_GetPeriphCLKFreq+0x6b4>
 c040d68:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
 c040d6c:	f000 82bc 	beq.w	c0412e8 <HAL_RCCEx_GetPeriphCLKFreq+0xc2c>
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIKRDY)) && (srcclk == RCC_I2C1CLKSOURCE_MSIK))
 c040d70:	4a9c      	ldr	r2, [pc, #624]	@ (c040fe4 <HAL_RCCEx_GetPeriphCLKFreq+0x928>)
 c040d72:	6810      	ldr	r0, [r2, #0]
 c040d74:	f010 0020 	ands.w	r0, r0, #32
 c040d78:	f43f ace1 	beq.w	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
 c040d7c:	f5b3 6f40 	cmp.w	r3, #3072	@ 0xc00
 c040d80:	f040 82b5 	bne.w	c0412ee <HAL_RCCEx_GetPeriphCLKFreq+0xc32>
      frequency = MSIRangeTable[(__HAL_RCC_GET_MSIK_RANGE() >> RCC_ICSCR1_MSIKRANGE_Pos)];
 c040d84:	6893      	ldr	r3, [r2, #8]
 c040d86:	0219      	lsls	r1, r3, #8
 c040d88:	bf4c      	ite	mi
 c040d8a:	6893      	ldrmi	r3, [r2, #8]
 c040d8c:	f8d2 30f4 	ldrpl.w	r3, [r2, #244]	@ 0xf4
 c040d90:	4a93      	ldr	r2, [pc, #588]	@ (c040fe0 <HAL_RCCEx_GetPeriphCLKFreq+0x924>)
 c040d92:	bf4c      	ite	mi
 c040d94:	f3c3 6303 	ubfxmi	r3, r3, #24, #4
 c040d98:	f3c3 2303 	ubfxpl	r3, r3, #8, #4
 c040d9c:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
 c040da0:	e4cd      	b.n	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
    srcclk = __HAL_RCC_GET_I2C2_SOURCE();
 c040da2:	4a90      	ldr	r2, [pc, #576]	@ (c040fe4 <HAL_RCCEx_GetPeriphCLKFreq+0x928>)
 c040da4:	f8d2 30e0 	ldr.w	r3, [r2, #224]	@ 0xe0
    if (srcclk == RCC_I2C2CLKSOURCE_PCLK1)
 c040da8:	f413 5340 	ands.w	r3, r3, #12288	@ 0x3000
 c040dac:	f43f ae87 	beq.w	c040abe <HAL_RCCEx_GetPeriphCLKFreq+0x402>
    else if (srcclk == RCC_I2C2CLKSOURCE_SYSCLK)
 c040db0:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 c040db4:	f43f ae63 	beq.w	c040a7e <HAL_RCCEx_GetPeriphCLKFreq+0x3c2>
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_I2C2CLKSOURCE_HSI))
 c040db8:	6812      	ldr	r2, [r2, #0]
 c040dba:	0552      	lsls	r2, r2, #21
 c040dbc:	d503      	bpl.n	c040dc6 <HAL_RCCEx_GetPeriphCLKFreq+0x70a>
 c040dbe:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 c040dc2:	f000 829d 	beq.w	c041300 <HAL_RCCEx_GetPeriphCLKFreq+0xc44>
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIKRDY)) && (srcclk == RCC_I2C2CLKSOURCE_MSIK))
 c040dc6:	4a87      	ldr	r2, [pc, #540]	@ (c040fe4 <HAL_RCCEx_GetPeriphCLKFreq+0x928>)
 c040dc8:	6810      	ldr	r0, [r2, #0]
 c040dca:	f010 0020 	ands.w	r0, r0, #32
 c040dce:	f43f acb6 	beq.w	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
 c040dd2:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
 c040dd6:	f040 8296 	bne.w	c041306 <HAL_RCCEx_GetPeriphCLKFreq+0xc4a>
      frequency = MSIRangeTable[(__HAL_RCC_GET_MSIK_RANGE() >> RCC_ICSCR1_MSIKRANGE_Pos)];
 c040dda:	6893      	ldr	r3, [r2, #8]
 c040ddc:	0218      	lsls	r0, r3, #8
 c040dde:	bf4c      	ite	mi
 c040de0:	6893      	ldrmi	r3, [r2, #8]
 c040de2:	f8d2 30f4 	ldrpl.w	r3, [r2, #244]	@ 0xf4
 c040de6:	4a7e      	ldr	r2, [pc, #504]	@ (c040fe0 <HAL_RCCEx_GetPeriphCLKFreq+0x924>)
 c040de8:	bf4c      	ite	mi
 c040dea:	f3c3 6303 	ubfxmi	r3, r3, #24, #4
 c040dee:	f3c3 2303 	ubfxpl	r3, r3, #8, #4
 c040df2:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
 c040df6:	e4a2      	b.n	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
    srcclk = __HAL_RCC_GET_I2C3_SOURCE();
 c040df8:	4b7a      	ldr	r3, [pc, #488]	@ (c040fe4 <HAL_RCCEx_GetPeriphCLKFreq+0x928>)
 c040dfa:	f8d3 20e8 	ldr.w	r2, [r3, #232]	@ 0xe8
 c040dfe:	f002 02c0 	and.w	r2, r2, #192	@ 0xc0
    switch (srcclk)
 c040e02:	2a80      	cmp	r2, #128	@ 0x80
 c040e04:	d00c      	beq.n	c040e20 <HAL_RCCEx_GetPeriphCLKFreq+0x764>
 c040e06:	d807      	bhi.n	c040e18 <HAL_RCCEx_GetPeriphCLKFreq+0x75c>
 c040e08:	2a00      	cmp	r2, #0
 c040e0a:	f43f aecf 	beq.w	c040bac <HAL_RCCEx_GetPeriphCLKFreq+0x4f0>
 c040e0e:	2a40      	cmp	r2, #64	@ 0x40
 c040e10:	f43f ae35 	beq.w	c040a7e <HAL_RCCEx_GetPeriphCLKFreq+0x3c2>
          frequency = 0U;
 c040e14:	2000      	movs	r0, #0
 c040e16:	e492      	b.n	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
    switch (srcclk)
 c040e18:	2ac0      	cmp	r2, #192	@ 0xc0
 c040e1a:	d008      	beq.n	c040e2e <HAL_RCCEx_GetPeriphCLKFreq+0x772>
          frequency = 0U;
 c040e1c:	2000      	movs	r0, #0
 c040e1e:	e48e      	b.n	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
 c040e20:	6818      	ldr	r0, [r3, #0]
          frequency = HSI_VALUE;
 c040e22:	4b71      	ldr	r3, [pc, #452]	@ (c040fe8 <HAL_RCCEx_GetPeriphCLKFreq+0x92c>)
 c040e24:	f410 6080 	ands.w	r0, r0, #1024	@ 0x400
 c040e28:	bf18      	it	ne
 c040e2a:	4618      	movne	r0, r3
 c040e2c:	e487      	b.n	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIKRDY))
 c040e2e:	6818      	ldr	r0, [r3, #0]
 c040e30:	f010 0020 	ands.w	r0, r0, #32
 c040e34:	f43f ac83 	beq.w	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
          frequency = MSIRangeTable[(__HAL_RCC_GET_MSIK_RANGE() >> RCC_ICSCR1_MSIKRANGE_Pos)];
 c040e38:	689a      	ldr	r2, [r3, #8]
 c040e3a:	0211      	lsls	r1, r2, #8
 c040e3c:	bf4c      	ite	mi
 c040e3e:	689b      	ldrmi	r3, [r3, #8]
 c040e40:	f8d3 30f4 	ldrpl.w	r3, [r3, #244]	@ 0xf4
 c040e44:	4a66      	ldr	r2, [pc, #408]	@ (c040fe0 <HAL_RCCEx_GetPeriphCLKFreq+0x924>)
 c040e46:	bf4c      	ite	mi
 c040e48:	f3c3 6303 	ubfxmi	r3, r3, #24, #4
 c040e4c:	f3c3 2303 	ubfxpl	r3, r3, #8, #4
 c040e50:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
 c040e54:	e473      	b.n	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
    srcclk = __HAL_RCC_GET_I2C4_SOURCE();
 c040e56:	4a63      	ldr	r2, [pc, #396]	@ (c040fe4 <HAL_RCCEx_GetPeriphCLKFreq+0x928>)
 c040e58:	f8d2 30e0 	ldr.w	r3, [r2, #224]	@ 0xe0
    if (srcclk == RCC_I2C4CLKSOURCE_PCLK1)
 c040e5c:	f413 4340 	ands.w	r3, r3, #49152	@ 0xc000
 c040e60:	f43f ae2d 	beq.w	c040abe <HAL_RCCEx_GetPeriphCLKFreq+0x402>
    else if (srcclk == RCC_I2C4CLKSOURCE_SYSCLK)
 c040e64:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
 c040e68:	f43f ae09 	beq.w	c040a7e <HAL_RCCEx_GetPeriphCLKFreq+0x3c2>
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_I2C4CLKSOURCE_HSI))
 c040e6c:	6812      	ldr	r2, [r2, #0]
 c040e6e:	0552      	lsls	r2, r2, #21
 c040e70:	d503      	bpl.n	c040e7a <HAL_RCCEx_GetPeriphCLKFreq+0x7be>
 c040e72:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
 c040e76:	f000 8249 	beq.w	c04130c <HAL_RCCEx_GetPeriphCLKFreq+0xc50>
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIKRDY)) && (srcclk == RCC_I2C4CLKSOURCE_MSIK))
 c040e7a:	4a5a      	ldr	r2, [pc, #360]	@ (c040fe4 <HAL_RCCEx_GetPeriphCLKFreq+0x928>)
 c040e7c:	6810      	ldr	r0, [r2, #0]
 c040e7e:	f010 0020 	ands.w	r0, r0, #32
 c040e82:	f43f ac5c 	beq.w	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
 c040e86:	f5b3 4f40 	cmp.w	r3, #49152	@ 0xc000
 c040e8a:	f040 8242 	bne.w	c041312 <HAL_RCCEx_GetPeriphCLKFreq+0xc56>
      frequency = MSIRangeTable[(__HAL_RCC_GET_MSIK_RANGE() >> RCC_ICSCR1_MSIKRANGE_Pos)];
 c040e8e:	6893      	ldr	r3, [r2, #8]
 c040e90:	021b      	lsls	r3, r3, #8
 c040e92:	bf4c      	ite	mi
 c040e94:	6893      	ldrmi	r3, [r2, #8]
 c040e96:	f8d2 30f4 	ldrpl.w	r3, [r2, #244]	@ 0xf4
 c040e9a:	4a51      	ldr	r2, [pc, #324]	@ (c040fe0 <HAL_RCCEx_GetPeriphCLKFreq+0x924>)
 c040e9c:	bf4c      	ite	mi
 c040e9e:	f3c3 6303 	ubfxmi	r3, r3, #24, #4
 c040ea2:	f3c3 2303 	ubfxpl	r3, r3, #8, #4
 c040ea6:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
 c040eaa:	e448      	b.n	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
    srcclk = __HAL_RCC_GET_LPTIM34_SOURCE();
 c040eac:	4a4d      	ldr	r2, [pc, #308]	@ (c040fe4 <HAL_RCCEx_GetPeriphCLKFreq+0x928>)
 c040eae:	f8d2 30e8 	ldr.w	r3, [r2, #232]	@ 0xe8
    if (srcclk == RCC_LPTIM34CLKSOURCE_MSIK)
 c040eb2:	f413 7340 	ands.w	r3, r3, #768	@ 0x300
 c040eb6:	d113      	bne.n	c040ee0 <HAL_RCCEx_GetPeriphCLKFreq+0x824>
      if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIKRDY))
 c040eb8:	6810      	ldr	r0, [r2, #0]
 c040eba:	f010 0020 	ands.w	r0, r0, #32
 c040ebe:	f43f ac3e 	beq.w	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
        frequency = MSIRangeTable[(__HAL_RCC_GET_MSIK_RANGE() >> RCC_ICSCR1_MSIKRANGE_Pos)];
 c040ec2:	6893      	ldr	r3, [r2, #8]
 c040ec4:	0218      	lsls	r0, r3, #8
 c040ec6:	bf4c      	ite	mi
 c040ec8:	6893      	ldrmi	r3, [r2, #8]
 c040eca:	f8d2 30f4 	ldrpl.w	r3, [r2, #244]	@ 0xf4
 c040ece:	4a44      	ldr	r2, [pc, #272]	@ (c040fe0 <HAL_RCCEx_GetPeriphCLKFreq+0x924>)
 c040ed0:	bf4c      	ite	mi
 c040ed2:	f3c3 6303 	ubfxmi	r3, r3, #24, #4
 c040ed6:	f3c3 2303 	ubfxpl	r3, r3, #8, #4
 c040eda:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
 c040ede:	e42e      	b.n	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
    else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIRDY)) && (srcclk == RCC_LPTIM34CLKSOURCE_LSI))
 c040ee0:	f8d2 10f0 	ldr.w	r1, [r2, #240]	@ 0xf0
 c040ee4:	0109      	lsls	r1, r1, #4
 c040ee6:	d50b      	bpl.n	c040f00 <HAL_RCCEx_GetPeriphCLKFreq+0x844>
 c040ee8:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 c040eec:	d108      	bne.n	c040f00 <HAL_RCCEx_GetPeriphCLKFreq+0x844>
      if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIPREDIV))
 c040eee:	f8d2 30f0 	ldr.w	r3, [r2, #240]	@ 0xf0
        frequency = LSI_VALUE / 128U;
 c040ef2:	f013 5f80 	tst.w	r3, #268435456	@ 0x10000000
 c040ef6:	bf0c      	ite	eq
 c040ef8:	f44f 40fa 	moveq.w	r0, #32000	@ 0x7d00
 c040efc:	20fa      	movne	r0, #250	@ 0xfa
 c040efe:	e41e      	b.n	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_LPTIM34CLKSOURCE_HSI))
 c040f00:	6812      	ldr	r2, [r2, #0]
 c040f02:	0552      	lsls	r2, r2, #21
 c040f04:	d503      	bpl.n	c040f0e <HAL_RCCEx_GetPeriphCLKFreq+0x852>
 c040f06:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 c040f0a:	f000 8205 	beq.w	c041318 <HAL_RCCEx_GetPeriphCLKFreq+0xc5c>
    else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_LPTIM34CLKSOURCE_LSE))
 c040f0e:	4a35      	ldr	r2, [pc, #212]	@ (c040fe4 <HAL_RCCEx_GetPeriphCLKFreq+0x928>)
 c040f10:	f8d2 00f0 	ldr.w	r0, [r2, #240]	@ 0xf0
 c040f14:	f010 0002 	ands.w	r0, r0, #2
 c040f18:	f43f ac11 	beq.w	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
 c040f1c:	f5a3 7c40 	sub.w	ip, r3, #768	@ 0x300
 c040f20:	f1dc 0300 	rsbs	r3, ip, #0
 c040f24:	eb43 030c 	adc.w	r3, r3, ip
 c040f28:	03d8      	lsls	r0, r3, #15
 c040f2a:	e408      	b.n	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
    srcclk = __HAL_RCC_GET_LPTIM1_SOURCE();
 c040f2c:	4a2d      	ldr	r2, [pc, #180]	@ (c040fe4 <HAL_RCCEx_GetPeriphCLKFreq+0x928>)
 c040f2e:	f8d2 30e8 	ldr.w	r3, [r2, #232]	@ 0xe8
    if (srcclk == RCC_LPTIM1CLKSOURCE_MSIK)
 c040f32:	f413 6340 	ands.w	r3, r3, #3072	@ 0xc00
 c040f36:	d114      	bne.n	c040f62 <HAL_RCCEx_GetPeriphCLKFreq+0x8a6>
      if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIKRDY))
 c040f38:	6810      	ldr	r0, [r2, #0]
 c040f3a:	f010 0020 	ands.w	r0, r0, #32
 c040f3e:	f43f abfe 	beq.w	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
        frequency = MSIRangeTable[(__HAL_RCC_GET_MSIK_RANGE() >> RCC_ICSCR1_MSIKRANGE_Pos)];
 c040f42:	6893      	ldr	r3, [r2, #8]
 c040f44:	0218      	lsls	r0, r3, #8
 c040f46:	bf4c      	ite	mi
 c040f48:	6893      	ldrmi	r3, [r2, #8]
 c040f4a:	f8d2 30f4 	ldrpl.w	r3, [r2, #244]	@ 0xf4
 c040f4e:	4a24      	ldr	r2, [pc, #144]	@ (c040fe0 <HAL_RCCEx_GetPeriphCLKFreq+0x924>)
 c040f50:	bf4c      	ite	mi
 c040f52:	f3c3 6303 	ubfxmi	r3, r3, #24, #4
 c040f56:	f3c3 2303 	ubfxpl	r3, r3, #8, #4
 c040f5a:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
 c040f5e:	f7ff bbee 	b.w	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
    else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIRDY)) && (srcclk == RCC_LPTIM1CLKSOURCE_LSI))
 c040f62:	f8d2 10f0 	ldr.w	r1, [r2, #240]	@ 0xf0
 c040f66:	0109      	lsls	r1, r1, #4
 c040f68:	d50c      	bpl.n	c040f84 <HAL_RCCEx_GetPeriphCLKFreq+0x8c8>
 c040f6a:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 c040f6e:	d109      	bne.n	c040f84 <HAL_RCCEx_GetPeriphCLKFreq+0x8c8>
      if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIPREDIV))
 c040f70:	f8d2 30f0 	ldr.w	r3, [r2, #240]	@ 0xf0
        frequency = LSI_VALUE / 128U;
 c040f74:	f013 5f80 	tst.w	r3, #268435456	@ 0x10000000
 c040f78:	bf0c      	ite	eq
 c040f7a:	f44f 40fa 	moveq.w	r0, #32000	@ 0x7d00
 c040f7e:	20fa      	movne	r0, #250	@ 0xfa
 c040f80:	f7ff bbdd 	b.w	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_LPTIM1CLKSOURCE_HSI))
 c040f84:	6812      	ldr	r2, [r2, #0]
 c040f86:	0552      	lsls	r2, r2, #21
 c040f88:	d503      	bpl.n	c040f92 <HAL_RCCEx_GetPeriphCLKFreq+0x8d6>
 c040f8a:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
 c040f8e:	f000 81c6 	beq.w	c04131e <HAL_RCCEx_GetPeriphCLKFreq+0xc62>
    else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_LPTIM1CLKSOURCE_LSE))
 c040f92:	4a14      	ldr	r2, [pc, #80]	@ (c040fe4 <HAL_RCCEx_GetPeriphCLKFreq+0x928>)
 c040f94:	f8d2 00f0 	ldr.w	r0, [r2, #240]	@ 0xf0
 c040f98:	f010 0002 	ands.w	r0, r0, #2
 c040f9c:	f43f abcf 	beq.w	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
 c040fa0:	f5a3 6040 	sub.w	r0, r3, #3072	@ 0xc00
 c040fa4:	4243      	negs	r3, r0
 c040fa6:	4143      	adcs	r3, r0
 c040fa8:	03d8      	lsls	r0, r3, #15
 c040faa:	f7ff bbc8 	b.w	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
    srcclk = __HAL_RCC_GET_LPTIM2_SOURCE();
 c040fae:	4a0d      	ldr	r2, [pc, #52]	@ (c040fe4 <HAL_RCCEx_GetPeriphCLKFreq+0x928>)
 c040fb0:	f8d2 30e0 	ldr.w	r3, [r2, #224]	@ 0xe0
    if (srcclk == RCC_LPTIM2CLKSOURCE_PCLK1)
 c040fb4:	f413 2340 	ands.w	r3, r3, #786432	@ 0xc0000
 c040fb8:	f43f ad81 	beq.w	c040abe <HAL_RCCEx_GetPeriphCLKFreq+0x402>
    else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIRDY)) && (srcclk == RCC_LPTIM2CLKSOURCE_LSI))
 c040fbc:	f8d2 10f0 	ldr.w	r1, [r2, #240]	@ 0xf0
 c040fc0:	0109      	lsls	r1, r1, #4
 c040fc2:	d513      	bpl.n	c040fec <HAL_RCCEx_GetPeriphCLKFreq+0x930>
 c040fc4:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
 c040fc8:	d110      	bne.n	c040fec <HAL_RCCEx_GetPeriphCLKFreq+0x930>
      if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIPREDIV))
 c040fca:	f8d2 30f0 	ldr.w	r3, [r2, #240]	@ 0xf0
        frequency = LSI_VALUE / 128U;
 c040fce:	f013 5f80 	tst.w	r3, #268435456	@ 0x10000000
 c040fd2:	bf0c      	ite	eq
 c040fd4:	f44f 40fa 	moveq.w	r0, #32000	@ 0x7d00
 c040fd8:	20fa      	movne	r0, #250	@ 0xfa
 c040fda:	f7ff bbb0 	b.w	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
 c040fde:	bf00      	nop
 c040fe0:	0c05fa94 	.word	0x0c05fa94
 c040fe4:	56020c00 	.word	0x56020c00
 c040fe8:	00f42400 	.word	0x00f42400
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_LPTIM2CLKSOURCE_HSI))
 c040fec:	6812      	ldr	r2, [r2, #0]
 c040fee:	0552      	lsls	r2, r2, #21
 c040ff0:	d503      	bpl.n	c040ffa <HAL_RCCEx_GetPeriphCLKFreq+0x93e>
 c040ff2:	f5b3 2f00 	cmp.w	r3, #524288	@ 0x80000
 c040ff6:	f000 8195 	beq.w	c041324 <HAL_RCCEx_GetPeriphCLKFreq+0xc68>
    else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_LPTIM2CLKSOURCE_LSE))
 c040ffa:	4abe      	ldr	r2, [pc, #760]	@ (c0412f4 <HAL_RCCEx_GetPeriphCLKFreq+0xc38>)
 c040ffc:	f8d2 00f0 	ldr.w	r0, [r2, #240]	@ 0xf0
 c041000:	f010 0002 	ands.w	r0, r0, #2
 c041004:	f43f ab9b 	beq.w	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
 c041008:	f5a3 2040 	sub.w	r0, r3, #786432	@ 0xc0000
 c04100c:	4243      	negs	r3, r0
 c04100e:	4143      	adcs	r3, r0
 c041010:	03d8      	lsls	r0, r3, #15
 c041012:	f7ff bb94 	b.w	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
    srcclk = __HAL_RCC_GET_FDCAN1_SOURCE();
 c041016:	4ab7      	ldr	r2, [pc, #732]	@ (c0412f4 <HAL_RCCEx_GetPeriphCLKFreq+0xc38>)
 c041018:	f8d2 30e0 	ldr.w	r3, [r2, #224]	@ 0xe0
    if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)) && (srcclk == RCC_FDCAN1CLKSOURCE_HSE))
 c04101c:	6812      	ldr	r2, [r2, #0]
    srcclk = __HAL_RCC_GET_FDCAN1_SOURCE();
 c04101e:	f003 7340 	and.w	r3, r3, #50331648	@ 0x3000000
    if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)) && (srcclk == RCC_FDCAN1CLKSOURCE_HSE))
 c041022:	0391      	lsls	r1, r2, #14
 c041024:	d502      	bpl.n	c04102c <HAL_RCCEx_GetPeriphCLKFreq+0x970>
 c041026:	2b00      	cmp	r3, #0
 c041028:	f000 817f 	beq.w	c04132a <HAL_RCCEx_GetPeriphCLKFreq+0xc6e>
    else if (srcclk == RCC_FDCAN1CLKSOURCE_PLL1) /* PLL1 ? */
 c04102c:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
 c041030:	d105      	bne.n	c04103e <HAL_RCCEx_GetPeriphCLKFreq+0x982>
      HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
 c041032:	a801      	add	r0, sp, #4
 c041034:	f7ff f932 	bl	c04029c <HAL_RCCEx_GetPLL1ClockFreq>
      frequency = pll1_clocks.PLL1_Q_Frequency;
 c041038:	9802      	ldr	r0, [sp, #8]
 c04103a:	f7ff bb80 	b.w	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
    else if (srcclk == RCC_FDCAN1CLKSOURCE_PLL2) /* PLL2 ? */
 c04103e:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
 c041042:	f040 8175 	bne.w	c041330 <HAL_RCCEx_GetPeriphCLKFreq+0xc74>
      HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 c041046:	a801      	add	r0, sp, #4
 c041048:	f7ff f9d8 	bl	c0403fc <HAL_RCCEx_GetPLL2ClockFreq>
      frequency = pll2_clocks.PLL2_P_Frequency;
 c04104c:	9801      	ldr	r0, [sp, #4]
 c04104e:	f7ff bb76 	b.w	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
    srcclk = __HAL_RCC_GET_SPI1_SOURCE();
 c041052:	4ba8      	ldr	r3, [pc, #672]	@ (c0412f4 <HAL_RCCEx_GetPeriphCLKFreq+0xc38>)
 c041054:	f8d3 20e0 	ldr.w	r2, [r3, #224]	@ 0xe0
 c041058:	f402 1240 	and.w	r2, r2, #3145728	@ 0x300000
    switch (srcclk)
 c04105c:	f5b2 1f00 	cmp.w	r2, #2097152	@ 0x200000
 c041060:	d010      	beq.n	c041084 <HAL_RCCEx_GetPeriphCLKFreq+0x9c8>
 c041062:	d809      	bhi.n	c041078 <HAL_RCCEx_GetPeriphCLKFreq+0x9bc>
 c041064:	2a00      	cmp	r2, #0
 c041066:	f43f ad03 	beq.w	c040a70 <HAL_RCCEx_GetPeriphCLKFreq+0x3b4>
 c04106a:	f5b2 1f80 	cmp.w	r2, #1048576	@ 0x100000
 c04106e:	f43f ad06 	beq.w	c040a7e <HAL_RCCEx_GetPeriphCLKFreq+0x3c2>
          frequency = 0U;
 c041072:	2000      	movs	r0, #0
 c041074:	f7ff bb63 	b.w	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
    switch (srcclk)
 c041078:	f5b2 1f40 	cmp.w	r2, #3145728	@ 0x300000
 c04107c:	d00a      	beq.n	c041094 <HAL_RCCEx_GetPeriphCLKFreq+0x9d8>
          frequency = 0U;
 c04107e:	2000      	movs	r0, #0
 c041080:	f7ff bb5d 	b.w	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
 c041084:	6818      	ldr	r0, [r3, #0]
          frequency = HSI_VALUE;
 c041086:	4b9c      	ldr	r3, [pc, #624]	@ (c0412f8 <HAL_RCCEx_GetPeriphCLKFreq+0xc3c>)
 c041088:	f410 6080 	ands.w	r0, r0, #1024	@ 0x400
 c04108c:	bf18      	it	ne
 c04108e:	4618      	movne	r0, r3
 c041090:	f7ff bb55 	b.w	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIKRDY))
 c041094:	6818      	ldr	r0, [r3, #0]
 c041096:	f010 0020 	ands.w	r0, r0, #32
 c04109a:	f43f ab50 	beq.w	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
          frequency = MSIRangeTable[(__HAL_RCC_GET_MSIK_RANGE() >> RCC_ICSCR1_MSIKRANGE_Pos)];
 c04109e:	689a      	ldr	r2, [r3, #8]
 c0410a0:	0212      	lsls	r2, r2, #8
 c0410a2:	bf4c      	ite	mi
 c0410a4:	689b      	ldrmi	r3, [r3, #8]
 c0410a6:	f8d3 30f4 	ldrpl.w	r3, [r3, #244]	@ 0xf4
 c0410aa:	4a94      	ldr	r2, [pc, #592]	@ (c0412fc <HAL_RCCEx_GetPeriphCLKFreq+0xc40>)
 c0410ac:	bf4c      	ite	mi
 c0410ae:	f3c3 6303 	ubfxmi	r3, r3, #24, #4
 c0410b2:	f3c3 2303 	ubfxpl	r3, r3, #8, #4
 c0410b6:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
 c0410ba:	f7ff bb40 	b.w	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
    srcclk = __HAL_RCC_GET_SPI2_SOURCE();
 c0410be:	4b8d      	ldr	r3, [pc, #564]	@ (c0412f4 <HAL_RCCEx_GetPeriphCLKFreq+0xc38>)
 c0410c0:	f8d3 20e0 	ldr.w	r2, [r3, #224]	@ 0xe0
 c0410c4:	f402 3240 	and.w	r2, r2, #196608	@ 0x30000
    switch (srcclk)
 c0410c8:	f5b2 3f00 	cmp.w	r2, #131072	@ 0x20000
 c0410cc:	d010      	beq.n	c0410f0 <HAL_RCCEx_GetPeriphCLKFreq+0xa34>
 c0410ce:	d809      	bhi.n	c0410e4 <HAL_RCCEx_GetPeriphCLKFreq+0xa28>
 c0410d0:	2a00      	cmp	r2, #0
 c0410d2:	f43f acf4 	beq.w	c040abe <HAL_RCCEx_GetPeriphCLKFreq+0x402>
 c0410d6:	f5b2 3f80 	cmp.w	r2, #65536	@ 0x10000
 c0410da:	f43f acd0 	beq.w	c040a7e <HAL_RCCEx_GetPeriphCLKFreq+0x3c2>
          frequency = 0U;
 c0410de:	2000      	movs	r0, #0
 c0410e0:	f7ff bb2d 	b.w	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
    switch (srcclk)
 c0410e4:	f5b2 3f40 	cmp.w	r2, #196608	@ 0x30000
 c0410e8:	d00a      	beq.n	c041100 <HAL_RCCEx_GetPeriphCLKFreq+0xa44>
          frequency = 0U;
 c0410ea:	2000      	movs	r0, #0
 c0410ec:	f7ff bb27 	b.w	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
 c0410f0:	6818      	ldr	r0, [r3, #0]
          frequency = HSI_VALUE;
 c0410f2:	4b81      	ldr	r3, [pc, #516]	@ (c0412f8 <HAL_RCCEx_GetPeriphCLKFreq+0xc3c>)
 c0410f4:	f410 6080 	ands.w	r0, r0, #1024	@ 0x400
 c0410f8:	bf18      	it	ne
 c0410fa:	4618      	movne	r0, r3
 c0410fc:	f7ff bb1f 	b.w	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIKRDY))
 c041100:	6818      	ldr	r0, [r3, #0]
 c041102:	f010 0020 	ands.w	r0, r0, #32
 c041106:	f43f ab1a 	beq.w	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
          frequency = MSIRangeTable[(__HAL_RCC_GET_MSIK_RANGE() >> RCC_ICSCR1_MSIKRANGE_Pos)];
 c04110a:	689a      	ldr	r2, [r3, #8]
 c04110c:	0210      	lsls	r0, r2, #8
 c04110e:	bf4c      	ite	mi
 c041110:	689b      	ldrmi	r3, [r3, #8]
 c041112:	f8d3 30f4 	ldrpl.w	r3, [r3, #244]	@ 0xf4
 c041116:	4a79      	ldr	r2, [pc, #484]	@ (c0412fc <HAL_RCCEx_GetPeriphCLKFreq+0xc40>)
 c041118:	bf4c      	ite	mi
 c04111a:	f3c3 6303 	ubfxmi	r3, r3, #24, #4
 c04111e:	f3c3 2303 	ubfxpl	r3, r3, #8, #4
 c041122:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
 c041126:	f7ff bb0a 	b.w	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
    srcclk = __HAL_RCC_GET_SPI3_SOURCE();
 c04112a:	4b72      	ldr	r3, [pc, #456]	@ (c0412f4 <HAL_RCCEx_GetPeriphCLKFreq+0xc38>)
 c04112c:	f8d3 20e8 	ldr.w	r2, [r3, #232]	@ 0xe8
 c041130:	f002 0218 	and.w	r2, r2, #24
    switch (srcclk)
 c041134:	2a10      	cmp	r2, #16
 c041136:	d00e      	beq.n	c041156 <HAL_RCCEx_GetPeriphCLKFreq+0xa9a>
 c041138:	d808      	bhi.n	c04114c <HAL_RCCEx_GetPeriphCLKFreq+0xa90>
 c04113a:	2a00      	cmp	r2, #0
 c04113c:	f43f ad36 	beq.w	c040bac <HAL_RCCEx_GetPeriphCLKFreq+0x4f0>
 c041140:	2a08      	cmp	r2, #8
 c041142:	f43f ac9c 	beq.w	c040a7e <HAL_RCCEx_GetPeriphCLKFreq+0x3c2>
          frequency = 0U;
 c041146:	2000      	movs	r0, #0
 c041148:	f7ff baf9 	b.w	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
    switch (srcclk)
 c04114c:	2a18      	cmp	r2, #24
 c04114e:	d00a      	beq.n	c041166 <HAL_RCCEx_GetPeriphCLKFreq+0xaaa>
          frequency = 0U;
 c041150:	2000      	movs	r0, #0
 c041152:	f7ff baf4 	b.w	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
 c041156:	6818      	ldr	r0, [r3, #0]
          frequency = HSI_VALUE;
 c041158:	4b67      	ldr	r3, [pc, #412]	@ (c0412f8 <HAL_RCCEx_GetPeriphCLKFreq+0xc3c>)
 c04115a:	f410 6080 	ands.w	r0, r0, #1024	@ 0x400
 c04115e:	bf18      	it	ne
 c041160:	4618      	movne	r0, r3
 c041162:	f7ff baec 	b.w	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIKRDY))
 c041166:	6818      	ldr	r0, [r3, #0]
 c041168:	f010 0020 	ands.w	r0, r0, #32
 c04116c:	f43f aae7 	beq.w	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
          frequency = MSIRangeTable[(__HAL_RCC_GET_MSIK_RANGE() >> RCC_ICSCR1_MSIKRANGE_Pos)];
 c041170:	689a      	ldr	r2, [r3, #8]
 c041172:	0211      	lsls	r1, r2, #8
 c041174:	bf4c      	ite	mi
 c041176:	689b      	ldrmi	r3, [r3, #8]
 c041178:	f8d3 30f4 	ldrpl.w	r3, [r3, #244]	@ 0xf4
 c04117c:	4a5f      	ldr	r2, [pc, #380]	@ (c0412fc <HAL_RCCEx_GetPeriphCLKFreq+0xc40>)
 c04117e:	bf4c      	ite	mi
 c041180:	f3c3 6303 	ubfxmi	r3, r3, #24, #4
 c041184:	f3c3 2303 	ubfxpl	r3, r3, #8, #4
 c041188:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
 c04118c:	f7ff bad7 	b.w	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
    srcclk = __HAL_RCC_GET_OSPI_SOURCE();
 c041190:	4a58      	ldr	r2, [pc, #352]	@ (c0412f4 <HAL_RCCEx_GetPeriphCLKFreq+0xc38>)
 c041192:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
 c041196:	f403 1340 	and.w	r3, r3, #3145728	@ 0x300000
    switch (srcclk)
 c04119a:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
 c04119e:	f43f abf0 	beq.w	c040982 <HAL_RCCEx_GetPeriphCLKFreq+0x2c6>
 c0411a2:	d808      	bhi.n	c0411b6 <HAL_RCCEx_GetPeriphCLKFreq+0xafa>
 c0411a4:	2b00      	cmp	r3, #0
 c0411a6:	f43f ac6a 	beq.w	c040a7e <HAL_RCCEx_GetPeriphCLKFreq+0x3c2>
 c0411aa:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
 c0411ae:	d009      	beq.n	c0411c4 <HAL_RCCEx_GetPeriphCLKFreq+0xb08>
          frequency = 0U;
 c0411b0:	2000      	movs	r0, #0
 c0411b2:	f7ff bac4 	b.w	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
    switch (srcclk)
 c0411b6:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
 c0411ba:	f43f ac15 	beq.w	c0409e8 <HAL_RCCEx_GetPeriphCLKFreq+0x32c>
          frequency = 0U;
 c0411be:	2000      	movs	r0, #0
 c0411c0:	f7ff babd 	b.w	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIKRDY))
 c0411c4:	6810      	ldr	r0, [r2, #0]
 c0411c6:	f010 0020 	ands.w	r0, r0, #32
 c0411ca:	f43f aab8 	beq.w	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
          frequency = MSIRangeTable[(__HAL_RCC_GET_MSIK_RANGE() >> RCC_ICSCR1_MSIKRANGE_Pos)];
 c0411ce:	4b49      	ldr	r3, [pc, #292]	@ (c0412f4 <HAL_RCCEx_GetPeriphCLKFreq+0xc38>)
 c0411d0:	689a      	ldr	r2, [r3, #8]
 c0411d2:	0212      	lsls	r2, r2, #8
 c0411d4:	bf4c      	ite	mi
 c0411d6:	689b      	ldrmi	r3, [r3, #8]
 c0411d8:	f8d3 30f4 	ldrpl.w	r3, [r3, #244]	@ 0xf4
 c0411dc:	4a47      	ldr	r2, [pc, #284]	@ (c0412fc <HAL_RCCEx_GetPeriphCLKFreq+0xc40>)
 c0411de:	bf4c      	ite	mi
 c0411e0:	f3c3 6303 	ubfxmi	r3, r3, #24, #4
 c0411e4:	f3c3 2303 	ubfxpl	r3, r3, #8, #4
 c0411e8:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
 c0411ec:	f7ff baa7 	b.w	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
    srcclk = __HAL_RCC_GET_DAC1_SOURCE();
 c0411f0:	4a40      	ldr	r2, [pc, #256]	@ (c0412f4 <HAL_RCCEx_GetPeriphCLKFreq+0xc38>)
 c0411f2:	f8d2 30e8 	ldr.w	r3, [r2, #232]	@ 0xe8
    if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_DAC1CLKSOURCE_LSE))
 c0411f6:	f8d2 10f0 	ldr.w	r1, [r2, #240]	@ 0xf0
    srcclk = __HAL_RCC_GET_DAC1_SOURCE();
 c0411fa:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
    if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_DAC1CLKSOURCE_LSE))
 c0411fe:	0788      	lsls	r0, r1, #30
 c041200:	d502      	bpl.n	c041208 <HAL_RCCEx_GetPeriphCLKFreq+0xb4c>
 c041202:	2b00      	cmp	r3, #0
 c041204:	f000 8097 	beq.w	c041336 <HAL_RCCEx_GetPeriphCLKFreq+0xc7a>
    else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIRDY)) && (srcclk == RCC_DAC1CLKSOURCE_LSI))
 c041208:	f8d2 00f0 	ldr.w	r0, [r2, #240]	@ 0xf0
 c04120c:	f010 6000 	ands.w	r0, r0, #134217728	@ 0x8000000
 c041210:	f43f aa95 	beq.w	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
 c041214:	2b00      	cmp	r3, #0
 c041216:	f000 8092 	beq.w	c04133e <HAL_RCCEx_GetPeriphCLKFreq+0xc82>
      if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIPREDIV))
 c04121a:	f8d2 30f0 	ldr.w	r3, [r2, #240]	@ 0xf0
        frequency = LSI_VALUE / 128U;
 c04121e:	f013 5f80 	tst.w	r3, #268435456	@ 0x10000000
 c041222:	bf0c      	ite	eq
 c041224:	f44f 40fa 	moveq.w	r0, #32000	@ 0x7d00
 c041228:	20fa      	movne	r0, #250	@ 0xfa
 c04122a:	f7ff ba88 	b.w	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
    srcclk = __HAL_RCC_GET_RNG_SOURCE();
 c04122e:	4a31      	ldr	r2, [pc, #196]	@ (c0412f4 <HAL_RCCEx_GetPeriphCLKFreq+0xc38>)
 c041230:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
    if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSI48RDY)) && (srcclk == RCC_RNGCLKSOURCE_HSI48))
 c041234:	6811      	ldr	r1, [r2, #0]
    srcclk = __HAL_RCC_GET_RNG_SOURCE();
 c041236:	f403 5340 	and.w	r3, r3, #12288	@ 0x3000
    if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSI48RDY)) && (srcclk == RCC_RNGCLKSOURCE_HSI48))
 c04123a:	0489      	lsls	r1, r1, #18
 c04123c:	d502      	bpl.n	c041244 <HAL_RCCEx_GetPeriphCLKFreq+0xb88>
 c04123e:	2b00      	cmp	r3, #0
 c041240:	f000 8080 	beq.w	c041344 <HAL_RCCEx_GetPeriphCLKFreq+0xc88>
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSI48RDY)) && (srcclk == RCC_RNGCLKSOURCE_HSI48_DIV2))
 c041244:	6812      	ldr	r2, [r2, #0]
 c041246:	0492      	lsls	r2, r2, #18
 c041248:	d502      	bpl.n	c041250 <HAL_RCCEx_GetPeriphCLKFreq+0xb94>
 c04124a:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 c04124e:	d07c      	beq.n	c04134a <HAL_RCCEx_GetPeriphCLKFreq+0xc8e>
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_RNGCLKSOURCE_HSI))
 c041250:	4a28      	ldr	r2, [pc, #160]	@ (c0412f4 <HAL_RCCEx_GetPeriphCLKFreq+0xc38>)
 c041252:	6810      	ldr	r0, [r2, #0]
 c041254:	f410 6080 	ands.w	r0, r0, #1024	@ 0x400
 c041258:	f43f aa71 	beq.w	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
          frequency = HSI_VALUE;
 c04125c:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 c041260:	4825      	ldr	r0, [pc, #148]	@ (c0412f8 <HAL_RCCEx_GetPeriphCLKFreq+0xc3c>)
 c041262:	bf18      	it	ne
 c041264:	2000      	movne	r0, #0
 c041266:	f7ff ba6a 	b.w	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
          frequency = 0U;
 c04126a:	2000      	movs	r0, #0
 c04126c:	f7ff ba67 	b.w	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
 c041270:	2000      	movs	r0, #0
 c041272:	f7ff ba64 	b.w	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
      frequency = LSE_VALUE;
 c041276:	f44f 4000 	mov.w	r0, #32768	@ 0x8000
 c04127a:	f7ff ba60 	b.w	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
        frequency = EXTERNAL_SAI1_CLOCK_VALUE;
 c04127e:	f64b 3080 	movw	r0, #48000	@ 0xbb80
 c041282:	f7ff ba5c 	b.w	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
 c041286:	f64b 3080 	movw	r0, #48000	@ 0xbb80
 c04128a:	f7ff ba58 	b.w	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
          frequency = 0U;
 c04128e:	2000      	movs	r0, #0
 c041290:	f7ff ba55 	b.w	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
          frequency = HSI_VALUE;
 c041294:	4818      	ldr	r0, [pc, #96]	@ (c0412f8 <HAL_RCCEx_GetPeriphCLKFreq+0xc3c>)
 c041296:	f7ff ba52 	b.w	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
 c04129a:	4817      	ldr	r0, [pc, #92]	@ (c0412f8 <HAL_RCCEx_GetPeriphCLKFreq+0xc3c>)
 c04129c:	f7ff ba4f 	b.w	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
 c0412a0:	4815      	ldr	r0, [pc, #84]	@ (c0412f8 <HAL_RCCEx_GetPeriphCLKFreq+0xc3c>)
 c0412a2:	f7ff ba4c 	b.w	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
 c0412a6:	4814      	ldr	r0, [pc, #80]	@ (c0412f8 <HAL_RCCEx_GetPeriphCLKFreq+0xc3c>)
 c0412a8:	f7ff ba49 	b.w	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
 c0412ac:	4812      	ldr	r0, [pc, #72]	@ (c0412f8 <HAL_RCCEx_GetPeriphCLKFreq+0xc3c>)
 c0412ae:	f7ff ba46 	b.w	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
 c0412b2:	4811      	ldr	r0, [pc, #68]	@ (c0412f8 <HAL_RCCEx_GetPeriphCLKFreq+0xc3c>)
 c0412b4:	f7ff ba43 	b.w	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
 c0412b8:	480f      	ldr	r0, [pc, #60]	@ (c0412f8 <HAL_RCCEx_GetPeriphCLKFreq+0xc3c>)
 c0412ba:	f7ff ba40 	b.w	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
      frequency = LSE_VALUE;
 c0412be:	f44f 4000 	mov.w	r0, #32768	@ 0x8000
 c0412c2:	f7ff ba3c 	b.w	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
          frequency = 0U;
 c0412c6:	2000      	movs	r0, #0
 c0412c8:	f7ff ba39 	b.w	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
          frequency = HSI_VALUE;
 c0412cc:	480a      	ldr	r0, [pc, #40]	@ (c0412f8 <HAL_RCCEx_GetPeriphCLKFreq+0xc3c>)
 c0412ce:	f7ff ba36 	b.w	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
        frequency = EXTERNAL_SAI1_CLOCK_VALUE;
 c0412d2:	f64b 3080 	movw	r0, #48000	@ 0xbb80
 c0412d6:	f7ff ba32 	b.w	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
 c0412da:	f64b 3080 	movw	r0, #48000	@ 0xbb80
 c0412de:	f7ff ba2e 	b.w	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
          frequency = 0U;
 c0412e2:	2000      	movs	r0, #0
 c0412e4:	f7ff ba2b 	b.w	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
          frequency = HSI_VALUE;
 c0412e8:	4803      	ldr	r0, [pc, #12]	@ (c0412f8 <HAL_RCCEx_GetPeriphCLKFreq+0xc3c>)
 c0412ea:	f7ff ba28 	b.w	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
          frequency = 0U;
 c0412ee:	2000      	movs	r0, #0
 c0412f0:	f7ff ba25 	b.w	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
 c0412f4:	56020c00 	.word	0x56020c00
 c0412f8:	00f42400 	.word	0x00f42400
 c0412fc:	0c05fa94 	.word	0x0c05fa94
          frequency = HSI_VALUE;
 c041300:	4813      	ldr	r0, [pc, #76]	@ (c041350 <HAL_RCCEx_GetPeriphCLKFreq+0xc94>)
 c041302:	f7ff ba1c 	b.w	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
          frequency = 0U;
 c041306:	2000      	movs	r0, #0
 c041308:	f7ff ba19 	b.w	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
          frequency = HSI_VALUE;
 c04130c:	4810      	ldr	r0, [pc, #64]	@ (c041350 <HAL_RCCEx_GetPeriphCLKFreq+0xc94>)
 c04130e:	f7ff ba16 	b.w	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
          frequency = 0U;
 c041312:	2000      	movs	r0, #0
 c041314:	f7ff ba13 	b.w	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
          frequency = HSI_VALUE;
 c041318:	480d      	ldr	r0, [pc, #52]	@ (c041350 <HAL_RCCEx_GetPeriphCLKFreq+0xc94>)
 c04131a:	f7ff ba10 	b.w	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
 c04131e:	480c      	ldr	r0, [pc, #48]	@ (c041350 <HAL_RCCEx_GetPeriphCLKFreq+0xc94>)
 c041320:	f7ff ba0d 	b.w	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
 c041324:	480a      	ldr	r0, [pc, #40]	@ (c041350 <HAL_RCCEx_GetPeriphCLKFreq+0xc94>)
 c041326:	f7ff ba0a 	b.w	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
 c04132a:	4809      	ldr	r0, [pc, #36]	@ (c041350 <HAL_RCCEx_GetPeriphCLKFreq+0xc94>)
 c04132c:	f7ff ba07 	b.w	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
          frequency = 0U;
 c041330:	2000      	movs	r0, #0
 c041332:	f7ff ba04 	b.w	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
      frequency = LSE_VALUE;
 c041336:	f44f 4000 	mov.w	r0, #32768	@ 0x8000
 c04133a:	f7ff ba00 	b.w	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
          frequency = 0U;
 c04133e:	4618      	mov	r0, r3
 c041340:	f7ff b9fd 	b.w	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
          frequency = HSI48_VALUE;
 c041344:	4803      	ldr	r0, [pc, #12]	@ (c041354 <HAL_RCCEx_GetPeriphCLKFreq+0xc98>)
 c041346:	f7ff b9fa 	b.w	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
      frequency = HSI48_VALUE >> 1U ;
 c04134a:	4803      	ldr	r0, [pc, #12]	@ (c041358 <HAL_RCCEx_GetPeriphCLKFreq+0xc9c>)
 c04134c:	f7ff b9f7 	b.w	c04073e <HAL_RCCEx_GetPeriphCLKFreq+0x82>
 c041350:	00f42400 	.word	0x00f42400
 c041354:	02dc6c00 	.word	0x02dc6c00
 c041358:	016e3600 	.word	0x016e3600

0c04135c <HAL_RNG_MspInit>:
  /* Prevent unused argument(s) compilation warning */
  UNUSED(hrng);
  /* NOTE : This function should not be modified. When the callback is needed,
            function HAL_RNG_MspInit must be implemented in the user file.
   */
}
 c04135c:	4770      	bx	lr

0c04135e <HAL_RNG_Init>:
{
 c04135e:	b538      	push	{r3, r4, r5, lr}
  if (hrng == NULL)
 c041360:	4604      	mov	r4, r0
 c041362:	2800      	cmp	r0, #0
 c041364:	d039      	beq.n	c0413da <HAL_RNG_Init+0x7c>
  if (hrng->State == HAL_RNG_STATE_RESET)
 c041366:	7a43      	ldrb	r3, [r0, #9]
 c041368:	f003 02ff 	and.w	r2, r3, #255	@ 0xff
 c04136c:	b913      	cbnz	r3, c041374 <HAL_RNG_Init+0x16>
    hrng->Lock = HAL_UNLOCKED;
 c04136e:	7202      	strb	r2, [r0, #8]
    HAL_RNG_MspInit(hrng);
 c041370:	f7ff fff4 	bl	c04135c <HAL_RNG_MspInit>
  hrng->State = HAL_RNG_STATE_BUSY;
 c041374:	2302      	movs	r3, #2
  __HAL_RNG_DISABLE(hrng);
 c041376:	6822      	ldr	r2, [r4, #0]
  hrng->State = HAL_RNG_STATE_BUSY;
 c041378:	7263      	strb	r3, [r4, #9]
  __HAL_RNG_DISABLE(hrng);
 c04137a:	6813      	ldr	r3, [r2, #0]
  MODIFY_REG(hrng->Instance->CR, RNG_CR_CED | RNG_CR_CONDRST, hrng->Init.ClockErrorDetection | RNG_CR_CONDRST);
 c04137c:	6861      	ldr	r1, [r4, #4]
  __HAL_RNG_DISABLE(hrng);
 c04137e:	f023 0304 	bic.w	r3, r3, #4
 c041382:	6013      	str	r3, [r2, #0]
  MODIFY_REG(hrng->Instance->CR, RNG_CR_CED | RNG_CR_CONDRST, hrng->Init.ClockErrorDetection | RNG_CR_CONDRST);
 c041384:	6813      	ldr	r3, [r2, #0]
 c041386:	f023 4380 	bic.w	r3, r3, #1073741824	@ 0x40000000
 c04138a:	f023 0320 	bic.w	r3, r3, #32
 c04138e:	430b      	orrs	r3, r1
 c041390:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
 c041394:	6013      	str	r3, [r2, #0]
  CLEAR_BIT(hrng->Instance->CR, RNG_CR_CONDRST);
 c041396:	6813      	ldr	r3, [r2, #0]
 c041398:	f023 4380 	bic.w	r3, r3, #1073741824	@ 0x40000000
 c04139c:	6013      	str	r3, [r2, #0]
  tickstart = HAL_GetTick();
 c04139e:	f002 fca3 	bl	c043ce8 <HAL_GetTick>
 c0413a2:	4605      	mov	r5, r0
  while (HAL_IS_BIT_SET(hrng->Instance->CR, RNG_CR_CONDRST))
 c0413a4:	6823      	ldr	r3, [r4, #0]
 c0413a6:	681a      	ldr	r2, [r3, #0]
 c0413a8:	0051      	lsls	r1, r2, #1
 c0413aa:	d409      	bmi.n	c0413c0 <HAL_RNG_Init+0x62>
  __HAL_RNG_ENABLE(hrng);
 c0413ac:	681a      	ldr	r2, [r3, #0]
 c0413ae:	f042 0204 	orr.w	r2, r2, #4
 c0413b2:	601a      	str	r2, [r3, #0]
  if (__HAL_RNG_GET_IT(hrng, RNG_IT_SEI) != RESET)
 c0413b4:	685b      	ldr	r3, [r3, #4]
 c0413b6:	065a      	lsls	r2, r3, #25
 c0413b8:	d511      	bpl.n	c0413de <HAL_RNG_Init+0x80>
    hrng->State = HAL_RNG_STATE_ERROR;
 c0413ba:	2304      	movs	r3, #4
 c0413bc:	7263      	strb	r3, [r4, #9]
    return HAL_ERROR;
 c0413be:	e00c      	b.n	c0413da <HAL_RNG_Init+0x7c>
    if ((HAL_GetTick() - tickstart) > RNG_TIMEOUT_VALUE)
 c0413c0:	f002 fc92 	bl	c043ce8 <HAL_GetTick>
 c0413c4:	1b40      	subs	r0, r0, r5
 c0413c6:	2804      	cmp	r0, #4
 c0413c8:	d9ec      	bls.n	c0413a4 <HAL_RNG_Init+0x46>
      if (HAL_IS_BIT_SET(hrng->Instance->CR, RNG_CR_CONDRST))
 c0413ca:	6823      	ldr	r3, [r4, #0]
 c0413cc:	681b      	ldr	r3, [r3, #0]
 c0413ce:	0058      	lsls	r0, r3, #1
 c0413d0:	d5e8      	bpl.n	c0413a4 <HAL_RNG_Init+0x46>
        hrng->State = HAL_RNG_STATE_READY;
 c0413d2:	2301      	movs	r3, #1
 c0413d4:	7263      	strb	r3, [r4, #9]
        hrng->ErrorCode = HAL_RNG_ERROR_TIMEOUT;
 c0413d6:	2302      	movs	r3, #2
 c0413d8:	60e3      	str	r3, [r4, #12]
    return HAL_ERROR;
 c0413da:	2001      	movs	r0, #1
}
 c0413dc:	bd38      	pop	{r3, r4, r5, pc}
  tickstart = HAL_GetTick();
 c0413de:	f002 fc83 	bl	c043ce8 <HAL_GetTick>
 c0413e2:	4605      	mov	r5, r0
  while (__HAL_RNG_GET_FLAG(hrng, RNG_FLAG_SECS) != RESET)
 c0413e4:	6823      	ldr	r3, [r4, #0]
 c0413e6:	6858      	ldr	r0, [r3, #4]
 c0413e8:	f010 0004 	ands.w	r0, r0, #4
 c0413ec:	d103      	bne.n	c0413f6 <HAL_RNG_Init+0x98>
  hrng->State = HAL_RNG_STATE_READY;
 c0413ee:	2301      	movs	r3, #1
 c0413f0:	7263      	strb	r3, [r4, #9]
  hrng->ErrorCode = HAL_RNG_ERROR_NONE;
 c0413f2:	60e0      	str	r0, [r4, #12]
  return HAL_OK;
 c0413f4:	e7f2      	b.n	c0413dc <HAL_RNG_Init+0x7e>
    if ((HAL_GetTick() - tickstart) > RNG_TIMEOUT_VALUE)
 c0413f6:	f002 fc77 	bl	c043ce8 <HAL_GetTick>
 c0413fa:	1b40      	subs	r0, r0, r5
 c0413fc:	2804      	cmp	r0, #4
 c0413fe:	d9f1      	bls.n	c0413e4 <HAL_RNG_Init+0x86>
      if (__HAL_RNG_GET_FLAG(hrng, RNG_FLAG_SECS) != RESET)
 c041400:	6823      	ldr	r3, [r4, #0]
 c041402:	685b      	ldr	r3, [r3, #4]
 c041404:	075b      	lsls	r3, r3, #29
 c041406:	d5ed      	bpl.n	c0413e4 <HAL_RNG_Init+0x86>
        hrng->State = HAL_RNG_STATE_ERROR;
 c041408:	2304      	movs	r3, #4
 c04140a:	e7e3      	b.n	c0413d4 <HAL_RNG_Init+0x76>

0c04140c <HAL_RNG_ErrorCallback>:
  * @brief  RNG error callbacks.
  * @param  hrng pointer to a RNG_HandleTypeDef structure that contains
  *                the configuration information for RNG.
  * @retval None
  */
__weak void HAL_RNG_ErrorCallback(RNG_HandleTypeDef *hrng)
 c04140c:	4770      	bx	lr

0c04140e <RNG_RecoverSeedError>:
  * @param  hrng pointer to a RNG_HandleTypeDef structure.
  * @retval HAL status
  */
HAL_StatusTypeDef RNG_RecoverSeedError(RNG_HandleTypeDef *hrng)
{
  __IO uint32_t count = 0U;
 c04140e:	2300      	movs	r3, #0
{
 c041410:	b507      	push	{r0, r1, r2, lr}
  __IO uint32_t count = 0U;
 c041412:	9301      	str	r3, [sp, #4]

  /*Check if seed error current status (SECS)is set */
  if (__HAL_RNG_GET_FLAG(hrng, RNG_FLAG_SECS) == RESET)
 c041414:	6803      	ldr	r3, [r0, #0]
 c041416:	685a      	ldr	r2, [r3, #4]
 c041418:	0751      	lsls	r1, r2, #29
 c04141a:	d409      	bmi.n	c041430 <RNG_RecoverSeedError+0x22>
  {
    /* RNG performed the reset automatically (auto-reset) */
    /* Clear bit SEIS */
    CLEAR_BIT(hrng->Instance->SR, RNG_IT_SEI);
 c04141c:	685a      	ldr	r2, [r3, #4]
 c04141e:	f022 0240 	bic.w	r2, r2, #64	@ 0x40
 c041422:	605a      	str	r2, [r3, #4]
        return HAL_ERROR;
      }
    } while (HAL_IS_BIT_SET(hrng->Instance->SR, RNG_FLAG_SECS));
  }
  /* Update the error code */
  hrng->ErrorCode &= ~ HAL_RNG_ERROR_SEED;
 c041424:	68c3      	ldr	r3, [r0, #12]
 c041426:	f023 0308 	bic.w	r3, r3, #8
 c04142a:	60c3      	str	r3, [r0, #12]
  return HAL_OK;
 c04142c:	2000      	movs	r0, #0
 c04142e:	e018      	b.n	c041462 <RNG_RecoverSeedError+0x54>
    SET_BIT(hrng->Instance->CR, RNG_CR_CONDRST);
 c041430:	681a      	ldr	r2, [r3, #0]
 c041432:	f042 4280 	orr.w	r2, r2, #1073741824	@ 0x40000000
 c041436:	601a      	str	r2, [r3, #0]
    CLEAR_BIT(hrng->Instance->CR, RNG_CR_CONDRST);
 c041438:	681a      	ldr	r2, [r3, #0]
 c04143a:	f022 4280 	bic.w	r2, r2, #1073741824	@ 0x40000000
 c04143e:	601a      	str	r2, [r3, #0]
    count = RNG_TIMEOUT_VALUE;
 c041440:	2204      	movs	r2, #4
 c041442:	9201      	str	r2, [sp, #4]
      count-- ;
 c041444:	9a01      	ldr	r2, [sp, #4]
 c041446:	3a01      	subs	r2, #1
 c041448:	9201      	str	r2, [sp, #4]
      if (count == 0U)
 c04144a:	9a01      	ldr	r2, [sp, #4]
 c04144c:	b962      	cbnz	r2, c041468 <RNG_RecoverSeedError+0x5a>
        hrng->State = HAL_RNG_STATE_READY;
 c04144e:	2301      	movs	r3, #1
 c041450:	7243      	strb	r3, [r0, #9]
        hrng->ErrorCode |= HAL_RNG_ERROR_TIMEOUT;
 c041452:	68c3      	ldr	r3, [r0, #12]
        __HAL_UNLOCK(hrng);
 c041454:	7202      	strb	r2, [r0, #8]
        hrng->ErrorCode |= HAL_RNG_ERROR_TIMEOUT;
 c041456:	f043 0302 	orr.w	r3, r3, #2
 c04145a:	60c3      	str	r3, [r0, #12]
        HAL_RNG_ErrorCallback(hrng);
 c04145c:	f7ff ffd6 	bl	c04140c <HAL_RNG_ErrorCallback>
        return HAL_ERROR;
 c041460:	2001      	movs	r0, #1
}
 c041462:	b003      	add	sp, #12
 c041464:	f85d fb04 	ldr.w	pc, [sp], #4
    } while (HAL_IS_BIT_SET(hrng->Instance->CR, RNG_CR_CONDRST));
 c041468:	681a      	ldr	r2, [r3, #0]
 c04146a:	0052      	lsls	r2, r2, #1
 c04146c:	d4ea      	bmi.n	c041444 <RNG_RecoverSeedError+0x36>
    if (__HAL_RNG_GET_IT(hrng, RNG_IT_SEI) != RESET)
 c04146e:	685a      	ldr	r2, [r3, #4]
 c041470:	0651      	lsls	r1, r2, #25
      CLEAR_BIT(hrng->Instance->SR, RNG_IT_SEI);
 c041472:	bf42      	ittt	mi
 c041474:	685a      	ldrmi	r2, [r3, #4]
 c041476:	f022 0240 	bicmi.w	r2, r2, #64	@ 0x40
 c04147a:	605a      	strmi	r2, [r3, #4]
    count = RNG_TIMEOUT_VALUE;
 c04147c:	2204      	movs	r2, #4
 c04147e:	9201      	str	r2, [sp, #4]
      count-- ;
 c041480:	9a01      	ldr	r2, [sp, #4]
 c041482:	3a01      	subs	r2, #1
 c041484:	9201      	str	r2, [sp, #4]
      if (count == 0U)
 c041486:	9a01      	ldr	r2, [sp, #4]
 c041488:	2a00      	cmp	r2, #0
 c04148a:	d0e0      	beq.n	c04144e <RNG_RecoverSeedError+0x40>
    } while (HAL_IS_BIT_SET(hrng->Instance->SR, RNG_FLAG_SECS));
 c04148c:	685a      	ldr	r2, [r3, #4]
 c04148e:	0752      	lsls	r2, r2, #29
 c041490:	d4f6      	bmi.n	c041480 <RNG_RecoverSeedError+0x72>
 c041492:	e7c7      	b.n	c041424 <RNG_RecoverSeedError+0x16>

0c041494 <HAL_RNG_GenerateRandomNumber>:
{
 c041494:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  __HAL_LOCK(hrng);
 c041498:	7a03      	ldrb	r3, [r0, #8]
{
 c04149a:	4604      	mov	r4, r0
  __HAL_LOCK(hrng);
 c04149c:	2b01      	cmp	r3, #1
{
 c04149e:	460f      	mov	r7, r1
  __HAL_LOCK(hrng);
 c0414a0:	d045      	beq.n	c04152e <HAL_RNG_GenerateRandomNumber+0x9a>
 c0414a2:	2301      	movs	r3, #1
  if (hrng->State == HAL_RNG_STATE_READY)
 c0414a4:	7a42      	ldrb	r2, [r0, #9]
  __HAL_LOCK(hrng);
 c0414a6:	7203      	strb	r3, [r0, #8]
  if (hrng->State == HAL_RNG_STATE_READY)
 c0414a8:	429a      	cmp	r2, r3
 c0414aa:	b2d6      	uxtb	r6, r2
 c0414ac:	d13b      	bne.n	c041526 <HAL_RNG_GenerateRandomNumber+0x92>
    hrng->State = HAL_RNG_STATE_BUSY;
 c0414ae:	2302      	movs	r3, #2
 c0414b0:	7243      	strb	r3, [r0, #9]
    if (__HAL_RNG_GET_IT(hrng, RNG_IT_SEI) != RESET)
 c0414b2:	6803      	ldr	r3, [r0, #0]
 c0414b4:	685d      	ldr	r5, [r3, #4]
 c0414b6:	f015 0540 	ands.w	r5, r5, #64	@ 0x40
 c0414ba:	d006      	beq.n	c0414ca <HAL_RNG_GenerateRandomNumber+0x36>
      hrng->ErrorCode = HAL_RNG_ERROR_SEED;
 c0414bc:	2308      	movs	r3, #8
 c0414be:	60c3      	str	r3, [r0, #12]
      status = RNG_RecoverSeedError(hrng);
 c0414c0:	f7ff ffa5 	bl	c04140e <RNG_RecoverSeedError>
      if (status == HAL_ERROR)
 c0414c4:	2801      	cmp	r0, #1
      status = RNG_RecoverSeedError(hrng);
 c0414c6:	4605      	mov	r5, r0
      if (status == HAL_ERROR)
 c0414c8:	d02a      	beq.n	c041520 <HAL_RNG_GenerateRandomNumber+0x8c>
    tickstart = HAL_GetTick();
 c0414ca:	f002 fc0d 	bl	c043ce8 <HAL_GetTick>
 c0414ce:	4680      	mov	r8, r0
    while (__HAL_RNG_GET_FLAG(hrng, RNG_FLAG_DRDY) == RESET)
 c0414d0:	6823      	ldr	r3, [r4, #0]
 c0414d2:	685a      	ldr	r2, [r3, #4]
 c0414d4:	07d0      	lsls	r0, r2, #31
 c0414d6:	d513      	bpl.n	c041500 <HAL_RNG_GenerateRandomNumber+0x6c>
    hrng->RandomNumber = hrng->Instance->DR;
 c0414d8:	689a      	ldr	r2, [r3, #8]
    if (__HAL_RNG_GET_IT(hrng, RNG_IT_SEI) != RESET)
 c0414da:	6859      	ldr	r1, [r3, #4]
    hrng->RandomNumber = hrng->Instance->DR;
 c0414dc:	6122      	str	r2, [r4, #16]
    if (__HAL_RNG_GET_IT(hrng, RNG_IT_SEI) != RESET)
 c0414de:	0649      	lsls	r1, r1, #25
      hrng->ErrorCode = HAL_RNG_ERROR_SEED;
 c0414e0:	bf43      	ittte	mi
 c0414e2:	2208      	movmi	r2, #8
 c0414e4:	60e2      	strmi	r2, [r4, #12]
      CLEAR_BIT(hrng->Instance->SR, RNG_FLAG_DRDY);
 c0414e6:	685a      	ldrmi	r2, [r3, #4]
      *random32bit = hrng->RandomNumber;
 c0414e8:	462e      	movpl	r6, r5
      CLEAR_BIT(hrng->Instance->SR, RNG_FLAG_DRDY);
 c0414ea:	bf44      	itt	mi
 c0414ec:	f022 0201 	bicmi.w	r2, r2, #1
 c0414f0:	605a      	strmi	r2, [r3, #4]
    hrng->State = HAL_RNG_STATE_READY;
 c0414f2:	f04f 0301 	mov.w	r3, #1
      *random32bit = hrng->RandomNumber;
 c0414f6:	bf58      	it	pl
 c0414f8:	603a      	strpl	r2, [r7, #0]
    hrng->State = HAL_RNG_STATE_READY;
 c0414fa:	7263      	strb	r3, [r4, #9]
  __HAL_UNLOCK(hrng);
 c0414fc:	2300      	movs	r3, #0
 c0414fe:	e00e      	b.n	c04151e <HAL_RNG_GenerateRandomNumber+0x8a>
      if ((HAL_GetTick() - tickstart) > RNG_TIMEOUT_VALUE)
 c041500:	f002 fbf2 	bl	c043ce8 <HAL_GetTick>
 c041504:	eba0 0008 	sub.w	r0, r0, r8
 c041508:	2804      	cmp	r0, #4
 c04150a:	d9e1      	bls.n	c0414d0 <HAL_RNG_GenerateRandomNumber+0x3c>
        if (__HAL_RNG_GET_FLAG(hrng, RNG_FLAG_DRDY) == RESET)
 c04150c:	6823      	ldr	r3, [r4, #0]
 c04150e:	685b      	ldr	r3, [r3, #4]
 c041510:	f013 0301 	ands.w	r3, r3, #1
 c041514:	d1dc      	bne.n	c0414d0 <HAL_RNG_GenerateRandomNumber+0x3c>
          hrng->State = HAL_RNG_STATE_READY;
 c041516:	2201      	movs	r2, #1
 c041518:	7262      	strb	r2, [r4, #9]
          hrng->ErrorCode = HAL_RNG_ERROR_TIMEOUT;
 c04151a:	2202      	movs	r2, #2
 c04151c:	60e2      	str	r2, [r4, #12]
  __HAL_UNLOCK(hrng);
 c04151e:	7223      	strb	r3, [r4, #8]
}
 c041520:	4630      	mov	r0, r6
 c041522:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    hrng->ErrorCode = HAL_RNG_ERROR_BUSY;
 c041526:	2204      	movs	r2, #4
    status = HAL_ERROR;
 c041528:	461e      	mov	r6, r3
    hrng->ErrorCode = HAL_RNG_ERROR_BUSY;
 c04152a:	60c2      	str	r2, [r0, #12]
    status = HAL_ERROR;
 c04152c:	e7e6      	b.n	c0414fc <HAL_RNG_GenerateRandomNumber+0x68>
  __HAL_LOCK(hrng);
 c04152e:	2602      	movs	r6, #2
 c041530:	e7f6      	b.n	c041520 <HAL_RNG_GenerateRandomNumber+0x8c>
	...

0c041534 <UART_EndRxTransfer>:
  * @brief  End ongoing Rx transfer on UART peripheral (following error detection or Reception completion).
  * @param  huart UART handle.
  * @retval None
  */
static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
{
 c041534:	b510      	push	{r4, lr}
  /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
 c041536:	6802      	ldr	r2, [r0, #0]
 */
__STATIC_FORCEINLINE uint32_t __LDREXW(volatile uint32_t *addr)
{
    uint32_t result;

   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 c041538:	e852 3f00 	ldrex	r3, [r2]
 c04153c:	f423 7390 	bic.w	r3, r3, #288	@ 0x120
 */
__STATIC_FORCEINLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
{
   uint32_t result;

   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 c041540:	e842 3100 	strex	r1, r3, [r2]
   return(result);
 c041544:	6802      	ldr	r2, [r0, #0]
 c041546:	2900      	cmp	r1, #0
 c041548:	d1f5      	bne.n	c041536 <UART_EndRxTransfer+0x2>
  ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
 c04154a:	4c0f      	ldr	r4, [pc, #60]	@ (c041588 <UART_EndRxTransfer+0x54>)
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 c04154c:	f102 0308 	add.w	r3, r2, #8
 c041550:	e853 3f00 	ldrex	r3, [r3]
 c041554:	4023      	ands	r3, r4
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 c041556:	f102 0c08 	add.w	ip, r2, #8
 c04155a:	e84c 3100 	strex	r1, r3, [ip]
 c04155e:	2900      	cmp	r1, #0
 c041560:	d1f4      	bne.n	c04154c <UART_EndRxTransfer+0x18>

  /* In case of reception waiting for IDLE event, disable also the IDLE IE interrupt source */
  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 c041562:	6ec3      	ldr	r3, [r0, #108]	@ 0x6c
 c041564:	2b01      	cmp	r3, #1
 c041566:	d107      	bne.n	c041578 <UART_EndRxTransfer+0x44>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 c041568:	e852 3f00 	ldrex	r3, [r2]
  {
    ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 c04156c:	f023 0310 	bic.w	r3, r3, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 c041570:	e842 3100 	strex	r1, r3, [r2]
 c041574:	2900      	cmp	r1, #0
 c041576:	d1f7      	bne.n	c041568 <UART_EndRxTransfer+0x34>
  }

  /* At end of Rx process, restore huart->RxState to Ready */
  huart->RxState = HAL_UART_STATE_READY;
 c041578:	2320      	movs	r3, #32
 c04157a:	f8c0 308c 	str.w	r3, [r0, #140]	@ 0x8c
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 c04157e:	2300      	movs	r3, #0
 c041580:	66c3      	str	r3, [r0, #108]	@ 0x6c

  /* Reset RxIsr function pointer */
  huart->RxISR = NULL;
 c041582:	6743      	str	r3, [r0, #116]	@ 0x74
}
 c041584:	bd10      	pop	{r4, pc}
 c041586:	bf00      	nop
 c041588:	effffffe 	.word	0xeffffffe

0c04158c <HAL_UART_MspInit>:
}
 c04158c:	4770      	bx	lr

0c04158e <HAL_UART_RxCpltCallback>:
__weak void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
 c04158e:	4770      	bx	lr

0c041590 <HAL_UART_ErrorCallback>:
__weak void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart)
 c041590:	4770      	bx	lr

0c041592 <HAL_UARTEx_RxEventCallback>:
}
 c041592:	4770      	bx	lr

0c041594 <UART_RxISR_8BIT>:
{
  uint16_t uhMask = huart->Mask;
  uint16_t  uhdata;

  /* Check that a Rx process is ongoing */
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 c041594:	f8d0 208c 	ldr.w	r2, [r0, #140]	@ 0x8c
{
 c041598:	b508      	push	{r3, lr}
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 c04159a:	2a22      	cmp	r2, #34	@ 0x22
  uint16_t uhMask = huart->Mask;
 c04159c:	f8b0 1060 	ldrh.w	r1, [r0, #96]	@ 0x60
  {
    uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 c0415a0:	6803      	ldr	r3, [r0, #0]
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 c0415a2:	d158      	bne.n	c041656 <UART_RxISR_8BIT+0xc2>
    uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 c0415a4:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
    *huart->pRxBuffPtr = (uint8_t)(uhdata & (uint8_t)uhMask);
 c0415a6:	6d82      	ldr	r2, [r0, #88]	@ 0x58
 c0415a8:	400b      	ands	r3, r1
 c0415aa:	7013      	strb	r3, [r2, #0]
    huart->pRxBuffPtr++;
 c0415ac:	6d83      	ldr	r3, [r0, #88]	@ 0x58
 c0415ae:	3301      	adds	r3, #1
 c0415b0:	6583      	str	r3, [r0, #88]	@ 0x58
    huart->RxXferCount--;
 c0415b2:	f8b0 305e 	ldrh.w	r3, [r0, #94]	@ 0x5e
 c0415b6:	3b01      	subs	r3, #1
 c0415b8:	b29b      	uxth	r3, r3
 c0415ba:	f8a0 305e 	strh.w	r3, [r0, #94]	@ 0x5e

    if (huart->RxXferCount == 0U)
 c0415be:	f8b0 305e 	ldrh.w	r3, [r0, #94]	@ 0x5e
 c0415c2:	b29b      	uxth	r3, r3
 c0415c4:	2b00      	cmp	r3, #0
 c0415c6:	d145      	bne.n	c041654 <UART_RxISR_8BIT+0xc0>
    {
      /* Disable the UART Parity Error Interrupt and RXNE interrupts */
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
 c0415c8:	6802      	ldr	r2, [r0, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 c0415ca:	e852 3f00 	ldrex	r3, [r2]
 c0415ce:	f423 7390 	bic.w	r3, r3, #288	@ 0x120
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 c0415d2:	e842 3100 	strex	r1, r3, [r2]
   return(result);
 c0415d6:	6803      	ldr	r3, [r0, #0]
 c0415d8:	2900      	cmp	r1, #0
 c0415da:	d1f5      	bne.n	c0415c8 <UART_RxISR_8BIT+0x34>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 c0415dc:	f103 0208 	add.w	r2, r3, #8
 c0415e0:	e852 2f00 	ldrex	r2, [r2]

      /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
      ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 c0415e4:	f022 0201 	bic.w	r2, r2, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 c0415e8:	f103 0c08 	add.w	ip, r3, #8
 c0415ec:	e84c 2100 	strex	r1, r2, [ip]
 c0415f0:	2900      	cmp	r1, #0
 c0415f2:	d1f3      	bne.n	c0415dc <UART_RxISR_8BIT+0x48>

      /* Rx process is completed, restore huart->RxState to Ready */
      huart->RxState = HAL_UART_STATE_READY;
 c0415f4:	2220      	movs	r2, #32
 c0415f6:	f8c0 208c 	str.w	r2, [r0, #140]	@ 0x8c
      huart->RxISR = NULL;

      /* Initialize type of RxEvent to Transfer Complete */
      huart->RxEventType = HAL_UART_RXEVENT_TC;

      if (!(IS_LPUART_INSTANCE(huart->Instance)))
 c0415fa:	4a19      	ldr	r2, [pc, #100]	@ (c041660 <UART_RxISR_8BIT+0xcc>)
      huart->RxISR = NULL;
 c0415fc:	6741      	str	r1, [r0, #116]	@ 0x74
      if (!(IS_LPUART_INSTANCE(huart->Instance)))
 c0415fe:	4293      	cmp	r3, r2
      huart->RxEventType = HAL_UART_RXEVENT_TC;
 c041600:	6701      	str	r1, [r0, #112]	@ 0x70
      if (!(IS_LPUART_INSTANCE(huart->Instance)))
 c041602:	d105      	bne.n	c041610 <UART_RxISR_8BIT+0x7c>
        }
      }

      /* Check current reception Mode :
         If Reception till IDLE event has been selected : */
      if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 c041604:	6ec2      	ldr	r2, [r0, #108]	@ 0x6c
 c041606:	2a01      	cmp	r2, #1
 c041608:	d011      	beq.n	c04162e <UART_RxISR_8BIT+0x9a>
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
        /*Call registered Rx complete callback*/
        huart->RxCpltCallback(huart);
#else
        /*Call legacy weak Rx complete callback*/
        HAL_UART_RxCpltCallback(huart);
 c04160a:	f7ff ffc0 	bl	c04158e <HAL_UART_RxCpltCallback>
 c04160e:	e021      	b.n	c041654 <UART_RxISR_8BIT+0xc0>
      if (!(IS_LPUART_INSTANCE(huart->Instance)))
 c041610:	4a14      	ldr	r2, [pc, #80]	@ (c041664 <UART_RxISR_8BIT+0xd0>)
 c041612:	4293      	cmp	r3, r2
 c041614:	d0f6      	beq.n	c041604 <UART_RxISR_8BIT+0x70>
        if (READ_BIT(huart->Instance->CR2, USART_CR2_RTOEN) != 0U)
 c041616:	685a      	ldr	r2, [r3, #4]
 c041618:	0211      	lsls	r1, r2, #8
 c04161a:	d5f3      	bpl.n	c041604 <UART_RxISR_8BIT+0x70>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 c04161c:	e853 2f00 	ldrex	r2, [r3]
          ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_RTOIE);
 c041620:	f022 6280 	bic.w	r2, r2, #67108864	@ 0x4000000
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 c041624:	e843 2100 	strex	r1, r2, [r3]
 c041628:	2900      	cmp	r1, #0
 c04162a:	d1f7      	bne.n	c04161c <UART_RxISR_8BIT+0x88>
 c04162c:	e7ea      	b.n	c041604 <UART_RxISR_8BIT+0x70>
        huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 c04162e:	2200      	movs	r2, #0
 c041630:	66c2      	str	r2, [r0, #108]	@ 0x6c
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 c041632:	e853 2f00 	ldrex	r2, [r3]
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 c041636:	f022 0210 	bic.w	r2, r2, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 c04163a:	e843 2100 	strex	r1, r2, [r3]
 c04163e:	2900      	cmp	r1, #0
 c041640:	d1f7      	bne.n	c041632 <UART_RxISR_8BIT+0x9e>
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE) == SET)
 c041642:	69da      	ldr	r2, [r3, #28]
        HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 c041644:	f8b0 105c 	ldrh.w	r1, [r0, #92]	@ 0x5c
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE) == SET)
 c041648:	06d2      	lsls	r2, r2, #27
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_IDLEF);
 c04164a:	bf44      	itt	mi
 c04164c:	2210      	movmi	r2, #16
 c04164e:	621a      	strmi	r2, [r3, #32]
        HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 c041650:	f7ff ff9f 	bl	c041592 <HAL_UARTEx_RxEventCallback>
  else
  {
    /* Clear RXNE interrupt flag */
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
  }
}
 c041654:	bd08      	pop	{r3, pc}
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
 c041656:	699a      	ldr	r2, [r3, #24]
 c041658:	f042 0208 	orr.w	r2, r2, #8
 c04165c:	619a      	str	r2, [r3, #24]
}
 c04165e:	e7f9      	b.n	c041654 <UART_RxISR_8BIT+0xc0>
 c041660:	46002400 	.word	0x46002400
 c041664:	56002400 	.word	0x56002400

0c041668 <UART_RxISR_16BIT>:
  uint16_t *tmp;
  uint16_t uhMask = huart->Mask;
  uint16_t  uhdata;

  /* Check that a Rx process is ongoing */
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 c041668:	f8d0 208c 	ldr.w	r2, [r0, #140]	@ 0x8c
{
 c04166c:	b508      	push	{r3, lr}
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 c04166e:	2a22      	cmp	r2, #34	@ 0x22
  uint16_t uhMask = huart->Mask;
 c041670:	f8b0 1060 	ldrh.w	r1, [r0, #96]	@ 0x60
  {
    uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 c041674:	6803      	ldr	r3, [r0, #0]
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 c041676:	d155      	bne.n	c041724 <UART_RxISR_16BIT+0xbc>
    uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 c041678:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
    tmp = (uint16_t *) huart->pRxBuffPtr ;
    *tmp = (uint16_t)(uhdata & uhMask);
 c04167a:	4011      	ands	r1, r2
 c04167c:	6d82      	ldr	r2, [r0, #88]	@ 0x58
 c04167e:	f822 1b02 	strh.w	r1, [r2], #2
    huart->pRxBuffPtr += 2U;
 c041682:	6582      	str	r2, [r0, #88]	@ 0x58
    huart->RxXferCount--;
 c041684:	f8b0 205e 	ldrh.w	r2, [r0, #94]	@ 0x5e
 c041688:	3a01      	subs	r2, #1
 c04168a:	b292      	uxth	r2, r2
 c04168c:	f8a0 205e 	strh.w	r2, [r0, #94]	@ 0x5e

    if (huart->RxXferCount == 0U)
 c041690:	f8b0 205e 	ldrh.w	r2, [r0, #94]	@ 0x5e
 c041694:	b292      	uxth	r2, r2
 c041696:	2a00      	cmp	r2, #0
 c041698:	d143      	bne.n	c041722 <UART_RxISR_16BIT+0xba>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 c04169a:	e853 2f00 	ldrex	r2, [r3]
    {
      /* Disable the UART Parity Error Interrupt and RXNE interrupt*/
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
 c04169e:	f422 7290 	bic.w	r2, r2, #288	@ 0x120
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 c0416a2:	e843 2100 	strex	r1, r2, [r3]
 c0416a6:	2900      	cmp	r1, #0
 c0416a8:	d1f7      	bne.n	c04169a <UART_RxISR_16BIT+0x32>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 c0416aa:	f103 0208 	add.w	r2, r3, #8
 c0416ae:	e852 2f00 	ldrex	r2, [r2]

      /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
      ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 c0416b2:	f022 0201 	bic.w	r2, r2, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 c0416b6:	f103 0c08 	add.w	ip, r3, #8
 c0416ba:	e84c 2100 	strex	r1, r2, [ip]
 c0416be:	2900      	cmp	r1, #0
 c0416c0:	d1f3      	bne.n	c0416aa <UART_RxISR_16BIT+0x42>

      /* Rx process is completed, restore huart->RxState to Ready */
      huart->RxState = HAL_UART_STATE_READY;
 c0416c2:	2220      	movs	r2, #32
 c0416c4:	f8c0 208c 	str.w	r2, [r0, #140]	@ 0x8c
      huart->RxISR = NULL;

      /* Initialize type of RxEvent to Transfer Complete */
      huart->RxEventType = HAL_UART_RXEVENT_TC;

      if (!(IS_LPUART_INSTANCE(huart->Instance)))
 c0416c8:	4a19      	ldr	r2, [pc, #100]	@ (c041730 <UART_RxISR_16BIT+0xc8>)
      huart->RxISR = NULL;
 c0416ca:	6741      	str	r1, [r0, #116]	@ 0x74
      if (!(IS_LPUART_INSTANCE(huart->Instance)))
 c0416cc:	4293      	cmp	r3, r2
      huart->RxEventType = HAL_UART_RXEVENT_TC;
 c0416ce:	6701      	str	r1, [r0, #112]	@ 0x70
      if (!(IS_LPUART_INSTANCE(huart->Instance)))
 c0416d0:	d105      	bne.n	c0416de <UART_RxISR_16BIT+0x76>
        }
      }

      /* Check current reception Mode :
         If Reception till IDLE event has been selected : */
      if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 c0416d2:	6ec2      	ldr	r2, [r0, #108]	@ 0x6c
 c0416d4:	2a01      	cmp	r2, #1
 c0416d6:	d011      	beq.n	c0416fc <UART_RxISR_16BIT+0x94>
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
        /*Call registered Rx complete callback*/
        huart->RxCpltCallback(huart);
#else
        /*Call legacy weak Rx complete callback*/
        HAL_UART_RxCpltCallback(huart);
 c0416d8:	f7ff ff59 	bl	c04158e <HAL_UART_RxCpltCallback>
 c0416dc:	e021      	b.n	c041722 <UART_RxISR_16BIT+0xba>
      if (!(IS_LPUART_INSTANCE(huart->Instance)))
 c0416de:	4a15      	ldr	r2, [pc, #84]	@ (c041734 <UART_RxISR_16BIT+0xcc>)
 c0416e0:	4293      	cmp	r3, r2
 c0416e2:	d0f6      	beq.n	c0416d2 <UART_RxISR_16BIT+0x6a>
        if (READ_BIT(huart->Instance->CR2, USART_CR2_RTOEN) != 0U)
 c0416e4:	685a      	ldr	r2, [r3, #4]
 c0416e6:	0211      	lsls	r1, r2, #8
 c0416e8:	d5f3      	bpl.n	c0416d2 <UART_RxISR_16BIT+0x6a>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 c0416ea:	e853 2f00 	ldrex	r2, [r3]
          ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_RTOIE);
 c0416ee:	f022 6280 	bic.w	r2, r2, #67108864	@ 0x4000000
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 c0416f2:	e843 2100 	strex	r1, r2, [r3]
 c0416f6:	2900      	cmp	r1, #0
 c0416f8:	d1f7      	bne.n	c0416ea <UART_RxISR_16BIT+0x82>
 c0416fa:	e7ea      	b.n	c0416d2 <UART_RxISR_16BIT+0x6a>
        huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 c0416fc:	2200      	movs	r2, #0
 c0416fe:	66c2      	str	r2, [r0, #108]	@ 0x6c
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 c041700:	e853 2f00 	ldrex	r2, [r3]
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 c041704:	f022 0210 	bic.w	r2, r2, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 c041708:	e843 2100 	strex	r1, r2, [r3]
 c04170c:	2900      	cmp	r1, #0
 c04170e:	d1f7      	bne.n	c041700 <UART_RxISR_16BIT+0x98>
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE) == SET)
 c041710:	69da      	ldr	r2, [r3, #28]
        HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 c041712:	f8b0 105c 	ldrh.w	r1, [r0, #92]	@ 0x5c
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE) == SET)
 c041716:	06d2      	lsls	r2, r2, #27
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_IDLEF);
 c041718:	bf44      	itt	mi
 c04171a:	2210      	movmi	r2, #16
 c04171c:	621a      	strmi	r2, [r3, #32]
        HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 c04171e:	f7ff ff38 	bl	c041592 <HAL_UARTEx_RxEventCallback>
  else
  {
    /* Clear RXNE interrupt flag */
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
  }
}
 c041722:	bd08      	pop	{r3, pc}
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
 c041724:	699a      	ldr	r2, [r3, #24]
 c041726:	f042 0208 	orr.w	r2, r2, #8
 c04172a:	619a      	str	r2, [r3, #24]
}
 c04172c:	e7f9      	b.n	c041722 <UART_RxISR_16BIT+0xba>
 c04172e:	bf00      	nop
 c041730:	46002400 	.word	0x46002400
 c041734:	56002400 	.word	0x56002400

0c041738 <UART_RxISR_8BIT_FIFOEN>:
  *         interruptions have been enabled by HAL_UART_Receive_IT()
  * @param huart UART handle.
  * @retval None
  */
static void UART_RxISR_8BIT_FIFOEN(UART_HandleTypeDef *huart)
{
 c041738:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint16_t  uhMask = huart->Mask;
  uint16_t  uhdata;
  uint16_t  nb_rx_data;
  uint16_t  rxdatacount;
  uint32_t  isrflags = READ_REG(huart->Instance->ISR);
 c04173c:	6803      	ldr	r3, [r0, #0]
{
 c04173e:	4604      	mov	r4, r0
  uint32_t  isrflags = READ_REG(huart->Instance->ISR);
 c041740:	f8d3 b01c 	ldr.w	fp, [r3, #28]
  uint32_t  cr1its   = READ_REG(huart->Instance->CR1);
 c041744:	681f      	ldr	r7, [r3, #0]
  uint32_t  cr3its   = READ_REG(huart->Instance->CR3);
 c041746:	689d      	ldr	r5, [r3, #8]

  /* Check that a Rx process is ongoing */
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 c041748:	f8d0 208c 	ldr.w	r2, [r0, #140]	@ 0x8c
  uint16_t  uhMask = huart->Mask;
 c04174c:	f8b0 6060 	ldrh.w	r6, [r0, #96]	@ 0x60
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 c041750:	2a22      	cmp	r2, #34	@ 0x22
 c041752:	f040 80bd 	bne.w	c0418d0 <UART_RxISR_8BIT_FIFOEN+0x198>
  {
    nb_rx_data = huart->NbRxDataToProcess;
    while ((nb_rx_data > 0U) && ((isrflags & USART_ISR_RXNE_RXFNE) != 0U))
 c041756:	f8b0 3068 	ldrh.w	r3, [r0, #104]	@ 0x68
 c04175a:	b143      	cbz	r3, c04176e <UART_RxISR_8BIT_FIFOEN+0x36>
        /* Disable the UART Parity Error Interrupt and RXFT interrupt*/
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);

        /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error)
           and RX FIFO Threshold interrupt */
        ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
 c04175c:	f8df 817c 	ldr.w	r8, [pc, #380]	@ c0418dc <UART_RxISR_8BIT_FIFOEN+0x1a4>
        huart->RxISR = NULL;

        /* Initialize type of RxEvent to Transfer Complete */
        huart->RxEventType = HAL_UART_RXEVENT_TC;

        if (!(IS_LPUART_INSTANCE(huart->Instance)))
 c041760:	f8df 917c 	ldr.w	r9, [pc, #380]	@ c0418e0 <UART_RxISR_8BIT_FIFOEN+0x1a8>
 c041764:	f8df a17c 	ldr.w	sl, [pc, #380]	@ c0418e4 <UART_RxISR_8BIT_FIFOEN+0x1ac>
    while ((nb_rx_data > 0U) && ((isrflags & USART_ISR_RXNE_RXFNE) != 0U))
 c041768:	f01b 0f20 	tst.w	fp, #32
 c04176c:	d120      	bne.n	c0417b0 <UART_RxISR_8BIT_FIFOEN+0x78>

    /* When remaining number of bytes to receive is less than the RX FIFO
    threshold, next incoming frames are processed as if FIFO mode was
    disabled (i.e. one interrupt per received frame).
    */
    rxdatacount = huart->RxXferCount;
 c04176e:	f8b4 305e 	ldrh.w	r3, [r4, #94]	@ 0x5e
 c041772:	b29b      	uxth	r3, r3
    if ((rxdatacount != 0U) && (rxdatacount < huart->NbRxDataToProcess))
 c041774:	b1d3      	cbz	r3, c0417ac <UART_RxISR_8BIT_FIFOEN+0x74>
 c041776:	f8b4 2068 	ldrh.w	r2, [r4, #104]	@ 0x68
 c04177a:	429a      	cmp	r2, r3
 c04177c:	d916      	bls.n	c0417ac <UART_RxISR_8BIT_FIFOEN+0x74>
    {
      /* Disable the UART RXFT interrupt*/
      ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_RXFTIE);
 c04177e:	6822      	ldr	r2, [r4, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 c041780:	f102 0308 	add.w	r3, r2, #8
 c041784:	e853 3f00 	ldrex	r3, [r3]
 c041788:	f023 5380 	bic.w	r3, r3, #268435456	@ 0x10000000
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 c04178c:	3208      	adds	r2, #8
 c04178e:	e842 3100 	strex	r1, r3, [r2]
   return(result);
 c041792:	6822      	ldr	r2, [r4, #0]
 c041794:	2900      	cmp	r1, #0
 c041796:	d1f2      	bne.n	c04177e <UART_RxISR_8BIT_FIFOEN+0x46>

      /* Update the RxISR function pointer */
      huart->RxISR = UART_RxISR_8BIT;
 c041798:	4b53      	ldr	r3, [pc, #332]	@ (c0418e8 <UART_RxISR_8BIT_FIFOEN+0x1b0>)
 c04179a:	6763      	str	r3, [r4, #116]	@ 0x74
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 c04179c:	e852 3f00 	ldrex	r3, [r2]

      /* Enable the UART Data Register Not Empty interrupt */
      ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_RXNEIE_RXFNEIE);
 c0417a0:	f043 0320 	orr.w	r3, r3, #32
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 c0417a4:	e842 3100 	strex	r1, r3, [r2]
 c0417a8:	2900      	cmp	r1, #0
 c0417aa:	d1f7      	bne.n	c04179c <UART_RxISR_8BIT_FIFOEN+0x64>
  else
  {
    /* Clear RXNE interrupt flag */
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
  }
}
 c0417ac:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
      uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 c0417b0:	6823      	ldr	r3, [r4, #0]
      *huart->pRxBuffPtr = (uint8_t)(uhdata & (uint8_t)uhMask);
 c0417b2:	6da2      	ldr	r2, [r4, #88]	@ 0x58
      uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 c0417b4:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
      *huart->pRxBuffPtr = (uint8_t)(uhdata & (uint8_t)uhMask);
 c0417b6:	4033      	ands	r3, r6
 c0417b8:	7013      	strb	r3, [r2, #0]
      huart->pRxBuffPtr++;
 c0417ba:	6da3      	ldr	r3, [r4, #88]	@ 0x58
 c0417bc:	3301      	adds	r3, #1
 c0417be:	65a3      	str	r3, [r4, #88]	@ 0x58
      huart->RxXferCount--;
 c0417c0:	f8b4 305e 	ldrh.w	r3, [r4, #94]	@ 0x5e
 c0417c4:	3b01      	subs	r3, #1
 c0417c6:	b29b      	uxth	r3, r3
 c0417c8:	f8a4 305e 	strh.w	r3, [r4, #94]	@ 0x5e
      isrflags = READ_REG(huart->Instance->ISR);
 c0417cc:	6823      	ldr	r3, [r4, #0]
 c0417ce:	f8d3 b01c 	ldr.w	fp, [r3, #28]
      if ((isrflags & (USART_ISR_PE | USART_ISR_FE | USART_ISR_NE)) != 0U)
 c0417d2:	f01b 0f07 	tst.w	fp, #7
 c0417d6:	d02f      	beq.n	c041838 <UART_RxISR_8BIT_FIFOEN+0x100>
        if (((isrflags & USART_ISR_PE) != 0U) && ((cr1its & USART_CR1_PEIE) != 0U))
 c0417d8:	f01b 0f01 	tst.w	fp, #1
 c0417dc:	d009      	beq.n	c0417f2 <UART_RxISR_8BIT_FIFOEN+0xba>
 c0417de:	05f9      	lsls	r1, r7, #23
 c0417e0:	d507      	bpl.n	c0417f2 <UART_RxISR_8BIT_FIFOEN+0xba>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_PEF);
 c0417e2:	2201      	movs	r2, #1
 c0417e4:	621a      	str	r2, [r3, #32]
          huart->ErrorCode |= HAL_UART_ERROR_PE;
 c0417e6:	f8d4 2090 	ldr.w	r2, [r4, #144]	@ 0x90
 c0417ea:	f042 0201 	orr.w	r2, r2, #1
 c0417ee:	f8c4 2090 	str.w	r2, [r4, #144]	@ 0x90
        if (((isrflags & USART_ISR_FE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 c0417f2:	f01b 0f02 	tst.w	fp, #2
 c0417f6:	d009      	beq.n	c04180c <UART_RxISR_8BIT_FIFOEN+0xd4>
 c0417f8:	07ea      	lsls	r2, r5, #31
 c0417fa:	d507      	bpl.n	c04180c <UART_RxISR_8BIT_FIFOEN+0xd4>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_FEF);
 c0417fc:	2202      	movs	r2, #2
 c0417fe:	621a      	str	r2, [r3, #32]
          huart->ErrorCode |= HAL_UART_ERROR_FE;
 c041800:	f8d4 2090 	ldr.w	r2, [r4, #144]	@ 0x90
 c041804:	f042 0204 	orr.w	r2, r2, #4
 c041808:	f8c4 2090 	str.w	r2, [r4, #144]	@ 0x90
        if (((isrflags & USART_ISR_NE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 c04180c:	f01b 0f04 	tst.w	fp, #4
 c041810:	d009      	beq.n	c041826 <UART_RxISR_8BIT_FIFOEN+0xee>
 c041812:	07e8      	lsls	r0, r5, #31
 c041814:	d507      	bpl.n	c041826 <UART_RxISR_8BIT_FIFOEN+0xee>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_NEF);
 c041816:	2204      	movs	r2, #4
 c041818:	621a      	str	r2, [r3, #32]
          huart->ErrorCode |= HAL_UART_ERROR_NE;
 c04181a:	f8d4 3090 	ldr.w	r3, [r4, #144]	@ 0x90
 c04181e:	f043 0302 	orr.w	r3, r3, #2
 c041822:	f8c4 3090 	str.w	r3, [r4, #144]	@ 0x90
        if (huart->ErrorCode != HAL_UART_ERROR_NONE)
 c041826:	f8d4 3090 	ldr.w	r3, [r4, #144]	@ 0x90
 c04182a:	b12b      	cbz	r3, c041838 <UART_RxISR_8BIT_FIFOEN+0x100>
          HAL_UART_ErrorCallback(huart);
 c04182c:	4620      	mov	r0, r4
 c04182e:	f7ff feaf 	bl	c041590 <HAL_UART_ErrorCallback>
          huart->ErrorCode = HAL_UART_ERROR_NONE;
 c041832:	2300      	movs	r3, #0
 c041834:	f8c4 3090 	str.w	r3, [r4, #144]	@ 0x90
      if (huart->RxXferCount == 0U)
 c041838:	f8b4 305e 	ldrh.w	r3, [r4, #94]	@ 0x5e
 c04183c:	b29b      	uxth	r3, r3
 c04183e:	2b00      	cmp	r3, #0
 c041840:	d192      	bne.n	c041768 <UART_RxISR_8BIT_FIFOEN+0x30>
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 c041842:	6822      	ldr	r2, [r4, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 c041844:	e852 3f00 	ldrex	r3, [r2]
 c041848:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 c04184c:	e842 3100 	strex	r1, r3, [r2]
   return(result);
 c041850:	6823      	ldr	r3, [r4, #0]
 c041852:	2900      	cmp	r1, #0
 c041854:	d1f5      	bne.n	c041842 <UART_RxISR_8BIT_FIFOEN+0x10a>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 c041856:	f103 0208 	add.w	r2, r3, #8
 c04185a:	e852 2f00 	ldrex	r2, [r2]
        ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
 c04185e:	ea02 0208 	and.w	r2, r2, r8
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 c041862:	f103 0008 	add.w	r0, r3, #8
 c041866:	e840 2100 	strex	r1, r2, [r0]
 c04186a:	2900      	cmp	r1, #0
 c04186c:	d1f3      	bne.n	c041856 <UART_RxISR_8BIT_FIFOEN+0x11e>
        huart->RxState = HAL_UART_STATE_READY;
 c04186e:	2220      	movs	r2, #32
        if (!(IS_LPUART_INSTANCE(huart->Instance)))
 c041870:	454b      	cmp	r3, r9
        huart->RxState = HAL_UART_STATE_READY;
 c041872:	f8c4 208c 	str.w	r2, [r4, #140]	@ 0x8c
        huart->RxISR = NULL;
 c041876:	6761      	str	r1, [r4, #116]	@ 0x74
        huart->RxEventType = HAL_UART_RXEVENT_TC;
 c041878:	6721      	str	r1, [r4, #112]	@ 0x70
        if (!(IS_LPUART_INSTANCE(huart->Instance)))
 c04187a:	d00c      	beq.n	c041896 <UART_RxISR_8BIT_FIFOEN+0x15e>
 c04187c:	4553      	cmp	r3, sl
 c04187e:	d00a      	beq.n	c041896 <UART_RxISR_8BIT_FIFOEN+0x15e>
          if (READ_BIT(huart->Instance->CR2, USART_CR2_RTOEN) != 0U)
 c041880:	685a      	ldr	r2, [r3, #4]
 c041882:	0211      	lsls	r1, r2, #8
 c041884:	d507      	bpl.n	c041896 <UART_RxISR_8BIT_FIFOEN+0x15e>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 c041886:	e853 2f00 	ldrex	r2, [r3]
            ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_RTOIE);
 c04188a:	f022 6280 	bic.w	r2, r2, #67108864	@ 0x4000000
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 c04188e:	e843 2100 	strex	r1, r2, [r3]
 c041892:	2900      	cmp	r1, #0
 c041894:	d1f7      	bne.n	c041886 <UART_RxISR_8BIT_FIFOEN+0x14e>
        if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 c041896:	6ee2      	ldr	r2, [r4, #108]	@ 0x6c
 c041898:	2a01      	cmp	r2, #1
 c04189a:	d115      	bne.n	c0418c8 <UART_RxISR_8BIT_FIFOEN+0x190>
          huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 c04189c:	2200      	movs	r2, #0
 c04189e:	66e2      	str	r2, [r4, #108]	@ 0x6c
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 c0418a0:	e853 2f00 	ldrex	r2, [r3]
          ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 c0418a4:	f022 0210 	bic.w	r2, r2, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 c0418a8:	e843 2100 	strex	r1, r2, [r3]
 c0418ac:	2900      	cmp	r1, #0
 c0418ae:	d1f7      	bne.n	c0418a0 <UART_RxISR_8BIT_FIFOEN+0x168>
          if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE) == SET)
 c0418b0:	69da      	ldr	r2, [r3, #28]
          HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 c0418b2:	4620      	mov	r0, r4
          if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE) == SET)
 c0418b4:	06d2      	lsls	r2, r2, #27
            __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_IDLEF);
 c0418b6:	bf48      	it	mi
 c0418b8:	2210      	movmi	r2, #16
          HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 c0418ba:	f8b4 105c 	ldrh.w	r1, [r4, #92]	@ 0x5c
            __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_IDLEF);
 c0418be:	bf48      	it	mi
 c0418c0:	621a      	strmi	r2, [r3, #32]
          HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 c0418c2:	f7ff fe66 	bl	c041592 <HAL_UARTEx_RxEventCallback>
 c0418c6:	e74f      	b.n	c041768 <UART_RxISR_8BIT_FIFOEN+0x30>
          HAL_UART_RxCpltCallback(huart);
 c0418c8:	4620      	mov	r0, r4
 c0418ca:	f7ff fe60 	bl	c04158e <HAL_UART_RxCpltCallback>
    while ((nb_rx_data > 0U) && ((isrflags & USART_ISR_RXNE_RXFNE) != 0U))
 c0418ce:	e74b      	b.n	c041768 <UART_RxISR_8BIT_FIFOEN+0x30>
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
 c0418d0:	699a      	ldr	r2, [r3, #24]
 c0418d2:	f042 0208 	orr.w	r2, r2, #8
 c0418d6:	619a      	str	r2, [r3, #24]
}
 c0418d8:	e768      	b.n	c0417ac <UART_RxISR_8BIT_FIFOEN+0x74>
 c0418da:	bf00      	nop
 c0418dc:	effffffe 	.word	0xeffffffe
 c0418e0:	46002400 	.word	0x46002400
 c0418e4:	56002400 	.word	0x56002400
 c0418e8:	0c041595 	.word	0x0c041595

0c0418ec <UART_RxISR_16BIT_FIFOEN>:
  *         interruptions have been enabled by HAL_UART_Receive_IT()
  * @param huart UART handle.
  * @retval None
  */
static void UART_RxISR_16BIT_FIFOEN(UART_HandleTypeDef *huart)
{
 c0418ec:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint16_t *tmp;
  uint16_t  uhMask = huart->Mask;
  uint16_t  uhdata;
  uint16_t  nb_rx_data;
  uint16_t  rxdatacount;
  uint32_t  isrflags = READ_REG(huart->Instance->ISR);
 c0418f0:	6803      	ldr	r3, [r0, #0]
{
 c0418f2:	4604      	mov	r4, r0
  uint32_t  isrflags = READ_REG(huart->Instance->ISR);
 c0418f4:	f8d3 b01c 	ldr.w	fp, [r3, #28]
  uint32_t  cr1its   = READ_REG(huart->Instance->CR1);
 c0418f8:	681f      	ldr	r7, [r3, #0]
  uint32_t  cr3its   = READ_REG(huart->Instance->CR3);
 c0418fa:	689d      	ldr	r5, [r3, #8]

  /* Check that a Rx process is ongoing */
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 c0418fc:	f8d0 208c 	ldr.w	r2, [r0, #140]	@ 0x8c
  uint16_t  uhMask = huart->Mask;
 c041900:	f8b0 6060 	ldrh.w	r6, [r0, #96]	@ 0x60
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 c041904:	2a22      	cmp	r2, #34	@ 0x22
 c041906:	f040 80bb 	bne.w	c041a80 <UART_RxISR_16BIT_FIFOEN+0x194>
  {
    nb_rx_data = huart->NbRxDataToProcess;
    while ((nb_rx_data > 0U) && ((isrflags & USART_ISR_RXNE_RXFNE) != 0U))
 c04190a:	f8b0 3068 	ldrh.w	r3, [r0, #104]	@ 0x68
 c04190e:	b143      	cbz	r3, c041922 <UART_RxISR_16BIT_FIFOEN+0x36>
        /* Disable the UART Parity Error Interrupt and RXFT interrupt*/
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);

        /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error)
           and RX FIFO Threshold interrupt */
        ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
 c041910:	f8df 8178 	ldr.w	r8, [pc, #376]	@ c041a8c <UART_RxISR_16BIT_FIFOEN+0x1a0>
        huart->RxISR = NULL;

        /* Initialize type of RxEvent to Transfer Complete */
        huart->RxEventType = HAL_UART_RXEVENT_TC;

        if (!(IS_LPUART_INSTANCE(huart->Instance)))
 c041914:	f8df 9178 	ldr.w	r9, [pc, #376]	@ c041a90 <UART_RxISR_16BIT_FIFOEN+0x1a4>
 c041918:	f8df a178 	ldr.w	sl, [pc, #376]	@ c041a94 <UART_RxISR_16BIT_FIFOEN+0x1a8>
    while ((nb_rx_data > 0U) && ((isrflags & USART_ISR_RXNE_RXFNE) != 0U))
 c04191c:	f01b 0f20 	tst.w	fp, #32
 c041920:	d120      	bne.n	c041964 <UART_RxISR_16BIT_FIFOEN+0x78>

    /* When remaining number of bytes to receive is less than the RX FIFO
    threshold, next incoming frames are processed as if FIFO mode was
    disabled (i.e. one interrupt per received frame).
    */
    rxdatacount = huart->RxXferCount;
 c041922:	f8b4 305e 	ldrh.w	r3, [r4, #94]	@ 0x5e
 c041926:	b29b      	uxth	r3, r3
    if ((rxdatacount != 0U) && (rxdatacount < huart->NbRxDataToProcess))
 c041928:	b1d3      	cbz	r3, c041960 <UART_RxISR_16BIT_FIFOEN+0x74>
 c04192a:	f8b4 2068 	ldrh.w	r2, [r4, #104]	@ 0x68
 c04192e:	429a      	cmp	r2, r3
 c041930:	d916      	bls.n	c041960 <UART_RxISR_16BIT_FIFOEN+0x74>
    {
      /* Disable the UART RXFT interrupt*/
      ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_RXFTIE);
 c041932:	6822      	ldr	r2, [r4, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 c041934:	f102 0308 	add.w	r3, r2, #8
 c041938:	e853 3f00 	ldrex	r3, [r3]
 c04193c:	f023 5380 	bic.w	r3, r3, #268435456	@ 0x10000000
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 c041940:	3208      	adds	r2, #8
 c041942:	e842 3100 	strex	r1, r3, [r2]
   return(result);
 c041946:	6822      	ldr	r2, [r4, #0]
 c041948:	2900      	cmp	r1, #0
 c04194a:	d1f2      	bne.n	c041932 <UART_RxISR_16BIT_FIFOEN+0x46>

      /* Update the RxISR function pointer */
      huart->RxISR = UART_RxISR_16BIT;
 c04194c:	4b52      	ldr	r3, [pc, #328]	@ (c041a98 <UART_RxISR_16BIT_FIFOEN+0x1ac>)
 c04194e:	6763      	str	r3, [r4, #116]	@ 0x74
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 c041950:	e852 3f00 	ldrex	r3, [r2]

      /* Enable the UART Data Register Not Empty interrupt */
      ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_RXNEIE_RXFNEIE);
 c041954:	f043 0320 	orr.w	r3, r3, #32
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 c041958:	e842 3100 	strex	r1, r3, [r2]
 c04195c:	2900      	cmp	r1, #0
 c04195e:	d1f7      	bne.n	c041950 <UART_RxISR_16BIT_FIFOEN+0x64>
  else
  {
    /* Clear RXNE interrupt flag */
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
  }
}
 c041960:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
      uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 c041964:	6823      	ldr	r3, [r4, #0]
      *tmp = (uint16_t)(uhdata & uhMask);
 c041966:	6da2      	ldr	r2, [r4, #88]	@ 0x58
      uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 c041968:	6a59      	ldr	r1, [r3, #36]	@ 0x24
      *tmp = (uint16_t)(uhdata & uhMask);
 c04196a:	4031      	ands	r1, r6
 c04196c:	f822 1b02 	strh.w	r1, [r2], #2
      huart->pRxBuffPtr += 2U;
 c041970:	65a2      	str	r2, [r4, #88]	@ 0x58
      huart->RxXferCount--;
 c041972:	f8b4 205e 	ldrh.w	r2, [r4, #94]	@ 0x5e
 c041976:	3a01      	subs	r2, #1
 c041978:	b292      	uxth	r2, r2
 c04197a:	f8a4 205e 	strh.w	r2, [r4, #94]	@ 0x5e
      isrflags = READ_REG(huart->Instance->ISR);
 c04197e:	f8d3 b01c 	ldr.w	fp, [r3, #28]
      if ((isrflags & (USART_ISR_PE | USART_ISR_FE | USART_ISR_NE)) != 0U)
 c041982:	f01b 0f07 	tst.w	fp, #7
 c041986:	d02f      	beq.n	c0419e8 <UART_RxISR_16BIT_FIFOEN+0xfc>
        if (((isrflags & USART_ISR_PE) != 0U) && ((cr1its & USART_CR1_PEIE) != 0U))
 c041988:	f01b 0f01 	tst.w	fp, #1
 c04198c:	d009      	beq.n	c0419a2 <UART_RxISR_16BIT_FIFOEN+0xb6>
 c04198e:	05f9      	lsls	r1, r7, #23
 c041990:	d507      	bpl.n	c0419a2 <UART_RxISR_16BIT_FIFOEN+0xb6>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_PEF);
 c041992:	2201      	movs	r2, #1
 c041994:	621a      	str	r2, [r3, #32]
          huart->ErrorCode |= HAL_UART_ERROR_PE;
 c041996:	f8d4 2090 	ldr.w	r2, [r4, #144]	@ 0x90
 c04199a:	f042 0201 	orr.w	r2, r2, #1
 c04199e:	f8c4 2090 	str.w	r2, [r4, #144]	@ 0x90
        if (((isrflags & USART_ISR_FE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 c0419a2:	f01b 0f02 	tst.w	fp, #2
 c0419a6:	d009      	beq.n	c0419bc <UART_RxISR_16BIT_FIFOEN+0xd0>
 c0419a8:	07ea      	lsls	r2, r5, #31
 c0419aa:	d507      	bpl.n	c0419bc <UART_RxISR_16BIT_FIFOEN+0xd0>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_FEF);
 c0419ac:	2202      	movs	r2, #2
 c0419ae:	621a      	str	r2, [r3, #32]
          huart->ErrorCode |= HAL_UART_ERROR_FE;
 c0419b0:	f8d4 2090 	ldr.w	r2, [r4, #144]	@ 0x90
 c0419b4:	f042 0204 	orr.w	r2, r2, #4
 c0419b8:	f8c4 2090 	str.w	r2, [r4, #144]	@ 0x90
        if (((isrflags & USART_ISR_NE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 c0419bc:	f01b 0f04 	tst.w	fp, #4
 c0419c0:	d009      	beq.n	c0419d6 <UART_RxISR_16BIT_FIFOEN+0xea>
 c0419c2:	07e8      	lsls	r0, r5, #31
 c0419c4:	d507      	bpl.n	c0419d6 <UART_RxISR_16BIT_FIFOEN+0xea>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_NEF);
 c0419c6:	2204      	movs	r2, #4
 c0419c8:	621a      	str	r2, [r3, #32]
          huart->ErrorCode |= HAL_UART_ERROR_NE;
 c0419ca:	f8d4 3090 	ldr.w	r3, [r4, #144]	@ 0x90
 c0419ce:	f043 0302 	orr.w	r3, r3, #2
 c0419d2:	f8c4 3090 	str.w	r3, [r4, #144]	@ 0x90
        if (huart->ErrorCode != HAL_UART_ERROR_NONE)
 c0419d6:	f8d4 3090 	ldr.w	r3, [r4, #144]	@ 0x90
 c0419da:	b12b      	cbz	r3, c0419e8 <UART_RxISR_16BIT_FIFOEN+0xfc>
          HAL_UART_ErrorCallback(huart);
 c0419dc:	4620      	mov	r0, r4
 c0419de:	f7ff fdd7 	bl	c041590 <HAL_UART_ErrorCallback>
          huart->ErrorCode = HAL_UART_ERROR_NONE;
 c0419e2:	2300      	movs	r3, #0
 c0419e4:	f8c4 3090 	str.w	r3, [r4, #144]	@ 0x90
      if (huart->RxXferCount == 0U)
 c0419e8:	f8b4 305e 	ldrh.w	r3, [r4, #94]	@ 0x5e
 c0419ec:	b29b      	uxth	r3, r3
 c0419ee:	2b00      	cmp	r3, #0
 c0419f0:	d194      	bne.n	c04191c <UART_RxISR_16BIT_FIFOEN+0x30>
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 c0419f2:	6822      	ldr	r2, [r4, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 c0419f4:	e852 3f00 	ldrex	r3, [r2]
 c0419f8:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 c0419fc:	e842 3100 	strex	r1, r3, [r2]
   return(result);
 c041a00:	6823      	ldr	r3, [r4, #0]
 c041a02:	2900      	cmp	r1, #0
 c041a04:	d1f5      	bne.n	c0419f2 <UART_RxISR_16BIT_FIFOEN+0x106>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 c041a06:	f103 0208 	add.w	r2, r3, #8
 c041a0a:	e852 2f00 	ldrex	r2, [r2]
        ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
 c041a0e:	ea02 0208 	and.w	r2, r2, r8
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 c041a12:	f103 0008 	add.w	r0, r3, #8
 c041a16:	e840 2100 	strex	r1, r2, [r0]
 c041a1a:	2900      	cmp	r1, #0
 c041a1c:	d1f3      	bne.n	c041a06 <UART_RxISR_16BIT_FIFOEN+0x11a>
        huart->RxState = HAL_UART_STATE_READY;
 c041a1e:	2220      	movs	r2, #32
        if (!(IS_LPUART_INSTANCE(huart->Instance)))
 c041a20:	454b      	cmp	r3, r9
        huart->RxState = HAL_UART_STATE_READY;
 c041a22:	f8c4 208c 	str.w	r2, [r4, #140]	@ 0x8c
        huart->RxISR = NULL;
 c041a26:	6761      	str	r1, [r4, #116]	@ 0x74
        huart->RxEventType = HAL_UART_RXEVENT_TC;
 c041a28:	6721      	str	r1, [r4, #112]	@ 0x70
        if (!(IS_LPUART_INSTANCE(huart->Instance)))
 c041a2a:	d00c      	beq.n	c041a46 <UART_RxISR_16BIT_FIFOEN+0x15a>
 c041a2c:	4553      	cmp	r3, sl
 c041a2e:	d00a      	beq.n	c041a46 <UART_RxISR_16BIT_FIFOEN+0x15a>
          if (READ_BIT(huart->Instance->CR2, USART_CR2_RTOEN) != 0U)
 c041a30:	685a      	ldr	r2, [r3, #4]
 c041a32:	0211      	lsls	r1, r2, #8
 c041a34:	d507      	bpl.n	c041a46 <UART_RxISR_16BIT_FIFOEN+0x15a>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 c041a36:	e853 2f00 	ldrex	r2, [r3]
            ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_RTOIE);
 c041a3a:	f022 6280 	bic.w	r2, r2, #67108864	@ 0x4000000
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 c041a3e:	e843 2100 	strex	r1, r2, [r3]
 c041a42:	2900      	cmp	r1, #0
 c041a44:	d1f7      	bne.n	c041a36 <UART_RxISR_16BIT_FIFOEN+0x14a>
        if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 c041a46:	6ee2      	ldr	r2, [r4, #108]	@ 0x6c
 c041a48:	2a01      	cmp	r2, #1
 c041a4a:	d115      	bne.n	c041a78 <UART_RxISR_16BIT_FIFOEN+0x18c>
          huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 c041a4c:	2200      	movs	r2, #0
 c041a4e:	66e2      	str	r2, [r4, #108]	@ 0x6c
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 c041a50:	e853 2f00 	ldrex	r2, [r3]
          ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 c041a54:	f022 0210 	bic.w	r2, r2, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 c041a58:	e843 2100 	strex	r1, r2, [r3]
 c041a5c:	2900      	cmp	r1, #0
 c041a5e:	d1f7      	bne.n	c041a50 <UART_RxISR_16BIT_FIFOEN+0x164>
          if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE) == SET)
 c041a60:	69da      	ldr	r2, [r3, #28]
          HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 c041a62:	4620      	mov	r0, r4
          if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE) == SET)
 c041a64:	06d2      	lsls	r2, r2, #27
            __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_IDLEF);
 c041a66:	bf48      	it	mi
 c041a68:	2210      	movmi	r2, #16
          HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 c041a6a:	f8b4 105c 	ldrh.w	r1, [r4, #92]	@ 0x5c
            __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_IDLEF);
 c041a6e:	bf48      	it	mi
 c041a70:	621a      	strmi	r2, [r3, #32]
          HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 c041a72:	f7ff fd8e 	bl	c041592 <HAL_UARTEx_RxEventCallback>
 c041a76:	e751      	b.n	c04191c <UART_RxISR_16BIT_FIFOEN+0x30>
          HAL_UART_RxCpltCallback(huart);
 c041a78:	4620      	mov	r0, r4
 c041a7a:	f7ff fd88 	bl	c04158e <HAL_UART_RxCpltCallback>
    while ((nb_rx_data > 0U) && ((isrflags & USART_ISR_RXNE_RXFNE) != 0U))
 c041a7e:	e74d      	b.n	c04191c <UART_RxISR_16BIT_FIFOEN+0x30>
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
 c041a80:	699a      	ldr	r2, [r3, #24]
 c041a82:	f042 0208 	orr.w	r2, r2, #8
 c041a86:	619a      	str	r2, [r3, #24]
}
 c041a88:	e76a      	b.n	c041960 <UART_RxISR_16BIT_FIFOEN+0x74>
 c041a8a:	bf00      	nop
 c041a8c:	effffffe 	.word	0xeffffffe
 c041a90:	46002400 	.word	0x46002400
 c041a94:	56002400 	.word	0x56002400
 c041a98:	0c041669 	.word	0x0c041669

0c041a9c <UART_SetConfig>:
{
 c041a9c:	b538      	push	{r3, r4, r5, lr}
 c041a9e:	4604      	mov	r4, r0
  if (UART_INSTANCE_LOWPOWER(huart))
 c041aa0:	6803      	ldr	r3, [r0, #0]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 c041aa2:	69c1      	ldr	r1, [r0, #28]
 c041aa4:	6882      	ldr	r2, [r0, #8]
 c041aa6:	6900      	ldr	r0, [r0, #16]
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 c041aa8:	681d      	ldr	r5, [r3, #0]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 c041aaa:	4302      	orrs	r2, r0
 c041aac:	6960      	ldr	r0, [r4, #20]
 c041aae:	4302      	orrs	r2, r0
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 c041ab0:	485b      	ldr	r0, [pc, #364]	@ (c041c20 <UART_SetConfig+0x184>)
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 c041ab2:	430a      	orrs	r2, r1
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 c041ab4:	4028      	ands	r0, r5
 c041ab6:	4302      	orrs	r2, r0
 c041ab8:	601a      	str	r2, [r3, #0]
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 c041aba:	685a      	ldr	r2, [r3, #4]
 c041abc:	68e0      	ldr	r0, [r4, #12]
 c041abe:	f422 5240 	bic.w	r2, r2, #12288	@ 0x3000
 c041ac2:	4302      	orrs	r2, r0
 c041ac4:	605a      	str	r2, [r3, #4]
  if (!(UART_INSTANCE_LOWPOWER(huart)))
 c041ac6:	4a57      	ldr	r2, [pc, #348]	@ (c041c24 <UART_SetConfig+0x188>)
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;
 c041ac8:	69a0      	ldr	r0, [r4, #24]
  if (!(UART_INSTANCE_LOWPOWER(huart)))
 c041aca:	4293      	cmp	r3, r2
 c041acc:	d005      	beq.n	c041ada <UART_SetConfig+0x3e>
 c041ace:	f102 5280 	add.w	r2, r2, #268435456	@ 0x10000000
 c041ad2:	4293      	cmp	r3, r2
    tmpreg |= huart->Init.OneBitSampling;
 c041ad4:	bf1c      	itt	ne
 c041ad6:	6a22      	ldrne	r2, [r4, #32]
 c041ad8:	4310      	orrne	r0, r2
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 c041ada:	689a      	ldr	r2, [r3, #8]
 c041adc:	f022 426e 	bic.w	r2, r2, #3992977408	@ 0xee000000
 c041ae0:	f422 6230 	bic.w	r2, r2, #2816	@ 0xb00
 c041ae4:	4302      	orrs	r2, r0
 c041ae6:	609a      	str	r2, [r3, #8]
  MODIFY_REG(huart->Instance->PRESC, USART_PRESC_PRESCALER, huart->Init.ClockPrescaler);
 c041ae8:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 c041aea:	6a60      	ldr	r0, [r4, #36]	@ 0x24
 c041aec:	f022 020f 	bic.w	r2, r2, #15
 c041af0:	4302      	orrs	r2, r0
 c041af2:	62da      	str	r2, [r3, #44]	@ 0x2c
  UART_GETCLOCKSOURCE(huart, clocksource);
 c041af4:	4a4c      	ldr	r2, [pc, #304]	@ (c041c28 <UART_SetConfig+0x18c>)
 c041af6:	4293      	cmp	r3, r2
 c041af8:	d04d      	beq.n	c041b96 <UART_SetConfig+0xfa>
 c041afa:	f5a2 4274 	sub.w	r2, r2, #62464	@ 0xf400
 c041afe:	4293      	cmp	r3, r2
 c041b00:	d06e      	beq.n	c041be0 <UART_SetConfig+0x144>
 c041b02:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
 c041b06:	4293      	cmp	r3, r2
 c041b08:	d06c      	beq.n	c041be4 <UART_SetConfig+0x148>
 c041b0a:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
 c041b0e:	4293      	cmp	r3, r2
 c041b10:	d06a      	beq.n	c041be8 <UART_SetConfig+0x14c>
 c041b12:	f1b3 2f50 	cmp.w	r3, #1342197760	@ 0x50005000
 c041b16:	d069      	beq.n	c041bec <UART_SetConfig+0x150>
 c041b18:	4a44      	ldr	r2, [pc, #272]	@ (c041c2c <UART_SetConfig+0x190>)
 c041b1a:	4293      	cmp	r3, r2
 c041b1c:	d01c      	beq.n	c041b58 <UART_SetConfig+0xbc>
  if (UART_INSTANCE_LOWPOWER(huart))
 c041b1e:	f102 4270 	add.w	r2, r2, #4026531840	@ 0xf0000000
 c041b22:	4293      	cmp	r3, r2
  UART_GETCLOCKSOURCE(huart, clocksource);
 c041b24:	f04f 0000 	mov.w	r0, #0
  if (UART_INSTANCE_LOWPOWER(huart))
 c041b28:	d136      	bne.n	c041b98 <UART_SetConfig+0xfc>
    pclk = HAL_RCCEx_GetPeriphCLKFreq(clocksource);
 c041b2a:	2100      	movs	r1, #0
 c041b2c:	f7fe fdc6 	bl	c0406bc <HAL_RCCEx_GetPeriphCLKFreq>
    if (pclk != 0U)
 c041b30:	b378      	cbz	r0, c041b92 <UART_SetConfig+0xf6>
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
 c041b32:	6a61      	ldr	r1, [r4, #36]	@ 0x24
 c041b34:	4a3e      	ldr	r2, [pc, #248]	@ (c041c30 <UART_SetConfig+0x194>)
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 c041b36:	6865      	ldr	r5, [r4, #4]
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
 c041b38:	f832 2011 	ldrh.w	r2, [r2, r1, lsl #1]
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 c041b3c:	eb05 0145 	add.w	r1, r5, r5, lsl #1
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
 c041b40:	fbb0 f3f2 	udiv	r3, r0, r2
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 c041b44:	4299      	cmp	r1, r3
 c041b46:	d909      	bls.n	c041b5c <UART_SetConfig+0xc0>
        ret = HAL_ERROR;
 c041b48:	2001      	movs	r0, #1
  huart->NbRxDataToProcess = 1;
 c041b4a:	f04f 1301 	mov.w	r3, #65537	@ 0x10001
 c041b4e:	66a3      	str	r3, [r4, #104]	@ 0x68
  huart->RxISR = NULL;
 c041b50:	2300      	movs	r3, #0
  huart->TxISR = NULL;
 c041b52:	e9c4 331d 	strd	r3, r3, [r4, #116]	@ 0x74
}
 c041b56:	bd38      	pop	{r3, r4, r5, pc}
  UART_GETCLOCKSOURCE(huart, clocksource);
 c041b58:	2020      	movs	r0, #32
 c041b5a:	e7e6      	b.n	c041b2a <UART_SetConfig+0x8e>
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 c041b5c:	ebb3 3f05 	cmp.w	r3, r5, lsl #12
 c041b60:	d8f2      	bhi.n	c041b48 <UART_SetConfig+0xac>
        usartdiv = (uint32_t)(UART_DIV_LPUART(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 c041b62:	2300      	movs	r3, #0
 c041b64:	4619      	mov	r1, r3
 c041b66:	f001 ff25 	bl	c0439b4 <__aeabi_uldivmod>
 c041b6a:	0209      	lsls	r1, r1, #8
 c041b6c:	ea41 6110 	orr.w	r1, r1, r0, lsr #24
 c041b70:	086b      	lsrs	r3, r5, #1
 c041b72:	0200      	lsls	r0, r0, #8
 c041b74:	18c0      	adds	r0, r0, r3
 c041b76:	462a      	mov	r2, r5
 c041b78:	f04f 0300 	mov.w	r3, #0
 c041b7c:	f141 0100 	adc.w	r1, r1, #0
 c041b80:	f001 ff18 	bl	c0439b4 <__aeabi_uldivmod>
        if ((usartdiv >= LPUART_BRR_MIN) && (usartdiv <= LPUART_BRR_MAX))
 c041b84:	4b2b      	ldr	r3, [pc, #172]	@ (c041c34 <UART_SetConfig+0x198>)
 c041b86:	f5a0 7240 	sub.w	r2, r0, #768	@ 0x300
 c041b8a:	429a      	cmp	r2, r3
 c041b8c:	d8dc      	bhi.n	c041b48 <UART_SetConfig+0xac>
          huart->Instance->BRR = usartdiv;
 c041b8e:	6823      	ldr	r3, [r4, #0]
 c041b90:	60d8      	str	r0, [r3, #12]
  HAL_StatusTypeDef ret               = HAL_OK;
 c041b92:	2000      	movs	r0, #0
 c041b94:	e7d9      	b.n	c041b4a <UART_SetConfig+0xae>
  UART_GETCLOCKSOURCE(huart, clocksource);
 c041b96:	2001      	movs	r0, #1
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 c041b98:	f5b1 4f00 	cmp.w	r1, #32768	@ 0x8000
    pclk = HAL_RCCEx_GetPeriphCLKFreq(clocksource);
 c041b9c:	f04f 0100 	mov.w	r1, #0
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 c041ba0:	d126      	bne.n	c041bf0 <UART_SetConfig+0x154>
    pclk = HAL_RCCEx_GetPeriphCLKFreq(clocksource);
 c041ba2:	f7fe fd8b 	bl	c0406bc <HAL_RCCEx_GetPeriphCLKFreq>
    if (pclk != 0U)
 c041ba6:	2800      	cmp	r0, #0
 c041ba8:	d0f3      	beq.n	c041b92 <UART_SetConfig+0xf6>
      usartdiv = (uint32_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 c041baa:	6a61      	ldr	r1, [r4, #36]	@ 0x24
 c041bac:	4b20      	ldr	r3, [pc, #128]	@ (c041c30 <UART_SetConfig+0x194>)
 c041bae:	6862      	ldr	r2, [r4, #4]
 c041bb0:	f833 3011 	ldrh.w	r3, [r3, r1, lsl #1]
 c041bb4:	fbb0 f0f3 	udiv	r0, r0, r3
 c041bb8:	0853      	lsrs	r3, r2, #1
 c041bba:	eb03 0340 	add.w	r3, r3, r0, lsl #1
 c041bbe:	fbb3 f3f2 	udiv	r3, r3, r2
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 c041bc2:	f64f 72ef 	movw	r2, #65519	@ 0xffef
 c041bc6:	f1a3 0110 	sub.w	r1, r3, #16
 c041bca:	4291      	cmp	r1, r2
 c041bcc:	d8bc      	bhi.n	c041b48 <UART_SetConfig+0xac>
        brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
 c041bce:	f023 020f 	bic.w	r2, r3, #15
        huart->Instance->BRR = brrtemp;
 c041bd2:	6821      	ldr	r1, [r4, #0]
        brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
 c041bd4:	b292      	uxth	r2, r2
        brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
 c041bd6:	f3c3 0342 	ubfx	r3, r3, #1, #3
        huart->Instance->BRR = brrtemp;
 c041bda:	4313      	orrs	r3, r2
 c041bdc:	60cb      	str	r3, [r1, #12]
 c041bde:	e7d8      	b.n	c041b92 <UART_SetConfig+0xf6>
  UART_GETCLOCKSOURCE(huart, clocksource);
 c041be0:	2002      	movs	r0, #2
 c041be2:	e7d9      	b.n	c041b98 <UART_SetConfig+0xfc>
 c041be4:	2004      	movs	r0, #4
 c041be6:	e7d7      	b.n	c041b98 <UART_SetConfig+0xfc>
 c041be8:	2008      	movs	r0, #8
 c041bea:	e7d5      	b.n	c041b98 <UART_SetConfig+0xfc>
 c041bec:	2010      	movs	r0, #16
 c041bee:	e7d3      	b.n	c041b98 <UART_SetConfig+0xfc>
    pclk = HAL_RCCEx_GetPeriphCLKFreq(clocksource);
 c041bf0:	f7fe fd64 	bl	c0406bc <HAL_RCCEx_GetPeriphCLKFreq>
    if (pclk != 0U)
 c041bf4:	2800      	cmp	r0, #0
 c041bf6:	d0cc      	beq.n	c041b92 <UART_SetConfig+0xf6>
      usartdiv = (uint32_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 c041bf8:	6a61      	ldr	r1, [r4, #36]	@ 0x24
 c041bfa:	4b0d      	ldr	r3, [pc, #52]	@ (c041c30 <UART_SetConfig+0x194>)
 c041bfc:	6862      	ldr	r2, [r4, #4]
 c041bfe:	f833 3011 	ldrh.w	r3, [r3, r1, lsl #1]
 c041c02:	fbb0 f3f3 	udiv	r3, r0, r3
 c041c06:	eb03 0352 	add.w	r3, r3, r2, lsr #1
 c041c0a:	fbb3 f3f2 	udiv	r3, r3, r2
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 c041c0e:	f64f 72ef 	movw	r2, #65519	@ 0xffef
 c041c12:	f1a3 0110 	sub.w	r1, r3, #16
 c041c16:	4291      	cmp	r1, r2
 c041c18:	d896      	bhi.n	c041b48 <UART_SetConfig+0xac>
        huart->Instance->BRR = (uint16_t)usartdiv;
 c041c1a:	6822      	ldr	r2, [r4, #0]
 c041c1c:	60d3      	str	r3, [r2, #12]
 c041c1e:	e7b8      	b.n	c041b92 <UART_SetConfig+0xf6>
 c041c20:	cfff69f3 	.word	0xcfff69f3
 c041c24:	46002400 	.word	0x46002400
 c041c28:	50013800 	.word	0x50013800
 c041c2c:	56002400 	.word	0x56002400
 c041c30:	0c05fb9c 	.word	0x0c05fb9c
 c041c34:	000ffcff 	.word	0x000ffcff

0c041c38 <UART_AdvFeatureConfig>:
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 c041c38:	6a83      	ldr	r3, [r0, #40]	@ 0x28
{
 c041c3a:	b510      	push	{r4, lr}
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 c041c3c:	07da      	lsls	r2, r3, #31
 c041c3e:	d506      	bpl.n	c041c4e <UART_AdvFeatureConfig+0x16>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
 c041c40:	6801      	ldr	r1, [r0, #0]
 c041c42:	6ac4      	ldr	r4, [r0, #44]	@ 0x2c
 c041c44:	684a      	ldr	r2, [r1, #4]
 c041c46:	f422 3200 	bic.w	r2, r2, #131072	@ 0x20000
 c041c4a:	4322      	orrs	r2, r4
 c041c4c:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
 c041c4e:	079c      	lsls	r4, r3, #30
 c041c50:	d506      	bpl.n	c041c60 <UART_AdvFeatureConfig+0x28>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
 c041c52:	6801      	ldr	r1, [r0, #0]
 c041c54:	6b04      	ldr	r4, [r0, #48]	@ 0x30
 c041c56:	684a      	ldr	r2, [r1, #4]
 c041c58:	f422 3280 	bic.w	r2, r2, #65536	@ 0x10000
 c041c5c:	4322      	orrs	r2, r4
 c041c5e:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
 c041c60:	0759      	lsls	r1, r3, #29
 c041c62:	d506      	bpl.n	c041c72 <UART_AdvFeatureConfig+0x3a>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
 c041c64:	6801      	ldr	r1, [r0, #0]
 c041c66:	6b44      	ldr	r4, [r0, #52]	@ 0x34
 c041c68:	684a      	ldr	r2, [r1, #4]
 c041c6a:	f422 2280 	bic.w	r2, r2, #262144	@ 0x40000
 c041c6e:	4322      	orrs	r2, r4
 c041c70:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
 c041c72:	071a      	lsls	r2, r3, #28
 c041c74:	d506      	bpl.n	c041c84 <UART_AdvFeatureConfig+0x4c>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
 c041c76:	6801      	ldr	r1, [r0, #0]
 c041c78:	6b84      	ldr	r4, [r0, #56]	@ 0x38
 c041c7a:	684a      	ldr	r2, [r1, #4]
 c041c7c:	f422 4200 	bic.w	r2, r2, #32768	@ 0x8000
 c041c80:	4322      	orrs	r2, r4
 c041c82:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
 c041c84:	06dc      	lsls	r4, r3, #27
 c041c86:	d506      	bpl.n	c041c96 <UART_AdvFeatureConfig+0x5e>
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
 c041c88:	6801      	ldr	r1, [r0, #0]
 c041c8a:	6bc4      	ldr	r4, [r0, #60]	@ 0x3c
 c041c8c:	688a      	ldr	r2, [r1, #8]
 c041c8e:	f422 5280 	bic.w	r2, r2, #4096	@ 0x1000
 c041c92:	4322      	orrs	r2, r4
 c041c94:	608a      	str	r2, [r1, #8]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
 c041c96:	0699      	lsls	r1, r3, #26
 c041c98:	d506      	bpl.n	c041ca8 <UART_AdvFeatureConfig+0x70>
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
 c041c9a:	6801      	ldr	r1, [r0, #0]
 c041c9c:	6c04      	ldr	r4, [r0, #64]	@ 0x40
 c041c9e:	688a      	ldr	r2, [r1, #8]
 c041ca0:	f422 5200 	bic.w	r2, r2, #8192	@ 0x2000
 c041ca4:	4322      	orrs	r2, r4
 c041ca6:	608a      	str	r2, [r1, #8]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
 c041ca8:	065a      	lsls	r2, r3, #25
 c041caa:	d510      	bpl.n	c041cce <UART_AdvFeatureConfig+0x96>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 c041cac:	6801      	ldr	r1, [r0, #0]
 c041cae:	6c44      	ldr	r4, [r0, #68]	@ 0x44
 c041cb0:	684a      	ldr	r2, [r1, #4]
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 c041cb2:	f5b4 1f80 	cmp.w	r4, #1048576	@ 0x100000
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 c041cb6:	f422 1280 	bic.w	r2, r2, #1048576	@ 0x100000
 c041cba:	ea42 0204 	orr.w	r2, r2, r4
 c041cbe:	604a      	str	r2, [r1, #4]
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 c041cc0:	d105      	bne.n	c041cce <UART_AdvFeatureConfig+0x96>
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
 c041cc2:	684a      	ldr	r2, [r1, #4]
 c041cc4:	6c84      	ldr	r4, [r0, #72]	@ 0x48
 c041cc6:	f422 02c0 	bic.w	r2, r2, #6291456	@ 0x600000
 c041cca:	4322      	orrs	r2, r4
 c041ccc:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
 c041cce:	061b      	lsls	r3, r3, #24
 c041cd0:	d506      	bpl.n	c041ce0 <UART_AdvFeatureConfig+0xa8>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
 c041cd2:	6802      	ldr	r2, [r0, #0]
 c041cd4:	6cc1      	ldr	r1, [r0, #76]	@ 0x4c
 c041cd6:	6853      	ldr	r3, [r2, #4]
 c041cd8:	f423 2300 	bic.w	r3, r3, #524288	@ 0x80000
 c041cdc:	430b      	orrs	r3, r1
 c041cde:	6053      	str	r3, [r2, #4]
}
 c041ce0:	bd10      	pop	{r4, pc}

0c041ce2 <UART_WaitOnFlagUntilTimeout>:
{
 c041ce2:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 c041ce6:	4604      	mov	r4, r0
 c041ce8:	460f      	mov	r7, r1
 c041cea:	4616      	mov	r6, r2
 c041cec:	4698      	mov	r8, r3
 c041cee:	f8dd 9020 	ldr.w	r9, [sp, #32]
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 c041cf2:	6822      	ldr	r2, [r4, #0]
 c041cf4:	69d3      	ldr	r3, [r2, #28]
 c041cf6:	ea37 0303 	bics.w	r3, r7, r3
 c041cfa:	bf0c      	ite	eq
 c041cfc:	2301      	moveq	r3, #1
 c041cfe:	2300      	movne	r3, #0
 c041d00:	42b3      	cmp	r3, r6
 c041d02:	d001      	beq.n	c041d08 <UART_WaitOnFlagUntilTimeout+0x26>
  return HAL_OK;
 c041d04:	2000      	movs	r0, #0
 c041d06:	e01e      	b.n	c041d46 <UART_WaitOnFlagUntilTimeout+0x64>
    if (Timeout != HAL_MAX_DELAY)
 c041d08:	f1b9 3fff 	cmp.w	r9, #4294967295	@ 0xffffffff
 c041d0c:	d0f2      	beq.n	c041cf4 <UART_WaitOnFlagUntilTimeout+0x12>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 c041d0e:	f001 ffeb 	bl	c043ce8 <HAL_GetTick>
 c041d12:	eba0 0008 	sub.w	r0, r0, r8
 c041d16:	4548      	cmp	r0, r9
 c041d18:	d825      	bhi.n	c041d66 <UART_WaitOnFlagUntilTimeout+0x84>
 c041d1a:	f1b9 0f00 	cmp.w	r9, #0
 c041d1e:	d022      	beq.n	c041d66 <UART_WaitOnFlagUntilTimeout+0x84>
      if (READ_BIT(huart->Instance->CR1, USART_CR1_RE) != 0U)
 c041d20:	6820      	ldr	r0, [r4, #0]
 c041d22:	6803      	ldr	r3, [r0, #0]
 c041d24:	075a      	lsls	r2, r3, #29
 c041d26:	d5e4      	bpl.n	c041cf2 <UART_WaitOnFlagUntilTimeout+0x10>
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_ORE) == SET)
 c041d28:	69c5      	ldr	r5, [r0, #28]
 c041d2a:	f015 0508 	ands.w	r5, r5, #8
 c041d2e:	d00c      	beq.n	c041d4a <UART_WaitOnFlagUntilTimeout+0x68>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF);
 c041d30:	2508      	movs	r5, #8
 c041d32:	6205      	str	r5, [r0, #32]
          UART_EndRxTransfer(huart);
 c041d34:	4620      	mov	r0, r4
 c041d36:	f7ff fbfd 	bl	c041534 <UART_EndRxTransfer>
          __HAL_UNLOCK(huart);
 c041d3a:	2300      	movs	r3, #0
          return HAL_ERROR;
 c041d3c:	2001      	movs	r0, #1
          huart->ErrorCode = HAL_UART_ERROR_ORE;
 c041d3e:	f8c4 5090 	str.w	r5, [r4, #144]	@ 0x90
          __HAL_UNLOCK(huart);
 c041d42:	f884 3084 	strb.w	r3, [r4, #132]	@ 0x84
}
 c041d46:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_RTOF) == SET)
 c041d4a:	69c3      	ldr	r3, [r0, #28]
 c041d4c:	051b      	lsls	r3, r3, #20
 c041d4e:	d5d0      	bpl.n	c041cf2 <UART_WaitOnFlagUntilTimeout+0x10>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
 c041d50:	f44f 6300 	mov.w	r3, #2048	@ 0x800
 c041d54:	6203      	str	r3, [r0, #32]
          UART_EndRxTransfer(huart);
 c041d56:	4620      	mov	r0, r4
 c041d58:	f7ff fbec 	bl	c041534 <UART_EndRxTransfer>
          huart->ErrorCode = HAL_UART_ERROR_RTO;
 c041d5c:	2320      	movs	r3, #32
          __HAL_UNLOCK(huart);
 c041d5e:	f884 5084 	strb.w	r5, [r4, #132]	@ 0x84
          huart->ErrorCode = HAL_UART_ERROR_RTO;
 c041d62:	f8c4 3090 	str.w	r3, [r4, #144]	@ 0x90
        return HAL_TIMEOUT;
 c041d66:	2003      	movs	r0, #3
 c041d68:	e7ed      	b.n	c041d46 <UART_WaitOnFlagUntilTimeout+0x64>

0c041d6a <HAL_UART_Transmit>:
{
 c041d6a:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 c041d6e:	4698      	mov	r8, r3
  if (huart->gState == HAL_UART_STATE_READY)
 c041d70:	f8d0 3088 	ldr.w	r3, [r0, #136]	@ 0x88
{
 c041d74:	4604      	mov	r4, r0
  if (huart->gState == HAL_UART_STATE_READY)
 c041d76:	2b20      	cmp	r3, #32
{
 c041d78:	460e      	mov	r6, r1
 c041d7a:	4617      	mov	r7, r2
  if (huart->gState == HAL_UART_STATE_READY)
 c041d7c:	d14e      	bne.n	c041e1c <HAL_UART_Transmit+0xb2>
    if ((pData == NULL) || (Size == 0U))
 c041d7e:	2900      	cmp	r1, #0
 c041d80:	d04e      	beq.n	c041e20 <HAL_UART_Transmit+0xb6>
 c041d82:	2a00      	cmp	r2, #0
 c041d84:	d04c      	beq.n	c041e20 <HAL_UART_Transmit+0xb6>
    if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
 c041d86:	6803      	ldr	r3, [r0, #0]
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 c041d88:	2500      	movs	r5, #0
    if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
 c041d8a:	689a      	ldr	r2, [r3, #8]
 c041d8c:	0612      	lsls	r2, r2, #24
      CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
 c041d8e:	bf42      	ittt	mi
 c041d90:	689a      	ldrmi	r2, [r3, #8]
 c041d92:	f022 0280 	bicmi.w	r2, r2, #128	@ 0x80
 c041d96:	609a      	strmi	r2, [r3, #8]
    huart->gState = HAL_UART_STATE_BUSY_TX;
 c041d98:	2321      	movs	r3, #33	@ 0x21
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 c041d9a:	f8c0 5090 	str.w	r5, [r0, #144]	@ 0x90
    huart->gState = HAL_UART_STATE_BUSY_TX;
 c041d9e:	f8c0 3088 	str.w	r3, [r0, #136]	@ 0x88
    tickstart = HAL_GetTick();
 c041da2:	f001 ffa1 	bl	c043ce8 <HAL_GetTick>
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 c041da6:	68a3      	ldr	r3, [r4, #8]
    tickstart = HAL_GetTick();
 c041da8:	4681      	mov	r9, r0
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 c041daa:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
    huart->TxXferSize  = Size;
 c041dae:	f8a4 7054 	strh.w	r7, [r4, #84]	@ 0x54
    huart->TxXferCount = Size;
 c041db2:	f8a4 7056 	strh.w	r7, [r4, #86]	@ 0x56
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 c041db6:	d103      	bne.n	c041dc0 <HAL_UART_Transmit+0x56>
 c041db8:	6923      	ldr	r3, [r4, #16]
 c041dba:	b90b      	cbnz	r3, c041dc0 <HAL_UART_Transmit+0x56>
 c041dbc:	4635      	mov	r5, r6
      pdata8bits  = NULL;
 c041dbe:	461e      	mov	r6, r3
    while (huart->TxXferCount > 0U)
 c041dc0:	f8b4 2056 	ldrh.w	r2, [r4, #86]	@ 0x56
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
 c041dc4:	464b      	mov	r3, r9
    while (huart->TxXferCount > 0U)
 c041dc6:	b292      	uxth	r2, r2
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
 c041dc8:	f8cd 8000 	str.w	r8, [sp]
    while (huart->TxXferCount > 0U)
 c041dcc:	b942      	cbnz	r2, c041de0 <HAL_UART_Transmit+0x76>
    if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
 c041dce:	2140      	movs	r1, #64	@ 0x40
 c041dd0:	4620      	mov	r0, r4
 c041dd2:	f7ff ff86 	bl	c041ce2 <UART_WaitOnFlagUntilTimeout>
 c041dd6:	2320      	movs	r3, #32
 c041dd8:	b948      	cbnz	r0, c041dee <HAL_UART_Transmit+0x84>
    huart->gState = HAL_UART_STATE_READY;
 c041dda:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
    return HAL_OK;
 c041dde:	e009      	b.n	c041df4 <HAL_UART_Transmit+0x8a>
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
 c041de0:	2200      	movs	r2, #0
 c041de2:	2180      	movs	r1, #128	@ 0x80
 c041de4:	4620      	mov	r0, r4
 c041de6:	f7ff ff7c 	bl	c041ce2 <UART_WaitOnFlagUntilTimeout>
 c041dea:	b130      	cbz	r0, c041dfa <HAL_UART_Transmit+0x90>
        huart->gState = HAL_UART_STATE_READY;
 c041dec:	2320      	movs	r3, #32
        return HAL_TIMEOUT;
 c041dee:	2003      	movs	r0, #3
        huart->gState = HAL_UART_STATE_READY;
 c041df0:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
}
 c041df4:	b003      	add	sp, #12
 c041df6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        huart->Instance->TDR = (uint16_t)(*pdata16bits & 0x01FFU);
 c041dfa:	6822      	ldr	r2, [r4, #0]
      if (pdata8bits == NULL)
 c041dfc:	b95e      	cbnz	r6, c041e16 <HAL_UART_Transmit+0xac>
        huart->Instance->TDR = (uint16_t)(*pdata16bits & 0x01FFU);
 c041dfe:	f835 3b02 	ldrh.w	r3, [r5], #2
 c041e02:	f3c3 0308 	ubfx	r3, r3, #0, #9
        huart->Instance->TDR = (uint8_t)(*pdata8bits & 0xFFU);
 c041e06:	6293      	str	r3, [r2, #40]	@ 0x28
      huart->TxXferCount--;
 c041e08:	f8b4 2056 	ldrh.w	r2, [r4, #86]	@ 0x56
 c041e0c:	3a01      	subs	r2, #1
 c041e0e:	b292      	uxth	r2, r2
 c041e10:	f8a4 2056 	strh.w	r2, [r4, #86]	@ 0x56
 c041e14:	e7d4      	b.n	c041dc0 <HAL_UART_Transmit+0x56>
        huart->Instance->TDR = (uint8_t)(*pdata8bits & 0xFFU);
 c041e16:	f816 3b01 	ldrb.w	r3, [r6], #1
 c041e1a:	e7f4      	b.n	c041e06 <HAL_UART_Transmit+0x9c>
    return HAL_BUSY;
 c041e1c:	2002      	movs	r0, #2
 c041e1e:	e7e9      	b.n	c041df4 <HAL_UART_Transmit+0x8a>
      return  HAL_ERROR;
 c041e20:	2001      	movs	r0, #1
 c041e22:	e7e7      	b.n	c041df4 <HAL_UART_Transmit+0x8a>

0c041e24 <UART_CheckIdleState>:
{
 c041e24:	b573      	push	{r0, r1, r4, r5, r6, lr}
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 c041e26:	2600      	movs	r6, #0
{
 c041e28:	4604      	mov	r4, r0
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 c041e2a:	f8c0 6090 	str.w	r6, [r0, #144]	@ 0x90
  tickstart = HAL_GetTick();
 c041e2e:	f001 ff5b 	bl	c043ce8 <HAL_GetTick>
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 c041e32:	6823      	ldr	r3, [r4, #0]
  tickstart = HAL_GetTick();
 c041e34:	4605      	mov	r5, r0
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 c041e36:	681b      	ldr	r3, [r3, #0]
 c041e38:	071a      	lsls	r2, r3, #28
 c041e3a:	d51c      	bpl.n	c041e76 <UART_CheckIdleState+0x52>
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 c041e3c:	f06f 437e 	mvn.w	r3, #4261412864	@ 0xfe000000
 c041e40:	4632      	mov	r2, r6
 c041e42:	9300      	str	r3, [sp, #0]
 c041e44:	f44f 1100 	mov.w	r1, #2097152	@ 0x200000
 c041e48:	4603      	mov	r3, r0
 c041e4a:	4620      	mov	r0, r4
 c041e4c:	f7ff ff49 	bl	c041ce2 <UART_WaitOnFlagUntilTimeout>
 c041e50:	b188      	cbz	r0, c041e76 <UART_CheckIdleState+0x52>
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE_TXFNFIE));
 c041e52:	6822      	ldr	r2, [r4, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 c041e54:	e852 3f00 	ldrex	r3, [r2]
 c041e58:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 c041e5c:	e842 3100 	strex	r1, r3, [r2]
 c041e60:	2900      	cmp	r1, #0
 c041e62:	d1f6      	bne.n	c041e52 <UART_CheckIdleState+0x2e>
      huart->gState = HAL_UART_STATE_READY;
 c041e64:	2320      	movs	r3, #32
 c041e66:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
      return HAL_TIMEOUT;
 c041e6a:	2003      	movs	r0, #3
      __HAL_UNLOCK(huart);
 c041e6c:	2300      	movs	r3, #0
 c041e6e:	f884 3084 	strb.w	r3, [r4, #132]	@ 0x84
}
 c041e72:	b002      	add	sp, #8
 c041e74:	bd70      	pop	{r4, r5, r6, pc}
  if ((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
 c041e76:	6823      	ldr	r3, [r4, #0]
 c041e78:	681b      	ldr	r3, [r3, #0]
 c041e7a:	075b      	lsls	r3, r3, #29
 c041e7c:	d524      	bpl.n	c041ec8 <UART_CheckIdleState+0xa4>
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 c041e7e:	f06f 437e 	mvn.w	r3, #4261412864	@ 0xfe000000
 c041e82:	2200      	movs	r2, #0
 c041e84:	9300      	str	r3, [sp, #0]
 c041e86:	f44f 0180 	mov.w	r1, #4194304	@ 0x400000
 c041e8a:	462b      	mov	r3, r5
 c041e8c:	4620      	mov	r0, r4
 c041e8e:	f7ff ff28 	bl	c041ce2 <UART_WaitOnFlagUntilTimeout>
 c041e92:	b1c8      	cbz	r0, c041ec8 <UART_CheckIdleState+0xa4>
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
 c041e94:	6822      	ldr	r2, [r4, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 c041e96:	e852 3f00 	ldrex	r3, [r2]
 c041e9a:	f423 7390 	bic.w	r3, r3, #288	@ 0x120
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 c041e9e:	e842 3100 	strex	r1, r3, [r2]
   return(result);
 c041ea2:	6822      	ldr	r2, [r4, #0]
 c041ea4:	2900      	cmp	r1, #0
 c041ea6:	d1f5      	bne.n	c041e94 <UART_CheckIdleState+0x70>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 c041ea8:	f102 0308 	add.w	r3, r2, #8
 c041eac:	e853 3f00 	ldrex	r3, [r3]
      ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 c041eb0:	f023 0301 	bic.w	r3, r3, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 c041eb4:	f102 0008 	add.w	r0, r2, #8
 c041eb8:	e840 3100 	strex	r1, r3, [r0]
 c041ebc:	2900      	cmp	r1, #0
 c041ebe:	d1f3      	bne.n	c041ea8 <UART_CheckIdleState+0x84>
      huart->RxState = HAL_UART_STATE_READY;
 c041ec0:	2320      	movs	r3, #32
 c041ec2:	f8c4 308c 	str.w	r3, [r4, #140]	@ 0x8c
      return HAL_TIMEOUT;
 c041ec6:	e7d0      	b.n	c041e6a <UART_CheckIdleState+0x46>
  huart->gState = HAL_UART_STATE_READY;
 c041ec8:	2320      	movs	r3, #32
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 c041eca:	2000      	movs	r0, #0
  huart->gState = HAL_UART_STATE_READY;
 c041ecc:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
  huart->RxState = HAL_UART_STATE_READY;
 c041ed0:	f8c4 308c 	str.w	r3, [r4, #140]	@ 0x8c
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 c041ed4:	66e0      	str	r0, [r4, #108]	@ 0x6c
  huart->RxEventType = HAL_UART_RXEVENT_TC;
 c041ed6:	6720      	str	r0, [r4, #112]	@ 0x70
  return HAL_OK;
 c041ed8:	e7c8      	b.n	c041e6c <UART_CheckIdleState+0x48>

0c041eda <HAL_UART_Init>:
{
 c041eda:	b510      	push	{r4, lr}
  if (huart == NULL)
 c041edc:	4604      	mov	r4, r0
 c041ede:	b350      	cbz	r0, c041f36 <HAL_UART_Init+0x5c>
  if (huart->gState == HAL_UART_STATE_RESET)
 c041ee0:	f8d0 3088 	ldr.w	r3, [r0, #136]	@ 0x88
 c041ee4:	b91b      	cbnz	r3, c041eee <HAL_UART_Init+0x14>
    huart->Lock = HAL_UNLOCKED;
 c041ee6:	f880 3084 	strb.w	r3, [r0, #132]	@ 0x84
    HAL_UART_MspInit(huart);
 c041eea:	f7ff fb4f 	bl	c04158c <HAL_UART_MspInit>
  huart->gState = HAL_UART_STATE_BUSY;
 c041eee:	2324      	movs	r3, #36	@ 0x24
  __HAL_UART_DISABLE(huart);
 c041ef0:	6822      	ldr	r2, [r4, #0]
  huart->gState = HAL_UART_STATE_BUSY;
 c041ef2:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
  __HAL_UART_DISABLE(huart);
 c041ef6:	6813      	ldr	r3, [r2, #0]
  if (UART_SetConfig(huart) == HAL_ERROR)
 c041ef8:	4620      	mov	r0, r4
  __HAL_UART_DISABLE(huart);
 c041efa:	f023 0301 	bic.w	r3, r3, #1
 c041efe:	6013      	str	r3, [r2, #0]
  if (UART_SetConfig(huart) == HAL_ERROR)
 c041f00:	f7ff fdcc 	bl	c041a9c <UART_SetConfig>
 c041f04:	2801      	cmp	r0, #1
 c041f06:	d016      	beq.n	c041f36 <HAL_UART_Init+0x5c>
  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
 c041f08:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
 c041f0a:	b113      	cbz	r3, c041f12 <HAL_UART_Init+0x38>
    UART_AdvFeatureConfig(huart);
 c041f0c:	4620      	mov	r0, r4
 c041f0e:	f7ff fe93 	bl	c041c38 <UART_AdvFeatureConfig>
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 c041f12:	6823      	ldr	r3, [r4, #0]
  return (UART_CheckIdleState(huart));
 c041f14:	4620      	mov	r0, r4
}
 c041f16:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 c041f1a:	685a      	ldr	r2, [r3, #4]
 c041f1c:	f422 4290 	bic.w	r2, r2, #18432	@ 0x4800
 c041f20:	605a      	str	r2, [r3, #4]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 c041f22:	689a      	ldr	r2, [r3, #8]
 c041f24:	f022 022a 	bic.w	r2, r2, #42	@ 0x2a
 c041f28:	609a      	str	r2, [r3, #8]
  __HAL_UART_ENABLE(huart);
 c041f2a:	681a      	ldr	r2, [r3, #0]
 c041f2c:	f042 0201 	orr.w	r2, r2, #1
 c041f30:	601a      	str	r2, [r3, #0]
  return (UART_CheckIdleState(huart));
 c041f32:	f7ff bf77 	b.w	c041e24 <UART_CheckIdleState>
}
 c041f36:	2001      	movs	r0, #1
 c041f38:	bd10      	pop	{r4, pc}
	...

0c041f3c <UART_Start_Receive_IT>:
  huart->RxISR       = NULL;
 c041f3c:	2300      	movs	r3, #0
{
 c041f3e:	b530      	push	{r4, r5, lr}
  huart->pRxBuffPtr  = pData;
 c041f40:	6581      	str	r1, [r0, #88]	@ 0x58
  UART_MASK_COMPUTATION(huart);
 c041f42:	6881      	ldr	r1, [r0, #8]
  huart->RxXferSize  = Size;
 c041f44:	f8a0 205c 	strh.w	r2, [r0, #92]	@ 0x5c
  UART_MASK_COMPUTATION(huart);
 c041f48:	f5b1 5f80 	cmp.w	r1, #4096	@ 0x1000
  huart->RxXferCount = Size;
 c041f4c:	f8a0 205e 	strh.w	r2, [r0, #94]	@ 0x5e
  huart->RxISR       = NULL;
 c041f50:	6743      	str	r3, [r0, #116]	@ 0x74
  UART_MASK_COMPUTATION(huart);
 c041f52:	d135      	bne.n	c041fc0 <UART_Start_Receive_IT+0x84>
 c041f54:	6903      	ldr	r3, [r0, #16]
 c041f56:	2b00      	cmp	r3, #0
 c041f58:	f240 13ff 	movw	r3, #511	@ 0x1ff
 c041f5c:	bf18      	it	ne
 c041f5e:	23ff      	movne	r3, #255	@ 0xff
 c041f60:	f8a0 3060 	strh.w	r3, [r0, #96]	@ 0x60
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 c041f64:	2300      	movs	r3, #0
 c041f66:	f8c0 3090 	str.w	r3, [r0, #144]	@ 0x90
  huart->RxState = HAL_UART_STATE_BUSY_RX;
 c041f6a:	2322      	movs	r3, #34	@ 0x22
 c041f6c:	f8c0 308c 	str.w	r3, [r0, #140]	@ 0x8c
  ATOMIC_SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
 c041f70:	6801      	ldr	r1, [r0, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 c041f72:	f101 0308 	add.w	r3, r1, #8
 c041f76:	e853 3f00 	ldrex	r3, [r3]
 c041f7a:	f043 0301 	orr.w	r3, r3, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 c041f7e:	3108      	adds	r1, #8
 c041f80:	e841 3400 	strex	r4, r3, [r1]
   return(result);
 c041f84:	6803      	ldr	r3, [r0, #0]
 c041f86:	2c00      	cmp	r4, #0
 c041f88:	d1f2      	bne.n	c041f70 <UART_Start_Receive_IT+0x34>
  if ((huart->FifoMode == UART_FIFOMODE_ENABLE) && (Size >= huart->NbRxDataToProcess))
 c041f8a:	6e45      	ldr	r5, [r0, #100]	@ 0x64
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 c041f8c:	6884      	ldr	r4, [r0, #8]
  if ((huart->FifoMode == UART_FIFOMODE_ENABLE) && (Size >= huart->NbRxDataToProcess))
 c041f8e:	f1b5 5f00 	cmp.w	r5, #536870912	@ 0x20000000
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 c041f92:	6901      	ldr	r1, [r0, #16]
  if ((huart->FifoMode == UART_FIFOMODE_ENABLE) && (Size >= huart->NbRxDataToProcess))
 c041f94:	d132      	bne.n	c041ffc <UART_Start_Receive_IT+0xc0>
 c041f96:	f8b0 5068 	ldrh.w	r5, [r0, #104]	@ 0x68
 c041f9a:	4295      	cmp	r5, r2
 c041f9c:	d82e      	bhi.n	c041ffc <UART_Start_Receive_IT+0xc0>
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 c041f9e:	f5b4 5f80 	cmp.w	r4, #4096	@ 0x1000
      huart->RxISR = UART_RxISR_16BIT_FIFOEN;
 c041fa2:	4a24      	ldr	r2, [pc, #144]	@ (c042034 <UART_Start_Receive_IT+0xf8>)
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 c041fa4:	d103      	bne.n	c041fae <UART_Start_Receive_IT+0x72>
      huart->RxISR = UART_RxISR_16BIT_FIFOEN;
 c041fa6:	4c24      	ldr	r4, [pc, #144]	@ (c042038 <UART_Start_Receive_IT+0xfc>)
 c041fa8:	2900      	cmp	r1, #0
 c041faa:	bf08      	it	eq
 c041fac:	4622      	moveq	r2, r4
 c041fae:	6742      	str	r2, [r0, #116]	@ 0x74
    if (huart->Init.Parity != UART_PARITY_NONE)
 c041fb0:	b1b1      	cbz	r1, c041fe0 <UART_Start_Receive_IT+0xa4>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 c041fb2:	e853 2f00 	ldrex	r2, [r3]
      ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 c041fb6:	f442 7280 	orr.w	r2, r2, #256	@ 0x100
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 c041fba:	e843 2100 	strex	r1, r2, [r3]
   return(result);
 c041fbe:	e7f7      	b.n	c041fb0 <UART_Start_Receive_IT+0x74>
  UART_MASK_COMPUTATION(huart);
 c041fc0:	b929      	cbnz	r1, c041fce <UART_Start_Receive_IT+0x92>
 c041fc2:	6903      	ldr	r3, [r0, #16]
 c041fc4:	2b00      	cmp	r3, #0
 c041fc6:	bf14      	ite	ne
 c041fc8:	237f      	movne	r3, #127	@ 0x7f
 c041fca:	23ff      	moveq	r3, #255	@ 0xff
 c041fcc:	e7c8      	b.n	c041f60 <UART_Start_Receive_IT+0x24>
 c041fce:	f1b1 5f80 	cmp.w	r1, #268435456	@ 0x10000000
 c041fd2:	d1c5      	bne.n	c041f60 <UART_Start_Receive_IT+0x24>
 c041fd4:	6903      	ldr	r3, [r0, #16]
 c041fd6:	2b00      	cmp	r3, #0
 c041fd8:	bf14      	ite	ne
 c041fda:	233f      	movne	r3, #63	@ 0x3f
 c041fdc:	237f      	moveq	r3, #127	@ 0x7f
 c041fde:	e7bf      	b.n	c041f60 <UART_Start_Receive_IT+0x24>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 c041fe0:	f103 0208 	add.w	r2, r3, #8
 c041fe4:	e852 2f00 	ldrex	r2, [r2]
    ATOMIC_SET_BIT(huart->Instance->CR3, USART_CR3_RXFTIE);
 c041fe8:	f042 5280 	orr.w	r2, r2, #268435456	@ 0x10000000
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 c041fec:	f103 0008 	add.w	r0, r3, #8
 c041ff0:	e840 2100 	strex	r1, r2, [r0]
 c041ff4:	2900      	cmp	r1, #0
 c041ff6:	d1f3      	bne.n	c041fe0 <UART_Start_Receive_IT+0xa4>
}
 c041ff8:	2000      	movs	r0, #0
 c041ffa:	bd30      	pop	{r4, r5, pc}
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 c041ffc:	f5b4 5f80 	cmp.w	r4, #4096	@ 0x1000
      huart->RxISR = UART_RxISR_16BIT;
 c042000:	4a0e      	ldr	r2, [pc, #56]	@ (c04203c <UART_Start_Receive_IT+0x100>)
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 c042002:	d103      	bne.n	c04200c <UART_Start_Receive_IT+0xd0>
      huart->RxISR = UART_RxISR_16BIT;
 c042004:	4c0e      	ldr	r4, [pc, #56]	@ (c042040 <UART_Start_Receive_IT+0x104>)
 c042006:	2900      	cmp	r1, #0
 c042008:	bf08      	it	eq
 c04200a:	4622      	moveq	r2, r4
 c04200c:	6742      	str	r2, [r0, #116]	@ 0x74
    if (huart->Init.Parity != UART_PARITY_NONE)
 c04200e:	b141      	cbz	r1, c042022 <UART_Start_Receive_IT+0xe6>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 c042010:	e853 2f00 	ldrex	r2, [r3]
      ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_PEIE | USART_CR1_RXNEIE_RXFNEIE);
 c042014:	f442 7290 	orr.w	r2, r2, #288	@ 0x120
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 c042018:	e843 2100 	strex	r1, r2, [r3]
 c04201c:	2900      	cmp	r1, #0
 c04201e:	d1f7      	bne.n	c042010 <UART_Start_Receive_IT+0xd4>
 c042020:	e7ea      	b.n	c041ff8 <UART_Start_Receive_IT+0xbc>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 c042022:	e853 2f00 	ldrex	r2, [r3]
      ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_RXNEIE_RXFNEIE);
 c042026:	f042 0220 	orr.w	r2, r2, #32
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 c04202a:	e843 2100 	strex	r1, r2, [r3]
 c04202e:	2900      	cmp	r1, #0
 c042030:	d1f7      	bne.n	c042022 <UART_Start_Receive_IT+0xe6>
 c042032:	e7e1      	b.n	c041ff8 <UART_Start_Receive_IT+0xbc>
 c042034:	0c041739 	.word	0x0c041739
 c042038:	0c0418ed 	.word	0x0c0418ed
 c04203c:	0c041595 	.word	0x0c041595
 c042040:	0c041669 	.word	0x0c041669

0c042044 <HAL_UART_Receive_IT>:
  if (huart->RxState == HAL_UART_STATE_READY)
 c042044:	f8d0 308c 	ldr.w	r3, [r0, #140]	@ 0x8c
{
 c042048:	b430      	push	{r4, r5}
  if (huart->RxState == HAL_UART_STATE_READY)
 c04204a:	2b20      	cmp	r3, #32
 c04204c:	d120      	bne.n	c042090 <HAL_UART_Receive_IT+0x4c>
    if ((pData == NULL) || (Size == 0U))
 c04204e:	b311      	cbz	r1, c042096 <HAL_UART_Receive_IT+0x52>
 c042050:	b30a      	cbz	r2, c042096 <HAL_UART_Receive_IT+0x52>
    huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 c042052:	2300      	movs	r3, #0
 c042054:	66c3      	str	r3, [r0, #108]	@ 0x6c
    if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 c042056:	6803      	ldr	r3, [r0, #0]
 c042058:	689c      	ldr	r4, [r3, #8]
 c04205a:	0665      	lsls	r5, r4, #25
      CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 c04205c:	bf42      	ittt	mi
 c04205e:	689c      	ldrmi	r4, [r3, #8]
 c042060:	f024 0440 	bicmi.w	r4, r4, #64	@ 0x40
 c042064:	609c      	strmi	r4, [r3, #8]
    if (!(IS_LPUART_INSTANCE(huart->Instance)))
 c042066:	4c0d      	ldr	r4, [pc, #52]	@ (c04209c <HAL_UART_Receive_IT+0x58>)
 c042068:	42a3      	cmp	r3, r4
 c04206a:	d00e      	beq.n	c04208a <HAL_UART_Receive_IT+0x46>
 c04206c:	f104 5480 	add.w	r4, r4, #268435456	@ 0x10000000
 c042070:	42a3      	cmp	r3, r4
 c042072:	d00a      	beq.n	c04208a <HAL_UART_Receive_IT+0x46>
      if (READ_BIT(huart->Instance->CR2, USART_CR2_RTOEN) != 0U)
 c042074:	685c      	ldr	r4, [r3, #4]
 c042076:	0224      	lsls	r4, r4, #8
 c042078:	d507      	bpl.n	c04208a <HAL_UART_Receive_IT+0x46>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 c04207a:	e853 4f00 	ldrex	r4, [r3]
        ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_RTOIE);
 c04207e:	f044 6480 	orr.w	r4, r4, #67108864	@ 0x4000000
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 c042082:	e843 4500 	strex	r5, r4, [r3]
 c042086:	2d00      	cmp	r5, #0
 c042088:	d1f7      	bne.n	c04207a <HAL_UART_Receive_IT+0x36>
}
 c04208a:	bc30      	pop	{r4, r5}
    return (UART_Start_Receive_IT(huart, pData, Size));
 c04208c:	f7ff bf56 	b.w	c041f3c <UART_Start_Receive_IT>
    return HAL_BUSY;
 c042090:	2002      	movs	r0, #2
}
 c042092:	bc30      	pop	{r4, r5}
 c042094:	4770      	bx	lr
      return HAL_ERROR;
 c042096:	2001      	movs	r0, #1
 c042098:	e7fb      	b.n	c042092 <HAL_UART_Receive_IT+0x4e>
 c04209a:	bf00      	nop
 c04209c:	46002400 	.word	0x46002400

0c0420a0 <calloc>:
 c0420a0:	4b02      	ldr	r3, [pc, #8]	@ (c0420ac <calloc+0xc>)
 c0420a2:	460a      	mov	r2, r1
 c0420a4:	4601      	mov	r1, r0
 c0420a6:	6818      	ldr	r0, [r3, #0]
 c0420a8:	f000 b802 	b.w	c0420b0 <_calloc_r>
 c0420ac:	30030ad4 	.word	0x30030ad4

0c0420b0 <_calloc_r>:
 c0420b0:	b570      	push	{r4, r5, r6, lr}
 c0420b2:	fba1 5402 	umull	r5, r4, r1, r2
 c0420b6:	b93c      	cbnz	r4, c0420c8 <_calloc_r+0x18>
 c0420b8:	4629      	mov	r1, r5
 c0420ba:	f000 f851 	bl	c042160 <_malloc_r>
 c0420be:	4606      	mov	r6, r0
 c0420c0:	b928      	cbnz	r0, c0420ce <_calloc_r+0x1e>
 c0420c2:	2600      	movs	r6, #0
 c0420c4:	4630      	mov	r0, r6
 c0420c6:	bd70      	pop	{r4, r5, r6, pc}
 c0420c8:	220c      	movs	r2, #12
 c0420ca:	6002      	str	r2, [r0, #0]
 c0420cc:	e7f9      	b.n	c0420c2 <_calloc_r+0x12>
 c0420ce:	462a      	mov	r2, r5
 c0420d0:	4621      	mov	r1, r4
 c0420d2:	f019 fb2c 	bl	c05b72e <memset>
 c0420d6:	e7f5      	b.n	c0420c4 <_calloc_r+0x14>

0c0420d8 <exit>:
 c0420d8:	b508      	push	{r3, lr}
 c0420da:	4b06      	ldr	r3, [pc, #24]	@ (c0420f4 <exit+0x1c>)
 c0420dc:	4604      	mov	r4, r0
 c0420de:	b113      	cbz	r3, c0420e6 <exit+0xe>
 c0420e0:	2100      	movs	r1, #0
 c0420e2:	f3af 8000 	nop.w
 c0420e6:	4b04      	ldr	r3, [pc, #16]	@ (c0420f8 <exit+0x20>)
 c0420e8:	681b      	ldr	r3, [r3, #0]
 c0420ea:	b103      	cbz	r3, c0420ee <exit+0x16>
 c0420ec:	4798      	blx	r3
 c0420ee:	4620      	mov	r0, r4
 c0420f0:	f01c fb78 	bl	c05e7e4 <_exit>
 c0420f4:	00000000 	.word	0x00000000
 c0420f8:	3003e950 	.word	0x3003e950

0c0420fc <malloc>:
 c0420fc:	4b02      	ldr	r3, [pc, #8]	@ (c042108 <malloc+0xc>)
 c0420fe:	4601      	mov	r1, r0
 c042100:	6818      	ldr	r0, [r3, #0]
 c042102:	f000 b82d 	b.w	c042160 <_malloc_r>
 c042106:	bf00      	nop
 c042108:	30030ad4 	.word	0x30030ad4

0c04210c <free>:
 c04210c:	4b02      	ldr	r3, [pc, #8]	@ (c042118 <free+0xc>)
 c04210e:	4601      	mov	r1, r0
 c042110:	6818      	ldr	r0, [r3, #0]
 c042112:	f000 bacd 	b.w	c0426b0 <_free_r>
 c042116:	bf00      	nop
 c042118:	30030ad4 	.word	0x30030ad4

0c04211c <sbrk_aligned>:
 c04211c:	b570      	push	{r4, r5, r6, lr}
 c04211e:	4e0f      	ldr	r6, [pc, #60]	@ (c04215c <sbrk_aligned+0x40>)
 c042120:	460c      	mov	r4, r1
 c042122:	4605      	mov	r5, r0
 c042124:	6831      	ldr	r1, [r6, #0]
 c042126:	b911      	cbnz	r1, c04212e <sbrk_aligned+0x12>
 c042128:	f000 fa70 	bl	c04260c <_sbrk_r>
 c04212c:	6030      	str	r0, [r6, #0]
 c04212e:	4621      	mov	r1, r4
 c042130:	4628      	mov	r0, r5
 c042132:	f000 fa6b 	bl	c04260c <_sbrk_r>
 c042136:	1c43      	adds	r3, r0, #1
 c042138:	d103      	bne.n	c042142 <sbrk_aligned+0x26>
 c04213a:	f04f 34ff 	mov.w	r4, #4294967295	@ 0xffffffff
 c04213e:	4620      	mov	r0, r4
 c042140:	bd70      	pop	{r4, r5, r6, pc}
 c042142:	1cc4      	adds	r4, r0, #3
 c042144:	f024 0403 	bic.w	r4, r4, #3
 c042148:	42a0      	cmp	r0, r4
 c04214a:	d0f8      	beq.n	c04213e <sbrk_aligned+0x22>
 c04214c:	1a21      	subs	r1, r4, r0
 c04214e:	4628      	mov	r0, r5
 c042150:	f000 fa5c 	bl	c04260c <_sbrk_r>
 c042154:	3001      	adds	r0, #1
 c042156:	d1f2      	bne.n	c04213e <sbrk_aligned+0x22>
 c042158:	e7ef      	b.n	c04213a <sbrk_aligned+0x1e>
 c04215a:	bf00      	nop
 c04215c:	3003e810 	.word	0x3003e810

0c042160 <_malloc_r>:
 c042160:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 c042164:	1ccd      	adds	r5, r1, #3
 c042166:	4606      	mov	r6, r0
 c042168:	f025 0503 	bic.w	r5, r5, #3
 c04216c:	3508      	adds	r5, #8
 c04216e:	2d0c      	cmp	r5, #12
 c042170:	bf38      	it	cc
 c042172:	250c      	movcc	r5, #12
 c042174:	2d00      	cmp	r5, #0
 c042176:	db01      	blt.n	c04217c <_malloc_r+0x1c>
 c042178:	42a9      	cmp	r1, r5
 c04217a:	d904      	bls.n	c042186 <_malloc_r+0x26>
 c04217c:	230c      	movs	r3, #12
 c04217e:	6033      	str	r3, [r6, #0]
 c042180:	2000      	movs	r0, #0
 c042182:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 c042186:	f8df 80d4 	ldr.w	r8, [pc, #212]	@ c04225c <_malloc_r+0xfc>
 c04218a:	f000 f869 	bl	c042260 <__malloc_lock>
 c04218e:	f8d8 3000 	ldr.w	r3, [r8]
 c042192:	461c      	mov	r4, r3
 c042194:	bb44      	cbnz	r4, c0421e8 <_malloc_r+0x88>
 c042196:	4629      	mov	r1, r5
 c042198:	4630      	mov	r0, r6
 c04219a:	f7ff ffbf 	bl	c04211c <sbrk_aligned>
 c04219e:	1c43      	adds	r3, r0, #1
 c0421a0:	4604      	mov	r4, r0
 c0421a2:	d158      	bne.n	c042256 <_malloc_r+0xf6>
 c0421a4:	f8d8 4000 	ldr.w	r4, [r8]
 c0421a8:	4627      	mov	r7, r4
 c0421aa:	2f00      	cmp	r7, #0
 c0421ac:	d143      	bne.n	c042236 <_malloc_r+0xd6>
 c0421ae:	2c00      	cmp	r4, #0
 c0421b0:	d04b      	beq.n	c04224a <_malloc_r+0xea>
 c0421b2:	6823      	ldr	r3, [r4, #0]
 c0421b4:	4639      	mov	r1, r7
 c0421b6:	4630      	mov	r0, r6
 c0421b8:	eb04 0903 	add.w	r9, r4, r3
 c0421bc:	f000 fa26 	bl	c04260c <_sbrk_r>
 c0421c0:	4581      	cmp	r9, r0
 c0421c2:	d142      	bne.n	c04224a <_malloc_r+0xea>
 c0421c4:	6821      	ldr	r1, [r4, #0]
 c0421c6:	4630      	mov	r0, r6
 c0421c8:	1a6d      	subs	r5, r5, r1
 c0421ca:	4629      	mov	r1, r5
 c0421cc:	f7ff ffa6 	bl	c04211c <sbrk_aligned>
 c0421d0:	3001      	adds	r0, #1
 c0421d2:	d03a      	beq.n	c04224a <_malloc_r+0xea>
 c0421d4:	6823      	ldr	r3, [r4, #0]
 c0421d6:	442b      	add	r3, r5
 c0421d8:	6023      	str	r3, [r4, #0]
 c0421da:	f8d8 3000 	ldr.w	r3, [r8]
 c0421de:	685a      	ldr	r2, [r3, #4]
 c0421e0:	bb62      	cbnz	r2, c04223c <_malloc_r+0xdc>
 c0421e2:	f8c8 7000 	str.w	r7, [r8]
 c0421e6:	e00f      	b.n	c042208 <_malloc_r+0xa8>
 c0421e8:	6822      	ldr	r2, [r4, #0]
 c0421ea:	1b52      	subs	r2, r2, r5
 c0421ec:	d420      	bmi.n	c042230 <_malloc_r+0xd0>
 c0421ee:	2a0b      	cmp	r2, #11
 c0421f0:	d917      	bls.n	c042222 <_malloc_r+0xc2>
 c0421f2:	1961      	adds	r1, r4, r5
 c0421f4:	42a3      	cmp	r3, r4
 c0421f6:	6025      	str	r5, [r4, #0]
 c0421f8:	bf18      	it	ne
 c0421fa:	6059      	strne	r1, [r3, #4]
 c0421fc:	6863      	ldr	r3, [r4, #4]
 c0421fe:	bf08      	it	eq
 c042200:	f8c8 1000 	streq.w	r1, [r8]
 c042204:	5162      	str	r2, [r4, r5]
 c042206:	604b      	str	r3, [r1, #4]
 c042208:	4630      	mov	r0, r6
 c04220a:	f000 f82f 	bl	c04226c <__malloc_unlock>
 c04220e:	f104 000b 	add.w	r0, r4, #11
 c042212:	1d23      	adds	r3, r4, #4
 c042214:	f020 0007 	bic.w	r0, r0, #7
 c042218:	1ac2      	subs	r2, r0, r3
 c04221a:	bf1c      	itt	ne
 c04221c:	1a1b      	subne	r3, r3, r0
 c04221e:	50a3      	strne	r3, [r4, r2]
 c042220:	e7af      	b.n	c042182 <_malloc_r+0x22>
 c042222:	6862      	ldr	r2, [r4, #4]
 c042224:	42a3      	cmp	r3, r4
 c042226:	bf0c      	ite	eq
 c042228:	f8c8 2000 	streq.w	r2, [r8]
 c04222c:	605a      	strne	r2, [r3, #4]
 c04222e:	e7eb      	b.n	c042208 <_malloc_r+0xa8>
 c042230:	4623      	mov	r3, r4
 c042232:	6864      	ldr	r4, [r4, #4]
 c042234:	e7ae      	b.n	c042194 <_malloc_r+0x34>
 c042236:	463c      	mov	r4, r7
 c042238:	687f      	ldr	r7, [r7, #4]
 c04223a:	e7b6      	b.n	c0421aa <_malloc_r+0x4a>
 c04223c:	461a      	mov	r2, r3
 c04223e:	685b      	ldr	r3, [r3, #4]
 c042240:	42a3      	cmp	r3, r4
 c042242:	d1fb      	bne.n	c04223c <_malloc_r+0xdc>
 c042244:	2300      	movs	r3, #0
 c042246:	6053      	str	r3, [r2, #4]
 c042248:	e7de      	b.n	c042208 <_malloc_r+0xa8>
 c04224a:	230c      	movs	r3, #12
 c04224c:	4630      	mov	r0, r6
 c04224e:	6033      	str	r3, [r6, #0]
 c042250:	f000 f80c 	bl	c04226c <__malloc_unlock>
 c042254:	e794      	b.n	c042180 <_malloc_r+0x20>
 c042256:	6005      	str	r5, [r0, #0]
 c042258:	e7d6      	b.n	c042208 <_malloc_r+0xa8>
 c04225a:	bf00      	nop
 c04225c:	3003e814 	.word	0x3003e814

0c042260 <__malloc_lock>:
 c042260:	4801      	ldr	r0, [pc, #4]	@ (c042268 <__malloc_lock+0x8>)
 c042262:	f000 ba1a 	b.w	c04269a <__retarget_lock_acquire_recursive>
 c042266:	bf00      	nop
 c042268:	3003e958 	.word	0x3003e958

0c04226c <__malloc_unlock>:
 c04226c:	4801      	ldr	r0, [pc, #4]	@ (c042274 <__malloc_unlock+0x8>)
 c04226e:	f000 ba15 	b.w	c04269c <__retarget_lock_release_recursive>
 c042272:	bf00      	nop
 c042274:	3003e958 	.word	0x3003e958

0c042278 <std>:
 c042278:	2300      	movs	r3, #0
 c04227a:	b510      	push	{r4, lr}
 c04227c:	4604      	mov	r4, r0
 c04227e:	6083      	str	r3, [r0, #8]
 c042280:	8181      	strh	r1, [r0, #12]
 c042282:	4619      	mov	r1, r3
 c042284:	6643      	str	r3, [r0, #100]	@ 0x64
 c042286:	81c2      	strh	r2, [r0, #14]
 c042288:	2208      	movs	r2, #8
 c04228a:	6183      	str	r3, [r0, #24]
 c04228c:	e9c0 3300 	strd	r3, r3, [r0]
 c042290:	e9c0 3304 	strd	r3, r3, [r0, #16]
 c042294:	305c      	adds	r0, #92	@ 0x5c
 c042296:	f019 fa4a 	bl	c05b72e <memset>
 c04229a:	4b0d      	ldr	r3, [pc, #52]	@ (c0422d0 <std+0x58>)
 c04229c:	6224      	str	r4, [r4, #32]
 c04229e:	6263      	str	r3, [r4, #36]	@ 0x24
 c0422a0:	4b0c      	ldr	r3, [pc, #48]	@ (c0422d4 <std+0x5c>)
 c0422a2:	62a3      	str	r3, [r4, #40]	@ 0x28
 c0422a4:	4b0c      	ldr	r3, [pc, #48]	@ (c0422d8 <std+0x60>)
 c0422a6:	62e3      	str	r3, [r4, #44]	@ 0x2c
 c0422a8:	4b0c      	ldr	r3, [pc, #48]	@ (c0422dc <std+0x64>)
 c0422aa:	6323      	str	r3, [r4, #48]	@ 0x30
 c0422ac:	4b0c      	ldr	r3, [pc, #48]	@ (c0422e0 <std+0x68>)
 c0422ae:	429c      	cmp	r4, r3
 c0422b0:	d006      	beq.n	c0422c0 <std+0x48>
 c0422b2:	f103 0268 	add.w	r2, r3, #104	@ 0x68
 c0422b6:	4294      	cmp	r4, r2
 c0422b8:	d002      	beq.n	c0422c0 <std+0x48>
 c0422ba:	33d0      	adds	r3, #208	@ 0xd0
 c0422bc:	429c      	cmp	r4, r3
 c0422be:	d105      	bne.n	c0422cc <std+0x54>
 c0422c0:	f104 0058 	add.w	r0, r4, #88	@ 0x58
 c0422c4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 c0422c8:	f000 b9e6 	b.w	c042698 <__retarget_lock_init_recursive>
 c0422cc:	bd10      	pop	{r4, pc}
 c0422ce:	bf00      	nop
 c0422d0:	0c042489 	.word	0x0c042489
 c0422d4:	0c0424ab 	.word	0x0c0424ab
 c0422d8:	0c0424e3 	.word	0x0c0424e3
 c0422dc:	0c042507 	.word	0x0c042507
 c0422e0:	3003e818 	.word	0x3003e818

0c0422e4 <stdio_exit_handler>:
 c0422e4:	4a02      	ldr	r2, [pc, #8]	@ (c0422f0 <stdio_exit_handler+0xc>)
 c0422e6:	4903      	ldr	r1, [pc, #12]	@ (c0422f4 <stdio_exit_handler+0x10>)
 c0422e8:	4803      	ldr	r0, [pc, #12]	@ (c0422f8 <stdio_exit_handler+0x14>)
 c0422ea:	f000 b869 	b.w	c0423c0 <_fwalk_sglue>
 c0422ee:	bf00      	nop
 c0422f0:	30030ac8 	.word	0x30030ac8
 c0422f4:	0c043099 	.word	0x0c043099
 c0422f8:	30030ad8 	.word	0x30030ad8

0c0422fc <cleanup_stdio>:
 c0422fc:	6841      	ldr	r1, [r0, #4]
 c0422fe:	4b0c      	ldr	r3, [pc, #48]	@ (c042330 <cleanup_stdio+0x34>)
 c042300:	4299      	cmp	r1, r3
 c042302:	b510      	push	{r4, lr}
 c042304:	4604      	mov	r4, r0
 c042306:	d001      	beq.n	c04230c <cleanup_stdio+0x10>
 c042308:	f000 fec6 	bl	c043098 <_fflush_r>
 c04230c:	68a1      	ldr	r1, [r4, #8]
 c04230e:	4b09      	ldr	r3, [pc, #36]	@ (c042334 <cleanup_stdio+0x38>)
 c042310:	4299      	cmp	r1, r3
 c042312:	d002      	beq.n	c04231a <cleanup_stdio+0x1e>
 c042314:	4620      	mov	r0, r4
 c042316:	f000 febf 	bl	c043098 <_fflush_r>
 c04231a:	68e1      	ldr	r1, [r4, #12]
 c04231c:	4b06      	ldr	r3, [pc, #24]	@ (c042338 <cleanup_stdio+0x3c>)
 c04231e:	4299      	cmp	r1, r3
 c042320:	d004      	beq.n	c04232c <cleanup_stdio+0x30>
 c042322:	4620      	mov	r0, r4
 c042324:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 c042328:	f000 beb6 	b.w	c043098 <_fflush_r>
 c04232c:	bd10      	pop	{r4, pc}
 c04232e:	bf00      	nop
 c042330:	3003e818 	.word	0x3003e818
 c042334:	3003e880 	.word	0x3003e880
 c042338:	3003e8e8 	.word	0x3003e8e8

0c04233c <global_stdio_init.part.0>:
 c04233c:	b510      	push	{r4, lr}
 c04233e:	4b0b      	ldr	r3, [pc, #44]	@ (c04236c <global_stdio_init.part.0+0x30>)
 c042340:	2104      	movs	r1, #4
 c042342:	4c0b      	ldr	r4, [pc, #44]	@ (c042370 <global_stdio_init.part.0+0x34>)
 c042344:	4a0b      	ldr	r2, [pc, #44]	@ (c042374 <global_stdio_init.part.0+0x38>)
 c042346:	4620      	mov	r0, r4
 c042348:	601a      	str	r2, [r3, #0]
 c04234a:	2200      	movs	r2, #0
 c04234c:	f7ff ff94 	bl	c042278 <std>
 c042350:	f104 0068 	add.w	r0, r4, #104	@ 0x68
 c042354:	2201      	movs	r2, #1
 c042356:	2109      	movs	r1, #9
 c042358:	f7ff ff8e 	bl	c042278 <std>
 c04235c:	f104 00d0 	add.w	r0, r4, #208	@ 0xd0
 c042360:	2202      	movs	r2, #2
 c042362:	2112      	movs	r1, #18
 c042364:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 c042368:	f7ff bf86 	b.w	c042278 <std>
 c04236c:	3003e950 	.word	0x3003e950
 c042370:	3003e818 	.word	0x3003e818
 c042374:	0c0422e5 	.word	0x0c0422e5

0c042378 <__sfp_lock_acquire>:
 c042378:	4801      	ldr	r0, [pc, #4]	@ (c042380 <__sfp_lock_acquire+0x8>)
 c04237a:	f000 b98e 	b.w	c04269a <__retarget_lock_acquire_recursive>
 c04237e:	bf00      	nop
 c042380:	3003e959 	.word	0x3003e959

0c042384 <__sfp_lock_release>:
 c042384:	4801      	ldr	r0, [pc, #4]	@ (c04238c <__sfp_lock_release+0x8>)
 c042386:	f000 b989 	b.w	c04269c <__retarget_lock_release_recursive>
 c04238a:	bf00      	nop
 c04238c:	3003e959 	.word	0x3003e959

0c042390 <__sinit>:
 c042390:	b510      	push	{r4, lr}
 c042392:	4604      	mov	r4, r0
 c042394:	f7ff fff0 	bl	c042378 <__sfp_lock_acquire>
 c042398:	6a23      	ldr	r3, [r4, #32]
 c04239a:	b11b      	cbz	r3, c0423a4 <__sinit+0x14>
 c04239c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 c0423a0:	f7ff bff0 	b.w	c042384 <__sfp_lock_release>
 c0423a4:	4b04      	ldr	r3, [pc, #16]	@ (c0423b8 <__sinit+0x28>)
 c0423a6:	6223      	str	r3, [r4, #32]
 c0423a8:	4b04      	ldr	r3, [pc, #16]	@ (c0423bc <__sinit+0x2c>)
 c0423aa:	681b      	ldr	r3, [r3, #0]
 c0423ac:	2b00      	cmp	r3, #0
 c0423ae:	d1f5      	bne.n	c04239c <__sinit+0xc>
 c0423b0:	f7ff ffc4 	bl	c04233c <global_stdio_init.part.0>
 c0423b4:	e7f2      	b.n	c04239c <__sinit+0xc>
 c0423b6:	bf00      	nop
 c0423b8:	0c0422fd 	.word	0x0c0422fd
 c0423bc:	3003e950 	.word	0x3003e950

0c0423c0 <_fwalk_sglue>:
 c0423c0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 c0423c4:	4607      	mov	r7, r0
 c0423c6:	4688      	mov	r8, r1
 c0423c8:	4614      	mov	r4, r2
 c0423ca:	2600      	movs	r6, #0
 c0423cc:	e9d4 9501 	ldrd	r9, r5, [r4, #4]
 c0423d0:	f1b9 0901 	subs.w	r9, r9, #1
 c0423d4:	d505      	bpl.n	c0423e2 <_fwalk_sglue+0x22>
 c0423d6:	6824      	ldr	r4, [r4, #0]
 c0423d8:	2c00      	cmp	r4, #0
 c0423da:	d1f7      	bne.n	c0423cc <_fwalk_sglue+0xc>
 c0423dc:	4630      	mov	r0, r6
 c0423de:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 c0423e2:	89ab      	ldrh	r3, [r5, #12]
 c0423e4:	2b01      	cmp	r3, #1
 c0423e6:	d907      	bls.n	c0423f8 <_fwalk_sglue+0x38>
 c0423e8:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
 c0423ec:	3301      	adds	r3, #1
 c0423ee:	d003      	beq.n	c0423f8 <_fwalk_sglue+0x38>
 c0423f0:	4629      	mov	r1, r5
 c0423f2:	4638      	mov	r0, r7
 c0423f4:	47c0      	blx	r8
 c0423f6:	4306      	orrs	r6, r0
 c0423f8:	3568      	adds	r5, #104	@ 0x68
 c0423fa:	e7e9      	b.n	c0423d0 <_fwalk_sglue+0x10>

0c0423fc <iprintf>:
 c0423fc:	b40f      	push	{r0, r1, r2, r3}
 c0423fe:	b507      	push	{r0, r1, r2, lr}
 c042400:	4906      	ldr	r1, [pc, #24]	@ (c04241c <iprintf+0x20>)
 c042402:	ab04      	add	r3, sp, #16
 c042404:	6808      	ldr	r0, [r1, #0]
 c042406:	f853 2b04 	ldr.w	r2, [r3], #4
 c04240a:	6881      	ldr	r1, [r0, #8]
 c04240c:	9301      	str	r3, [sp, #4]
 c04240e:	f000 fb19 	bl	c042a44 <_vfiprintf_r>
 c042412:	b003      	add	sp, #12
 c042414:	f85d eb04 	ldr.w	lr, [sp], #4
 c042418:	b004      	add	sp, #16
 c04241a:	4770      	bx	lr
 c04241c:	30030ad4 	.word	0x30030ad4

0c042420 <sniprintf>:
 c042420:	b40c      	push	{r2, r3}
 c042422:	4b18      	ldr	r3, [pc, #96]	@ (c042484 <sniprintf+0x64>)
 c042424:	b530      	push	{r4, r5, lr}
 c042426:	1e0c      	subs	r4, r1, #0
 c042428:	b09d      	sub	sp, #116	@ 0x74
 c04242a:	681d      	ldr	r5, [r3, #0]
 c04242c:	da08      	bge.n	c042440 <sniprintf+0x20>
 c04242e:	238b      	movs	r3, #139	@ 0x8b
 c042430:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 c042434:	602b      	str	r3, [r5, #0]
 c042436:	b01d      	add	sp, #116	@ 0x74
 c042438:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
 c04243c:	b002      	add	sp, #8
 c04243e:	4770      	bx	lr
 c042440:	f44f 7302 	mov.w	r3, #520	@ 0x208
 c042444:	9002      	str	r0, [sp, #8]
 c042446:	9006      	str	r0, [sp, #24]
 c042448:	a902      	add	r1, sp, #8
 c04244a:	f8ad 3014 	strh.w	r3, [sp, #20]
 c04244e:	bf14      	ite	ne
 c042450:	f104 33ff 	addne.w	r3, r4, #4294967295	@ 0xffffffff
 c042454:	4623      	moveq	r3, r4
 c042456:	9a20      	ldr	r2, [sp, #128]	@ 0x80
 c042458:	4628      	mov	r0, r5
 c04245a:	9304      	str	r3, [sp, #16]
 c04245c:	9307      	str	r3, [sp, #28]
 c04245e:	f64f 73ff 	movw	r3, #65535	@ 0xffff
 c042462:	f8ad 3016 	strh.w	r3, [sp, #22]
 c042466:	ab21      	add	r3, sp, #132	@ 0x84
 c042468:	9301      	str	r3, [sp, #4]
 c04246a:	f000 f9c7 	bl	c0427fc <_svfiprintf_r>
 c04246e:	1c43      	adds	r3, r0, #1
 c042470:	bfbc      	itt	lt
 c042472:	238b      	movlt	r3, #139	@ 0x8b
 c042474:	602b      	strlt	r3, [r5, #0]
 c042476:	2c00      	cmp	r4, #0
 c042478:	d0dd      	beq.n	c042436 <sniprintf+0x16>
 c04247a:	9b02      	ldr	r3, [sp, #8]
 c04247c:	2200      	movs	r2, #0
 c04247e:	701a      	strb	r2, [r3, #0]
 c042480:	e7d9      	b.n	c042436 <sniprintf+0x16>
 c042482:	bf00      	nop
 c042484:	30030ad4 	.word	0x30030ad4

0c042488 <__sread>:
 c042488:	b510      	push	{r4, lr}
 c04248a:	460c      	mov	r4, r1
 c04248c:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 c042490:	f000 f8aa 	bl	c0425e8 <_read_r>
 c042494:	2800      	cmp	r0, #0
 c042496:	bfab      	itete	ge
 c042498:	6d63      	ldrge	r3, [r4, #84]	@ 0x54
 c04249a:	89a3      	ldrhlt	r3, [r4, #12]
 c04249c:	181b      	addge	r3, r3, r0
 c04249e:	f423 5380 	biclt.w	r3, r3, #4096	@ 0x1000
 c0424a2:	bfac      	ite	ge
 c0424a4:	6563      	strge	r3, [r4, #84]	@ 0x54
 c0424a6:	81a3      	strhlt	r3, [r4, #12]
 c0424a8:	bd10      	pop	{r4, pc}

0c0424aa <__swrite>:
 c0424aa:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 c0424ae:	461f      	mov	r7, r3
 c0424b0:	898b      	ldrh	r3, [r1, #12]
 c0424b2:	4605      	mov	r5, r0
 c0424b4:	460c      	mov	r4, r1
 c0424b6:	05db      	lsls	r3, r3, #23
 c0424b8:	4616      	mov	r6, r2
 c0424ba:	d505      	bpl.n	c0424c8 <__swrite+0x1e>
 c0424bc:	2302      	movs	r3, #2
 c0424be:	2200      	movs	r2, #0
 c0424c0:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 c0424c4:	f000 f87e 	bl	c0425c4 <_lseek_r>
 c0424c8:	89a3      	ldrh	r3, [r4, #12]
 c0424ca:	4632      	mov	r2, r6
 c0424cc:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 c0424d0:	4628      	mov	r0, r5
 c0424d2:	f423 5380 	bic.w	r3, r3, #4096	@ 0x1000
 c0424d6:	81a3      	strh	r3, [r4, #12]
 c0424d8:	463b      	mov	r3, r7
 c0424da:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 c0424de:	f000 b8a5 	b.w	c04262c <_write_r>

0c0424e2 <__sseek>:
 c0424e2:	b510      	push	{r4, lr}
 c0424e4:	460c      	mov	r4, r1
 c0424e6:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 c0424ea:	f000 f86b 	bl	c0425c4 <_lseek_r>
 c0424ee:	1c43      	adds	r3, r0, #1
 c0424f0:	89a3      	ldrh	r3, [r4, #12]
 c0424f2:	bf15      	itete	ne
 c0424f4:	6560      	strne	r0, [r4, #84]	@ 0x54
 c0424f6:	f423 5380 	biceq.w	r3, r3, #4096	@ 0x1000
 c0424fa:	f443 5380 	orrne.w	r3, r3, #4096	@ 0x1000
 c0424fe:	81a3      	strheq	r3, [r4, #12]
 c042500:	bf18      	it	ne
 c042502:	81a3      	strhne	r3, [r4, #12]
 c042504:	bd10      	pop	{r4, pc}

0c042506 <__sclose>:
 c042506:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 c04250a:	f000 b84b 	b.w	c0425a4 <_close_r>

0c04250e <_vsniprintf_r>:
 c04250e:	b530      	push	{r4, r5, lr}
 c042510:	4614      	mov	r4, r2
 c042512:	b09b      	sub	sp, #108	@ 0x6c
 c042514:	4605      	mov	r5, r0
 c042516:	461a      	mov	r2, r3
 c042518:	2c00      	cmp	r4, #0
 c04251a:	da05      	bge.n	c042528 <_vsniprintf_r+0x1a>
 c04251c:	238b      	movs	r3, #139	@ 0x8b
 c04251e:	6003      	str	r3, [r0, #0]
 c042520:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 c042524:	b01b      	add	sp, #108	@ 0x6c
 c042526:	bd30      	pop	{r4, r5, pc}
 c042528:	f44f 7302 	mov.w	r3, #520	@ 0x208
 c04252c:	9100      	str	r1, [sp, #0]
 c04252e:	9104      	str	r1, [sp, #16]
 c042530:	4669      	mov	r1, sp
 c042532:	f8ad 300c 	strh.w	r3, [sp, #12]
 c042536:	bf14      	ite	ne
 c042538:	f104 33ff 	addne.w	r3, r4, #4294967295	@ 0xffffffff
 c04253c:	4623      	moveq	r3, r4
 c04253e:	9302      	str	r3, [sp, #8]
 c042540:	9305      	str	r3, [sp, #20]
 c042542:	f64f 73ff 	movw	r3, #65535	@ 0xffff
 c042546:	f8ad 300e 	strh.w	r3, [sp, #14]
 c04254a:	9b1e      	ldr	r3, [sp, #120]	@ 0x78
 c04254c:	f000 f956 	bl	c0427fc <_svfiprintf_r>
 c042550:	1c43      	adds	r3, r0, #1
 c042552:	bfbc      	itt	lt
 c042554:	238b      	movlt	r3, #139	@ 0x8b
 c042556:	602b      	strlt	r3, [r5, #0]
 c042558:	2c00      	cmp	r4, #0
 c04255a:	d0e3      	beq.n	c042524 <_vsniprintf_r+0x16>
 c04255c:	9b00      	ldr	r3, [sp, #0]
 c04255e:	2200      	movs	r2, #0
 c042560:	701a      	strb	r2, [r3, #0]
 c042562:	e7df      	b.n	c042524 <_vsniprintf_r+0x16>

0c042564 <vsniprintf>:
 c042564:	b507      	push	{r0, r1, r2, lr}
 c042566:	9300      	str	r3, [sp, #0]
 c042568:	4613      	mov	r3, r2
 c04256a:	460a      	mov	r2, r1
 c04256c:	4601      	mov	r1, r0
 c04256e:	4803      	ldr	r0, [pc, #12]	@ (c04257c <vsniprintf+0x18>)
 c042570:	6800      	ldr	r0, [r0, #0]
 c042572:	f7ff ffcc 	bl	c04250e <_vsniprintf_r>
 c042576:	b003      	add	sp, #12
 c042578:	f85d fb04 	ldr.w	pc, [sp], #4
 c04257c:	30030ad4 	.word	0x30030ad4

0c042580 <strncmp>:
 c042580:	b510      	push	{r4, lr}
 c042582:	b16a      	cbz	r2, c0425a0 <strncmp+0x20>
 c042584:	3901      	subs	r1, #1
 c042586:	1884      	adds	r4, r0, r2
 c042588:	f810 2b01 	ldrb.w	r2, [r0], #1
 c04258c:	f811 3f01 	ldrb.w	r3, [r1, #1]!
 c042590:	429a      	cmp	r2, r3
 c042592:	d103      	bne.n	c04259c <strncmp+0x1c>
 c042594:	42a0      	cmp	r0, r4
 c042596:	d001      	beq.n	c04259c <strncmp+0x1c>
 c042598:	2a00      	cmp	r2, #0
 c04259a:	d1f5      	bne.n	c042588 <strncmp+0x8>
 c04259c:	1ad0      	subs	r0, r2, r3
 c04259e:	bd10      	pop	{r4, pc}
 c0425a0:	4610      	mov	r0, r2
 c0425a2:	e7fc      	b.n	c04259e <strncmp+0x1e>

0c0425a4 <_close_r>:
 c0425a4:	b538      	push	{r3, r4, r5, lr}
 c0425a6:	2300      	movs	r3, #0
 c0425a8:	4d05      	ldr	r5, [pc, #20]	@ (c0425c0 <_close_r+0x1c>)
 c0425aa:	4604      	mov	r4, r0
 c0425ac:	4608      	mov	r0, r1
 c0425ae:	602b      	str	r3, [r5, #0]
 c0425b0:	f01c f8e2 	bl	c05e778 <_close>
 c0425b4:	1c43      	adds	r3, r0, #1
 c0425b6:	d102      	bne.n	c0425be <_close_r+0x1a>
 c0425b8:	682b      	ldr	r3, [r5, #0]
 c0425ba:	b103      	cbz	r3, c0425be <_close_r+0x1a>
 c0425bc:	6023      	str	r3, [r4, #0]
 c0425be:	bd38      	pop	{r3, r4, r5, pc}
 c0425c0:	3003e954 	.word	0x3003e954

0c0425c4 <_lseek_r>:
 c0425c4:	b538      	push	{r3, r4, r5, lr}
 c0425c6:	4604      	mov	r4, r0
 c0425c8:	4d06      	ldr	r5, [pc, #24]	@ (c0425e4 <_lseek_r+0x20>)
 c0425ca:	4608      	mov	r0, r1
 c0425cc:	4611      	mov	r1, r2
 c0425ce:	2200      	movs	r2, #0
 c0425d0:	602a      	str	r2, [r5, #0]
 c0425d2:	461a      	mov	r2, r3
 c0425d4:	f01c f8e8 	bl	c05e7a8 <_lseek>
 c0425d8:	1c43      	adds	r3, r0, #1
 c0425da:	d102      	bne.n	c0425e2 <_lseek_r+0x1e>
 c0425dc:	682b      	ldr	r3, [r5, #0]
 c0425de:	b103      	cbz	r3, c0425e2 <_lseek_r+0x1e>
 c0425e0:	6023      	str	r3, [r4, #0]
 c0425e2:	bd38      	pop	{r3, r4, r5, pc}
 c0425e4:	3003e954 	.word	0x3003e954

0c0425e8 <_read_r>:
 c0425e8:	b538      	push	{r3, r4, r5, lr}
 c0425ea:	4604      	mov	r4, r0
 c0425ec:	4d06      	ldr	r5, [pc, #24]	@ (c042608 <_read_r+0x20>)
 c0425ee:	4608      	mov	r0, r1
 c0425f0:	4611      	mov	r1, r2
 c0425f2:	2200      	movs	r2, #0
 c0425f4:	602a      	str	r2, [r5, #0]
 c0425f6:	461a      	mov	r2, r3
 c0425f8:	f01c f8de 	bl	c05e7b8 <_read>
 c0425fc:	1c43      	adds	r3, r0, #1
 c0425fe:	d102      	bne.n	c042606 <_read_r+0x1e>
 c042600:	682b      	ldr	r3, [r5, #0]
 c042602:	b103      	cbz	r3, c042606 <_read_r+0x1e>
 c042604:	6023      	str	r3, [r4, #0]
 c042606:	bd38      	pop	{r3, r4, r5, pc}
 c042608:	3003e954 	.word	0x3003e954

0c04260c <_sbrk_r>:
 c04260c:	b538      	push	{r3, r4, r5, lr}
 c04260e:	2300      	movs	r3, #0
 c042610:	4d05      	ldr	r5, [pc, #20]	@ (c042628 <_sbrk_r+0x1c>)
 c042612:	4604      	mov	r4, r0
 c042614:	4608      	mov	r0, r1
 c042616:	602b      	str	r3, [r5, #0]
 c042618:	f01c f8d6 	bl	c05e7c8 <_sbrk>
 c04261c:	1c43      	adds	r3, r0, #1
 c04261e:	d102      	bne.n	c042626 <_sbrk_r+0x1a>
 c042620:	682b      	ldr	r3, [r5, #0]
 c042622:	b103      	cbz	r3, c042626 <_sbrk_r+0x1a>
 c042624:	6023      	str	r3, [r4, #0]
 c042626:	bd38      	pop	{r3, r4, r5, pc}
 c042628:	3003e954 	.word	0x3003e954

0c04262c <_write_r>:
 c04262c:	b538      	push	{r3, r4, r5, lr}
 c04262e:	4604      	mov	r4, r0
 c042630:	4d06      	ldr	r5, [pc, #24]	@ (c04264c <_write_r+0x20>)
 c042632:	4608      	mov	r0, r1
 c042634:	4611      	mov	r1, r2
 c042636:	2200      	movs	r2, #0
 c042638:	602a      	str	r2, [r5, #0]
 c04263a:	461a      	mov	r2, r3
 c04263c:	f01c f83a 	bl	c05e6b4 <_write>
 c042640:	1c43      	adds	r3, r0, #1
 c042642:	d102      	bne.n	c04264a <_write_r+0x1e>
 c042644:	682b      	ldr	r3, [r5, #0]
 c042646:	b103      	cbz	r3, c04264a <_write_r+0x1e>
 c042648:	6023      	str	r3, [r4, #0]
 c04264a:	bd38      	pop	{r3, r4, r5, pc}
 c04264c:	3003e954 	.word	0x3003e954

0c042650 <__libc_init_array>:
 c042650:	b570      	push	{r4, r5, r6, lr}
 c042652:	4d0d      	ldr	r5, [pc, #52]	@ (c042688 <__libc_init_array+0x38>)
 c042654:	2600      	movs	r6, #0
 c042656:	4c0d      	ldr	r4, [pc, #52]	@ (c04268c <__libc_init_array+0x3c>)
 c042658:	1b64      	subs	r4, r4, r5
 c04265a:	10a4      	asrs	r4, r4, #2
 c04265c:	42a6      	cmp	r6, r4
 c04265e:	d109      	bne.n	c042674 <__libc_init_array+0x24>
 c042660:	4d0b      	ldr	r5, [pc, #44]	@ (c042690 <__libc_init_array+0x40>)
 c042662:	2600      	movs	r6, #0
 c042664:	4c0b      	ldr	r4, [pc, #44]	@ (c042694 <__libc_init_array+0x44>)
 c042666:	f01c f8bf 	bl	c05e7e8 <_init>
 c04266a:	1b64      	subs	r4, r4, r5
 c04266c:	10a4      	asrs	r4, r4, #2
 c04266e:	42a6      	cmp	r6, r4
 c042670:	d105      	bne.n	c04267e <__libc_init_array+0x2e>
 c042672:	bd70      	pop	{r4, r5, r6, pc}
 c042674:	f855 3b04 	ldr.w	r3, [r5], #4
 c042678:	3601      	adds	r6, #1
 c04267a:	4798      	blx	r3
 c04267c:	e7ee      	b.n	c04265c <__libc_init_array+0xc>
 c04267e:	f855 3b04 	ldr.w	r3, [r5], #4
 c042682:	3601      	adds	r6, #1
 c042684:	4798      	blx	r3
 c042686:	e7f2      	b.n	c04266e <__libc_init_array+0x1e>
 c042688:	30030b24 	.word	0x30030b24
 c04268c:	30030b24 	.word	0x30030b24
 c042690:	30030b24 	.word	0x30030b24
 c042694:	30030b28 	.word	0x30030b28

0c042698 <__retarget_lock_init_recursive>:
 c042698:	4770      	bx	lr

0c04269a <__retarget_lock_acquire_recursive>:
 c04269a:	4770      	bx	lr

0c04269c <__retarget_lock_release_recursive>:
 c04269c:	4770      	bx	lr

0c04269e <strlen>:
 c04269e:	4603      	mov	r3, r0
 c0426a0:	f813 2b01 	ldrb.w	r2, [r3], #1
 c0426a4:	2a00      	cmp	r2, #0
 c0426a6:	d1fb      	bne.n	c0426a0 <strlen+0x2>
 c0426a8:	1a18      	subs	r0, r3, r0
 c0426aa:	3801      	subs	r0, #1
 c0426ac:	4770      	bx	lr
	...

0c0426b0 <_free_r>:
 c0426b0:	b538      	push	{r3, r4, r5, lr}
 c0426b2:	4605      	mov	r5, r0
 c0426b4:	2900      	cmp	r1, #0
 c0426b6:	d041      	beq.n	c04273c <_free_r+0x8c>
 c0426b8:	f851 3c04 	ldr.w	r3, [r1, #-4]
 c0426bc:	1f0c      	subs	r4, r1, #4
 c0426be:	2b00      	cmp	r3, #0
 c0426c0:	bfb8      	it	lt
 c0426c2:	18e4      	addlt	r4, r4, r3
 c0426c4:	f7ff fdcc 	bl	c042260 <__malloc_lock>
 c0426c8:	4a1d      	ldr	r2, [pc, #116]	@ (c042740 <_free_r+0x90>)
 c0426ca:	6813      	ldr	r3, [r2, #0]
 c0426cc:	b933      	cbnz	r3, c0426dc <_free_r+0x2c>
 c0426ce:	6063      	str	r3, [r4, #4]
 c0426d0:	6014      	str	r4, [r2, #0]
 c0426d2:	4628      	mov	r0, r5
 c0426d4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 c0426d8:	f7ff bdc8 	b.w	c04226c <__malloc_unlock>
 c0426dc:	42a3      	cmp	r3, r4
 c0426de:	d908      	bls.n	c0426f2 <_free_r+0x42>
 c0426e0:	6820      	ldr	r0, [r4, #0]
 c0426e2:	1821      	adds	r1, r4, r0
 c0426e4:	428b      	cmp	r3, r1
 c0426e6:	bf01      	itttt	eq
 c0426e8:	6819      	ldreq	r1, [r3, #0]
 c0426ea:	685b      	ldreq	r3, [r3, #4]
 c0426ec:	1809      	addeq	r1, r1, r0
 c0426ee:	6021      	streq	r1, [r4, #0]
 c0426f0:	e7ed      	b.n	c0426ce <_free_r+0x1e>
 c0426f2:	461a      	mov	r2, r3
 c0426f4:	685b      	ldr	r3, [r3, #4]
 c0426f6:	b10b      	cbz	r3, c0426fc <_free_r+0x4c>
 c0426f8:	42a3      	cmp	r3, r4
 c0426fa:	d9fa      	bls.n	c0426f2 <_free_r+0x42>
 c0426fc:	6811      	ldr	r1, [r2, #0]
 c0426fe:	1850      	adds	r0, r2, r1
 c042700:	42a0      	cmp	r0, r4
 c042702:	d10b      	bne.n	c04271c <_free_r+0x6c>
 c042704:	6820      	ldr	r0, [r4, #0]
 c042706:	4401      	add	r1, r0
 c042708:	1850      	adds	r0, r2, r1
 c04270a:	6011      	str	r1, [r2, #0]
 c04270c:	4283      	cmp	r3, r0
 c04270e:	d1e0      	bne.n	c0426d2 <_free_r+0x22>
 c042710:	6818      	ldr	r0, [r3, #0]
 c042712:	685b      	ldr	r3, [r3, #4]
 c042714:	4408      	add	r0, r1
 c042716:	6053      	str	r3, [r2, #4]
 c042718:	6010      	str	r0, [r2, #0]
 c04271a:	e7da      	b.n	c0426d2 <_free_r+0x22>
 c04271c:	d902      	bls.n	c042724 <_free_r+0x74>
 c04271e:	230c      	movs	r3, #12
 c042720:	602b      	str	r3, [r5, #0]
 c042722:	e7d6      	b.n	c0426d2 <_free_r+0x22>
 c042724:	6820      	ldr	r0, [r4, #0]
 c042726:	1821      	adds	r1, r4, r0
 c042728:	428b      	cmp	r3, r1
 c04272a:	bf02      	ittt	eq
 c04272c:	6819      	ldreq	r1, [r3, #0]
 c04272e:	685b      	ldreq	r3, [r3, #4]
 c042730:	1809      	addeq	r1, r1, r0
 c042732:	6063      	str	r3, [r4, #4]
 c042734:	bf08      	it	eq
 c042736:	6021      	streq	r1, [r4, #0]
 c042738:	6054      	str	r4, [r2, #4]
 c04273a:	e7ca      	b.n	c0426d2 <_free_r+0x22>
 c04273c:	bd38      	pop	{r3, r4, r5, pc}
 c04273e:	bf00      	nop
 c042740:	3003e814 	.word	0x3003e814

0c042744 <__ssputs_r>:
 c042744:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 c042748:	461f      	mov	r7, r3
 c04274a:	688e      	ldr	r6, [r1, #8]
 c04274c:	4682      	mov	sl, r0
 c04274e:	460c      	mov	r4, r1
 c042750:	42be      	cmp	r6, r7
 c042752:	4690      	mov	r8, r2
 c042754:	680b      	ldr	r3, [r1, #0]
 c042756:	d82d      	bhi.n	c0427b4 <__ssputs_r+0x70>
 c042758:	f9b1 200c 	ldrsh.w	r2, [r1, #12]
 c04275c:	f412 6f90 	tst.w	r2, #1152	@ 0x480
 c042760:	d026      	beq.n	c0427b0 <__ssputs_r+0x6c>
 c042762:	6965      	ldr	r5, [r4, #20]
 c042764:	6909      	ldr	r1, [r1, #16]
 c042766:	eb05 0545 	add.w	r5, r5, r5, lsl #1
 c04276a:	eba3 0901 	sub.w	r9, r3, r1
 c04276e:	1c7b      	adds	r3, r7, #1
 c042770:	eb05 75d5 	add.w	r5, r5, r5, lsr #31
 c042774:	444b      	add	r3, r9
 c042776:	106d      	asrs	r5, r5, #1
 c042778:	429d      	cmp	r5, r3
 c04277a:	bf38      	it	cc
 c04277c:	461d      	movcc	r5, r3
 c04277e:	0553      	lsls	r3, r2, #21
 c042780:	d527      	bpl.n	c0427d2 <__ssputs_r+0x8e>
 c042782:	4629      	mov	r1, r5
 c042784:	f7ff fcec 	bl	c042160 <_malloc_r>
 c042788:	4606      	mov	r6, r0
 c04278a:	b360      	cbz	r0, c0427e6 <__ssputs_r+0xa2>
 c04278c:	464a      	mov	r2, r9
 c04278e:	6921      	ldr	r1, [r4, #16]
 c042790:	f018 ff5c 	bl	c05b64c <memcpy>
 c042794:	89a3      	ldrh	r3, [r4, #12]
 c042796:	f423 6390 	bic.w	r3, r3, #1152	@ 0x480
 c04279a:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 c04279e:	81a3      	strh	r3, [r4, #12]
 c0427a0:	6126      	str	r6, [r4, #16]
 c0427a2:	444e      	add	r6, r9
 c0427a4:	6165      	str	r5, [r4, #20]
 c0427a6:	eba5 0509 	sub.w	r5, r5, r9
 c0427aa:	6026      	str	r6, [r4, #0]
 c0427ac:	463e      	mov	r6, r7
 c0427ae:	60a5      	str	r5, [r4, #8]
 c0427b0:	42be      	cmp	r6, r7
 c0427b2:	d900      	bls.n	c0427b6 <__ssputs_r+0x72>
 c0427b4:	463e      	mov	r6, r7
 c0427b6:	4632      	mov	r2, r6
 c0427b8:	4641      	mov	r1, r8
 c0427ba:	6820      	ldr	r0, [r4, #0]
 c0427bc:	f018 ff77 	bl	c05b6ae <memmove>
 c0427c0:	68a3      	ldr	r3, [r4, #8]
 c0427c2:	2000      	movs	r0, #0
 c0427c4:	1b9b      	subs	r3, r3, r6
 c0427c6:	60a3      	str	r3, [r4, #8]
 c0427c8:	6823      	ldr	r3, [r4, #0]
 c0427ca:	4433      	add	r3, r6
 c0427cc:	6023      	str	r3, [r4, #0]
 c0427ce:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 c0427d2:	462a      	mov	r2, r5
 c0427d4:	f000 fd2a 	bl	c04322c <_realloc_r>
 c0427d8:	4606      	mov	r6, r0
 c0427da:	2800      	cmp	r0, #0
 c0427dc:	d1e0      	bne.n	c0427a0 <__ssputs_r+0x5c>
 c0427de:	6921      	ldr	r1, [r4, #16]
 c0427e0:	4650      	mov	r0, sl
 c0427e2:	f7ff ff65 	bl	c0426b0 <_free_r>
 c0427e6:	230c      	movs	r3, #12
 c0427e8:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 c0427ec:	f8ca 3000 	str.w	r3, [sl]
 c0427f0:	89a3      	ldrh	r3, [r4, #12]
 c0427f2:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 c0427f6:	81a3      	strh	r3, [r4, #12]
 c0427f8:	e7e9      	b.n	c0427ce <__ssputs_r+0x8a>
	...

0c0427fc <_svfiprintf_r>:
 c0427fc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c042800:	4698      	mov	r8, r3
 c042802:	898b      	ldrh	r3, [r1, #12]
 c042804:	b09d      	sub	sp, #116	@ 0x74
 c042806:	4607      	mov	r7, r0
 c042808:	061b      	lsls	r3, r3, #24
 c04280a:	460d      	mov	r5, r1
 c04280c:	4614      	mov	r4, r2
 c04280e:	d510      	bpl.n	c042832 <_svfiprintf_r+0x36>
 c042810:	690b      	ldr	r3, [r1, #16]
 c042812:	b973      	cbnz	r3, c042832 <_svfiprintf_r+0x36>
 c042814:	2140      	movs	r1, #64	@ 0x40
 c042816:	f7ff fca3 	bl	c042160 <_malloc_r>
 c04281a:	6028      	str	r0, [r5, #0]
 c04281c:	6128      	str	r0, [r5, #16]
 c04281e:	b930      	cbnz	r0, c04282e <_svfiprintf_r+0x32>
 c042820:	230c      	movs	r3, #12
 c042822:	603b      	str	r3, [r7, #0]
 c042824:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 c042828:	b01d      	add	sp, #116	@ 0x74
 c04282a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 c04282e:	2340      	movs	r3, #64	@ 0x40
 c042830:	616b      	str	r3, [r5, #20]
 c042832:	2300      	movs	r3, #0
 c042834:	f8cd 800c 	str.w	r8, [sp, #12]
 c042838:	f04f 0901 	mov.w	r9, #1
 c04283c:	f8df 81a0 	ldr.w	r8, [pc, #416]	@ c0429e0 <_svfiprintf_r+0x1e4>
 c042840:	9309      	str	r3, [sp, #36]	@ 0x24
 c042842:	2320      	movs	r3, #32
 c042844:	f88d 3029 	strb.w	r3, [sp, #41]	@ 0x29
 c042848:	2330      	movs	r3, #48	@ 0x30
 c04284a:	f88d 302a 	strb.w	r3, [sp, #42]	@ 0x2a
 c04284e:	4623      	mov	r3, r4
 c042850:	469a      	mov	sl, r3
 c042852:	f813 2b01 	ldrb.w	r2, [r3], #1
 c042856:	b10a      	cbz	r2, c04285c <_svfiprintf_r+0x60>
 c042858:	2a25      	cmp	r2, #37	@ 0x25
 c04285a:	d1f9      	bne.n	c042850 <_svfiprintf_r+0x54>
 c04285c:	ebba 0b04 	subs.w	fp, sl, r4
 c042860:	d00b      	beq.n	c04287a <_svfiprintf_r+0x7e>
 c042862:	465b      	mov	r3, fp
 c042864:	4622      	mov	r2, r4
 c042866:	4629      	mov	r1, r5
 c042868:	4638      	mov	r0, r7
 c04286a:	f7ff ff6b 	bl	c042744 <__ssputs_r>
 c04286e:	3001      	adds	r0, #1
 c042870:	f000 80a7 	beq.w	c0429c2 <_svfiprintf_r+0x1c6>
 c042874:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 c042876:	445a      	add	r2, fp
 c042878:	9209      	str	r2, [sp, #36]	@ 0x24
 c04287a:	f89a 3000 	ldrb.w	r3, [sl]
 c04287e:	2b00      	cmp	r3, #0
 c042880:	f000 809f 	beq.w	c0429c2 <_svfiprintf_r+0x1c6>
 c042884:	2300      	movs	r3, #0
 c042886:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 c04288a:	f10a 0a01 	add.w	sl, sl, #1
 c04288e:	9304      	str	r3, [sp, #16]
 c042890:	9307      	str	r3, [sp, #28]
 c042892:	f88d 3053 	strb.w	r3, [sp, #83]	@ 0x53
 c042896:	931a      	str	r3, [sp, #104]	@ 0x68
 c042898:	e9cd 2305 	strd	r2, r3, [sp, #20]
 c04289c:	4654      	mov	r4, sl
 c04289e:	2205      	movs	r2, #5
 c0428a0:	484f      	ldr	r0, [pc, #316]	@ (c0429e0 <_svfiprintf_r+0x1e4>)
 c0428a2:	f814 1b01 	ldrb.w	r1, [r4], #1
 c0428a6:	f000 fcb3 	bl	c043210 <memchr>
 c0428aa:	9a04      	ldr	r2, [sp, #16]
 c0428ac:	b9d8      	cbnz	r0, c0428e6 <_svfiprintf_r+0xea>
 c0428ae:	06d0      	lsls	r0, r2, #27
 c0428b0:	bf44      	itt	mi
 c0428b2:	2320      	movmi	r3, #32
 c0428b4:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
 c0428b8:	0711      	lsls	r1, r2, #28
 c0428ba:	bf44      	itt	mi
 c0428bc:	232b      	movmi	r3, #43	@ 0x2b
 c0428be:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
 c0428c2:	f89a 3000 	ldrb.w	r3, [sl]
 c0428c6:	2b2a      	cmp	r3, #42	@ 0x2a
 c0428c8:	d015      	beq.n	c0428f6 <_svfiprintf_r+0xfa>
 c0428ca:	9a07      	ldr	r2, [sp, #28]
 c0428cc:	4654      	mov	r4, sl
 c0428ce:	2000      	movs	r0, #0
 c0428d0:	f04f 0c0a 	mov.w	ip, #10
 c0428d4:	4621      	mov	r1, r4
 c0428d6:	f811 3b01 	ldrb.w	r3, [r1], #1
 c0428da:	3b30      	subs	r3, #48	@ 0x30
 c0428dc:	2b09      	cmp	r3, #9
 c0428de:	d94b      	bls.n	c042978 <_svfiprintf_r+0x17c>
 c0428e0:	b1b0      	cbz	r0, c042910 <_svfiprintf_r+0x114>
 c0428e2:	9207      	str	r2, [sp, #28]
 c0428e4:	e014      	b.n	c042910 <_svfiprintf_r+0x114>
 c0428e6:	eba0 0308 	sub.w	r3, r0, r8
 c0428ea:	46a2      	mov	sl, r4
 c0428ec:	fa09 f303 	lsl.w	r3, r9, r3
 c0428f0:	4313      	orrs	r3, r2
 c0428f2:	9304      	str	r3, [sp, #16]
 c0428f4:	e7d2      	b.n	c04289c <_svfiprintf_r+0xa0>
 c0428f6:	9b03      	ldr	r3, [sp, #12]
 c0428f8:	1d19      	adds	r1, r3, #4
 c0428fa:	681b      	ldr	r3, [r3, #0]
 c0428fc:	2b00      	cmp	r3, #0
 c0428fe:	9103      	str	r1, [sp, #12]
 c042900:	bfbb      	ittet	lt
 c042902:	425b      	neglt	r3, r3
 c042904:	f042 0202 	orrlt.w	r2, r2, #2
 c042908:	9307      	strge	r3, [sp, #28]
 c04290a:	9307      	strlt	r3, [sp, #28]
 c04290c:	bfb8      	it	lt
 c04290e:	9204      	strlt	r2, [sp, #16]
 c042910:	7823      	ldrb	r3, [r4, #0]
 c042912:	2b2e      	cmp	r3, #46	@ 0x2e
 c042914:	d10a      	bne.n	c04292c <_svfiprintf_r+0x130>
 c042916:	7863      	ldrb	r3, [r4, #1]
 c042918:	2b2a      	cmp	r3, #42	@ 0x2a
 c04291a:	d132      	bne.n	c042982 <_svfiprintf_r+0x186>
 c04291c:	9b03      	ldr	r3, [sp, #12]
 c04291e:	3402      	adds	r4, #2
 c042920:	1d1a      	adds	r2, r3, #4
 c042922:	681b      	ldr	r3, [r3, #0]
 c042924:	ea43 73e3 	orr.w	r3, r3, r3, asr #31
 c042928:	9203      	str	r2, [sp, #12]
 c04292a:	9305      	str	r3, [sp, #20]
 c04292c:	f8df a0b4 	ldr.w	sl, [pc, #180]	@ c0429e4 <_svfiprintf_r+0x1e8>
 c042930:	2203      	movs	r2, #3
 c042932:	7821      	ldrb	r1, [r4, #0]
 c042934:	4650      	mov	r0, sl
 c042936:	f000 fc6b 	bl	c043210 <memchr>
 c04293a:	b138      	cbz	r0, c04294c <_svfiprintf_r+0x150>
 c04293c:	eba0 000a 	sub.w	r0, r0, sl
 c042940:	2240      	movs	r2, #64	@ 0x40
 c042942:	9b04      	ldr	r3, [sp, #16]
 c042944:	3401      	adds	r4, #1
 c042946:	4082      	lsls	r2, r0
 c042948:	4313      	orrs	r3, r2
 c04294a:	9304      	str	r3, [sp, #16]
 c04294c:	f814 1b01 	ldrb.w	r1, [r4], #1
 c042950:	2206      	movs	r2, #6
 c042952:	4825      	ldr	r0, [pc, #148]	@ (c0429e8 <_svfiprintf_r+0x1ec>)
 c042954:	f88d 1028 	strb.w	r1, [sp, #40]	@ 0x28
 c042958:	f000 fc5a 	bl	c043210 <memchr>
 c04295c:	2800      	cmp	r0, #0
 c04295e:	d036      	beq.n	c0429ce <_svfiprintf_r+0x1d2>
 c042960:	4b22      	ldr	r3, [pc, #136]	@ (c0429ec <_svfiprintf_r+0x1f0>)
 c042962:	bb1b      	cbnz	r3, c0429ac <_svfiprintf_r+0x1b0>
 c042964:	9b03      	ldr	r3, [sp, #12]
 c042966:	3307      	adds	r3, #7
 c042968:	f023 0307 	bic.w	r3, r3, #7
 c04296c:	3308      	adds	r3, #8
 c04296e:	9303      	str	r3, [sp, #12]
 c042970:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 c042972:	4433      	add	r3, r6
 c042974:	9309      	str	r3, [sp, #36]	@ 0x24
 c042976:	e76a      	b.n	c04284e <_svfiprintf_r+0x52>
 c042978:	fb0c 3202 	mla	r2, ip, r2, r3
 c04297c:	460c      	mov	r4, r1
 c04297e:	2001      	movs	r0, #1
 c042980:	e7a8      	b.n	c0428d4 <_svfiprintf_r+0xd8>
 c042982:	2300      	movs	r3, #0
 c042984:	3401      	adds	r4, #1
 c042986:	f04f 0c0a 	mov.w	ip, #10
 c04298a:	4619      	mov	r1, r3
 c04298c:	9305      	str	r3, [sp, #20]
 c04298e:	4620      	mov	r0, r4
 c042990:	f810 2b01 	ldrb.w	r2, [r0], #1
 c042994:	3a30      	subs	r2, #48	@ 0x30
 c042996:	2a09      	cmp	r2, #9
 c042998:	d903      	bls.n	c0429a2 <_svfiprintf_r+0x1a6>
 c04299a:	2b00      	cmp	r3, #0
 c04299c:	d0c6      	beq.n	c04292c <_svfiprintf_r+0x130>
 c04299e:	9105      	str	r1, [sp, #20]
 c0429a0:	e7c4      	b.n	c04292c <_svfiprintf_r+0x130>
 c0429a2:	fb0c 2101 	mla	r1, ip, r1, r2
 c0429a6:	4604      	mov	r4, r0
 c0429a8:	2301      	movs	r3, #1
 c0429aa:	e7f0      	b.n	c04298e <_svfiprintf_r+0x192>
 c0429ac:	ab03      	add	r3, sp, #12
 c0429ae:	462a      	mov	r2, r5
 c0429b0:	a904      	add	r1, sp, #16
 c0429b2:	4638      	mov	r0, r7
 c0429b4:	9300      	str	r3, [sp, #0]
 c0429b6:	4b0e      	ldr	r3, [pc, #56]	@ (c0429f0 <_svfiprintf_r+0x1f4>)
 c0429b8:	f3af 8000 	nop.w
 c0429bc:	1c42      	adds	r2, r0, #1
 c0429be:	4606      	mov	r6, r0
 c0429c0:	d1d6      	bne.n	c042970 <_svfiprintf_r+0x174>
 c0429c2:	89ab      	ldrh	r3, [r5, #12]
 c0429c4:	065b      	lsls	r3, r3, #25
 c0429c6:	f53f af2d 	bmi.w	c042824 <_svfiprintf_r+0x28>
 c0429ca:	9809      	ldr	r0, [sp, #36]	@ 0x24
 c0429cc:	e72c      	b.n	c042828 <_svfiprintf_r+0x2c>
 c0429ce:	ab03      	add	r3, sp, #12
 c0429d0:	462a      	mov	r2, r5
 c0429d2:	a904      	add	r1, sp, #16
 c0429d4:	4638      	mov	r0, r7
 c0429d6:	9300      	str	r3, [sp, #0]
 c0429d8:	4b05      	ldr	r3, [pc, #20]	@ (c0429f0 <_svfiprintf_r+0x1f4>)
 c0429da:	f000 f9bd 	bl	c042d58 <_printf_i>
 c0429de:	e7ed      	b.n	c0429bc <_svfiprintf_r+0x1c0>
 c0429e0:	0c0433a0 	.word	0x0c0433a0
 c0429e4:	0c0433a6 	.word	0x0c0433a6
 c0429e8:	0c0433aa 	.word	0x0c0433aa
 c0429ec:	00000000 	.word	0x00000000
 c0429f0:	0c042745 	.word	0x0c042745

0c0429f4 <__sfputc_r>:
 c0429f4:	6893      	ldr	r3, [r2, #8]
 c0429f6:	3b01      	subs	r3, #1
 c0429f8:	2b00      	cmp	r3, #0
 c0429fa:	6093      	str	r3, [r2, #8]
 c0429fc:	b410      	push	{r4}
 c0429fe:	da07      	bge.n	c042a10 <__sfputc_r+0x1c>
 c042a00:	6994      	ldr	r4, [r2, #24]
 c042a02:	42a3      	cmp	r3, r4
 c042a04:	db01      	blt.n	c042a0a <__sfputc_r+0x16>
 c042a06:	290a      	cmp	r1, #10
 c042a08:	d102      	bne.n	c042a10 <__sfputc_r+0x1c>
 c042a0a:	bc10      	pop	{r4}
 c042a0c:	f000 bb6c 	b.w	c0430e8 <__swbuf_r>
 c042a10:	6813      	ldr	r3, [r2, #0]
 c042a12:	1c58      	adds	r0, r3, #1
 c042a14:	6010      	str	r0, [r2, #0]
 c042a16:	4608      	mov	r0, r1
 c042a18:	7019      	strb	r1, [r3, #0]
 c042a1a:	bc10      	pop	{r4}
 c042a1c:	4770      	bx	lr

0c042a1e <__sfputs_r>:
 c042a1e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 c042a20:	4606      	mov	r6, r0
 c042a22:	460f      	mov	r7, r1
 c042a24:	4614      	mov	r4, r2
 c042a26:	18d5      	adds	r5, r2, r3
 c042a28:	42ac      	cmp	r4, r5
 c042a2a:	d101      	bne.n	c042a30 <__sfputs_r+0x12>
 c042a2c:	2000      	movs	r0, #0
 c042a2e:	e007      	b.n	c042a40 <__sfputs_r+0x22>
 c042a30:	463a      	mov	r2, r7
 c042a32:	f814 1b01 	ldrb.w	r1, [r4], #1
 c042a36:	4630      	mov	r0, r6
 c042a38:	f7ff ffdc 	bl	c0429f4 <__sfputc_r>
 c042a3c:	1c43      	adds	r3, r0, #1
 c042a3e:	d1f3      	bne.n	c042a28 <__sfputs_r+0xa>
 c042a40:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

0c042a44 <_vfiprintf_r>:
 c042a44:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c042a48:	460d      	mov	r5, r1
 c042a4a:	b09d      	sub	sp, #116	@ 0x74
 c042a4c:	4614      	mov	r4, r2
 c042a4e:	4698      	mov	r8, r3
 c042a50:	4606      	mov	r6, r0
 c042a52:	b118      	cbz	r0, c042a5c <_vfiprintf_r+0x18>
 c042a54:	6a03      	ldr	r3, [r0, #32]
 c042a56:	b90b      	cbnz	r3, c042a5c <_vfiprintf_r+0x18>
 c042a58:	f7ff fc9a 	bl	c042390 <__sinit>
 c042a5c:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
 c042a5e:	07d9      	lsls	r1, r3, #31
 c042a60:	d405      	bmi.n	c042a6e <_vfiprintf_r+0x2a>
 c042a62:	89ab      	ldrh	r3, [r5, #12]
 c042a64:	059a      	lsls	r2, r3, #22
 c042a66:	d402      	bmi.n	c042a6e <_vfiprintf_r+0x2a>
 c042a68:	6da8      	ldr	r0, [r5, #88]	@ 0x58
 c042a6a:	f7ff fe16 	bl	c04269a <__retarget_lock_acquire_recursive>
 c042a6e:	89ab      	ldrh	r3, [r5, #12]
 c042a70:	071b      	lsls	r3, r3, #28
 c042a72:	d501      	bpl.n	c042a78 <_vfiprintf_r+0x34>
 c042a74:	692b      	ldr	r3, [r5, #16]
 c042a76:	b99b      	cbnz	r3, c042aa0 <_vfiprintf_r+0x5c>
 c042a78:	4629      	mov	r1, r5
 c042a7a:	4630      	mov	r0, r6
 c042a7c:	f000 fb72 	bl	c043164 <__swsetup_r>
 c042a80:	b170      	cbz	r0, c042aa0 <_vfiprintf_r+0x5c>
 c042a82:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
 c042a84:	07dc      	lsls	r4, r3, #31
 c042a86:	d504      	bpl.n	c042a92 <_vfiprintf_r+0x4e>
 c042a88:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 c042a8c:	b01d      	add	sp, #116	@ 0x74
 c042a8e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 c042a92:	89ab      	ldrh	r3, [r5, #12]
 c042a94:	0598      	lsls	r0, r3, #22
 c042a96:	d4f7      	bmi.n	c042a88 <_vfiprintf_r+0x44>
 c042a98:	6da8      	ldr	r0, [r5, #88]	@ 0x58
 c042a9a:	f7ff fdff 	bl	c04269c <__retarget_lock_release_recursive>
 c042a9e:	e7f3      	b.n	c042a88 <_vfiprintf_r+0x44>
 c042aa0:	2300      	movs	r3, #0
 c042aa2:	f8cd 800c 	str.w	r8, [sp, #12]
 c042aa6:	f04f 0901 	mov.w	r9, #1
 c042aaa:	f8df 81b4 	ldr.w	r8, [pc, #436]	@ c042c60 <_vfiprintf_r+0x21c>
 c042aae:	9309      	str	r3, [sp, #36]	@ 0x24
 c042ab0:	2320      	movs	r3, #32
 c042ab2:	f88d 3029 	strb.w	r3, [sp, #41]	@ 0x29
 c042ab6:	2330      	movs	r3, #48	@ 0x30
 c042ab8:	f88d 302a 	strb.w	r3, [sp, #42]	@ 0x2a
 c042abc:	4623      	mov	r3, r4
 c042abe:	469a      	mov	sl, r3
 c042ac0:	f813 2b01 	ldrb.w	r2, [r3], #1
 c042ac4:	b10a      	cbz	r2, c042aca <_vfiprintf_r+0x86>
 c042ac6:	2a25      	cmp	r2, #37	@ 0x25
 c042ac8:	d1f9      	bne.n	c042abe <_vfiprintf_r+0x7a>
 c042aca:	ebba 0b04 	subs.w	fp, sl, r4
 c042ace:	d00b      	beq.n	c042ae8 <_vfiprintf_r+0xa4>
 c042ad0:	465b      	mov	r3, fp
 c042ad2:	4622      	mov	r2, r4
 c042ad4:	4629      	mov	r1, r5
 c042ad6:	4630      	mov	r0, r6
 c042ad8:	f7ff ffa1 	bl	c042a1e <__sfputs_r>
 c042adc:	3001      	adds	r0, #1
 c042ade:	f000 80a7 	beq.w	c042c30 <_vfiprintf_r+0x1ec>
 c042ae2:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 c042ae4:	445a      	add	r2, fp
 c042ae6:	9209      	str	r2, [sp, #36]	@ 0x24
 c042ae8:	f89a 3000 	ldrb.w	r3, [sl]
 c042aec:	2b00      	cmp	r3, #0
 c042aee:	f000 809f 	beq.w	c042c30 <_vfiprintf_r+0x1ec>
 c042af2:	2300      	movs	r3, #0
 c042af4:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 c042af8:	f10a 0a01 	add.w	sl, sl, #1
 c042afc:	9304      	str	r3, [sp, #16]
 c042afe:	9307      	str	r3, [sp, #28]
 c042b00:	f88d 3053 	strb.w	r3, [sp, #83]	@ 0x53
 c042b04:	931a      	str	r3, [sp, #104]	@ 0x68
 c042b06:	e9cd 2305 	strd	r2, r3, [sp, #20]
 c042b0a:	4654      	mov	r4, sl
 c042b0c:	2205      	movs	r2, #5
 c042b0e:	4854      	ldr	r0, [pc, #336]	@ (c042c60 <_vfiprintf_r+0x21c>)
 c042b10:	f814 1b01 	ldrb.w	r1, [r4], #1
 c042b14:	f000 fb7c 	bl	c043210 <memchr>
 c042b18:	9a04      	ldr	r2, [sp, #16]
 c042b1a:	b9d8      	cbnz	r0, c042b54 <_vfiprintf_r+0x110>
 c042b1c:	06d1      	lsls	r1, r2, #27
 c042b1e:	bf44      	itt	mi
 c042b20:	2320      	movmi	r3, #32
 c042b22:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
 c042b26:	0713      	lsls	r3, r2, #28
 c042b28:	bf44      	itt	mi
 c042b2a:	232b      	movmi	r3, #43	@ 0x2b
 c042b2c:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
 c042b30:	f89a 3000 	ldrb.w	r3, [sl]
 c042b34:	2b2a      	cmp	r3, #42	@ 0x2a
 c042b36:	d015      	beq.n	c042b64 <_vfiprintf_r+0x120>
 c042b38:	9a07      	ldr	r2, [sp, #28]
 c042b3a:	4654      	mov	r4, sl
 c042b3c:	2000      	movs	r0, #0
 c042b3e:	f04f 0c0a 	mov.w	ip, #10
 c042b42:	4621      	mov	r1, r4
 c042b44:	f811 3b01 	ldrb.w	r3, [r1], #1
 c042b48:	3b30      	subs	r3, #48	@ 0x30
 c042b4a:	2b09      	cmp	r3, #9
 c042b4c:	d94b      	bls.n	c042be6 <_vfiprintf_r+0x1a2>
 c042b4e:	b1b0      	cbz	r0, c042b7e <_vfiprintf_r+0x13a>
 c042b50:	9207      	str	r2, [sp, #28]
 c042b52:	e014      	b.n	c042b7e <_vfiprintf_r+0x13a>
 c042b54:	eba0 0308 	sub.w	r3, r0, r8
 c042b58:	46a2      	mov	sl, r4
 c042b5a:	fa09 f303 	lsl.w	r3, r9, r3
 c042b5e:	4313      	orrs	r3, r2
 c042b60:	9304      	str	r3, [sp, #16]
 c042b62:	e7d2      	b.n	c042b0a <_vfiprintf_r+0xc6>
 c042b64:	9b03      	ldr	r3, [sp, #12]
 c042b66:	1d19      	adds	r1, r3, #4
 c042b68:	681b      	ldr	r3, [r3, #0]
 c042b6a:	2b00      	cmp	r3, #0
 c042b6c:	9103      	str	r1, [sp, #12]
 c042b6e:	bfbb      	ittet	lt
 c042b70:	425b      	neglt	r3, r3
 c042b72:	f042 0202 	orrlt.w	r2, r2, #2
 c042b76:	9307      	strge	r3, [sp, #28]
 c042b78:	9307      	strlt	r3, [sp, #28]
 c042b7a:	bfb8      	it	lt
 c042b7c:	9204      	strlt	r2, [sp, #16]
 c042b7e:	7823      	ldrb	r3, [r4, #0]
 c042b80:	2b2e      	cmp	r3, #46	@ 0x2e
 c042b82:	d10a      	bne.n	c042b9a <_vfiprintf_r+0x156>
 c042b84:	7863      	ldrb	r3, [r4, #1]
 c042b86:	2b2a      	cmp	r3, #42	@ 0x2a
 c042b88:	d132      	bne.n	c042bf0 <_vfiprintf_r+0x1ac>
 c042b8a:	9b03      	ldr	r3, [sp, #12]
 c042b8c:	3402      	adds	r4, #2
 c042b8e:	1d1a      	adds	r2, r3, #4
 c042b90:	681b      	ldr	r3, [r3, #0]
 c042b92:	ea43 73e3 	orr.w	r3, r3, r3, asr #31
 c042b96:	9203      	str	r2, [sp, #12]
 c042b98:	9305      	str	r3, [sp, #20]
 c042b9a:	f8df a0c8 	ldr.w	sl, [pc, #200]	@ c042c64 <_vfiprintf_r+0x220>
 c042b9e:	2203      	movs	r2, #3
 c042ba0:	7821      	ldrb	r1, [r4, #0]
 c042ba2:	4650      	mov	r0, sl
 c042ba4:	f000 fb34 	bl	c043210 <memchr>
 c042ba8:	b138      	cbz	r0, c042bba <_vfiprintf_r+0x176>
 c042baa:	eba0 000a 	sub.w	r0, r0, sl
 c042bae:	2240      	movs	r2, #64	@ 0x40
 c042bb0:	9b04      	ldr	r3, [sp, #16]
 c042bb2:	3401      	adds	r4, #1
 c042bb4:	4082      	lsls	r2, r0
 c042bb6:	4313      	orrs	r3, r2
 c042bb8:	9304      	str	r3, [sp, #16]
 c042bba:	f814 1b01 	ldrb.w	r1, [r4], #1
 c042bbe:	2206      	movs	r2, #6
 c042bc0:	4829      	ldr	r0, [pc, #164]	@ (c042c68 <_vfiprintf_r+0x224>)
 c042bc2:	f88d 1028 	strb.w	r1, [sp, #40]	@ 0x28
 c042bc6:	f000 fb23 	bl	c043210 <memchr>
 c042bca:	2800      	cmp	r0, #0
 c042bcc:	d03f      	beq.n	c042c4e <_vfiprintf_r+0x20a>
 c042bce:	4b27      	ldr	r3, [pc, #156]	@ (c042c6c <_vfiprintf_r+0x228>)
 c042bd0:	bb1b      	cbnz	r3, c042c1a <_vfiprintf_r+0x1d6>
 c042bd2:	9b03      	ldr	r3, [sp, #12]
 c042bd4:	3307      	adds	r3, #7
 c042bd6:	f023 0307 	bic.w	r3, r3, #7
 c042bda:	3308      	adds	r3, #8
 c042bdc:	9303      	str	r3, [sp, #12]
 c042bde:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 c042be0:	443b      	add	r3, r7
 c042be2:	9309      	str	r3, [sp, #36]	@ 0x24
 c042be4:	e76a      	b.n	c042abc <_vfiprintf_r+0x78>
 c042be6:	fb0c 3202 	mla	r2, ip, r2, r3
 c042bea:	460c      	mov	r4, r1
 c042bec:	2001      	movs	r0, #1
 c042bee:	e7a8      	b.n	c042b42 <_vfiprintf_r+0xfe>
 c042bf0:	2300      	movs	r3, #0
 c042bf2:	3401      	adds	r4, #1
 c042bf4:	f04f 0c0a 	mov.w	ip, #10
 c042bf8:	4619      	mov	r1, r3
 c042bfa:	9305      	str	r3, [sp, #20]
 c042bfc:	4620      	mov	r0, r4
 c042bfe:	f810 2b01 	ldrb.w	r2, [r0], #1
 c042c02:	3a30      	subs	r2, #48	@ 0x30
 c042c04:	2a09      	cmp	r2, #9
 c042c06:	d903      	bls.n	c042c10 <_vfiprintf_r+0x1cc>
 c042c08:	2b00      	cmp	r3, #0
 c042c0a:	d0c6      	beq.n	c042b9a <_vfiprintf_r+0x156>
 c042c0c:	9105      	str	r1, [sp, #20]
 c042c0e:	e7c4      	b.n	c042b9a <_vfiprintf_r+0x156>
 c042c10:	fb0c 2101 	mla	r1, ip, r1, r2
 c042c14:	4604      	mov	r4, r0
 c042c16:	2301      	movs	r3, #1
 c042c18:	e7f0      	b.n	c042bfc <_vfiprintf_r+0x1b8>
 c042c1a:	ab03      	add	r3, sp, #12
 c042c1c:	462a      	mov	r2, r5
 c042c1e:	a904      	add	r1, sp, #16
 c042c20:	4630      	mov	r0, r6
 c042c22:	9300      	str	r3, [sp, #0]
 c042c24:	4b12      	ldr	r3, [pc, #72]	@ (c042c70 <_vfiprintf_r+0x22c>)
 c042c26:	f3af 8000 	nop.w
 c042c2a:	4607      	mov	r7, r0
 c042c2c:	1c78      	adds	r0, r7, #1
 c042c2e:	d1d6      	bne.n	c042bde <_vfiprintf_r+0x19a>
 c042c30:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
 c042c32:	07d9      	lsls	r1, r3, #31
 c042c34:	d405      	bmi.n	c042c42 <_vfiprintf_r+0x1fe>
 c042c36:	89ab      	ldrh	r3, [r5, #12]
 c042c38:	059a      	lsls	r2, r3, #22
 c042c3a:	d402      	bmi.n	c042c42 <_vfiprintf_r+0x1fe>
 c042c3c:	6da8      	ldr	r0, [r5, #88]	@ 0x58
 c042c3e:	f7ff fd2d 	bl	c04269c <__retarget_lock_release_recursive>
 c042c42:	89ab      	ldrh	r3, [r5, #12]
 c042c44:	065b      	lsls	r3, r3, #25
 c042c46:	f53f af1f 	bmi.w	c042a88 <_vfiprintf_r+0x44>
 c042c4a:	9809      	ldr	r0, [sp, #36]	@ 0x24
 c042c4c:	e71e      	b.n	c042a8c <_vfiprintf_r+0x48>
 c042c4e:	ab03      	add	r3, sp, #12
 c042c50:	462a      	mov	r2, r5
 c042c52:	a904      	add	r1, sp, #16
 c042c54:	4630      	mov	r0, r6
 c042c56:	9300      	str	r3, [sp, #0]
 c042c58:	4b05      	ldr	r3, [pc, #20]	@ (c042c70 <_vfiprintf_r+0x22c>)
 c042c5a:	f000 f87d 	bl	c042d58 <_printf_i>
 c042c5e:	e7e4      	b.n	c042c2a <_vfiprintf_r+0x1e6>
 c042c60:	0c0433a0 	.word	0x0c0433a0
 c042c64:	0c0433a6 	.word	0x0c0433a6
 c042c68:	0c0433aa 	.word	0x0c0433aa
 c042c6c:	00000000 	.word	0x00000000
 c042c70:	0c042a1f 	.word	0x0c042a1f

0c042c74 <_printf_common>:
 c042c74:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 c042c78:	4616      	mov	r6, r2
 c042c7a:	4698      	mov	r8, r3
 c042c7c:	688a      	ldr	r2, [r1, #8]
 c042c7e:	4607      	mov	r7, r0
 c042c80:	690b      	ldr	r3, [r1, #16]
 c042c82:	460c      	mov	r4, r1
 c042c84:	f8dd 9020 	ldr.w	r9, [sp, #32]
 c042c88:	4293      	cmp	r3, r2
 c042c8a:	bfb8      	it	lt
 c042c8c:	4613      	movlt	r3, r2
 c042c8e:	6033      	str	r3, [r6, #0]
 c042c90:	f891 2043 	ldrb.w	r2, [r1, #67]	@ 0x43
 c042c94:	b10a      	cbz	r2, c042c9a <_printf_common+0x26>
 c042c96:	3301      	adds	r3, #1
 c042c98:	6033      	str	r3, [r6, #0]
 c042c9a:	6823      	ldr	r3, [r4, #0]
 c042c9c:	0699      	lsls	r1, r3, #26
 c042c9e:	bf42      	ittt	mi
 c042ca0:	6833      	ldrmi	r3, [r6, #0]
 c042ca2:	3302      	addmi	r3, #2
 c042ca4:	6033      	strmi	r3, [r6, #0]
 c042ca6:	6825      	ldr	r5, [r4, #0]
 c042ca8:	f015 0506 	ands.w	r5, r5, #6
 c042cac:	d106      	bne.n	c042cbc <_printf_common+0x48>
 c042cae:	f104 0a19 	add.w	sl, r4, #25
 c042cb2:	68e3      	ldr	r3, [r4, #12]
 c042cb4:	6832      	ldr	r2, [r6, #0]
 c042cb6:	1a9b      	subs	r3, r3, r2
 c042cb8:	42ab      	cmp	r3, r5
 c042cba:	dc2b      	bgt.n	c042d14 <_printf_common+0xa0>
 c042cbc:	f894 3043 	ldrb.w	r3, [r4, #67]	@ 0x43
 c042cc0:	6822      	ldr	r2, [r4, #0]
 c042cc2:	3b00      	subs	r3, #0
 c042cc4:	bf18      	it	ne
 c042cc6:	2301      	movne	r3, #1
 c042cc8:	0692      	lsls	r2, r2, #26
 c042cca:	d430      	bmi.n	c042d2e <_printf_common+0xba>
 c042ccc:	f104 0243 	add.w	r2, r4, #67	@ 0x43
 c042cd0:	4641      	mov	r1, r8
 c042cd2:	4638      	mov	r0, r7
 c042cd4:	47c8      	blx	r9
 c042cd6:	3001      	adds	r0, #1
 c042cd8:	d023      	beq.n	c042d22 <_printf_common+0xae>
 c042cda:	6823      	ldr	r3, [r4, #0]
 c042cdc:	341a      	adds	r4, #26
 c042cde:	f854 2c0a 	ldr.w	r2, [r4, #-10]
 c042ce2:	f003 0306 	and.w	r3, r3, #6
 c042ce6:	2b04      	cmp	r3, #4
 c042ce8:	bf0a      	itet	eq
 c042cea:	f854 5c0e 	ldreq.w	r5, [r4, #-14]
 c042cee:	2500      	movne	r5, #0
 c042cf0:	6833      	ldreq	r3, [r6, #0]
 c042cf2:	f04f 0600 	mov.w	r6, #0
 c042cf6:	bf08      	it	eq
 c042cf8:	1aed      	subeq	r5, r5, r3
 c042cfa:	f854 3c12 	ldr.w	r3, [r4, #-18]
 c042cfe:	bf08      	it	eq
 c042d00:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
 c042d04:	4293      	cmp	r3, r2
 c042d06:	bfc4      	itt	gt
 c042d08:	1a9b      	subgt	r3, r3, r2
 c042d0a:	18ed      	addgt	r5, r5, r3
 c042d0c:	42b5      	cmp	r5, r6
 c042d0e:	d11a      	bne.n	c042d46 <_printf_common+0xd2>
 c042d10:	2000      	movs	r0, #0
 c042d12:	e008      	b.n	c042d26 <_printf_common+0xb2>
 c042d14:	2301      	movs	r3, #1
 c042d16:	4652      	mov	r2, sl
 c042d18:	4641      	mov	r1, r8
 c042d1a:	4638      	mov	r0, r7
 c042d1c:	47c8      	blx	r9
 c042d1e:	3001      	adds	r0, #1
 c042d20:	d103      	bne.n	c042d2a <_printf_common+0xb6>
 c042d22:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 c042d26:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 c042d2a:	3501      	adds	r5, #1
 c042d2c:	e7c1      	b.n	c042cb2 <_printf_common+0x3e>
 c042d2e:	18e1      	adds	r1, r4, r3
 c042d30:	1c5a      	adds	r2, r3, #1
 c042d32:	2030      	movs	r0, #48	@ 0x30
 c042d34:	3302      	adds	r3, #2
 c042d36:	4422      	add	r2, r4
 c042d38:	f881 0043 	strb.w	r0, [r1, #67]	@ 0x43
 c042d3c:	f894 1045 	ldrb.w	r1, [r4, #69]	@ 0x45
 c042d40:	f882 1043 	strb.w	r1, [r2, #67]	@ 0x43
 c042d44:	e7c2      	b.n	c042ccc <_printf_common+0x58>
 c042d46:	2301      	movs	r3, #1
 c042d48:	4622      	mov	r2, r4
 c042d4a:	4641      	mov	r1, r8
 c042d4c:	4638      	mov	r0, r7
 c042d4e:	47c8      	blx	r9
 c042d50:	3001      	adds	r0, #1
 c042d52:	d0e6      	beq.n	c042d22 <_printf_common+0xae>
 c042d54:	3601      	adds	r6, #1
 c042d56:	e7d9      	b.n	c042d0c <_printf_common+0x98>

0c042d58 <_printf_i>:
 c042d58:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 c042d5c:	7e0f      	ldrb	r7, [r1, #24]
 c042d5e:	4691      	mov	r9, r2
 c042d60:	4680      	mov	r8, r0
 c042d62:	460c      	mov	r4, r1
 c042d64:	2f78      	cmp	r7, #120	@ 0x78
 c042d66:	469a      	mov	sl, r3
 c042d68:	9e0c      	ldr	r6, [sp, #48]	@ 0x30
 c042d6a:	f101 0243 	add.w	r2, r1, #67	@ 0x43
 c042d6e:	d807      	bhi.n	c042d80 <_printf_i+0x28>
 c042d70:	2f62      	cmp	r7, #98	@ 0x62
 c042d72:	d80a      	bhi.n	c042d8a <_printf_i+0x32>
 c042d74:	2f00      	cmp	r7, #0
 c042d76:	f000 80d2 	beq.w	c042f1e <_printf_i+0x1c6>
 c042d7a:	2f58      	cmp	r7, #88	@ 0x58
 c042d7c:	f000 80b9 	beq.w	c042ef2 <_printf_i+0x19a>
 c042d80:	f104 0642 	add.w	r6, r4, #66	@ 0x42
 c042d84:	f884 7042 	strb.w	r7, [r4, #66]	@ 0x42
 c042d88:	e03a      	b.n	c042e00 <_printf_i+0xa8>
 c042d8a:	f1a7 0363 	sub.w	r3, r7, #99	@ 0x63
 c042d8e:	2b15      	cmp	r3, #21
 c042d90:	d8f6      	bhi.n	c042d80 <_printf_i+0x28>
 c042d92:	a101      	add	r1, pc, #4	@ (adr r1, c042d98 <_printf_i+0x40>)
 c042d94:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
 c042d98:	0c042df1 	.word	0x0c042df1
 c042d9c:	0c042e05 	.word	0x0c042e05
 c042da0:	0c042d81 	.word	0x0c042d81
 c042da4:	0c042d81 	.word	0x0c042d81
 c042da8:	0c042d81 	.word	0x0c042d81
 c042dac:	0c042d81 	.word	0x0c042d81
 c042db0:	0c042e05 	.word	0x0c042e05
 c042db4:	0c042d81 	.word	0x0c042d81
 c042db8:	0c042d81 	.word	0x0c042d81
 c042dbc:	0c042d81 	.word	0x0c042d81
 c042dc0:	0c042d81 	.word	0x0c042d81
 c042dc4:	0c042f05 	.word	0x0c042f05
 c042dc8:	0c042e2f 	.word	0x0c042e2f
 c042dcc:	0c042ebf 	.word	0x0c042ebf
 c042dd0:	0c042d81 	.word	0x0c042d81
 c042dd4:	0c042d81 	.word	0x0c042d81
 c042dd8:	0c042f27 	.word	0x0c042f27
 c042ddc:	0c042d81 	.word	0x0c042d81
 c042de0:	0c042e2f 	.word	0x0c042e2f
 c042de4:	0c042d81 	.word	0x0c042d81
 c042de8:	0c042d81 	.word	0x0c042d81
 c042dec:	0c042ec7 	.word	0x0c042ec7
 c042df0:	6833      	ldr	r3, [r6, #0]
 c042df2:	1d1a      	adds	r2, r3, #4
 c042df4:	681b      	ldr	r3, [r3, #0]
 c042df6:	6032      	str	r2, [r6, #0]
 c042df8:	f104 0642 	add.w	r6, r4, #66	@ 0x42
 c042dfc:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
 c042e00:	2301      	movs	r3, #1
 c042e02:	e09d      	b.n	c042f40 <_printf_i+0x1e8>
 c042e04:	6833      	ldr	r3, [r6, #0]
 c042e06:	6820      	ldr	r0, [r4, #0]
 c042e08:	1d19      	adds	r1, r3, #4
 c042e0a:	6031      	str	r1, [r6, #0]
 c042e0c:	0606      	lsls	r6, r0, #24
 c042e0e:	d501      	bpl.n	c042e14 <_printf_i+0xbc>
 c042e10:	681d      	ldr	r5, [r3, #0]
 c042e12:	e003      	b.n	c042e1c <_printf_i+0xc4>
 c042e14:	0645      	lsls	r5, r0, #25
 c042e16:	d5fb      	bpl.n	c042e10 <_printf_i+0xb8>
 c042e18:	f9b3 5000 	ldrsh.w	r5, [r3]
 c042e1c:	2d00      	cmp	r5, #0
 c042e1e:	da03      	bge.n	c042e28 <_printf_i+0xd0>
 c042e20:	232d      	movs	r3, #45	@ 0x2d
 c042e22:	426d      	negs	r5, r5
 c042e24:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
 c042e28:	4859      	ldr	r0, [pc, #356]	@ (c042f90 <_printf_i+0x238>)
 c042e2a:	230a      	movs	r3, #10
 c042e2c:	e011      	b.n	c042e52 <_printf_i+0xfa>
 c042e2e:	6821      	ldr	r1, [r4, #0]
 c042e30:	6833      	ldr	r3, [r6, #0]
 c042e32:	0608      	lsls	r0, r1, #24
 c042e34:	f853 5b04 	ldr.w	r5, [r3], #4
 c042e38:	d402      	bmi.n	c042e40 <_printf_i+0xe8>
 c042e3a:	0649      	lsls	r1, r1, #25
 c042e3c:	bf48      	it	mi
 c042e3e:	b2ad      	uxthmi	r5, r5
 c042e40:	2f6f      	cmp	r7, #111	@ 0x6f
 c042e42:	6033      	str	r3, [r6, #0]
 c042e44:	4852      	ldr	r0, [pc, #328]	@ (c042f90 <_printf_i+0x238>)
 c042e46:	bf14      	ite	ne
 c042e48:	230a      	movne	r3, #10
 c042e4a:	2308      	moveq	r3, #8
 c042e4c:	2100      	movs	r1, #0
 c042e4e:	f884 1043 	strb.w	r1, [r4, #67]	@ 0x43
 c042e52:	6866      	ldr	r6, [r4, #4]
 c042e54:	2e00      	cmp	r6, #0
 c042e56:	60a6      	str	r6, [r4, #8]
 c042e58:	bfa2      	ittt	ge
 c042e5a:	6821      	ldrge	r1, [r4, #0]
 c042e5c:	f021 0104 	bicge.w	r1, r1, #4
 c042e60:	6021      	strge	r1, [r4, #0]
 c042e62:	b90d      	cbnz	r5, c042e68 <_printf_i+0x110>
 c042e64:	2e00      	cmp	r6, #0
 c042e66:	d04b      	beq.n	c042f00 <_printf_i+0x1a8>
 c042e68:	4616      	mov	r6, r2
 c042e6a:	fbb5 f1f3 	udiv	r1, r5, r3
 c042e6e:	fb03 5711 	mls	r7, r3, r1, r5
 c042e72:	5dc7      	ldrb	r7, [r0, r7]
 c042e74:	f806 7d01 	strb.w	r7, [r6, #-1]!
 c042e78:	462f      	mov	r7, r5
 c042e7a:	460d      	mov	r5, r1
 c042e7c:	42bb      	cmp	r3, r7
 c042e7e:	d9f4      	bls.n	c042e6a <_printf_i+0x112>
 c042e80:	2b08      	cmp	r3, #8
 c042e82:	d10b      	bne.n	c042e9c <_printf_i+0x144>
 c042e84:	6823      	ldr	r3, [r4, #0]
 c042e86:	07df      	lsls	r7, r3, #31
 c042e88:	d508      	bpl.n	c042e9c <_printf_i+0x144>
 c042e8a:	6923      	ldr	r3, [r4, #16]
 c042e8c:	6861      	ldr	r1, [r4, #4]
 c042e8e:	4299      	cmp	r1, r3
 c042e90:	bfde      	ittt	le
 c042e92:	2330      	movle	r3, #48	@ 0x30
 c042e94:	f806 3c01 	strble.w	r3, [r6, #-1]
 c042e98:	f106 36ff 	addle.w	r6, r6, #4294967295	@ 0xffffffff
 c042e9c:	1b92      	subs	r2, r2, r6
 c042e9e:	6122      	str	r2, [r4, #16]
 c042ea0:	464b      	mov	r3, r9
 c042ea2:	aa03      	add	r2, sp, #12
 c042ea4:	4621      	mov	r1, r4
 c042ea6:	4640      	mov	r0, r8
 c042ea8:	f8cd a000 	str.w	sl, [sp]
 c042eac:	f7ff fee2 	bl	c042c74 <_printf_common>
 c042eb0:	3001      	adds	r0, #1
 c042eb2:	d14a      	bne.n	c042f4a <_printf_i+0x1f2>
 c042eb4:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 c042eb8:	b004      	add	sp, #16
 c042eba:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 c042ebe:	6823      	ldr	r3, [r4, #0]
 c042ec0:	f043 0320 	orr.w	r3, r3, #32
 c042ec4:	6023      	str	r3, [r4, #0]
 c042ec6:	2778      	movs	r7, #120	@ 0x78
 c042ec8:	4832      	ldr	r0, [pc, #200]	@ (c042f94 <_printf_i+0x23c>)
 c042eca:	6823      	ldr	r3, [r4, #0]
 c042ecc:	f884 7045 	strb.w	r7, [r4, #69]	@ 0x45
 c042ed0:	061f      	lsls	r7, r3, #24
 c042ed2:	6831      	ldr	r1, [r6, #0]
 c042ed4:	f851 5b04 	ldr.w	r5, [r1], #4
 c042ed8:	d402      	bmi.n	c042ee0 <_printf_i+0x188>
 c042eda:	065f      	lsls	r7, r3, #25
 c042edc:	bf48      	it	mi
 c042ede:	b2ad      	uxthmi	r5, r5
 c042ee0:	6031      	str	r1, [r6, #0]
 c042ee2:	07d9      	lsls	r1, r3, #31
 c042ee4:	bf44      	itt	mi
 c042ee6:	f043 0320 	orrmi.w	r3, r3, #32
 c042eea:	6023      	strmi	r3, [r4, #0]
 c042eec:	b11d      	cbz	r5, c042ef6 <_printf_i+0x19e>
 c042eee:	2310      	movs	r3, #16
 c042ef0:	e7ac      	b.n	c042e4c <_printf_i+0xf4>
 c042ef2:	4827      	ldr	r0, [pc, #156]	@ (c042f90 <_printf_i+0x238>)
 c042ef4:	e7e9      	b.n	c042eca <_printf_i+0x172>
 c042ef6:	6823      	ldr	r3, [r4, #0]
 c042ef8:	f023 0320 	bic.w	r3, r3, #32
 c042efc:	6023      	str	r3, [r4, #0]
 c042efe:	e7f6      	b.n	c042eee <_printf_i+0x196>
 c042f00:	4616      	mov	r6, r2
 c042f02:	e7bd      	b.n	c042e80 <_printf_i+0x128>
 c042f04:	6833      	ldr	r3, [r6, #0]
 c042f06:	6825      	ldr	r5, [r4, #0]
 c042f08:	1d18      	adds	r0, r3, #4
 c042f0a:	6961      	ldr	r1, [r4, #20]
 c042f0c:	6030      	str	r0, [r6, #0]
 c042f0e:	062e      	lsls	r6, r5, #24
 c042f10:	681b      	ldr	r3, [r3, #0]
 c042f12:	d501      	bpl.n	c042f18 <_printf_i+0x1c0>
 c042f14:	6019      	str	r1, [r3, #0]
 c042f16:	e002      	b.n	c042f1e <_printf_i+0x1c6>
 c042f18:	0668      	lsls	r0, r5, #25
 c042f1a:	d5fb      	bpl.n	c042f14 <_printf_i+0x1bc>
 c042f1c:	8019      	strh	r1, [r3, #0]
 c042f1e:	2300      	movs	r3, #0
 c042f20:	4616      	mov	r6, r2
 c042f22:	6123      	str	r3, [r4, #16]
 c042f24:	e7bc      	b.n	c042ea0 <_printf_i+0x148>
 c042f26:	6833      	ldr	r3, [r6, #0]
 c042f28:	2100      	movs	r1, #0
 c042f2a:	1d1a      	adds	r2, r3, #4
 c042f2c:	6032      	str	r2, [r6, #0]
 c042f2e:	681e      	ldr	r6, [r3, #0]
 c042f30:	6862      	ldr	r2, [r4, #4]
 c042f32:	4630      	mov	r0, r6
 c042f34:	f000 f96c 	bl	c043210 <memchr>
 c042f38:	b108      	cbz	r0, c042f3e <_printf_i+0x1e6>
 c042f3a:	1b80      	subs	r0, r0, r6
 c042f3c:	6060      	str	r0, [r4, #4]
 c042f3e:	6863      	ldr	r3, [r4, #4]
 c042f40:	6123      	str	r3, [r4, #16]
 c042f42:	2300      	movs	r3, #0
 c042f44:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
 c042f48:	e7aa      	b.n	c042ea0 <_printf_i+0x148>
 c042f4a:	6923      	ldr	r3, [r4, #16]
 c042f4c:	4632      	mov	r2, r6
 c042f4e:	4649      	mov	r1, r9
 c042f50:	4640      	mov	r0, r8
 c042f52:	47d0      	blx	sl
 c042f54:	3001      	adds	r0, #1
 c042f56:	d0ad      	beq.n	c042eb4 <_printf_i+0x15c>
 c042f58:	6823      	ldr	r3, [r4, #0]
 c042f5a:	079b      	lsls	r3, r3, #30
 c042f5c:	d413      	bmi.n	c042f86 <_printf_i+0x22e>
 c042f5e:	68e0      	ldr	r0, [r4, #12]
 c042f60:	9b03      	ldr	r3, [sp, #12]
 c042f62:	4298      	cmp	r0, r3
 c042f64:	bfb8      	it	lt
 c042f66:	4618      	movlt	r0, r3
 c042f68:	e7a6      	b.n	c042eb8 <_printf_i+0x160>
 c042f6a:	2301      	movs	r3, #1
 c042f6c:	4632      	mov	r2, r6
 c042f6e:	4649      	mov	r1, r9
 c042f70:	4640      	mov	r0, r8
 c042f72:	47d0      	blx	sl
 c042f74:	3001      	adds	r0, #1
 c042f76:	d09d      	beq.n	c042eb4 <_printf_i+0x15c>
 c042f78:	3501      	adds	r5, #1
 c042f7a:	68e3      	ldr	r3, [r4, #12]
 c042f7c:	9903      	ldr	r1, [sp, #12]
 c042f7e:	1a5b      	subs	r3, r3, r1
 c042f80:	42ab      	cmp	r3, r5
 c042f82:	dcf2      	bgt.n	c042f6a <_printf_i+0x212>
 c042f84:	e7eb      	b.n	c042f5e <_printf_i+0x206>
 c042f86:	2500      	movs	r5, #0
 c042f88:	f104 0619 	add.w	r6, r4, #25
 c042f8c:	e7f5      	b.n	c042f7a <_printf_i+0x222>
 c042f8e:	bf00      	nop
 c042f90:	0c0433b1 	.word	0x0c0433b1
 c042f94:	0c0433c2 	.word	0x0c0433c2

0c042f98 <__sflush_r>:
 c042f98:	f9b1 200c 	ldrsh.w	r2, [r1, #12]
 c042f9c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 c042f9e:	0716      	lsls	r6, r2, #28
 c042fa0:	4605      	mov	r5, r0
 c042fa2:	460c      	mov	r4, r1
 c042fa4:	d454      	bmi.n	c043050 <__sflush_r+0xb8>
 c042fa6:	684b      	ldr	r3, [r1, #4]
 c042fa8:	2b00      	cmp	r3, #0
 c042faa:	dc02      	bgt.n	c042fb2 <__sflush_r+0x1a>
 c042fac:	6c0b      	ldr	r3, [r1, #64]	@ 0x40
 c042fae:	2b00      	cmp	r3, #0
 c042fb0:	dd48      	ble.n	c043044 <__sflush_r+0xac>
 c042fb2:	6ae6      	ldr	r6, [r4, #44]	@ 0x2c
 c042fb4:	2e00      	cmp	r6, #0
 c042fb6:	d045      	beq.n	c043044 <__sflush_r+0xac>
 c042fb8:	2300      	movs	r3, #0
 c042fba:	f412 5280 	ands.w	r2, r2, #4096	@ 0x1000
 c042fbe:	682f      	ldr	r7, [r5, #0]
 c042fc0:	6a21      	ldr	r1, [r4, #32]
 c042fc2:	602b      	str	r3, [r5, #0]
 c042fc4:	d030      	beq.n	c043028 <__sflush_r+0x90>
 c042fc6:	6d62      	ldr	r2, [r4, #84]	@ 0x54
 c042fc8:	89a3      	ldrh	r3, [r4, #12]
 c042fca:	0759      	lsls	r1, r3, #29
 c042fcc:	d505      	bpl.n	c042fda <__sflush_r+0x42>
 c042fce:	6863      	ldr	r3, [r4, #4]
 c042fd0:	1ad2      	subs	r2, r2, r3
 c042fd2:	6b63      	ldr	r3, [r4, #52]	@ 0x34
 c042fd4:	b10b      	cbz	r3, c042fda <__sflush_r+0x42>
 c042fd6:	6c23      	ldr	r3, [r4, #64]	@ 0x40
 c042fd8:	1ad2      	subs	r2, r2, r3
 c042fda:	2300      	movs	r3, #0
 c042fdc:	6ae6      	ldr	r6, [r4, #44]	@ 0x2c
 c042fde:	6a21      	ldr	r1, [r4, #32]
 c042fe0:	4628      	mov	r0, r5
 c042fe2:	47b0      	blx	r6
 c042fe4:	1c43      	adds	r3, r0, #1
 c042fe6:	89a3      	ldrh	r3, [r4, #12]
 c042fe8:	d106      	bne.n	c042ff8 <__sflush_r+0x60>
 c042fea:	6829      	ldr	r1, [r5, #0]
 c042fec:	291d      	cmp	r1, #29
 c042fee:	d82b      	bhi.n	c043048 <__sflush_r+0xb0>
 c042ff0:	4a28      	ldr	r2, [pc, #160]	@ (c043094 <__sflush_r+0xfc>)
 c042ff2:	410a      	asrs	r2, r1
 c042ff4:	07d6      	lsls	r6, r2, #31
 c042ff6:	d427      	bmi.n	c043048 <__sflush_r+0xb0>
 c042ff8:	2200      	movs	r2, #0
 c042ffa:	04d9      	lsls	r1, r3, #19
 c042ffc:	6062      	str	r2, [r4, #4]
 c042ffe:	6922      	ldr	r2, [r4, #16]
 c043000:	6022      	str	r2, [r4, #0]
 c043002:	d504      	bpl.n	c04300e <__sflush_r+0x76>
 c043004:	1c42      	adds	r2, r0, #1
 c043006:	d101      	bne.n	c04300c <__sflush_r+0x74>
 c043008:	682b      	ldr	r3, [r5, #0]
 c04300a:	b903      	cbnz	r3, c04300e <__sflush_r+0x76>
 c04300c:	6560      	str	r0, [r4, #84]	@ 0x54
 c04300e:	6b61      	ldr	r1, [r4, #52]	@ 0x34
 c043010:	602f      	str	r7, [r5, #0]
 c043012:	b1b9      	cbz	r1, c043044 <__sflush_r+0xac>
 c043014:	f104 0344 	add.w	r3, r4, #68	@ 0x44
 c043018:	4299      	cmp	r1, r3
 c04301a:	d002      	beq.n	c043022 <__sflush_r+0x8a>
 c04301c:	4628      	mov	r0, r5
 c04301e:	f7ff fb47 	bl	c0426b0 <_free_r>
 c043022:	2300      	movs	r3, #0
 c043024:	6363      	str	r3, [r4, #52]	@ 0x34
 c043026:	e00d      	b.n	c043044 <__sflush_r+0xac>
 c043028:	2301      	movs	r3, #1
 c04302a:	4628      	mov	r0, r5
 c04302c:	47b0      	blx	r6
 c04302e:	4602      	mov	r2, r0
 c043030:	1c50      	adds	r0, r2, #1
 c043032:	d1c9      	bne.n	c042fc8 <__sflush_r+0x30>
 c043034:	682b      	ldr	r3, [r5, #0]
 c043036:	2b00      	cmp	r3, #0
 c043038:	d0c6      	beq.n	c042fc8 <__sflush_r+0x30>
 c04303a:	2b1d      	cmp	r3, #29
 c04303c:	d001      	beq.n	c043042 <__sflush_r+0xaa>
 c04303e:	2b16      	cmp	r3, #22
 c043040:	d11c      	bne.n	c04307c <__sflush_r+0xe4>
 c043042:	602f      	str	r7, [r5, #0]
 c043044:	2000      	movs	r0, #0
 c043046:	e020      	b.n	c04308a <__sflush_r+0xf2>
 c043048:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 c04304c:	b21b      	sxth	r3, r3
 c04304e:	e019      	b.n	c043084 <__sflush_r+0xec>
 c043050:	690f      	ldr	r7, [r1, #16]
 c043052:	2f00      	cmp	r7, #0
 c043054:	d0f6      	beq.n	c043044 <__sflush_r+0xac>
 c043056:	0793      	lsls	r3, r2, #30
 c043058:	680e      	ldr	r6, [r1, #0]
 c04305a:	600f      	str	r7, [r1, #0]
 c04305c:	bf0c      	ite	eq
 c04305e:	694b      	ldreq	r3, [r1, #20]
 c043060:	2300      	movne	r3, #0
 c043062:	1bf6      	subs	r6, r6, r7
 c043064:	608b      	str	r3, [r1, #8]
 c043066:	2e00      	cmp	r6, #0
 c043068:	ddec      	ble.n	c043044 <__sflush_r+0xac>
 c04306a:	4633      	mov	r3, r6
 c04306c:	463a      	mov	r2, r7
 c04306e:	6a21      	ldr	r1, [r4, #32]
 c043070:	4628      	mov	r0, r5
 c043072:	f8d4 c028 	ldr.w	ip, [r4, #40]	@ 0x28
 c043076:	47e0      	blx	ip
 c043078:	2800      	cmp	r0, #0
 c04307a:	dc07      	bgt.n	c04308c <__sflush_r+0xf4>
 c04307c:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 c043080:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 c043084:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 c043088:	81a3      	strh	r3, [r4, #12]
 c04308a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 c04308c:	4407      	add	r7, r0
 c04308e:	1a36      	subs	r6, r6, r0
 c043090:	e7e9      	b.n	c043066 <__sflush_r+0xce>
 c043092:	bf00      	nop
 c043094:	dfbffffe 	.word	0xdfbffffe

0c043098 <_fflush_r>:
 c043098:	b538      	push	{r3, r4, r5, lr}
 c04309a:	690b      	ldr	r3, [r1, #16]
 c04309c:	4605      	mov	r5, r0
 c04309e:	460c      	mov	r4, r1
 c0430a0:	b913      	cbnz	r3, c0430a8 <_fflush_r+0x10>
 c0430a2:	2500      	movs	r5, #0
 c0430a4:	4628      	mov	r0, r5
 c0430a6:	bd38      	pop	{r3, r4, r5, pc}
 c0430a8:	b118      	cbz	r0, c0430b2 <_fflush_r+0x1a>
 c0430aa:	6a03      	ldr	r3, [r0, #32]
 c0430ac:	b90b      	cbnz	r3, c0430b2 <_fflush_r+0x1a>
 c0430ae:	f7ff f96f 	bl	c042390 <__sinit>
 c0430b2:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 c0430b6:	2b00      	cmp	r3, #0
 c0430b8:	d0f3      	beq.n	c0430a2 <_fflush_r+0xa>
 c0430ba:	6e62      	ldr	r2, [r4, #100]	@ 0x64
 c0430bc:	07d0      	lsls	r0, r2, #31
 c0430be:	d404      	bmi.n	c0430ca <_fflush_r+0x32>
 c0430c0:	0599      	lsls	r1, r3, #22
 c0430c2:	d402      	bmi.n	c0430ca <_fflush_r+0x32>
 c0430c4:	6da0      	ldr	r0, [r4, #88]	@ 0x58
 c0430c6:	f7ff fae8 	bl	c04269a <__retarget_lock_acquire_recursive>
 c0430ca:	4628      	mov	r0, r5
 c0430cc:	4621      	mov	r1, r4
 c0430ce:	f7ff ff63 	bl	c042f98 <__sflush_r>
 c0430d2:	6e63      	ldr	r3, [r4, #100]	@ 0x64
 c0430d4:	4605      	mov	r5, r0
 c0430d6:	07da      	lsls	r2, r3, #31
 c0430d8:	d4e4      	bmi.n	c0430a4 <_fflush_r+0xc>
 c0430da:	89a3      	ldrh	r3, [r4, #12]
 c0430dc:	059b      	lsls	r3, r3, #22
 c0430de:	d4e1      	bmi.n	c0430a4 <_fflush_r+0xc>
 c0430e0:	6da0      	ldr	r0, [r4, #88]	@ 0x58
 c0430e2:	f7ff fadb 	bl	c04269c <__retarget_lock_release_recursive>
 c0430e6:	e7dd      	b.n	c0430a4 <_fflush_r+0xc>

0c0430e8 <__swbuf_r>:
 c0430e8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 c0430ea:	460e      	mov	r6, r1
 c0430ec:	4614      	mov	r4, r2
 c0430ee:	4605      	mov	r5, r0
 c0430f0:	b118      	cbz	r0, c0430fa <__swbuf_r+0x12>
 c0430f2:	6a03      	ldr	r3, [r0, #32]
 c0430f4:	b90b      	cbnz	r3, c0430fa <__swbuf_r+0x12>
 c0430f6:	f7ff f94b 	bl	c042390 <__sinit>
 c0430fa:	69a3      	ldr	r3, [r4, #24]
 c0430fc:	60a3      	str	r3, [r4, #8]
 c0430fe:	89a3      	ldrh	r3, [r4, #12]
 c043100:	071a      	lsls	r2, r3, #28
 c043102:	d501      	bpl.n	c043108 <__swbuf_r+0x20>
 c043104:	6923      	ldr	r3, [r4, #16]
 c043106:	b943      	cbnz	r3, c04311a <__swbuf_r+0x32>
 c043108:	4621      	mov	r1, r4
 c04310a:	4628      	mov	r0, r5
 c04310c:	f000 f82a 	bl	c043164 <__swsetup_r>
 c043110:	b118      	cbz	r0, c04311a <__swbuf_r+0x32>
 c043112:	f04f 37ff 	mov.w	r7, #4294967295	@ 0xffffffff
 c043116:	4638      	mov	r0, r7
 c043118:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 c04311a:	6823      	ldr	r3, [r4, #0]
 c04311c:	b2f6      	uxtb	r6, r6
 c04311e:	6922      	ldr	r2, [r4, #16]
 c043120:	4637      	mov	r7, r6
 c043122:	1a98      	subs	r0, r3, r2
 c043124:	6963      	ldr	r3, [r4, #20]
 c043126:	4283      	cmp	r3, r0
 c043128:	dc05      	bgt.n	c043136 <__swbuf_r+0x4e>
 c04312a:	4621      	mov	r1, r4
 c04312c:	4628      	mov	r0, r5
 c04312e:	f7ff ffb3 	bl	c043098 <_fflush_r>
 c043132:	2800      	cmp	r0, #0
 c043134:	d1ed      	bne.n	c043112 <__swbuf_r+0x2a>
 c043136:	68a3      	ldr	r3, [r4, #8]
 c043138:	3b01      	subs	r3, #1
 c04313a:	60a3      	str	r3, [r4, #8]
 c04313c:	6823      	ldr	r3, [r4, #0]
 c04313e:	1c5a      	adds	r2, r3, #1
 c043140:	6022      	str	r2, [r4, #0]
 c043142:	701e      	strb	r6, [r3, #0]
 c043144:	1c43      	adds	r3, r0, #1
 c043146:	6962      	ldr	r2, [r4, #20]
 c043148:	429a      	cmp	r2, r3
 c04314a:	d004      	beq.n	c043156 <__swbuf_r+0x6e>
 c04314c:	89a3      	ldrh	r3, [r4, #12]
 c04314e:	07db      	lsls	r3, r3, #31
 c043150:	d5e1      	bpl.n	c043116 <__swbuf_r+0x2e>
 c043152:	2e0a      	cmp	r6, #10
 c043154:	d1df      	bne.n	c043116 <__swbuf_r+0x2e>
 c043156:	4621      	mov	r1, r4
 c043158:	4628      	mov	r0, r5
 c04315a:	f7ff ff9d 	bl	c043098 <_fflush_r>
 c04315e:	2800      	cmp	r0, #0
 c043160:	d0d9      	beq.n	c043116 <__swbuf_r+0x2e>
 c043162:	e7d6      	b.n	c043112 <__swbuf_r+0x2a>

0c043164 <__swsetup_r>:
 c043164:	b538      	push	{r3, r4, r5, lr}
 c043166:	4b29      	ldr	r3, [pc, #164]	@ (c04320c <__swsetup_r+0xa8>)
 c043168:	4605      	mov	r5, r0
 c04316a:	460c      	mov	r4, r1
 c04316c:	6818      	ldr	r0, [r3, #0]
 c04316e:	b118      	cbz	r0, c043178 <__swsetup_r+0x14>
 c043170:	6a03      	ldr	r3, [r0, #32]
 c043172:	b90b      	cbnz	r3, c043178 <__swsetup_r+0x14>
 c043174:	f7ff f90c 	bl	c042390 <__sinit>
 c043178:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 c04317c:	0719      	lsls	r1, r3, #28
 c04317e:	d422      	bmi.n	c0431c6 <__swsetup_r+0x62>
 c043180:	06da      	lsls	r2, r3, #27
 c043182:	d407      	bmi.n	c043194 <__swsetup_r+0x30>
 c043184:	2209      	movs	r2, #9
 c043186:	602a      	str	r2, [r5, #0]
 c043188:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 c04318c:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 c043190:	81a3      	strh	r3, [r4, #12]
 c043192:	e033      	b.n	c0431fc <__swsetup_r+0x98>
 c043194:	0758      	lsls	r0, r3, #29
 c043196:	d512      	bpl.n	c0431be <__swsetup_r+0x5a>
 c043198:	6b61      	ldr	r1, [r4, #52]	@ 0x34
 c04319a:	b141      	cbz	r1, c0431ae <__swsetup_r+0x4a>
 c04319c:	f104 0344 	add.w	r3, r4, #68	@ 0x44
 c0431a0:	4299      	cmp	r1, r3
 c0431a2:	d002      	beq.n	c0431aa <__swsetup_r+0x46>
 c0431a4:	4628      	mov	r0, r5
 c0431a6:	f7ff fa83 	bl	c0426b0 <_free_r>
 c0431aa:	2300      	movs	r3, #0
 c0431ac:	6363      	str	r3, [r4, #52]	@ 0x34
 c0431ae:	89a3      	ldrh	r3, [r4, #12]
 c0431b0:	f023 0324 	bic.w	r3, r3, #36	@ 0x24
 c0431b4:	81a3      	strh	r3, [r4, #12]
 c0431b6:	2300      	movs	r3, #0
 c0431b8:	6063      	str	r3, [r4, #4]
 c0431ba:	6923      	ldr	r3, [r4, #16]
 c0431bc:	6023      	str	r3, [r4, #0]
 c0431be:	89a3      	ldrh	r3, [r4, #12]
 c0431c0:	f043 0308 	orr.w	r3, r3, #8
 c0431c4:	81a3      	strh	r3, [r4, #12]
 c0431c6:	6923      	ldr	r3, [r4, #16]
 c0431c8:	b94b      	cbnz	r3, c0431de <__swsetup_r+0x7a>
 c0431ca:	89a3      	ldrh	r3, [r4, #12]
 c0431cc:	f403 7320 	and.w	r3, r3, #640	@ 0x280
 c0431d0:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 c0431d4:	d003      	beq.n	c0431de <__swsetup_r+0x7a>
 c0431d6:	4621      	mov	r1, r4
 c0431d8:	4628      	mov	r0, r5
 c0431da:	f000 f87a 	bl	c0432d2 <__smakebuf_r>
 c0431de:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 c0431e2:	f013 0201 	ands.w	r2, r3, #1
 c0431e6:	d00a      	beq.n	c0431fe <__swsetup_r+0x9a>
 c0431e8:	2200      	movs	r2, #0
 c0431ea:	60a2      	str	r2, [r4, #8]
 c0431ec:	6962      	ldr	r2, [r4, #20]
 c0431ee:	4252      	negs	r2, r2
 c0431f0:	61a2      	str	r2, [r4, #24]
 c0431f2:	6922      	ldr	r2, [r4, #16]
 c0431f4:	b942      	cbnz	r2, c043208 <__swsetup_r+0xa4>
 c0431f6:	f013 0080 	ands.w	r0, r3, #128	@ 0x80
 c0431fa:	d1c5      	bne.n	c043188 <__swsetup_r+0x24>
 c0431fc:	bd38      	pop	{r3, r4, r5, pc}
 c0431fe:	0799      	lsls	r1, r3, #30
 c043200:	bf58      	it	pl
 c043202:	6962      	ldrpl	r2, [r4, #20]
 c043204:	60a2      	str	r2, [r4, #8]
 c043206:	e7f4      	b.n	c0431f2 <__swsetup_r+0x8e>
 c043208:	2000      	movs	r0, #0
 c04320a:	e7f7      	b.n	c0431fc <__swsetup_r+0x98>
 c04320c:	30030ad4 	.word	0x30030ad4

0c043210 <memchr>:
 c043210:	b2c9      	uxtb	r1, r1
 c043212:	4603      	mov	r3, r0
 c043214:	4402      	add	r2, r0
 c043216:	b510      	push	{r4, lr}
 c043218:	4293      	cmp	r3, r2
 c04321a:	4618      	mov	r0, r3
 c04321c:	d101      	bne.n	c043222 <memchr+0x12>
 c04321e:	2000      	movs	r0, #0
 c043220:	e003      	b.n	c04322a <memchr+0x1a>
 c043222:	7804      	ldrb	r4, [r0, #0]
 c043224:	3301      	adds	r3, #1
 c043226:	428c      	cmp	r4, r1
 c043228:	d1f6      	bne.n	c043218 <memchr+0x8>
 c04322a:	bd10      	pop	{r4, pc}

0c04322c <_realloc_r>:
 c04322c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 c043230:	4680      	mov	r8, r0
 c043232:	4615      	mov	r5, r2
 c043234:	460c      	mov	r4, r1
 c043236:	b921      	cbnz	r1, c043242 <_realloc_r+0x16>
 c043238:	4611      	mov	r1, r2
 c04323a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 c04323e:	f7fe bf8f 	b.w	c042160 <_malloc_r>
 c043242:	b92a      	cbnz	r2, c043250 <_realloc_r+0x24>
 c043244:	f7ff fa34 	bl	c0426b0 <_free_r>
 c043248:	2400      	movs	r4, #0
 c04324a:	4620      	mov	r0, r4
 c04324c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 c043250:	f000 f89e 	bl	c043390 <_malloc_usable_size_r>
 c043254:	4285      	cmp	r5, r0
 c043256:	4606      	mov	r6, r0
 c043258:	d802      	bhi.n	c043260 <_realloc_r+0x34>
 c04325a:	ebb5 0f50 	cmp.w	r5, r0, lsr #1
 c04325e:	d8f4      	bhi.n	c04324a <_realloc_r+0x1e>
 c043260:	4629      	mov	r1, r5
 c043262:	4640      	mov	r0, r8
 c043264:	f7fe ff7c 	bl	c042160 <_malloc_r>
 c043268:	4607      	mov	r7, r0
 c04326a:	2800      	cmp	r0, #0
 c04326c:	d0ec      	beq.n	c043248 <_realloc_r+0x1c>
 c04326e:	42b5      	cmp	r5, r6
 c043270:	462a      	mov	r2, r5
 c043272:	4621      	mov	r1, r4
 c043274:	bf28      	it	cs
 c043276:	4632      	movcs	r2, r6
 c043278:	f018 f9e8 	bl	c05b64c <memcpy>
 c04327c:	4621      	mov	r1, r4
 c04327e:	4640      	mov	r0, r8
 c043280:	463c      	mov	r4, r7
 c043282:	f7ff fa15 	bl	c0426b0 <_free_r>
 c043286:	e7e0      	b.n	c04324a <_realloc_r+0x1e>

0c043288 <__swhatbuf_r>:
 c043288:	b570      	push	{r4, r5, r6, lr}
 c04328a:	460c      	mov	r4, r1
 c04328c:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 c043290:	b096      	sub	sp, #88	@ 0x58
 c043292:	4615      	mov	r5, r2
 c043294:	2900      	cmp	r1, #0
 c043296:	461e      	mov	r6, r3
 c043298:	da0c      	bge.n	c0432b4 <__swhatbuf_r+0x2c>
 c04329a:	89a3      	ldrh	r3, [r4, #12]
 c04329c:	2100      	movs	r1, #0
 c04329e:	f013 0f80 	tst.w	r3, #128	@ 0x80
 c0432a2:	bf14      	ite	ne
 c0432a4:	2340      	movne	r3, #64	@ 0x40
 c0432a6:	f44f 6380 	moveq.w	r3, #1024	@ 0x400
 c0432aa:	2000      	movs	r0, #0
 c0432ac:	6031      	str	r1, [r6, #0]
 c0432ae:	602b      	str	r3, [r5, #0]
 c0432b0:	b016      	add	sp, #88	@ 0x58
 c0432b2:	bd70      	pop	{r4, r5, r6, pc}
 c0432b4:	466a      	mov	r2, sp
 c0432b6:	f000 f849 	bl	c04334c <_fstat_r>
 c0432ba:	2800      	cmp	r0, #0
 c0432bc:	dbed      	blt.n	c04329a <__swhatbuf_r+0x12>
 c0432be:	9901      	ldr	r1, [sp, #4]
 c0432c0:	f401 4170 	and.w	r1, r1, #61440	@ 0xf000
 c0432c4:	f5a1 5300 	sub.w	r3, r1, #8192	@ 0x2000
 c0432c8:	4259      	negs	r1, r3
 c0432ca:	4159      	adcs	r1, r3
 c0432cc:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 c0432d0:	e7eb      	b.n	c0432aa <__swhatbuf_r+0x22>

0c0432d2 <__smakebuf_r>:
 c0432d2:	898b      	ldrh	r3, [r1, #12]
 c0432d4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 c0432d6:	079d      	lsls	r5, r3, #30
 c0432d8:	4606      	mov	r6, r0
 c0432da:	460c      	mov	r4, r1
 c0432dc:	d507      	bpl.n	c0432ee <__smakebuf_r+0x1c>
 c0432de:	f104 0347 	add.w	r3, r4, #71	@ 0x47
 c0432e2:	6023      	str	r3, [r4, #0]
 c0432e4:	6123      	str	r3, [r4, #16]
 c0432e6:	2301      	movs	r3, #1
 c0432e8:	6163      	str	r3, [r4, #20]
 c0432ea:	b003      	add	sp, #12
 c0432ec:	bdf0      	pop	{r4, r5, r6, r7, pc}
 c0432ee:	ab01      	add	r3, sp, #4
 c0432f0:	466a      	mov	r2, sp
 c0432f2:	f7ff ffc9 	bl	c043288 <__swhatbuf_r>
 c0432f6:	9f00      	ldr	r7, [sp, #0]
 c0432f8:	4605      	mov	r5, r0
 c0432fa:	4630      	mov	r0, r6
 c0432fc:	4639      	mov	r1, r7
 c0432fe:	f7fe ff2f 	bl	c042160 <_malloc_r>
 c043302:	b948      	cbnz	r0, c043318 <__smakebuf_r+0x46>
 c043304:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 c043308:	059a      	lsls	r2, r3, #22
 c04330a:	d4ee      	bmi.n	c0432ea <__smakebuf_r+0x18>
 c04330c:	f023 0303 	bic.w	r3, r3, #3
 c043310:	f043 0302 	orr.w	r3, r3, #2
 c043314:	81a3      	strh	r3, [r4, #12]
 c043316:	e7e2      	b.n	c0432de <__smakebuf_r+0xc>
 c043318:	89a3      	ldrh	r3, [r4, #12]
 c04331a:	6020      	str	r0, [r4, #0]
 c04331c:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 c043320:	81a3      	strh	r3, [r4, #12]
 c043322:	9b01      	ldr	r3, [sp, #4]
 c043324:	e9c4 0704 	strd	r0, r7, [r4, #16]
 c043328:	b15b      	cbz	r3, c043342 <__smakebuf_r+0x70>
 c04332a:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 c04332e:	4630      	mov	r0, r6
 c043330:	f000 f81e 	bl	c043370 <_isatty_r>
 c043334:	b128      	cbz	r0, c043342 <__smakebuf_r+0x70>
 c043336:	89a3      	ldrh	r3, [r4, #12]
 c043338:	f023 0303 	bic.w	r3, r3, #3
 c04333c:	f043 0301 	orr.w	r3, r3, #1
 c043340:	81a3      	strh	r3, [r4, #12]
 c043342:	89a3      	ldrh	r3, [r4, #12]
 c043344:	431d      	orrs	r5, r3
 c043346:	81a5      	strh	r5, [r4, #12]
 c043348:	e7cf      	b.n	c0432ea <__smakebuf_r+0x18>
	...

0c04334c <_fstat_r>:
 c04334c:	b538      	push	{r3, r4, r5, lr}
 c04334e:	2300      	movs	r3, #0
 c043350:	4d06      	ldr	r5, [pc, #24]	@ (c04336c <_fstat_r+0x20>)
 c043352:	4604      	mov	r4, r0
 c043354:	4608      	mov	r0, r1
 c043356:	4611      	mov	r1, r2
 c043358:	602b      	str	r3, [r5, #0]
 c04335a:	f01b fa15 	bl	c05e788 <_fstat>
 c04335e:	1c43      	adds	r3, r0, #1
 c043360:	d102      	bne.n	c043368 <_fstat_r+0x1c>
 c043362:	682b      	ldr	r3, [r5, #0]
 c043364:	b103      	cbz	r3, c043368 <_fstat_r+0x1c>
 c043366:	6023      	str	r3, [r4, #0]
 c043368:	bd38      	pop	{r3, r4, r5, pc}
 c04336a:	bf00      	nop
 c04336c:	3003e954 	.word	0x3003e954

0c043370 <_isatty_r>:
 c043370:	b538      	push	{r3, r4, r5, lr}
 c043372:	2300      	movs	r3, #0
 c043374:	4d05      	ldr	r5, [pc, #20]	@ (c04338c <_isatty_r+0x1c>)
 c043376:	4604      	mov	r4, r0
 c043378:	4608      	mov	r0, r1
 c04337a:	602b      	str	r3, [r5, #0]
 c04337c:	f01b fa0c 	bl	c05e798 <_isatty>
 c043380:	1c43      	adds	r3, r0, #1
 c043382:	d102      	bne.n	c04338a <_isatty_r+0x1a>
 c043384:	682b      	ldr	r3, [r5, #0]
 c043386:	b103      	cbz	r3, c04338a <_isatty_r+0x1a>
 c043388:	6023      	str	r3, [r4, #0]
 c04338a:	bd38      	pop	{r3, r4, r5, pc}
 c04338c:	3003e954 	.word	0x3003e954

0c043390 <_malloc_usable_size_r>:
 c043390:	f851 3c04 	ldr.w	r3, [r1, #-4]
 c043394:	1f18      	subs	r0, r3, #4
 c043396:	2b00      	cmp	r3, #0
 c043398:	bfbc      	itt	lt
 c04339a:	580b      	ldrlt	r3, [r1, r0]
 c04339c:	18c0      	addlt	r0, r0, r3
 c04339e:	4770      	bx	lr
 c0433a0:	2b302d23 	.word	0x2b302d23
 c0433a4:	6c680020 	.word	0x6c680020
 c0433a8:	6665004c 	.word	0x6665004c
 c0433ac:	47464567 	.word	0x47464567
 c0433b0:	00          	.byte	0x00
 c0433b1:	30          	.byte	0x30
 c0433b2:	3231      	.short	0x3231
 c0433b4:	36353433 	.word	0x36353433
 c0433b8:	41393837 	.word	0x41393837
 c0433bc:	45444342 	.word	0x45444342
 c0433c0:	31300046 	.word	0x31300046
 c0433c4:	35343332 	.word	0x35343332
 c0433c8:	39383736 	.word	0x39383736
 c0433cc:	64636261 	.word	0x64636261
 c0433d0:	00006665 	.word	0x00006665

0c0433d4 <cmse_check_address_range>:
 c0433d4:	1843      	adds	r3, r0, r1
 c0433d6:	d26c      	bcs.n	c0434b2 <cmse_check_address_range+0xde>
 c0433d8:	2a1f      	cmp	r2, #31
 c0433da:	d86a      	bhi.n	c0434b2 <cmse_check_address_range+0xde>
 c0433dc:	3901      	subs	r1, #1
 c0433de:	f002 0314 	and.w	r3, r2, #20
 c0433e2:	4401      	add	r1, r0
 c0433e4:	b500      	push	{lr}
 c0433e6:	ea81 0c00 	eor.w	ip, r1, r0
 c0433ea:	2b14      	cmp	r3, #20
 c0433ec:	d80e      	bhi.n	c04340c <cmse_check_address_range+0x38>
 c0433ee:	e8df f003 	tbb	[pc, r3]
 c0433f2:	0d3f      	.short	0x0d3f
 c0433f4:	0d480d0d 	.word	0x0d480d0d
 c0433f8:	0d0d0d0d 	.word	0x0d0d0d0d
 c0433fc:	0d0d0d0d 	.word	0x0d0d0d0d
 c043400:	0d510d0d 	.word	0x0d510d0d
 c043404:	0d0d      	.short	0x0d0d
 c043406:	10          	.byte	0x10
 c043407:	00          	.byte	0x00
 c043408:	035b      	lsls	r3, r3, #13
 c04340a:	d400      	bmi.n	c04340e <cmse_check_address_range+0x3a>
 c04340c:	2000      	movs	r0, #0
 c04340e:	f85d fb04 	ldr.w	pc, [sp], #4
 c043412:	f1bc 0f1f 	cmp.w	ip, #31
 c043416:	e840 f3c0 	ttat	r3, r0
 c04341a:	d904      	bls.n	c043426 <cmse_check_address_range+0x52>
 c04341c:	469c      	mov	ip, r3
 c04341e:	e841 f3c0 	ttat	r3, r1
 c043422:	459c      	cmp	ip, r3
 c043424:	d1f2      	bne.n	c04340c <cmse_check_address_range+0x38>
 c043426:	f022 0214 	bic.w	r2, r2, #20
 c04342a:	3a01      	subs	r2, #1
 c04342c:	2a0a      	cmp	r2, #10
 c04342e:	d8ed      	bhi.n	c04340c <cmse_check_address_range+0x38>
 c043430:	a101      	add	r1, pc, #4	@ (adr r1, c043438 <cmse_check_address_range+0x64>)
 c043432:	f851 f022 	ldr.w	pc, [r1, r2, lsl #2]
 c043436:	bf00      	nop
 c043438:	0c04346b 	.word	0x0c04346b
 c04343c:	0c0434ad 	.word	0x0c0434ad
 c043440:	0c043465 	.word	0x0c043465
 c043444:	0c04340d 	.word	0x0c04340d
 c043448:	0c04340d 	.word	0x0c04340d
 c04344c:	0c04340d 	.word	0x0c04340d
 c043450:	0c04340d 	.word	0x0c04340d
 c043454:	0c043409 	.word	0x0c043409
 c043458:	0c04346b 	.word	0x0c04346b
 c04345c:	0c0434a7 	.word	0x0c0434a7
 c043460:	0c043465 	.word	0x0c043465
 c043464:	029a      	lsls	r2, r3, #10
 c043466:	d4d2      	bmi.n	c04340e <cmse_check_address_range+0x3a>
 c043468:	e7d0      	b.n	c04340c <cmse_check_address_range+0x38>
 c04346a:	031a      	lsls	r2, r3, #12
 c04346c:	d4cf      	bmi.n	c04340e <cmse_check_address_range+0x3a>
 c04346e:	e7cd      	b.n	c04340c <cmse_check_address_range+0x38>
 c043470:	f1bc 0f1f 	cmp.w	ip, #31
 c043474:	e840 f300 	tt	r3, r0
 c043478:	d9d5      	bls.n	c043426 <cmse_check_address_range+0x52>
 c04347a:	469c      	mov	ip, r3
 c04347c:	e841 f300 	tt	r3, r1
 c043480:	e7cf      	b.n	c043422 <cmse_check_address_range+0x4e>
 c043482:	f1bc 0f1f 	cmp.w	ip, #31
 c043486:	e840 f340 	ttt	r3, r0
 c04348a:	d9cc      	bls.n	c043426 <cmse_check_address_range+0x52>
 c04348c:	469c      	mov	ip, r3
 c04348e:	e841 f340 	ttt	r3, r1
 c043492:	e7c6      	b.n	c043422 <cmse_check_address_range+0x4e>
 c043494:	f1bc 0f1f 	cmp.w	ip, #31
 c043498:	e840 f380 	tta	r3, r0
 c04349c:	d9c3      	bls.n	c043426 <cmse_check_address_range+0x52>
 c04349e:	469c      	mov	ip, r3
 c0434a0:	e841 f380 	tta	r3, r1
 c0434a4:	e7bd      	b.n	c043422 <cmse_check_address_range+0x4e>
 c0434a6:	02db      	lsls	r3, r3, #11
 c0434a8:	d4b1      	bmi.n	c04340e <cmse_check_address_range+0x3a>
 c0434aa:	e7af      	b.n	c04340c <cmse_check_address_range+0x38>
 c0434ac:	0259      	lsls	r1, r3, #9
 c0434ae:	d5ae      	bpl.n	c04340e <cmse_check_address_range+0x3a>
 c0434b0:	e7ac      	b.n	c04340c <cmse_check_address_range+0x38>
 c0434b2:	2000      	movs	r0, #0
 c0434b4:	4770      	bx	lr
 c0434b6:	bf00      	nop

0c0434b8 <__aeabi_frsub>:
 c0434b8:	f080 4000 	eor.w	r0, r0, #2147483648	@ 0x80000000
 c0434bc:	e002      	b.n	c0434c4 <__addsf3>
 c0434be:	bf00      	nop

0c0434c0 <__aeabi_fsub>:
 c0434c0:	f081 4100 	eor.w	r1, r1, #2147483648	@ 0x80000000

0c0434c4 <__addsf3>:
 c0434c4:	0042      	lsls	r2, r0, #1
 c0434c6:	bf1f      	itttt	ne
 c0434c8:	ea5f 0341 	movsne.w	r3, r1, lsl #1
 c0434cc:	ea92 0f03 	teqne	r2, r3
 c0434d0:	ea7f 6c22 	mvnsne.w	ip, r2, asr #24
 c0434d4:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 c0434d8:	d06a      	beq.n	c0435b0 <__addsf3+0xec>
 c0434da:	ea4f 6212 	mov.w	r2, r2, lsr #24
 c0434de:	ebd2 6313 	rsbs	r3, r2, r3, lsr #24
 c0434e2:	bfc1      	itttt	gt
 c0434e4:	18d2      	addgt	r2, r2, r3
 c0434e6:	4041      	eorgt	r1, r0
 c0434e8:	4048      	eorgt	r0, r1
 c0434ea:	4041      	eorgt	r1, r0
 c0434ec:	bfb8      	it	lt
 c0434ee:	425b      	neglt	r3, r3
 c0434f0:	2b19      	cmp	r3, #25
 c0434f2:	bf88      	it	hi
 c0434f4:	4770      	bxhi	lr
 c0434f6:	f010 4f00 	tst.w	r0, #2147483648	@ 0x80000000
 c0434fa:	f440 0000 	orr.w	r0, r0, #8388608	@ 0x800000
 c0434fe:	f020 407f 	bic.w	r0, r0, #4278190080	@ 0xff000000
 c043502:	bf18      	it	ne
 c043504:	4240      	negne	r0, r0
 c043506:	f011 4f00 	tst.w	r1, #2147483648	@ 0x80000000
 c04350a:	f441 0100 	orr.w	r1, r1, #8388608	@ 0x800000
 c04350e:	f021 417f 	bic.w	r1, r1, #4278190080	@ 0xff000000
 c043512:	bf18      	it	ne
 c043514:	4249      	negne	r1, r1
 c043516:	ea92 0f03 	teq	r2, r3
 c04351a:	d03f      	beq.n	c04359c <__addsf3+0xd8>
 c04351c:	f1a2 0201 	sub.w	r2, r2, #1
 c043520:	fa41 fc03 	asr.w	ip, r1, r3
 c043524:	eb10 000c 	adds.w	r0, r0, ip
 c043528:	f1c3 0320 	rsb	r3, r3, #32
 c04352c:	fa01 f103 	lsl.w	r1, r1, r3
 c043530:	f000 4300 	and.w	r3, r0, #2147483648	@ 0x80000000
 c043534:	d502      	bpl.n	c04353c <__addsf3+0x78>
 c043536:	4249      	negs	r1, r1
 c043538:	eb60 0040 	sbc.w	r0, r0, r0, lsl #1
 c04353c:	f5b0 0f00 	cmp.w	r0, #8388608	@ 0x800000
 c043540:	d313      	bcc.n	c04356a <__addsf3+0xa6>
 c043542:	f1b0 7f80 	cmp.w	r0, #16777216	@ 0x1000000
 c043546:	d306      	bcc.n	c043556 <__addsf3+0x92>
 c043548:	0840      	lsrs	r0, r0, #1
 c04354a:	ea4f 0131 	mov.w	r1, r1, rrx
 c04354e:	f102 0201 	add.w	r2, r2, #1
 c043552:	2afe      	cmp	r2, #254	@ 0xfe
 c043554:	d251      	bcs.n	c0435fa <__addsf3+0x136>
 c043556:	f1b1 4f00 	cmp.w	r1, #2147483648	@ 0x80000000
 c04355a:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 c04355e:	bf08      	it	eq
 c043560:	f020 0001 	biceq.w	r0, r0, #1
 c043564:	ea40 0003 	orr.w	r0, r0, r3
 c043568:	4770      	bx	lr
 c04356a:	0049      	lsls	r1, r1, #1
 c04356c:	eb40 0000 	adc.w	r0, r0, r0
 c043570:	3a01      	subs	r2, #1
 c043572:	bf28      	it	cs
 c043574:	f5b0 0f00 	cmpcs.w	r0, #8388608	@ 0x800000
 c043578:	d2ed      	bcs.n	c043556 <__addsf3+0x92>
 c04357a:	fab0 fc80 	clz	ip, r0
 c04357e:	f1ac 0c08 	sub.w	ip, ip, #8
 c043582:	ebb2 020c 	subs.w	r2, r2, ip
 c043586:	fa00 f00c 	lsl.w	r0, r0, ip
 c04358a:	bfaa      	itet	ge
 c04358c:	eb00 50c2 	addge.w	r0, r0, r2, lsl #23
 c043590:	4252      	neglt	r2, r2
 c043592:	4318      	orrge	r0, r3
 c043594:	bfbc      	itt	lt
 c043596:	40d0      	lsrlt	r0, r2
 c043598:	4318      	orrlt	r0, r3
 c04359a:	4770      	bx	lr
 c04359c:	f092 0f00 	teq	r2, #0
 c0435a0:	f481 0100 	eor.w	r1, r1, #8388608	@ 0x800000
 c0435a4:	bf06      	itte	eq
 c0435a6:	f480 0000 	eoreq.w	r0, r0, #8388608	@ 0x800000
 c0435aa:	3201      	addeq	r2, #1
 c0435ac:	3b01      	subne	r3, #1
 c0435ae:	e7b5      	b.n	c04351c <__addsf3+0x58>
 c0435b0:	ea4f 0341 	mov.w	r3, r1, lsl #1
 c0435b4:	ea7f 6c22 	mvns.w	ip, r2, asr #24
 c0435b8:	bf18      	it	ne
 c0435ba:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 c0435be:	d021      	beq.n	c043604 <__addsf3+0x140>
 c0435c0:	ea92 0f03 	teq	r2, r3
 c0435c4:	d004      	beq.n	c0435d0 <__addsf3+0x10c>
 c0435c6:	f092 0f00 	teq	r2, #0
 c0435ca:	bf08      	it	eq
 c0435cc:	4608      	moveq	r0, r1
 c0435ce:	4770      	bx	lr
 c0435d0:	ea90 0f01 	teq	r0, r1
 c0435d4:	bf1c      	itt	ne
 c0435d6:	2000      	movne	r0, #0
 c0435d8:	4770      	bxne	lr
 c0435da:	f012 4f7f 	tst.w	r2, #4278190080	@ 0xff000000
 c0435de:	d104      	bne.n	c0435ea <__addsf3+0x126>
 c0435e0:	0040      	lsls	r0, r0, #1
 c0435e2:	bf28      	it	cs
 c0435e4:	f040 4000 	orrcs.w	r0, r0, #2147483648	@ 0x80000000
 c0435e8:	4770      	bx	lr
 c0435ea:	f112 7200 	adds.w	r2, r2, #33554432	@ 0x2000000
 c0435ee:	bf3c      	itt	cc
 c0435f0:	f500 0000 	addcc.w	r0, r0, #8388608	@ 0x800000
 c0435f4:	4770      	bxcc	lr
 c0435f6:	f000 4300 	and.w	r3, r0, #2147483648	@ 0x80000000
 c0435fa:	f043 40fe 	orr.w	r0, r3, #2130706432	@ 0x7f000000
 c0435fe:	f440 0000 	orr.w	r0, r0, #8388608	@ 0x800000
 c043602:	4770      	bx	lr
 c043604:	ea7f 6222 	mvns.w	r2, r2, asr #24
 c043608:	bf16      	itet	ne
 c04360a:	4608      	movne	r0, r1
 c04360c:	ea7f 6323 	mvnseq.w	r3, r3, asr #24
 c043610:	4601      	movne	r1, r0
 c043612:	0242      	lsls	r2, r0, #9
 c043614:	bf06      	itte	eq
 c043616:	ea5f 2341 	movseq.w	r3, r1, lsl #9
 c04361a:	ea90 0f01 	teqeq	r0, r1
 c04361e:	f440 0080 	orrne.w	r0, r0, #4194304	@ 0x400000
 c043622:	4770      	bx	lr

0c043624 <__aeabi_ui2f>:
 c043624:	f04f 0300 	mov.w	r3, #0
 c043628:	e004      	b.n	c043634 <__aeabi_i2f+0x8>
 c04362a:	bf00      	nop

0c04362c <__aeabi_i2f>:
 c04362c:	f010 4300 	ands.w	r3, r0, #2147483648	@ 0x80000000
 c043630:	bf48      	it	mi
 c043632:	4240      	negmi	r0, r0
 c043634:	ea5f 0c00 	movs.w	ip, r0
 c043638:	bf08      	it	eq
 c04363a:	4770      	bxeq	lr
 c04363c:	f043 4396 	orr.w	r3, r3, #1258291200	@ 0x4b000000
 c043640:	4601      	mov	r1, r0
 c043642:	f04f 0000 	mov.w	r0, #0
 c043646:	e01c      	b.n	c043682 <__aeabi_l2f+0x2a>

0c043648 <__aeabi_ul2f>:
 c043648:	ea50 0201 	orrs.w	r2, r0, r1
 c04364c:	bf08      	it	eq
 c04364e:	4770      	bxeq	lr
 c043650:	f04f 0300 	mov.w	r3, #0
 c043654:	e00a      	b.n	c04366c <__aeabi_l2f+0x14>
 c043656:	bf00      	nop

0c043658 <__aeabi_l2f>:
 c043658:	ea50 0201 	orrs.w	r2, r0, r1
 c04365c:	bf08      	it	eq
 c04365e:	4770      	bxeq	lr
 c043660:	f011 4300 	ands.w	r3, r1, #2147483648	@ 0x80000000
 c043664:	d502      	bpl.n	c04366c <__aeabi_l2f+0x14>
 c043666:	4240      	negs	r0, r0
 c043668:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 c04366c:	ea5f 0c01 	movs.w	ip, r1
 c043670:	bf02      	ittt	eq
 c043672:	4684      	moveq	ip, r0
 c043674:	4601      	moveq	r1, r0
 c043676:	2000      	moveq	r0, #0
 c043678:	f043 43b6 	orr.w	r3, r3, #1526726656	@ 0x5b000000
 c04367c:	bf08      	it	eq
 c04367e:	f1a3 5380 	subeq.w	r3, r3, #268435456	@ 0x10000000
 c043682:	f5a3 0300 	sub.w	r3, r3, #8388608	@ 0x800000
 c043686:	fabc f28c 	clz	r2, ip
 c04368a:	3a08      	subs	r2, #8
 c04368c:	eba3 53c2 	sub.w	r3, r3, r2, lsl #23
 c043690:	db10      	blt.n	c0436b4 <__aeabi_l2f+0x5c>
 c043692:	fa01 fc02 	lsl.w	ip, r1, r2
 c043696:	4463      	add	r3, ip
 c043698:	fa00 fc02 	lsl.w	ip, r0, r2
 c04369c:	f1c2 0220 	rsb	r2, r2, #32
 c0436a0:	f1bc 4f00 	cmp.w	ip, #2147483648	@ 0x80000000
 c0436a4:	fa20 f202 	lsr.w	r2, r0, r2
 c0436a8:	eb43 0002 	adc.w	r0, r3, r2
 c0436ac:	bf08      	it	eq
 c0436ae:	f020 0001 	biceq.w	r0, r0, #1
 c0436b2:	4770      	bx	lr
 c0436b4:	f102 0220 	add.w	r2, r2, #32
 c0436b8:	fa01 fc02 	lsl.w	ip, r1, r2
 c0436bc:	f1c2 0220 	rsb	r2, r2, #32
 c0436c0:	ea50 004c 	orrs.w	r0, r0, ip, lsl #1
 c0436c4:	fa21 f202 	lsr.w	r2, r1, r2
 c0436c8:	eb43 0002 	adc.w	r0, r3, r2
 c0436cc:	bf08      	it	eq
 c0436ce:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
 c0436d2:	4770      	bx	lr

0c0436d4 <__aeabi_fmul>:
 c0436d4:	f04f 0cff 	mov.w	ip, #255	@ 0xff
 c0436d8:	ea1c 52d0 	ands.w	r2, ip, r0, lsr #23
 c0436dc:	bf1e      	ittt	ne
 c0436de:	ea1c 53d1 	andsne.w	r3, ip, r1, lsr #23
 c0436e2:	ea92 0f0c 	teqne	r2, ip
 c0436e6:	ea93 0f0c 	teqne	r3, ip
 c0436ea:	d06f      	beq.n	c0437cc <__aeabi_fmul+0xf8>
 c0436ec:	441a      	add	r2, r3
 c0436ee:	ea80 0c01 	eor.w	ip, r0, r1
 c0436f2:	0240      	lsls	r0, r0, #9
 c0436f4:	bf18      	it	ne
 c0436f6:	ea5f 2141 	movsne.w	r1, r1, lsl #9
 c0436fa:	d01e      	beq.n	c04373a <__aeabi_fmul+0x66>
 c0436fc:	f04f 6300 	mov.w	r3, #134217728	@ 0x8000000
 c043700:	ea43 1050 	orr.w	r0, r3, r0, lsr #5
 c043704:	ea43 1151 	orr.w	r1, r3, r1, lsr #5
 c043708:	fba0 3101 	umull	r3, r1, r0, r1
 c04370c:	f00c 4000 	and.w	r0, ip, #2147483648	@ 0x80000000
 c043710:	f5b1 0f00 	cmp.w	r1, #8388608	@ 0x800000
 c043714:	bf3e      	ittt	cc
 c043716:	0049      	lslcc	r1, r1, #1
 c043718:	ea41 71d3 	orrcc.w	r1, r1, r3, lsr #31
 c04371c:	005b      	lslcc	r3, r3, #1
 c04371e:	ea40 0001 	orr.w	r0, r0, r1
 c043722:	f162 027f 	sbc.w	r2, r2, #127	@ 0x7f
 c043726:	2afd      	cmp	r2, #253	@ 0xfd
 c043728:	d81d      	bhi.n	c043766 <__aeabi_fmul+0x92>
 c04372a:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
 c04372e:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 c043732:	bf08      	it	eq
 c043734:	f020 0001 	biceq.w	r0, r0, #1
 c043738:	4770      	bx	lr
 c04373a:	f090 0f00 	teq	r0, #0
 c04373e:	f00c 4c00 	and.w	ip, ip, #2147483648	@ 0x80000000
 c043742:	bf08      	it	eq
 c043744:	0249      	lsleq	r1, r1, #9
 c043746:	ea4c 2050 	orr.w	r0, ip, r0, lsr #9
 c04374a:	ea40 2051 	orr.w	r0, r0, r1, lsr #9
 c04374e:	3a7f      	subs	r2, #127	@ 0x7f
 c043750:	bfc2      	ittt	gt
 c043752:	f1d2 03ff 	rsbsgt	r3, r2, #255	@ 0xff
 c043756:	ea40 50c2 	orrgt.w	r0, r0, r2, lsl #23
 c04375a:	4770      	bxgt	lr
 c04375c:	f440 0000 	orr.w	r0, r0, #8388608	@ 0x800000
 c043760:	f04f 0300 	mov.w	r3, #0
 c043764:	3a01      	subs	r2, #1
 c043766:	dc5d      	bgt.n	c043824 <__aeabi_fmul+0x150>
 c043768:	f112 0f19 	cmn.w	r2, #25
 c04376c:	bfdc      	itt	le
 c04376e:	f000 4000 	andle.w	r0, r0, #2147483648	@ 0x80000000
 c043772:	4770      	bxle	lr
 c043774:	f1c2 0200 	rsb	r2, r2, #0
 c043778:	0041      	lsls	r1, r0, #1
 c04377a:	fa21 f102 	lsr.w	r1, r1, r2
 c04377e:	f1c2 0220 	rsb	r2, r2, #32
 c043782:	fa00 fc02 	lsl.w	ip, r0, r2
 c043786:	ea5f 0031 	movs.w	r0, r1, rrx
 c04378a:	f140 0000 	adc.w	r0, r0, #0
 c04378e:	ea53 034c 	orrs.w	r3, r3, ip, lsl #1
 c043792:	bf08      	it	eq
 c043794:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
 c043798:	4770      	bx	lr
 c04379a:	f092 0f00 	teq	r2, #0
 c04379e:	f000 4c00 	and.w	ip, r0, #2147483648	@ 0x80000000
 c0437a2:	bf02      	ittt	eq
 c0437a4:	0040      	lsleq	r0, r0, #1
 c0437a6:	f410 0f00 	tsteq.w	r0, #8388608	@ 0x800000
 c0437aa:	3a01      	subeq	r2, #1
 c0437ac:	d0f9      	beq.n	c0437a2 <__aeabi_fmul+0xce>
 c0437ae:	ea40 000c 	orr.w	r0, r0, ip
 c0437b2:	f093 0f00 	teq	r3, #0
 c0437b6:	f001 4c00 	and.w	ip, r1, #2147483648	@ 0x80000000
 c0437ba:	bf02      	ittt	eq
 c0437bc:	0049      	lsleq	r1, r1, #1
 c0437be:	f411 0f00 	tsteq.w	r1, #8388608	@ 0x800000
 c0437c2:	3b01      	subeq	r3, #1
 c0437c4:	d0f9      	beq.n	c0437ba <__aeabi_fmul+0xe6>
 c0437c6:	ea41 010c 	orr.w	r1, r1, ip
 c0437ca:	e78f      	b.n	c0436ec <__aeabi_fmul+0x18>
 c0437cc:	ea0c 53d1 	and.w	r3, ip, r1, lsr #23
 c0437d0:	ea92 0f0c 	teq	r2, ip
 c0437d4:	bf18      	it	ne
 c0437d6:	ea93 0f0c 	teqne	r3, ip
 c0437da:	d00a      	beq.n	c0437f2 <__aeabi_fmul+0x11e>
 c0437dc:	f030 4c00 	bics.w	ip, r0, #2147483648	@ 0x80000000
 c0437e0:	bf18      	it	ne
 c0437e2:	f031 4c00 	bicsne.w	ip, r1, #2147483648	@ 0x80000000
 c0437e6:	d1d8      	bne.n	c04379a <__aeabi_fmul+0xc6>
 c0437e8:	ea80 0001 	eor.w	r0, r0, r1
 c0437ec:	f000 4000 	and.w	r0, r0, #2147483648	@ 0x80000000
 c0437f0:	4770      	bx	lr
 c0437f2:	f090 0f00 	teq	r0, #0
 c0437f6:	bf17      	itett	ne
 c0437f8:	f090 4f00 	teqne	r0, #2147483648	@ 0x80000000
 c0437fc:	4608      	moveq	r0, r1
 c0437fe:	f091 0f00 	teqne	r1, #0
 c043802:	f091 4f00 	teqne	r1, #2147483648	@ 0x80000000
 c043806:	d014      	beq.n	c043832 <__aeabi_fmul+0x15e>
 c043808:	ea92 0f0c 	teq	r2, ip
 c04380c:	d101      	bne.n	c043812 <__aeabi_fmul+0x13e>
 c04380e:	0242      	lsls	r2, r0, #9
 c043810:	d10f      	bne.n	c043832 <__aeabi_fmul+0x15e>
 c043812:	ea93 0f0c 	teq	r3, ip
 c043816:	d103      	bne.n	c043820 <__aeabi_fmul+0x14c>
 c043818:	024b      	lsls	r3, r1, #9
 c04381a:	bf18      	it	ne
 c04381c:	4608      	movne	r0, r1
 c04381e:	d108      	bne.n	c043832 <__aeabi_fmul+0x15e>
 c043820:	ea80 0001 	eor.w	r0, r0, r1
 c043824:	f000 4000 	and.w	r0, r0, #2147483648	@ 0x80000000
 c043828:	f040 40fe 	orr.w	r0, r0, #2130706432	@ 0x7f000000
 c04382c:	f440 0000 	orr.w	r0, r0, #8388608	@ 0x800000
 c043830:	4770      	bx	lr
 c043832:	f040 40fe 	orr.w	r0, r0, #2130706432	@ 0x7f000000
 c043836:	f440 0040 	orr.w	r0, r0, #12582912	@ 0xc00000
 c04383a:	4770      	bx	lr

0c04383c <__aeabi_fdiv>:
 c04383c:	f04f 0cff 	mov.w	ip, #255	@ 0xff
 c043840:	ea1c 52d0 	ands.w	r2, ip, r0, lsr #23
 c043844:	bf1e      	ittt	ne
 c043846:	ea1c 53d1 	andsne.w	r3, ip, r1, lsr #23
 c04384a:	ea92 0f0c 	teqne	r2, ip
 c04384e:	ea93 0f0c 	teqne	r3, ip
 c043852:	d069      	beq.n	c043928 <__aeabi_fdiv+0xec>
 c043854:	eba2 0203 	sub.w	r2, r2, r3
 c043858:	ea80 0c01 	eor.w	ip, r0, r1
 c04385c:	0249      	lsls	r1, r1, #9
 c04385e:	ea4f 2040 	mov.w	r0, r0, lsl #9
 c043862:	d037      	beq.n	c0438d4 <__aeabi_fdiv+0x98>
 c043864:	f04f 5380 	mov.w	r3, #268435456	@ 0x10000000
 c043868:	ea43 1111 	orr.w	r1, r3, r1, lsr #4
 c04386c:	ea43 1310 	orr.w	r3, r3, r0, lsr #4
 c043870:	f00c 4000 	and.w	r0, ip, #2147483648	@ 0x80000000
 c043874:	428b      	cmp	r3, r1
 c043876:	bf38      	it	cc
 c043878:	005b      	lslcc	r3, r3, #1
 c04387a:	f142 027d 	adc.w	r2, r2, #125	@ 0x7d
 c04387e:	f44f 0c00 	mov.w	ip, #8388608	@ 0x800000
 c043882:	428b      	cmp	r3, r1
 c043884:	bf24      	itt	cs
 c043886:	1a5b      	subcs	r3, r3, r1
 c043888:	ea40 000c 	orrcs.w	r0, r0, ip
 c04388c:	ebb3 0f51 	cmp.w	r3, r1, lsr #1
 c043890:	bf24      	itt	cs
 c043892:	eba3 0351 	subcs.w	r3, r3, r1, lsr #1
 c043896:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 c04389a:	ebb3 0f91 	cmp.w	r3, r1, lsr #2
 c04389e:	bf24      	itt	cs
 c0438a0:	eba3 0391 	subcs.w	r3, r3, r1, lsr #2
 c0438a4:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 c0438a8:	ebb3 0fd1 	cmp.w	r3, r1, lsr #3
 c0438ac:	bf24      	itt	cs
 c0438ae:	eba3 03d1 	subcs.w	r3, r3, r1, lsr #3
 c0438b2:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 c0438b6:	011b      	lsls	r3, r3, #4
 c0438b8:	bf18      	it	ne
 c0438ba:	ea5f 1c1c 	movsne.w	ip, ip, lsr #4
 c0438be:	d1e0      	bne.n	c043882 <__aeabi_fdiv+0x46>
 c0438c0:	2afd      	cmp	r2, #253	@ 0xfd
 c0438c2:	f63f af50 	bhi.w	c043766 <__aeabi_fmul+0x92>
 c0438c6:	428b      	cmp	r3, r1
 c0438c8:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 c0438cc:	bf08      	it	eq
 c0438ce:	f020 0001 	biceq.w	r0, r0, #1
 c0438d2:	4770      	bx	lr
 c0438d4:	f00c 4c00 	and.w	ip, ip, #2147483648	@ 0x80000000
 c0438d8:	ea4c 2050 	orr.w	r0, ip, r0, lsr #9
 c0438dc:	327f      	adds	r2, #127	@ 0x7f
 c0438de:	bfc2      	ittt	gt
 c0438e0:	f1d2 03ff 	rsbsgt	r3, r2, #255	@ 0xff
 c0438e4:	ea40 50c2 	orrgt.w	r0, r0, r2, lsl #23
 c0438e8:	4770      	bxgt	lr
 c0438ea:	f440 0000 	orr.w	r0, r0, #8388608	@ 0x800000
 c0438ee:	f04f 0300 	mov.w	r3, #0
 c0438f2:	3a01      	subs	r2, #1
 c0438f4:	e737      	b.n	c043766 <__aeabi_fmul+0x92>
 c0438f6:	f092 0f00 	teq	r2, #0
 c0438fa:	f000 4c00 	and.w	ip, r0, #2147483648	@ 0x80000000
 c0438fe:	bf02      	ittt	eq
 c043900:	0040      	lsleq	r0, r0, #1
 c043902:	f410 0f00 	tsteq.w	r0, #8388608	@ 0x800000
 c043906:	3a01      	subeq	r2, #1
 c043908:	d0f9      	beq.n	c0438fe <__aeabi_fdiv+0xc2>
 c04390a:	ea40 000c 	orr.w	r0, r0, ip
 c04390e:	f093 0f00 	teq	r3, #0
 c043912:	f001 4c00 	and.w	ip, r1, #2147483648	@ 0x80000000
 c043916:	bf02      	ittt	eq
 c043918:	0049      	lsleq	r1, r1, #1
 c04391a:	f411 0f00 	tsteq.w	r1, #8388608	@ 0x800000
 c04391e:	3b01      	subeq	r3, #1
 c043920:	d0f9      	beq.n	c043916 <__aeabi_fdiv+0xda>
 c043922:	ea41 010c 	orr.w	r1, r1, ip
 c043926:	e795      	b.n	c043854 <__aeabi_fdiv+0x18>
 c043928:	ea0c 53d1 	and.w	r3, ip, r1, lsr #23
 c04392c:	ea92 0f0c 	teq	r2, ip
 c043930:	d108      	bne.n	c043944 <__aeabi_fdiv+0x108>
 c043932:	0242      	lsls	r2, r0, #9
 c043934:	f47f af7d 	bne.w	c043832 <__aeabi_fmul+0x15e>
 c043938:	ea93 0f0c 	teq	r3, ip
 c04393c:	f47f af70 	bne.w	c043820 <__aeabi_fmul+0x14c>
 c043940:	4608      	mov	r0, r1
 c043942:	e776      	b.n	c043832 <__aeabi_fmul+0x15e>
 c043944:	ea93 0f0c 	teq	r3, ip
 c043948:	d104      	bne.n	c043954 <__aeabi_fdiv+0x118>
 c04394a:	024b      	lsls	r3, r1, #9
 c04394c:	f43f af4c 	beq.w	c0437e8 <__aeabi_fmul+0x114>
 c043950:	4608      	mov	r0, r1
 c043952:	e76e      	b.n	c043832 <__aeabi_fmul+0x15e>
 c043954:	f030 4c00 	bics.w	ip, r0, #2147483648	@ 0x80000000
 c043958:	bf18      	it	ne
 c04395a:	f031 4c00 	bicsne.w	ip, r1, #2147483648	@ 0x80000000
 c04395e:	d1ca      	bne.n	c0438f6 <__aeabi_fdiv+0xba>
 c043960:	f030 4200 	bics.w	r2, r0, #2147483648	@ 0x80000000
 c043964:	f47f af5c 	bne.w	c043820 <__aeabi_fmul+0x14c>
 c043968:	f031 4300 	bics.w	r3, r1, #2147483648	@ 0x80000000
 c04396c:	f47f af3c 	bne.w	c0437e8 <__aeabi_fmul+0x114>
 c043970:	e75f      	b.n	c043832 <__aeabi_fmul+0x15e>
 c043972:	bf00      	nop

0c043974 <__aeabi_f2uiz>:
 c043974:	0042      	lsls	r2, r0, #1
 c043976:	d20e      	bcs.n	c043996 <__aeabi_f2uiz+0x22>
 c043978:	f1b2 4ffe 	cmp.w	r2, #2130706432	@ 0x7f000000
 c04397c:	d30b      	bcc.n	c043996 <__aeabi_f2uiz+0x22>
 c04397e:	f04f 039e 	mov.w	r3, #158	@ 0x9e
 c043982:	ebb3 6212 	subs.w	r2, r3, r2, lsr #24
 c043986:	d409      	bmi.n	c04399c <__aeabi_f2uiz+0x28>
 c043988:	ea4f 2300 	mov.w	r3, r0, lsl #8
 c04398c:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
 c043990:	fa23 f002 	lsr.w	r0, r3, r2
 c043994:	4770      	bx	lr
 c043996:	f04f 0000 	mov.w	r0, #0
 c04399a:	4770      	bx	lr
 c04399c:	f112 0f61 	cmn.w	r2, #97	@ 0x61
 c0439a0:	d101      	bne.n	c0439a6 <__aeabi_f2uiz+0x32>
 c0439a2:	0242      	lsls	r2, r0, #9
 c0439a4:	d102      	bne.n	c0439ac <__aeabi_f2uiz+0x38>
 c0439a6:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 c0439aa:	4770      	bx	lr
 c0439ac:	f04f 0000 	mov.w	r0, #0
 c0439b0:	4770      	bx	lr
 c0439b2:	bf00      	nop

0c0439b4 <__aeabi_uldivmod>:
 c0439b4:	b953      	cbnz	r3, c0439cc <__aeabi_uldivmod+0x18>
 c0439b6:	b94a      	cbnz	r2, c0439cc <__aeabi_uldivmod+0x18>
 c0439b8:	2900      	cmp	r1, #0
 c0439ba:	bf08      	it	eq
 c0439bc:	2800      	cmpeq	r0, #0
 c0439be:	bf1c      	itt	ne
 c0439c0:	f04f 31ff 	movne.w	r1, #4294967295	@ 0xffffffff
 c0439c4:	f04f 30ff 	movne.w	r0, #4294967295	@ 0xffffffff
 c0439c8:	f000 b97e 	b.w	c043cc8 <__aeabi_idiv0>
 c0439cc:	f1ad 0c08 	sub.w	ip, sp, #8
 c0439d0:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 c0439d4:	f000 f806 	bl	c0439e4 <__udivmoddi4>
 c0439d8:	f8dd e004 	ldr.w	lr, [sp, #4]
 c0439dc:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 c0439e0:	b004      	add	sp, #16
 c0439e2:	4770      	bx	lr

0c0439e4 <__udivmoddi4>:
 c0439e4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c0439e8:	9d09      	ldr	r5, [sp, #36]	@ 0x24
 c0439ea:	460c      	mov	r4, r1
 c0439ec:	2b00      	cmp	r3, #0
 c0439ee:	d14d      	bne.n	c043a8c <__udivmoddi4+0xa8>
 c0439f0:	428a      	cmp	r2, r1
 c0439f2:	460f      	mov	r7, r1
 c0439f4:	4684      	mov	ip, r0
 c0439f6:	4696      	mov	lr, r2
 c0439f8:	fab2 f382 	clz	r3, r2
 c0439fc:	d960      	bls.n	c043ac0 <__udivmoddi4+0xdc>
 c0439fe:	b14b      	cbz	r3, c043a14 <__udivmoddi4+0x30>
 c043a00:	fa02 fe03 	lsl.w	lr, r2, r3
 c043a04:	f1c3 0220 	rsb	r2, r3, #32
 c043a08:	409f      	lsls	r7, r3
 c043a0a:	fa00 fc03 	lsl.w	ip, r0, r3
 c043a0e:	fa20 f202 	lsr.w	r2, r0, r2
 c043a12:	4317      	orrs	r7, r2
 c043a14:	ea4f 461e 	mov.w	r6, lr, lsr #16
 c043a18:	fa1f f48e 	uxth.w	r4, lr
 c043a1c:	ea4f 421c 	mov.w	r2, ip, lsr #16
 c043a20:	fbb7 f1f6 	udiv	r1, r7, r6
 c043a24:	fb06 7711 	mls	r7, r6, r1, r7
 c043a28:	fb01 f004 	mul.w	r0, r1, r4
 c043a2c:	ea42 4207 	orr.w	r2, r2, r7, lsl #16
 c043a30:	4290      	cmp	r0, r2
 c043a32:	d908      	bls.n	c043a46 <__udivmoddi4+0x62>
 c043a34:	eb1e 0202 	adds.w	r2, lr, r2
 c043a38:	f101 37ff 	add.w	r7, r1, #4294967295	@ 0xffffffff
 c043a3c:	d202      	bcs.n	c043a44 <__udivmoddi4+0x60>
 c043a3e:	4290      	cmp	r0, r2
 c043a40:	f200 812d 	bhi.w	c043c9e <__udivmoddi4+0x2ba>
 c043a44:	4639      	mov	r1, r7
 c043a46:	1a12      	subs	r2, r2, r0
 c043a48:	fa1f fc8c 	uxth.w	ip, ip
 c043a4c:	fbb2 f0f6 	udiv	r0, r2, r6
 c043a50:	fb06 2210 	mls	r2, r6, r0, r2
 c043a54:	fb00 f404 	mul.w	r4, r0, r4
 c043a58:	ea4c 4c02 	orr.w	ip, ip, r2, lsl #16
 c043a5c:	4564      	cmp	r4, ip
 c043a5e:	d908      	bls.n	c043a72 <__udivmoddi4+0x8e>
 c043a60:	eb1e 0c0c 	adds.w	ip, lr, ip
 c043a64:	f100 32ff 	add.w	r2, r0, #4294967295	@ 0xffffffff
 c043a68:	d202      	bcs.n	c043a70 <__udivmoddi4+0x8c>
 c043a6a:	4564      	cmp	r4, ip
 c043a6c:	f200 811a 	bhi.w	c043ca4 <__udivmoddi4+0x2c0>
 c043a70:	4610      	mov	r0, r2
 c043a72:	ea40 4001 	orr.w	r0, r0, r1, lsl #16
 c043a76:	ebac 0c04 	sub.w	ip, ip, r4
 c043a7a:	2100      	movs	r1, #0
 c043a7c:	b125      	cbz	r5, c043a88 <__udivmoddi4+0xa4>
 c043a7e:	fa2c f303 	lsr.w	r3, ip, r3
 c043a82:	2200      	movs	r2, #0
 c043a84:	e9c5 3200 	strd	r3, r2, [r5]
 c043a88:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 c043a8c:	428b      	cmp	r3, r1
 c043a8e:	d905      	bls.n	c043a9c <__udivmoddi4+0xb8>
 c043a90:	b10d      	cbz	r5, c043a96 <__udivmoddi4+0xb2>
 c043a92:	e9c5 0100 	strd	r0, r1, [r5]
 c043a96:	2100      	movs	r1, #0
 c043a98:	4608      	mov	r0, r1
 c043a9a:	e7f5      	b.n	c043a88 <__udivmoddi4+0xa4>
 c043a9c:	fab3 f183 	clz	r1, r3
 c043aa0:	2900      	cmp	r1, #0
 c043aa2:	d14d      	bne.n	c043b40 <__udivmoddi4+0x15c>
 c043aa4:	42a3      	cmp	r3, r4
 c043aa6:	f0c0 80f2 	bcc.w	c043c8e <__udivmoddi4+0x2aa>
 c043aaa:	4290      	cmp	r0, r2
 c043aac:	f080 80ef 	bcs.w	c043c8e <__udivmoddi4+0x2aa>
 c043ab0:	4606      	mov	r6, r0
 c043ab2:	4623      	mov	r3, r4
 c043ab4:	4608      	mov	r0, r1
 c043ab6:	2d00      	cmp	r5, #0
 c043ab8:	d0e6      	beq.n	c043a88 <__udivmoddi4+0xa4>
 c043aba:	e9c5 6300 	strd	r6, r3, [r5]
 c043abe:	e7e3      	b.n	c043a88 <__udivmoddi4+0xa4>
 c043ac0:	2b00      	cmp	r3, #0
 c043ac2:	f040 80a2 	bne.w	c043c0a <__udivmoddi4+0x226>
 c043ac6:	1a8a      	subs	r2, r1, r2
 c043ac8:	ea4f 471e 	mov.w	r7, lr, lsr #16
 c043acc:	fa1f f68e 	uxth.w	r6, lr
 c043ad0:	2101      	movs	r1, #1
 c043ad2:	fbb2 f4f7 	udiv	r4, r2, r7
 c043ad6:	fb07 2014 	mls	r0, r7, r4, r2
 c043ada:	ea4f 421c 	mov.w	r2, ip, lsr #16
 c043ade:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
 c043ae2:	fb06 f004 	mul.w	r0, r6, r4
 c043ae6:	4290      	cmp	r0, r2
 c043ae8:	d90f      	bls.n	c043b0a <__udivmoddi4+0x126>
 c043aea:	eb1e 0202 	adds.w	r2, lr, r2
 c043aee:	f104 38ff 	add.w	r8, r4, #4294967295	@ 0xffffffff
 c043af2:	bf2c      	ite	cs
 c043af4:	f04f 0901 	movcs.w	r9, #1
 c043af8:	f04f 0900 	movcc.w	r9, #0
 c043afc:	4290      	cmp	r0, r2
 c043afe:	d903      	bls.n	c043b08 <__udivmoddi4+0x124>
 c043b00:	f1b9 0f00 	cmp.w	r9, #0
 c043b04:	f000 80c8 	beq.w	c043c98 <__udivmoddi4+0x2b4>
 c043b08:	4644      	mov	r4, r8
 c043b0a:	1a12      	subs	r2, r2, r0
 c043b0c:	fa1f fc8c 	uxth.w	ip, ip
 c043b10:	fbb2 f0f7 	udiv	r0, r2, r7
 c043b14:	fb07 2210 	mls	r2, r7, r0, r2
 c043b18:	fb00 f606 	mul.w	r6, r0, r6
 c043b1c:	ea4c 4c02 	orr.w	ip, ip, r2, lsl #16
 c043b20:	4566      	cmp	r6, ip
 c043b22:	d908      	bls.n	c043b36 <__udivmoddi4+0x152>
 c043b24:	eb1e 0c0c 	adds.w	ip, lr, ip
 c043b28:	f100 32ff 	add.w	r2, r0, #4294967295	@ 0xffffffff
 c043b2c:	d202      	bcs.n	c043b34 <__udivmoddi4+0x150>
 c043b2e:	4566      	cmp	r6, ip
 c043b30:	f200 80bb 	bhi.w	c043caa <__udivmoddi4+0x2c6>
 c043b34:	4610      	mov	r0, r2
 c043b36:	ebac 0c06 	sub.w	ip, ip, r6
 c043b3a:	ea40 4004 	orr.w	r0, r0, r4, lsl #16
 c043b3e:	e79d      	b.n	c043a7c <__udivmoddi4+0x98>
 c043b40:	f1c1 0620 	rsb	r6, r1, #32
 c043b44:	408b      	lsls	r3, r1
 c043b46:	fa04 fe01 	lsl.w	lr, r4, r1
 c043b4a:	fa22 f706 	lsr.w	r7, r2, r6
 c043b4e:	fa20 fc06 	lsr.w	ip, r0, r6
 c043b52:	40f4      	lsrs	r4, r6
 c043b54:	408a      	lsls	r2, r1
 c043b56:	431f      	orrs	r7, r3
 c043b58:	ea4e 030c 	orr.w	r3, lr, ip
 c043b5c:	fa00 fe01 	lsl.w	lr, r0, r1
 c043b60:	ea4f 4817 	mov.w	r8, r7, lsr #16
 c043b64:	ea4f 4913 	mov.w	r9, r3, lsr #16
 c043b68:	fa1f fc87 	uxth.w	ip, r7
 c043b6c:	fbb4 f0f8 	udiv	r0, r4, r8
 c043b70:	fb08 4410 	mls	r4, r8, r0, r4
 c043b74:	ea49 4404 	orr.w	r4, r9, r4, lsl #16
 c043b78:	fb00 f90c 	mul.w	r9, r0, ip
 c043b7c:	45a1      	cmp	r9, r4
 c043b7e:	d90e      	bls.n	c043b9e <__udivmoddi4+0x1ba>
 c043b80:	193c      	adds	r4, r7, r4
 c043b82:	f100 3aff 	add.w	sl, r0, #4294967295	@ 0xffffffff
 c043b86:	bf2c      	ite	cs
 c043b88:	f04f 0b01 	movcs.w	fp, #1
 c043b8c:	f04f 0b00 	movcc.w	fp, #0
 c043b90:	45a1      	cmp	r9, r4
 c043b92:	d903      	bls.n	c043b9c <__udivmoddi4+0x1b8>
 c043b94:	f1bb 0f00 	cmp.w	fp, #0
 c043b98:	f000 8093 	beq.w	c043cc2 <__udivmoddi4+0x2de>
 c043b9c:	4650      	mov	r0, sl
 c043b9e:	eba4 0409 	sub.w	r4, r4, r9
 c043ba2:	fa1f f983 	uxth.w	r9, r3
 c043ba6:	fbb4 f3f8 	udiv	r3, r4, r8
 c043baa:	fb08 4413 	mls	r4, r8, r3, r4
 c043bae:	fb03 fc0c 	mul.w	ip, r3, ip
 c043bb2:	ea49 4404 	orr.w	r4, r9, r4, lsl #16
 c043bb6:	45a4      	cmp	ip, r4
 c043bb8:	d906      	bls.n	c043bc8 <__udivmoddi4+0x1e4>
 c043bba:	193c      	adds	r4, r7, r4
 c043bbc:	f103 38ff 	add.w	r8, r3, #4294967295	@ 0xffffffff
 c043bc0:	d201      	bcs.n	c043bc6 <__udivmoddi4+0x1e2>
 c043bc2:	45a4      	cmp	ip, r4
 c043bc4:	d87a      	bhi.n	c043cbc <__udivmoddi4+0x2d8>
 c043bc6:	4643      	mov	r3, r8
 c043bc8:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
 c043bcc:	eba4 040c 	sub.w	r4, r4, ip
 c043bd0:	fba0 9802 	umull	r9, r8, r0, r2
 c043bd4:	4544      	cmp	r4, r8
 c043bd6:	46cc      	mov	ip, r9
 c043bd8:	4643      	mov	r3, r8
 c043bda:	d302      	bcc.n	c043be2 <__udivmoddi4+0x1fe>
 c043bdc:	d106      	bne.n	c043bec <__udivmoddi4+0x208>
 c043bde:	45ce      	cmp	lr, r9
 c043be0:	d204      	bcs.n	c043bec <__udivmoddi4+0x208>
 c043be2:	3801      	subs	r0, #1
 c043be4:	ebb9 0c02 	subs.w	ip, r9, r2
 c043be8:	eb68 0307 	sbc.w	r3, r8, r7
 c043bec:	b15d      	cbz	r5, c043c06 <__udivmoddi4+0x222>
 c043bee:	ebbe 020c 	subs.w	r2, lr, ip
 c043bf2:	eb64 0403 	sbc.w	r4, r4, r3
 c043bf6:	fa04 f606 	lsl.w	r6, r4, r6
 c043bfa:	fa22 f301 	lsr.w	r3, r2, r1
 c043bfe:	40cc      	lsrs	r4, r1
 c043c00:	431e      	orrs	r6, r3
 c043c02:	e9c5 6400 	strd	r6, r4, [r5]
 c043c06:	2100      	movs	r1, #0
 c043c08:	e73e      	b.n	c043a88 <__udivmoddi4+0xa4>
 c043c0a:	fa02 fe03 	lsl.w	lr, r2, r3
 c043c0e:	f1c3 0120 	rsb	r1, r3, #32
 c043c12:	fa04 f203 	lsl.w	r2, r4, r3
 c043c16:	fa00 fc03 	lsl.w	ip, r0, r3
 c043c1a:	40cc      	lsrs	r4, r1
 c043c1c:	ea4f 471e 	mov.w	r7, lr, lsr #16
 c043c20:	fa20 f101 	lsr.w	r1, r0, r1
 c043c24:	fa1f f68e 	uxth.w	r6, lr
 c043c28:	fbb4 f0f7 	udiv	r0, r4, r7
 c043c2c:	430a      	orrs	r2, r1
 c043c2e:	fb07 4410 	mls	r4, r7, r0, r4
 c043c32:	0c11      	lsrs	r1, r2, #16
 c043c34:	ea41 4104 	orr.w	r1, r1, r4, lsl #16
 c043c38:	fb00 f406 	mul.w	r4, r0, r6
 c043c3c:	428c      	cmp	r4, r1
 c043c3e:	d90e      	bls.n	c043c5e <__udivmoddi4+0x27a>
 c043c40:	eb1e 0101 	adds.w	r1, lr, r1
 c043c44:	f100 38ff 	add.w	r8, r0, #4294967295	@ 0xffffffff
 c043c48:	bf2c      	ite	cs
 c043c4a:	f04f 0901 	movcs.w	r9, #1
 c043c4e:	f04f 0900 	movcc.w	r9, #0
 c043c52:	428c      	cmp	r4, r1
 c043c54:	d902      	bls.n	c043c5c <__udivmoddi4+0x278>
 c043c56:	f1b9 0f00 	cmp.w	r9, #0
 c043c5a:	d02c      	beq.n	c043cb6 <__udivmoddi4+0x2d2>
 c043c5c:	4640      	mov	r0, r8
 c043c5e:	1b09      	subs	r1, r1, r4
 c043c60:	b292      	uxth	r2, r2
 c043c62:	fbb1 f4f7 	udiv	r4, r1, r7
 c043c66:	fb07 1114 	mls	r1, r7, r4, r1
 c043c6a:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 c043c6e:	fb04 f106 	mul.w	r1, r4, r6
 c043c72:	4291      	cmp	r1, r2
 c043c74:	d907      	bls.n	c043c86 <__udivmoddi4+0x2a2>
 c043c76:	eb1e 0202 	adds.w	r2, lr, r2
 c043c7a:	f104 38ff 	add.w	r8, r4, #4294967295	@ 0xffffffff
 c043c7e:	d201      	bcs.n	c043c84 <__udivmoddi4+0x2a0>
 c043c80:	4291      	cmp	r1, r2
 c043c82:	d815      	bhi.n	c043cb0 <__udivmoddi4+0x2cc>
 c043c84:	4644      	mov	r4, r8
 c043c86:	1a52      	subs	r2, r2, r1
 c043c88:	ea44 4100 	orr.w	r1, r4, r0, lsl #16
 c043c8c:	e721      	b.n	c043ad2 <__udivmoddi4+0xee>
 c043c8e:	1a86      	subs	r6, r0, r2
 c043c90:	eb64 0303 	sbc.w	r3, r4, r3
 c043c94:	2001      	movs	r0, #1
 c043c96:	e70e      	b.n	c043ab6 <__udivmoddi4+0xd2>
 c043c98:	3c02      	subs	r4, #2
 c043c9a:	4472      	add	r2, lr
 c043c9c:	e735      	b.n	c043b0a <__udivmoddi4+0x126>
 c043c9e:	3902      	subs	r1, #2
 c043ca0:	4472      	add	r2, lr
 c043ca2:	e6d0      	b.n	c043a46 <__udivmoddi4+0x62>
 c043ca4:	44f4      	add	ip, lr
 c043ca6:	3802      	subs	r0, #2
 c043ca8:	e6e3      	b.n	c043a72 <__udivmoddi4+0x8e>
 c043caa:	44f4      	add	ip, lr
 c043cac:	3802      	subs	r0, #2
 c043cae:	e742      	b.n	c043b36 <__udivmoddi4+0x152>
 c043cb0:	3c02      	subs	r4, #2
 c043cb2:	4472      	add	r2, lr
 c043cb4:	e7e7      	b.n	c043c86 <__udivmoddi4+0x2a2>
 c043cb6:	3802      	subs	r0, #2
 c043cb8:	4471      	add	r1, lr
 c043cba:	e7d0      	b.n	c043c5e <__udivmoddi4+0x27a>
 c043cbc:	3b02      	subs	r3, #2
 c043cbe:	443c      	add	r4, r7
 c043cc0:	e782      	b.n	c043bc8 <__udivmoddi4+0x1e4>
 c043cc2:	3802      	subs	r0, #2
 c043cc4:	443c      	add	r4, r7
 c043cc6:	e76a      	b.n	c043b9e <__udivmoddi4+0x1ba>

0c043cc8 <__aeabi_idiv0>:
 c043cc8:	4770      	bx	lr
 c043cca:	bf00      	nop

0c043ccc <HAL_InitTick>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
  /* load 1Hz for timeout 1 second */
  uint32_t ticks = SystemCoreClock ;
 c043ccc:	4b05      	ldr	r3, [pc, #20]	@ (c043ce4 <HAL_InitTick+0x18>)
  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 c043cce:	2000      	movs	r0, #0
  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 c043cd0:	681a      	ldr	r2, [r3, #0]
 c043cd2:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 c043cd6:	3a01      	subs	r2, #1
 c043cd8:	615a      	str	r2, [r3, #20]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 c043cda:	2205      	movs	r2, #5
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 c043cdc:	6198      	str	r0, [r3, #24]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 c043cde:	611a      	str	r2, [r3, #16]
                   SysTick_CTRL_ENABLE_Msk;
  return HAL_OK;
}
 c043ce0:	4770      	bx	lr
 c043ce2:	bf00      	nop
 c043ce4:	300308e4 	.word	0x300308e4

0c043ce8 <HAL_GetTick>:
  * @note This function overwrites the one declared as __weak in HAL.
  *       In this implementation, time is counted without using SysTick timer interrupts.
  * @retval tick value
  */
uint32_t HAL_GetTick(void)
{
 c043ce8:	b537      	push	{r0, r1, r2, r4, r5, lr}
  static uint32_t m_uTick = 0U;
  static uint32_t t1 = 0U, tdelta = 0U;
  uint32_t t2;
  /* device specific behaviour for HAL_GetTick */
  DEVICE_GET_TICK;
 c043cea:	2000      	movs	r0, #0
 c043cec:	4b12      	ldr	r3, [pc, #72]	@ (c043d38 <HAL_GetTick+0x50>)
 c043cee:	aa01      	add	r2, sp, #4
 c043cf0:	429a      	cmp	r2, r3
 c043cf2:	9001      	str	r0, [sp, #4]
 c043cf4:	d21d      	bcs.n	c043d32 <HAL_GetTick+0x4a>
  t2 =  SysTick->VAL;
 c043cf6:	f04f 21e0 	mov.w	r1, #3758153728	@ 0xe000e000

  if (t2 <= t1)
  {
    tdelta += t1 - t2;
 c043cfa:	4810      	ldr	r0, [pc, #64]	@ (c043d3c <HAL_GetTick+0x54>)
  if (t2 <= t1)
 c043cfc:	4c10      	ldr	r4, [pc, #64]	@ (c043d40 <HAL_GetTick+0x58>)
  t2 =  SysTick->VAL;
 c043cfe:	698a      	ldr	r2, [r1, #24]
    tdelta += t1 - t2;
 c043d00:	6805      	ldr	r5, [r0, #0]
  if (t2 <= t1)
 c043d02:	6823      	ldr	r3, [r4, #0]
 c043d04:	4293      	cmp	r3, r2
 c043d06:	442b      	add	r3, r5
  else
  {
    tdelta += t1 + SysTick->LOAD - t2;
  }

  if (tdelta > (SystemCoreClock / (1000U)))
 c043d08:	f44f 757a 	mov.w	r5, #1000	@ 0x3e8
    tdelta += t1 + SysTick->LOAD - t2;
 c043d0c:	bf3c      	itt	cc
 c043d0e:	6949      	ldrcc	r1, [r1, #20]
 c043d10:	185b      	addcc	r3, r3, r1
  if (tdelta > (SystemCoreClock / (1000U)))
 c043d12:	490c      	ldr	r1, [pc, #48]	@ (c043d44 <HAL_GetTick+0x5c>)
    tdelta += t1 + SysTick->LOAD - t2;
 c043d14:	1a9b      	subs	r3, r3, r2
  if (tdelta > (SystemCoreClock / (1000U)))
 c043d16:	6809      	ldr	r1, [r1, #0]
 c043d18:	6003      	str	r3, [r0, #0]
 c043d1a:	fbb1 f1f5 	udiv	r1, r1, r5
 c043d1e:	4299      	cmp	r1, r3
 c043d20:	4b09      	ldr	r3, [pc, #36]	@ (c043d48 <HAL_GetTick+0x60>)
 c043d22:	d204      	bcs.n	c043d2e <HAL_GetTick+0x46>
  {
    tdelta = 0U;
 c043d24:	2500      	movs	r5, #0
    m_uTick ++;
 c043d26:	6819      	ldr	r1, [r3, #0]
    tdelta = 0U;
 c043d28:	6005      	str	r5, [r0, #0]
    m_uTick ++;
 c043d2a:	3101      	adds	r1, #1
 c043d2c:	6019      	str	r1, [r3, #0]
  }

  t1 = t2;
  return m_uTick;
 c043d2e:	6818      	ldr	r0, [r3, #0]
  t1 = t2;
 c043d30:	6022      	str	r2, [r4, #0]
}
 c043d32:	b003      	add	sp, #12
 c043d34:	bd30      	pop	{r4, r5, pc}
 c043d36:	bf00      	nop
 c043d38:	3003ea00 	.word	0x3003ea00
 c043d3c:	30030ed4 	.word	0x30030ed4
 c043d40:	30030ed8 	.word	0x30030ed8
 c043d44:	300308e4 	.word	0x300308e4
 c043d48:	30030ed0 	.word	0x30030ed0
	...

Disassembly of section .TFM_SP_PS_RO:

0c043d60 <key_type_is_raw_bytes>:
/* Global data, support functions and library management */
/****************************************************************/

static int key_type_is_raw_bytes( psa_key_type_t type )
{
    return( PSA_KEY_TYPE_IS_UNSTRUCTURED( type ) );
 c043d60:	f400 40e0 	and.w	r0, r0, #28672	@ 0x7000
 c043d64:	f5b0 5f80 	cmp.w	r0, #4096	@ 0x1000
 c043d68:	d004      	beq.n	c043d74 <key_type_is_raw_bytes+0x14>
 c043d6a:	f5a0 5300 	sub.w	r3, r0, #8192	@ 0x2000
 c043d6e:	4258      	negs	r0, r3
 c043d70:	4158      	adcs	r0, r3
 c043d72:	4770      	bx	lr
 c043d74:	2001      	movs	r0, #1
}
 c043d76:	4770      	bx	lr

0c043d78 <psa_mac_key_can_do>:
 */
MBEDTLS_STATIC_TESTABLE psa_status_t psa_mac_key_can_do(
    psa_algorithm_t algorithm,
    psa_key_type_t key_type )
{
    if( PSA_ALG_IS_HMAC( algorithm ) )
 c043d78:	4b0e      	ldr	r3, [pc, #56]	@ (c043db4 <psa_mac_key_can_do+0x3c>)
 c043d7a:	4003      	ands	r3, r0
 c043d7c:	f1b3 7f60 	cmp.w	r3, #58720256	@ 0x3800000
 c043d80:	d106      	bne.n	c043d90 <psa_mac_key_can_do+0x18>
    {
        if( key_type == PSA_KEY_TYPE_HMAC )
            return( PSA_SUCCESS );
 c043d82:	f5b1 5f88 	cmp.w	r1, #4352	@ 0x1100
 c043d86:	bf14      	ite	ne
 c043d88:	f06f 0086 	mvnne.w	r0, #134	@ 0x86
 c043d8c:	2000      	moveq	r0, #0
 c043d8e:	4770      	bx	lr
    }

    if( PSA_ALG_IS_BLOCK_CIPHER_MAC( algorithm ) )
 c043d90:	f1b3 7f70 	cmp.w	r3, #62914560	@ 0x3c00000
 c043d94:	d10b      	bne.n	c043dae <psa_mac_key_can_do+0x36>
    {
        /* Check that we're calling PSA_BLOCK_CIPHER_BLOCK_LENGTH with a cipher
         * key. */
        if( ( key_type & PSA_KEY_TYPE_CATEGORY_MASK ) ==
 c043d96:	f401 43e0 	and.w	r3, r1, #28672	@ 0x7000
 c043d9a:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 c043d9e:	d106      	bne.n	c043dae <psa_mac_key_can_do+0x36>
            return( PSA_SUCCESS );
 c043da0:	f411 6fe0 	tst.w	r1, #1792	@ 0x700
 c043da4:	bf0c      	ite	eq
 c043da6:	f06f 0086 	mvneq.w	r0, #134	@ 0x86
 c043daa:	2000      	movne	r0, #0
 c043dac:	4770      	bx	lr
            if( PSA_BLOCK_CIPHER_BLOCK_LENGTH( key_type ) > 1 )
                return( PSA_SUCCESS );
        }
    }

    return( PSA_ERROR_INVALID_ARGUMENT );
 c043dae:	f06f 0086 	mvn.w	r0, #134	@ 0x86
}
 c043db2:	4770      	bx	lr
 c043db4:	7fc00000 	.word	0x7fc00000

0c043db8 <psa_key_policy_algorithm_intersection>:
    psa_key_type_t key_type,
    psa_algorithm_t alg1,
    psa_algorithm_t alg2 )
{
    /* Common case: both sides actually specify the same policy. */
    if( alg1 == alg2 )
 c043db8:	4291      	cmp	r1, r2
{
 c043dba:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 c043dbc:	4606      	mov	r6, r0
 c043dbe:	460c      	mov	r4, r1
    if( alg1 == alg2 )
 c043dc0:	f000 8089 	beq.w	c043ed6 <psa_key_policy_algorithm_intersection+0x11e>
        return( alg1 );
    /* If the policies are from the same hash-and-sign family, check
     * if one is a wildcard. If so the other has the specific algorithm. */
    if( PSA_ALG_IS_SIGN_HASH( alg1 ) &&
 c043dc4:	4b91      	ldr	r3, [pc, #580]	@ (c04400c <psa_key_policy_algorithm_intersection+0x254>)
 c043dc6:	f421 75ff 	bic.w	r5, r1, #510	@ 0x1fe
 c043dca:	f025 0501 	bic.w	r5, r5, #1
 c043dce:	429d      	cmp	r5, r3
 c043dd0:	f021 00ff 	bic.w	r0, r1, #255	@ 0xff
 c043dd4:	d00d      	beq.n	c043df2 <psa_key_policy_algorithm_intersection+0x3a>
 c043dd6:	f503 5388 	add.w	r3, r3, #4352	@ 0x1100
 c043dda:	4298      	cmp	r0, r3
 c043ddc:	d009      	beq.n	c043df2 <psa_key_policy_algorithm_intersection+0x3a>
 c043dde:	f421 737f 	bic.w	r3, r1, #1020	@ 0x3fc
 c043de2:	498b      	ldr	r1, [pc, #556]	@ (c044010 <psa_key_policy_algorithm_intersection+0x258>)
 c043de4:	f023 0303 	bic.w	r3, r3, #3
 c043de8:	428b      	cmp	r3, r1
 c043dea:	d002      	beq.n	c043df2 <psa_key_policy_algorithm_intersection+0x3a>
 c043dec:	4b89      	ldr	r3, [pc, #548]	@ (c044014 <psa_key_policy_algorithm_intersection+0x25c>)
 c043dee:	4298      	cmp	r0, r3
 c043df0:	d14e      	bne.n	c043e90 <psa_key_policy_algorithm_intersection+0xd8>
 c043df2:	4f86      	ldr	r7, [pc, #536]	@ (c04400c <psa_key_policy_algorithm_intersection+0x254>)
 c043df4:	f422 71ff 	bic.w	r1, r2, #510	@ 0x1fe
 c043df8:	f021 0101 	bic.w	r1, r1, #1
 c043dfc:	42b9      	cmp	r1, r7
        PSA_ALG_IS_SIGN_HASH( alg2 ) &&
 c043dfe:	f022 03ff 	bic.w	r3, r2, #255	@ 0xff
    if( PSA_ALG_IS_SIGN_HASH( alg1 ) &&
 c043e02:	d00e      	beq.n	c043e22 <psa_key_policy_algorithm_intersection+0x6a>
        PSA_ALG_IS_SIGN_HASH( alg2 ) &&
 c043e04:	f507 5788 	add.w	r7, r7, #4352	@ 0x1100
 c043e08:	42bb      	cmp	r3, r7
 c043e0a:	d00a      	beq.n	c043e22 <psa_key_policy_algorithm_intersection+0x6a>
 c043e0c:	f8df c200 	ldr.w	ip, [pc, #512]	@ c044010 <psa_key_policy_algorithm_intersection+0x258>
 c043e10:	f422 777f 	bic.w	r7, r2, #1020	@ 0x3fc
 c043e14:	f027 0703 	bic.w	r7, r7, #3
 c043e18:	4567      	cmp	r7, ip
 c043e1a:	d002      	beq.n	c043e22 <psa_key_policy_algorithm_intersection+0x6a>
 c043e1c:	4f7d      	ldr	r7, [pc, #500]	@ (c044014 <psa_key_policy_algorithm_intersection+0x25c>)
 c043e1e:	42bb      	cmp	r3, r7
 c043e20:	d136      	bne.n	c043e90 <psa_key_policy_algorithm_intersection+0xd8>
        ( alg1 & ~PSA_ALG_HASH_MASK ) == ( alg2 & ~PSA_ALG_HASH_MASK ) )
 c043e22:	ea84 0702 	eor.w	r7, r4, r2
        PSA_ALG_IS_SIGN_HASH( alg2 ) &&
 c043e26:	2fff      	cmp	r7, #255	@ 0xff
 c043e28:	d832      	bhi.n	c043e90 <psa_key_policy_algorithm_intersection+0xd8>
    {
        if( PSA_ALG_SIGN_GET_HASH( alg1 ) == PSA_ALG_ANY_HASH )
 c043e2a:	4f78      	ldr	r7, [pc, #480]	@ (c04400c <psa_key_policy_algorithm_intersection+0x254>)
 c043e2c:	42bd      	cmp	r5, r7
 c043e2e:	d00d      	beq.n	c043e4c <psa_key_policy_algorithm_intersection+0x94>
 c043e30:	4d79      	ldr	r5, [pc, #484]	@ (c044018 <psa_key_policy_algorithm_intersection+0x260>)
 c043e32:	42a8      	cmp	r0, r5
 c043e34:	d00a      	beq.n	c043e4c <psa_key_policy_algorithm_intersection+0x94>
 c043e36:	f424 757f 	bic.w	r5, r4, #1020	@ 0x3fc
 c043e3a:	f025 0503 	bic.w	r5, r5, #3
 c043e3e:	f507 7700 	add.w	r7, r7, #512	@ 0x200
 c043e42:	42bd      	cmp	r5, r7
 c043e44:	d002      	beq.n	c043e4c <psa_key_policy_algorithm_intersection+0x94>
 c043e46:	4d73      	ldr	r5, [pc, #460]	@ (c044014 <psa_key_policy_algorithm_intersection+0x25c>)
 c043e48:	42a8      	cmp	r0, r5
 c043e4a:	d107      	bne.n	c043e5c <psa_key_policy_algorithm_intersection+0xa4>
 c043e4c:	f014 00ff 	ands.w	r0, r4, #255	@ 0xff
 c043e50:	d004      	beq.n	c043e5c <psa_key_policy_algorithm_intersection+0xa4>
 c043e52:	4d72      	ldr	r5, [pc, #456]	@ (c04401c <psa_key_policy_algorithm_intersection+0x264>)
 c043e54:	f040 7000 	orr.w	r0, r0, #33554432	@ 0x2000000
 c043e58:	42a8      	cmp	r0, r5
 c043e5a:	d03c      	beq.n	c043ed6 <psa_key_policy_algorithm_intersection+0x11e>
            return( alg2 );
        if( PSA_ALG_SIGN_GET_HASH( alg2 ) == PSA_ALG_ANY_HASH )
 c043e5c:	486b      	ldr	r0, [pc, #428]	@ (c04400c <psa_key_policy_algorithm_intersection+0x254>)
 c043e5e:	4281      	cmp	r1, r0
 c043e60:	d00d      	beq.n	c043e7e <psa_key_policy_algorithm_intersection+0xc6>
 c043e62:	496d      	ldr	r1, [pc, #436]	@ (c044018 <psa_key_policy_algorithm_intersection+0x260>)
 c043e64:	428b      	cmp	r3, r1
 c043e66:	d00a      	beq.n	c043e7e <psa_key_policy_algorithm_intersection+0xc6>
 c043e68:	f422 717f 	bic.w	r1, r2, #1020	@ 0x3fc
 c043e6c:	f021 0103 	bic.w	r1, r1, #3
 c043e70:	f500 7000 	add.w	r0, r0, #512	@ 0x200
 c043e74:	4281      	cmp	r1, r0
 c043e76:	d002      	beq.n	c043e7e <psa_key_policy_algorithm_intersection+0xc6>
 c043e78:	4966      	ldr	r1, [pc, #408]	@ (c044014 <psa_key_policy_algorithm_intersection+0x25c>)
 c043e7a:	428b      	cmp	r3, r1
 c043e7c:	d108      	bne.n	c043e90 <psa_key_policy_algorithm_intersection+0xd8>
 c043e7e:	f012 03ff 	ands.w	r3, r2, #255	@ 0xff
 c043e82:	d005      	beq.n	c043e90 <psa_key_policy_algorithm_intersection+0xd8>
 c043e84:	4965      	ldr	r1, [pc, #404]	@ (c04401c <psa_key_policy_algorithm_intersection+0x264>)
 c043e86:	f043 7300 	orr.w	r3, r3, #33554432	@ 0x2000000
 c043e8a:	428b      	cmp	r3, r1
 c043e8c:	f000 80b8 	beq.w	c044000 <psa_key_policy_algorithm_intersection+0x248>
            return( alg1 );
    }
    /* If the policies are from the same AEAD family, check whether
     * one of them is a minimum-tag-length wildcard. Calculate the most
     * restrictive tag length. */
    if( PSA_ALG_IS_AEAD( alg1 ) && PSA_ALG_IS_AEAD( alg2 ) &&
 c043e90:	f004 43fe 	and.w	r3, r4, #2130706432	@ 0x7f000000
 c043e94:	f1b3 6fa0 	cmp.w	r3, #83886080	@ 0x5000000
 c043e98:	d12b      	bne.n	c043ef2 <psa_key_policy_algorithm_intersection+0x13a>
 c043e9a:	f002 43fe 	and.w	r3, r2, #2130706432	@ 0x7f000000
 c043e9e:	f1b3 6fa0 	cmp.w	r3, #83886080	@ 0x5000000
 c043ea2:	f040 80af 	bne.w	c044004 <psa_key_policy_algorithm_intersection+0x24c>
        ( PSA_ALG_AEAD_WITH_SHORTENED_TAG( alg1, 0 ) ==
 c043ea6:	ea84 0302 	eor.w	r3, r4, r2
    if( PSA_ALG_IS_AEAD( alg1 ) && PSA_ALG_IS_AEAD( alg2 ) &&
 c043eaa:	f433 137e 	bics.w	r3, r3, #4161536	@ 0x3f8000
 c043eae:	f040 80a9 	bne.w	c044004 <psa_key_policy_algorithm_intersection+0x24c>
        size_t alg1_len = PSA_ALG_AEAD_GET_TAG_LENGTH( alg1 );
        size_t alg2_len = PSA_ALG_AEAD_GET_TAG_LENGTH( alg2 );
        size_t restricted_len = alg1_len > alg2_len ? alg1_len : alg2_len;

        /* If both are wildcards, return most restrictive wildcard */
        if( ( ( alg1 & PSA_ALG_AEAD_AT_LEAST_THIS_LENGTH_FLAG ) != 0 ) &&
 c043eb2:	0425      	lsls	r5, r4, #16
        size_t alg1_len = PSA_ALG_AEAD_GET_TAG_LENGTH( alg1 );
 c043eb4:	f3c4 4305 	ubfx	r3, r4, #16, #6
        size_t alg2_len = PSA_ALG_AEAD_GET_TAG_LENGTH( alg2 );
 c043eb8:	f3c2 4005 	ubfx	r0, r2, #16, #6
            ( ( alg2 & PSA_ALG_AEAD_AT_LEAST_THIS_LENGTH_FLAG ) != 0 ) )
 c043ebc:	f402 4100 	and.w	r1, r2, #32768	@ 0x8000
        if( ( ( alg1 & PSA_ALG_AEAD_AT_LEAST_THIS_LENGTH_FLAG ) != 0 ) &&
 c043ec0:	d50f      	bpl.n	c043ee2 <psa_key_policy_algorithm_intersection+0x12a>
 c043ec2:	b151      	cbz	r1, c043eda <psa_key_policy_algorithm_intersection+0x122>
        size_t restricted_len = alg1_len > alg2_len ? alg1_len : alg2_len;
 c043ec4:	4283      	cmp	r3, r0
 c043ec6:	bf38      	it	cc
 c043ec8:	4603      	movcc	r3, r0
        {
            return( PSA_ALG_AEAD_WITH_AT_LEAST_THIS_LENGTH_TAG(
 c043eca:	f424 127e 	bic.w	r2, r4, #4161536	@ 0x3f8000
 c043ece:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
 c043ed2:	f442 4200 	orr.w	r2, r2, #32768	@ 0x8000
        if( alg1_len == alg2_len )
            return( PSA_ALG_TRUNCATED_MAC( alg1, alg1_len ) );
    }
    /* If the policies are incompatible, allow nothing. */
    return( 0 );
}
 c043ed6:	4610      	mov	r0, r2
 c043ed8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            return( 0 );
 c043eda:	4283      	cmp	r3, r0
 c043edc:	bf88      	it	hi
 c043ede:	2200      	movhi	r2, #0
 c043ee0:	e7f9      	b.n	c043ed6 <psa_key_policy_algorithm_intersection+0x11e>
        if( ( ( alg2 & PSA_ALG_AEAD_AT_LEAST_THIS_LENGTH_FLAG ) != 0 ) &&
 c043ee2:	2900      	cmp	r1, #0
 c043ee4:	f000 808e 	beq.w	c044004 <psa_key_policy_algorithm_intersection+0x24c>
 c043ee8:	4283      	cmp	r3, r0
 c043eea:	bf2c      	ite	cs
 c043eec:	4622      	movcs	r2, r4
 c043eee:	2200      	movcc	r2, #0
 c043ef0:	e7f1      	b.n	c043ed6 <psa_key_policy_algorithm_intersection+0x11e>
    if( PSA_ALG_IS_MAC( alg1 ) && PSA_ALG_IS_MAC( alg2 ) &&
 c043ef2:	f1b3 7f40 	cmp.w	r3, #50331648	@ 0x3000000
 c043ef6:	f040 8085 	bne.w	c044004 <psa_key_policy_algorithm_intersection+0x24c>
 c043efa:	f002 43fe 	and.w	r3, r2, #2130706432	@ 0x7f000000
 c043efe:	f1b3 7f40 	cmp.w	r3, #50331648	@ 0x3000000
 c043f02:	d17f      	bne.n	c044004 <psa_key_policy_algorithm_intersection+0x24c>
        ( PSA_ALG_FULL_LENGTH_MAC( alg1 ) ==
 c043f04:	ea84 0302 	eor.w	r3, r4, r2
    if( PSA_ALG_IS_MAC( alg1 ) && PSA_ALG_IS_MAC( alg2 ) &&
 c043f08:	f433 157e 	bics.w	r5, r3, #4161536	@ 0x3f8000
 c043f0c:	d17a      	bne.n	c044004 <psa_key_policy_algorithm_intersection+0x24c>
        if( PSA_SUCCESS != psa_mac_key_can_do( alg1, key_type ) )
 c043f0e:	4631      	mov	r1, r6
 c043f10:	4620      	mov	r0, r4
 c043f12:	f7ff ff31 	bl	c043d78 <psa_mac_key_can_do>
 c043f16:	2800      	cmp	r0, #0
 c043f18:	d174      	bne.n	c044004 <psa_key_policy_algorithm_intersection+0x24c>
        size_t alg1_len = PSA_MAC_LENGTH( key_type, 0, alg1 );
 c043f1a:	f414 157c 	ands.w	r5, r4, #4128768	@ 0x3f0000
 c043f1e:	d018      	beq.n	c043f52 <psa_key_policy_algorithm_intersection+0x19a>
 c043f20:	f3c4 4505 	ubfx	r5, r4, #16, #6
        size_t alg2_len = PSA_MAC_LENGTH( key_type, 0, alg2 );
 c043f24:	f412 137c 	ands.w	r3, r2, #4128768	@ 0x3f0000
 c043f28:	d035      	beq.n	c043f96 <psa_key_policy_algorithm_intersection+0x1de>
 c043f2a:	f3c2 4305 	ubfx	r3, r2, #16, #6
        if( ( ( alg1 & PSA_ALG_MAC_AT_LEAST_THIS_LENGTH_FLAG ) != 0 ) &&
 c043f2e:	0420      	lsls	r0, r4, #16
            ( ( alg2 & PSA_ALG_AEAD_AT_LEAST_THIS_LENGTH_FLAG ) != 0 ) )
 c043f30:	f402 4100 	and.w	r1, r2, #32768	@ 0x8000
        if( ( ( alg1 & PSA_ALG_MAC_AT_LEAST_THIS_LENGTH_FLAG ) != 0 ) &&
 c043f34:	d555      	bpl.n	c043fe2 <psa_key_policy_algorithm_intersection+0x22a>
 c043f36:	2900      	cmp	r1, #0
 c043f38:	d04f      	beq.n	c043fda <psa_key_policy_algorithm_intersection+0x222>
        size_t restricted_len = alg1_len > alg2_len ? alg1_len : alg2_len;
 c043f3a:	42ab      	cmp	r3, r5
 c043f3c:	bf38      	it	cc
 c043f3e:	462b      	movcc	r3, r5
            return( PSA_ALG_AT_LEAST_THIS_LENGTH_MAC( alg1, restricted_len ) );
 c043f40:	041b      	lsls	r3, r3, #16
 c043f42:	f403 137c 	and.w	r3, r3, #4128768	@ 0x3f0000
 c043f46:	f424 147e 	bic.w	r4, r4, #4161536	@ 0x3f8000
 c043f4a:	4323      	orrs	r3, r4
 c043f4c:	f443 4200 	orr.w	r2, r3, #32768	@ 0x8000
 c043f50:	e7c1      	b.n	c043ed6 <psa_key_policy_algorithm_intersection+0x11e>
        size_t alg1_len = PSA_MAC_LENGTH( key_type, 0, alg1 );
 c043f52:	4b33      	ldr	r3, [pc, #204]	@ (c044020 <psa_key_policy_algorithm_intersection+0x268>)
 c043f54:	4023      	ands	r3, r4
 c043f56:	f1b3 7f60 	cmp.w	r3, #58720256	@ 0x3800000
 c043f5a:	d10d      	bne.n	c043f78 <psa_key_policy_algorithm_intersection+0x1c0>
 c043f5c:	4931      	ldr	r1, [pc, #196]	@ (c044024 <psa_key_policy_algorithm_intersection+0x26c>)
 c043f5e:	b2e3      	uxtb	r3, r4
 c043f60:	f043 7300 	orr.w	r3, r3, #33554432	@ 0x2000000
 c043f64:	428b      	cmp	r3, r1
 c043f66:	d014      	beq.n	c043f92 <psa_key_policy_algorithm_intersection+0x1da>
 c043f68:	f103 437e 	add.w	r3, r3, #4261412864	@ 0xfe000000
 c043f6c:	3b02      	subs	r3, #2
 c043f6e:	2b11      	cmp	r3, #17
 c043f70:	d8d8      	bhi.n	c043f24 <psa_key_policy_algorithm_intersection+0x16c>
 c043f72:	492d      	ldr	r1, [pc, #180]	@ (c044028 <psa_key_policy_algorithm_intersection+0x270>)
 c043f74:	5ccd      	ldrb	r5, [r1, r3]
 c043f76:	e7d5      	b.n	c043f24 <psa_key_policy_algorithm_intersection+0x16c>
 c043f78:	f1b3 7f70 	cmp.w	r3, #62914560	@ 0x3c00000
 c043f7c:	d1d2      	bne.n	c043f24 <psa_key_policy_algorithm_intersection+0x16c>
 c043f7e:	f406 43e0 	and.w	r3, r6, #28672	@ 0x7000
 c043f82:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 c043f86:	d1cd      	bne.n	c043f24 <psa_key_policy_algorithm_intersection+0x16c>
 c043f88:	2501      	movs	r5, #1
 c043f8a:	f3c6 2302 	ubfx	r3, r6, #8, #3
 c043f8e:	409d      	lsls	r5, r3
 c043f90:	e7c8      	b.n	c043f24 <psa_key_policy_algorithm_intersection+0x16c>
 c043f92:	2510      	movs	r5, #16
 c043f94:	e7c6      	b.n	c043f24 <psa_key_policy_algorithm_intersection+0x16c>
        size_t alg2_len = PSA_MAC_LENGTH( key_type, 0, alg2 );
 c043f96:	4922      	ldr	r1, [pc, #136]	@ (c044020 <psa_key_policy_algorithm_intersection+0x268>)
 c043f98:	4011      	ands	r1, r2
 c043f9a:	f1b1 7f60 	cmp.w	r1, #58720256	@ 0x3800000
 c043f9e:	d10d      	bne.n	c043fbc <psa_key_policy_algorithm_intersection+0x204>
 c043fa0:	4820      	ldr	r0, [pc, #128]	@ (c044024 <psa_key_policy_algorithm_intersection+0x26c>)
 c043fa2:	b2d1      	uxtb	r1, r2
 c043fa4:	f041 7100 	orr.w	r1, r1, #33554432	@ 0x2000000
 c043fa8:	4281      	cmp	r1, r0
 c043faa:	d014      	beq.n	c043fd6 <psa_key_policy_algorithm_intersection+0x21e>
 c043fac:	f101 417e 	add.w	r1, r1, #4261412864	@ 0xfe000000
 c043fb0:	3902      	subs	r1, #2
 c043fb2:	2911      	cmp	r1, #17
 c043fb4:	d8bb      	bhi.n	c043f2e <psa_key_policy_algorithm_intersection+0x176>
 c043fb6:	4b1d      	ldr	r3, [pc, #116]	@ (c04402c <psa_key_policy_algorithm_intersection+0x274>)
 c043fb8:	5c5b      	ldrb	r3, [r3, r1]
 c043fba:	e7b8      	b.n	c043f2e <psa_key_policy_algorithm_intersection+0x176>
 c043fbc:	f1b1 7f70 	cmp.w	r1, #62914560	@ 0x3c00000
 c043fc0:	d1b5      	bne.n	c043f2e <psa_key_policy_algorithm_intersection+0x176>
 c043fc2:	f406 41e0 	and.w	r1, r6, #28672	@ 0x7000
 c043fc6:	f5b1 5f00 	cmp.w	r1, #8192	@ 0x2000
 c043fca:	d1b0      	bne.n	c043f2e <psa_key_policy_algorithm_intersection+0x176>
 c043fcc:	2301      	movs	r3, #1
 c043fce:	f3c6 2602 	ubfx	r6, r6, #8, #3
 c043fd2:	40b3      	lsls	r3, r6
 c043fd4:	e7ab      	b.n	c043f2e <psa_key_policy_algorithm_intersection+0x176>
 c043fd6:	2310      	movs	r3, #16
 c043fd8:	e7a9      	b.n	c043f2e <psa_key_policy_algorithm_intersection+0x176>
            return( 0 );
 c043fda:	429d      	cmp	r5, r3
 c043fdc:	bf88      	it	hi
 c043fde:	2200      	movhi	r2, #0
 c043fe0:	e779      	b.n	c043ed6 <psa_key_policy_algorithm_intersection+0x11e>
        if( ( alg2 & PSA_ALG_MAC_AT_LEAST_THIS_LENGTH_FLAG ) != 0 )
 c043fe2:	b121      	cbz	r1, c043fee <psa_key_policy_algorithm_intersection+0x236>
            return( ( alg2_len <= alg1_len ) ? alg1 : 0 );
 c043fe4:	429d      	cmp	r5, r3
 c043fe6:	bf2c      	ite	cs
 c043fe8:	4622      	movcs	r2, r4
 c043fea:	2200      	movcc	r2, #0
 c043fec:	e773      	b.n	c043ed6 <psa_key_policy_algorithm_intersection+0x11e>
        if( alg1_len == alg2_len )
 c043fee:	429d      	cmp	r5, r3
 c043ff0:	d10a      	bne.n	c044008 <psa_key_policy_algorithm_intersection+0x250>
            return( PSA_ALG_TRUNCATED_MAC( alg1, alg1_len ) );
 c043ff2:	042d      	lsls	r5, r5, #16
 c043ff4:	f405 157c 	and.w	r5, r5, #4128768	@ 0x3f0000
 c043ff8:	f424 127e 	bic.w	r2, r4, #4161536	@ 0x3f8000
 c043ffc:	432a      	orrs	r2, r5
 c043ffe:	e76a      	b.n	c043ed6 <psa_key_policy_algorithm_intersection+0x11e>
 c044000:	4622      	mov	r2, r4
 c044002:	e768      	b.n	c043ed6 <psa_key_policy_algorithm_intersection+0x11e>
            return( 0 );
 c044004:	2200      	movs	r2, #0
 c044006:	e766      	b.n	c043ed6 <psa_key_policy_algorithm_intersection+0x11e>
 c044008:	460a      	mov	r2, r1
 c04400a:	e764      	b.n	c043ed6 <psa_key_policy_algorithm_intersection+0x11e>
 c04400c:	06000200 	.word	0x06000200
 c044010:	06000400 	.word	0x06000400
 c044014:	06000900 	.word	0x06000900
 c044018:	06001300 	.word	0x06001300
 c04401c:	020000ff 	.word	0x020000ff
 c044020:	7fc00000 	.word	0x7fc00000
 c044024:	02000001 	.word	0x02000001
 c044028:	0c060e58 	.word	0x0c060e58
 c04402c:	0c060e58 	.word	0x0c060e58

0c044030 <psa_key_algorithm_permits>:
static int psa_key_algorithm_permits( psa_key_type_t key_type,
                                      psa_algorithm_t policy_alg,
                                      psa_algorithm_t requested_alg )
{
    /* Common case: the policy only allows requested_alg. */
    if( requested_alg == policy_alg )
 c044030:	428a      	cmp	r2, r1
{
 c044032:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 c044034:	4606      	mov	r6, r0
 c044036:	460c      	mov	r4, r1
    if( requested_alg == policy_alg )
 c044038:	f000 80d8 	beq.w	c0441ec <psa_key_algorithm_permits+0x1bc>
        return( 1 );
    /* If policy_alg is a hash-and-sign with a wildcard for the hash,
     * and requested_alg is the same hash-and-sign family with any hash,
     * then requested_alg is compliant with policy_alg. */
    if( PSA_ALG_IS_SIGN_HASH( requested_alg ) &&
 c04403c:	496e      	ldr	r1, [pc, #440]	@ (c0441f8 <psa_key_algorithm_permits+0x1c8>)
 c04403e:	f422 73ff 	bic.w	r3, r2, #510	@ 0x1fe
 c044042:	f023 0301 	bic.w	r3, r3, #1
 c044046:	428b      	cmp	r3, r1
 c044048:	d00e      	beq.n	c044068 <psa_key_algorithm_permits+0x38>
 c04404a:	4b6c      	ldr	r3, [pc, #432]	@ (c0441fc <psa_key_algorithm_permits+0x1cc>)
 c04404c:	f022 01ff 	bic.w	r1, r2, #255	@ 0xff
 c044050:	4299      	cmp	r1, r3
 c044052:	d009      	beq.n	c044068 <psa_key_algorithm_permits+0x38>
 c044054:	486a      	ldr	r0, [pc, #424]	@ (c044200 <psa_key_algorithm_permits+0x1d0>)
 c044056:	f422 737f 	bic.w	r3, r2, #1020	@ 0x3fc
 c04405a:	f023 0303 	bic.w	r3, r3, #3
 c04405e:	4283      	cmp	r3, r0
 c044060:	d002      	beq.n	c044068 <psa_key_algorithm_permits+0x38>
 c044062:	4b68      	ldr	r3, [pc, #416]	@ (c044204 <psa_key_algorithm_permits+0x1d4>)
 c044064:	4299      	cmp	r1, r3
 c044066:	d124      	bne.n	c0440b2 <psa_key_algorithm_permits+0x82>
 c044068:	4963      	ldr	r1, [pc, #396]	@ (c0441f8 <psa_key_algorithm_permits+0x1c8>)
 c04406a:	f424 73ff 	bic.w	r3, r4, #510	@ 0x1fe
 c04406e:	f023 0301 	bic.w	r3, r3, #1
 c044072:	428b      	cmp	r3, r1
 c044074:	d00e      	beq.n	c044094 <psa_key_algorithm_permits+0x64>
        PSA_ALG_SIGN_GET_HASH( policy_alg ) == PSA_ALG_ANY_HASH )
 c044076:	4b61      	ldr	r3, [pc, #388]	@ (c0441fc <psa_key_algorithm_permits+0x1cc>)
 c044078:	f024 01ff 	bic.w	r1, r4, #255	@ 0xff
 c04407c:	4299      	cmp	r1, r3
 c04407e:	d009      	beq.n	c044094 <psa_key_algorithm_permits+0x64>
 c044080:	485f      	ldr	r0, [pc, #380]	@ (c044200 <psa_key_algorithm_permits+0x1d0>)
 c044082:	f424 737f 	bic.w	r3, r4, #1020	@ 0x3fc
 c044086:	f023 0303 	bic.w	r3, r3, #3
 c04408a:	4283      	cmp	r3, r0
 c04408c:	d002      	beq.n	c044094 <psa_key_algorithm_permits+0x64>
 c04408e:	4b5d      	ldr	r3, [pc, #372]	@ (c044204 <psa_key_algorithm_permits+0x1d4>)
 c044090:	4299      	cmp	r1, r3
 c044092:	d10e      	bne.n	c0440b2 <psa_key_algorithm_permits+0x82>
 c044094:	f014 03ff 	ands.w	r3, r4, #255	@ 0xff
 c044098:	d00b      	beq.n	c0440b2 <psa_key_algorithm_permits+0x82>
 c04409a:	495b      	ldr	r1, [pc, #364]	@ (c044208 <psa_key_algorithm_permits+0x1d8>)
 c04409c:	f043 7300 	orr.w	r3, r3, #33554432	@ 0x2000000
 c0440a0:	428b      	cmp	r3, r1
 c0440a2:	d106      	bne.n	c0440b2 <psa_key_algorithm_permits+0x82>
    {
        return( ( policy_alg & ~PSA_ALG_HASH_MASK ) ==
 c0440a4:	ea82 0004 	eor.w	r0, r2, r4
 c0440a8:	28ff      	cmp	r0, #255	@ 0xff
        PSA_ALG_IS_AEAD( requested_alg ) &&
        ( PSA_ALG_AEAD_WITH_SHORTENED_TAG( policy_alg, 0 ) ==
          PSA_ALG_AEAD_WITH_SHORTENED_TAG( requested_alg, 0 ) ) &&
        ( ( policy_alg & PSA_ALG_AEAD_AT_LEAST_THIS_LENGTH_FLAG ) != 0 ) )
    {
        return( PSA_ALG_AEAD_GET_TAG_LENGTH( policy_alg ) <=
 c0440aa:	bf8c      	ite	hi
 c0440ac:	2000      	movhi	r0, #0
 c0440ae:	2001      	movls	r0, #1
        return( PSA_ALG_KEY_AGREEMENT_GET_BASE( requested_alg ) ==
                policy_alg );
    }
    /* If it isn't explicitly permitted, it's forbidden. */
    return( 0 );
}
 c0440b0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if( PSA_ALG_IS_AEAD( policy_alg ) &&
 c0440b2:	f004 43fe 	and.w	r3, r4, #2130706432	@ 0x7f000000
 c0440b6:	f1b3 6fa0 	cmp.w	r3, #83886080	@ 0x5000000
 c0440ba:	d114      	bne.n	c0440e6 <psa_key_algorithm_permits+0xb6>
        PSA_ALG_IS_AEAD( requested_alg ) &&
 c0440bc:	f002 43fe 	and.w	r3, r2, #2130706432	@ 0x7f000000
    if( PSA_ALG_IS_AEAD( policy_alg ) &&
 c0440c0:	f1b3 6fa0 	cmp.w	r3, #83886080	@ 0x5000000
 c0440c4:	f040 8094 	bne.w	c0441f0 <psa_key_algorithm_permits+0x1c0>
        ( PSA_ALG_AEAD_WITH_SHORTENED_TAG( policy_alg, 0 ) ==
 c0440c8:	ea82 0304 	eor.w	r3, r2, r4
        PSA_ALG_IS_AEAD( requested_alg ) &&
 c0440cc:	f433 137e 	bics.w	r3, r3, #4161536	@ 0x3f8000
 c0440d0:	f040 808e 	bne.w	c0441f0 <psa_key_algorithm_permits+0x1c0>
          PSA_ALG_AEAD_WITH_SHORTENED_TAG( requested_alg, 0 ) ) &&
 c0440d4:	f414 4000 	ands.w	r0, r4, #32768	@ 0x8000
 c0440d8:	d0ea      	beq.n	c0440b0 <psa_key_algorithm_permits+0x80>
        return( PSA_ALG_AEAD_GET_TAG_LENGTH( policy_alg ) <=
 c0440da:	f3c4 4005 	ubfx	r0, r4, #16, #6
                PSA_ALG_AEAD_GET_TAG_LENGTH( requested_alg ) );
 c0440de:	f3c2 4205 	ubfx	r2, r2, #16, #6
        return( PSA_ALG_AEAD_GET_TAG_LENGTH( policy_alg ) <=
 c0440e2:	4290      	cmp	r0, r2
 c0440e4:	e7e1      	b.n	c0440aa <psa_key_algorithm_permits+0x7a>
    if( PSA_ALG_IS_MAC( policy_alg ) &&
 c0440e6:	f1b3 7f40 	cmp.w	r3, #50331648	@ 0x3000000
 c0440ea:	d16b      	bne.n	c0441c4 <psa_key_algorithm_permits+0x194>
        PSA_ALG_IS_MAC( requested_alg ) &&
 c0440ec:	f002 43fe 	and.w	r3, r2, #2130706432	@ 0x7f000000
    if( PSA_ALG_IS_MAC( policy_alg ) &&
 c0440f0:	f1b3 7f40 	cmp.w	r3, #50331648	@ 0x3000000
 c0440f4:	d17c      	bne.n	c0441f0 <psa_key_algorithm_permits+0x1c0>
        ( PSA_ALG_FULL_LENGTH_MAC( policy_alg ) ==
 c0440f6:	ea82 0504 	eor.w	r5, r2, r4
        PSA_ALG_IS_MAC( requested_alg ) &&
 c0440fa:	f435 157e 	bics.w	r5, r5, #4161536	@ 0x3f8000
 c0440fe:	d177      	bne.n	c0441f0 <psa_key_algorithm_permits+0x1c0>
        if( PSA_SUCCESS != psa_mac_key_can_do( policy_alg, key_type ) )
 c044100:	4631      	mov	r1, r6
 c044102:	4620      	mov	r0, r4
 c044104:	f7ff fe38 	bl	c043d78 <psa_mac_key_can_do>
 c044108:	2800      	cmp	r0, #0
 c04410a:	d171      	bne.n	c0441f0 <psa_key_algorithm_permits+0x1c0>
        size_t requested_output_length = PSA_MAC_LENGTH(
 c04410c:	4b3f      	ldr	r3, [pc, #252]	@ (c04420c <psa_key_algorithm_permits+0x1dc>)
 c04410e:	f412 177c 	ands.w	r7, r2, #4128768	@ 0x3f0000
 c044112:	ea03 0302 	and.w	r3, r3, r2
 c044116:	d01b      	beq.n	c044150 <psa_key_algorithm_permits+0x120>
        size_t default_output_length = PSA_MAC_LENGTH(
 c044118:	f1b3 7f60 	cmp.w	r3, #58720256	@ 0x3800000
        size_t requested_output_length = PSA_MAC_LENGTH(
 c04411c:	f3c2 4705 	ubfx	r7, r2, #16, #6
        size_t default_output_length = PSA_MAC_LENGTH(
 c044120:	d13d      	bne.n	c04419e <psa_key_algorithm_permits+0x16e>
 c044122:	493b      	ldr	r1, [pc, #236]	@ (c044210 <psa_key_algorithm_permits+0x1e0>)
 c044124:	b2d3      	uxtb	r3, r2
 c044126:	f043 7300 	orr.w	r3, r3, #33554432	@ 0x2000000
 c04412a:	428b      	cmp	r3, r1
 c04412c:	d03b      	beq.n	c0441a6 <psa_key_algorithm_permits+0x176>
 c04412e:	f103 437e 	add.w	r3, r3, #4261412864	@ 0xfe000000
 c044132:	3b02      	subs	r3, #2
 c044134:	2b11      	cmp	r3, #17
 c044136:	d801      	bhi.n	c04413c <psa_key_algorithm_permits+0x10c>
 c044138:	4936      	ldr	r1, [pc, #216]	@ (c044214 <psa_key_algorithm_permits+0x1e4>)
 c04413a:	5ccd      	ldrb	r5, [r1, r3]
        if( PSA_MAC_TRUNCATED_LENGTH( policy_alg ) == 0 )
 c04413c:	f414 1f7c 	tst.w	r4, #4128768	@ 0x3f0000
 c044140:	f3c4 4305 	ubfx	r3, r4, #16, #6
 c044144:	d131      	bne.n	c0441aa <psa_key_algorithm_permits+0x17a>
            return( requested_output_length == default_output_length );
 c044146:	42af      	cmp	r7, r5
        return( PSA_ALG_KEY_AGREEMENT_GET_BASE( requested_alg ) ==
 c044148:	bf14      	ite	ne
 c04414a:	2000      	movne	r0, #0
 c04414c:	2001      	moveq	r0, #1
 c04414e:	e7af      	b.n	c0440b0 <psa_key_algorithm_permits+0x80>
        size_t requested_output_length = PSA_MAC_LENGTH(
 c044150:	f1b3 7f60 	cmp.w	r3, #58720256	@ 0x3800000
 c044154:	d10d      	bne.n	c044172 <psa_key_algorithm_permits+0x142>
 c044156:	492e      	ldr	r1, [pc, #184]	@ (c044210 <psa_key_algorithm_permits+0x1e0>)
 c044158:	b2d3      	uxtb	r3, r2
 c04415a:	f043 7300 	orr.w	r3, r3, #33554432	@ 0x2000000
 c04415e:	428b      	cmp	r3, r1
 c044160:	d048      	beq.n	c0441f4 <psa_key_algorithm_permits+0x1c4>
 c044162:	f103 437e 	add.w	r3, r3, #4261412864	@ 0xfe000000
 c044166:	3b02      	subs	r3, #2
 c044168:	2b11      	cmp	r3, #17
 c04416a:	d8da      	bhi.n	c044122 <psa_key_algorithm_permits+0xf2>
 c04416c:	492a      	ldr	r1, [pc, #168]	@ (c044218 <psa_key_algorithm_permits+0x1e8>)
 c04416e:	5ccf      	ldrb	r7, [r1, r3]
 c044170:	e7d7      	b.n	c044122 <psa_key_algorithm_permits+0xf2>
 c044172:	f1b3 7f70 	cmp.w	r3, #62914560	@ 0x3c00000
 c044176:	d1e1      	bne.n	c04413c <psa_key_algorithm_permits+0x10c>
 c044178:	f406 43e0 	and.w	r3, r6, #28672	@ 0x7000
 c04417c:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 c044180:	d103      	bne.n	c04418a <psa_key_algorithm_permits+0x15a>
 c044182:	2701      	movs	r7, #1
 c044184:	f3c6 2302 	ubfx	r3, r6, #8, #3
 c044188:	409f      	lsls	r7, r3
        size_t default_output_length = PSA_MAC_LENGTH(
 c04418a:	f406 43e0 	and.w	r3, r6, #28672	@ 0x7000
 c04418e:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 c044192:	d1d3      	bne.n	c04413c <psa_key_algorithm_permits+0x10c>
 c044194:	2501      	movs	r5, #1
 c044196:	f3c6 2102 	ubfx	r1, r6, #8, #3
 c04419a:	408d      	lsls	r5, r1
 c04419c:	e7ce      	b.n	c04413c <psa_key_algorithm_permits+0x10c>
 c04419e:	f1b3 7f70 	cmp.w	r3, #62914560	@ 0x3c00000
 c0441a2:	d1cb      	bne.n	c04413c <psa_key_algorithm_permits+0x10c>
 c0441a4:	e7f1      	b.n	c04418a <psa_key_algorithm_permits+0x15a>
 c0441a6:	2510      	movs	r5, #16
 c0441a8:	e7c8      	b.n	c04413c <psa_key_algorithm_permits+0x10c>
        if( PSA_MAC_TRUNCATED_LENGTH( requested_alg ) == 0 &&
 c0441aa:	f412 1f7c 	tst.w	r2, #4128768	@ 0x3f0000
 c0441ae:	d101      	bne.n	c0441b4 <psa_key_algorithm_permits+0x184>
 c0441b0:	42ab      	cmp	r3, r5
 c0441b2:	d01b      	beq.n	c0441ec <psa_key_algorithm_permits+0x1bc>
        if( ( policy_alg & PSA_ALG_MAC_AT_LEAST_THIS_LENGTH_FLAG ) != 0 )
 c0441b4:	0422      	lsls	r2, r4, #16
 c0441b6:	f57f af7b 	bpl.w	c0440b0 <psa_key_algorithm_permits+0x80>
            return( PSA_MAC_TRUNCATED_LENGTH( policy_alg ) <=
 c0441ba:	429f      	cmp	r7, r3
 c0441bc:	bf34      	ite	cc
 c0441be:	2000      	movcc	r0, #0
 c0441c0:	2001      	movcs	r0, #1
 c0441c2:	e775      	b.n	c0440b0 <psa_key_algorithm_permits+0x80>
    if( PSA_ALG_IS_RAW_KEY_AGREEMENT( policy_alg ) &&
 c0441c4:	f1b3 6f10 	cmp.w	r3, #150994944	@ 0x9000000
 c0441c8:	d112      	bne.n	c0441f0 <psa_key_algorithm_permits+0x1c0>
 c0441ca:	f024 601f 	bic.w	r0, r4, #166723584	@ 0x9f00000
 c0441ce:	f420 2070 	bic.w	r0, r0, #983040	@ 0xf0000
 c0441d2:	b968      	cbnz	r0, c0441f0 <psa_key_algorithm_permits+0x1c0>
        PSA_ALG_IS_KEY_AGREEMENT( requested_alg ) )
 c0441d4:	f002 43fe 	and.w	r3, r2, #2130706432	@ 0x7f000000
    if( PSA_ALG_IS_RAW_KEY_AGREEMENT( policy_alg ) &&
 c0441d8:	f1b3 6f10 	cmp.w	r3, #150994944	@ 0x9000000
 c0441dc:	f47f af68 	bne.w	c0440b0 <psa_key_algorithm_permits+0x80>
        return( PSA_ALG_KEY_AGREEMENT_GET_BASE( requested_alg ) ==
 c0441e0:	480e      	ldr	r0, [pc, #56]	@ (c04421c <psa_key_algorithm_permits+0x1ec>)
 c0441e2:	4010      	ands	r0, r2
 c0441e4:	f040 6010 	orr.w	r0, r0, #150994944	@ 0x9000000
 c0441e8:	42a0      	cmp	r0, r4
 c0441ea:	e7ad      	b.n	c044148 <psa_key_algorithm_permits+0x118>
        return( 1 );
 c0441ec:	2001      	movs	r0, #1
 c0441ee:	e75f      	b.n	c0440b0 <psa_key_algorithm_permits+0x80>
            return( 0 );
 c0441f0:	2000      	movs	r0, #0
 c0441f2:	e75d      	b.n	c0440b0 <psa_key_algorithm_permits+0x80>
        size_t requested_output_length = PSA_MAC_LENGTH(
 c0441f4:	2710      	movs	r7, #16
        size_t default_output_length = PSA_MAC_LENGTH(
 c0441f6:	e794      	b.n	c044122 <psa_key_algorithm_permits+0xf2>
 c0441f8:	06000200 	.word	0x06000200
 c0441fc:	06001300 	.word	0x06001300
 c044200:	06000400 	.word	0x06000400
 c044204:	06000900 	.word	0x06000900
 c044208:	020000ff 	.word	0x020000ff
 c04420c:	7fc00000 	.word	0x7fc00000
 c044210:	02000001 	.word	0x02000001
 c044214:	0c060e58 	.word	0x0c060e58
 c044218:	0c060e58 	.word	0x0c060e58
 c04421c:	f6ff0000 	.word	0xf6ff0000

0c044220 <psa_tls12_prf_set_key>:
}

static psa_status_t psa_tls12_prf_set_key( psa_tls12_prf_key_derivation_t *prf,
                                           const uint8_t *data,
                                           size_t data_length )
{
 c044220:	b570      	push	{r4, r5, r6, lr}
 c044222:	4604      	mov	r4, r0
    if( prf->state != PSA_TLS12_PRF_STATE_SEED_SET )
 c044224:	7880      	ldrb	r0, [r0, #2]
{
 c044226:	460e      	mov	r6, r1
    if( prf->state != PSA_TLS12_PRF_STATE_SEED_SET )
 c044228:	2801      	cmp	r0, #1
{
 c04422a:	4615      	mov	r5, r2
    if( prf->state != PSA_TLS12_PRF_STATE_SEED_SET )
 c04422c:	d10e      	bne.n	c04424c <psa_tls12_prf_set_key+0x2c>
        return( PSA_ERROR_BAD_STATE );

    if( data_length != 0 )
 c04422e:	b14a      	cbz	r2, c044244 <psa_tls12_prf_set_key+0x24>
    {
        prf->secret = mbedtls_calloc( 1, data_length );
 c044230:	4611      	mov	r1, r2
 c044232:	f7f7 f8b7 	bl	c03b3a4 <mbedtls_calloc>
 c044236:	6060      	str	r0, [r4, #4]
        if( prf->secret == NULL )
 c044238:	b158      	cbz	r0, c044252 <psa_tls12_prf_set_key+0x32>
            return( PSA_ERROR_INSUFFICIENT_MEMORY );

        memcpy( prf->secret, data, data_length );
 c04423a:	462a      	mov	r2, r5
 c04423c:	4631      	mov	r1, r6
 c04423e:	f017 fa05 	bl	c05b64c <memcpy>
        prf->secret_length = data_length;
 c044242:	60a5      	str	r5, [r4, #8]
    }

    prf->state = PSA_TLS12_PRF_STATE_KEY_SET;
 c044244:	2302      	movs	r3, #2

    return( PSA_SUCCESS );
 c044246:	2000      	movs	r0, #0
    prf->state = PSA_TLS12_PRF_STATE_KEY_SET;
 c044248:	70a3      	strb	r3, [r4, #2]
}
 c04424a:	bd70      	pop	{r4, r5, r6, pc}
        return( PSA_ERROR_BAD_STATE );
 c04424c:	f06f 0088 	mvn.w	r0, #136	@ 0x88
 c044250:	e7fb      	b.n	c04424a <psa_tls12_prf_set_key+0x2a>
            return( PSA_ERROR_INSUFFICIENT_MEMORY );
 c044252:	f06f 008c 	mvn.w	r0, #140	@ 0x8c
 c044256:	e7f8      	b.n	c04424a <psa_tls12_prf_set_key+0x2a>

0c044258 <psa_tls12_prf_input>:

static psa_status_t psa_tls12_prf_input( psa_tls12_prf_key_derivation_t *prf,
                                         psa_key_derivation_step_t step,
                                         const uint8_t *data,
                                         size_t data_length )
{
 c044258:	b570      	push	{r4, r5, r6, lr}
 c04425a:	461c      	mov	r4, r3
    switch( step )
 c04425c:	f240 2301 	movw	r3, #513	@ 0x201
 c044260:	4299      	cmp	r1, r3
{
 c044262:	4605      	mov	r5, r0
 c044264:	4616      	mov	r6, r2
    switch( step )
 c044266:	d024      	beq.n	c0442b2 <psa_tls12_prf_input+0x5a>
 c044268:	f5b1 7f01 	cmp.w	r1, #516	@ 0x204
 c04426c:	d006      	beq.n	c04427c <psa_tls12_prf_input+0x24>
 c04426e:	f240 1301 	movw	r3, #257	@ 0x101
 c044272:	4299      	cmp	r1, r3
 c044274:	d017      	beq.n	c0442a6 <psa_tls12_prf_input+0x4e>
 c044276:	f06f 0086 	mvn.w	r0, #134	@ 0x86
        case PSA_KEY_DERIVATION_INPUT_LABEL:
            return( psa_tls12_prf_set_label( prf, data, data_length ) );
        default:
            return( PSA_ERROR_INVALID_ARGUMENT );
    }
}
 c04427a:	bd70      	pop	{r4, r5, r6, pc}
    if( prf->state != PSA_TLS12_PRF_STATE_INIT )
 c04427c:	7883      	ldrb	r3, [r0, #2]
 c04427e:	bb53      	cbnz	r3, c0442d6 <psa_tls12_prf_input+0x7e>
    if( data_length != 0 )
 c044280:	b16c      	cbz	r4, c04429e <psa_tls12_prf_input+0x46>
        prf->seed = mbedtls_calloc( 1, data_length );
 c044282:	4621      	mov	r1, r4
 c044284:	2001      	movs	r0, #1
 c044286:	f7f7 f88d 	bl	c03b3a4 <mbedtls_calloc>
 c04428a:	60e8      	str	r0, [r5, #12]
        if( prf->seed == NULL )
 c04428c:	b910      	cbnz	r0, c044294 <psa_tls12_prf_input+0x3c>
            return( PSA_ERROR_INSUFFICIENT_MEMORY );
 c04428e:	f06f 008c 	mvn.w	r0, #140	@ 0x8c
 c044292:	e7f2      	b.n	c04427a <psa_tls12_prf_input+0x22>
        memcpy( prf->seed, data, data_length );
 c044294:	4622      	mov	r2, r4
 c044296:	4631      	mov	r1, r6
 c044298:	f017 f9d8 	bl	c05b64c <memcpy>
        prf->seed_length = data_length;
 c04429c:	612c      	str	r4, [r5, #16]
    return( PSA_SUCCESS );
 c04429e:	2301      	movs	r3, #1
 c0442a0:	2000      	movs	r0, #0
    prf->state = PSA_TLS12_PRF_STATE_SEED_SET;
 c0442a2:	70ab      	strb	r3, [r5, #2]
 c0442a4:	e7e9      	b.n	c04427a <psa_tls12_prf_input+0x22>
            return( psa_tls12_prf_set_key( prf, data, data_length ) );
 c0442a6:	4622      	mov	r2, r4
 c0442a8:	4631      	mov	r1, r6
}
 c0442aa:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
            return( psa_tls12_prf_set_key( prf, data, data_length ) );
 c0442ae:	f7ff bfb7 	b.w	c044220 <psa_tls12_prf_set_key>
    if( prf->state != PSA_TLS12_PRF_STATE_KEY_SET )
 c0442b2:	7883      	ldrb	r3, [r0, #2]
 c0442b4:	2b02      	cmp	r3, #2
 c0442b6:	d10e      	bne.n	c0442d6 <psa_tls12_prf_input+0x7e>
    if( data_length != 0 )
 c0442b8:	b15c      	cbz	r4, c0442d2 <psa_tls12_prf_input+0x7a>
        prf->label = mbedtls_calloc( 1, data_length );
 c0442ba:	4621      	mov	r1, r4
 c0442bc:	2001      	movs	r0, #1
 c0442be:	f7f7 f871 	bl	c03b3a4 <mbedtls_calloc>
 c0442c2:	6168      	str	r0, [r5, #20]
        if( prf->label == NULL )
 c0442c4:	2800      	cmp	r0, #0
 c0442c6:	d0e2      	beq.n	c04428e <psa_tls12_prf_input+0x36>
        memcpy( prf->label, data, data_length );
 c0442c8:	4622      	mov	r2, r4
 c0442ca:	4631      	mov	r1, r6
 c0442cc:	f017 f9be 	bl	c05b64c <memcpy>
        prf->label_length = data_length;
 c0442d0:	61ac      	str	r4, [r5, #24]
    return( PSA_SUCCESS );
 c0442d2:	2303      	movs	r3, #3
 c0442d4:	e7e4      	b.n	c0442a0 <psa_tls12_prf_input+0x48>
        return( PSA_ERROR_BAD_STATE );
 c0442d6:	f06f 0088 	mvn.w	r0, #136	@ 0x88
 c0442da:	e7ce      	b.n	c04427a <psa_tls12_prf_input+0x22>

0c0442dc <psa_key_derivation_setup_kdf>:
{
 c0442dc:	b538      	push	{r3, r4, r5, lr}
 c0442de:	460c      	mov	r4, r1
    memset( &operation->ctx, 0, sizeof( operation->ctx ) );
 c0442e0:	f44f 722c 	mov.w	r2, #688	@ 0x2b0
 c0442e4:	2100      	movs	r1, #0
{
 c0442e6:	4605      	mov	r5, r0
    memset( &operation->ctx, 0, sizeof( operation->ctx ) );
 c0442e8:	3010      	adds	r0, #16
 c0442ea:	f017 fa20 	bl	c05b72e <memset>
    if( PSA_ALG_IS_HKDF( kdf_alg ) )
 c0442ee:	4925      	ldr	r1, [pc, #148]	@ (c044384 <psa_key_derivation_setup_kdf+0xa8>)
 c0442f0:	f424 733f 	bic.w	r3, r4, #764	@ 0x2fc
 c0442f4:	f023 0303 	bic.w	r3, r3, #3
 c0442f8:	428b      	cmp	r3, r1
 c0442fa:	f024 02ff 	bic.w	r2, r4, #255	@ 0xff
 c0442fe:	d002      	beq.n	c044306 <psa_key_derivation_setup_kdf+0x2a>
    if( PSA_ALG_IS_TLS12_PRF( kdf_alg ) )
 c044300:	4b21      	ldr	r3, [pc, #132]	@ (c044388 <psa_key_derivation_setup_kdf+0xac>)
 c044302:	429a      	cmp	r2, r3
 c044304:	d119      	bne.n	c04433a <psa_key_derivation_setup_kdf+0x5e>
        size_t hash_size = PSA_HASH_LENGTH( hash_alg );
 c044306:	4b21      	ldr	r3, [pc, #132]	@ (c04438c <psa_key_derivation_setup_kdf+0xb0>)
        psa_algorithm_t hash_alg = PSA_ALG_HKDF_GET_HASH( kdf_alg );
 c044308:	b2e4      	uxtb	r4, r4
 c04430a:	f044 7400 	orr.w	r4, r4, #33554432	@ 0x2000000
        size_t hash_size = PSA_HASH_LENGTH( hash_alg );
 c04430e:	429c      	cmp	r4, r3
 c044310:	d034      	beq.n	c04437c <psa_key_derivation_setup_kdf+0xa0>
 c044312:	f104 437e 	add.w	r3, r4, #4261412864	@ 0xfe000000
 c044316:	3b02      	subs	r3, #2
 c044318:	2b11      	cmp	r3, #17
 c04431a:	d80e      	bhi.n	c04433a <psa_key_derivation_setup_kdf+0x5e>
 c04431c:	e8df f003 	tbb	[pc, r3]
 c044320:	14142525 	.word	0x14142525
 c044324:	27090d0d 	.word	0x27090d0d
 c044328:	1009302c 	.word	0x1009302c
 c04432c:	10090d0d 	.word	0x10090d0d
 c044330:	3012      	.short	0x3012
 c044332:	231c      	movs	r3, #28
        if( ( PSA_ALG_IS_TLS12_PRF( kdf_alg ) ||
 c044334:	4914      	ldr	r1, [pc, #80]	@ (c044388 <psa_key_derivation_setup_kdf+0xac>)
 c044336:	428a      	cmp	r2, r1
 c044338:	d10a      	bne.n	c044350 <psa_key_derivation_setup_kdf+0x74>
            return( PSA_ERROR_NOT_SUPPORTED );
 c04433a:	f06f 0085 	mvn.w	r0, #133	@ 0x85
 c04433e:	e013      	b.n	c044368 <psa_key_derivation_setup_kdf+0x8c>
        size_t hash_size = PSA_HASH_LENGTH( hash_alg );
 c044340:	2320      	movs	r3, #32
 c044342:	e7f7      	b.n	c044334 <psa_key_derivation_setup_kdf+0x58>
 c044344:	2330      	movs	r3, #48	@ 0x30
 c044346:	e7f5      	b.n	c044334 <psa_key_derivation_setup_kdf+0x58>
 c044348:	2314      	movs	r3, #20
        if( ( PSA_ALG_IS_TLS12_PRF( kdf_alg ) ||
 c04434a:	490f      	ldr	r1, [pc, #60]	@ (c044388 <psa_key_derivation_setup_kdf+0xac>)
 c04434c:	428a      	cmp	r2, r1
 c04434e:	d002      	beq.n	c044356 <psa_key_derivation_setup_kdf+0x7a>
 c044350:	490f      	ldr	r1, [pc, #60]	@ (c044390 <psa_key_derivation_setup_kdf+0xb4>)
 c044352:	428a      	cmp	r2, r1
 c044354:	d104      	bne.n	c044360 <psa_key_derivation_setup_kdf+0x84>
            ! ( hash_alg == PSA_ALG_SHA_256 || hash_alg == PSA_ALG_SHA_384 ) )
 c044356:	f104 447e 	add.w	r4, r4, #4261412864	@ 0xfe000000
 c04435a:	3c09      	subs	r4, #9
              PSA_ALG_IS_TLS12_PSK_TO_MS( kdf_alg ) ) &&
 c04435c:	2c01      	cmp	r4, #1
 c04435e:	d8ec      	bhi.n	c04433a <psa_key_derivation_setup_kdf+0x5e>
        return( PSA_SUCCESS );
 c044360:	2000      	movs	r0, #0
        operation->capacity = 255 * hash_size;
 c044362:	ebc3 2303 	rsb	r3, r3, r3, lsl #8
 c044366:	60ab      	str	r3, [r5, #8]
}
 c044368:	bd38      	pop	{r3, r4, r5, pc}
        size_t hash_size = PSA_HASH_LENGTH( hash_alg );
 c04436a:	2310      	movs	r3, #16
 c04436c:	e7ed      	b.n	c04434a <psa_key_derivation_setup_kdf+0x6e>
 c04436e:	2320      	movs	r3, #32
        if( ( PSA_ALG_IS_TLS12_PRF( kdf_alg ) ||
 c044370:	4905      	ldr	r1, [pc, #20]	@ (c044388 <psa_key_derivation_setup_kdf+0xac>)
 c044372:	428a      	cmp	r2, r1
 c044374:	d0f4      	beq.n	c044360 <psa_key_derivation_setup_kdf+0x84>
 c044376:	e7eb      	b.n	c044350 <psa_key_derivation_setup_kdf+0x74>
        size_t hash_size = PSA_HASH_LENGTH( hash_alg );
 c044378:	2330      	movs	r3, #48	@ 0x30
 c04437a:	e7f9      	b.n	c044370 <psa_key_derivation_setup_kdf+0x94>
 c04437c:	2310      	movs	r3, #16
 c04437e:	e7d9      	b.n	c044334 <psa_key_derivation_setup_kdf+0x58>
 c044380:	2340      	movs	r3, #64	@ 0x40
 c044382:	e7d7      	b.n	c044334 <psa_key_derivation_setup_kdf+0x58>
 c044384:	08000100 	.word	0x08000100
 c044388:	08000200 	.word	0x08000200
 c04438c:	02000001 	.word	0x02000001
 c044390:	08000300 	.word	0x08000300

0c044394 <psa_tls12_prf_psk_to_ms_set_key>:
#if defined(MBEDTLS_PSA_BUILTIN_ALG_TLS12_PSK_TO_MS)
static psa_status_t psa_tls12_prf_psk_to_ms_set_key(
    psa_tls12_prf_key_derivation_t *prf,
    const uint8_t *data,
    size_t data_length )
{
 c044394:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    psa_status_t status;
    uint8_t pms[ 4 + 2 * PSA_TLS12_PSK_TO_MS_PSK_MAX_SIZE ];
    uint8_t *cur = pms;

    if( data_length > PSA_TLS12_PSK_TO_MS_PSK_MAX_SIZE )
 c044398:	2a80      	cmp	r2, #128	@ 0x80
{
 c04439a:	4606      	mov	r6, r0
 c04439c:	460f      	mov	r7, r1
 c04439e:	4614      	mov	r4, r2
 c0443a0:	b0c2      	sub	sp, #264	@ 0x108
    if( data_length > PSA_TLS12_PSK_TO_MS_PSK_MAX_SIZE )
 c0443a2:	d828      	bhi.n	c0443f6 <psa_tls12_prf_psk_to_ms_set_key+0x62>
     * The premaster secret is formed as follows: if the PSK is N octets
     * long, concatenate a uint16 with the value N, N zero octets, a second
     * uint16 with the value N, and the PSK itself.
     */

    *cur++ = MBEDTLS_BYTE_1( data_length );
 c0443a4:	f04f 0800 	mov.w	r8, #0
    *cur++ = MBEDTLS_BYTE_0( data_length );
    memset( cur, 0, data_length );
 c0443a8:	f10d 0306 	add.w	r3, sp, #6
 c0443ac:	4641      	mov	r1, r8
 c0443ae:	4618      	mov	r0, r3
    *cur++ = MBEDTLS_BYTE_0( data_length );
 c0443b0:	f88d 2005 	strb.w	r2, [sp, #5]
    *cur++ = MBEDTLS_BYTE_1( data_length );
 c0443b4:	f88d 8004 	strb.w	r8, [sp, #4]
    memset( cur, 0, data_length );
 c0443b8:	f017 f9b9 	bl	c05b72e <memset>
    cur += data_length;
    *cur++ = pms[0];
 c0443bc:	f800 8004 	strb.w	r8, [r0, r4]
    cur += data_length;
 c0443c0:	1902      	adds	r2, r0, r4
    *cur++ = pms[1];
 c0443c2:	f89d 1005 	ldrb.w	r1, [sp, #5]
 c0443c6:	1c93      	adds	r3, r2, #2
 c0443c8:	7051      	strb	r1, [r2, #1]
    memcpy( cur, data, data_length );
 c0443ca:	4618      	mov	r0, r3
 c0443cc:	4622      	mov	r2, r4
 c0443ce:	4639      	mov	r1, r7
 c0443d0:	f017 f93c 	bl	c05b64c <memcpy>
    *cur++ = MBEDTLS_BYTE_1( data_length );
 c0443d4:	ad01      	add	r5, sp, #4
    cur += data_length;
 c0443d6:	1902      	adds	r2, r0, r4

    status = psa_tls12_prf_set_key( prf, pms, cur - pms );
 c0443d8:	4629      	mov	r1, r5
 c0443da:	4630      	mov	r0, r6
 c0443dc:	1b52      	subs	r2, r2, r5
 c0443de:	f7ff ff1f 	bl	c044220 <psa_tls12_prf_set_key>

    mbedtls_platform_zeroize( pms, sizeof( pms ) );
 c0443e2:	f44f 7182 	mov.w	r1, #260	@ 0x104
    status = psa_tls12_prf_set_key( prf, pms, cur - pms );
 c0443e6:	4604      	mov	r4, r0
    mbedtls_platform_zeroize( pms, sizeof( pms ) );
 c0443e8:	4628      	mov	r0, r5
 c0443ea:	f7f6 fff1 	bl	c03b3d0 <mbedtls_platform_zeroize>
    return( status );
}
 c0443ee:	4620      	mov	r0, r4
 c0443f0:	b042      	add	sp, #264	@ 0x108
 c0443f2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        return( PSA_ERROR_INVALID_ARGUMENT );
 c0443f6:	f06f 0486 	mvn.w	r4, #134	@ 0x86
 c0443fa:	e7f8      	b.n	c0443ee <psa_tls12_prf_psk_to_ms_set_key+0x5a>

0c0443fc <psa_finish_key_creation>:
{
 c0443fc:	b5f0      	push	{r4, r5, r6, r7, lr}
    if( ! PSA_KEY_LIFETIME_IS_VOLATILE( slot->attr.lifetime ) )
 c0443fe:	7904      	ldrb	r4, [r0, #4]
{
 c044400:	4606      	mov	r6, r0
 c044402:	460f      	mov	r7, r1
 c044404:	4615      	mov	r5, r2
 c044406:	b085      	sub	sp, #20
    if( ! PSA_KEY_LIFETIME_IS_VOLATILE( slot->attr.lifetime ) )
 c044408:	b324      	cbz	r4, c044454 <psa_finish_key_creation+0x58>
 *                   secure element, otherwise the behaviour is undefined.
 */
static inline psa_key_slot_number_t psa_key_slot_get_slot_number(
    const psa_key_slot_t *slot )
{
    return( *( (psa_key_slot_number_t *)( slot->key.data ) ) );
 c04440a:	6a41      	ldr	r1, [r0, #36]	@ 0x24
        if( driver != NULL )
 c04440c:	b1e7      	cbz	r7, c044448 <psa_finish_key_creation+0x4c>
            psa_key_slot_number_t slot_number =
 c04440e:	e9d1 2300 	ldrd	r2, r3, [r1]
            memcpy( &data.slot_number, &slot_number, sizeof( slot_number ) );
 c044412:	e9cd 2300 	strd	r2, r3, [sp]
 c044416:	ab02      	add	r3, sp, #8
 c044418:	e9dd 0100 	ldrd	r0, r1, [sp]
            status = psa_save_persistent_key( &slot->attr,
 c04441c:	2208      	movs	r2, #8
            memcpy( &data.slot_number, &slot_number, sizeof( slot_number ) );
 c04441e:	e883 0003 	stmia.w	r3, {r0, r1}
            status = psa_save_persistent_key( &slot->attr,
 c044422:	4619      	mov	r1, r3
 c044424:	4630      	mov	r0, r6
 c044426:	f004 ff79 	bl	c04931c <psa_save_persistent_key>
 c04442a:	4604      	mov	r4, r0
        psa_crypto_transaction.unknown.type == PSA_CRYPTO_TRANSACTION_CREATE_KEY )
 c04442c:	4b14      	ldr	r3, [pc, #80]	@ (c044480 <psa_finish_key_creation+0x84>)
    if( driver != NULL &&
 c04442e:	881b      	ldrh	r3, [r3, #0]
 c044430:	2b01      	cmp	r3, #1
 c044432:	d10d      	bne.n	c044450 <psa_finish_key_creation+0x54>
        status = psa_save_se_persistent_data( driver );
 c044434:	4638      	mov	r0, r7
 c044436:	f004 fc42 	bl	c048cbe <psa_save_se_persistent_data>
        if( status != PSA_SUCCESS )
 c04443a:	4604      	mov	r4, r0
 c04443c:	b1c0      	cbz	r0, c044470 <psa_finish_key_creation+0x74>
            psa_destroy_persistent_key( slot->attr.id );
 c04443e:	e9d6 0102 	ldrd	r0, r1, [r6, #8]
 c044442:	f004 febf 	bl	c0491c4 <psa_destroy_persistent_key>
            return( status );
 c044446:	e010      	b.n	c04446a <psa_finish_key_creation+0x6e>
            status = psa_save_persistent_key( &slot->attr,
 c044448:	6a82      	ldr	r2, [r0, #40]	@ 0x28
 c04444a:	f004 ff67 	bl	c04931c <psa_save_persistent_key>
        status = psa_crypto_stop_transaction( );
 c04444e:	4604      	mov	r4, r0
    if( status == PSA_SUCCESS )
 c044450:	b95c      	cbnz	r4, c04446a <psa_finish_key_creation+0x6e>
 c044452:	e001      	b.n	c044458 <psa_finish_key_creation+0x5c>
    if( driver != NULL &&
 c044454:	2900      	cmp	r1, #0
 c044456:	d1e9      	bne.n	c04442c <psa_finish_key_creation+0x30>
        *key = slot->attr.id;
 c044458:	e9d6 0102 	ldrd	r0, r1, [r6, #8]
 c04445c:	e885 0003 	stmia.w	r5, {r0, r1}
        status = psa_unlock_key_slot( slot );
 c044460:	4630      	mov	r0, r6
 c044462:	f004 fe27 	bl	c0490b4 <psa_unlock_key_slot>
        if( status != PSA_SUCCESS )
 c044466:	4604      	mov	r4, r0
 c044468:	b928      	cbnz	r0, c044476 <psa_finish_key_creation+0x7a>
}
 c04446a:	4620      	mov	r0, r4
 c04446c:	b005      	add	sp, #20
 c04446e:	bdf0      	pop	{r4, r5, r6, r7, pc}
        status = psa_crypto_stop_transaction( );
 c044470:	f005 f83a 	bl	c0494e8 <psa_crypto_stop_transaction>
 c044474:	e7eb      	b.n	c04444e <psa_finish_key_creation+0x52>
            *key = MBEDTLS_SVC_KEY_ID_INIT;
 c044476:	2300      	movs	r3, #0
 c044478:	e9c5 3300 	strd	r3, r3, [r5]
 c04447c:	e7f5      	b.n	c04446a <psa_finish_key_creation+0x6e>
 c04447e:	bf00      	nop
 c044480:	30031818 	.word	0x30031818

0c044484 <psa_rsa_oaep_set_padding_mode>:
    psa_algorithm_t hash_alg = PSA_ALG_RSA_OAEP_GET_HASH( alg );
 c044484:	4b0b      	ldr	r3, [pc, #44]	@ (c0444b4 <psa_rsa_oaep_set_padding_mode+0x30>)
 c044486:	f020 02ff 	bic.w	r2, r0, #255	@ 0xff
 c04448a:	429a      	cmp	r2, r3
 c04448c:	bf08      	it	eq
 c04448e:	b2c0      	uxtbeq	r0, r0
{
 c044490:	b510      	push	{r4, lr}
    psa_algorithm_t hash_alg = PSA_ALG_RSA_OAEP_GET_HASH( alg );
 c044492:	bf14      	ite	ne
 c044494:	2000      	movne	r0, #0
 c044496:	f040 7000 	orreq.w	r0, r0, #33554432	@ 0x2000000
{
 c04449a:	460c      	mov	r4, r1
    const mbedtls_md_info_t *md_info = mbedtls_md_info_from_psa( hash_alg );
 c04449c:	f003 fe58 	bl	c048150 <mbedtls_md_info_from_psa>
    mbedtls_md_type_t md_alg = mbedtls_md_get_type( md_info );
 c0444a0:	f012 fae5 	bl	c056a6e <mbedtls_md_get_type>
    mbedtls_rsa_set_padding( rsa, MBEDTLS_RSA_PKCS_V21, md_alg );
 c0444a4:	2101      	movs	r1, #1
    mbedtls_md_type_t md_alg = mbedtls_md_get_type( md_info );
 c0444a6:	4602      	mov	r2, r0
    mbedtls_rsa_set_padding( rsa, MBEDTLS_RSA_PKCS_V21, md_alg );
 c0444a8:	4620      	mov	r0, r4
}
 c0444aa:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mbedtls_rsa_set_padding( rsa, MBEDTLS_RSA_PKCS_V21, md_alg );
 c0444ae:	f00b b8dc 	b.w	c04f66a <mbedtls_rsa_set_padding>
 c0444b2:	bf00      	nop
 c0444b4:	07000300 	.word	0x07000300

0c0444b8 <validate_unstructured_key_bit_size>:
    switch( type )
 c0444b8:	f5b0 5f10 	cmp.w	r0, #9216	@ 0x2400
 c0444bc:	d00d      	beq.n	c0444da <validate_unstructured_key_bit_size+0x22>
 c0444be:	d809      	bhi.n	c0444d4 <validate_unstructured_key_bit_size+0x1c>
 c0444c0:	f5b0 5f88 	cmp.w	r0, #4352	@ 0x1100
 c0444c4:	d014      	beq.n	c0444f0 <validate_unstructured_key_bit_size+0x38>
 c0444c6:	f5b0 5f90 	cmp.w	r0, #4608	@ 0x1200
 c0444ca:	d011      	beq.n	c0444f0 <validate_unstructured_key_bit_size+0x38>
 c0444cc:	f241 0301 	movw	r3, #4097	@ 0x1001
 c0444d0:	4298      	cmp	r0, r3
 c0444d2:	d00d      	beq.n	c0444f0 <validate_unstructured_key_bit_size+0x38>
 c0444d4:	f06f 0085 	mvn.w	r0, #133	@ 0x85
 c0444d8:	4770      	bx	lr
            if( bits != 128 && bits != 192 && bits != 256 )
 c0444da:	f021 0340 	bic.w	r3, r1, #64	@ 0x40
 c0444de:	2b80      	cmp	r3, #128	@ 0x80
 c0444e0:	d00d      	beq.n	c0444fe <validate_unstructured_key_bit_size+0x46>
                return( PSA_ERROR_INVALID_ARGUMENT );
 c0444e2:	f5b1 7f80 	cmp.w	r1, #256	@ 0x100
 c0444e6:	bf0c      	ite	eq
 c0444e8:	2000      	moveq	r0, #0
 c0444ea:	f06f 0086 	mvnne.w	r0, #134	@ 0x86
 c0444ee:	4770      	bx	lr
 c0444f0:	f011 0f07 	tst.w	r1, #7
 c0444f4:	bf0c      	ite	eq
 c0444f6:	2000      	moveq	r0, #0
 c0444f8:	f06f 0086 	mvnne.w	r0, #134	@ 0x86
 c0444fc:	4770      	bx	lr
    return( PSA_SUCCESS );
 c0444fe:	2000      	movs	r0, #0
}
 c044500:	4770      	bx	lr
	...

0c044504 <psa_sign_verify_check_alg>:
        if( ! PSA_ALG_IS_SIGN_MESSAGE( alg ) )
 c044504:	f421 72ff 	bic.w	r2, r1, #510	@ 0x1fe
{
 c044508:	b510      	push	{r4, lr}
        if( ! PSA_ALG_IS_SIGN_MESSAGE( alg ) )
 c04450a:	f021 03ff 	bic.w	r3, r1, #255	@ 0xff
 c04450e:	4c19      	ldr	r4, [pc, #100]	@ (c044574 <psa_sign_verify_check_alg+0x70>)
 c044510:	f022 0201 	bic.w	r2, r2, #1
    if( input_is_message )
 c044514:	b1e8      	cbz	r0, c044552 <psa_sign_verify_check_alg+0x4e>
        if( ! PSA_ALG_IS_SIGN_MESSAGE( alg ) )
 c044516:	42a2      	cmp	r2, r4
 c044518:	d014      	beq.n	c044544 <psa_sign_verify_check_alg+0x40>
 c04451a:	4a17      	ldr	r2, [pc, #92]	@ (c044578 <psa_sign_verify_check_alg+0x74>)
 c04451c:	4293      	cmp	r3, r2
 c04451e:	d011      	beq.n	c044544 <psa_sign_verify_check_alg+0x40>
 c044520:	4816      	ldr	r0, [pc, #88]	@ (c04457c <psa_sign_verify_check_alg+0x78>)
 c044522:	f421 727f 	bic.w	r2, r1, #1020	@ 0x3fc
 c044526:	f022 0203 	bic.w	r2, r2, #3
 c04452a:	4282      	cmp	r2, r0
 c04452c:	d00a      	beq.n	c044544 <psa_sign_verify_check_alg+0x40>
 c04452e:	4a14      	ldr	r2, [pc, #80]	@ (c044580 <psa_sign_verify_check_alg+0x7c>)
 c044530:	4293      	cmp	r3, r2
 c044532:	d007      	beq.n	c044544 <psa_sign_verify_check_alg+0x40>
 c044534:	4b13      	ldr	r3, [pc, #76]	@ (c044584 <psa_sign_verify_check_alg+0x80>)
            return( PSA_ERROR_INVALID_ARGUMENT );
 c044536:	4299      	cmp	r1, r3
 c044538:	bf08      	it	eq
 c04453a:	2000      	moveq	r0, #0
 c04453c:	bf18      	it	ne
 c04453e:	f06f 0086 	mvnne.w	r0, #134	@ 0x86
 c044542:	e005      	b.n	c044550 <psa_sign_verify_check_alg+0x4c>
            if( ! PSA_ALG_IS_HASH( PSA_ALG_SIGN_GET_HASH( alg ) ) )
 c044544:	b2c9      	uxtb	r1, r1
            return( PSA_ERROR_INVALID_ARGUMENT );
 c044546:	2900      	cmp	r1, #0
 c044548:	bf14      	ite	ne
 c04454a:	2000      	movne	r0, #0
 c04454c:	f06f 0086 	mvneq.w	r0, #134	@ 0x86
}
 c044550:	bd10      	pop	{r4, pc}
        if( ! PSA_ALG_IS_SIGN_HASH( alg ) )
 c044552:	42a2      	cmp	r2, r4
 c044554:	d0fc      	beq.n	c044550 <psa_sign_verify_check_alg+0x4c>
 c044556:	4a08      	ldr	r2, [pc, #32]	@ (c044578 <psa_sign_verify_check_alg+0x74>)
 c044558:	4293      	cmp	r3, r2
 c04455a:	d0f9      	beq.n	c044550 <psa_sign_verify_check_alg+0x4c>
 c04455c:	f421 717f 	bic.w	r1, r1, #1020	@ 0x3fc
 c044560:	f021 0103 	bic.w	r1, r1, #3
 c044564:	f5a2 6270 	sub.w	r2, r2, #3840	@ 0xf00
 c044568:	4291      	cmp	r1, r2
 c04456a:	d0f1      	beq.n	c044550 <psa_sign_verify_check_alg+0x4c>
 c04456c:	f502 62a0 	add.w	r2, r2, #1280	@ 0x500
            return( PSA_ERROR_INVALID_ARGUMENT );
 c044570:	4293      	cmp	r3, r2
 c044572:	e7e3      	b.n	c04453c <psa_sign_verify_check_alg+0x38>
 c044574:	06000200 	.word	0x06000200
 c044578:	06001300 	.word	0x06001300
 c04457c:	06000400 	.word	0x06000400
 c044580:	06000900 	.word	0x06000900
 c044584:	06000800 	.word	0x06000800

0c044588 <psa_get_and_lock_key_slot_with_policy>:
{
 c044588:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 c04458c:	466d      	mov	r5, sp
 c04458e:	e885 0003 	stmia.w	r5, {r0, r1}
    status = psa_get_and_lock_key_slot( key, p_slot );
 c044592:	e895 0003 	ldmia.w	r5, {r0, r1}
{
 c044596:	4690      	mov	r8, r2
 c044598:	461f      	mov	r7, r3
 c04459a:	9c0a      	ldr	r4, [sp, #40]	@ 0x28
    status = psa_get_and_lock_key_slot( key, p_slot );
 c04459c:	f004 fd26 	bl	c048fec <psa_get_and_lock_key_slot>
    if( status != PSA_SUCCESS )
 c0445a0:	4605      	mov	r5, r0
 c0445a2:	2800      	cmp	r0, #0
 c0445a4:	d15f      	bne.n	c044666 <psa_get_and_lock_key_slot_with_policy+0xde>
    slot = *p_slot;
 c0445a6:	f8d8 6000 	ldr.w	r6, [r8]
    if( PSA_KEY_TYPE_IS_PUBLIC_KEY( slot->attr.type ) )
 c0445aa:	f8b6 9000 	ldrh.w	r9, [r6]
 c0445ae:	f409 43e0 	and.w	r3, r9, #28672	@ 0x7000
 c0445b2:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
    if( ( slot->attr.policy.usage & usage ) != usage )
 c0445b6:	6933      	ldr	r3, [r6, #16]
        usage &= ~PSA_KEY_USAGE_EXPORT;
 c0445b8:	bf08      	it	eq
 c0445ba:	f027 0701 	biceq.w	r7, r7, #1
    if( ( slot->attr.policy.usage & usage ) != usage )
 c0445be:	ea37 0303 	bics.w	r3, r7, r3
 c0445c2:	d148      	bne.n	c044656 <psa_get_and_lock_key_slot_with_policy+0xce>
    if( alg != 0 )
 c0445c4:	2c00      	cmp	r4, #0
 c0445c6:	d04e      	beq.n	c044666 <psa_get_and_lock_key_slot_with_policy+0xde>
    if( PSA_ALG_IS_WILDCARD( alg ) )
 c0445c8:	4930      	ldr	r1, [pc, #192]	@ (c04468c <psa_get_and_lock_key_slot_with_policy+0x104>)
 c0445ca:	f424 72ff 	bic.w	r2, r4, #510	@ 0x1fe
 c0445ce:	f022 0201 	bic.w	r2, r2, #1
 c0445d2:	428a      	cmp	r2, r1
 c0445d4:	f024 03ff 	bic.w	r3, r4, #255	@ 0xff
 c0445d8:	d00d      	beq.n	c0445f6 <psa_get_and_lock_key_slot_with_policy+0x6e>
 c0445da:	f501 5188 	add.w	r1, r1, #4352	@ 0x1100
 c0445de:	428b      	cmp	r3, r1
 c0445e0:	d009      	beq.n	c0445f6 <psa_get_and_lock_key_slot_with_policy+0x6e>
 c0445e2:	482b      	ldr	r0, [pc, #172]	@ (c044690 <psa_get_and_lock_key_slot_with_policy+0x108>)
 c0445e4:	f424 717f 	bic.w	r1, r4, #1020	@ 0x3fc
 c0445e8:	f021 0103 	bic.w	r1, r1, #3
 c0445ec:	4281      	cmp	r1, r0
 c0445ee:	d002      	beq.n	c0445f6 <psa_get_and_lock_key_slot_with_policy+0x6e>
 c0445f0:	4928      	ldr	r1, [pc, #160]	@ (c044694 <psa_get_and_lock_key_slot_with_policy+0x10c>)
 c0445f2:	428b      	cmp	r3, r1
 c0445f4:	d11b      	bne.n	c04462e <psa_get_and_lock_key_slot_with_policy+0xa6>
 c0445f6:	f014 01ff 	ands.w	r1, r4, #255	@ 0xff
 c0445fa:	d018      	beq.n	c04462e <psa_get_and_lock_key_slot_with_policy+0xa6>
 c0445fc:	4823      	ldr	r0, [pc, #140]	@ (c04468c <psa_get_and_lock_key_slot_with_policy+0x104>)
 c0445fe:	4282      	cmp	r2, r0
 c044600:	d00d      	beq.n	c04461e <psa_get_and_lock_key_slot_with_policy+0x96>
 c044602:	4a25      	ldr	r2, [pc, #148]	@ (c044698 <psa_get_and_lock_key_slot_with_policy+0x110>)
 c044604:	4293      	cmp	r3, r2
 c044606:	d00a      	beq.n	c04461e <psa_get_and_lock_key_slot_with_policy+0x96>
 c044608:	f424 727f 	bic.w	r2, r4, #1020	@ 0x3fc
 c04460c:	f022 0203 	bic.w	r2, r2, #3
 c044610:	f500 7000 	add.w	r0, r0, #512	@ 0x200
 c044614:	4282      	cmp	r2, r0
 c044616:	d002      	beq.n	c04461e <psa_get_and_lock_key_slot_with_policy+0x96>
 c044618:	4a1e      	ldr	r2, [pc, #120]	@ (c044694 <psa_get_and_lock_key_slot_with_policy+0x10c>)
 c04461a:	4293      	cmp	r3, r2
 c04461c:	d10e      	bne.n	c04463c <psa_get_and_lock_key_slot_with_policy+0xb4>
 c04461e:	4a1f      	ldr	r2, [pc, #124]	@ (c04469c <psa_get_and_lock_key_slot_with_policy+0x114>)
 c044620:	f041 7300 	orr.w	r3, r1, #33554432	@ 0x2000000
 c044624:	4293      	cmp	r3, r2
 c044626:	d109      	bne.n	c04463c <psa_get_and_lock_key_slot_with_policy+0xb4>
        return( PSA_ERROR_INVALID_ARGUMENT );
 c044628:	f06f 0586 	mvn.w	r5, #134	@ 0x86
 c04462c:	e015      	b.n	c04465a <psa_get_and_lock_key_slot_with_policy+0xd2>
    if( PSA_ALG_IS_WILDCARD( alg ) )
 c04462e:	f004 43fe 	and.w	r3, r4, #2130706432	@ 0x7f000000
 c044632:	f1b3 7f40 	cmp.w	r3, #50331648	@ 0x3000000
 c044636:	d11a      	bne.n	c04466e <psa_get_and_lock_key_slot_with_policy+0xe6>
 c044638:	0421      	lsls	r1, r4, #16
 c04463a:	d4f5      	bmi.n	c044628 <psa_get_and_lock_key_slot_with_policy+0xa0>
    if( psa_key_algorithm_permits( key_type, policy->alg, alg ) ||
 c04463c:	4622      	mov	r2, r4
 c04463e:	4648      	mov	r0, r9
 c044640:	6971      	ldr	r1, [r6, #20]
 c044642:	f7ff fcf5 	bl	c044030 <psa_key_algorithm_permits>
 c044646:	4607      	mov	r7, r0
 c044648:	b968      	cbnz	r0, c044666 <psa_get_and_lock_key_slot_with_policy+0xde>
        psa_key_algorithm_permits( key_type, policy->alg2, alg ) )
 c04464a:	4622      	mov	r2, r4
 c04464c:	4648      	mov	r0, r9
 c04464e:	69b1      	ldr	r1, [r6, #24]
 c044650:	f7ff fcee 	bl	c044030 <psa_key_algorithm_permits>
    if( psa_key_algorithm_permits( key_type, policy->alg, alg ) ||
 c044654:	b9c0      	cbnz	r0, c044688 <psa_get_and_lock_key_slot_with_policy+0x100>
        status = PSA_ERROR_NOT_PERMITTED;
 c044656:	f06f 0584 	mvn.w	r5, #132	@ 0x84
    *p_slot = NULL;
 c04465a:	2300      	movs	r3, #0
    psa_unlock_key_slot( slot );
 c04465c:	4630      	mov	r0, r6
    *p_slot = NULL;
 c04465e:	f8c8 3000 	str.w	r3, [r8]
    psa_unlock_key_slot( slot );
 c044662:	f004 fd27 	bl	c0490b4 <psa_unlock_key_slot>
}
 c044666:	4628      	mov	r0, r5
 c044668:	b003      	add	sp, #12
 c04466a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    if( PSA_ALG_IS_WILDCARD( alg ) )
 c04466e:	f1b3 6fa0 	cmp.w	r3, #83886080	@ 0x5000000
 c044672:	d104      	bne.n	c04467e <psa_get_and_lock_key_slot_with_policy+0xf6>
 c044674:	f3c4 33c0 	ubfx	r3, r4, #15, #1
 c044678:	2b00      	cmp	r3, #0
 c04467a:	d0df      	beq.n	c04463c <psa_get_and_lock_key_slot_with_policy+0xb4>
 c04467c:	e7d4      	b.n	c044628 <psa_get_and_lock_key_slot_with_policy+0xa0>
 c04467e:	4b07      	ldr	r3, [pc, #28]	@ (c04469c <psa_get_and_lock_key_slot_with_policy+0x114>)
 c044680:	1ae2      	subs	r2, r4, r3
 c044682:	4253      	negs	r3, r2
 c044684:	4153      	adcs	r3, r2
 c044686:	e7f7      	b.n	c044678 <psa_get_and_lock_key_slot_with_policy+0xf0>
    return( PSA_SUCCESS );
 c044688:	463d      	mov	r5, r7
 c04468a:	e7ec      	b.n	c044666 <psa_get_and_lock_key_slot_with_policy+0xde>
 c04468c:	06000200 	.word	0x06000200
 c044690:	06000400 	.word	0x06000400
 c044694:	06000900 	.word	0x06000900
 c044698:	06001300 	.word	0x06001300
 c04469c:	020000ff 	.word	0x020000ff

0c0446a0 <psa_sign_internal>:
{
 c0446a0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c0446a4:	461d      	mov	r5, r3
    *signature_length = 0;
 c0446a6:	2300      	movs	r3, #0
{
 c0446a8:	b097      	sub	sp, #92	@ 0x5c
 c0446aa:	f8dd 9090 	ldr.w	r9, [sp, #144]	@ 0x90
 c0446ae:	ac06      	add	r4, sp, #24
 c0446b0:	e884 0003 	stmia.w	r4, {r0, r1}
 c0446b4:	e9dd ab20 	ldrd	sl, fp, [sp, #128]	@ 0x80
 c0446b8:	e9dd 8622 	ldrd	r8, r6, [sp, #136]	@ 0x88
    status = psa_sign_verify_check_alg( input_is_message, alg );
 c0446bc:	4629      	mov	r1, r5
 c0446be:	4610      	mov	r0, r2
    *signature_length = 0;
 c0446c0:	f8c9 3000 	str.w	r3, [r9]
{
 c0446c4:	4617      	mov	r7, r2
    status = psa_sign_verify_check_alg( input_is_message, alg );
 c0446c6:	f7ff ff1d 	bl	c044504 <psa_sign_verify_check_alg>
    if( status != PSA_SUCCESS )
 c0446ca:	2800      	cmp	r0, #0
 c0446cc:	d13d      	bne.n	c04474a <psa_sign_internal+0xaa>
    if( signature_size == 0 )
 c0446ce:	2e00      	cmp	r6, #0
 c0446d0:	d047      	beq.n	c044762 <psa_sign_internal+0xc2>
    status = psa_get_and_lock_key_slot_with_policy(
 c0446d2:	2f00      	cmp	r7, #0
 c0446d4:	9500      	str	r5, [sp, #0]
 c0446d6:	e894 0003 	ldmia.w	r4, {r0, r1}
 c0446da:	bf14      	ite	ne
 c0446dc:	f44f 6380 	movne.w	r3, #1024	@ 0x400
 c0446e0:	f44f 5380 	moveq.w	r3, #4096	@ 0x1000
 c0446e4:	aa09      	add	r2, sp, #36	@ 0x24
 c0446e6:	f7ff ff4f 	bl	c044588 <psa_get_and_lock_key_slot_with_policy>
    if( status != PSA_SUCCESS )
 c0446ea:	4604      	mov	r4, r0
 c0446ec:	bba8      	cbnz	r0, c04475a <psa_sign_internal+0xba>
    if( ! PSA_KEY_TYPE_IS_KEY_PAIR( slot->attr.type ) )
 c0446ee:	f8dd e024 	ldr.w	lr, [sp, #36]	@ 0x24
 c0446f2:	f8be 3000 	ldrh.w	r3, [lr]
 c0446f6:	f403 43e0 	and.w	r3, r3, #28672	@ 0x7000
 c0446fa:	f5b3 4fe0 	cmp.w	r3, #28672	@ 0x7000
 c0446fe:	d12a      	bne.n	c044756 <psa_sign_internal+0xb6>
    attributes.core = slot->attr;
 c044700:	46f4      	mov	ip, lr
 c044702:	ac0a      	add	r4, sp, #40	@ 0x28
 c044704:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 c044708:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 c04470a:	e89c 000f 	ldmia.w	ip, {r0, r1, r2, r3}
 c04470e:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
        status = psa_driver_wrapper_sign_message(
 c044712:	e9de 1209 	ldrd	r1, r2, [lr, #36]	@ 0x24
 c044716:	462b      	mov	r3, r5
 c044718:	e9cd 6903 	strd	r6, r9, [sp, #12]
 c04471c:	e9cd b801 	strd	fp, r8, [sp, #4]
 c044720:	f8cd a000 	str.w	sl, [sp]
 c044724:	a80a      	add	r0, sp, #40	@ 0x28
    if( input_is_message )
 c044726:	b19f      	cbz	r7, c044750 <psa_sign_internal+0xb0>
        status = psa_driver_wrapper_sign_message(
 c044728:	f003 f825 	bl	c047776 <psa_driver_wrapper_sign_message>
        status = psa_driver_wrapper_sign_hash(
 c04472c:	4604      	mov	r4, r0
    if( status == PSA_SUCCESS )
 c04472e:	b9a0      	cbnz	r0, c04475a <psa_sign_internal+0xba>
        memset( signature + *signature_length, '!',
 c044730:	2121      	movs	r1, #33	@ 0x21
 c044732:	f8d9 0000 	ldr.w	r0, [r9]
 c044736:	1a32      	subs	r2, r6, r0
 c044738:	4440      	add	r0, r8
        memset( signature, '!', signature_size );
 c04473a:	f016 fff8 	bl	c05b72e <memset>
    unlock_status = psa_unlock_key_slot( slot );
 c04473e:	9809      	ldr	r0, [sp, #36]	@ 0x24
 c044740:	f004 fcb8 	bl	c0490b4 <psa_unlock_key_slot>
    return( ( status == PSA_SUCCESS ) ? unlock_status : status );
 c044744:	2c00      	cmp	r4, #0
 c044746:	bf18      	it	ne
 c044748:	4620      	movne	r0, r4
}
 c04474a:	b017      	add	sp, #92	@ 0x5c
 c04474c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        status = psa_driver_wrapper_sign_hash(
 c044750:	f003 f815 	bl	c04777e <psa_driver_wrapper_sign_hash>
 c044754:	e7ea      	b.n	c04472c <psa_sign_internal+0x8c>
        status = PSA_ERROR_INVALID_ARGUMENT;
 c044756:	f06f 0486 	mvn.w	r4, #134	@ 0x86
        memset( signature, '!', signature_size );
 c04475a:	4632      	mov	r2, r6
 c04475c:	2121      	movs	r1, #33	@ 0x21
 c04475e:	4640      	mov	r0, r8
 c044760:	e7eb      	b.n	c04473a <psa_sign_internal+0x9a>
        return( PSA_ERROR_BUFFER_TOO_SMALL );
 c044762:	f06f 0089 	mvn.w	r0, #137	@ 0x89
 c044766:	e7f0      	b.n	c04474a <psa_sign_internal+0xaa>

0c044768 <psa_verify_internal>:
{
 c044768:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 c04476c:	b094      	sub	sp, #80	@ 0x50
 c04476e:	f10d 0a10 	add.w	sl, sp, #16
 c044772:	e88a 0003 	stmia.w	sl, {r0, r1}
 c044776:	e9dd 671c 	ldrd	r6, r7, [sp, #112]	@ 0x70
 c04477a:	e9dd 891e 	ldrd	r8, r9, [sp, #120]	@ 0x78
    status = psa_sign_verify_check_alg( input_is_message, alg );
 c04477e:	4619      	mov	r1, r3
 c044780:	4610      	mov	r0, r2
{
 c044782:	4615      	mov	r5, r2
 c044784:	461c      	mov	r4, r3
    status = psa_sign_verify_check_alg( input_is_message, alg );
 c044786:	f7ff febd 	bl	c044504 <psa_sign_verify_check_alg>
    if( status != PSA_SUCCESS )
 c04478a:	bb88      	cbnz	r0, c0447f0 <psa_verify_internal+0x88>
    status = psa_get_and_lock_key_slot_with_policy(
 c04478c:	2d00      	cmp	r5, #0
 c04478e:	9400      	str	r4, [sp, #0]
 c044790:	bf18      	it	ne
 c044792:	f44f 6300 	movne.w	r3, #2048	@ 0x800
 c044796:	e89a 0003 	ldmia.w	sl, {r0, r1}
 c04479a:	bf08      	it	eq
 c04479c:	f44f 5300 	moveq.w	r3, #8192	@ 0x2000
 c0447a0:	aa07      	add	r2, sp, #28
 c0447a2:	f7ff fef1 	bl	c044588 <psa_get_and_lock_key_slot_with_policy>
    if( status != PSA_SUCCESS )
 c0447a6:	bb18      	cbnz	r0, c0447f0 <psa_verify_internal+0x88>
    psa_key_attributes_t attributes = {
 c0447a8:	4601      	mov	r1, r0
 c0447aa:	2210      	movs	r2, #16
 c0447ac:	a810      	add	r0, sp, #64	@ 0x40
 c0447ae:	f016 ffbe 	bl	c05b72e <memset>
      .core = slot->attr
 c0447b2:	f8dd a01c 	ldr.w	sl, [sp, #28]
    psa_key_attributes_t attributes = {
 c0447b6:	f10d 0c20 	add.w	ip, sp, #32
 c0447ba:	46d6      	mov	lr, sl
 c0447bc:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
 c0447c0:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
 c0447c4:	e89e 000f 	ldmia.w	lr, {r0, r1, r2, r3}
 c0447c8:	e88c 000f 	stmia.w	ip, {r0, r1, r2, r3}
        status = psa_driver_wrapper_verify_message(
 c0447cc:	e9da 1209 	ldrd	r1, r2, [sl, #36]	@ 0x24
 c0447d0:	4623      	mov	r3, r4
 c0447d2:	e9cd 8902 	strd	r8, r9, [sp, #8]
 c0447d6:	e9cd 6700 	strd	r6, r7, [sp]
 c0447da:	a808      	add	r0, sp, #32
    if( input_is_message )
 c0447dc:	b15d      	cbz	r5, c0447f6 <psa_verify_internal+0x8e>
        status = psa_driver_wrapper_verify_message(
 c0447de:	f002 ffcc 	bl	c04777a <psa_driver_wrapper_verify_message>
        status = psa_driver_wrapper_verify_hash(
 c0447e2:	4604      	mov	r4, r0
    unlock_status = psa_unlock_key_slot( slot );
 c0447e4:	9807      	ldr	r0, [sp, #28]
 c0447e6:	f004 fc65 	bl	c0490b4 <psa_unlock_key_slot>
    return( ( status == PSA_SUCCESS ) ? unlock_status : status );
 c0447ea:	2c00      	cmp	r4, #0
 c0447ec:	bf18      	it	ne
 c0447ee:	4620      	movne	r0, r4
}
 c0447f0:	b014      	add	sp, #80	@ 0x50
 c0447f2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        status = psa_driver_wrapper_verify_hash(
 c0447f6:	f003 f800 	bl	c0477fa <psa_driver_wrapper_verify_hash>
 c0447fa:	e7f2      	b.n	c0447e2 <psa_verify_internal+0x7a>

0c0447fc <psa_get_and_lock_transparent_key_slot_with_policy>:
{
 c0447fc:	b530      	push	{r4, r5, lr}
 c0447fe:	b085      	sub	sp, #20
 c044800:	ac02      	add	r4, sp, #8
 c044802:	e884 0003 	stmia.w	r4, {r0, r1}
    psa_status_t status = psa_get_and_lock_key_slot_with_policy( key, p_slot,
 c044806:	9908      	ldr	r1, [sp, #32]
{
 c044808:	4615      	mov	r5, r2
    psa_status_t status = psa_get_and_lock_key_slot_with_policy( key, p_slot,
 c04480a:	9100      	str	r1, [sp, #0]
 c04480c:	e894 0003 	ldmia.w	r4, {r0, r1}
 c044810:	f7ff feba 	bl	c044588 <psa_get_and_lock_key_slot_with_policy>
    if( status != PSA_SUCCESS )
 c044814:	4604      	mov	r4, r0
 c044816:	b940      	cbnz	r0, c04482a <psa_get_and_lock_transparent_key_slot_with_policy+0x2e>
    if( psa_key_lifetime_is_external( (*p_slot)->attr.lifetime ) )
 c044818:	6828      	ldr	r0, [r5, #0]
 *         The lifetime designates a key that is volatile or in internal
 *         storage.
 */
static inline int psa_key_lifetime_is_external( psa_key_lifetime_t lifetime )
{
    return( PSA_KEY_LIFETIME_GET_LOCATION( lifetime )
 c04481a:	6843      	ldr	r3, [r0, #4]
 c04481c:	0a1b      	lsrs	r3, r3, #8
 c04481e:	d004      	beq.n	c04482a <psa_get_and_lock_transparent_key_slot_with_policy+0x2e>
        psa_unlock_key_slot( *p_slot );
 c044820:	f004 fc48 	bl	c0490b4 <psa_unlock_key_slot>
        *p_slot = NULL;
 c044824:	602c      	str	r4, [r5, #0]
        return( PSA_ERROR_NOT_SUPPORTED );
 c044826:	f06f 0485 	mvn.w	r4, #133	@ 0x85
}
 c04482a:	4620      	mov	r0, r4
 c04482c:	b005      	add	sp, #20
 c04482e:	bd30      	pop	{r4, r5, pc}

0c044830 <psa_key_derivation_start_hmac>:
{
 c044830:	b5f0      	push	{r4, r5, r6, r7, lr}
 c044832:	b08f      	sub	sp, #60	@ 0x3c
 c044834:	4605      	mov	r5, r0
 c044836:	460c      	mov	r4, r1
 c044838:	4617      	mov	r7, r2
    psa_key_attributes_t attributes = PSA_KEY_ATTRIBUTES_INIT;
 c04483a:	2100      	movs	r1, #0
 c04483c:	222c      	movs	r2, #44	@ 0x2c
 c04483e:	a803      	add	r0, sp, #12
{
 c044840:	461e      	mov	r6, r3
    psa_key_attributes_t attributes = PSA_KEY_ATTRIBUTES_INIT;
 c044842:	f016 ff74 	bl	c05b72e <memset>
    if( bits > PSA_MAX_KEY_BITS )
 c044846:	f64f 72f8 	movw	r2, #65528	@ 0xfff8
        attributes->core.type = type;
 c04484a:	f44f 5388 	mov.w	r3, #4352	@ 0x1100
    if( bits > PSA_MAX_KEY_BITS )
 c04484e:	ebb2 0fc6 	cmp.w	r2, r6, lsl #3
 c044852:	f64f 72ff 	movw	r2, #65535	@ 0xffff
        attributes->core.type = type;
 c044856:	f8ad 3008 	strh.w	r3, [sp, #8]
    psa_set_key_bits( &attributes, PSA_BYTES_TO_BITS( hmac_key_length ) );
 c04485a:	ea4f 03c6 	mov.w	r3, r6, lsl #3
    if( bits > PSA_MAX_KEY_BITS )
 c04485e:	bf38      	it	cc
 c044860:	4613      	movcc	r3, r2
 c044862:	f8ad 300a 	strh.w	r3, [sp, #10]
    attributes->core.policy.usage = usage_flags;
 c044866:	f44f 53a0 	mov.w	r3, #5120	@ 0x1400
 c04486a:	9306      	str	r3, [sp, #24]
    operation->is_sign = 1;
 c04486c:	796b      	ldrb	r3, [r5, #5]
    operation->mac_size = PSA_HASH_LENGTH( hash_alg );
 c04486e:	b2e1      	uxtb	r1, r4
    operation->is_sign = 1;
 c044870:	f043 0301 	orr.w	r3, r3, #1
 c044874:	716b      	strb	r3, [r5, #5]
    operation->mac_size = PSA_HASH_LENGTH( hash_alg );
 c044876:	4b10      	ldr	r3, [pc, #64]	@ (c0448b8 <psa_key_derivation_start_hmac+0x88>)
 c044878:	f041 7400 	orr.w	r4, r1, #33554432	@ 0x2000000
 c04487c:	429c      	cmp	r4, r3
 c04487e:	d017      	beq.n	c0448b0 <psa_key_derivation_start_hmac+0x80>
 c044880:	f104 447e 	add.w	r4, r4, #4261412864	@ 0xfe000000
 c044884:	3c02      	subs	r4, #2
 c044886:	2c11      	cmp	r4, #17
 c044888:	d814      	bhi.n	c0448b4 <psa_key_derivation_start_hmac+0x84>
 c04488a:	4b0c      	ldr	r3, [pc, #48]	@ (c0448bc <psa_key_derivation_start_hmac+0x8c>)
 c04488c:	5d1b      	ldrb	r3, [r3, r4]
    status = psa_driver_wrapper_mac_sign_setup( operation,
 c04488e:	f041 7160 	orr.w	r1, r1, #58720256	@ 0x3800000
    operation->mac_size = PSA_HASH_LENGTH( hash_alg );
 c044892:	712b      	strb	r3, [r5, #4]
    status = psa_driver_wrapper_mac_sign_setup( operation,
 c044894:	463a      	mov	r2, r7
 c044896:	4633      	mov	r3, r6
 c044898:	9100      	str	r1, [sp, #0]
 c04489a:	4628      	mov	r0, r5
 c04489c:	a902      	add	r1, sp, #8
 c04489e:	f003 f988 	bl	c047bb2 <psa_driver_wrapper_mac_sign_setup>
 c0448a2:	4604      	mov	r4, r0
    psa_reset_key_attributes( &attributes );
 c0448a4:	a802      	add	r0, sp, #8
 c0448a6:	f002 ff36 	bl	c047716 <mbedcrypto__psa_reset_key_attributes>
}
 c0448aa:	4620      	mov	r0, r4
 c0448ac:	b00f      	add	sp, #60	@ 0x3c
 c0448ae:	bdf0      	pop	{r4, r5, r6, r7, pc}
    operation->mac_size = PSA_HASH_LENGTH( hash_alg );
 c0448b0:	2310      	movs	r3, #16
 c0448b2:	e7ec      	b.n	c04488e <psa_key_derivation_start_hmac+0x5e>
 c0448b4:	2300      	movs	r3, #0
 c0448b6:	e7ea      	b.n	c04488e <psa_key_derivation_start_hmac+0x5e>
 c0448b8:	02000001 	.word	0x02000001
 c0448bc:	0c060e58 	.word	0x0c060e58

0c0448c0 <mbedtls_to_psa_error>:
    int low_level_ret = - ( -ret & 0x007f );
 c0448c0:	4243      	negs	r3, r0
    switch( low_level_ret != 0 ? low_level_ret : ret )
 c0448c2:	f013 037f 	ands.w	r3, r3, #127	@ 0x7f
 c0448c6:	d01f      	beq.n	c044908 <mbedtls_to_psa_error+0x48>
    int low_level_ret = - ( -ret & 0x007f );
 c0448c8:	4258      	negs	r0, r3
    switch( low_level_ret != 0 ? low_level_ret : ret )
 c0448ca:	f110 0f32 	cmn.w	r0, #50	@ 0x32
 c0448ce:	f280 813a 	bge.w	c044b46 <mbedtls_to_psa_error+0x286>
 c0448d2:	f110 0f40 	cmn.w	r0, #64	@ 0x40
 c0448d6:	da4e      	bge.n	c044976 <mbedtls_to_psa_error+0xb6>
 c0448d8:	f110 0f50 	cmn.w	r0, #80	@ 0x50
 c0448dc:	f280 80d2 	bge.w	c044a84 <mbedtls_to_psa_error+0x1c4>
 c0448e0:	f110 0f68 	cmn.w	r0, #104	@ 0x68
 c0448e4:	da5a      	bge.n	c04499c <mbedtls_to_psa_error+0xdc>
 c0448e6:	f110 0f69 	cmn.w	r0, #105	@ 0x69
 c0448ea:	f000 80cb 	beq.w	c044a84 <mbedtls_to_psa_error+0x1c4>
 c0448ee:	f110 0f7a 	cmn.w	r0, #122	@ 0x7a
 c0448f2:	da67      	bge.n	c0449c4 <mbedtls_to_psa_error+0x104>
 c0448f4:	f510 5f64 	cmn.w	r0, #14592	@ 0x3900
 c0448f8:	f000 816f 	beq.w	c044bda <mbedtls_to_psa_error+0x31a>
 c0448fc:	f510 5f62 	cmn.w	r0, #14464	@ 0x3880
 c044900:	d021      	beq.n	c044946 <mbedtls_to_psa_error+0x86>
 c044902:	f510 5f66 	cmn.w	r0, #14720	@ 0x3980
 c044906:	e11a      	b.n	c044b3e <mbedtls_to_psa_error+0x27e>
 c044908:	f510 5f68 	cmn.w	r0, #14848	@ 0x3a00
 c04490c:	f000 8118 	beq.w	c044b40 <mbedtls_to_psa_error+0x280>
 c044910:	dcdb      	bgt.n	c0448ca <mbedtls_to_psa_error+0xa>
 c044912:	f510 4f88 	cmn.w	r0, #17408	@ 0x4400
 c044916:	f000 814b 	beq.w	c044bb0 <mbedtls_to_psa_error+0x2f0>
 c04491a:	f300 80d1 	bgt.w	c044ac0 <mbedtls_to_psa_error+0x200>
 c04491e:	f510 4fa4 	cmn.w	r0, #20992	@ 0x5200
 c044922:	f000 814b 	beq.w	c044bbc <mbedtls_to_psa_error+0x2fc>
 c044926:	f300 808e 	bgt.w	c044a46 <mbedtls_to_psa_error+0x186>
 c04492a:	f510 4fc4 	cmn.w	r0, #25088	@ 0x6200
 c04492e:	f000 8148 	beq.w	c044bc2 <mbedtls_to_psa_error+0x302>
 c044932:	dc79      	bgt.n	c044a28 <mbedtls_to_psa_error+0x168>
 c044934:	f510 4fc7 	cmn.w	r0, #25472	@ 0x6380
 c044938:	f000 8146 	beq.w	c044bc8 <mbedtls_to_psa_error+0x308>
 c04493c:	dc6a      	bgt.n	c044a14 <mbedtls_to_psa_error+0x154>
 c04493e:	f510 4fc8 	cmn.w	r0, #25600	@ 0x6400
 c044942:	f040 809f 	bne.w	c044a84 <mbedtls_to_psa_error+0x1c4>
            return( PSA_ERROR_HARDWARE_FAILURE );
 c044946:	f06f 0092 	mvn.w	r0, #146	@ 0x92
 c04494a:	4770      	bx	lr
 c04494c:	2301      	movs	r3, #1
    switch( low_level_ret != 0 ? low_level_ret : ret )
 c04494e:	4aa4      	ldr	r2, [pc, #656]	@ (c044be0 <mbedtls_to_psa_error+0x320>)
 c044950:	3032      	adds	r0, #50	@ 0x32
 c044952:	4083      	lsls	r3, r0
 c044954:	401a      	ands	r2, r3
 c044956:	2a00      	cmp	r2, #0
 c044958:	d1f5      	bne.n	c044946 <mbedtls_to_psa_error+0x86>
 c04495a:	4aa2      	ldr	r2, [pc, #648]	@ (c044be4 <mbedtls_to_psa_error+0x324>)
 c04495c:	401a      	ands	r2, r3
 c04495e:	2a00      	cmp	r2, #0
 c044960:	f040 80ee 	bne.w	c044b40 <mbedtls_to_psa_error+0x280>
 c044964:	4aa0      	ldr	r2, [pc, #640]	@ (c044be8 <mbedtls_to_psa_error+0x328>)
 c044966:	401a      	ands	r2, r3
            return( PSA_ERROR_GENERIC_ERROR );
 c044968:	2a00      	cmp	r2, #0
 c04496a:	bf14      	ite	ne
 c04496c:	f06f 0086 	mvnne.w	r0, #134	@ 0x86
 c044970:	f06f 0083 	mvneq.w	r0, #131	@ 0x83
 c044974:	4770      	bx	lr
 c044976:	2301      	movs	r3, #1
    switch( low_level_ret != 0 ? low_level_ret : ret )
 c044978:	f241 0259 	movw	r2, #4185	@ 0x1059
 c04497c:	3040      	adds	r0, #64	@ 0x40
 c04497e:	4083      	lsls	r3, r0
 c044980:	4213      	tst	r3, r2
 c044982:	f040 8118 	bne.w	c044bb6 <mbedtls_to_psa_error+0x2f6>
 c044986:	f413 5f2a 	tst.w	r3, #10880	@ 0x2a80
 c04498a:	d1dc      	bne.n	c044946 <mbedtls_to_psa_error+0x86>
            return( PSA_ERROR_GENERIC_ERROR );
 c04498c:	f413 6fa0 	tst.w	r3, #1280	@ 0x500
 c044990:	bf14      	ite	ne
 c044992:	f06f 0085 	mvnne.w	r0, #133	@ 0x85
 c044996:	f06f 0083 	mvneq.w	r0, #131	@ 0x83
 c04499a:	4770      	bx	lr
    switch( low_level_ret != 0 ? low_level_ret : ret )
 c04499c:	2301      	movs	r3, #1
 c04499e:	f100 0268 	add.w	r2, r0, #104	@ 0x68
 c0449a2:	4093      	lsls	r3, r2
 c0449a4:	4a91      	ldr	r2, [pc, #580]	@ (c044bec <mbedtls_to_psa_error+0x32c>)
 c0449a6:	4213      	tst	r3, r2
 c0449a8:	d13b      	bne.n	c044a22 <mbedtls_to_psa_error+0x162>
 c0449aa:	f110 0f56 	cmn.w	r0, #86	@ 0x56
 c0449ae:	f000 8114 	beq.w	c044bda <mbedtls_to_psa_error+0x31a>
            return( PSA_ERROR_GENERIC_ERROR );
 c0449b2:	f110 0f54 	cmn.w	r0, #84	@ 0x54
 c0449b6:	bf08      	it	eq
 c0449b8:	f06f 0088 	mvneq.w	r0, #136	@ 0x88
 c0449bc:	bf18      	it	ne
 c0449be:	f06f 0083 	mvnne.w	r0, #131	@ 0x83
 c0449c2:	4770      	bx	lr
    switch( low_level_ret != 0 ? low_level_ret : ret )
 c0449c4:	307a      	adds	r0, #122	@ 0x7a
 c0449c6:	2810      	cmp	r0, #16
 c0449c8:	d85c      	bhi.n	c044a84 <mbedtls_to_psa_error+0x1c4>
 c0449ca:	a301      	add	r3, pc, #4	@ (adr r3, c0449d0 <mbedtls_to_psa_error+0x110>)
 c0449cc:	f853 f020 	ldr.w	pc, [r3, r0, lsl #2]
 c0449d0:	0c044947 	.word	0x0c044947
 c0449d4:	0c044a85 	.word	0x0c044a85
 c0449d8:	0c044a85 	.word	0x0c044a85
 c0449dc:	0c044a85 	.word	0x0c044a85
 c0449e0:	0c044a85 	.word	0x0c044a85
 c0449e4:	0c044a85 	.word	0x0c044a85
 c0449e8:	0c044a85 	.word	0x0c044a85
 c0449ec:	0c044a85 	.word	0x0c044a85
 c0449f0:	0c044b41 	.word	0x0c044b41
 c0449f4:	0c044a85 	.word	0x0c044a85
 c0449f8:	0c044947 	.word	0x0c044947
 c0449fc:	0c044a85 	.word	0x0c044a85
 c044a00:	0c044bc9 	.word	0x0c044bc9
 c044a04:	0c044a85 	.word	0x0c044a85
 c044a08:	0c044bb1 	.word	0x0c044bb1
 c044a0c:	0c044a85 	.word	0x0c044a85
 c044a10:	0c044bcf 	.word	0x0c044bcf
 c044a14:	f510 4fc6 	cmn.w	r0, #25344	@ 0x6300
 c044a18:	f000 80df 	beq.w	c044bda <mbedtls_to_psa_error+0x31a>
 c044a1c:	f510 4fc5 	cmn.w	r0, #25216	@ 0x6280
 c044a20:	d130      	bne.n	c044a84 <mbedtls_to_psa_error+0x1c4>
            return( PSA_ERROR_INVALID_ARGUMENT );
 c044a22:	f06f 0086 	mvn.w	r0, #134	@ 0x86
 c044a26:	4770      	bx	lr
    switch( low_level_ret != 0 ? low_level_ret : ret )
 c044a28:	f510 4fc3 	cmn.w	r0, #24960	@ 0x6180
 c044a2c:	f000 80cf 	beq.w	c044bce <mbedtls_to_psa_error+0x30e>
 c044a30:	db28      	blt.n	c044a84 <mbedtls_to_psa_error+0x1c4>
 c044a32:	f510 4fc1 	cmn.w	r0, #24704	@ 0x6080
 c044a36:	f000 8083 	beq.w	c044b40 <mbedtls_to_psa_error+0x280>
 c044a3a:	f510 4fa5 	cmn.w	r0, #21120	@ 0x5280
 c044a3e:	d082      	beq.n	c044946 <mbedtls_to_psa_error+0x86>
 c044a40:	f510 4fc2 	cmn.w	r0, #24832	@ 0x6100
 c044a44:	e7ec      	b.n	c044a20 <mbedtls_to_psa_error+0x160>
 c044a46:	f510 4f9b 	cmn.w	r0, #19840	@ 0x4d80
 c044a4a:	f000 80c0 	beq.w	c044bce <mbedtls_to_psa_error+0x30e>
 c044a4e:	dc1c      	bgt.n	c044a8a <mbedtls_to_psa_error+0x1ca>
 c044a50:	f510 4f9e 	cmn.w	r0, #20224	@ 0x4f00
 c044a54:	f000 80ac 	beq.w	c044bb0 <mbedtls_to_psa_error+0x2f0>
 c044a58:	dc0d      	bgt.n	c044a76 <mbedtls_to_psa_error+0x1b6>
 c044a5a:	f510 4fa3 	cmn.w	r0, #20864	@ 0x5180
 c044a5e:	f000 80b6 	beq.w	c044bce <mbedtls_to_psa_error+0x30e>
 c044a62:	db0f      	blt.n	c044a84 <mbedtls_to_psa_error+0x1c4>
 c044a64:	f510 4fa1 	cmn.w	r0, #20608	@ 0x5080
 c044a68:	d06a      	beq.n	c044b40 <mbedtls_to_psa_error+0x280>
 c044a6a:	f510 4f9f 	cmn.w	r0, #20352	@ 0x4f80
 c044a6e:	d0d8      	beq.n	c044a22 <mbedtls_to_psa_error+0x162>
 c044a70:	f510 4fa2 	cmn.w	r0, #20736	@ 0x5100
 c044a74:	e7d4      	b.n	c044a20 <mbedtls_to_psa_error+0x160>
 c044a76:	f510 4f9d 	cmn.w	r0, #20096	@ 0x4e80
 c044a7a:	d061      	beq.n	c044b40 <mbedtls_to_psa_error+0x280>
 c044a7c:	f510 4f9c 	cmn.w	r0, #19968	@ 0x4e00
 c044a80:	f000 80ab 	beq.w	c044bda <mbedtls_to_psa_error+0x31a>
            return( PSA_ERROR_GENERIC_ERROR );
 c044a84:	f06f 0083 	mvn.w	r0, #131	@ 0x83
}
 c044a88:	4770      	bx	lr
    switch( low_level_ret != 0 ? low_level_ret : ret )
 c044a8a:	f510 4f98 	cmn.w	r0, #19456	@ 0x4c00
 c044a8e:	f000 80a4 	beq.w	c044bda <mbedtls_to_psa_error+0x31a>
 c044a92:	dc06      	bgt.n	c044aa2 <mbedtls_to_psa_error+0x1e2>
 c044a94:	f510 4f9a 	cmn.w	r0, #19712	@ 0x4d00
 c044a98:	f000 808d 	beq.w	c044bb6 <mbedtls_to_psa_error+0x2f6>
 c044a9c:	f510 4f99 	cmn.w	r0, #19584	@ 0x4c80
 c044aa0:	e7be      	b.n	c044a20 <mbedtls_to_psa_error+0x160>
 c044aa2:	f510 4f89 	cmn.w	r0, #17536	@ 0x4480
 c044aa6:	f000 8086 	beq.w	c044bb6 <mbedtls_to_psa_error+0x2f6>
 c044aaa:	dceb      	bgt.n	c044a84 <mbedtls_to_psa_error+0x1c4>
 c044aac:	f510 4f8b 	cmn.w	r0, #17792	@ 0x4580
 c044ab0:	f43f af49 	beq.w	c044946 <mbedtls_to_psa_error+0x86>
 c044ab4:	f510 4f8a 	cmn.w	r0, #17664	@ 0x4500
 c044ab8:	d042      	beq.n	c044b40 <mbedtls_to_psa_error+0x280>
 c044aba:	f510 4f97 	cmn.w	r0, #19328	@ 0x4b80
 c044abe:	e740      	b.n	c044942 <mbedtls_to_psa_error+0x82>
 c044ac0:	f510 5f78 	cmn.w	r0, #15872	@ 0x3e00
 c044ac4:	d07a      	beq.n	c044bbc <mbedtls_to_psa_error+0x2fc>
 c044ac6:	dc23      	bgt.n	c044b10 <mbedtls_to_psa_error+0x250>
 c044ac8:	f510 4f82 	cmn.w	r0, #16640	@ 0x4100
 c044acc:	d079      	beq.n	c044bc2 <mbedtls_to_psa_error+0x302>
 c044ace:	dc10      	bgt.n	c044af2 <mbedtls_to_psa_error+0x232>
 c044ad0:	f510 4f86 	cmn.w	r0, #17152	@ 0x4300
 c044ad4:	d078      	beq.n	c044bc8 <mbedtls_to_psa_error+0x308>
 c044ad6:	dc02      	bgt.n	c044ade <mbedtls_to_psa_error+0x21e>
 c044ad8:	f510 4f87 	cmn.w	r0, #17280	@ 0x4380
 c044adc:	e7d0      	b.n	c044a80 <mbedtls_to_psa_error+0x1c0>
 c044ade:	f510 4f85 	cmn.w	r0, #17024	@ 0x4280
 c044ae2:	d071      	beq.n	c044bc8 <mbedtls_to_psa_error+0x308>
 c044ae4:	dbce      	blt.n	c044a84 <mbedtls_to_psa_error+0x1c4>
 c044ae6:	f510 4f84 	cmn.w	r0, #16896	@ 0x4200
 c044aea:	d09a      	beq.n	c044a22 <mbedtls_to_psa_error+0x162>
 c044aec:	f510 4f83 	cmn.w	r0, #16768	@ 0x4180
 c044af0:	e727      	b.n	c044942 <mbedtls_to_psa_error+0x82>
 c044af2:	f510 5f7e 	cmn.w	r0, #16256	@ 0x3f80
 c044af6:	d06a      	beq.n	c044bce <mbedtls_to_psa_error+0x30e>
 c044af8:	dc02      	bgt.n	c044b00 <mbedtls_to_psa_error+0x240>
 c044afa:	f510 4f81 	cmn.w	r0, #16512	@ 0x4080
 c044afe:	e78f      	b.n	c044a20 <mbedtls_to_psa_error+0x160>
 c044b00:	f020 0080 	bic.w	r0, r0, #128	@ 0x80
            return( PSA_ERROR_GENERIC_ERROR );
 c044b04:	f510 5f7c 	cmn.w	r0, #16128	@ 0x3f00
 c044b08:	bf08      	it	eq
 c044b0a:	f06f 0086 	mvneq.w	r0, #134	@ 0x86
 c044b0e:	e755      	b.n	c0449bc <mbedtls_to_psa_error+0xfc>
    switch( low_level_ret != 0 ? low_level_ret : ret )
 c044b10:	f510 5f70 	cmn.w	r0, #15360	@ 0x3c00
 c044b14:	d05e      	beq.n	c044bd4 <mbedtls_to_psa_error+0x314>
 c044b16:	dc08      	bgt.n	c044b2a <mbedtls_to_psa_error+0x26a>
 c044b18:	f510 5f74 	cmn.w	r0, #15616	@ 0x3d00
 c044b1c:	d081      	beq.n	c044a22 <mbedtls_to_psa_error+0x162>
 c044b1e:	f510 5f72 	cmn.w	r0, #15488	@ 0x3c80
 c044b22:	d00d      	beq.n	c044b40 <mbedtls_to_psa_error+0x280>
 c044b24:	f510 5f76 	cmn.w	r0, #15744	@ 0x3d80
 c044b28:	e77a      	b.n	c044a20 <mbedtls_to_psa_error+0x160>
 c044b2a:	f510 5f6e 	cmn.w	r0, #15232	@ 0x3b80
 c044b2e:	d051      	beq.n	c044bd4 <mbedtls_to_psa_error+0x314>
 c044b30:	dba8      	blt.n	c044a84 <mbedtls_to_psa_error+0x1c4>
 c044b32:	f510 5f6c 	cmn.w	r0, #15104	@ 0x3b00
 c044b36:	f43f af74 	beq.w	c044a22 <mbedtls_to_psa_error+0x162>
 c044b3a:	f510 5f6a 	cmn.w	r0, #14976	@ 0x3a80
 c044b3e:	d1a1      	bne.n	c044a84 <mbedtls_to_psa_error+0x1c4>
 c044b40:	f06f 0085 	mvn.w	r0, #133	@ 0x85
 c044b44:	4770      	bx	lr
 c044b46:	f110 0f13 	cmn.w	r0, #19
 c044b4a:	f6ff aeff 	blt.w	c04494c <mbedtls_to_psa_error+0x8c>
 c044b4e:	f100 0313 	add.w	r3, r0, #19
 c044b52:	2b13      	cmp	r3, #19
 c044b54:	d896      	bhi.n	c044a84 <mbedtls_to_psa_error+0x1c4>
 c044b56:	2b13      	cmp	r3, #19
 c044b58:	d894      	bhi.n	c044a84 <mbedtls_to_psa_error+0x1c4>
 c044b5a:	a201      	add	r2, pc, #4	@ (adr r2, c044b60 <mbedtls_to_psa_error+0x2a0>)
 c044b5c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 c044b60:	0c044947 	.word	0x0c044947
 c044b64:	0c044bdb 	.word	0x0c044bdb
 c044b68:	0c044947 	.word	0x0c044947
 c044b6c:	0c044bcf 	.word	0x0c044bcf
 c044b70:	0c044bdb 	.word	0x0c044bdb
 c044b74:	0c044a23 	.word	0x0c044a23
 c044b78:	0c044a23 	.word	0x0c044a23
 c044b7c:	0c044a23 	.word	0x0c044a23
 c044b80:	0c044a85 	.word	0x0c044a85
 c044b84:	0c044a23 	.word	0x0c044a23
 c044b88:	0c044a85 	.word	0x0c044a85
 c044b8c:	0c044bb1 	.word	0x0c044bb1
 c044b90:	0c044a85 	.word	0x0c044a85
 c044b94:	0c044a23 	.word	0x0c044a23
 c044b98:	0c044a85 	.word	0x0c044a85
 c044b9c:	0c044a23 	.word	0x0c044a23
 c044ba0:	0c044a85 	.word	0x0c044a85
 c044ba4:	0c044bbd 	.word	0x0c044bbd
 c044ba8:	0c044a85 	.word	0x0c044a85
 c044bac:	0c044a89 	.word	0x0c044a89
            return( PSA_ERROR_BUFFER_TOO_SMALL );
 c044bb0:	f06f 0089 	mvn.w	r0, #137	@ 0x89
 c044bb4:	4770      	bx	lr
            return( PSA_ERROR_INSUFFICIENT_ENTROPY );
 c044bb6:	f06f 0093 	mvn.w	r0, #147	@ 0x93
 c044bba:	4770      	bx	lr
            return( PSA_ERROR_STORAGE_FAILURE );
 c044bbc:	f06f 0091 	mvn.w	r0, #145	@ 0x91
 c044bc0:	4770      	bx	lr
            return( PSA_ERROR_INVALID_PADDING );
 c044bc2:	f06f 0095 	mvn.w	r0, #149	@ 0x95
 c044bc6:	4770      	bx	lr
            return( PSA_ERROR_CORRUPTION_DETECTED );
 c044bc8:	f06f 0096 	mvn.w	r0, #150	@ 0x96
 c044bcc:	4770      	bx	lr
            return( PSA_ERROR_INSUFFICIENT_MEMORY );
 c044bce:	f06f 008c 	mvn.w	r0, #140	@ 0x8c
 c044bd2:	4770      	bx	lr
            return( PSA_ERROR_NOT_PERMITTED );
 c044bd4:	f06f 0084 	mvn.w	r0, #132	@ 0x84
 c044bd8:	4770      	bx	lr
            return( PSA_ERROR_INVALID_SIGNATURE );
 c044bda:	f06f 0094 	mvn.w	r0, #148	@ 0x94
 c044bde:	4770      	bx	lr
 c044be0:	0a002aaa 	.word	0x0a002aaa
 c044be4:	1405d001 	.word	0x1405d001
 c044be8:	40000400 	.word	0x40000400
 c044bec:	00800155 	.word	0x00800155

0c044bf0 <psa_validate_optional_attributes>:
{
 c044bf0:	b5f0      	push	{r4, r5, r6, r7, lr}
    if( attributes->core.type != 0 )
 c044bf2:	880b      	ldrh	r3, [r1, #0]
{
 c044bf4:	4605      	mov	r5, r0
 c044bf6:	460e      	mov	r6, r1
 c044bf8:	b08b      	sub	sp, #44	@ 0x2c
    if( attributes->core.type != 0 )
 c044bfa:	b13b      	cbz	r3, c044c0c <psa_validate_optional_attributes+0x1c>
        if( attributes->core.type != slot->attr.type )
 c044bfc:	8802      	ldrh	r2, [r0, #0]
 c044bfe:	429a      	cmp	r2, r3
 c044c00:	d004      	beq.n	c044c0c <psa_validate_optional_attributes+0x1c>
            return( PSA_ERROR_INVALID_ARGUMENT );
 c044c02:	f06f 0486 	mvn.w	r4, #134	@ 0x86
}
 c044c06:	4620      	mov	r0, r4
 c044c08:	b00b      	add	sp, #44	@ 0x2c
 c044c0a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if( attributes->domain_parameters_size != 0 )
 c044c0c:	6af3      	ldr	r3, [r6, #44]	@ 0x2c
 c044c0e:	2b00      	cmp	r3, #0
 c044c10:	d043      	beq.n	c044c9a <psa_validate_optional_attributes+0xaa>
        if( PSA_KEY_TYPE_IS_RSA( slot->attr.type ) )
 c044c12:	f244 0301 	movw	r3, #16385	@ 0x4001
 c044c16:	8828      	ldrh	r0, [r5, #0]
 c044c18:	f420 5240 	bic.w	r2, r0, #12288	@ 0x3000
 c044c1c:	429a      	cmp	r2, r3
 c044c1e:	d1f0      	bne.n	c044c02 <psa_validate_optional_attributes+0x12>
            psa_status_t status = mbedtls_psa_rsa_load_representation(
 c044c20:	e9d5 1209 	ldrd	r1, r2, [r5, #36]	@ 0x24
            mbedtls_rsa_context *rsa = NULL;
 c044c24:	2300      	movs	r3, #0
 c044c26:	9303      	str	r3, [sp, #12]
            psa_status_t status = mbedtls_psa_rsa_load_representation(
 c044c28:	ab03      	add	r3, sp, #12
 c044c2a:	f003 fdeb 	bl	c048804 <mbedtls_psa_rsa_load_representation>
            if( status != PSA_SUCCESS )
 c044c2e:	4604      	mov	r4, r0
 c044c30:	2800      	cmp	r0, #0
 c044c32:	d1e8      	bne.n	c044c06 <psa_validate_optional_attributes+0x16>
            mbedtls_mpi_init( &actual );
 c044c34:	af04      	add	r7, sp, #16
 c044c36:	4638      	mov	r0, r7
 c044c38:	f00e fb5d 	bl	c0532f6 <mbedtls_mpi_init>
            mbedtls_mpi_init( &required );
 c044c3c:	a807      	add	r0, sp, #28
 c044c3e:	f00e fb5a 	bl	c0532f6 <mbedtls_mpi_init>
            ret = mbedtls_rsa_export( rsa,
 c044c42:	4623      	mov	r3, r4
 c044c44:	4622      	mov	r2, r4
 c044c46:	4621      	mov	r1, r4
 c044c48:	e9cd 4700 	strd	r4, r7, [sp]
 c044c4c:	9803      	ldr	r0, [sp, #12]
 c044c4e:	f00a fc4b 	bl	c04f4e8 <mbedtls_rsa_export>
 c044c52:	4604      	mov	r4, r0
            mbedtls_rsa_free( rsa );
 c044c54:	9803      	ldr	r0, [sp, #12]
 c044c56:	f00b fd57 	bl	c050708 <mbedtls_rsa_free>
            mbedtls_free( rsa );
 c044c5a:	9803      	ldr	r0, [sp, #12]
 c044c5c:	f7f6 fba8 	bl	c03b3b0 <mbedtls_free>
            if( ret != 0 )
 c044c60:	b974      	cbnz	r4, c044c80 <psa_validate_optional_attributes+0x90>
            ret = mbedtls_mpi_read_binary( &required,
 c044c62:	e9d6 120a 	ldrd	r1, r2, [r6, #40]	@ 0x28
 c044c66:	a807      	add	r0, sp, #28
 c044c68:	f00e fc9f 	bl	c0535aa <mbedtls_mpi_read_binary>
            if( ret != 0 )
 c044c6c:	4604      	mov	r4, r0
 c044c6e:	b938      	cbnz	r0, c044c80 <psa_validate_optional_attributes+0x90>
            if( mbedtls_mpi_cmp_mpi( &actual, &required ) != 0 )
 c044c70:	4638      	mov	r0, r7
 c044c72:	a907      	add	r1, sp, #28
 c044c74:	f00e fde2 	bl	c05383c <mbedtls_mpi_cmp_mpi>
                ret = MBEDTLS_ERR_RSA_BAD_INPUT_DATA;
 c044c78:	4b0c      	ldr	r3, [pc, #48]	@ (c044cac <psa_validate_optional_attributes+0xbc>)
 c044c7a:	1e04      	subs	r4, r0, #0
 c044c7c:	bf18      	it	ne
 c044c7e:	461c      	movne	r4, r3
            mbedtls_mpi_free( &actual );
 c044c80:	4638      	mov	r0, r7
 c044c82:	f00e fb3e 	bl	c053302 <mbedtls_mpi_free>
            mbedtls_mpi_free( &required );
 c044c86:	a807      	add	r0, sp, #28
 c044c88:	f00e fb3b 	bl	c053302 <mbedtls_mpi_free>
            if( ret != 0)
 c044c8c:	b12c      	cbz	r4, c044c9a <psa_validate_optional_attributes+0xaa>
                return( mbedtls_to_psa_error( ret ) );
 c044c8e:	4620      	mov	r0, r4
}
 c044c90:	b00b      	add	sp, #44	@ 0x2c
 c044c92:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
                return( mbedtls_to_psa_error( ret ) );
 c044c96:	f7ff be13 	b.w	c0448c0 <mbedtls_to_psa_error>
    if( attributes->core.bits != 0 )
 c044c9a:	8874      	ldrh	r4, [r6, #2]
 c044c9c:	2c00      	cmp	r4, #0
 c044c9e:	d0b2      	beq.n	c044c06 <psa_validate_optional_attributes+0x16>
        if( attributes->core.bits != slot->attr.bits )
 c044ca0:	886b      	ldrh	r3, [r5, #2]
 c044ca2:	42a3      	cmp	r3, r4
 c044ca4:	d1ad      	bne.n	c044c02 <psa_validate_optional_attributes+0x12>
    return( PSA_SUCCESS );
 c044ca6:	2400      	movs	r4, #0
 c044ca8:	e7ad      	b.n	c044c06 <psa_validate_optional_attributes+0x16>
 c044caa:	bf00      	nop
 c044cac:	ffffbf80 	.word	0xffffbf80

0c044cb0 <psa_key_agreement_ecdh>:
                                            size_t peer_key_length,
                                            const mbedtls_ecp_keypair *our_key,
                                            uint8_t *shared_secret,
                                            size_t shared_secret_size,
                                            size_t *shared_secret_length )
{
 c044cb0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c044cb4:	461f      	mov	r7, r3
    mbedtls_ecp_keypair *their_key = NULL;
 c044cb6:	2300      	movs	r3, #0
{
 c044cb8:	b0c5      	sub	sp, #276	@ 0x114
    mbedtls_ecp_keypair *their_key = NULL;
 c044cba:	9302      	str	r3, [sp, #8]
 * \return              \c 0 on failure (\p grpid is not recognized).
 */
static inline psa_ecc_family_t mbedtls_ecc_group_to_psa( mbedtls_ecp_group_id grpid,
                                                        size_t *bits )
{
    switch( grpid )
 c044cbc:	7813      	ldrb	r3, [r2, #0]
 c044cbe:	ae02      	add	r6, sp, #8
 c044cc0:	3b01      	subs	r3, #1
{
 c044cc2:	4681      	mov	r9, r0
 c044cc4:	468a      	mov	sl, r1
 c044cc6:	4690      	mov	r8, r2
 c044cc8:	f8dd b13c 	ldr.w	fp, [sp, #316]	@ 0x13c
 c044ccc:	2b0c      	cmp	r3, #12
 c044cce:	d808      	bhi.n	c044ce2 <psa_key_agreement_ecdh+0x32>
 c044cd0:	e8df f003 	tbb	[pc, r3]
 c044cd4:	55524f73 	.word	0x55524f73
 c044cd8:	625f5b58 	.word	0x625f5b58
 c044cdc:	6d6b6865 	.word	0x6d6b6865
 c044ce0:	70          	.byte	0x70
 c044ce1:	00          	.byte	0x00
            return( PSA_ECC_FAMILY_SECP_K1 );
        case MBEDTLS_ECP_DP_CURVE448:
            *bits = 448;
            return( PSA_ECC_FAMILY_MONTGOMERY );
        default:
            *bits = 0;
 c044ce2:	2400      	movs	r4, #0
            return( 0 );
 c044ce4:	4625      	mov	r5, r4
    mbedtls_ecdh_context ecdh;
    psa_status_t status;
    size_t bits = 0;
    psa_ecc_family_t curve = mbedtls_ecc_group_to_psa( our_key->grp.id, &bits );
    mbedtls_ecdh_init( &ecdh );
 c044ce6:	a803      	add	r0, sp, #12
 c044ce8:	f011 f86e 	bl	c055dc8 <mbedtls_ecdh_init>

    status = mbedtls_psa_ecp_load_representation(
 c044cec:	f445 4082 	orr.w	r0, r5, #16640	@ 0x4100
 c044cf0:	4653      	mov	r3, sl
 c044cf2:	464a      	mov	r2, r9
 c044cf4:	4621      	mov	r1, r4
 c044cf6:	9600      	str	r6, [sp, #0]
 c044cf8:	f002 ffa8 	bl	c047c4c <mbedtls_psa_ecp_load_representation>
                 PSA_KEY_TYPE_ECC_PUBLIC_KEY(curve),
                 bits,
                 peer_key,
                 peer_key_length,
                 &their_key );
    if( status != PSA_SUCCESS )
 c044cfc:	4605      	mov	r5, r0
 c044cfe:	bb38      	cbnz	r0, c044d50 <psa_key_agreement_ecdh+0xa0>
        goto exit;

    status = mbedtls_to_psa_error(
 c044d00:	2201      	movs	r2, #1
 c044d02:	6831      	ldr	r1, [r6, #0]
 c044d04:	a803      	add	r0, sp, #12
 c044d06:	f011 f8ab 	bl	c055e60 <mbedtls_ecdh_get_params>
 c044d0a:	f7ff fdd9 	bl	c0448c0 <mbedtls_to_psa_error>
        mbedtls_ecdh_get_params( &ecdh, their_key, MBEDTLS_ECDH_THEIRS ) );
    if( status != PSA_SUCCESS )
 c044d0e:	4605      	mov	r5, r0
 c044d10:	b9f0      	cbnz	r0, c044d50 <psa_key_agreement_ecdh+0xa0>
        goto exit;
    status = mbedtls_to_psa_error(
 c044d12:	4602      	mov	r2, r0
 c044d14:	4641      	mov	r1, r8
 c044d16:	a803      	add	r0, sp, #12
 c044d18:	f011 f8a2 	bl	c055e60 <mbedtls_ecdh_get_params>
 c044d1c:	f7ff fdd0 	bl	c0448c0 <mbedtls_to_psa_error>
        mbedtls_ecdh_get_params( &ecdh, our_key, MBEDTLS_ECDH_OURS ) );
    if( status != PSA_SUCCESS )
 c044d20:	4605      	mov	r5, r0
 c044d22:	b9a8      	cbnz	r0, c044d50 <psa_key_agreement_ecdh+0xa0>
        goto exit;

    status = mbedtls_to_psa_error(
 c044d24:	4b26      	ldr	r3, [pc, #152]	@ (c044dc0 <psa_key_agreement_ecdh+0x110>)
 c044d26:	463a      	mov	r2, r7
 c044d28:	9301      	str	r3, [sp, #4]
 c044d2a:	4b26      	ldr	r3, [pc, #152]	@ (c044dc4 <psa_key_agreement_ecdh+0x114>)
 c044d2c:	4659      	mov	r1, fp
 c044d2e:	9300      	str	r3, [sp, #0]
 c044d30:	a803      	add	r0, sp, #12
 c044d32:	9b4e      	ldr	r3, [sp, #312]	@ 0x138
 c044d34:	f011 f8c4 	bl	c055ec0 <mbedtls_ecdh_calc_secret>
 c044d38:	f7ff fdc2 	bl	c0448c0 <mbedtls_to_psa_error>
        mbedtls_ecdh_calc_secret( &ecdh,
                                  shared_secret_length,
                                  shared_secret, shared_secret_size,
                                  mbedtls_psa_get_random,
                                  MBEDTLS_PSA_RANDOM_STATE ) );
    if( status != PSA_SUCCESS )
 c044d3c:	4605      	mov	r5, r0
 c044d3e:	b938      	cbnz	r0, c044d50 <psa_key_agreement_ecdh+0xa0>
        goto exit;
    if( PSA_BITS_TO_BYTES( bits ) != *shared_secret_length )
 c044d40:	f8db 3000 	ldr.w	r3, [fp]
 c044d44:	3407      	adds	r4, #7
 c044d46:	ebb3 0fd4 	cmp.w	r3, r4, lsr #3
 c044d4a:	d005      	beq.n	c044d58 <psa_key_agreement_ecdh+0xa8>
        status = PSA_ERROR_CORRUPTION_DETECTED;
 c044d4c:	f06f 0596 	mvn.w	r5, #150	@ 0x96

exit:
    if( status != PSA_SUCCESS )
        mbedtls_platform_zeroize( shared_secret, shared_secret_size );
 c044d50:	4638      	mov	r0, r7
 c044d52:	994e      	ldr	r1, [sp, #312]	@ 0x138
 c044d54:	f7f6 fb3c 	bl	c03b3d0 <mbedtls_platform_zeroize>
    mbedtls_ecdh_free( &ecdh );
 c044d58:	a803      	add	r0, sp, #12
 c044d5a:	f011 f863 	bl	c055e24 <mbedtls_ecdh_free>
    mbedtls_ecp_keypair_free( their_key );
 c044d5e:	6830      	ldr	r0, [r6, #0]
 c044d60:	f007 fdfd 	bl	c04c95e <mbedtls_ecp_keypair_free>
    mbedtls_free( their_key );
 c044d64:	6830      	ldr	r0, [r6, #0]
 c044d66:	f7f6 fb23 	bl	c03b3b0 <mbedtls_free>

    return( status );
}
 c044d6a:	4628      	mov	r0, r5
 c044d6c:	b045      	add	sp, #276	@ 0x114
 c044d6e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            *bits = 224;
 c044d72:	24e0      	movs	r4, #224	@ 0xe0
    switch( grpid )
 c044d74:	2512      	movs	r5, #18
 c044d76:	e7b6      	b.n	c044ce6 <psa_key_agreement_ecdh+0x36>
            *bits = 256;
 c044d78:	f44f 7480 	mov.w	r4, #256	@ 0x100
 c044d7c:	e7fa      	b.n	c044d74 <psa_key_agreement_ecdh+0xc4>
            *bits = 384;
 c044d7e:	f44f 74c0 	mov.w	r4, #384	@ 0x180
 c044d82:	e7f7      	b.n	c044d74 <psa_key_agreement_ecdh+0xc4>
            *bits = 521;
 c044d84:	f240 2409 	movw	r4, #521	@ 0x209
 c044d88:	e7f4      	b.n	c044d74 <psa_key_agreement_ecdh+0xc4>
            *bits = 256;
 c044d8a:	f44f 7480 	mov.w	r4, #256	@ 0x100
            return( PSA_ECC_FAMILY_BRAINPOOL_P_R1 );
 c044d8e:	2530      	movs	r5, #48	@ 0x30
            return( PSA_ECC_FAMILY_BRAINPOOL_P_R1 );
 c044d90:	e7a9      	b.n	c044ce6 <psa_key_agreement_ecdh+0x36>
            *bits = 384;
 c044d92:	f44f 74c0 	mov.w	r4, #384	@ 0x180
 c044d96:	e7fa      	b.n	c044d8e <psa_key_agreement_ecdh+0xde>
            *bits = 512;
 c044d98:	f44f 7400 	mov.w	r4, #512	@ 0x200
 c044d9c:	e7f7      	b.n	c044d8e <psa_key_agreement_ecdh+0xde>
            *bits = 255;
 c044d9e:	24ff      	movs	r4, #255	@ 0xff
            return( PSA_ECC_FAMILY_MONTGOMERY );
 c044da0:	2541      	movs	r5, #65	@ 0x41
            return( PSA_ECC_FAMILY_MONTGOMERY );
 c044da2:	e7a0      	b.n	c044ce6 <psa_key_agreement_ecdh+0x36>
            *bits = 192;
 c044da4:	24c0      	movs	r4, #192	@ 0xc0
            return( PSA_ECC_FAMILY_SECP_K1 );
 c044da6:	2517      	movs	r5, #23
            return( PSA_ECC_FAMILY_SECP_K1 );
 c044da8:	e79d      	b.n	c044ce6 <psa_key_agreement_ecdh+0x36>
            *bits = 224;
 c044daa:	24e0      	movs	r4, #224	@ 0xe0
 c044dac:	e7fb      	b.n	c044da6 <psa_key_agreement_ecdh+0xf6>
            *bits = 256;
 c044dae:	f44f 7480 	mov.w	r4, #256	@ 0x100
 c044db2:	e7f8      	b.n	c044da6 <psa_key_agreement_ecdh+0xf6>
            *bits = 448;
 c044db4:	f44f 74e0 	mov.w	r4, #448	@ 0x1c0
 c044db8:	e7f2      	b.n	c044da0 <psa_key_agreement_ecdh+0xf0>
    switch( grpid )
 c044dba:	24c0      	movs	r4, #192	@ 0xc0
 c044dbc:	e7da      	b.n	c044d74 <psa_key_agreement_ecdh+0xc4>
 c044dbe:	bf00      	nop
 c044dc0:	30031188 	.word	0x30031188
 c044dc4:	0c055d65 	.word	0x0c055d65

0c044dc8 <psa_key_agreement_raw_internal>:
                                                    const uint8_t *peer_key,
                                                    size_t peer_key_length,
                                                    uint8_t *shared_secret,
                                                    size_t shared_secret_size,
                                                    size_t *shared_secret_length )
{
 c044dc8:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
 c044dca:	461e      	mov	r6, r3
#if defined(MBEDTLS_PSA_BUILTIN_ALG_ECDH)
    mbedtls_ecp_keypair *ecp = NULL;
 c044dcc:	2300      	movs	r3, #0
 c044dce:	9303      	str	r3, [sp, #12]
    psa_status_t status;
#endif /* MBEDTLS_PSA_BUILTIN_ALG_ECDH */

    switch( alg )
 c044dd0:	4b16      	ldr	r3, [pc, #88]	@ (c044e2c <psa_key_agreement_raw_internal+0x64>)
{
 c044dd2:	4615      	mov	r5, r2
    switch( alg )
 c044dd4:	4298      	cmp	r0, r3
 c044dd6:	d122      	bne.n	c044e1e <psa_key_agreement_raw_internal+0x56>
    {
#if defined(MBEDTLS_PSA_BUILTIN_ALG_ECDH)
        case PSA_ALG_ECDH:
            if( ! PSA_KEY_TYPE_IS_ECC_KEY_PAIR( private_key->attr.type ) )
 c044dd8:	8808      	ldrh	r0, [r1, #0]
 c044dda:	f020 03ff 	bic.w	r3, r0, #255	@ 0xff
 c044dde:	f5b3 4fe2 	cmp.w	r3, #28928	@ 0x7100
 c044de2:	d11f      	bne.n	c044e24 <psa_key_agreement_raw_internal+0x5c>
                return( PSA_ERROR_INVALID_ARGUMENT );
            status = mbedtls_psa_ecp_load_representation(
 c044de4:	ab03      	add	r3, sp, #12
 c044de6:	9300      	str	r3, [sp, #0]
 c044de8:	e9d1 2309 	ldrd	r2, r3, [r1, #36]	@ 0x24
 c044dec:	8849      	ldrh	r1, [r1, #2]
 c044dee:	f002 ff2d 	bl	c047c4c <mbedtls_psa_ecp_load_representation>
                                      private_key->attr.type,
                                      private_key->attr.bits,
                                      private_key->key.data,
                                      private_key->key.bytes,
                                      &ecp );
            if( status != PSA_SUCCESS )
 c044df2:	4604      	mov	r4, r0
 c044df4:	b980      	cbnz	r0, c044e18 <psa_key_agreement_raw_internal+0x50>
                return( status );
            status = psa_key_agreement_ecdh( peer_key, peer_key_length,
 c044df6:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 c044df8:	4631      	mov	r1, r6
 c044dfa:	9301      	str	r3, [sp, #4]
 c044dfc:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 c044dfe:	9a03      	ldr	r2, [sp, #12]
 c044e00:	9300      	str	r3, [sp, #0]
 c044e02:	4628      	mov	r0, r5
 c044e04:	9b08      	ldr	r3, [sp, #32]
 c044e06:	f7ff ff53 	bl	c044cb0 <psa_key_agreement_ecdh>
 c044e0a:	4604      	mov	r4, r0
                                             ecp,
                                             shared_secret, shared_secret_size,
                                             shared_secret_length );
            mbedtls_ecp_keypair_free( ecp );
 c044e0c:	9803      	ldr	r0, [sp, #12]
 c044e0e:	f007 fda6 	bl	c04c95e <mbedtls_ecp_keypair_free>
            mbedtls_free( ecp );
 c044e12:	9803      	ldr	r0, [sp, #12]
 c044e14:	f7f6 facc 	bl	c03b3b0 <mbedtls_free>
            (void) shared_secret;
            (void) shared_secret_size;
            (void) shared_secret_length;
            return( PSA_ERROR_NOT_SUPPORTED );
    }
}
 c044e18:	4620      	mov	r0, r4
 c044e1a:	b004      	add	sp, #16
 c044e1c:	bd70      	pop	{r4, r5, r6, pc}
            return( PSA_ERROR_NOT_SUPPORTED );
 c044e1e:	f06f 0485 	mvn.w	r4, #133	@ 0x85
 c044e22:	e7f9      	b.n	c044e18 <psa_key_agreement_raw_internal+0x50>
                return( PSA_ERROR_INVALID_ARGUMENT );
 c044e24:	f06f 0486 	mvn.w	r4, #134	@ 0x86
 c044e28:	e7f6      	b.n	c044e18 <psa_key_agreement_raw_internal+0x50>
 c044e2a:	bf00      	nop
 c044e2c:	09020000 	.word	0x09020000

0c044e30 <mbedtls_ecc_group_of_psa>:
    switch( curve )
 c044e30:	2830      	cmp	r0, #48	@ 0x30
 c044e32:	d02c      	beq.n	c044e8e <mbedtls_ecc_group_of_psa+0x5e>
 c044e34:	d805      	bhi.n	c044e42 <mbedtls_ecc_group_of_psa+0x12>
 c044e36:	2812      	cmp	r0, #18
 c044e38:	d00f      	beq.n	c044e5a <mbedtls_ecc_group_of_psa+0x2a>
 c044e3a:	2817      	cmp	r0, #23
 c044e3c:	d034      	beq.n	c044ea8 <mbedtls_ecc_group_of_psa+0x78>
    return( MBEDTLS_ECP_DP_NONE );
 c044e3e:	2000      	movs	r0, #0
 c044e40:	4770      	bx	lr
    switch( curve )
 c044e42:	2841      	cmp	r0, #65	@ 0x41
 c044e44:	d1fb      	bne.n	c044e3e <mbedtls_ecc_group_of_psa+0xe>
            switch( bits )
 c044e46:	29ff      	cmp	r1, #255	@ 0xff
 c044e48:	d041      	beq.n	c044ece <mbedtls_ecc_group_of_psa+0x9e>
 c044e4a:	f5b1 7f80 	cmp.w	r1, #256	@ 0x100
 c044e4e:	d1f6      	bne.n	c044e3e <mbedtls_ecc_group_of_psa+0xe>
                    return( MBEDTLS_ECP_DP_CURVE25519 );
 c044e50:	2a00      	cmp	r2, #0
 c044e52:	bf0c      	ite	eq
 c044e54:	2000      	moveq	r0, #0
 c044e56:	2009      	movne	r0, #9
 c044e58:	4770      	bx	lr
            switch( bits )
 c044e5a:	f5b1 7fc0 	cmp.w	r1, #384	@ 0x180
 c044e5e:	d02a      	beq.n	c044eb6 <mbedtls_ecc_group_of_psa+0x86>
 c044e60:	d809      	bhi.n	c044e76 <mbedtls_ecc_group_of_psa+0x46>
 c044e62:	29e0      	cmp	r1, #224	@ 0xe0
 c044e64:	d029      	beq.n	c044eba <mbedtls_ecc_group_of_psa+0x8a>
 c044e66:	f5b1 7f80 	cmp.w	r1, #256	@ 0x100
 c044e6a:	d028      	beq.n	c044ebe <mbedtls_ecc_group_of_psa+0x8e>
 c044e6c:	f1a1 03c0 	sub.w	r3, r1, #192	@ 0xc0
 c044e70:	4258      	negs	r0, r3
 c044e72:	4158      	adcs	r0, r3
 c044e74:	4770      	bx	lr
 c044e76:	f240 2309 	movw	r3, #521	@ 0x209
 c044e7a:	4299      	cmp	r1, r3
 c044e7c:	d021      	beq.n	c044ec2 <mbedtls_ecc_group_of_psa+0x92>
 c044e7e:	f5b1 7f04 	cmp.w	r1, #528	@ 0x210
 c044e82:	d1dc      	bne.n	c044e3e <mbedtls_ecc_group_of_psa+0xe>
                    return( MBEDTLS_ECP_DP_SECP521R1 );
 c044e84:	2a00      	cmp	r2, #0
 c044e86:	bf0c      	ite	eq
 c044e88:	2000      	moveq	r0, #0
 c044e8a:	2005      	movne	r0, #5
 c044e8c:	4770      	bx	lr
            switch( bits )
 c044e8e:	f5b1 7fc0 	cmp.w	r1, #384	@ 0x180
 c044e92:	d018      	beq.n	c044ec6 <mbedtls_ecc_group_of_psa+0x96>
 c044e94:	f5b1 7f00 	cmp.w	r1, #512	@ 0x200
 c044e98:	d017      	beq.n	c044eca <mbedtls_ecc_group_of_psa+0x9a>
    return( MBEDTLS_ECP_DP_NONE );
 c044e9a:	f5b1 7f80 	cmp.w	r1, #256	@ 0x100
 c044e9e:	bf08      	it	eq
 c044ea0:	2006      	moveq	r0, #6
 c044ea2:	bf18      	it	ne
 c044ea4:	2000      	movne	r0, #0
 c044ea6:	4770      	bx	lr
            switch( bits )
 c044ea8:	29c0      	cmp	r1, #192	@ 0xc0
 c044eaa:	d012      	beq.n	c044ed2 <mbedtls_ecc_group_of_psa+0xa2>
    return( MBEDTLS_ECP_DP_NONE );
 c044eac:	f5b1 7f80 	cmp.w	r1, #256	@ 0x100
 c044eb0:	bf08      	it	eq
 c044eb2:	200c      	moveq	r0, #12
 c044eb4:	e7f5      	b.n	c044ea2 <mbedtls_ecc_group_of_psa+0x72>
                    return( MBEDTLS_ECP_DP_SECP384R1 );
 c044eb6:	2004      	movs	r0, #4
 c044eb8:	4770      	bx	lr
 c044eba:	2002      	movs	r0, #2
 c044ebc:	4770      	bx	lr
                    return( MBEDTLS_ECP_DP_SECP256R1 );
 c044ebe:	2003      	movs	r0, #3
 c044ec0:	4770      	bx	lr
                    return( MBEDTLS_ECP_DP_SECP521R1 );
 c044ec2:	2005      	movs	r0, #5
 c044ec4:	4770      	bx	lr
 c044ec6:	2007      	movs	r0, #7
 c044ec8:	4770      	bx	lr
                    return( MBEDTLS_ECP_DP_BP512R1 );
 c044eca:	2008      	movs	r0, #8
 c044ecc:	4770      	bx	lr
                    return( MBEDTLS_ECP_DP_CURVE25519 );
 c044ece:	2009      	movs	r0, #9
 c044ed0:	4770      	bx	lr
                    return( MBEDTLS_ECP_DP_SECP192K1 );
 c044ed2:	200a      	movs	r0, #10
}
 c044ed4:	4770      	bx	lr

0c044ed6 <psa_allocate_buffer_to_slot>:
{
 c044ed6:	b538      	push	{r3, r4, r5, lr}
 c044ed8:	4604      	mov	r4, r0
    if ( ( buffer_length == 0 ) && ( slot->key.data == NULL ) )
 c044eda:	460d      	mov	r5, r1
 c044edc:	6a43      	ldr	r3, [r0, #36]	@ 0x24
 c044ede:	b919      	cbnz	r1, c044ee8 <psa_allocate_buffer_to_slot+0x12>
 c044ee0:	b153      	cbz	r3, c044ef8 <psa_allocate_buffer_to_slot+0x22>
        return( PSA_ERROR_ALREADY_EXISTS );
 c044ee2:	f06f 008a 	mvn.w	r0, #138	@ 0x8a
 c044ee6:	e008      	b.n	c044efa <psa_allocate_buffer_to_slot+0x24>
    if( slot->key.data != NULL )
 c044ee8:	2b00      	cmp	r3, #0
 c044eea:	d1fa      	bne.n	c044ee2 <psa_allocate_buffer_to_slot+0xc>
    slot->key.data = mbedtls_calloc( 1, buffer_length );
 c044eec:	2001      	movs	r0, #1
 c044eee:	f7f6 fa59 	bl	c03b3a4 <mbedtls_calloc>
 c044ef2:	6260      	str	r0, [r4, #36]	@ 0x24
    if( slot->key.data == NULL )
 c044ef4:	b110      	cbz	r0, c044efc <psa_allocate_buffer_to_slot+0x26>
    slot->key.bytes = buffer_length;
 c044ef6:	62a5      	str	r5, [r4, #40]	@ 0x28
        return( PSA_SUCCESS );
 c044ef8:	2000      	movs	r0, #0
}
 c044efa:	bd38      	pop	{r3, r4, r5, pc}
        return( PSA_ERROR_INSUFFICIENT_MEMORY );
 c044efc:	f06f 008c 	mvn.w	r0, #140	@ 0x8c
 c044f00:	e7fb      	b.n	c044efa <psa_allocate_buffer_to_slot+0x24>

0c044f02 <psa_copy_key_material_into_slot>:
{
 c044f02:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 c044f04:	460f      	mov	r7, r1
    psa_status_t status = psa_allocate_buffer_to_slot( slot,
 c044f06:	4611      	mov	r1, r2
{
 c044f08:	4606      	mov	r6, r0
 c044f0a:	4615      	mov	r5, r2
    psa_status_t status = psa_allocate_buffer_to_slot( slot,
 c044f0c:	f7ff ffe3 	bl	c044ed6 <psa_allocate_buffer_to_slot>
    if( status != PSA_SUCCESS )
 c044f10:	4604      	mov	r4, r0
 c044f12:	b920      	cbnz	r0, c044f1e <psa_copy_key_material_into_slot+0x1c>
    memcpy( slot->key.data, data, data_length );
 c044f14:	462a      	mov	r2, r5
 c044f16:	4639      	mov	r1, r7
 c044f18:	6a70      	ldr	r0, [r6, #36]	@ 0x24
 c044f1a:	f016 fb97 	bl	c05b64c <memcpy>
}
 c044f1e:	4620      	mov	r0, r4
 c044f20:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

0c044f24 <psa_start_key_creation>:
{
 c044f24:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    return( attributes->core.id );
 c044f28:	e9d1 6801 	ldrd	r6, r8, [r1, #4]
 c044f2c:	4699      	mov	r9, r3
    *p_drv = NULL;
 c044f2e:	2300      	movs	r3, #0
{
 c044f30:	4682      	mov	sl, r0
 c044f32:	460d      	mov	r5, r1
    status = psa_validate_key_location( lifetime, p_drv );
 c044f34:	4630      	mov	r0, r6
 c044f36:	4649      	mov	r1, r9
{
 c044f38:	b086      	sub	sp, #24
    *p_drv = NULL;
 c044f3a:	f8c9 3000 	str.w	r3, [r9]
{
 c044f3e:	4617      	mov	r7, r2
    status = psa_validate_key_location( lifetime, p_drv );
 c044f40:	f004 f8c2 	bl	c0490c8 <psa_validate_key_location>
    if( status != PSA_SUCCESS )
 c044f44:	4604      	mov	r4, r0
 c044f46:	b988      	cbnz	r0, c044f6c <psa_start_key_creation+0x48>
    status = psa_validate_key_persistence( lifetime );
 c044f48:	4630      	mov	r0, r6
 c044f4a:	f004 f8cd 	bl	c0490e8 <psa_validate_key_persistence>
    if( status != PSA_SUCCESS )
 c044f4e:	4604      	mov	r4, r0
 c044f50:	b960      	cbnz	r0, c044f6c <psa_start_key_creation+0x48>
    if ( PSA_KEY_LIFETIME_IS_VOLATILE( lifetime ) )
 c044f52:	b2f6      	uxtb	r6, r6
 c044f54:	b976      	cbnz	r6, c044f74 <psa_start_key_creation+0x50>
        if( MBEDTLS_SVC_KEY_ID_GET_KEY_ID( key ) != 0 )
 c044f56:	f1b8 0f00 	cmp.w	r8, #0
 c044f5a:	d105      	bne.n	c044f68 <psa_start_key_creation+0x44>
    if( ( policy->usage & ~( PSA_KEY_USAGE_EXPORT |
 c044f5c:	692b      	ldr	r3, [r5, #16]
 c044f5e:	f423 43fe 	bic.w	r3, r3, #32512	@ 0x7f00
 c044f62:	f023 0303 	bic.w	r3, r3, #3
 c044f66:	b183      	cbz	r3, c044f8a <psa_start_key_creation+0x66>
            return( PSA_ERROR_INVALID_ARGUMENT );
 c044f68:	f06f 0486 	mvn.w	r4, #134	@ 0x86
}
 c044f6c:	4620      	mov	r0, r4
 c044f6e:	b006      	add	sp, #24
 c044f70:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 c044f74:	ab04      	add	r3, sp, #16
 c044f76:	e9d5 0102 	ldrd	r0, r1, [r5, #8]
        if( !psa_is_valid_key_id( psa_get_key_id( attributes ), 1 ) )
 c044f7a:	2201      	movs	r2, #1
 c044f7c:	e883 0003 	stmia.w	r3, {r0, r1}
 c044f80:	f003 ff78 	bl	c048e74 <psa_is_valid_key_id>
 c044f84:	2800      	cmp	r0, #0
 c044f86:	d1e9      	bne.n	c044f5c <psa_start_key_creation+0x38>
 c044f88:	e7ee      	b.n	c044f68 <psa_start_key_creation+0x44>
    if( psa_get_key_bits( attributes ) > PSA_MAX_KEY_BITS )
 c044f8a:	f64f 73f8 	movw	r3, #65528	@ 0xfff8
 c044f8e:	886a      	ldrh	r2, [r5, #2]
 c044f90:	429a      	cmp	r2, r3
 c044f92:	d853      	bhi.n	c04503c <psa_start_key_creation+0x118>
    if( attributes->core.flags & ~ ( MBEDTLS_PSA_KA_MASK_EXTERNAL_ONLY |
 c044f94:	8bab      	ldrh	r3, [r5, #28]
 c044f96:	2b01      	cmp	r3, #1
 c044f98:	d8e6      	bhi.n	c044f68 <psa_start_key_creation+0x44>
    status = psa_get_empty_key_slot( &volatile_key_id, p_slot );
 c044f9a:	4639      	mov	r1, r7
 c044f9c:	a801      	add	r0, sp, #4
 c044f9e:	f003 ffe3 	bl	c048f68 <psa_get_empty_key_slot>
    if( status != PSA_SUCCESS )
 c044fa2:	4604      	mov	r4, r0
 c044fa4:	2800      	cmp	r0, #0
 c044fa6:	d1e1      	bne.n	c044f6c <psa_start_key_creation+0x48>
    slot = *p_slot;
 c044fa8:	f8d7 8000 	ldr.w	r8, [r7]
    slot->attr = attributes->core;
 c044fac:	462f      	mov	r7, r5
 c044fae:	4646      	mov	r6, r8
 c044fb0:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
 c044fb2:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 c044fb4:	e897 000f 	ldmia.w	r7, {r0, r1, r2, r3}
 c044fb8:	e886 000f 	stmia.w	r6, {r0, r1, r2, r3}
    if( PSA_KEY_LIFETIME_IS_VOLATILE( slot->attr.lifetime ) )
 c044fbc:	f898 3004 	ldrb.w	r3, [r8, #4]
 c044fc0:	b913      	cbnz	r3, c044fc8 <psa_start_key_creation+0xa4>
        slot->attr.id.key_id = volatile_key_id;
 c044fc2:	9b01      	ldr	r3, [sp, #4]
 c044fc4:	f8c8 3008 	str.w	r3, [r8, #8]
    slot->attr.flags &= ~MBEDTLS_PSA_KA_MASK_EXTERNAL_ONLY;
 c044fc8:	f8b8 301c 	ldrh.w	r3, [r8, #28]
    if( *p_drv != NULL )
 c044fcc:	f8d9 2000 	ldr.w	r2, [r9]
    slot->attr.flags &= ~MBEDTLS_PSA_KA_MASK_EXTERNAL_ONLY;
 c044fd0:	f023 0301 	bic.w	r3, r3, #1
 c044fd4:	f8a8 301c 	strh.w	r3, [r8, #28]
    if( *p_drv != NULL )
 c044fd8:	b352      	cbz	r2, c045030 <psa_start_key_creation+0x10c>
        status = psa_find_se_slot_for_key( attributes, method, *p_drv,
 c044fda:	4651      	mov	r1, sl
 c044fdc:	4628      	mov	r0, r5
 c044fde:	ab02      	add	r3, sp, #8
 c044fe0:	f003 fe7e 	bl	c048ce0 <psa_find_se_slot_for_key>
        if( status != PSA_SUCCESS )
 c044fe4:	4606      	mov	r6, r0
 c044fe6:	b9b8      	cbnz	r0, c045018 <psa_start_key_creation+0xf4>
        if( ! PSA_KEY_LIFETIME_IS_VOLATILE( attributes->core.lifetime ) )
 c044fe8:	792b      	ldrb	r3, [r5, #4]
 c044fea:	b1bb      	cbz	r3, c04501c <psa_start_key_creation+0xf8>
 * \param type          The type of transaction to start.
 */
static inline void psa_crypto_prepare_transaction(
    psa_crypto_transaction_type_t type )
{
    psa_crypto_transaction.unknown.type = type;
 c044fec:	2301      	movs	r3, #1
 c044fee:	4915      	ldr	r1, [pc, #84]	@ (c045044 <psa_start_key_creation+0x120>)
 c044ff0:	800b      	strh	r3, [r1, #0]
            psa_crypto_transaction.key.lifetime = slot->attr.lifetime;
 c044ff2:	f8d8 3004 	ldr.w	r3, [r8, #4]
 c044ff6:	604b      	str	r3, [r1, #4]
            psa_crypto_transaction.key.slot = slot_number;
 c044ff8:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 c044ffc:	e9c1 2302 	strd	r2, r3, [r1, #8]
            psa_crypto_transaction.key.id = slot->attr.id;
 c045000:	f101 0310 	add.w	r3, r1, #16
 c045004:	e9d8 0102 	ldrd	r0, r1, [r8, #8]
 c045008:	e883 0003 	stmia.w	r3, {r0, r1}
            status = psa_crypto_save_transaction( );
 c04500c:	f004 fa38 	bl	c049480 <psa_crypto_save_transaction>
            if( status != PSA_SUCCESS )
 c045010:	4606      	mov	r6, r0
 c045012:	b118      	cbz	r0, c04501c <psa_start_key_creation+0xf8>
                (void) psa_crypto_stop_transaction( );
 c045014:	f004 fa68 	bl	c0494e8 <psa_crypto_stop_transaction>
            return( status );
 c045018:	4634      	mov	r4, r6
 c04501a:	e7a7      	b.n	c044f6c <psa_start_key_creation+0x48>
        status = psa_copy_key_material_into_slot(
 c04501c:	2208      	movs	r2, #8
 c04501e:	4640      	mov	r0, r8
 c045020:	eb0d 0102 	add.w	r1, sp, r2
 c045024:	f7ff ff6d 	bl	c044f02 <psa_copy_key_material_into_slot>
    if( *p_drv == NULL && method == PSA_KEY_CREATION_REGISTER )
 c045028:	f8d9 3000 	ldr.w	r3, [r9]
 c04502c:	2b00      	cmp	r3, #0
 c04502e:	d19d      	bne.n	c044f6c <psa_start_key_creation+0x48>
        return( PSA_ERROR_INVALID_ARGUMENT );
 c045030:	f1ba 0f04 	cmp.w	sl, #4
 c045034:	bf08      	it	eq
 c045036:	f06f 0486 	mvneq.w	r4, #134	@ 0x86
 c04503a:	e797      	b.n	c044f6c <psa_start_key_creation+0x48>
        return( PSA_ERROR_NOT_SUPPORTED );
 c04503c:	f06f 0485 	mvn.w	r4, #133	@ 0x85
 c045040:	e794      	b.n	c044f6c <psa_start_key_creation+0x48>
 c045042:	bf00      	nop
 c045044:	30031818 	.word	0x30031818

0c045048 <psa_import_key_into_slot>:
{
 c045048:	e92d 4ff1 	stmdb	sp!, {r0, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c04504c:	f8dd a030 	ldr.w	sl, [sp, #48]	@ 0x30
 c045050:	4606      	mov	r6, r0
 c045052:	e9dd b80a 	ldrd	fp, r8, [sp, #40]	@ 0x28
 c045056:	4689      	mov	r9, r1
 c045058:	461f      	mov	r7, r3
    if(( data_length == 0 ) && ( data == NULL )) {
 c04505a:	4615      	mov	r5, r2
    psa_key_type_t type = attributes->core.type;
 c04505c:	8804      	ldrh	r4, [r0, #0]
    if(( data_length == 0 ) && ( data == NULL )) {
 c04505e:	b92a      	cbnz	r2, c04506c <psa_import_key_into_slot+0x24>
 c045060:	b1e9      	cbz	r1, c04509e <psa_import_key_into_slot+0x56>
            return( PSA_ERROR_NOT_SUPPORTED );
 c045062:	f06f 0085 	mvn.w	r0, #133	@ 0x85
}
 c045066:	b001      	add	sp, #4
 c045068:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if( key_type_is_raw_bytes( type ) )
 c04506c:	4620      	mov	r0, r4
 c04506e:	f7fe fe77 	bl	c043d60 <key_type_is_raw_bytes>
 c045072:	b1b0      	cbz	r0, c0450a2 <psa_import_key_into_slot+0x5a>
        *bits = PSA_BYTES_TO_BITS( data_length );
 c045074:	00d1      	lsls	r1, r2, #3
        if( data_length > SIZE_MAX / 8 )
 c045076:	f1b2 5f00 	cmp.w	r2, #536870912	@ 0x20000000
        *bits = PSA_BYTES_TO_BITS( data_length );
 c04507a:	f8ca 1000 	str.w	r1, [sl]
        if( data_length > SIZE_MAX / 8 )
 c04507e:	d2f0      	bcs.n	c045062 <psa_import_key_into_slot+0x1a>
        if( ( *bits ) > PSA_MAX_KEY_BITS )
 c045080:	f64f 73f8 	movw	r3, #65528	@ 0xfff8
 c045084:	4299      	cmp	r1, r3
 c045086:	d8ec      	bhi.n	c045062 <psa_import_key_into_slot+0x1a>
        status = validate_unstructured_key_bit_size( type, *bits );
 c045088:	4620      	mov	r0, r4
 c04508a:	f7ff fa15 	bl	c0444b8 <validate_unstructured_key_bit_size>
        if( status != PSA_SUCCESS )
 c04508e:	2800      	cmp	r0, #0
 c045090:	d1e9      	bne.n	c045066 <psa_import_key_into_slot+0x1e>
        memcpy( key_buffer, data, data_length );
 c045092:	4649      	mov	r1, r9
 c045094:	4638      	mov	r0, r7
 c045096:	f016 fad9 	bl	c05b64c <memcpy>
        *key_buffer_length = data_length;
 c04509a:	f8c8 5000 	str.w	r5, [r8]
        return( PSA_SUCCESS );
 c04509e:	2000      	movs	r0, #0
 c0450a0:	e7e1      	b.n	c045066 <psa_import_key_into_slot+0x1e>
    else if( PSA_KEY_TYPE_IS_ASYMMETRIC( type ) )
 c0450a2:	0463      	lsls	r3, r4, #17
 c0450a4:	d5dd      	bpl.n	c045062 <psa_import_key_into_slot+0x1a>
        if( PSA_KEY_TYPE_IS_ECC( type ) )
 c0450a6:	f404 434f 	and.w	r3, r4, #52992	@ 0xcf00
 c0450aa:	f5b3 4f82 	cmp.w	r3, #16640	@ 0x4100
 c0450ae:	d10a      	bne.n	c0450c6 <psa_import_key_into_slot+0x7e>
            return( mbedtls_psa_ecp_import_key( attributes,
 c0450b0:	463b      	mov	r3, r7
 c0450b2:	4630      	mov	r0, r6
 c0450b4:	e9cd 8a0b 	strd	r8, sl, [sp, #44]	@ 0x2c
 c0450b8:	f8cd b028 	str.w	fp, [sp, #40]	@ 0x28
}
 c0450bc:	b001      	add	sp, #4
 c0450be:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
            return( mbedtls_psa_ecp_import_key( attributes,
 c0450c2:	f002 be95 	b.w	c047df0 <mbedtls_psa_ecp_import_key>
        if( PSA_KEY_TYPE_IS_RSA( type ) )
 c0450c6:	f244 0301 	movw	r3, #16385	@ 0x4001
 c0450ca:	f424 5440 	bic.w	r4, r4, #12288	@ 0x3000
 c0450ce:	429c      	cmp	r4, r3
 c0450d0:	d1c7      	bne.n	c045062 <psa_import_key_into_slot+0x1a>
            return( mbedtls_psa_rsa_import_key( attributes,
 c0450d2:	463b      	mov	r3, r7
 c0450d4:	4630      	mov	r0, r6
 c0450d6:	e9cd 8a0b 	strd	r8, sl, [sp, #44]	@ 0x2c
 c0450da:	f8cd b028 	str.w	fp, [sp, #40]	@ 0x28
}
 c0450de:	b001      	add	sp, #4
 c0450e0:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
            return( mbedtls_psa_rsa_import_key( attributes,
 c0450e4:	f003 bc30 	b.w	c048948 <mbedtls_psa_rsa_import_key>

0c0450e8 <psa_remove_key_data_from_memory>:
{
 c0450e8:	b510      	push	{r4, lr}
 c0450ea:	4604      	mov	r4, r0
    if( slot->key.data != NULL )
 c0450ec:	6a40      	ldr	r0, [r0, #36]	@ 0x24
 c0450ee:	b110      	cbz	r0, c0450f6 <psa_remove_key_data_from_memory+0xe>
        mbedtls_platform_zeroize( slot->key.data, slot->key.bytes);
 c0450f0:	6aa1      	ldr	r1, [r4, #40]	@ 0x28
 c0450f2:	f7f6 f96d 	bl	c03b3d0 <mbedtls_platform_zeroize>
    mbedtls_free( slot->key.data );
 c0450f6:	6a60      	ldr	r0, [r4, #36]	@ 0x24
 c0450f8:	f7f6 f95a 	bl	c03b3b0 <mbedtls_free>
    slot->key.data = NULL;
 c0450fc:	2000      	movs	r0, #0
    slot->key.bytes = 0;
 c0450fe:	e9c4 0009 	strd	r0, r0, [r4, #36]	@ 0x24
}
 c045102:	bd10      	pop	{r4, pc}

0c045104 <psa_wipe_key_slot>:
{
 c045104:	b538      	push	{r3, r4, r5, lr}
 c045106:	4604      	mov	r4, r0
    psa_status_t status = psa_remove_key_data_from_memory( slot );
 c045108:	f7ff ffee 	bl	c0450e8 <psa_remove_key_data_from_memory>
    if( slot->lock_count != 1 )
 c04510c:	6a23      	ldr	r3, [r4, #32]
    memset( slot, 0, sizeof( *slot ) );
 c04510e:	222c      	movs	r2, #44	@ 0x2c
        status = PSA_ERROR_CORRUPTION_DETECTED;
 c045110:	2b01      	cmp	r3, #1
 c045112:	bf0c      	ite	eq
 c045114:	4605      	moveq	r5, r0
 c045116:	f06f 0596 	mvnne.w	r5, #150	@ 0x96
    memset( slot, 0, sizeof( *slot ) );
 c04511a:	2100      	movs	r1, #0
 c04511c:	4620      	mov	r0, r4
 c04511e:	f016 fb06 	bl	c05b72e <memset>
}
 c045122:	4628      	mov	r0, r5
 c045124:	bd38      	pop	{r3, r4, r5, pc}

0c045126 <psa_fail_key_creation.constprop.0>:
static void psa_fail_key_creation( psa_key_slot_t *slot,
 c045126:	b510      	push	{r4, lr}
    if( slot == NULL )
 c045128:	4604      	mov	r4, r0
 c04512a:	b130      	cbz	r0, c04513a <psa_fail_key_creation.constprop.0+0x14>
    (void) psa_crypto_stop_transaction( );
 c04512c:	f004 f9dc 	bl	c0494e8 <psa_crypto_stop_transaction>
    psa_wipe_key_slot( slot );
 c045130:	4620      	mov	r0, r4
}
 c045132:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    psa_wipe_key_slot( slot );
 c045136:	f7ff bfe5 	b.w	c045104 <psa_wipe_key_slot>
}
 c04513a:	bd10      	pop	{r4, pc}

0c04513c <mbedcrypto__psa_destroy_key>:
{
 c04513c:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
 c04513e:	466b      	mov	r3, sp
    if( mbedtls_svc_key_id_is_null( key ) )
 c045140:	4604      	mov	r4, r0
{
 c045142:	e883 0003 	stmia.w	r3, {r0, r1}
    if( mbedtls_svc_key_id_is_null( key ) )
 c045146:	b170      	cbz	r0, c045166 <mbedcrypto__psa_destroy_key+0x2a>
    status = psa_get_and_lock_key_slot( key, &slot );
 c045148:	e893 0003 	ldmia.w	r3, {r0, r1}
 c04514c:	aa03      	add	r2, sp, #12
 c04514e:	f003 ff4d 	bl	c048fec <psa_get_and_lock_key_slot>
    if( status != PSA_SUCCESS )
 c045152:	4604      	mov	r4, r0
 c045154:	b938      	cbnz	r0, c045166 <mbedcrypto__psa_destroy_key+0x2a>
    if( slot->lock_count > 1 )
 c045156:	9803      	ldr	r0, [sp, #12]
 c045158:	6a03      	ldr	r3, [r0, #32]
 c04515a:	2b01      	cmp	r3, #1
 c04515c:	d906      	bls.n	c04516c <mbedcrypto__psa_destroy_key+0x30>
       psa_unlock_key_slot( slot );
 c04515e:	f003 ffa9 	bl	c0490b4 <psa_unlock_key_slot>
       return( PSA_ERROR_GENERIC_ERROR );
 c045162:	f06f 0483 	mvn.w	r4, #131	@ 0x83
}
 c045166:	4620      	mov	r0, r4
 c045168:	b004      	add	sp, #16
 c04516a:	bd70      	pop	{r4, r5, r6, pc}
    if( PSA_KEY_LIFETIME_IS_READ_ONLY( slot->attr.lifetime ) )
 c04516c:	6840      	ldr	r0, [r0, #4]
 c04516e:	b2c3      	uxtb	r3, r0
 c045170:	2bff      	cmp	r3, #255	@ 0xff
 c045172:	d041      	beq.n	c0451f8 <mbedcrypto__psa_destroy_key+0xbc>
    driver = psa_get_se_driver_entry( slot->attr.lifetime );
 c045174:	f003 fd62 	bl	c048c3c <psa_get_se_driver_entry>
    if( driver != NULL )
 c045178:	4606      	mov	r6, r0
 c04517a:	b328      	cbz	r0, c0451c8 <mbedcrypto__psa_destroy_key+0x8c>
 c04517c:	2202      	movs	r2, #2
 c04517e:	4b21      	ldr	r3, [pc, #132]	@ (c045204 <mbedcrypto__psa_destroy_key+0xc8>)
 c045180:	801a      	strh	r2, [r3, #0]
        psa_crypto_transaction.key.lifetime = slot->attr.lifetime;
 c045182:	9a03      	ldr	r2, [sp, #12]
        psa_crypto_transaction.key.id = slot->attr.id;
 c045184:	3310      	adds	r3, #16
        psa_crypto_transaction.key.lifetime = slot->attr.lifetime;
 c045186:	6851      	ldr	r1, [r2, #4]
 c045188:	f843 1c0c 	str.w	r1, [r3, #-12]
 c04518c:	6a51      	ldr	r1, [r2, #36]	@ 0x24
 c04518e:	e9d1 0100 	ldrd	r0, r1, [r1]
        psa_crypto_transaction.key.slot = psa_key_slot_get_slot_number( slot );
 c045192:	e943 0102 	strd	r0, r1, [r3, #-8]
        psa_crypto_transaction.key.id = slot->attr.id;
 c045196:	e9d2 0102 	ldrd	r0, r1, [r2, #8]
 c04519a:	e883 0003 	stmia.w	r3, {r0, r1}
        status = psa_crypto_save_transaction( );
 c04519e:	f004 f96f 	bl	c049480 <psa_crypto_save_transaction>
        if( status != PSA_SUCCESS )
 c0451a2:	4604      	mov	r4, r0
 c0451a4:	b140      	cbz	r0, c0451b8 <mbedcrypto__psa_destroy_key+0x7c>
            (void) psa_crypto_stop_transaction( );
 c0451a6:	f004 f99f 	bl	c0494e8 <psa_crypto_stop_transaction>
    status = psa_wipe_key_slot( slot );
 c0451aa:	9803      	ldr	r0, [sp, #12]
 c0451ac:	f7ff ffaa 	bl	c045104 <psa_wipe_key_slot>
    if( status != PSA_SUCCESS )
 c0451b0:	2800      	cmp	r0, #0
 c0451b2:	bf18      	it	ne
 c0451b4:	4604      	movne	r4, r0
 c0451b6:	e7d6      	b.n	c045166 <mbedcrypto__psa_destroy_key+0x2a>
 c0451b8:	9b03      	ldr	r3, [sp, #12]
        status = psa_destroy_se_key( driver,
 c0451ba:	4630      	mov	r0, r6
 c0451bc:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 c0451be:	e9d3 2300 	ldrd	r2, r3, [r3]
 c0451c2:	f003 fdcd 	bl	c048d60 <psa_destroy_se_key>
 c0451c6:	4604      	mov	r4, r0
    if( ! PSA_KEY_LIFETIME_IS_VOLATILE( slot->attr.lifetime ) )
 c0451c8:	9b03      	ldr	r3, [sp, #12]
 c0451ca:	791a      	ldrb	r2, [r3, #4]
 c0451cc:	b12a      	cbz	r2, c0451da <mbedcrypto__psa_destroy_key+0x9e>
        status = psa_destroy_persistent_key( slot->attr.id );
 c0451ce:	e9d3 0102 	ldrd	r0, r1, [r3, #8]
 c0451d2:	f003 fff7 	bl	c0491c4 <psa_destroy_persistent_key>
 c0451d6:	4605      	mov	r5, r0
        if( overall_status == PSA_SUCCESS )
 c0451d8:	b104      	cbz	r4, c0451dc <mbedcrypto__psa_destroy_key+0xa0>
{
 c0451da:	4625      	mov	r5, r4
    if( driver != NULL )
 c0451dc:	b17e      	cbz	r6, c0451fe <mbedcrypto__psa_destroy_key+0xc2>
        status = psa_save_se_persistent_data( driver );
 c0451de:	4630      	mov	r0, r6
 c0451e0:	f003 fd6d 	bl	c048cbe <psa_save_se_persistent_data>
            overall_status = status;
 c0451e4:	2d00      	cmp	r5, #0
 c0451e6:	bf08      	it	eq
 c0451e8:	4605      	moveq	r5, r0
        status = psa_crypto_stop_transaction( );
 c0451ea:	f004 f97d 	bl	c0494e8 <psa_crypto_stop_transaction>
exit:
 c0451ee:	2d00      	cmp	r5, #0
 c0451f0:	bf14      	ite	ne
 c0451f2:	462c      	movne	r4, r5
 c0451f4:	4604      	moveq	r4, r0
 c0451f6:	e7d8      	b.n	c0451aa <mbedcrypto__psa_destroy_key+0x6e>
        overall_status = PSA_ERROR_NOT_PERMITTED;
 c0451f8:	f06f 0484 	mvn.w	r4, #132	@ 0x84
 c0451fc:	e7d5      	b.n	c0451aa <mbedcrypto__psa_destroy_key+0x6e>
exit:
 c0451fe:	462c      	mov	r4, r5
 c045200:	e7d3      	b.n	c0451aa <mbedcrypto__psa_destroy_key+0x6e>
 c045202:	bf00      	nop
 c045204:	30031818 	.word	0x30031818

0c045208 <mbedcrypto__psa_get_key_attributes>:
{
 c045208:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 c04520c:	b08a      	sub	sp, #40	@ 0x28
 c04520e:	ac02      	add	r4, sp, #8
 c045210:	e884 0003 	stmia.w	r4, {r0, r1}
    psa_reset_key_attributes( attributes );
 c045214:	4610      	mov	r0, r2
{
 c045216:	4616      	mov	r6, r2
    psa_reset_key_attributes( attributes );
 c045218:	f002 fa7d 	bl	c047716 <mbedcrypto__psa_reset_key_attributes>
    status = psa_get_and_lock_key_slot_with_policy( key, &slot, 0, 0 );
 c04521c:	2300      	movs	r3, #0
 c04521e:	9300      	str	r3, [sp, #0]
 c045220:	aa05      	add	r2, sp, #20
 c045222:	e894 0003 	ldmia.w	r4, {r0, r1}
 c045226:	f7ff f9af 	bl	c044588 <psa_get_and_lock_key_slot_with_policy>
    if( status != PSA_SUCCESS )
 c04522a:	2800      	cmp	r0, #0
 c04522c:	d12d      	bne.n	c04528a <mbedcrypto__psa_get_key_attributes+0x82>
    attributes->core = slot->attr;
 c04522e:	9f05      	ldr	r7, [sp, #20]
 c045230:	4634      	mov	r4, r6
 c045232:	463d      	mov	r5, r7
 c045234:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 c045236:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 c045238:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
 c04523c:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
    attributes->core.flags &= ( MBEDTLS_PSA_KA_MASK_EXTERNAL_ONLY |
 c045240:	8bb3      	ldrh	r3, [r6, #28]
    if( psa_get_se_driver_entry( slot->attr.lifetime ) != NULL )
 c045242:	6878      	ldr	r0, [r7, #4]
    attributes->core.flags &= ( MBEDTLS_PSA_KA_MASK_EXTERNAL_ONLY |
 c045244:	f003 0301 	and.w	r3, r3, #1
 c045248:	83b3      	strh	r3, [r6, #28]
    if( psa_get_se_driver_entry( slot->attr.lifetime ) != NULL )
 c04524a:	f003 fcf7 	bl	c048c3c <psa_get_se_driver_entry>
 c04524e:	9905      	ldr	r1, [sp, #20]
 c045250:	b140      	cbz	r0, c045264 <mbedcrypto__psa_get_key_attributes+0x5c>
 c045252:	6a4b      	ldr	r3, [r1, #36]	@ 0x24
 c045254:	e9d3 4500 	ldrd	r4, r5, [r3]
    attributes->core.flags |= MBEDTLS_PSA_KA_FLAG_HAS_SLOT_NUMBER;
 c045258:	8bb3      	ldrh	r3, [r6, #28]
    attributes->slot_number = slot_number;
 c04525a:	e9c6 4508 	strd	r4, r5, [r6, #32]
    attributes->core.flags |= MBEDTLS_PSA_KA_FLAG_HAS_SLOT_NUMBER;
 c04525e:	f043 0301 	orr.w	r3, r3, #1
 c045262:	83b3      	strh	r3, [r6, #28]
    switch( slot->attr.type )
 c045264:	f244 0301 	movw	r3, #16385	@ 0x4001
 c045268:	8808      	ldrh	r0, [r1, #0]
 c04526a:	4298      	cmp	r0, r3
 c04526c:	d003      	beq.n	c045276 <mbedcrypto__psa_get_key_attributes+0x6e>
 c04526e:	f247 0301 	movw	r3, #28673	@ 0x7001
 c045272:	4298      	cmp	r0, r3
 c045274:	d102      	bne.n	c04527c <mbedcrypto__psa_get_key_attributes+0x74>
 c045276:	684b      	ldr	r3, [r1, #4]
            if( ! psa_key_lifetime_is_external( slot->attr.lifetime ) )
 c045278:	0a1b      	lsrs	r3, r3, #8
 c04527a:	d009      	beq.n	c045290 <mbedcrypto__psa_get_key_attributes+0x88>
        ret = MBEDTLS_ERR_MPI_ALLOC_FAILED;
 c04527c:	2400      	movs	r4, #0
    unlock_status = psa_unlock_key_slot( slot );
 c04527e:	9805      	ldr	r0, [sp, #20]
 c045280:	f003 ff18 	bl	c0490b4 <psa_unlock_key_slot>
    return( ( status == PSA_SUCCESS ) ? unlock_status : status );
 c045284:	2c00      	cmp	r4, #0
 c045286:	bf18      	it	ne
 c045288:	4620      	movne	r0, r4
}
 c04528a:	b00a      	add	sp, #40	@ 0x28
 c04528c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
                mbedtls_rsa_context *rsa = NULL;
 c045290:	9306      	str	r3, [sp, #24]
                status = mbedtls_psa_rsa_load_representation(
 c045292:	e9d1 1209 	ldrd	r1, r2, [r1, #36]	@ 0x24
 c045296:	ab06      	add	r3, sp, #24
 c045298:	f003 fab4 	bl	c048804 <mbedtls_psa_rsa_load_representation>
                if( status != PSA_SUCCESS )
 c04529c:	4604      	mov	r4, r0
 c04529e:	2800      	cmp	r0, #0
 c0452a0:	d13b      	bne.n	c04531a <mbedcrypto__psa_get_key_attributes+0x112>
                status = psa_get_rsa_public_exponent( rsa,
 c0452a2:	9d06      	ldr	r5, [sp, #24]
    mbedtls_mpi_init( &mpi );
 c0452a4:	af07      	add	r7, sp, #28
 c0452a6:	4638      	mov	r0, r7
 c0452a8:	f00e f825 	bl	c0532f6 <mbedtls_mpi_init>
    ret = mbedtls_rsa_export( rsa, NULL, NULL, NULL, NULL, &mpi );
 c0452ac:	4628      	mov	r0, r5
 c0452ae:	4623      	mov	r3, r4
 c0452b0:	4622      	mov	r2, r4
 c0452b2:	4621      	mov	r1, r4
 c0452b4:	e9cd 4700 	strd	r4, r7, [sp]
 c0452b8:	f00a f916 	bl	c04f4e8 <mbedtls_rsa_export>
    if( ret != 0 )
 c0452bc:	4605      	mov	r5, r0
 c0452be:	b9c8      	cbnz	r0, c0452f4 <mbedcrypto__psa_get_key_attributes+0xec>
    if( mbedtls_mpi_cmp_int( &mpi, 65537 ) == 0 )
 c0452c0:	f04f 1101 	mov.w	r1, #65537	@ 0x10001
 c0452c4:	4638      	mov	r0, r7
 c0452c6:	f00e fafc 	bl	c0538c2 <mbedtls_mpi_cmp_int>
 c0452ca:	4605      	mov	r5, r0
 c0452cc:	b348      	cbz	r0, c045322 <mbedcrypto__psa_get_key_attributes+0x11a>
    buflen = mbedtls_mpi_size( &mpi );
 c0452ce:	4638      	mov	r0, r7
 c0452d0:	f00e f943 	bl	c05355a <mbedtls_mpi_size>
    buffer = mbedtls_calloc( 1, buflen );
 c0452d4:	4601      	mov	r1, r0
    buflen = mbedtls_mpi_size( &mpi );
 c0452d6:	4680      	mov	r8, r0
    buffer = mbedtls_calloc( 1, buflen );
 c0452d8:	2001      	movs	r0, #1
 c0452da:	f7f6 f863 	bl	c03b3a4 <mbedtls_calloc>
    if( buffer == NULL )
 c0452de:	4604      	mov	r4, r0
 c0452e0:	b308      	cbz	r0, c045326 <mbedcrypto__psa_get_key_attributes+0x11e>
    ret = mbedtls_mpi_write_binary( &mpi, buffer, buflen );
 c0452e2:	4601      	mov	r1, r0
 c0452e4:	4642      	mov	r2, r8
 c0452e6:	4638      	mov	r0, r7
 c0452e8:	f00e f9b6 	bl	c053658 <mbedtls_mpi_write_binary>
    if( ret != 0 )
 c0452ec:	4605      	mov	r5, r0
 c0452ee:	b908      	cbnz	r0, c0452f4 <mbedcrypto__psa_get_key_attributes+0xec>
    attributes->domain_parameters_size = buflen;
 c0452f0:	e9c6 480a 	strd	r4, r8, [r6, #40]	@ 0x28
    mbedtls_mpi_free( &mpi );
 c0452f4:	4638      	mov	r0, r7
 c0452f6:	f00e f804 	bl	c053302 <mbedtls_mpi_free>
    if( ret != 0 )
 c0452fa:	b115      	cbz	r5, c045302 <mbedcrypto__psa_get_key_attributes+0xfa>
        mbedtls_free( buffer );
 c0452fc:	4620      	mov	r0, r4
 c0452fe:	f7f6 f857 	bl	c03b3b0 <mbedtls_free>
    return( mbedtls_to_psa_error( ret ) );
 c045302:	4628      	mov	r0, r5
 c045304:	f7ff fadc 	bl	c0448c0 <mbedtls_to_psa_error>
 c045308:	4604      	mov	r4, r0
                mbedtls_rsa_free( rsa );
 c04530a:	9806      	ldr	r0, [sp, #24]
 c04530c:	f00b f9fc 	bl	c050708 <mbedtls_rsa_free>
                mbedtls_free( rsa );
 c045310:	9806      	ldr	r0, [sp, #24]
 c045312:	f7f6 f84d 	bl	c03b3b0 <mbedtls_free>
    if( status != PSA_SUCCESS )
 c045316:	2c00      	cmp	r4, #0
 c045318:	d0b0      	beq.n	c04527c <mbedcrypto__psa_get_key_attributes+0x74>
        psa_reset_key_attributes( attributes );
 c04531a:	4630      	mov	r0, r6
 c04531c:	f002 f9fb 	bl	c047716 <mbedcrypto__psa_reset_key_attributes>
 c045320:	e7ad      	b.n	c04527e <mbedcrypto__psa_get_key_attributes+0x76>
    uint8_t *buffer = NULL;
 c045322:	4604      	mov	r4, r0
 c045324:	e7e6      	b.n	c0452f4 <mbedcrypto__psa_get_key_attributes+0xec>
        ret = MBEDTLS_ERR_MPI_ALLOC_FAILED;
 c045326:	f06f 050f 	mvn.w	r5, #15
 c04532a:	e7e3      	b.n	c0452f4 <mbedcrypto__psa_get_key_attributes+0xec>

0c04532c <psa_get_key_slot_number>:
    if( attributes->core.flags & MBEDTLS_PSA_KA_FLAG_HAS_SLOT_NUMBER )
 c04532c:	8b83      	ldrh	r3, [r0, #28]
 c04532e:	07db      	lsls	r3, r3, #31
 c045330:	d505      	bpl.n	c04533e <psa_get_key_slot_number+0x12>
        *slot_number = attributes->slot_number;
 c045332:	e9d0 2308 	ldrd	r2, r3, [r0, #32]
        return( PSA_SUCCESS );
 c045336:	2000      	movs	r0, #0
        *slot_number = attributes->slot_number;
 c045338:	e9c1 2300 	strd	r2, r3, [r1]
        return( PSA_SUCCESS );
 c04533c:	4770      	bx	lr
        return( PSA_ERROR_INVALID_ARGUMENT );
 c04533e:	f06f 0086 	mvn.w	r0, #134	@ 0x86
}
 c045342:	4770      	bx	lr

0c045344 <psa_export_key_internal>:
{
 c045344:	b570      	push	{r4, r5, r6, lr}
 c045346:	4614      	mov	r4, r2
    psa_key_type_t type = attributes->core.type;
 c045348:	8802      	ldrh	r2, [r0, #0]
{
 c04534a:	461d      	mov	r5, r3
    if( key_type_is_raw_bytes( type ) ||
 c04534c:	4610      	mov	r0, r2
{
 c04534e:	9e04      	ldr	r6, [sp, #16]
    if( key_type_is_raw_bytes( type ) ||
 c045350:	f7fe fd06 	bl	c043d60 <key_type_is_raw_bytes>
 c045354:	b950      	cbnz	r0, c04536c <psa_export_key_internal+0x28>
 c045356:	f244 0301 	movw	r3, #16385	@ 0x4001
        PSA_KEY_TYPE_IS_RSA( type )   ||
 c04535a:	f422 5040 	bic.w	r0, r2, #12288	@ 0x3000
    if( key_type_is_raw_bytes( type ) ||
 c04535e:	4298      	cmp	r0, r3
 c045360:	d004      	beq.n	c04536c <psa_export_key_internal+0x28>
        PSA_KEY_TYPE_IS_ECC( type )      )
 c045362:	f402 424f 	and.w	r2, r2, #52992	@ 0xcf00
        PSA_KEY_TYPE_IS_RSA( type )   ||
 c045366:	f5b2 4f82 	cmp.w	r2, #16640	@ 0x4100
 c04536a:	d10e      	bne.n	c04538a <psa_export_key_internal+0x46>
    if( key_buffer_size > data_size )
 c04536c:	42b4      	cmp	r4, r6
 c04536e:	d80f      	bhi.n	c045390 <psa_export_key_internal+0x4c>
    memcpy( data, key_buffer, key_buffer_size );
 c045370:	4622      	mov	r2, r4
 c045372:	4628      	mov	r0, r5
 c045374:	f016 f96a 	bl	c05b64c <memcpy>
    memset( data + key_buffer_size, 0,
 c045378:	2100      	movs	r1, #0
 c04537a:	1b32      	subs	r2, r6, r4
 c04537c:	1928      	adds	r0, r5, r4
 c04537e:	f016 f9d6 	bl	c05b72e <memset>
    return( PSA_SUCCESS );
 c045382:	2000      	movs	r0, #0
    *data_length = key_buffer_size;
 c045384:	9b05      	ldr	r3, [sp, #20]
 c045386:	601c      	str	r4, [r3, #0]
}
 c045388:	bd70      	pop	{r4, r5, r6, pc}
        return( PSA_ERROR_NOT_SUPPORTED );
 c04538a:	f06f 0085 	mvn.w	r0, #133	@ 0x85
 c04538e:	e7fb      	b.n	c045388 <psa_export_key_internal+0x44>
        return( PSA_ERROR_BUFFER_TOO_SMALL );
 c045390:	f06f 0089 	mvn.w	r0, #137	@ 0x89
 c045394:	e7f8      	b.n	c045388 <psa_export_key_internal+0x44>

0c045396 <mbedcrypto__psa_export_key>:
{
 c045396:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 c04539a:	b092      	sub	sp, #72	@ 0x48
 c04539c:	ac02      	add	r4, sp, #8
 c04539e:	4617      	mov	r7, r2
    if( data_size == 0 )
 c0453a0:	461e      	mov	r6, r3
{
 c0453a2:	e884 0003 	stmia.w	r4, {r0, r1}
 c0453a6:	f8dd 8060 	ldr.w	r8, [sp, #96]	@ 0x60
    if( data_size == 0 )
 c0453aa:	b35b      	cbz	r3, c045404 <mbedcrypto__psa_export_key+0x6e>
    *data_length = 0;
 c0453ac:	2300      	movs	r3, #0
 c0453ae:	f8c8 3000 	str.w	r3, [r8]
    status = psa_get_and_lock_key_slot_with_policy( key, &slot,
 c0453b2:	9300      	str	r3, [sp, #0]
 c0453b4:	aa05      	add	r2, sp, #20
 c0453b6:	2301      	movs	r3, #1
 c0453b8:	e894 0003 	ldmia.w	r4, {r0, r1}
 c0453bc:	f7ff f8e4 	bl	c044588 <psa_get_and_lock_key_slot_with_policy>
    if( status != PSA_SUCCESS )
 c0453c0:	b9e8      	cbnz	r0, c0453fe <mbedcrypto__psa_export_key+0x68>
    psa_key_attributes_t attributes = {
 c0453c2:	4601      	mov	r1, r0
 c0453c4:	2210      	movs	r2, #16
 c0453c6:	a80e      	add	r0, sp, #56	@ 0x38
 c0453c8:	f016 f9b1 	bl	c05b72e <memset>
        .core = slot->attr
 c0453cc:	f8dd c014 	ldr.w	ip, [sp, #20]
    psa_key_attributes_t attributes = {
 c0453d0:	ac06      	add	r4, sp, #24
 c0453d2:	4665      	mov	r5, ip
 c0453d4:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 c0453d6:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 c0453d8:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
 c0453dc:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
    status = psa_driver_wrapper_export_key( &attributes,
 c0453e0:	e9cd 6800 	strd	r6, r8, [sp]
 c0453e4:	463b      	mov	r3, r7
 c0453e6:	e9dc 1209 	ldrd	r1, r2, [ip, #36]	@ 0x24
 c0453ea:	a806      	add	r0, sp, #24
 c0453ec:	f002 fab5 	bl	c04795a <psa_driver_wrapper_export_key>
 c0453f0:	4604      	mov	r4, r0
    unlock_status = psa_unlock_key_slot( slot );
 c0453f2:	9805      	ldr	r0, [sp, #20]
 c0453f4:	f003 fe5e 	bl	c0490b4 <psa_unlock_key_slot>
    return( ( status == PSA_SUCCESS ) ? unlock_status : status );
 c0453f8:	2c00      	cmp	r4, #0
 c0453fa:	bf18      	it	ne
 c0453fc:	4620      	movne	r0, r4
}
 c0453fe:	b012      	add	sp, #72	@ 0x48
 c045400:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        return( PSA_ERROR_BUFFER_TOO_SMALL );
 c045404:	f06f 0089 	mvn.w	r0, #137	@ 0x89
 c045408:	e7f9      	b.n	c0453fe <mbedcrypto__psa_export_key+0x68>

0c04540a <psa_export_public_key_internal>:
    if( PSA_KEY_TYPE_IS_RSA( type ) || PSA_KEY_TYPE_IS_ECC( type ) )
 c04540a:	f244 0c01 	movw	ip, #16385	@ 0x4001
{
 c04540e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 c045412:	4614      	mov	r4, r2
 c045414:	e9dd 5606 	ldrd	r5, r6, [sp, #24]
    psa_key_type_t type = attributes->core.type;
 c045418:	8802      	ldrh	r2, [r0, #0]
    if( PSA_KEY_TYPE_IS_RSA( type ) || PSA_KEY_TYPE_IS_ECC( type ) )
 c04541a:	f422 5740 	bic.w	r7, r2, #12288	@ 0x3000
 c04541e:	4567      	cmp	r7, ip
 c045420:	d004      	beq.n	c04542c <psa_export_public_key_internal+0x22>
 c045422:	f402 4c4f 	and.w	ip, r2, #52992	@ 0xcf00
 c045426:	f5bc 4f82 	cmp.w	ip, #16640	@ 0x4100
 c04542a:	d122      	bne.n	c045472 <psa_export_public_key_internal+0x68>
        if( PSA_KEY_TYPE_IS_PUBLIC_KEY( type ) )
 c04542c:	f402 42e0 	and.w	r2, r2, #28672	@ 0x7000
 c045430:	f5b2 4f80 	cmp.w	r2, #16384	@ 0x4000
 c045434:	d10e      	bne.n	c045454 <psa_export_public_key_internal+0x4a>
    if( key_buffer_size > data_size )
 c045436:	42ac      	cmp	r4, r5
 c045438:	d81e      	bhi.n	c045478 <psa_export_public_key_internal+0x6e>
    memcpy( data, key_buffer, key_buffer_size );
 c04543a:	4622      	mov	r2, r4
 c04543c:	4618      	mov	r0, r3
 c04543e:	f016 f905 	bl	c05b64c <memcpy>
    memset( data + key_buffer_size, 0,
 c045442:	2100      	movs	r1, #0
 c045444:	1b2a      	subs	r2, r5, r4
 c045446:	4420      	add	r0, r4
 c045448:	f016 f971 	bl	c05b72e <memset>
    return( PSA_SUCCESS );
 c04544c:	2000      	movs	r0, #0
    *data_length = key_buffer_size;
 c04544e:	6034      	str	r4, [r6, #0]
}
 c045450:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        if( PSA_KEY_TYPE_IS_RSA( type ) )
 c045454:	f244 0201 	movw	r2, #16385	@ 0x4001
 c045458:	4297      	cmp	r7, r2
            return( mbedtls_psa_rsa_export_public_key( attributes,
 c04545a:	e9cd 5606 	strd	r5, r6, [sp, #24]
 c04545e:	4622      	mov	r2, r4
        if( PSA_KEY_TYPE_IS_RSA( type ) )
 c045460:	d103      	bne.n	c04546a <psa_export_public_key_internal+0x60>
}
 c045462:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
            return( mbedtls_psa_rsa_export_public_key( attributes,
 c045466:	f003 ba96 	b.w	c048996 <mbedtls_psa_rsa_export_public_key>
}
 c04546a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
            return( mbedtls_psa_ecp_export_public_key( attributes,
 c04546e:	f002 bced 	b.w	c047e4c <mbedtls_psa_ecp_export_public_key>
        return( PSA_ERROR_NOT_SUPPORTED );
 c045472:	f06f 0085 	mvn.w	r0, #133	@ 0x85
 c045476:	e7eb      	b.n	c045450 <psa_export_public_key_internal+0x46>
        return( PSA_ERROR_BUFFER_TOO_SMALL );
 c045478:	f06f 0089 	mvn.w	r0, #137	@ 0x89
 c04547c:	e7e8      	b.n	c045450 <psa_export_public_key_internal+0x46>

0c04547e <mbedcrypto__psa_export_public_key>:
{
 c04547e:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 c045482:	b093      	sub	sp, #76	@ 0x4c
 c045484:	ac02      	add	r4, sp, #8
 c045486:	4690      	mov	r8, r2
    if( data_size == 0 )
 c045488:	461f      	mov	r7, r3
{
 c04548a:	e884 0003 	stmia.w	r4, {r0, r1}
 c04548e:	f8dd 9068 	ldr.w	r9, [sp, #104]	@ 0x68
    if( data_size == 0 )
 c045492:	b353      	cbz	r3, c0454ea <mbedcrypto__psa_export_public_key+0x6c>
    *data_length = 0;
 c045494:	2300      	movs	r3, #0
 c045496:	f8c9 3000 	str.w	r3, [r9]
    status = psa_get_and_lock_key_slot_with_policy( key, &slot, 0, 0 );
 c04549a:	9300      	str	r3, [sp, #0]
 c04549c:	aa05      	add	r2, sp, #20
 c04549e:	e894 0003 	ldmia.w	r4, {r0, r1}
 c0454a2:	f7ff f871 	bl	c044588 <psa_get_and_lock_key_slot_with_policy>
    if( status != PSA_SUCCESS )
 c0454a6:	b9d0      	cbnz	r0, c0454de <mbedcrypto__psa_export_public_key+0x60>
    if( ! PSA_KEY_TYPE_IS_ASYMMETRIC( slot->attr.type ) )
 c0454a8:	9e05      	ldr	r6, [sp, #20]
 c0454aa:	8833      	ldrh	r3, [r6, #0]
 c0454ac:	045b      	lsls	r3, r3, #17
 c0454ae:	d519      	bpl.n	c0454e4 <mbedcrypto__psa_export_public_key+0x66>
    attributes.core = slot->attr;
 c0454b0:	4635      	mov	r5, r6
 c0454b2:	ac06      	add	r4, sp, #24
 c0454b4:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 c0454b6:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 c0454b8:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
 c0454bc:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
    status = psa_driver_wrapper_export_public_key(
 c0454c0:	e9cd 7900 	strd	r7, r9, [sp]
 c0454c4:	4643      	mov	r3, r8
 c0454c6:	e9d6 1209 	ldrd	r1, r2, [r6, #36]	@ 0x24
 c0454ca:	a806      	add	r0, sp, #24
 c0454cc:	f002 fa77 	bl	c0479be <psa_driver_wrapper_export_public_key>
 c0454d0:	4604      	mov	r4, r0
    unlock_status = psa_unlock_key_slot( slot );
 c0454d2:	9805      	ldr	r0, [sp, #20]
 c0454d4:	f003 fdee 	bl	c0490b4 <psa_unlock_key_slot>
    return( ( status == PSA_SUCCESS ) ? unlock_status : status );
 c0454d8:	2c00      	cmp	r4, #0
 c0454da:	bf18      	it	ne
 c0454dc:	4620      	movne	r0, r4
}
 c0454de:	b013      	add	sp, #76	@ 0x4c
 c0454e0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
         status = PSA_ERROR_INVALID_ARGUMENT;
 c0454e4:	f06f 0486 	mvn.w	r4, #134	@ 0x86
 c0454e8:	e7f3      	b.n	c0454d2 <mbedcrypto__psa_export_public_key+0x54>
        return( PSA_ERROR_BUFFER_TOO_SMALL );
 c0454ea:	f06f 0089 	mvn.w	r0, #137	@ 0x89
 c0454ee:	e7f6      	b.n	c0454de <mbedcrypto__psa_export_public_key+0x60>

0c0454f0 <mbedcrypto__psa_import_key>:
{
 c0454f0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 c0454f4:	4606      	mov	r6, r0
    psa_key_slot_t *slot = NULL;
 c0454f6:	2000      	movs	r0, #0
{
 c0454f8:	b088      	sub	sp, #32
    *key = MBEDTLS_SVC_KEY_ID_INIT;
 c0454fa:	e9c3 0000 	strd	r0, r0, [r3]
{
 c0454fe:	4688      	mov	r8, r1
 c045500:	4617      	mov	r7, r2
 c045502:	461d      	mov	r5, r3
    status = psa_start_key_creation( PSA_KEY_CREATION_IMPORT, attributes,
 c045504:	4631      	mov	r1, r6
 c045506:	ab06      	add	r3, sp, #24
 c045508:	aa05      	add	r2, sp, #20
    psa_se_drv_table_entry_t *driver = NULL;
 c04550a:	e9cd 0005 	strd	r0, r0, [sp, #20]
    status = psa_start_key_creation( PSA_KEY_CREATION_IMPORT, attributes,
 c04550e:	f7ff fd09 	bl	c044f24 <psa_start_key_creation>
    if( status != PSA_SUCCESS )
 c045512:	4604      	mov	r4, r0
 c045514:	b9a0      	cbnz	r0, c045540 <mbedcrypto__psa_import_key+0x50>
    if( slot->key.data == NULL )
 c045516:	9805      	ldr	r0, [sp, #20]
 c045518:	6a43      	ldr	r3, [r0, #36]	@ 0x24
 c04551a:	b1ab      	cbz	r3, c045548 <mbedcrypto__psa_import_key+0x58>
    bits = slot->attr.bits;
 c04551c:	9b05      	ldr	r3, [sp, #20]
    status = psa_driver_wrapper_import_key( attributes,
 c04551e:	4641      	mov	r1, r8
    bits = slot->attr.bits;
 c045520:	885a      	ldrh	r2, [r3, #2]
    status = psa_driver_wrapper_import_key( attributes,
 c045522:	4630      	mov	r0, r6
    bits = slot->attr.bits;
 c045524:	9207      	str	r2, [sp, #28]
    status = psa_driver_wrapper_import_key( attributes,
 c045526:	aa07      	add	r2, sp, #28
 c045528:	9202      	str	r2, [sp, #8]
 c04552a:	f103 0228 	add.w	r2, r3, #40	@ 0x28
 c04552e:	9201      	str	r2, [sp, #4]
 c045530:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
 c045532:	9200      	str	r2, [sp, #0]
 c045534:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 c045536:	463a      	mov	r2, r7
 c045538:	f002 f9cc 	bl	c0478d4 <psa_driver_wrapper_import_key>
    if( status != PSA_SUCCESS )
 c04553c:	4604      	mov	r4, r0
 c04553e:	b150      	cbz	r0, c045556 <mbedcrypto__psa_import_key+0x66>
        psa_fail_key_creation( slot, driver );
 c045540:	9805      	ldr	r0, [sp, #20]
 c045542:	f7ff fdf0 	bl	c045126 <psa_fail_key_creation.constprop.0>
    return( status );
 c045546:	e019      	b.n	c04557c <mbedcrypto__psa_import_key+0x8c>
        status = psa_allocate_buffer_to_slot( slot, data_length );
 c045548:	4639      	mov	r1, r7
 c04554a:	f7ff fcc4 	bl	c044ed6 <psa_allocate_buffer_to_slot>
        if( status != PSA_SUCCESS )
 c04554e:	4604      	mov	r4, r0
 c045550:	2800      	cmp	r0, #0
 c045552:	d0e3      	beq.n	c04551c <mbedcrypto__psa_import_key+0x2c>
 c045554:	e7f4      	b.n	c045540 <mbedcrypto__psa_import_key+0x50>
    if( slot->attr.bits == 0 )
 c045556:	9805      	ldr	r0, [sp, #20]
        slot->attr.bits = (psa_key_bits_t) bits;
 c045558:	9b07      	ldr	r3, [sp, #28]
    if( slot->attr.bits == 0 )
 c04555a:	8842      	ldrh	r2, [r0, #2]
 c04555c:	b992      	cbnz	r2, c045584 <mbedcrypto__psa_import_key+0x94>
        slot->attr.bits = (psa_key_bits_t) bits;
 c04555e:	8043      	strh	r3, [r0, #2]
    status = psa_validate_optional_attributes( slot, attributes );
 c045560:	4631      	mov	r1, r6
 c045562:	f7ff fb45 	bl	c044bf0 <psa_validate_optional_attributes>
    if( status != PSA_SUCCESS )
 c045566:	4604      	mov	r4, r0
 c045568:	2800      	cmp	r0, #0
 c04556a:	d1e9      	bne.n	c045540 <mbedcrypto__psa_import_key+0x50>
    status = psa_finish_key_creation( slot, driver, key );
 c04556c:	e9dd 0105 	ldrd	r0, r1, [sp, #20]
 c045570:	462a      	mov	r2, r5
 c045572:	f7fe ff43 	bl	c0443fc <psa_finish_key_creation>
    if( status != PSA_SUCCESS )
 c045576:	4604      	mov	r4, r0
 c045578:	2800      	cmp	r0, #0
 c04557a:	d1e1      	bne.n	c045540 <mbedcrypto__psa_import_key+0x50>
}
 c04557c:	4620      	mov	r0, r4
 c04557e:	b008      	add	sp, #32
 c045580:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    else if( bits != slot->attr.bits )
 c045584:	429a      	cmp	r2, r3
 c045586:	d0eb      	beq.n	c045560 <mbedcrypto__psa_import_key+0x70>
        status = PSA_ERROR_INVALID_ARGUMENT;
 c045588:	f06f 0486 	mvn.w	r4, #134	@ 0x86
 c04558c:	e7d8      	b.n	c045540 <mbedcrypto__psa_import_key+0x50>

0c04558e <mbedtls_psa_register_se_key>:
    psa_key_slot_t *slot = NULL;
 c04558e:	2300      	movs	r3, #0
{
 c045590:	b530      	push	{r4, r5, lr}
 c045592:	b085      	sub	sp, #20
    psa_se_drv_table_entry_t *driver = NULL;
 c045594:	e9cd 3300 	strd	r3, r3, [sp]
    mbedtls_svc_key_id_t key = MBEDTLS_SVC_KEY_ID_INIT;
 c045598:	e9cd 3302 	strd	r3, r3, [sp, #8]
    if( psa_get_key_type( attributes ) == PSA_KEY_TYPE_NONE )
 c04559c:	8803      	ldrh	r3, [r0, #0]
{
 c04559e:	4601      	mov	r1, r0
    if( psa_get_key_type( attributes ) == PSA_KEY_TYPE_NONE )
 c0455a0:	b1d3      	cbz	r3, c0455d8 <mbedtls_psa_register_se_key+0x4a>
    if( psa_get_key_bits( attributes ) == 0 )
 c0455a2:	8843      	ldrh	r3, [r0, #2]
 c0455a4:	b1c3      	cbz	r3, c0455d8 <mbedtls_psa_register_se_key+0x4a>
    status = psa_start_key_creation( PSA_KEY_CREATION_REGISTER, attributes,
 c0455a6:	466a      	mov	r2, sp
 c0455a8:	2004      	movs	r0, #4
 c0455aa:	ab01      	add	r3, sp, #4
 c0455ac:	f7ff fcba 	bl	c044f24 <psa_start_key_creation>
    if( status != PSA_SUCCESS )
 c0455b0:	ad02      	add	r5, sp, #8
 c0455b2:	4604      	mov	r4, r0
 c0455b4:	b930      	cbnz	r0, c0455c4 <mbedtls_psa_register_se_key+0x36>
    status = psa_finish_key_creation( slot, driver, &key );
 c0455b6:	e9dd 0100 	ldrd	r0, r1, [sp]
 c0455ba:	462a      	mov	r2, r5
 c0455bc:	f7fe ff1e 	bl	c0443fc <psa_finish_key_creation>
    if( status != PSA_SUCCESS )
 c0455c0:	4604      	mov	r4, r0
 c0455c2:	b110      	cbz	r0, c0455ca <mbedtls_psa_register_se_key+0x3c>
        psa_fail_key_creation( slot, driver );
 c0455c4:	9800      	ldr	r0, [sp, #0]
 c0455c6:	f7ff fdae 	bl	c045126 <psa_fail_key_creation.constprop.0>
    psa_close_key( key );
 c0455ca:	e895 0003 	ldmia.w	r5, {r0, r1}
 c0455ce:	f003 fdae 	bl	c04912e <mbedcrypto__psa_close_key>
}
 c0455d2:	4620      	mov	r0, r4
 c0455d4:	b005      	add	sp, #20
 c0455d6:	bd30      	pop	{r4, r5, pc}
        return( PSA_ERROR_NOT_SUPPORTED );
 c0455d8:	f06f 0485 	mvn.w	r4, #133	@ 0x85
 c0455dc:	e7f9      	b.n	c0455d2 <mbedtls_psa_register_se_key+0x44>

0c0455de <mbedcrypto__psa_copy_key>:
{
 c0455de:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    psa_key_attributes_t actual_attributes = *specified_attributes;
 c0455e2:	4615      	mov	r5, r2
    psa_key_slot_t *source_slot = NULL;
 c0455e4:	2700      	movs	r7, #0
{
 c0455e6:	461e      	mov	r6, r3
 c0455e8:	b095      	sub	sp, #84	@ 0x54
 c0455ea:	f10d 0c08 	add.w	ip, sp, #8
    psa_key_attributes_t actual_attributes = *specified_attributes;
 c0455ee:	ac08      	add	r4, sp, #32
{
 c0455f0:	e88c 0003 	stmia.w	ip, {r0, r1}
 c0455f4:	4690      	mov	r8, r2
    psa_key_attributes_t actual_attributes = *specified_attributes;
 c0455f6:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 c0455f8:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 c0455fa:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 c0455fc:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 c0455fe:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
    psa_key_slot_t *target_slot = NULL;
 c045602:	e9cd 7705 	strd	r7, r7, [sp, #20]
    psa_key_attributes_t actual_attributes = *specified_attributes;
 c045606:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
    *target_key = MBEDTLS_SVC_KEY_ID_INIT;
 c04560a:	e9c6 7700 	strd	r7, r7, [r6]
    status = psa_get_and_lock_transparent_key_slot_with_policy(
 c04560e:	2302      	movs	r3, #2
    psa_se_drv_table_entry_t *driver = NULL;
 c045610:	9707      	str	r7, [sp, #28]
    status = psa_get_and_lock_transparent_key_slot_with_policy(
 c045612:	aa05      	add	r2, sp, #20
 c045614:	9700      	str	r7, [sp, #0]
 c045616:	e89c 0003 	ldmia.w	ip, {r0, r1}
 c04561a:	f7ff f8ef 	bl	c0447fc <psa_get_and_lock_transparent_key_slot_with_policy>
    if( status != PSA_SUCCESS )
 c04561e:	4604      	mov	r4, r0
 c045620:	bb18      	cbnz	r0, c04566a <mbedcrypto__psa_copy_key+0x8c>
    status = psa_validate_optional_attributes( source_slot,
 c045622:	4641      	mov	r1, r8
 c045624:	9805      	ldr	r0, [sp, #20]
 c045626:	f7ff fae3 	bl	c044bf0 <psa_validate_optional_attributes>
    if( status != PSA_SUCCESS )
 c04562a:	4604      	mov	r4, r0
 c04562c:	b9e8      	cbnz	r0, c04566a <mbedcrypto__psa_copy_key+0x8c>
    status = psa_restrict_key_policy( source_slot->attr.type,
 c04562e:	9d05      	ldr	r5, [sp, #20]
        psa_key_policy_algorithm_intersection( key_type, policy->alg,
 c045630:	f8dd a034 	ldr.w	sl, [sp, #52]	@ 0x34
    status = psa_restrict_key_policy( source_slot->attr.type,
 c045634:	f8b5 b000 	ldrh.w	fp, [r5]
                                               constraint->alg );
 c045638:	f8d5 9014 	ldr.w	r9, [r5, #20]
        psa_key_policy_algorithm_intersection( key_type, policy->alg,
 c04563c:	4651      	mov	r1, sl
 c04563e:	464a      	mov	r2, r9
 c045640:	4658      	mov	r0, fp
 c045642:	f7fe fbb9 	bl	c043db8 <psa_key_policy_algorithm_intersection>
 c045646:	4604      	mov	r4, r0
        psa_key_policy_algorithm_intersection( key_type, policy->alg2,
 c045648:	f8dd 8038 	ldr.w	r8, [sp, #56]	@ 0x38
                                               constraint->alg2 );
 c04564c:	69af      	ldr	r7, [r5, #24]
        psa_key_policy_algorithm_intersection( key_type, policy->alg2,
 c04564e:	4641      	mov	r1, r8
 c045650:	463a      	mov	r2, r7
 c045652:	4658      	mov	r0, fp
 c045654:	f7fe fbb0 	bl	c043db8 <psa_key_policy_algorithm_intersection>
    if( intersection_alg == 0 && policy->alg != 0 && constraint->alg != 0 )
 c045658:	b95c      	cbnz	r4, c045672 <mbedcrypto__psa_copy_key+0x94>
 c04565a:	f1ba 0f00 	cmp.w	sl, #0
 c04565e:	d008      	beq.n	c045672 <mbedcrypto__psa_copy_key+0x94>
 c045660:	f1b9 0f00 	cmp.w	r9, #0
 c045664:	d005      	beq.n	c045672 <mbedcrypto__psa_copy_key+0x94>
        return( PSA_ERROR_INVALID_ARGUMENT );
 c045666:	f06f 0486 	mvn.w	r4, #134	@ 0x86
        psa_fail_key_creation( target_slot, driver );
 c04566a:	9806      	ldr	r0, [sp, #24]
 c04566c:	f7ff fd5b 	bl	c045126 <psa_fail_key_creation.constprop.0>
 c045670:	e02f      	b.n	c0456d2 <mbedcrypto__psa_copy_key+0xf4>
    if( intersection_alg2 == 0 && policy->alg2 != 0 && constraint->alg2 != 0 )
 c045672:	b920      	cbnz	r0, c04567e <mbedcrypto__psa_copy_key+0xa0>
 c045674:	f1b8 0f00 	cmp.w	r8, #0
 c045678:	d001      	beq.n	c04567e <mbedcrypto__psa_copy_key+0xa0>
 c04567a:	2f00      	cmp	r7, #0
 c04567c:	d1f3      	bne.n	c045666 <mbedcrypto__psa_copy_key+0x88>
    policy->usage &= constraint->usage;
 c04567e:	692a      	ldr	r2, [r5, #16]
 c045680:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
    policy->alg2 = intersection_alg2;
 c045682:	900e      	str	r0, [sp, #56]	@ 0x38
    policy->usage &= constraint->usage;
 c045684:	4013      	ands	r3, r2
    policy->alg = intersection_alg;
 c045686:	e9cd 340c 	strd	r3, r4, [sp, #48]	@ 0x30
    status = psa_start_key_creation( PSA_KEY_CREATION_COPY, &actual_attributes,
 c04568a:	2003      	movs	r0, #3
 c04568c:	ab07      	add	r3, sp, #28
 c04568e:	aa06      	add	r2, sp, #24
 c045690:	a908      	add	r1, sp, #32
 c045692:	f7ff fc47 	bl	c044f24 <psa_start_key_creation>
    if( status != PSA_SUCCESS )
 c045696:	4604      	mov	r4, r0
 c045698:	2800      	cmp	r0, #0
 c04569a:	d1e6      	bne.n	c04566a <mbedcrypto__psa_copy_key+0x8c>
    if( driver != NULL )
 c04569c:	e9dd 7306 	ldrd	r7, r3, [sp, #24]
 c0456a0:	bb03      	cbnz	r3, c0456e4 <mbedcrypto__psa_copy_key+0x106>
    if( psa_key_lifetime_is_external( actual_attributes.core.lifetime ) )
 c0456a2:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 c0456a4:	0a1b      	lsrs	r3, r3, #8
 c0456a6:	d1de      	bne.n	c045666 <mbedcrypto__psa_copy_key+0x88>
    status = psa_copy_key_material( source_slot, target_slot );
 c0456a8:	9d05      	ldr	r5, [sp, #20]
    psa_status_t status = psa_copy_key_material_into_slot( target,
 c0456aa:	4638      	mov	r0, r7
 c0456ac:	e9d5 1209 	ldrd	r1, r2, [r5, #36]	@ 0x24
 c0456b0:	f7ff fc27 	bl	c044f02 <psa_copy_key_material_into_slot>
    if( status != PSA_SUCCESS )
 c0456b4:	4604      	mov	r4, r0
 c0456b6:	2800      	cmp	r0, #0
 c0456b8:	d1d7      	bne.n	c04566a <mbedcrypto__psa_copy_key+0x8c>
    status = psa_finish_key_creation( target_slot, driver, target_key );
 c0456ba:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
    target->attr.type = source->attr.type;
 c0456be:	882b      	ldrh	r3, [r5, #0]
    status = psa_finish_key_creation( target_slot, driver, target_key );
 c0456c0:	4632      	mov	r2, r6
    target->attr.type = source->attr.type;
 c0456c2:	803b      	strh	r3, [r7, #0]
    target->attr.bits = source->attr.bits;
 c0456c4:	886b      	ldrh	r3, [r5, #2]
 c0456c6:	807b      	strh	r3, [r7, #2]
    status = psa_finish_key_creation( target_slot, driver, target_key );
 c0456c8:	f7fe fe98 	bl	c0443fc <psa_finish_key_creation>
    if( status != PSA_SUCCESS )
 c0456cc:	4604      	mov	r4, r0
 c0456ce:	2800      	cmp	r0, #0
 c0456d0:	d1cb      	bne.n	c04566a <mbedcrypto__psa_copy_key+0x8c>
    unlock_status = psa_unlock_key_slot( source_slot );
 c0456d2:	9805      	ldr	r0, [sp, #20]
 c0456d4:	f003 fcee 	bl	c0490b4 <psa_unlock_key_slot>
}
 c0456d8:	2c00      	cmp	r4, #0
 c0456da:	bf18      	it	ne
 c0456dc:	4620      	movne	r0, r4
 c0456de:	b015      	add	sp, #84	@ 0x54
 c0456e0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        status = PSA_ERROR_NOT_SUPPORTED;
 c0456e4:	f06f 0485 	mvn.w	r4, #133	@ 0x85
 c0456e8:	e7bf      	b.n	c04566a <mbedcrypto__psa_copy_key+0x8c>

0c0456ea <mbedcrypto__psa_hash_abort>:
    if( operation->id == 0 )
 c0456ea:	6803      	ldr	r3, [r0, #0]
{
 c0456ec:	b510      	push	{r4, lr}
 c0456ee:	4604      	mov	r4, r0
    if( operation->id == 0 )
 c0456f0:	b123      	cbz	r3, c0456fc <mbedcrypto__psa_hash_abort+0x12>
    psa_status_t status = psa_driver_wrapper_hash_abort( operation );
 c0456f2:	f002 fa15 	bl	c047b20 <psa_driver_wrapper_hash_abort>
    operation->id = 0;
 c0456f6:	2300      	movs	r3, #0
 c0456f8:	6023      	str	r3, [r4, #0]
}
 c0456fa:	bd10      	pop	{r4, pc}
        return( PSA_SUCCESS );
 c0456fc:	4618      	mov	r0, r3
 c0456fe:	e7fc      	b.n	c0456fa <mbedcrypto__psa_hash_abort+0x10>

0c045700 <mbedcrypto__psa_hash_setup>:
{
 c045700:	b538      	push	{r3, r4, r5, lr}
 c045702:	460c      	mov	r4, r1
    if( operation->id != 0 )
 c045704:	6801      	ldr	r1, [r0, #0]
{
 c045706:	4605      	mov	r5, r0
    if( operation->id != 0 )
 c045708:	b9a1      	cbnz	r1, c045734 <mbedcrypto__psa_hash_setup+0x34>
    if( !PSA_ALG_IS_HASH( alg ) )
 c04570a:	f004 43fe 	and.w	r3, r4, #2130706432	@ 0x7f000000
 c04570e:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
 c045712:	d112      	bne.n	c04573a <mbedcrypto__psa_hash_setup+0x3a>
    memset( &operation->ctx, 0, sizeof( operation->ctx ) );
 c045714:	f44f 72c0 	mov.w	r2, #384	@ 0x180
 c045718:	3008      	adds	r0, #8
 c04571a:	f016 f808 	bl	c05b72e <memset>
    status = psa_driver_wrapper_hash_setup( operation, alg );
 c04571e:	4621      	mov	r1, r4
 c045720:	4628      	mov	r0, r5
 c045722:	f002 f9d4 	bl	c047ace <psa_driver_wrapper_hash_setup>
    if( status != PSA_SUCCESS )
 c045726:	4604      	mov	r4, r0
 c045728:	b110      	cbz	r0, c045730 <mbedcrypto__psa_hash_setup+0x30>
        psa_hash_abort( operation );
 c04572a:	4628      	mov	r0, r5
 c04572c:	f7ff ffdd 	bl	c0456ea <mbedcrypto__psa_hash_abort>
}
 c045730:	4620      	mov	r0, r4
 c045732:	bd38      	pop	{r3, r4, r5, pc}
        status = PSA_ERROR_BAD_STATE;
 c045734:	f06f 0488 	mvn.w	r4, #136	@ 0x88
 c045738:	e7f7      	b.n	c04572a <mbedcrypto__psa_hash_setup+0x2a>
        status = PSA_ERROR_INVALID_ARGUMENT;
 c04573a:	f06f 0486 	mvn.w	r4, #134	@ 0x86
 c04573e:	e7f4      	b.n	c04572a <mbedcrypto__psa_hash_setup+0x2a>

0c045740 <mbedcrypto__psa_hash_update>:
{
 c045740:	b538      	push	{r3, r4, r5, lr}
    if( operation->id == 0 )
 c045742:	6804      	ldr	r4, [r0, #0]
{
 c045744:	4605      	mov	r5, r0
    if( operation->id == 0 )
 c045746:	b164      	cbz	r4, c045762 <mbedcrypto__psa_hash_update+0x22>
    if( input_length == 0 )
 c045748:	b912      	cbnz	r2, c045750 <mbedcrypto__psa_hash_update+0x10>
        return( PSA_SUCCESS );
 c04574a:	2400      	movs	r4, #0
}
 c04574c:	4620      	mov	r0, r4
 c04574e:	bd38      	pop	{r3, r4, r5, pc}
    status = psa_driver_wrapper_hash_update( operation, input, input_length );
 c045750:	f002 f9d1 	bl	c047af6 <psa_driver_wrapper_hash_update>
    if( status != PSA_SUCCESS )
 c045754:	4604      	mov	r4, r0
 c045756:	2800      	cmp	r0, #0
 c045758:	d0f7      	beq.n	c04574a <mbedcrypto__psa_hash_update+0xa>
        psa_hash_abort( operation );
 c04575a:	4628      	mov	r0, r5
 c04575c:	f7ff ffc5 	bl	c0456ea <mbedcrypto__psa_hash_abort>
 c045760:	e7f4      	b.n	c04574c <mbedcrypto__psa_hash_update+0xc>
        status = PSA_ERROR_BAD_STATE;
 c045762:	f06f 0488 	mvn.w	r4, #136	@ 0x88
 c045766:	e7f8      	b.n	c04575a <mbedcrypto__psa_hash_update+0x1a>

0c045768 <mbedcrypto__psa_hash_finish>:
{
 c045768:	b570      	push	{r4, r5, r6, lr}
    *hash_length = 0;
 c04576a:	2600      	movs	r6, #0
 c04576c:	601e      	str	r6, [r3, #0]
    if( operation->id == 0 )
 c04576e:	6804      	ldr	r4, [r0, #0]
{
 c045770:	4605      	mov	r5, r0
    if( operation->id == 0 )
 c045772:	b13c      	cbz	r4, c045784 <mbedcrypto__psa_hash_finish+0x1c>
    psa_status_t status = psa_driver_wrapper_hash_finish(
 c045774:	f002 f9c8 	bl	c047b08 <psa_driver_wrapper_hash_finish>
 c045778:	4604      	mov	r4, r0
    psa_hash_abort( operation );
 c04577a:	4628      	mov	r0, r5
 c04577c:	f7ff ffb5 	bl	c0456ea <mbedcrypto__psa_hash_abort>
}
 c045780:	4620      	mov	r0, r4
 c045782:	bd70      	pop	{r4, r5, r6, pc}
        return( PSA_ERROR_BAD_STATE );
 c045784:	f06f 0488 	mvn.w	r4, #136	@ 0x88
 c045788:	e7fa      	b.n	c045780 <mbedcrypto__psa_hash_finish+0x18>

0c04578a <mbedcrypto__psa_hash_verify>:
{
 c04578a:	b5f0      	push	{r4, r5, r6, r7, lr}
 c04578c:	b093      	sub	sp, #76	@ 0x4c
 c04578e:	460d      	mov	r5, r1
 c045790:	4617      	mov	r7, r2
    psa_status_t status = psa_hash_finish(
 c045792:	ab01      	add	r3, sp, #4
 c045794:	2240      	movs	r2, #64	@ 0x40
 c045796:	a902      	add	r1, sp, #8
{
 c045798:	4606      	mov	r6, r0
    psa_status_t status = psa_hash_finish(
 c04579a:	f7ff ffe5 	bl	c045768 <mbedcrypto__psa_hash_finish>
    if( status != PSA_SUCCESS )
 c04579e:	4604      	mov	r4, r0
 c0457a0:	b960      	cbnz	r0, c0457bc <mbedcrypto__psa_hash_verify+0x32>
    if( actual_hash_length != hash_length )
 c0457a2:	9b01      	ldr	r3, [sp, #4]
 c0457a4:	42bb      	cmp	r3, r7
 c0457a6:	d11b      	bne.n	c0457e0 <mbedcrypto__psa_hash_verify+0x56>
 c0457a8:	4629      	mov	r1, r5
    unsigned char diff = 0;
 c0457aa:	4602      	mov	r2, r0
 c0457ac:	ad02      	add	r5, sp, #8
 c0457ae:	440b      	add	r3, r1
    for( i = 0; i < n; i++ )
 c0457b0:	4299      	cmp	r1, r3
 c0457b2:	d10e      	bne.n	c0457d2 <mbedcrypto__psa_hash_verify+0x48>
        status = PSA_ERROR_INVALID_SIGNATURE;
 c0457b4:	2a00      	cmp	r2, #0
 c0457b6:	bf18      	it	ne
 c0457b8:	f06f 0494 	mvnne.w	r4, #148	@ 0x94
    mbedtls_platform_zeroize( actual_hash, sizeof( actual_hash ) );
 c0457bc:	2140      	movs	r1, #64	@ 0x40
 c0457be:	a802      	add	r0, sp, #8
 c0457c0:	f7f5 fe06 	bl	c03b3d0 <mbedtls_platform_zeroize>
    if( status != PSA_SUCCESS )
 c0457c4:	b114      	cbz	r4, c0457cc <mbedcrypto__psa_hash_verify+0x42>
        psa_hash_abort(operation);
 c0457c6:	4630      	mov	r0, r6
 c0457c8:	f7ff ff8f 	bl	c0456ea <mbedcrypto__psa_hash_abort>
}
 c0457cc:	4620      	mov	r0, r4
 c0457ce:	b013      	add	sp, #76	@ 0x4c
 c0457d0:	bdf0      	pop	{r4, r5, r6, r7, pc}
        diff |= a[i] ^ b[i];
 c0457d2:	f811 0b01 	ldrb.w	r0, [r1], #1
 c0457d6:	f815 7b01 	ldrb.w	r7, [r5], #1
 c0457da:	4078      	eors	r0, r7
 c0457dc:	4302      	orrs	r2, r0
    for( i = 0; i < n; i++ )
 c0457de:	e7e7      	b.n	c0457b0 <mbedcrypto__psa_hash_verify+0x26>
        status = PSA_ERROR_INVALID_SIGNATURE;
 c0457e0:	f06f 0494 	mvn.w	r4, #148	@ 0x94
 c0457e4:	e7ea      	b.n	c0457bc <mbedcrypto__psa_hash_verify+0x32>

0c0457e6 <mbedcrypto__psa_hash_compute>:
{
 c0457e6:	b470      	push	{r4, r5, r6}
    *hash_length = 0;
 c0457e8:	2400      	movs	r4, #0
{
 c0457ea:	e9dd 6503 	ldrd	r6, r5, [sp, #12]
    *hash_length = 0;
 c0457ee:	602c      	str	r4, [r5, #0]
    if( !PSA_ALG_IS_HASH( alg ) )
 c0457f0:	f000 44fe 	and.w	r4, r0, #2130706432	@ 0x7f000000
 c0457f4:	f1b4 7f00 	cmp.w	r4, #33554432	@ 0x2000000
 c0457f8:	d104      	bne.n	c045804 <mbedcrypto__psa_hash_compute+0x1e>
    return( psa_driver_wrapper_hash_compute( alg, input, input_length,
 c0457fa:	e9cd 6503 	strd	r6, r5, [sp, #12]
}
 c0457fe:	bc70      	pop	{r4, r5, r6}
    return( psa_driver_wrapper_hash_compute( alg, input, input_length,
 c045800:	f002 b963 	b.w	c047aca <psa_driver_wrapper_hash_compute>
}
 c045804:	f06f 0086 	mvn.w	r0, #134	@ 0x86
 c045808:	bc70      	pop	{r4, r5, r6}
 c04580a:	4770      	bx	lr

0c04580c <mbedcrypto__psa_hash_compare>:
{
 c04580c:	b570      	push	{r4, r5, r6, lr}
 c04580e:	461d      	mov	r5, r3
    if( !PSA_ALG_IS_HASH( alg ) )
 c045810:	f000 43fe 	and.w	r3, r0, #2130706432	@ 0x7f000000
 c045814:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
{
 c045818:	b094      	sub	sp, #80	@ 0x50
    if( !PSA_ALG_IS_HASH( alg ) )
 c04581a:	d127      	bne.n	c04586c <mbedcrypto__psa_hash_compare+0x60>
    psa_status_t status = psa_driver_wrapper_hash_compute(
 c04581c:	ab03      	add	r3, sp, #12
 c04581e:	9301      	str	r3, [sp, #4]
 c045820:	2340      	movs	r3, #64	@ 0x40
 c045822:	9300      	str	r3, [sp, #0]
 c045824:	ab04      	add	r3, sp, #16
 c045826:	f002 f950 	bl	c047aca <psa_driver_wrapper_hash_compute>
    if( status != PSA_SUCCESS )
 c04582a:	4604      	mov	r4, r0
 c04582c:	b968      	cbnz	r0, c04584a <mbedcrypto__psa_hash_compare+0x3e>
    if( actual_hash_length != hash_length )
 c04582e:	9a03      	ldr	r2, [sp, #12]
 c045830:	9b18      	ldr	r3, [sp, #96]	@ 0x60
 c045832:	429a      	cmp	r2, r3
 c045834:	d117      	bne.n	c045866 <mbedcrypto__psa_hash_compare+0x5a>
 c045836:	462b      	mov	r3, r5
    unsigned char diff = 0;
 c045838:	4601      	mov	r1, r0
 c04583a:	ad04      	add	r5, sp, #16
 c04583c:	441a      	add	r2, r3
    for( i = 0; i < n; i++ )
 c04583e:	4293      	cmp	r3, r2
 c045840:	d10a      	bne.n	c045858 <mbedcrypto__psa_hash_compare+0x4c>
        status = PSA_ERROR_INVALID_SIGNATURE;
 c045842:	2900      	cmp	r1, #0
 c045844:	bf18      	it	ne
 c045846:	f06f 0494 	mvnne.w	r4, #148	@ 0x94
    mbedtls_platform_zeroize( actual_hash, sizeof( actual_hash ) );
 c04584a:	2140      	movs	r1, #64	@ 0x40
 c04584c:	a804      	add	r0, sp, #16
 c04584e:	f7f5 fdbf 	bl	c03b3d0 <mbedtls_platform_zeroize>
}
 c045852:	4620      	mov	r0, r4
 c045854:	b014      	add	sp, #80	@ 0x50
 c045856:	bd70      	pop	{r4, r5, r6, pc}
        diff |= a[i] ^ b[i];
 c045858:	f813 0b01 	ldrb.w	r0, [r3], #1
 c04585c:	f815 6b01 	ldrb.w	r6, [r5], #1
 c045860:	4070      	eors	r0, r6
 c045862:	4301      	orrs	r1, r0
    for( i = 0; i < n; i++ )
 c045864:	e7eb      	b.n	c04583e <mbedcrypto__psa_hash_compare+0x32>
        status = PSA_ERROR_INVALID_SIGNATURE;
 c045866:	f06f 0494 	mvn.w	r4, #148	@ 0x94
 c04586a:	e7ee      	b.n	c04584a <mbedcrypto__psa_hash_compare+0x3e>
        return( PSA_ERROR_INVALID_ARGUMENT );
 c04586c:	f06f 0486 	mvn.w	r4, #134	@ 0x86
 c045870:	e7ef      	b.n	c045852 <mbedcrypto__psa_hash_compare+0x46>

0c045872 <mbedcrypto__psa_hash_clone>:
{
 c045872:	b538      	push	{r3, r4, r5, lr}
    if( source_operation->id == 0 ||
 c045874:	6803      	ldr	r3, [r0, #0]
{
 c045876:	460d      	mov	r5, r1
    if( source_operation->id == 0 ||
 c045878:	b153      	cbz	r3, c045890 <mbedcrypto__psa_hash_clone+0x1e>
 c04587a:	680b      	ldr	r3, [r1, #0]
 c04587c:	b943      	cbnz	r3, c045890 <mbedcrypto__psa_hash_clone+0x1e>
    psa_status_t status = psa_driver_wrapper_hash_clone( source_operation,
 c04587e:	f002 f92f 	bl	c047ae0 <psa_driver_wrapper_hash_clone>
    if( status != PSA_SUCCESS )
 c045882:	4604      	mov	r4, r0
 c045884:	b110      	cbz	r0, c04588c <mbedcrypto__psa_hash_clone+0x1a>
        psa_hash_abort( target_operation );
 c045886:	4628      	mov	r0, r5
 c045888:	f7ff ff2f 	bl	c0456ea <mbedcrypto__psa_hash_abort>
}
 c04588c:	4620      	mov	r0, r4
 c04588e:	bd38      	pop	{r3, r4, r5, pc}
        return( PSA_ERROR_BAD_STATE );
 c045890:	f06f 0488 	mvn.w	r4, #136	@ 0x88
 c045894:	e7fa      	b.n	c04588c <mbedcrypto__psa_hash_clone+0x1a>

0c045896 <mbedcrypto__psa_mac_abort>:
    if( operation->id == 0 )
 c045896:	6803      	ldr	r3, [r0, #0]
{
 c045898:	b510      	push	{r4, lr}
 c04589a:	4604      	mov	r4, r0
    if( operation->id == 0 )
 c04589c:	b153      	cbz	r3, c0458b4 <mbedcrypto__psa_mac_abort+0x1e>
    psa_status_t status = psa_driver_wrapper_mac_abort( operation );
 c04589e:	f002 f9cc 	bl	c047c3a <psa_driver_wrapper_mac_abort>
    operation->id = 0;
 c0458a2:	2300      	movs	r3, #0
 c0458a4:	6023      	str	r3, [r4, #0]
    operation->mac_size = 0;
 c0458a6:	88a3      	ldrh	r3, [r4, #4]
 c0458a8:	f423 73ff 	bic.w	r3, r3, #510	@ 0x1fe
 c0458ac:	f023 0301 	bic.w	r3, r3, #1
 c0458b0:	80a3      	strh	r3, [r4, #4]
}
 c0458b2:	bd10      	pop	{r4, pc}
        return( PSA_SUCCESS );
 c0458b4:	4618      	mov	r0, r3
 c0458b6:	e7fc      	b.n	c0458b2 <mbedcrypto__psa_mac_abort+0x1c>

0c0458b8 <psa_mac_setup>:
{
 c0458b8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 c0458bc:	4606      	mov	r6, r0
 c0458be:	461d      	mov	r5, r3
    psa_key_slot_t *slot = NULL;
 c0458c0:	2300      	movs	r3, #0
{
 c0458c2:	b092      	sub	sp, #72	@ 0x48
    psa_key_slot_t *slot = NULL;
 c0458c4:	9305      	str	r3, [sp, #20]
    if( operation->id != 0 )
 c0458c6:	6833      	ldr	r3, [r6, #0]
{
 c0458c8:	a802      	add	r0, sp, #8
 c0458ca:	e880 0006 	stmia.w	r0, {r1, r2}
 c0458ce:	9f18      	ldr	r7, [sp, #96]	@ 0x60
    if( operation->id != 0 )
 c0458d0:	2b00      	cmp	r3, #0
 c0458d2:	f040 809c 	bne.w	c045a0e <psa_mac_setup+0x156>
    status = psa_get_and_lock_key_slot_with_policy(
 c0458d6:	2f00      	cmp	r7, #0
 c0458d8:	9500      	str	r5, [sp, #0]
 c0458da:	bf18      	it	ne
 c0458dc:	f44f 5380 	movne.w	r3, #4096	@ 0x1000
 c0458e0:	c803      	ldmia	r0, {r0, r1}
 c0458e2:	bf08      	it	eq
 c0458e4:	f44f 5300 	moveq.w	r3, #8192	@ 0x2000
 c0458e8:	aa05      	add	r2, sp, #20
 c0458ea:	f7fe fe4d 	bl	c044588 <psa_get_and_lock_key_slot_with_policy>
    if( status != PSA_SUCCESS )
 c0458ee:	4604      	mov	r4, r0
 c0458f0:	b998      	cbnz	r0, c04591a <psa_mac_setup+0x62>
    attributes.core = slot->attr;
 c0458f2:	f8dd 8014 	ldr.w	r8, [sp, #20]
 c0458f6:	ac06      	add	r4, sp, #24
 c0458f8:	46c4      	mov	ip, r8
 c0458fa:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 c0458fe:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 c045900:	e89c 000f 	ldmia.w	ip, {r0, r1, r2, r3}
 c045904:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
    if( ! PSA_ALG_IS_MAC( alg ) )
 c045908:	f005 43fe 	and.w	r3, r5, #2130706432	@ 0x7f000000
 c04590c:	f1b3 7f40 	cmp.w	r3, #50331648	@ 0x3000000
 c045910:	f8bd 1018 	ldrh.w	r1, [sp, #24]
 c045914:	d005      	beq.n	c045922 <psa_mac_setup+0x6a>
        return( PSA_ERROR_INVALID_ARGUMENT );
 c045916:	f06f 0486 	mvn.w	r4, #134	@ 0x86
        psa_mac_abort( operation );
 c04591a:	4630      	mov	r0, r6
 c04591c:	f7ff ffbb 	bl	c045896 <mbedcrypto__psa_mac_abort>
 c045920:	e03f      	b.n	c0459a2 <psa_mac_setup+0xea>
    status = psa_mac_key_can_do( alg, key_type );
 c045922:	4628      	mov	r0, r5
 c045924:	f7fe fa28 	bl	c043d78 <psa_mac_key_can_do>
    if( status != PSA_SUCCESS )
 c045928:	4604      	mov	r4, r0
 c04592a:	2800      	cmp	r0, #0
 c04592c:	d1f5      	bne.n	c04591a <psa_mac_setup+0x62>
    *mac_size = PSA_MAC_LENGTH( key_type, key_bits, alg );
 c04592e:	f415 1f7c 	tst.w	r5, #4128768	@ 0x3f0000
 c045932:	d005      	beq.n	c045940 <psa_mac_setup+0x88>
 c045934:	f3c5 4305 	ubfx	r3, r5, #16, #6
    if( *mac_size < 4 )
 c045938:	2b03      	cmp	r3, #3
    *mac_size = PSA_MAC_LENGTH( key_type, key_bits, alg );
 c04593a:	7133      	strb	r3, [r6, #4]
    if( *mac_size < 4 )
 c04593c:	d80d      	bhi.n	c04595a <psa_mac_setup+0xa2>
 c04593e:	e040      	b.n	c0459c2 <psa_mac_setup+0x10a>
    *mac_size = PSA_MAC_LENGTH( key_type, key_bits, alg );
 c045940:	4b34      	ldr	r3, [pc, #208]	@ (c045a14 <psa_mac_setup+0x15c>)
 c045942:	402b      	ands	r3, r5
 c045944:	f1b3 7f60 	cmp.w	r3, #58720256	@ 0x3800000
 c045948:	d141      	bne.n	c0459ce <psa_mac_setup+0x116>
 c04594a:	4a33      	ldr	r2, [pc, #204]	@ (c045a18 <psa_mac_setup+0x160>)
 c04594c:	b2eb      	uxtb	r3, r5
 c04594e:	f043 7300 	orr.w	r3, r3, #33554432	@ 0x2000000
 c045952:	4293      	cmp	r3, r2
 c045954:	d12e      	bne.n	c0459b4 <psa_mac_setup+0xfc>
 c045956:	2310      	movs	r3, #16
 c045958:	7133      	strb	r3, [r6, #4]
    if( *mac_size > PSA_MAC_LENGTH( key_type, key_bits,
 c04595a:	4a2e      	ldr	r2, [pc, #184]	@ (c045a14 <psa_mac_setup+0x15c>)
 c04595c:	402a      	ands	r2, r5
 c04595e:	f1b2 7f60 	cmp.w	r2, #58720256	@ 0x3800000
 c045962:	d142      	bne.n	c0459ea <psa_mac_setup+0x132>
 c045964:	492c      	ldr	r1, [pc, #176]	@ (c045a18 <psa_mac_setup+0x160>)
 c045966:	b2ea      	uxtb	r2, r5
 c045968:	f042 7200 	orr.w	r2, r2, #33554432	@ 0x2000000
 c04596c:	428a      	cmp	r2, r1
 c04596e:	d049      	beq.n	c045a04 <psa_mac_setup+0x14c>
 c045970:	f102 427e 	add.w	r2, r2, #4261412864	@ 0xfe000000
 c045974:	3a02      	subs	r2, #2
 c045976:	2a11      	cmp	r2, #17
 c045978:	d8cd      	bhi.n	c045916 <psa_mac_setup+0x5e>
 c04597a:	4928      	ldr	r1, [pc, #160]	@ (c045a1c <psa_mac_setup+0x164>)
 c04597c:	5c8a      	ldrb	r2, [r1, r2]
 c04597e:	4293      	cmp	r3, r2
 c045980:	d8c9      	bhi.n	c045916 <psa_mac_setup+0x5e>
    operation->is_sign = is_sign;
 c045982:	7973      	ldrb	r3, [r6, #5]
        status = psa_driver_wrapper_mac_sign_setup( operation,
 c045984:	4630      	mov	r0, r6
    operation->is_sign = is_sign;
 c045986:	f367 0300 	bfi	r3, r7, #0, #1
 c04598a:	7173      	strb	r3, [r6, #5]
        status = psa_driver_wrapper_mac_sign_setup( operation,
 c04598c:	e9d8 2309 	ldrd	r2, r3, [r8, #36]	@ 0x24
 c045990:	a906      	add	r1, sp, #24
 c045992:	9500      	str	r5, [sp, #0]
    if( is_sign )
 c045994:	2f00      	cmp	r7, #0
 c045996:	d037      	beq.n	c045a08 <psa_mac_setup+0x150>
        status = psa_driver_wrapper_mac_sign_setup( operation,
 c045998:	f002 f90b 	bl	c047bb2 <psa_driver_wrapper_mac_sign_setup>
        status = psa_driver_wrapper_mac_verify_setup( operation,
 c04599c:	4604      	mov	r4, r0
    if( status != PSA_SUCCESS )
 c04599e:	2800      	cmp	r0, #0
 c0459a0:	d1bb      	bne.n	c04591a <psa_mac_setup+0x62>
    unlock_status = psa_unlock_key_slot( slot );
 c0459a2:	9805      	ldr	r0, [sp, #20]
 c0459a4:	f003 fb86 	bl	c0490b4 <psa_unlock_key_slot>
}
 c0459a8:	2c00      	cmp	r4, #0
 c0459aa:	bf18      	it	ne
 c0459ac:	4620      	movne	r0, r4
 c0459ae:	b012      	add	sp, #72	@ 0x48
 c0459b0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 c0459b4:	f103 437e 	add.w	r3, r3, #4261412864	@ 0xfe000000
 c0459b8:	3b02      	subs	r3, #2
 c0459ba:	2b11      	cmp	r3, #17
 c0459bc:	d904      	bls.n	c0459c8 <psa_mac_setup+0x110>
    *mac_size = PSA_MAC_LENGTH( key_type, key_bits, alg );
 c0459be:	2300      	movs	r3, #0
 c0459c0:	7133      	strb	r3, [r6, #4]
        status = PSA_ERROR_BAD_STATE;
 c0459c2:	f06f 0485 	mvn.w	r4, #133	@ 0x85
 c0459c6:	e7a8      	b.n	c04591a <psa_mac_setup+0x62>
 c0459c8:	4a15      	ldr	r2, [pc, #84]	@ (c045a20 <psa_mac_setup+0x168>)
 c0459ca:	5cd3      	ldrb	r3, [r2, r3]
 c0459cc:	e7b4      	b.n	c045938 <psa_mac_setup+0x80>
    *mac_size = PSA_MAC_LENGTH( key_type, key_bits, alg );
 c0459ce:	f1b3 7f70 	cmp.w	r3, #62914560	@ 0x3c00000
 c0459d2:	d1f4      	bne.n	c0459be <psa_mac_setup+0x106>
 c0459d4:	f401 43e0 	and.w	r3, r1, #28672	@ 0x7000
 c0459d8:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 c0459dc:	d1ef      	bne.n	c0459be <psa_mac_setup+0x106>
 c0459de:	2301      	movs	r3, #1
 c0459e0:	f3c1 2202 	ubfx	r2, r1, #8, #3
 c0459e4:	4093      	lsls	r3, r2
 c0459e6:	b2db      	uxtb	r3, r3
 c0459e8:	e7a6      	b.n	c045938 <psa_mac_setup+0x80>
    if( *mac_size > PSA_MAC_LENGTH( key_type, key_bits,
 c0459ea:	f1b2 7f70 	cmp.w	r2, #62914560	@ 0x3c00000
 c0459ee:	d192      	bne.n	c045916 <psa_mac_setup+0x5e>
 c0459f0:	f401 42e0 	and.w	r2, r1, #28672	@ 0x7000
 c0459f4:	f5b2 5f00 	cmp.w	r2, #8192	@ 0x2000
 c0459f8:	d18d      	bne.n	c045916 <psa_mac_setup+0x5e>
 c0459fa:	2201      	movs	r2, #1
 c0459fc:	f3c1 2102 	ubfx	r1, r1, #8, #3
 c045a00:	408a      	lsls	r2, r1
 c045a02:	e7bc      	b.n	c04597e <psa_mac_setup+0xc6>
 c045a04:	2210      	movs	r2, #16
 c045a06:	e7ba      	b.n	c04597e <psa_mac_setup+0xc6>
        status = psa_driver_wrapper_mac_verify_setup( operation,
 c045a08:	f002 f8e6 	bl	c047bd8 <psa_driver_wrapper_mac_verify_setup>
 c045a0c:	e7c6      	b.n	c04599c <psa_mac_setup+0xe4>
        status = PSA_ERROR_BAD_STATE;
 c045a0e:	f06f 0488 	mvn.w	r4, #136	@ 0x88
 c045a12:	e782      	b.n	c04591a <psa_mac_setup+0x62>
 c045a14:	7fc00000 	.word	0x7fc00000
 c045a18:	02000001 	.word	0x02000001
 c045a1c:	0c060e58 	.word	0x0c060e58
 c045a20:	0c060e58 	.word	0x0c060e58

0c045a24 <mbedcrypto__psa_mac_sign_setup>:
{
 c045a24:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 c045a26:	ac02      	add	r4, sp, #8
 c045a28:	e884 0006 	stmia.w	r4, {r1, r2}
    return( psa_mac_setup( operation, key, alg, 1 ) );
 c045a2c:	2201      	movs	r2, #1
 c045a2e:	9200      	str	r2, [sp, #0]
 c045a30:	e894 0006 	ldmia.w	r4, {r1, r2}
 c045a34:	f7ff ff40 	bl	c0458b8 <psa_mac_setup>
}
 c045a38:	b004      	add	sp, #16
 c045a3a:	bd10      	pop	{r4, pc}

0c045a3c <mbedcrypto__psa_mac_verify_setup>:
{
 c045a3c:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 c045a3e:	ac02      	add	r4, sp, #8
 c045a40:	e884 0006 	stmia.w	r4, {r1, r2}
    return( psa_mac_setup( operation, key, alg, 0 ) );
 c045a44:	2200      	movs	r2, #0
 c045a46:	9200      	str	r2, [sp, #0]
 c045a48:	e894 0006 	ldmia.w	r4, {r1, r2}
 c045a4c:	f7ff ff34 	bl	c0458b8 <psa_mac_setup>
}
 c045a50:	b004      	add	sp, #16
 c045a52:	bd10      	pop	{r4, pc}

0c045a54 <mbedcrypto__psa_mac_update>:
{
 c045a54:	b538      	push	{r3, r4, r5, lr}
    if( operation->id == 0 )
 c045a56:	6804      	ldr	r4, [r0, #0]
{
 c045a58:	4605      	mov	r5, r0
    if( operation->id == 0 )
 c045a5a:	b164      	cbz	r4, c045a76 <mbedcrypto__psa_mac_update+0x22>
    if( input_length == 0 )
 c045a5c:	b912      	cbnz	r2, c045a64 <mbedcrypto__psa_mac_update+0x10>
        return( PSA_SUCCESS );
 c045a5e:	2400      	movs	r4, #0
}
 c045a60:	4620      	mov	r0, r4
 c045a62:	bd38      	pop	{r3, r4, r5, pc}
    psa_status_t status = psa_driver_wrapper_mac_update( operation,
 c045a64:	f002 f8cb 	bl	c047bfe <psa_driver_wrapper_mac_update>
    if( status != PSA_SUCCESS )
 c045a68:	4604      	mov	r4, r0
 c045a6a:	2800      	cmp	r0, #0
 c045a6c:	d0f7      	beq.n	c045a5e <mbedcrypto__psa_mac_update+0xa>
        psa_mac_abort( operation );
 c045a6e:	4628      	mov	r0, r5
 c045a70:	f7ff ff11 	bl	c045896 <mbedcrypto__psa_mac_abort>
 c045a74:	e7f4      	b.n	c045a60 <mbedcrypto__psa_mac_update+0xc>
        return( PSA_ERROR_BAD_STATE );
 c045a76:	f06f 0488 	mvn.w	r4, #136	@ 0x88
 c045a7a:	e7f1      	b.n	c045a60 <mbedcrypto__psa_mac_update+0xc>

0c045a7c <mbedcrypto__psa_mac_sign_finish>:
{
 c045a7c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 c045a80:	4616      	mov	r6, r2
    if( operation->id == 0 )
 c045a82:	6802      	ldr	r2, [r0, #0]
{
 c045a84:	4605      	mov	r5, r0
 c045a86:	460f      	mov	r7, r1
 c045a88:	4698      	mov	r8, r3
    if( operation->id == 0 )
 c045a8a:	b1f2      	cbz	r2, c045aca <mbedcrypto__psa_mac_sign_finish+0x4e>
    if( ! operation->is_sign )
 c045a8c:	7942      	ldrb	r2, [r0, #5]
 c045a8e:	07d2      	lsls	r2, r2, #31
 c045a90:	d51b      	bpl.n	c045aca <mbedcrypto__psa_mac_sign_finish+0x4e>
    if( operation->mac_size == 0 )
 c045a92:	7902      	ldrb	r2, [r0, #4]
 c045a94:	b1ca      	cbz	r2, c045aca <mbedcrypto__psa_mac_sign_finish+0x4e>
    if( mac_size < operation->mac_size )
 c045a96:	42b2      	cmp	r2, r6
 c045a98:	d81a      	bhi.n	c045ad0 <mbedcrypto__psa_mac_sign_finish+0x54>
    status = psa_driver_wrapper_mac_sign_finish( operation,
 c045a9a:	f002 f8b9 	bl	c047c10 <psa_driver_wrapper_mac_sign_finish>
    if( status != PSA_SUCCESS )
 c045a9e:	4604      	mov	r4, r0
 c045aa0:	b118      	cbz	r0, c045aaa <mbedcrypto__psa_mac_sign_finish+0x2e>
        operation->mac_size = 0;
 c045aa2:	2300      	movs	r3, #0
        *mac_length = mac_size;
 c045aa4:	f8c8 6000 	str.w	r6, [r8]
        operation->mac_size = 0;
 c045aa8:	712b      	strb	r3, [r5, #4]
    if( mac_size > operation->mac_size )
 c045aaa:	7928      	ldrb	r0, [r5, #4]
 c045aac:	42b0      	cmp	r0, r6
 c045aae:	d204      	bcs.n	c045aba <mbedcrypto__psa_mac_sign_finish+0x3e>
        memset( &mac[operation->mac_size], '!',
 c045ab0:	1a32      	subs	r2, r6, r0
 c045ab2:	2121      	movs	r1, #33	@ 0x21
 c045ab4:	4438      	add	r0, r7
 c045ab6:	f015 fe3a 	bl	c05b72e <memset>
    abort_status = psa_mac_abort( operation );
 c045aba:	4628      	mov	r0, r5
 c045abc:	f7ff feeb 	bl	c045896 <mbedcrypto__psa_mac_abort>
}
 c045ac0:	2c00      	cmp	r4, #0
 c045ac2:	bf18      	it	ne
 c045ac4:	4620      	movne	r0, r4
 c045ac6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        status = PSA_ERROR_BAD_STATE;
 c045aca:	f06f 0488 	mvn.w	r4, #136	@ 0x88
 c045ace:	e7e8      	b.n	c045aa2 <mbedcrypto__psa_mac_sign_finish+0x26>
        status = PSA_ERROR_BUFFER_TOO_SMALL;
 c045ad0:	f06f 0489 	mvn.w	r4, #137	@ 0x89
 c045ad4:	e7e5      	b.n	c045aa2 <mbedcrypto__psa_mac_sign_finish+0x26>
	...

0c045ad8 <psa_key_derivation_tls12_prf_generate_next_block>:
{
 c045ad8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    uint8_t hash_length = PSA_HASH_LENGTH( hash_alg );
 c045adc:	4b40      	ldr	r3, [pc, #256]	@ (c045be0 <psa_key_derivation_tls12_prf_generate_next_block+0x108>)
    psa_algorithm_t hash_alg = PSA_ALG_HKDF_GET_HASH( alg );
 c045ade:	b2cf      	uxtb	r7, r1
 c045ae0:	f047 7700 	orr.w	r7, r7, #33554432	@ 0x2000000
    uint8_t hash_length = PSA_HASH_LENGTH( hash_alg );
 c045ae4:	429f      	cmp	r7, r3
{
 c045ae6:	4605      	mov	r5, r0
 c045ae8:	f5ad 7d0a 	sub.w	sp, sp, #552	@ 0x228
    uint8_t hash_length = PSA_HASH_LENGTH( hash_alg );
 c045aec:	d06a      	beq.n	c045bc4 <psa_key_derivation_tls12_prf_generate_next_block+0xec>
 c045aee:	f107 437e 	add.w	r3, r7, #4261412864	@ 0xfe000000
 c045af2:	3b02      	subs	r3, #2
 c045af4:	2b11      	cmp	r3, #17
 c045af6:	d867      	bhi.n	c045bc8 <psa_key_derivation_tls12_prf_generate_next_block+0xf0>
 c045af8:	4a3a      	ldr	r2, [pc, #232]	@ (c045be4 <psa_key_derivation_tls12_prf_generate_next_block+0x10c>)
 c045afa:	5cd6      	ldrb	r6, [r2, r3]
    psa_mac_operation_t hmac = PSA_MAC_OPERATION_INIT;
 c045afc:	f44f 7208 	mov.w	r2, #544	@ 0x220
 c045b00:	2100      	movs	r1, #0
 c045b02:	a802      	add	r0, sp, #8
 c045b04:	f015 fe13 	bl	c05b72e <memset>
    if( tls12_prf->block_number == 0xff )
 c045b08:	786b      	ldrb	r3, [r5, #1]
 c045b0a:	2bff      	cmp	r3, #255	@ 0xff
 c045b0c:	d065      	beq.n	c045bda <psa_key_derivation_tls12_prf_generate_next_block+0x102>
    ++tls12_prf->block_number;
 c045b0e:	3301      	adds	r3, #1
 c045b10:	706b      	strb	r3, [r5, #1]
    status = psa_key_derivation_start_hmac( &hmac,
 c045b12:	4639      	mov	r1, r7
 c045b14:	e9d5 2301 	ldrd	r2, r3, [r5, #4]
    tls12_prf->left_in_block = hash_length;
 c045b18:	702e      	strb	r6, [r5, #0]
    status = psa_key_derivation_start_hmac( &hmac,
 c045b1a:	a802      	add	r0, sp, #8
 c045b1c:	f7fe fe88 	bl	c044830 <psa_key_derivation_start_hmac>
    if( status != PSA_SUCCESS )
 c045b20:	4604      	mov	r4, r0
 c045b22:	2800      	cmp	r0, #0
 c045b24:	d143      	bne.n	c045bae <psa_key_derivation_tls12_prf_generate_next_block+0xd6>
    if( tls12_prf->block_number == 1 )
 c045b26:	786b      	ldrb	r3, [r5, #1]
 c045b28:	2b01      	cmp	r3, #1
 c045b2a:	d14f      	bne.n	c045bcc <psa_key_derivation_tls12_prf_generate_next_block+0xf4>
        status = psa_mac_update( &hmac,
 c045b2c:	e9d5 1205 	ldrd	r1, r2, [r5, #20]
 c045b30:	a802      	add	r0, sp, #8
 c045b32:	f7ff ff8f 	bl	c045a54 <mbedcrypto__psa_mac_update>
        if( status != PSA_SUCCESS )
 c045b36:	4604      	mov	r4, r0
 c045b38:	2800      	cmp	r0, #0
 c045b3a:	d138      	bne.n	c045bae <psa_key_derivation_tls12_prf_generate_next_block+0xd6>
        status = psa_mac_update( &hmac,
 c045b3c:	e9d5 1203 	ldrd	r1, r2, [r5, #12]
 c045b40:	a802      	add	r0, sp, #8
 c045b42:	f7ff ff87 	bl	c045a54 <mbedcrypto__psa_mac_update>
        if( status != PSA_SUCCESS )
 c045b46:	4604      	mov	r4, r0
 c045b48:	bb88      	cbnz	r0, c045bae <psa_key_derivation_tls12_prf_generate_next_block+0xd6>
                                  tls12_prf->Ai, hash_length,
 c045b4a:	f105 081c 	add.w	r8, r5, #28
    status = psa_mac_sign_finish( &hmac,
 c045b4e:	ab01      	add	r3, sp, #4
 c045b50:	4632      	mov	r2, r6
 c045b52:	4641      	mov	r1, r8
 c045b54:	a802      	add	r0, sp, #8
 c045b56:	f7ff ff91 	bl	c045a7c <mbedcrypto__psa_mac_sign_finish>
    if( hmac_output_length != hash_length )
 c045b5a:	9b01      	ldr	r3, [sp, #4]
    status = psa_mac_sign_finish( &hmac,
 c045b5c:	4604      	mov	r4, r0
    if( hmac_output_length != hash_length )
 c045b5e:	429e      	cmp	r6, r3
 c045b60:	d138      	bne.n	c045bd4 <psa_key_derivation_tls12_prf_generate_next_block+0xfc>
    if( status != PSA_SUCCESS )
 c045b62:	bb20      	cbnz	r0, c045bae <psa_key_derivation_tls12_prf_generate_next_block+0xd6>
    status = psa_key_derivation_start_hmac( &hmac,
 c045b64:	e9d5 2301 	ldrd	r2, r3, [r5, #4]
 c045b68:	4639      	mov	r1, r7
 c045b6a:	a802      	add	r0, sp, #8
 c045b6c:	f7fe fe60 	bl	c044830 <psa_key_derivation_start_hmac>
    if( status != PSA_SUCCESS )
 c045b70:	4604      	mov	r4, r0
 c045b72:	b9e0      	cbnz	r0, c045bae <psa_key_derivation_tls12_prf_generate_next_block+0xd6>
    status = psa_mac_update( &hmac, tls12_prf->Ai, hash_length );
 c045b74:	4632      	mov	r2, r6
 c045b76:	4641      	mov	r1, r8
 c045b78:	a802      	add	r0, sp, #8
 c045b7a:	f7ff ff6b 	bl	c045a54 <mbedcrypto__psa_mac_update>
    if( status != PSA_SUCCESS )
 c045b7e:	4604      	mov	r4, r0
 c045b80:	b9a8      	cbnz	r0, c045bae <psa_key_derivation_tls12_prf_generate_next_block+0xd6>
    status = psa_mac_update( &hmac, tls12_prf->label, tls12_prf->label_length );
 c045b82:	e9d5 1205 	ldrd	r1, r2, [r5, #20]
 c045b86:	a802      	add	r0, sp, #8
 c045b88:	f7ff ff64 	bl	c045a54 <mbedcrypto__psa_mac_update>
    if( status != PSA_SUCCESS )
 c045b8c:	4604      	mov	r4, r0
 c045b8e:	b970      	cbnz	r0, c045bae <psa_key_derivation_tls12_prf_generate_next_block+0xd6>
    status = psa_mac_update( &hmac, tls12_prf->seed, tls12_prf->seed_length );
 c045b90:	e9d5 1203 	ldrd	r1, r2, [r5, #12]
 c045b94:	a802      	add	r0, sp, #8
 c045b96:	f7ff ff5d 	bl	c045a54 <mbedcrypto__psa_mac_update>
    if( status != PSA_SUCCESS )
 c045b9a:	4604      	mov	r4, r0
 c045b9c:	b938      	cbnz	r0, c045bae <psa_key_derivation_tls12_prf_generate_next_block+0xd6>
    status = psa_mac_sign_finish( &hmac,
 c045b9e:	4632      	mov	r2, r6
 c045ba0:	ab01      	add	r3, sp, #4
 c045ba2:	f105 015c 	add.w	r1, r5, #92	@ 0x5c
 c045ba6:	a802      	add	r0, sp, #8
 c045ba8:	f7ff ff68 	bl	c045a7c <mbedcrypto__psa_mac_sign_finish>
 c045bac:	4604      	mov	r4, r0
    cleanup_status = psa_mac_abort( &hmac );
 c045bae:	a802      	add	r0, sp, #8
 c045bb0:	f7ff fe71 	bl	c045896 <mbedcrypto__psa_mac_abort>
    if( status == PSA_SUCCESS && cleanup_status != PSA_SUCCESS )
 c045bb4:	2c00      	cmp	r4, #0
 c045bb6:	bf08      	it	eq
 c045bb8:	4604      	moveq	r4, r0
}
 c045bba:	4620      	mov	r0, r4
 c045bbc:	f50d 7d0a 	add.w	sp, sp, #552	@ 0x228
 c045bc0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    uint8_t hash_length = PSA_HASH_LENGTH( hash_alg );
 c045bc4:	2610      	movs	r6, #16
 c045bc6:	e799      	b.n	c045afc <psa_key_derivation_tls12_prf_generate_next_block+0x24>
 c045bc8:	2600      	movs	r6, #0
 c045bca:	e797      	b.n	c045afc <psa_key_derivation_tls12_prf_generate_next_block+0x24>
        status = psa_mac_update( &hmac, tls12_prf->Ai, hash_length );
 c045bcc:	4632      	mov	r2, r6
 c045bce:	f105 011c 	add.w	r1, r5, #28
 c045bd2:	e7b5      	b.n	c045b40 <psa_key_derivation_tls12_prf_generate_next_block+0x68>
        status = PSA_ERROR_CORRUPTION_DETECTED;
 c045bd4:	f06f 0496 	mvn.w	r4, #150	@ 0x96
 c045bd8:	e7e9      	b.n	c045bae <psa_key_derivation_tls12_prf_generate_next_block+0xd6>
        return( PSA_ERROR_CORRUPTION_DETECTED );
 c045bda:	f06f 0496 	mvn.w	r4, #150	@ 0x96
 c045bde:	e7ec      	b.n	c045bba <psa_key_derivation_tls12_prf_generate_next_block+0xe2>
 c045be0:	02000001 	.word	0x02000001
 c045be4:	0c060e58 	.word	0x0c060e58

0c045be8 <mbedcrypto__psa_mac_verify_finish>:
{
 c045be8:	b538      	push	{r3, r4, r5, lr}
    if( operation->id == 0 )
 c045bea:	6804      	ldr	r4, [r0, #0]
{
 c045bec:	4605      	mov	r5, r0
    if( operation->id == 0 )
 c045bee:	b17c      	cbz	r4, c045c10 <mbedcrypto__psa_mac_verify_finish+0x28>
    if( operation->is_sign )
 c045bf0:	7944      	ldrb	r4, [r0, #5]
 c045bf2:	07e4      	lsls	r4, r4, #31
 c045bf4:	d40c      	bmi.n	c045c10 <mbedcrypto__psa_mac_verify_finish+0x28>
    if( operation->mac_size != mac_length )
 c045bf6:	7904      	ldrb	r4, [r0, #4]
 c045bf8:	4294      	cmp	r4, r2
 c045bfa:	d10c      	bne.n	c045c16 <mbedcrypto__psa_mac_verify_finish+0x2e>
    status = psa_driver_wrapper_mac_verify_finish( operation,
 c045bfc:	f002 f814 	bl	c047c28 <psa_driver_wrapper_mac_verify_finish>
 c045c00:	4604      	mov	r4, r0
    abort_status = psa_mac_abort( operation );
 c045c02:	4628      	mov	r0, r5
 c045c04:	f7ff fe47 	bl	c045896 <mbedcrypto__psa_mac_abort>
}
 c045c08:	2c00      	cmp	r4, #0
 c045c0a:	bf18      	it	ne
 c045c0c:	4620      	movne	r0, r4
 c045c0e:	bd38      	pop	{r3, r4, r5, pc}
        status = PSA_ERROR_BAD_STATE;
 c045c10:	f06f 0488 	mvn.w	r4, #136	@ 0x88
 c045c14:	e7f5      	b.n	c045c02 <mbedcrypto__psa_mac_verify_finish+0x1a>
        status = PSA_ERROR_INVALID_SIGNATURE;
 c045c16:	f06f 0494 	mvn.w	r4, #148	@ 0x94
 c045c1a:	e7f2      	b.n	c045c02 <mbedcrypto__psa_mac_verify_finish+0x1a>

0c045c1c <psa_sign_message_builtin>:
{
 c045c1c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 c045c20:	4617      	mov	r7, r2
 c045c22:	461c      	mov	r4, r3
    if ( PSA_ALG_IS_SIGN_HASH( alg ) )
 c045c24:	4a1f      	ldr	r2, [pc, #124]	@ (c045ca4 <psa_sign_message_builtin+0x88>)
 c045c26:	f423 73ff 	bic.w	r3, r3, #510	@ 0x1fe
 c045c2a:	f023 0301 	bic.w	r3, r3, #1
 c045c2e:	4293      	cmp	r3, r2
{
 c045c30:	4605      	mov	r5, r0
 c045c32:	460e      	mov	r6, r1
 c045c34:	b098      	sub	sp, #96	@ 0x60
    if ( PSA_ALG_IS_SIGN_HASH( alg ) )
 c045c36:	d00e      	beq.n	c045c56 <psa_sign_message_builtin+0x3a>
 c045c38:	4b1b      	ldr	r3, [pc, #108]	@ (c045ca8 <psa_sign_message_builtin+0x8c>)
 c045c3a:	f024 02ff 	bic.w	r2, r4, #255	@ 0xff
 c045c3e:	429a      	cmp	r2, r3
 c045c40:	d009      	beq.n	c045c56 <psa_sign_message_builtin+0x3a>
 c045c42:	491a      	ldr	r1, [pc, #104]	@ (c045cac <psa_sign_message_builtin+0x90>)
 c045c44:	f424 737f 	bic.w	r3, r4, #1020	@ 0x3fc
 c045c48:	f023 0303 	bic.w	r3, r3, #3
 c045c4c:	428b      	cmp	r3, r1
 c045c4e:	d002      	beq.n	c045c56 <psa_sign_message_builtin+0x3a>
 c045c50:	4b17      	ldr	r3, [pc, #92]	@ (c045cb0 <psa_sign_message_builtin+0x94>)
 c045c52:	429a      	cmp	r2, r3
 c045c54:	d122      	bne.n	c045c9c <psa_sign_message_builtin+0x80>
        status = psa_driver_wrapper_hash_compute(
 c045c56:	e9dd 121e 	ldrd	r1, r2, [sp, #120]	@ 0x78
 c045c5a:	ab07      	add	r3, sp, #28
 c045c5c:	9301      	str	r3, [sp, #4]
 c045c5e:	2340      	movs	r3, #64	@ 0x40
                    PSA_ALG_SIGN_GET_HASH( alg ),
 c045c60:	f014 00ff 	ands.w	r0, r4, #255	@ 0xff
        status = psa_driver_wrapper_hash_compute(
 c045c64:	f10d 0820 	add.w	r8, sp, #32
 c045c68:	bf18      	it	ne
 c045c6a:	f040 7000 	orrne.w	r0, r0, #33554432	@ 0x2000000
 c045c6e:	9300      	str	r3, [sp, #0]
 c045c70:	4643      	mov	r3, r8
 c045c72:	f001 ff2a 	bl	c047aca <psa_driver_wrapper_hash_compute>
        if( status != PSA_SUCCESS )
 c045c76:	b970      	cbnz	r0, c045c96 <psa_sign_message_builtin+0x7a>
        return psa_driver_wrapper_sign_hash(
 c045c78:	9b22      	ldr	r3, [sp, #136]	@ 0x88
 c045c7a:	463a      	mov	r2, r7
 c045c7c:	9304      	str	r3, [sp, #16]
 c045c7e:	9b21      	ldr	r3, [sp, #132]	@ 0x84
 c045c80:	4631      	mov	r1, r6
 c045c82:	9303      	str	r3, [sp, #12]
 c045c84:	9b20      	ldr	r3, [sp, #128]	@ 0x80
 c045c86:	4628      	mov	r0, r5
 c045c88:	9302      	str	r3, [sp, #8]
 c045c8a:	9b07      	ldr	r3, [sp, #28]
 c045c8c:	e9cd 8300 	strd	r8, r3, [sp]
 c045c90:	4623      	mov	r3, r4
 c045c92:	f001 fd74 	bl	c04777e <psa_driver_wrapper_sign_hash>
}
 c045c96:	b018      	add	sp, #96	@ 0x60
 c045c98:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    return( PSA_ERROR_NOT_SUPPORTED );
 c045c9c:	f06f 0085 	mvn.w	r0, #133	@ 0x85
 c045ca0:	e7f9      	b.n	c045c96 <psa_sign_message_builtin+0x7a>
 c045ca2:	bf00      	nop
 c045ca4:	06000200 	.word	0x06000200
 c045ca8:	06001300 	.word	0x06001300
 c045cac:	06000400 	.word	0x06000400
 c045cb0:	06000900 	.word	0x06000900

0c045cb4 <psa_verify_message_builtin>:
{
 c045cb4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 c045cb8:	4617      	mov	r7, r2
 c045cba:	461c      	mov	r4, r3
    if ( PSA_ALG_IS_SIGN_HASH( alg ) )
 c045cbc:	4a1e      	ldr	r2, [pc, #120]	@ (c045d38 <psa_verify_message_builtin+0x84>)
 c045cbe:	f423 73ff 	bic.w	r3, r3, #510	@ 0x1fe
 c045cc2:	f023 0301 	bic.w	r3, r3, #1
 c045cc6:	4293      	cmp	r3, r2
{
 c045cc8:	4605      	mov	r5, r0
 c045cca:	460e      	mov	r6, r1
 c045ccc:	b096      	sub	sp, #88	@ 0x58
    if ( PSA_ALG_IS_SIGN_HASH( alg ) )
 c045cce:	d00e      	beq.n	c045cee <psa_verify_message_builtin+0x3a>
 c045cd0:	4b1a      	ldr	r3, [pc, #104]	@ (c045d3c <psa_verify_message_builtin+0x88>)
 c045cd2:	f024 02ff 	bic.w	r2, r4, #255	@ 0xff
 c045cd6:	429a      	cmp	r2, r3
 c045cd8:	d009      	beq.n	c045cee <psa_verify_message_builtin+0x3a>
 c045cda:	4919      	ldr	r1, [pc, #100]	@ (c045d40 <psa_verify_message_builtin+0x8c>)
 c045cdc:	f424 737f 	bic.w	r3, r4, #1020	@ 0x3fc
 c045ce0:	f023 0303 	bic.w	r3, r3, #3
 c045ce4:	428b      	cmp	r3, r1
 c045ce6:	d002      	beq.n	c045cee <psa_verify_message_builtin+0x3a>
 c045ce8:	4b16      	ldr	r3, [pc, #88]	@ (c045d44 <psa_verify_message_builtin+0x90>)
 c045cea:	429a      	cmp	r2, r3
 c045cec:	d120      	bne.n	c045d30 <psa_verify_message_builtin+0x7c>
        status = psa_driver_wrapper_hash_compute(
 c045cee:	e9dd 121c 	ldrd	r1, r2, [sp, #112]	@ 0x70
 c045cf2:	ab05      	add	r3, sp, #20
 c045cf4:	9301      	str	r3, [sp, #4]
 c045cf6:	2340      	movs	r3, #64	@ 0x40
                    PSA_ALG_SIGN_GET_HASH( alg ),
 c045cf8:	f014 00ff 	ands.w	r0, r4, #255	@ 0xff
        status = psa_driver_wrapper_hash_compute(
 c045cfc:	f10d 0818 	add.w	r8, sp, #24
 c045d00:	bf18      	it	ne
 c045d02:	f040 7000 	orrne.w	r0, r0, #33554432	@ 0x2000000
 c045d06:	9300      	str	r3, [sp, #0]
 c045d08:	4643      	mov	r3, r8
 c045d0a:	f001 fede 	bl	c047aca <psa_driver_wrapper_hash_compute>
        if( status != PSA_SUCCESS )
 c045d0e:	b960      	cbnz	r0, c045d2a <psa_verify_message_builtin+0x76>
        return psa_driver_wrapper_verify_hash(
 c045d10:	9b1f      	ldr	r3, [sp, #124]	@ 0x7c
 c045d12:	463a      	mov	r2, r7
 c045d14:	9303      	str	r3, [sp, #12]
 c045d16:	9b1e      	ldr	r3, [sp, #120]	@ 0x78
 c045d18:	4631      	mov	r1, r6
 c045d1a:	9302      	str	r3, [sp, #8]
 c045d1c:	9b05      	ldr	r3, [sp, #20]
 c045d1e:	4628      	mov	r0, r5
 c045d20:	e9cd 8300 	strd	r8, r3, [sp]
 c045d24:	4623      	mov	r3, r4
 c045d26:	f001 fd68 	bl	c0477fa <psa_driver_wrapper_verify_hash>
}
 c045d2a:	b016      	add	sp, #88	@ 0x58
 c045d2c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    return( PSA_ERROR_NOT_SUPPORTED );
 c045d30:	f06f 0085 	mvn.w	r0, #133	@ 0x85
 c045d34:	e7f9      	b.n	c045d2a <psa_verify_message_builtin+0x76>
 c045d36:	bf00      	nop
 c045d38:	06000200 	.word	0x06000200
 c045d3c:	06001300 	.word	0x06001300
 c045d40:	06000400 	.word	0x06000400
 c045d44:	06000900 	.word	0x06000900

0c045d48 <psa_sign_hash_builtin>:
{
 c045d48:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    if( attributes->core.type == PSA_KEY_TYPE_RSA_KEY_PAIR )
 c045d4c:	f247 0b01 	movw	fp, #28673	@ 0x7001
{
 c045d50:	e9dd ce0c 	ldrd	ip, lr, [sp, #48]	@ 0x30
 c045d54:	e9dd 890e 	ldrd	r8, r9, [sp, #56]	@ 0x38
    if( attributes->core.type == PSA_KEY_TYPE_RSA_KEY_PAIR )
 c045d58:	8805      	ldrh	r5, [r0, #0]
{
 c045d5a:	4606      	mov	r6, r0
    if( attributes->core.type == PSA_KEY_TYPE_RSA_KEY_PAIR )
 c045d5c:	455d      	cmp	r5, fp
{
 c045d5e:	4617      	mov	r7, r2
 c045d60:	461c      	mov	r4, r3
 c045d62:	f8dd a040 	ldr.w	sl, [sp, #64]	@ 0x40
 c045d66:	9101      	str	r1, [sp, #4]
    if( attributes->core.type == PSA_KEY_TYPE_RSA_KEY_PAIR )
 c045d68:	d11a      	bne.n	c045da0 <psa_sign_hash_builtin+0x58>
        if( PSA_ALG_IS_RSA_PKCS1V15_SIGN( alg ) ||
 c045d6a:	4a1d      	ldr	r2, [pc, #116]	@ (c045de0 <psa_sign_hash_builtin+0x98>)
 c045d6c:	f423 73ff 	bic.w	r3, r3, #510	@ 0x1fe
 c045d70:	f023 0301 	bic.w	r3, r3, #1
 c045d74:	4293      	cmp	r3, r2
 c045d76:	d004      	beq.n	c045d82 <psa_sign_hash_builtin+0x3a>
            PSA_ALG_IS_RSA_PSS( alg) )
 c045d78:	4b1a      	ldr	r3, [pc, #104]	@ (c045de4 <psa_sign_hash_builtin+0x9c>)
        if( PSA_ALG_IS_RSA_PKCS1V15_SIGN( alg ) ||
 c045d7a:	f024 02ff 	bic.w	r2, r4, #255	@ 0xff
            PSA_ALG_IS_RSA_PSS( alg) )
 c045d7e:	429a      	cmp	r2, r3
 c045d80:	d12a      	bne.n	c045dd8 <psa_sign_hash_builtin+0x90>
            return( mbedtls_psa_rsa_sign_hash(
 c045d82:	4623      	mov	r3, r4
 c045d84:	463a      	mov	r2, r7
 c045d86:	4630      	mov	r0, r6
 c045d88:	9901      	ldr	r1, [sp, #4]
 c045d8a:	e9cd 9a0f 	strd	r9, sl, [sp, #60]	@ 0x3c
 c045d8e:	e9cd e80d 	strd	lr, r8, [sp, #52]	@ 0x34
 c045d92:	f8cd c030 	str.w	ip, [sp, #48]	@ 0x30
}
 c045d96:	b003      	add	sp, #12
 c045d98:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
            return( mbedtls_psa_rsa_sign_hash(
 c045d9c:	f002 be5c 	b.w	c048a58 <mbedtls_psa_rsa_sign_hash>
    else if( PSA_KEY_TYPE_IS_ECC( attributes->core.type ) )
 c045da0:	f405 454f 	and.w	r5, r5, #52992	@ 0xcf00
 c045da4:	f5b5 4f82 	cmp.w	r5, #16640	@ 0x4100
 c045da8:	d111      	bne.n	c045dce <psa_sign_hash_builtin+0x86>
        if( PSA_ALG_IS_ECDSA( alg ) )
 c045daa:	f423 74ff 	bic.w	r4, r3, #510	@ 0x1fe
 c045dae:	f024 0401 	bic.w	r4, r4, #1
 c045db2:	f1b4 2f06 	cmp.w	r4, #100664832	@ 0x6000600
 c045db6:	d10f      	bne.n	c045dd8 <psa_sign_hash_builtin+0x90>
            return( mbedtls_psa_ecdsa_sign_hash(
 c045db8:	e9cd 9a0f 	strd	r9, sl, [sp, #60]	@ 0x3c
 c045dbc:	e9cd e80d 	strd	lr, r8, [sp, #52]	@ 0x34
 c045dc0:	f8cd c030 	str.w	ip, [sp, #48]	@ 0x30
}
 c045dc4:	b003      	add	sp, #12
 c045dc6:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
            return( mbedtls_psa_ecdsa_sign_hash(
 c045dca:	f002 b8b5 	b.w	c047f38 <mbedtls_psa_ecdsa_sign_hash>
    return( PSA_ERROR_NOT_SUPPORTED );
 c045dce:	f06f 0085 	mvn.w	r0, #133	@ 0x85
}
 c045dd2:	b003      	add	sp, #12
 c045dd4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            return( PSA_ERROR_INVALID_ARGUMENT );
 c045dd8:	f06f 0086 	mvn.w	r0, #134	@ 0x86
 c045ddc:	e7f9      	b.n	c045dd2 <psa_sign_hash_builtin+0x8a>
 c045dde:	bf00      	nop
 c045de0:	06000200 	.word	0x06000200
 c045de4:	06001300 	.word	0x06001300

0c045de8 <mbedcrypto__psa_sign_hash>:
{
 c045de8:	b510      	push	{r4, lr}
 c045dea:	b088      	sub	sp, #32
 c045dec:	ac06      	add	r4, sp, #24
 c045dee:	e884 0003 	stmia.w	r4, {r0, r1}
    return psa_sign_internal(
 c045df2:	990d      	ldr	r1, [sp, #52]	@ 0x34
 c045df4:	9104      	str	r1, [sp, #16]
 c045df6:	990c      	ldr	r1, [sp, #48]	@ 0x30
 c045df8:	9103      	str	r1, [sp, #12]
 c045dfa:	990b      	ldr	r1, [sp, #44]	@ 0x2c
 c045dfc:	9102      	str	r1, [sp, #8]
 c045dfe:	990a      	ldr	r1, [sp, #40]	@ 0x28
 c045e00:	e9cd 3100 	strd	r3, r1, [sp]
 c045e04:	4613      	mov	r3, r2
 c045e06:	e894 0003 	ldmia.w	r4, {r0, r1}
 c045e0a:	2200      	movs	r2, #0
 c045e0c:	f7fe fc48 	bl	c0446a0 <psa_sign_internal>
}
 c045e10:	b008      	add	sp, #32
 c045e12:	bd10      	pop	{r4, pc}

0c045e14 <psa_verify_hash_builtin>:
{
 c045e14:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    if( PSA_KEY_TYPE_IS_RSA( attributes->core.type ) )
 c045e18:	f244 0a01 	movw	sl, #16385	@ 0x4001
{
 c045e1c:	e9dd ce0c 	ldrd	ip, lr, [sp, #48]	@ 0x30
 c045e20:	e9dd 890e 	ldrd	r8, r9, [sp, #56]	@ 0x38
    if( PSA_KEY_TYPE_IS_RSA( attributes->core.type ) )
 c045e24:	8805      	ldrh	r5, [r0, #0]
{
 c045e26:	4606      	mov	r6, r0
    if( PSA_KEY_TYPE_IS_RSA( attributes->core.type ) )
 c045e28:	f425 5b40 	bic.w	fp, r5, #12288	@ 0x3000
 c045e2c:	45d3      	cmp	fp, sl
{
 c045e2e:	4617      	mov	r7, r2
 c045e30:	461c      	mov	r4, r3
 c045e32:	9101      	str	r1, [sp, #4]
    if( PSA_KEY_TYPE_IS_RSA( attributes->core.type ) )
 c045e34:	d118      	bne.n	c045e68 <psa_verify_hash_builtin+0x54>
        if( PSA_ALG_IS_RSA_PKCS1V15_SIGN( alg ) ||
 c045e36:	4a1b      	ldr	r2, [pc, #108]	@ (c045ea4 <psa_verify_hash_builtin+0x90>)
 c045e38:	f423 73ff 	bic.w	r3, r3, #510	@ 0x1fe
 c045e3c:	f023 0301 	bic.w	r3, r3, #1
 c045e40:	4293      	cmp	r3, r2
 c045e42:	d004      	beq.n	c045e4e <psa_verify_hash_builtin+0x3a>
            PSA_ALG_IS_RSA_PSS( alg) )
 c045e44:	4b18      	ldr	r3, [pc, #96]	@ (c045ea8 <psa_verify_hash_builtin+0x94>)
        if( PSA_ALG_IS_RSA_PKCS1V15_SIGN( alg ) ||
 c045e46:	f024 02ff 	bic.w	r2, r4, #255	@ 0xff
            PSA_ALG_IS_RSA_PSS( alg) )
 c045e4a:	429a      	cmp	r2, r3
 c045e4c:	d126      	bne.n	c045e9c <psa_verify_hash_builtin+0x88>
            return( mbedtls_psa_rsa_verify_hash(
 c045e4e:	4623      	mov	r3, r4
 c045e50:	463a      	mov	r2, r7
 c045e52:	4630      	mov	r0, r6
 c045e54:	9901      	ldr	r1, [sp, #4]
 c045e56:	e9cd 890e 	strd	r8, r9, [sp, #56]	@ 0x38
 c045e5a:	e9cd ce0c 	strd	ip, lr, [sp, #48]	@ 0x30
}
 c045e5e:	b003      	add	sp, #12
 c045e60:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
            return( mbedtls_psa_rsa_verify_hash(
 c045e64:	f002 be6c 	b.w	c048b40 <mbedtls_psa_rsa_verify_hash>
    else if( PSA_KEY_TYPE_IS_ECC( attributes->core.type ) )
 c045e68:	f405 454f 	and.w	r5, r5, #52992	@ 0xcf00
 c045e6c:	f5b5 4f82 	cmp.w	r5, #16640	@ 0x4100
 c045e70:	d10f      	bne.n	c045e92 <psa_verify_hash_builtin+0x7e>
        if( PSA_ALG_IS_ECDSA( alg ) )
 c045e72:	f423 74ff 	bic.w	r4, r3, #510	@ 0x1fe
 c045e76:	f024 0401 	bic.w	r4, r4, #1
 c045e7a:	f1b4 2f06 	cmp.w	r4, #100664832	@ 0x6000600
 c045e7e:	d10d      	bne.n	c045e9c <psa_verify_hash_builtin+0x88>
            return( mbedtls_psa_ecdsa_verify_hash(
 c045e80:	e9cd 890e 	strd	r8, r9, [sp, #56]	@ 0x38
 c045e84:	e9cd ce0c 	strd	ip, lr, [sp, #48]	@ 0x30
}
 c045e88:	b003      	add	sp, #12
 c045e8a:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
            return( mbedtls_psa_ecdsa_verify_hash(
 c045e8e:	f002 b8f3 	b.w	c048078 <mbedtls_psa_ecdsa_verify_hash>
    return( PSA_ERROR_NOT_SUPPORTED );
 c045e92:	f06f 0085 	mvn.w	r0, #133	@ 0x85
}
 c045e96:	b003      	add	sp, #12
 c045e98:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            return( PSA_ERROR_INVALID_ARGUMENT );
 c045e9c:	f06f 0086 	mvn.w	r0, #134	@ 0x86
 c045ea0:	e7f9      	b.n	c045e96 <psa_verify_hash_builtin+0x82>
 c045ea2:	bf00      	nop
 c045ea4:	06000200 	.word	0x06000200
 c045ea8:	06001300 	.word	0x06001300

0c045eac <mbedcrypto__psa_verify_hash>:
{
 c045eac:	b510      	push	{r4, lr}
 c045eae:	b086      	sub	sp, #24
 c045eb0:	ac04      	add	r4, sp, #16
 c045eb2:	e884 0003 	stmia.w	r4, {r0, r1}
    return psa_verify_internal(
 c045eb6:	990a      	ldr	r1, [sp, #40]	@ 0x28
 c045eb8:	9103      	str	r1, [sp, #12]
 c045eba:	9909      	ldr	r1, [sp, #36]	@ 0x24
 c045ebc:	9102      	str	r1, [sp, #8]
 c045ebe:	9908      	ldr	r1, [sp, #32]
 c045ec0:	e9cd 3100 	strd	r3, r1, [sp]
 c045ec4:	4613      	mov	r3, r2
 c045ec6:	e894 0003 	ldmia.w	r4, {r0, r1}
 c045eca:	2200      	movs	r2, #0
 c045ecc:	f7fe fc4c 	bl	c044768 <psa_verify_internal>
}
 c045ed0:	b006      	add	sp, #24
 c045ed2:	bd10      	pop	{r4, pc}

0c045ed4 <mbedcrypto__psa_asymmetric_encrypt>:
{
 c045ed4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c045ed8:	461e      	mov	r6, r3
    *output_length = 0;
 c045eda:	2300      	movs	r3, #0
{
 c045edc:	b08b      	sub	sp, #44	@ 0x2c
 c045ede:	9f19      	ldr	r7, [sp, #100]	@ 0x64
    if( ! PSA_ALG_IS_RSA_OAEP( alg ) && salt_length != 0 )
 c045ee0:	f022 0bff 	bic.w	fp, r2, #255	@ 0xff
    *output_length = 0;
 c045ee4:	603b      	str	r3, [r7, #0]
    if( ! PSA_ALG_IS_RSA_OAEP( alg ) && salt_length != 0 )
 c045ee6:	4b3f      	ldr	r3, [pc, #252]	@ (c045fe4 <mbedcrypto__psa_asymmetric_encrypt+0x110>)
{
 c045ee8:	ac06      	add	r4, sp, #24
    if( ! PSA_ALG_IS_RSA_OAEP( alg ) && salt_length != 0 )
 c045eea:	459b      	cmp	fp, r3
{
 c045eec:	4615      	mov	r5, r2
 c045eee:	e9dd 8a16 	ldrd	r8, sl, [sp, #88]	@ 0x58
 c045ef2:	e884 0003 	stmia.w	r4, {r0, r1}
 c045ef6:	f8dd 9050 	ldr.w	r9, [sp, #80]	@ 0x50
    if( ! PSA_ALG_IS_RSA_OAEP( alg ) && salt_length != 0 )
 c045efa:	d002      	beq.n	c045f02 <mbedcrypto__psa_asymmetric_encrypt+0x2e>
 c045efc:	f1b8 0f00 	cmp.w	r8, #0
 c045f00:	d16c      	bne.n	c045fdc <mbedcrypto__psa_asymmetric_encrypt+0x108>
    status = psa_get_and_lock_transparent_key_slot_with_policy(
 c045f02:	9500      	str	r5, [sp, #0]
 c045f04:	f44f 7380 	mov.w	r3, #256	@ 0x100
 c045f08:	e894 0003 	ldmia.w	r4, {r0, r1}
 c045f0c:	aa08      	add	r2, sp, #32
 c045f0e:	f7fe fc75 	bl	c0447fc <psa_get_and_lock_transparent_key_slot_with_policy>
    if( status != PSA_SUCCESS )
 c045f12:	2800      	cmp	r0, #0
 c045f14:	d13f      	bne.n	c045f96 <mbedcrypto__psa_asymmetric_encrypt+0xc2>
    if( ! ( PSA_KEY_TYPE_IS_PUBLIC_KEY( slot->attr.type ) ||
 c045f16:	9908      	ldr	r1, [sp, #32]
 c045f18:	8808      	ldrh	r0, [r1, #0]
 c045f1a:	f400 43e0 	and.w	r3, r0, #28672	@ 0x7000
 c045f1e:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
 c045f22:	d002      	beq.n	c045f2a <mbedcrypto__psa_asymmetric_encrypt+0x56>
 c045f24:	f5b3 4fe0 	cmp.w	r3, #28672	@ 0x7000
 c045f28:	d152      	bne.n	c045fd0 <mbedcrypto__psa_asymmetric_encrypt+0xfc>
    if( PSA_KEY_TYPE_IS_RSA( slot->attr.type ) )
 c045f2a:	f244 0301 	movw	r3, #16385	@ 0x4001
 c045f2e:	f420 5240 	bic.w	r2, r0, #12288	@ 0x3000
 c045f32:	429a      	cmp	r2, r3
 c045f34:	d14f      	bne.n	c045fd6 <mbedcrypto__psa_asymmetric_encrypt+0x102>
        status = mbedtls_psa_rsa_load_representation( slot->attr.type,
 c045f36:	e9d1 1209 	ldrd	r1, r2, [r1, #36]	@ 0x24
        mbedtls_rsa_context *rsa = NULL;
 c045f3a:	2300      	movs	r3, #0
 c045f3c:	9309      	str	r3, [sp, #36]	@ 0x24
        status = mbedtls_psa_rsa_load_representation( slot->attr.type,
 c045f3e:	ab09      	add	r3, sp, #36	@ 0x24
 c045f40:	f002 fc60 	bl	c048804 <mbedtls_psa_rsa_load_representation>
        if( status != PSA_SUCCESS )
 c045f44:	4604      	mov	r4, r0
 c045f46:	b9d0      	cbnz	r0, c045f7e <mbedcrypto__psa_asymmetric_encrypt+0xaa>
        if( output_size < mbedtls_rsa_get_len( rsa ) )
 c045f48:	9809      	ldr	r0, [sp, #36]	@ 0x24
 c045f4a:	f009 fb91 	bl	c04f670 <mbedtls_rsa_get_len>
 c045f4e:	9b18      	ldr	r3, [sp, #96]	@ 0x60
 c045f50:	4298      	cmp	r0, r3
 c045f52:	d837      	bhi.n	c045fc4 <mbedcrypto__psa_asymmetric_encrypt+0xf0>
        if( alg == PSA_ALG_RSA_PKCS1V15_CRYPT )
 c045f54:	4b24      	ldr	r3, [pc, #144]	@ (c045fe8 <mbedcrypto__psa_asymmetric_encrypt+0x114>)
            status = mbedtls_to_psa_error(
 c045f56:	9809      	ldr	r0, [sp, #36]	@ 0x24
        if( alg == PSA_ALG_RSA_PKCS1V15_CRYPT )
 c045f58:	429d      	cmp	r5, r3
 c045f5a:	d11f      	bne.n	c045f9c <mbedcrypto__psa_asymmetric_encrypt+0xc8>
            status = mbedtls_to_psa_error(
 c045f5c:	4623      	mov	r3, r4
 c045f5e:	e9cd 6a01 	strd	r6, sl, [sp, #4]
 c045f62:	4a22      	ldr	r2, [pc, #136]	@ (c045fec <mbedcrypto__psa_asymmetric_encrypt+0x118>)
 c045f64:	4922      	ldr	r1, [pc, #136]	@ (c045ff0 <mbedcrypto__psa_asymmetric_encrypt+0x11c>)
 c045f66:	f8cd 9000 	str.w	r9, [sp]
 c045f6a:	f009 ffd3 	bl	c04ff14 <mbedtls_rsa_pkcs1_encrypt>
            status = mbedtls_to_psa_error(
 c045f6e:	f7fe fca7 	bl	c0448c0 <mbedtls_to_psa_error>
 c045f72:	4604      	mov	r4, r0
        if( status == PSA_SUCCESS )
 c045f74:	b918      	cbnz	r0, c045f7e <mbedcrypto__psa_asymmetric_encrypt+0xaa>
            *output_length = mbedtls_rsa_get_len( rsa );
 c045f76:	9809      	ldr	r0, [sp, #36]	@ 0x24
 c045f78:	f009 fb7a 	bl	c04f670 <mbedtls_rsa_get_len>
 c045f7c:	6038      	str	r0, [r7, #0]
        mbedtls_rsa_free( rsa );
 c045f7e:	9809      	ldr	r0, [sp, #36]	@ 0x24
 c045f80:	f00a fbc2 	bl	c050708 <mbedtls_rsa_free>
        mbedtls_free( rsa );
 c045f84:	9809      	ldr	r0, [sp, #36]	@ 0x24
 c045f86:	f7f5 fa13 	bl	c03b3b0 <mbedtls_free>
    unlock_status = psa_unlock_key_slot( slot );
 c045f8a:	9808      	ldr	r0, [sp, #32]
 c045f8c:	f003 f892 	bl	c0490b4 <psa_unlock_key_slot>
    return( ( status == PSA_SUCCESS ) ? unlock_status : status );
 c045f90:	2c00      	cmp	r4, #0
 c045f92:	bf18      	it	ne
 c045f94:	4620      	movne	r0, r4
}
 c045f96:	b00b      	add	sp, #44	@ 0x2c
 c045f98:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if( PSA_ALG_IS_RSA_OAEP( alg ) )
 c045f9c:	4b11      	ldr	r3, [pc, #68]	@ (c045fe4 <mbedcrypto__psa_asymmetric_encrypt+0x110>)
 c045f9e:	459b      	cmp	fp, r3
 c045fa0:	d113      	bne.n	c045fca <mbedcrypto__psa_asymmetric_encrypt+0xf6>
            psa_rsa_oaep_set_padding_mode( alg, rsa );
 c045fa2:	4601      	mov	r1, r0
 c045fa4:	4628      	mov	r0, r5
 c045fa6:	f7fe fa6d 	bl	c044484 <psa_rsa_oaep_set_padding_mode>
            status = mbedtls_to_psa_error(
 c045faa:	9b15      	ldr	r3, [sp, #84]	@ 0x54
 c045fac:	e9cd 6a03 	strd	r6, sl, [sp, #12]
 c045fb0:	9300      	str	r3, [sp, #0]
 c045fb2:	e9cd 8901 	strd	r8, r9, [sp, #4]
 c045fb6:	4623      	mov	r3, r4
 c045fb8:	4a0c      	ldr	r2, [pc, #48]	@ (c045fec <mbedcrypto__psa_asymmetric_encrypt+0x118>)
 c045fba:	490d      	ldr	r1, [pc, #52]	@ (c045ff0 <mbedcrypto__psa_asymmetric_encrypt+0x11c>)
 c045fbc:	9809      	ldr	r0, [sp, #36]	@ 0x24
 c045fbe:	f009 fea1 	bl	c04fd04 <mbedtls_rsa_rsaes_oaep_encrypt>
 c045fc2:	e7d4      	b.n	c045f6e <mbedcrypto__psa_asymmetric_encrypt+0x9a>
            status = PSA_ERROR_BUFFER_TOO_SMALL;
 c045fc4:	f06f 0489 	mvn.w	r4, #137	@ 0x89
 c045fc8:	e7d9      	b.n	c045f7e <mbedcrypto__psa_asymmetric_encrypt+0xaa>
            status = PSA_ERROR_INVALID_ARGUMENT;
 c045fca:	f06f 0486 	mvn.w	r4, #134	@ 0x86
 c045fce:	e7d6      	b.n	c045f7e <mbedcrypto__psa_asymmetric_encrypt+0xaa>
        status = PSA_ERROR_INVALID_ARGUMENT;
 c045fd0:	f06f 0486 	mvn.w	r4, #134	@ 0x86
 c045fd4:	e7d9      	b.n	c045f8a <mbedcrypto__psa_asymmetric_encrypt+0xb6>
        status = PSA_ERROR_NOT_SUPPORTED;
 c045fd6:	f06f 0485 	mvn.w	r4, #133	@ 0x85
 c045fda:	e7d6      	b.n	c045f8a <mbedcrypto__psa_asymmetric_encrypt+0xb6>
        return( PSA_ERROR_INVALID_ARGUMENT );
 c045fdc:	f06f 0086 	mvn.w	r0, #134	@ 0x86
 c045fe0:	e7d9      	b.n	c045f96 <mbedcrypto__psa_asymmetric_encrypt+0xc2>
 c045fe2:	bf00      	nop
 c045fe4:	07000300 	.word	0x07000300
 c045fe8:	07000200 	.word	0x07000200
 c045fec:	30031188 	.word	0x30031188
 c045ff0:	0c055d65 	.word	0x0c055d65

0c045ff4 <mbedcrypto__psa_asymmetric_decrypt>:
{
 c045ff4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c045ff8:	461e      	mov	r6, r3
    *output_length = 0;
 c045ffa:	2300      	movs	r3, #0
{
 c045ffc:	b08b      	sub	sp, #44	@ 0x2c
 c045ffe:	e9dd a718 	ldrd	sl, r7, [sp, #96]	@ 0x60
    *output_length = 0;
 c046002:	603b      	str	r3, [r7, #0]
    if( ! PSA_ALG_IS_RSA_OAEP( alg ) && salt_length != 0 )
 c046004:	4b39      	ldr	r3, [pc, #228]	@ (c0460ec <mbedcrypto__psa_asymmetric_decrypt+0xf8>)
 c046006:	f022 0bff 	bic.w	fp, r2, #255	@ 0xff
{
 c04600a:	ac06      	add	r4, sp, #24
    if( ! PSA_ALG_IS_RSA_OAEP( alg ) && salt_length != 0 )
 c04600c:	459b      	cmp	fp, r3
{
 c04600e:	4615      	mov	r5, r2
 c046010:	e9dd 8916 	ldrd	r8, r9, [sp, #88]	@ 0x58
 c046014:	e884 0003 	stmia.w	r4, {r0, r1}
    if( ! PSA_ALG_IS_RSA_OAEP( alg ) && salt_length != 0 )
 c046018:	d002      	beq.n	c046020 <mbedcrypto__psa_asymmetric_decrypt+0x2c>
 c04601a:	f1b8 0f00 	cmp.w	r8, #0
 c04601e:	d161      	bne.n	c0460e4 <mbedcrypto__psa_asymmetric_decrypt+0xf0>
    status = psa_get_and_lock_transparent_key_slot_with_policy(
 c046020:	9500      	str	r5, [sp, #0]
 c046022:	f44f 7300 	mov.w	r3, #512	@ 0x200
 c046026:	e894 0003 	ldmia.w	r4, {r0, r1}
 c04602a:	aa08      	add	r2, sp, #32
 c04602c:	f7fe fbe6 	bl	c0447fc <psa_get_and_lock_transparent_key_slot_with_policy>
    if( status != PSA_SUCCESS )
 c046030:	2800      	cmp	r0, #0
 c046032:	d135      	bne.n	c0460a0 <mbedcrypto__psa_asymmetric_decrypt+0xac>
    if( ! PSA_KEY_TYPE_IS_KEY_PAIR( slot->attr.type ) )
 c046034:	9908      	ldr	r1, [sp, #32]
 c046036:	880c      	ldrh	r4, [r1, #0]
 c046038:	f404 43e0 	and.w	r3, r4, #28672	@ 0x7000
 c04603c:	f5b3 4fe0 	cmp.w	r3, #28672	@ 0x7000
 c046040:	d14a      	bne.n	c0460d8 <mbedcrypto__psa_asymmetric_decrypt+0xe4>
    if( slot->attr.type == PSA_KEY_TYPE_RSA_KEY_PAIR )
 c046042:	f247 0301 	movw	r3, #28673	@ 0x7001
 c046046:	429c      	cmp	r4, r3
 c046048:	d149      	bne.n	c0460de <mbedcrypto__psa_asymmetric_decrypt+0xea>
        status = mbedtls_psa_rsa_load_representation( slot->attr.type,
 c04604a:	e9d1 1209 	ldrd	r1, r2, [r1, #36]	@ 0x24
        mbedtls_rsa_context *rsa = NULL;
 c04604e:	9009      	str	r0, [sp, #36]	@ 0x24
        status = mbedtls_psa_rsa_load_representation( slot->attr.type,
 c046050:	ab09      	add	r3, sp, #36	@ 0x24
 c046052:	4620      	mov	r0, r4
 c046054:	f002 fbd6 	bl	c048804 <mbedtls_psa_rsa_load_representation>
        if( status != PSA_SUCCESS )
 c046058:	4604      	mov	r4, r0
 c04605a:	b9d8      	cbnz	r0, c046094 <mbedcrypto__psa_asymmetric_decrypt+0xa0>
        if( input_length != mbedtls_rsa_get_len( rsa ) )
 c04605c:	9809      	ldr	r0, [sp, #36]	@ 0x24
 c04605e:	f009 fb07 	bl	c04f670 <mbedtls_rsa_get_len>
 c046062:	9b14      	ldr	r3, [sp, #80]	@ 0x50
 c046064:	4298      	cmp	r0, r3
 c046066:	d134      	bne.n	c0460d2 <mbedcrypto__psa_asymmetric_decrypt+0xde>
        if( alg == PSA_ALG_RSA_PKCS1V15_CRYPT )
 c046068:	4b21      	ldr	r3, [pc, #132]	@ (c0460f0 <mbedcrypto__psa_asymmetric_decrypt+0xfc>)
            status = mbedtls_to_psa_error(
 c04606a:	9809      	ldr	r0, [sp, #36]	@ 0x24
        if( alg == PSA_ALG_RSA_PKCS1V15_CRYPT )
 c04606c:	429d      	cmp	r5, r3
 c04606e:	d11a      	bne.n	c0460a6 <mbedcrypto__psa_asymmetric_decrypt+0xb2>
            status = mbedtls_to_psa_error(
 c046070:	2301      	movs	r3, #1
 c046072:	e9cd 9a02 	strd	r9, sl, [sp, #8]
 c046076:	e9cd 7600 	strd	r7, r6, [sp]
 c04607a:	4a1e      	ldr	r2, [pc, #120]	@ (c0460f4 <mbedcrypto__psa_asymmetric_decrypt+0x100>)
 c04607c:	491e      	ldr	r1, [pc, #120]	@ (c0460f8 <mbedcrypto__psa_asymmetric_decrypt+0x104>)
 c04607e:	f00a f909 	bl	c050294 <mbedtls_rsa_pkcs1_decrypt>
            status = mbedtls_to_psa_error(
 c046082:	f7fe fc1d 	bl	c0448c0 <mbedtls_to_psa_error>
 c046086:	4604      	mov	r4, r0
        mbedtls_rsa_free( rsa );
 c046088:	9809      	ldr	r0, [sp, #36]	@ 0x24
 c04608a:	f00a fb3d 	bl	c050708 <mbedtls_rsa_free>
        mbedtls_free( rsa );
 c04608e:	9809      	ldr	r0, [sp, #36]	@ 0x24
 c046090:	f7f5 f98e 	bl	c03b3b0 <mbedtls_free>
    unlock_status = psa_unlock_key_slot( slot );
 c046094:	9808      	ldr	r0, [sp, #32]
 c046096:	f003 f80d 	bl	c0490b4 <psa_unlock_key_slot>
    return( ( status == PSA_SUCCESS ) ? unlock_status : status );
 c04609a:	2c00      	cmp	r4, #0
 c04609c:	bf18      	it	ne
 c04609e:	4620      	movne	r0, r4
}
 c0460a0:	b00b      	add	sp, #44	@ 0x2c
 c0460a2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if( PSA_ALG_IS_RSA_OAEP( alg ) )
 c0460a6:	4b11      	ldr	r3, [pc, #68]	@ (c0460ec <mbedcrypto__psa_asymmetric_decrypt+0xf8>)
 c0460a8:	459b      	cmp	fp, r3
 c0460aa:	d112      	bne.n	c0460d2 <mbedcrypto__psa_asymmetric_decrypt+0xde>
            psa_rsa_oaep_set_padding_mode( alg, rsa );
 c0460ac:	4601      	mov	r1, r0
 c0460ae:	4628      	mov	r0, r5
 c0460b0:	f7fe f9e8 	bl	c044484 <psa_rsa_oaep_set_padding_mode>
            status = mbedtls_to_psa_error(
 c0460b4:	9b15      	ldr	r3, [sp, #84]	@ 0x54
 c0460b6:	e9cd 9a04 	strd	r9, sl, [sp, #16]
 c0460ba:	9300      	str	r3, [sp, #0]
 c0460bc:	e9cd 7602 	strd	r7, r6, [sp, #8]
 c0460c0:	2301      	movs	r3, #1
 c0460c2:	4a0c      	ldr	r2, [pc, #48]	@ (c0460f4 <mbedcrypto__psa_asymmetric_decrypt+0x100>)
 c0460c4:	490c      	ldr	r1, [pc, #48]	@ (c0460f8 <mbedcrypto__psa_asymmetric_decrypt+0x104>)
 c0460c6:	9809      	ldr	r0, [sp, #36]	@ 0x24
 c0460c8:	f8cd 8004 	str.w	r8, [sp, #4]
 c0460cc:	f009 ff42 	bl	c04ff54 <mbedtls_rsa_rsaes_oaep_decrypt>
 c0460d0:	e7d7      	b.n	c046082 <mbedcrypto__psa_asymmetric_decrypt+0x8e>
            status = PSA_ERROR_INVALID_ARGUMENT;
 c0460d2:	f06f 0486 	mvn.w	r4, #134	@ 0x86
 c0460d6:	e7d7      	b.n	c046088 <mbedcrypto__psa_asymmetric_decrypt+0x94>
        status = PSA_ERROR_INVALID_ARGUMENT;
 c0460d8:	f06f 0486 	mvn.w	r4, #134	@ 0x86
 c0460dc:	e7da      	b.n	c046094 <mbedcrypto__psa_asymmetric_decrypt+0xa0>
        status = PSA_ERROR_NOT_SUPPORTED;
 c0460de:	f06f 0485 	mvn.w	r4, #133	@ 0x85
 c0460e2:	e7d7      	b.n	c046094 <mbedcrypto__psa_asymmetric_decrypt+0xa0>
        return( PSA_ERROR_INVALID_ARGUMENT );
 c0460e4:	f06f 0086 	mvn.w	r0, #134	@ 0x86
 c0460e8:	e7da      	b.n	c0460a0 <mbedcrypto__psa_asymmetric_decrypt+0xac>
 c0460ea:	bf00      	nop
 c0460ec:	07000300 	.word	0x07000300
 c0460f0:	07000200 	.word	0x07000200
 c0460f4:	30031188 	.word	0x30031188
 c0460f8:	0c055d65 	.word	0x0c055d65

0c0460fc <mbedcrypto__psa_cipher_abort>:
    if( operation->id == 0 )
 c0460fc:	6803      	ldr	r3, [r0, #0]
{
 c0460fe:	b510      	push	{r4, lr}
 c046100:	4604      	mov	r4, r0
    if( operation->id == 0 )
 c046102:	b13b      	cbz	r3, c046114 <mbedcrypto__psa_cipher_abort+0x18>
    psa_driver_wrapper_cipher_abort( operation );
 c046104:	f001 fcd8 	bl	c047ab8 <psa_driver_wrapper_cipher_abort>
    operation->id = 0;
 c046108:	2300      	movs	r3, #0
 c04610a:	6023      	str	r3, [r4, #0]
    operation->iv_required = 0;
 c04610c:	7923      	ldrb	r3, [r4, #4]
 c04610e:	f023 0303 	bic.w	r3, r3, #3
 c046112:	7123      	strb	r3, [r4, #4]
}
 c046114:	2000      	movs	r0, #0
 c046116:	bd10      	pop	{r4, pc}

0c046118 <psa_cipher_setup>:
{
 c046118:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 c04611c:	4607      	mov	r7, r0
 c04611e:	461d      	mov	r5, r3
    psa_key_slot_t *slot = NULL;
 c046120:	2300      	movs	r3, #0
{
 c046122:	b092      	sub	sp, #72	@ 0x48
 c046124:	f99d 8060 	ldrsb.w	r8, [sp, #96]	@ 0x60
 c046128:	a802      	add	r0, sp, #8
 c04612a:	e880 0006 	stmia.w	r0, {r1, r2}
    if( operation->id != 0 )
 c04612e:	683a      	ldr	r2, [r7, #0]
                              PSA_KEY_USAGE_ENCRYPT :
 c046130:	f1b8 0f01 	cmp.w	r8, #1
    psa_key_slot_t *slot = NULL;
 c046134:	9305      	str	r3, [sp, #20]
                              PSA_KEY_USAGE_ENCRYPT :
 c046136:	bf0c      	ite	eq
 c046138:	f44f 7380 	moveq.w	r3, #256	@ 0x100
 c04613c:	f44f 7300 	movne.w	r3, #512	@ 0x200
    if( operation->id != 0 )
 c046140:	2a00      	cmp	r2, #0
 c046142:	d166      	bne.n	c046212 <psa_cipher_setup+0xfa>
    if( ! PSA_ALG_IS_CIPHER( alg ) )
 c046144:	f005 42fe 	and.w	r2, r5, #2130706432	@ 0x7f000000
 c046148:	f1b2 6f80 	cmp.w	r2, #67108864	@ 0x4000000
 c04614c:	d164      	bne.n	c046218 <psa_cipher_setup+0x100>
    status = psa_get_and_lock_key_slot_with_policy( key, &slot, usage, alg );
 c04614e:	9500      	str	r5, [sp, #0]
 c046150:	aa05      	add	r2, sp, #20
 c046152:	c803      	ldmia	r0, {r0, r1}
 c046154:	f7fe fa18 	bl	c044588 <psa_get_and_lock_key_slot_with_policy>
    if( status != PSA_SUCCESS )
 c046158:	4604      	mov	r4, r0
 c04615a:	2800      	cmp	r0, #0
 c04615c:	d13e      	bne.n	c0461dc <psa_cipher_setup+0xc4>
    operation->iv_set = 0;
 c04615e:	793b      	ldrb	r3, [r7, #4]
 c046160:	4a2f      	ldr	r2, [pc, #188]	@ (c046220 <psa_cipher_setup+0x108>)
 c046162:	f023 0303 	bic.w	r3, r3, #3
 c046166:	4295      	cmp	r5, r2
 c046168:	bf18      	it	ne
 c04616a:	f043 0301 	orrne.w	r3, r3, #1
    operation->default_iv_length = PSA_CIPHER_IV_LENGTH( slot->attr.type, alg );
 c04616e:	f8dd c014 	ldr.w	ip, [sp, #20]
    operation->iv_set = 0;
 c046172:	713b      	strb	r3, [r7, #4]
    operation->default_iv_length = PSA_CIPHER_IV_LENGTH( slot->attr.type, alg );
 c046174:	f8bc 3000 	ldrh.w	r3, [ip]
 c046178:	f403 42e0 	and.w	r2, r3, #28672	@ 0x7000
 c04617c:	f5b2 5f00 	cmp.w	r2, #8192	@ 0x2000
 c046180:	d138      	bne.n	c0461f4 <psa_cipher_setup+0xdc>
 c046182:	f413 6fe0 	tst.w	r3, #1792	@ 0x700
 c046186:	f3c3 2102 	ubfx	r1, r3, #8, #3
 c04618a:	d033      	beq.n	c0461f4 <psa_cipher_setup+0xdc>
 c04618c:	4825      	ldr	r0, [pc, #148]	@ (c046224 <psa_cipher_setup+0x10c>)
 c04618e:	f425 7280 	bic.w	r2, r5, #256	@ 0x100
 c046192:	4282      	cmp	r2, r0
 c046194:	d00a      	beq.n	c0461ac <psa_cipher_setup+0x94>
 c046196:	f500 7000 	add.w	r0, r0, #512	@ 0x200
 c04619a:	4285      	cmp	r5, r0
 c04619c:	d006      	beq.n	c0461ac <psa_cipher_setup+0x94>
 c04619e:	4822      	ldr	r0, [pc, #136]	@ (c046228 <psa_cipher_setup+0x110>)
 c0461a0:	4285      	cmp	r5, r0
 c0461a2:	d003      	beq.n	c0461ac <psa_cipher_setup+0x94>
 c0461a4:	f5a0 403f 	sub.w	r0, r0, #48896	@ 0xbf00
 c0461a8:	4282      	cmp	r2, r0
 c0461aa:	d123      	bne.n	c0461f4 <psa_cipher_setup+0xdc>
 c0461ac:	2301      	movs	r3, #1
 c0461ae:	408b      	lsls	r3, r1
 c0461b0:	b2db      	uxtb	r3, r3
    attributes.core = slot->attr;
 c0461b2:	4666      	mov	r6, ip
    operation->default_iv_length = PSA_CIPHER_IV_LENGTH( slot->attr.type, alg );
 c0461b4:	717b      	strb	r3, [r7, #5]
    attributes.core = slot->attr;
 c0461b6:	ac06      	add	r4, sp, #24
 c0461b8:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 c0461ba:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 c0461bc:	e896 000f 	ldmia.w	r6, {r0, r1, r2, r3}
    if( cipher_operation == MBEDTLS_ENCRYPT )
 c0461c0:	f1b8 0f01 	cmp.w	r8, #1
    attributes.core = slot->attr;
 c0461c4:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
        status = psa_driver_wrapper_cipher_encrypt_setup( operation,
 c0461c8:	e9dc 2309 	ldrd	r2, r3, [ip, #36]	@ 0x24
 c0461cc:	4638      	mov	r0, r7
 c0461ce:	9500      	str	r5, [sp, #0]
 c0461d0:	a906      	add	r1, sp, #24
    if( cipher_operation == MBEDTLS_ENCRYPT )
 c0461d2:	d11b      	bne.n	c04620c <psa_cipher_setup+0xf4>
        status = psa_driver_wrapper_cipher_encrypt_setup( operation,
 c0461d4:	f001 fc25 	bl	c047a22 <psa_driver_wrapper_cipher_encrypt_setup>
        status = psa_driver_wrapper_cipher_decrypt_setup( operation,
 c0461d8:	4604      	mov	r4, r0
    if( status != PSA_SUCCESS )
 c0461da:	b110      	cbz	r0, c0461e2 <psa_cipher_setup+0xca>
        psa_cipher_abort( operation );
 c0461dc:	4638      	mov	r0, r7
 c0461de:	f7ff ff8d 	bl	c0460fc <mbedcrypto__psa_cipher_abort>
    unlock_status = psa_unlock_key_slot( slot );
 c0461e2:	9805      	ldr	r0, [sp, #20]
 c0461e4:	f002 ff66 	bl	c0490b4 <psa_unlock_key_slot>
}
 c0461e8:	2c00      	cmp	r4, #0
 c0461ea:	bf18      	it	ne
 c0461ec:	4620      	movne	r0, r4
 c0461ee:	b012      	add	sp, #72	@ 0x48
 c0461f0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    operation->default_iv_length = PSA_CIPHER_IV_LENGTH( slot->attr.type, alg );
 c0461f4:	f242 0204 	movw	r2, #8196	@ 0x2004
 c0461f8:	4293      	cmp	r3, r2
 c0461fa:	d105      	bne.n	c046208 <psa_cipher_setup+0xf0>
 c0461fc:	4b0b      	ldr	r3, [pc, #44]	@ (c04622c <psa_cipher_setup+0x114>)
 c0461fe:	429d      	cmp	r5, r3
 c046200:	bf0c      	ite	eq
 c046202:	230c      	moveq	r3, #12
 c046204:	2300      	movne	r3, #0
 c046206:	e7d4      	b.n	c0461b2 <psa_cipher_setup+0x9a>
 c046208:	2300      	movs	r3, #0
 c04620a:	e7d2      	b.n	c0461b2 <psa_cipher_setup+0x9a>
        status = psa_driver_wrapper_cipher_decrypt_setup( operation,
 c04620c:	f001 fc1c 	bl	c047a48 <psa_driver_wrapper_cipher_decrypt_setup>
 c046210:	e7e2      	b.n	c0461d8 <psa_cipher_setup+0xc0>
        status = PSA_ERROR_BAD_STATE;
 c046212:	f06f 0488 	mvn.w	r4, #136	@ 0x88
 c046216:	e7e1      	b.n	c0461dc <psa_cipher_setup+0xc4>
        status = PSA_ERROR_INVALID_ARGUMENT;
 c046218:	f06f 0486 	mvn.w	r4, #134	@ 0x86
 c04621c:	e7de      	b.n	c0461dc <psa_cipher_setup+0xc4>
 c04621e:	bf00      	nop
 c046220:	04404400 	.word	0x04404400
 c046224:	04c01000 	.word	0x04c01000
 c046228:	0440ff00 	.word	0x0440ff00
 c04622c:	04800100 	.word	0x04800100

0c046230 <mbedcrypto__psa_cipher_encrypt_setup>:
{
 c046230:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 c046232:	ac02      	add	r4, sp, #8
 c046234:	e884 0006 	stmia.w	r4, {r1, r2}
    return( psa_cipher_setup( operation, key, alg, MBEDTLS_ENCRYPT ) );
 c046238:	2201      	movs	r2, #1
 c04623a:	9200      	str	r2, [sp, #0]
 c04623c:	e894 0006 	ldmia.w	r4, {r1, r2}
 c046240:	f7ff ff6a 	bl	c046118 <psa_cipher_setup>
}
 c046244:	b004      	add	sp, #16
 c046246:	bd10      	pop	{r4, pc}

0c046248 <mbedcrypto__psa_cipher_decrypt_setup>:
{
 c046248:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 c04624a:	ac02      	add	r4, sp, #8
 c04624c:	e884 0006 	stmia.w	r4, {r1, r2}
    return( psa_cipher_setup( operation, key, alg, MBEDTLS_DECRYPT ) );
 c046250:	2200      	movs	r2, #0
 c046252:	9200      	str	r2, [sp, #0]
 c046254:	e894 0006 	ldmia.w	r4, {r1, r2}
 c046258:	f7ff ff5e 	bl	c046118 <psa_cipher_setup>
}
 c04625c:	b004      	add	sp, #16
 c04625e:	bd10      	pop	{r4, pc}

0c046260 <mbedcrypto__psa_cipher_set_iv>:
{
 c046260:	b538      	push	{r3, r4, r5, lr}
    if( operation->id == 0 )
 c046262:	6804      	ldr	r4, [r0, #0]
{
 c046264:	4605      	mov	r5, r0
    if( operation->id == 0 )
 c046266:	b184      	cbz	r4, c04628a <mbedcrypto__psa_cipher_set_iv+0x2a>
    if( operation->iv_set || ! operation->iv_required )
 c046268:	7904      	ldrb	r4, [r0, #4]
 c04626a:	f004 0403 	and.w	r4, r4, #3
 c04626e:	2c01      	cmp	r4, #1
 c046270:	d10b      	bne.n	c04628a <mbedcrypto__psa_cipher_set_iv+0x2a>
    if( iv_length > PSA_CIPHER_IV_MAX_SIZE )
 c046272:	2a10      	cmp	r2, #16
 c046274:	d80f      	bhi.n	c046296 <mbedcrypto__psa_cipher_set_iv+0x36>
    status = psa_driver_wrapper_cipher_set_iv( operation,
 c046276:	f001 fbfa 	bl	c047a6e <psa_driver_wrapper_cipher_set_iv>
    if( status == PSA_SUCCESS )
 c04627a:	4604      	mov	r4, r0
 c04627c:	b938      	cbnz	r0, c04628e <mbedcrypto__psa_cipher_set_iv+0x2e>
        operation->iv_set = 1;
 c04627e:	792b      	ldrb	r3, [r5, #4]
 c046280:	f043 0302 	orr.w	r3, r3, #2
 c046284:	712b      	strb	r3, [r5, #4]
}
 c046286:	4620      	mov	r0, r4
 c046288:	bd38      	pop	{r3, r4, r5, pc}
        status = PSA_ERROR_BAD_STATE;
 c04628a:	f06f 0488 	mvn.w	r4, #136	@ 0x88
        psa_cipher_abort( operation );
 c04628e:	4628      	mov	r0, r5
 c046290:	f7ff ff34 	bl	c0460fc <mbedcrypto__psa_cipher_abort>
    return( status );
 c046294:	e7f7      	b.n	c046286 <mbedcrypto__psa_cipher_set_iv+0x26>
        status = PSA_ERROR_INVALID_ARGUMENT;
 c046296:	f06f 0486 	mvn.w	r4, #134	@ 0x86
 c04629a:	e7f8      	b.n	c04628e <mbedcrypto__psa_cipher_set_iv+0x2e>

0c04629c <mbedcrypto__psa_cipher_update>:
{
 c04629c:	b537      	push	{r0, r1, r2, r4, r5, lr}
    if( operation->id == 0 )
 c04629e:	6804      	ldr	r4, [r0, #0]
{
 c0462a0:	4605      	mov	r5, r0
    if( operation->id == 0 )
 c0462a2:	b194      	cbz	r4, c0462ca <mbedcrypto__psa_cipher_update+0x2e>
    if( operation->iv_required && ! operation->iv_set )
 c0462a4:	7904      	ldrb	r4, [r0, #4]
 c0462a6:	f004 0403 	and.w	r4, r4, #3
 c0462aa:	2c01      	cmp	r4, #1
 c0462ac:	d00d      	beq.n	c0462ca <mbedcrypto__psa_cipher_update+0x2e>
    status = psa_driver_wrapper_cipher_update( operation,
 c0462ae:	9c07      	ldr	r4, [sp, #28]
 c0462b0:	9401      	str	r4, [sp, #4]
 c0462b2:	9c06      	ldr	r4, [sp, #24]
 c0462b4:	9400      	str	r4, [sp, #0]
 c0462b6:	f001 fbe3 	bl	c047a80 <psa_driver_wrapper_cipher_update>
    if( status != PSA_SUCCESS )
 c0462ba:	4604      	mov	r4, r0
 c0462bc:	b110      	cbz	r0, c0462c4 <mbedcrypto__psa_cipher_update+0x28>
        psa_cipher_abort( operation );
 c0462be:	4628      	mov	r0, r5
 c0462c0:	f7ff ff1c 	bl	c0460fc <mbedcrypto__psa_cipher_abort>
}
 c0462c4:	4620      	mov	r0, r4
 c0462c6:	b003      	add	sp, #12
 c0462c8:	bd30      	pop	{r4, r5, pc}
        status = PSA_ERROR_BAD_STATE;
 c0462ca:	f06f 0488 	mvn.w	r4, #136	@ 0x88
 c0462ce:	e7f6      	b.n	c0462be <mbedcrypto__psa_cipher_update+0x22>

0c0462d0 <mbedcrypto__psa_cipher_finish>:
{
 c0462d0:	b570      	push	{r4, r5, r6, lr}
    if( operation->id == 0 )
 c0462d2:	6804      	ldr	r4, [r0, #0]
{
 c0462d4:	4605      	mov	r5, r0
 c0462d6:	461e      	mov	r6, r3
    if( operation->id == 0 )
 c0462d8:	b16c      	cbz	r4, c0462f6 <mbedcrypto__psa_cipher_finish+0x26>
    if( operation->iv_required && ! operation->iv_set )
 c0462da:	7904      	ldrb	r4, [r0, #4]
 c0462dc:	f004 0403 	and.w	r4, r4, #3
 c0462e0:	2c01      	cmp	r4, #1
 c0462e2:	d008      	beq.n	c0462f6 <mbedcrypto__psa_cipher_finish+0x26>
    status = psa_driver_wrapper_cipher_finish( operation,
 c0462e4:	f001 fbdc 	bl	c047aa0 <psa_driver_wrapper_cipher_finish>
    if( status == PSA_SUCCESS )
 c0462e8:	4604      	mov	r4, r0
 c0462ea:	b930      	cbnz	r0, c0462fa <mbedcrypto__psa_cipher_finish+0x2a>
        return( psa_cipher_abort( operation ) );
 c0462ec:	4628      	mov	r0, r5
}
 c0462ee:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        return( psa_cipher_abort( operation ) );
 c0462f2:	f7ff bf03 	b.w	c0460fc <mbedcrypto__psa_cipher_abort>
        status = PSA_ERROR_BAD_STATE;
 c0462f6:	f06f 0488 	mvn.w	r4, #136	@ 0x88
        *output_length = 0;
 c0462fa:	2300      	movs	r3, #0
        (void) psa_cipher_abort( operation );
 c0462fc:	4628      	mov	r0, r5
        *output_length = 0;
 c0462fe:	6033      	str	r3, [r6, #0]
        (void) psa_cipher_abort( operation );
 c046300:	f7ff fefc 	bl	c0460fc <mbedcrypto__psa_cipher_abort>
}
 c046304:	4620      	mov	r0, r4
 c046306:	bd70      	pop	{r4, r5, r6, pc}

0c046308 <mbedcrypto__psa_aead_encrypt>:
{
 c046308:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 c04630c:	461f      	mov	r7, r3
    *ciphertext_length = 0;
 c04630e:	2300      	movs	r3, #0
{
 c046310:	b09b      	sub	sp, #108	@ 0x6c
 c046312:	f8dd 90a4 	ldr.w	r9, [sp, #164]	@ 0xa4
 c046316:	ac0a      	add	r4, sp, #40	@ 0x28
    *ciphertext_length = 0;
 c046318:	f8c9 3000 	str.w	r3, [r9]
    if( !PSA_ALG_IS_AEAD( alg ) || PSA_ALG_IS_WILDCARD( alg ) )
 c04631c:	f002 43fe 	and.w	r3, r2, #2130706432	@ 0x7f000000
 c046320:	f1b3 6fa0 	cmp.w	r3, #83886080	@ 0x5000000
{
 c046324:	4615      	mov	r5, r2
 c046326:	e9dd 8627 	ldrd	r8, r6, [sp, #156]	@ 0x9c
 c04632a:	e884 0003 	stmia.w	r4, {r0, r1}
    if( !PSA_ALG_IS_AEAD( alg ) || PSA_ALG_IS_WILDCARD( alg ) )
 c04632e:	d12f      	bne.n	c046390 <mbedcrypto__psa_aead_encrypt+0x88>
 c046330:	4939      	ldr	r1, [pc, #228]	@ (c046418 <mbedcrypto__psa_aead_encrypt+0x110>)
 c046332:	f022 03ff 	bic.w	r3, r2, #255	@ 0xff
 c046336:	f422 72ff 	bic.w	r2, r2, #510	@ 0x1fe
 c04633a:	f022 0201 	bic.w	r2, r2, #1
 c04633e:	428a      	cmp	r2, r1
 c046340:	d00d      	beq.n	c04635e <mbedcrypto__psa_aead_encrypt+0x56>
 c046342:	f501 5188 	add.w	r1, r1, #4352	@ 0x1100
 c046346:	428b      	cmp	r3, r1
 c046348:	d009      	beq.n	c04635e <mbedcrypto__psa_aead_encrypt+0x56>
 c04634a:	4834      	ldr	r0, [pc, #208]	@ (c04641c <mbedcrypto__psa_aead_encrypt+0x114>)
 c04634c:	f425 717f 	bic.w	r1, r5, #1020	@ 0x3fc
 c046350:	f021 0103 	bic.w	r1, r1, #3
 c046354:	4281      	cmp	r1, r0
 c046356:	d002      	beq.n	c04635e <mbedcrypto__psa_aead_encrypt+0x56>
 c046358:	4931      	ldr	r1, [pc, #196]	@ (c046420 <mbedcrypto__psa_aead_encrypt+0x118>)
 c04635a:	428b      	cmp	r3, r1
 c04635c:	d11b      	bne.n	c046396 <mbedcrypto__psa_aead_encrypt+0x8e>
 c04635e:	f015 01ff 	ands.w	r1, r5, #255	@ 0xff
 c046362:	d018      	beq.n	c046396 <mbedcrypto__psa_aead_encrypt+0x8e>
 c046364:	482c      	ldr	r0, [pc, #176]	@ (c046418 <mbedcrypto__psa_aead_encrypt+0x110>)
 c046366:	4282      	cmp	r2, r0
 c046368:	d00d      	beq.n	c046386 <mbedcrypto__psa_aead_encrypt+0x7e>
 c04636a:	4a2e      	ldr	r2, [pc, #184]	@ (c046424 <mbedcrypto__psa_aead_encrypt+0x11c>)
 c04636c:	4293      	cmp	r3, r2
 c04636e:	d00a      	beq.n	c046386 <mbedcrypto__psa_aead_encrypt+0x7e>
 c046370:	f425 727f 	bic.w	r2, r5, #1020	@ 0x3fc
 c046374:	f022 0203 	bic.w	r2, r2, #3
 c046378:	f500 7000 	add.w	r0, r0, #512	@ 0x200
 c04637c:	4282      	cmp	r2, r0
 c04637e:	d002      	beq.n	c046386 <mbedcrypto__psa_aead_encrypt+0x7e>
 c046380:	4a27      	ldr	r2, [pc, #156]	@ (c046420 <mbedcrypto__psa_aead_encrypt+0x118>)
 c046382:	4293      	cmp	r3, r2
 c046384:	d109      	bne.n	c04639a <mbedcrypto__psa_aead_encrypt+0x92>
 c046386:	4a28      	ldr	r2, [pc, #160]	@ (c046428 <mbedcrypto__psa_aead_encrypt+0x120>)
 c046388:	f041 7300 	orr.w	r3, r1, #33554432	@ 0x2000000
 c04638c:	4293      	cmp	r3, r2
 c04638e:	d104      	bne.n	c04639a <mbedcrypto__psa_aead_encrypt+0x92>
        return( PSA_ERROR_NOT_SUPPORTED );
 c046390:	f06f 0485 	mvn.w	r4, #133	@ 0x85
 c046394:	e03b      	b.n	c04640e <mbedcrypto__psa_aead_encrypt+0x106>
    if( !PSA_ALG_IS_AEAD( alg ) || PSA_ALG_IS_WILDCARD( alg ) )
 c046396:	042b      	lsls	r3, r5, #16
 c046398:	d4fa      	bmi.n	c046390 <mbedcrypto__psa_aead_encrypt+0x88>
    status = psa_get_and_lock_key_slot_with_policy(
 c04639a:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	@ 0x28
 c04639e:	f44f 7380 	mov.w	r3, #256	@ 0x100
 c0463a2:	9500      	str	r5, [sp, #0]
 c0463a4:	aa0d      	add	r2, sp, #52	@ 0x34
 c0463a6:	f7fe f8ef 	bl	c044588 <psa_get_and_lock_key_slot_with_policy>
    if( status != PSA_SUCCESS )
 c0463aa:	4604      	mov	r4, r0
 c0463ac:	bb78      	cbnz	r0, c04640e <mbedcrypto__psa_aead_encrypt+0x106>
    psa_key_attributes_t attributes = {
 c0463ae:	4601      	mov	r1, r0
 c0463b0:	2210      	movs	r2, #16
 c0463b2:	a816      	add	r0, sp, #88	@ 0x58
 c0463b4:	f015 f9bb 	bl	c05b72e <memset>
      .core = slot->attr
 c0463b8:	f8dd e034 	ldr.w	lr, [sp, #52]	@ 0x34
    psa_key_attributes_t attributes = {
 c0463bc:	ac0e      	add	r4, sp, #56	@ 0x38
 c0463be:	46f4      	mov	ip, lr
 c0463c0:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 c0463c4:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 c0463c6:	e89c 000f 	ldmia.w	ip, {r0, r1, r2, r3}
 c0463ca:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
    status = psa_driver_wrapper_aead_encrypt(
 c0463ce:	9b26      	ldr	r3, [sp, #152]	@ 0x98
 c0463d0:	e9cd 6907 	strd	r6, r9, [sp, #28]
 c0463d4:	9305      	str	r3, [sp, #20]
 c0463d6:	9b25      	ldr	r3, [sp, #148]	@ 0x94
 c0463d8:	f8cd 8018 	str.w	r8, [sp, #24]
 c0463dc:	9304      	str	r3, [sp, #16]
 c0463de:	9b24      	ldr	r3, [sp, #144]	@ 0x90
 c0463e0:	a80e      	add	r0, sp, #56	@ 0x38
 c0463e2:	9303      	str	r3, [sp, #12]
 c0463e4:	9b23      	ldr	r3, [sp, #140]	@ 0x8c
 c0463e6:	9302      	str	r3, [sp, #8]
 c0463e8:	9b22      	ldr	r3, [sp, #136]	@ 0x88
 c0463ea:	e9cd 7300 	strd	r7, r3, [sp]
 c0463ee:	462b      	mov	r3, r5
 c0463f0:	e9de 1209 	ldrd	r1, r2, [lr, #36]	@ 0x24
 c0463f4:	f001 fb9d 	bl	c047b32 <psa_driver_wrapper_aead_encrypt>
    if( status != PSA_SUCCESS && ciphertext_size != 0 )
 c0463f8:	4604      	mov	r4, r0
 c0463fa:	b128      	cbz	r0, c046408 <mbedcrypto__psa_aead_encrypt+0x100>
 c0463fc:	b126      	cbz	r6, c046408 <mbedcrypto__psa_aead_encrypt+0x100>
        memset( ciphertext, 0, ciphertext_size );
 c0463fe:	4632      	mov	r2, r6
 c046400:	2100      	movs	r1, #0
 c046402:	4640      	mov	r0, r8
 c046404:	f015 f993 	bl	c05b72e <memset>
    psa_unlock_key_slot( slot );
 c046408:	980d      	ldr	r0, [sp, #52]	@ 0x34
 c04640a:	f002 fe53 	bl	c0490b4 <psa_unlock_key_slot>
}
 c04640e:	4620      	mov	r0, r4
 c046410:	b01b      	add	sp, #108	@ 0x6c
 c046412:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 c046416:	bf00      	nop
 c046418:	06000200 	.word	0x06000200
 c04641c:	06000400 	.word	0x06000400
 c046420:	06000900 	.word	0x06000900
 c046424:	06001300 	.word	0x06001300
 c046428:	020000ff 	.word	0x020000ff

0c04642c <mbedcrypto__psa_aead_decrypt>:
{
 c04642c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 c046430:	461f      	mov	r7, r3
    *plaintext_length = 0;
 c046432:	2300      	movs	r3, #0
{
 c046434:	b09b      	sub	sp, #108	@ 0x6c
 c046436:	f8dd 90a4 	ldr.w	r9, [sp, #164]	@ 0xa4
 c04643a:	ac0a      	add	r4, sp, #40	@ 0x28
    *plaintext_length = 0;
 c04643c:	f8c9 3000 	str.w	r3, [r9]
    if( !PSA_ALG_IS_AEAD( alg ) || PSA_ALG_IS_WILDCARD( alg ) )
 c046440:	f002 43fe 	and.w	r3, r2, #2130706432	@ 0x7f000000
 c046444:	f1b3 6fa0 	cmp.w	r3, #83886080	@ 0x5000000
{
 c046448:	4615      	mov	r5, r2
 c04644a:	e9dd 8627 	ldrd	r8, r6, [sp, #156]	@ 0x9c
 c04644e:	e884 0003 	stmia.w	r4, {r0, r1}
    if( !PSA_ALG_IS_AEAD( alg ) || PSA_ALG_IS_WILDCARD( alg ) )
 c046452:	d12f      	bne.n	c0464b4 <mbedcrypto__psa_aead_decrypt+0x88>
 c046454:	4939      	ldr	r1, [pc, #228]	@ (c04653c <mbedcrypto__psa_aead_decrypt+0x110>)
 c046456:	f022 03ff 	bic.w	r3, r2, #255	@ 0xff
 c04645a:	f422 72ff 	bic.w	r2, r2, #510	@ 0x1fe
 c04645e:	f022 0201 	bic.w	r2, r2, #1
 c046462:	428a      	cmp	r2, r1
 c046464:	d00d      	beq.n	c046482 <mbedcrypto__psa_aead_decrypt+0x56>
 c046466:	f501 5188 	add.w	r1, r1, #4352	@ 0x1100
 c04646a:	428b      	cmp	r3, r1
 c04646c:	d009      	beq.n	c046482 <mbedcrypto__psa_aead_decrypt+0x56>
 c04646e:	4834      	ldr	r0, [pc, #208]	@ (c046540 <mbedcrypto__psa_aead_decrypt+0x114>)
 c046470:	f425 717f 	bic.w	r1, r5, #1020	@ 0x3fc
 c046474:	f021 0103 	bic.w	r1, r1, #3
 c046478:	4281      	cmp	r1, r0
 c04647a:	d002      	beq.n	c046482 <mbedcrypto__psa_aead_decrypt+0x56>
 c04647c:	4931      	ldr	r1, [pc, #196]	@ (c046544 <mbedcrypto__psa_aead_decrypt+0x118>)
 c04647e:	428b      	cmp	r3, r1
 c046480:	d11b      	bne.n	c0464ba <mbedcrypto__psa_aead_decrypt+0x8e>
 c046482:	f015 01ff 	ands.w	r1, r5, #255	@ 0xff
 c046486:	d018      	beq.n	c0464ba <mbedcrypto__psa_aead_decrypt+0x8e>
 c046488:	482c      	ldr	r0, [pc, #176]	@ (c04653c <mbedcrypto__psa_aead_decrypt+0x110>)
 c04648a:	4282      	cmp	r2, r0
 c04648c:	d00d      	beq.n	c0464aa <mbedcrypto__psa_aead_decrypt+0x7e>
 c04648e:	4a2e      	ldr	r2, [pc, #184]	@ (c046548 <mbedcrypto__psa_aead_decrypt+0x11c>)
 c046490:	4293      	cmp	r3, r2
 c046492:	d00a      	beq.n	c0464aa <mbedcrypto__psa_aead_decrypt+0x7e>
 c046494:	f425 727f 	bic.w	r2, r5, #1020	@ 0x3fc
 c046498:	f022 0203 	bic.w	r2, r2, #3
 c04649c:	f500 7000 	add.w	r0, r0, #512	@ 0x200
 c0464a0:	4282      	cmp	r2, r0
 c0464a2:	d002      	beq.n	c0464aa <mbedcrypto__psa_aead_decrypt+0x7e>
 c0464a4:	4a27      	ldr	r2, [pc, #156]	@ (c046544 <mbedcrypto__psa_aead_decrypt+0x118>)
 c0464a6:	4293      	cmp	r3, r2
 c0464a8:	d109      	bne.n	c0464be <mbedcrypto__psa_aead_decrypt+0x92>
 c0464aa:	4a28      	ldr	r2, [pc, #160]	@ (c04654c <mbedcrypto__psa_aead_decrypt+0x120>)
 c0464ac:	f041 7300 	orr.w	r3, r1, #33554432	@ 0x2000000
 c0464b0:	4293      	cmp	r3, r2
 c0464b2:	d104      	bne.n	c0464be <mbedcrypto__psa_aead_decrypt+0x92>
        return( PSA_ERROR_NOT_SUPPORTED );
 c0464b4:	f06f 0485 	mvn.w	r4, #133	@ 0x85
 c0464b8:	e03b      	b.n	c046532 <mbedcrypto__psa_aead_decrypt+0x106>
    if( !PSA_ALG_IS_AEAD( alg ) || PSA_ALG_IS_WILDCARD( alg ) )
 c0464ba:	042b      	lsls	r3, r5, #16
 c0464bc:	d4fa      	bmi.n	c0464b4 <mbedcrypto__psa_aead_decrypt+0x88>
    status = psa_get_and_lock_key_slot_with_policy(
 c0464be:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	@ 0x28
 c0464c2:	f44f 7300 	mov.w	r3, #512	@ 0x200
 c0464c6:	9500      	str	r5, [sp, #0]
 c0464c8:	aa0d      	add	r2, sp, #52	@ 0x34
 c0464ca:	f7fe f85d 	bl	c044588 <psa_get_and_lock_key_slot_with_policy>
    if( status != PSA_SUCCESS )
 c0464ce:	4604      	mov	r4, r0
 c0464d0:	bb78      	cbnz	r0, c046532 <mbedcrypto__psa_aead_decrypt+0x106>
    psa_key_attributes_t attributes = {
 c0464d2:	4601      	mov	r1, r0
 c0464d4:	2210      	movs	r2, #16
 c0464d6:	a816      	add	r0, sp, #88	@ 0x58
 c0464d8:	f015 f929 	bl	c05b72e <memset>
      .core = slot->attr
 c0464dc:	f8dd e034 	ldr.w	lr, [sp, #52]	@ 0x34
    psa_key_attributes_t attributes = {
 c0464e0:	ac0e      	add	r4, sp, #56	@ 0x38
 c0464e2:	46f4      	mov	ip, lr
 c0464e4:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 c0464e8:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 c0464ea:	e89c 000f 	ldmia.w	ip, {r0, r1, r2, r3}
 c0464ee:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
    status = psa_driver_wrapper_aead_decrypt(
 c0464f2:	9b26      	ldr	r3, [sp, #152]	@ 0x98
 c0464f4:	e9cd 6907 	strd	r6, r9, [sp, #28]
 c0464f8:	9305      	str	r3, [sp, #20]
 c0464fa:	9b25      	ldr	r3, [sp, #148]	@ 0x94
 c0464fc:	f8cd 8018 	str.w	r8, [sp, #24]
 c046500:	9304      	str	r3, [sp, #16]
 c046502:	9b24      	ldr	r3, [sp, #144]	@ 0x90
 c046504:	a80e      	add	r0, sp, #56	@ 0x38
 c046506:	9303      	str	r3, [sp, #12]
 c046508:	9b23      	ldr	r3, [sp, #140]	@ 0x8c
 c04650a:	9302      	str	r3, [sp, #8]
 c04650c:	9b22      	ldr	r3, [sp, #136]	@ 0x88
 c04650e:	e9cd 7300 	strd	r7, r3, [sp]
 c046512:	462b      	mov	r3, r5
 c046514:	e9de 1209 	ldrd	r1, r2, [lr, #36]	@ 0x24
 c046518:	f001 fb2b 	bl	c047b72 <psa_driver_wrapper_aead_decrypt>
    if( status != PSA_SUCCESS && plaintext_size != 0 )
 c04651c:	4604      	mov	r4, r0
 c04651e:	b128      	cbz	r0, c04652c <mbedcrypto__psa_aead_decrypt+0x100>
 c046520:	b126      	cbz	r6, c04652c <mbedcrypto__psa_aead_decrypt+0x100>
        memset( plaintext, 0, plaintext_size );
 c046522:	4632      	mov	r2, r6
 c046524:	2100      	movs	r1, #0
 c046526:	4640      	mov	r0, r8
 c046528:	f015 f901 	bl	c05b72e <memset>
    psa_unlock_key_slot( slot );
 c04652c:	980d      	ldr	r0, [sp, #52]	@ 0x34
 c04652e:	f002 fdc1 	bl	c0490b4 <psa_unlock_key_slot>
}
 c046532:	4620      	mov	r0, r4
 c046534:	b01b      	add	sp, #108	@ 0x6c
 c046536:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 c04653a:	bf00      	nop
 c04653c:	06000200 	.word	0x06000200
 c046540:	06000400 	.word	0x06000400
 c046544:	06000900 	.word	0x06000900
 c046548:	06001300 	.word	0x06001300
 c04654c:	020000ff 	.word	0x020000ff

0c046550 <mbedcrypto__psa_key_derivation_abort>:
{
 c046550:	b538      	push	{r3, r4, r5, lr}
    if ( PSA_ALG_IS_KEY_AGREEMENT( operation->alg ) )
 c046552:	6803      	ldr	r3, [r0, #0]
{
 c046554:	4604      	mov	r4, r0
    if ( PSA_ALG_IS_KEY_AGREEMENT( operation->alg ) )
 c046556:	f003 42fe 	and.w	r2, r3, #2130706432	@ 0x7f000000
 c04655a:	f1b2 6f10 	cmp.w	r2, #150994944	@ 0x9000000
 c04655e:	d119      	bne.n	c046594 <mbedcrypto__psa_key_derivation_abort+0x44>
        return( PSA_ALG_KEY_AGREEMENT_GET_KDF( operation->alg ) );
 c046560:	f023 631f 	bic.w	r3, r3, #166723584	@ 0x9f00000
 c046564:	f423 2370 	bic.w	r3, r3, #983040	@ 0xf0000
 c046568:	f043 6300 	orr.w	r3, r3, #134217728	@ 0x8000000
    if( PSA_ALG_IS_HKDF( kdf_alg ) )
 c04656c:	4a1d      	ldr	r2, [pc, #116]	@ (c0465e4 <mbedcrypto__psa_key_derivation_abort+0x94>)
 c04656e:	f023 01ff 	bic.w	r1, r3, #255	@ 0xff
 c046572:	4291      	cmp	r1, r2
 c046574:	d112      	bne.n	c04659c <mbedcrypto__psa_key_derivation_abort+0x4c>
        mbedtls_free( operation->ctx.hkdf.info );
 c046576:	6920      	ldr	r0, [r4, #16]
 c046578:	f7f4 ff1a 	bl	c03b3b0 <mbedtls_free>
        status = psa_mac_abort( &operation->ctx.hkdf.hmac );
 c04657c:	f104 00a0 	add.w	r0, r4, #160	@ 0xa0
 c046580:	f7ff f989 	bl	c045896 <mbedcrypto__psa_mac_abort>
 c046584:	4605      	mov	r5, r0
    mbedtls_platform_zeroize( operation, sizeof( *operation ) );
 c046586:	4620      	mov	r0, r4
 c046588:	f44f 7130 	mov.w	r1, #704	@ 0x2c0
 c04658c:	f7f4 ff20 	bl	c03b3d0 <mbedtls_platform_zeroize>
}
 c046590:	4628      	mov	r0, r5
 c046592:	bd38      	pop	{r3, r4, r5, pc}
    if( kdf_alg == 0 )
 c046594:	2b00      	cmp	r3, #0
 c046596:	d1e9      	bne.n	c04656c <mbedcrypto__psa_key_derivation_abort+0x1c>
    psa_status_t status = PSA_SUCCESS;
 c046598:	2500      	movs	r5, #0
 c04659a:	e7f4      	b.n	c046586 <mbedcrypto__psa_key_derivation_abort+0x36>
    if( PSA_ALG_IS_TLS12_PRF( kdf_alg ) ||
 c04659c:	4a12      	ldr	r2, [pc, #72]	@ (c0465e8 <mbedcrypto__psa_key_derivation_abort+0x98>)
 c04659e:	f423 73ff 	bic.w	r3, r3, #510	@ 0x1fe
 c0465a2:	f023 0301 	bic.w	r3, r3, #1
 c0465a6:	4293      	cmp	r3, r2
 c0465a8:	d119      	bne.n	c0465de <mbedcrypto__psa_key_derivation_abort+0x8e>
        if( operation->ctx.tls12_prf.secret != NULL )
 c0465aa:	6960      	ldr	r0, [r4, #20]
 c0465ac:	b128      	cbz	r0, c0465ba <mbedcrypto__psa_key_derivation_abort+0x6a>
            mbedtls_platform_zeroize( operation->ctx.tls12_prf.secret,
 c0465ae:	69a1      	ldr	r1, [r4, #24]
 c0465b0:	f7f4 ff0e 	bl	c03b3d0 <mbedtls_platform_zeroize>
            mbedtls_free( operation->ctx.tls12_prf.secret );
 c0465b4:	6960      	ldr	r0, [r4, #20]
 c0465b6:	f7f4 fefb 	bl	c03b3b0 <mbedtls_free>
        if( operation->ctx.tls12_prf.seed != NULL )
 c0465ba:	69e0      	ldr	r0, [r4, #28]
 c0465bc:	b128      	cbz	r0, c0465ca <mbedcrypto__psa_key_derivation_abort+0x7a>
            mbedtls_platform_zeroize( operation->ctx.tls12_prf.seed,
 c0465be:	6a21      	ldr	r1, [r4, #32]
 c0465c0:	f7f4 ff06 	bl	c03b3d0 <mbedtls_platform_zeroize>
            mbedtls_free( operation->ctx.tls12_prf.seed );
 c0465c4:	69e0      	ldr	r0, [r4, #28]
 c0465c6:	f7f4 fef3 	bl	c03b3b0 <mbedtls_free>
        if( operation->ctx.tls12_prf.label != NULL )
 c0465ca:	6a60      	ldr	r0, [r4, #36]	@ 0x24
 c0465cc:	2800      	cmp	r0, #0
 c0465ce:	d0e3      	beq.n	c046598 <mbedcrypto__psa_key_derivation_abort+0x48>
            mbedtls_platform_zeroize( operation->ctx.tls12_prf.label,
 c0465d0:	6aa1      	ldr	r1, [r4, #40]	@ 0x28
 c0465d2:	f7f4 fefd 	bl	c03b3d0 <mbedtls_platform_zeroize>
            mbedtls_free( operation->ctx.tls12_prf.label );
 c0465d6:	6a60      	ldr	r0, [r4, #36]	@ 0x24
 c0465d8:	f7f4 feea 	bl	c03b3b0 <mbedtls_free>
 c0465dc:	e7dc      	b.n	c046598 <mbedcrypto__psa_key_derivation_abort+0x48>
        status = PSA_ERROR_BAD_STATE;
 c0465de:	f06f 0588 	mvn.w	r5, #136	@ 0x88
 c0465e2:	e7d0      	b.n	c046586 <mbedcrypto__psa_key_derivation_abort+0x36>
 c0465e4:	08000100 	.word	0x08000100
 c0465e8:	08000200 	.word	0x08000200

0c0465ec <psa_key_derivation_input_internal>:
{
 c0465ec:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
 c0465f0:	4605      	mov	r5, r0
    if ( PSA_ALG_IS_KEY_AGREEMENT( operation->alg ) )
 c0465f2:	6800      	ldr	r0, [r0, #0]
{
 c0465f4:	461f      	mov	r7, r3
    if ( PSA_ALG_IS_KEY_AGREEMENT( operation->alg ) )
 c0465f6:	f000 44fe 	and.w	r4, r0, #2130706432	@ 0x7f000000
 c0465fa:	f1b4 6f10 	cmp.w	r4, #150994944	@ 0x9000000
    switch( step )
 c0465fe:	f240 1401 	movw	r4, #257	@ 0x101
        return( PSA_ALG_KEY_AGREEMENT_GET_KDF( operation->alg ) );
 c046602:	bf02      	ittt	eq
 c046604:	f020 601f 	biceq.w	r0, r0, #166723584	@ 0x9f00000
 c046608:	f420 2070 	biceq.w	r0, r0, #983040	@ 0xf0000
 c04660c:	f040 6000 	orreq.w	r0, r0, #134217728	@ 0x8000000
    switch( step )
 c046610:	42a1      	cmp	r1, r4
{
 c046612:	9b08      	ldr	r3, [sp, #32]
    switch( step )
 c046614:	d00f      	beq.n	c046636 <psa_key_derivation_input_internal+0x4a>
 c046616:	f46f 7400 	mvn.w	r4, #512	@ 0x200
 c04661a:	190c      	adds	r4, r1, r4
 c04661c:	2c03      	cmp	r4, #3
 c04661e:	d804      	bhi.n	c04662a <psa_key_derivation_input_internal+0x3e>
            if( key_type == PSA_KEY_TYPE_RAW_DATA )
 c046620:	f241 0401 	movw	r4, #4097	@ 0x1001
 c046624:	42a2      	cmp	r2, r4
            if( key_type == PSA_KEY_TYPE_DERIVE )
 c046626:	d009      	beq.n	c04663c <psa_key_derivation_input_internal+0x50>
            if( key_type == PSA_KEY_TYPE_NONE )
 c046628:	b142      	cbz	r2, c04663c <psa_key_derivation_input_internal+0x50>
    return( PSA_ERROR_INVALID_ARGUMENT );
 c04662a:	f06f 0486 	mvn.w	r4, #134	@ 0x86
        psa_key_derivation_abort( operation );
 c04662e:	4628      	mov	r0, r5
 c046630:	f7ff ff8e 	bl	c046550 <mbedcrypto__psa_key_derivation_abort>
 c046634:	e064      	b.n	c046700 <psa_key_derivation_input_internal+0x114>
            if( key_type == PSA_KEY_TYPE_DERIVE )
 c046636:	f5b2 5f90 	cmp.w	r2, #4608	@ 0x1200
 c04663a:	e7f4      	b.n	c046626 <psa_key_derivation_input_internal+0x3a>
    if( PSA_ALG_IS_HKDF( kdf_alg ) )
 c04663c:	4c50      	ldr	r4, [pc, #320]	@ (c046780 <psa_key_derivation_input_internal+0x194>)
 c04663e:	f020 02ff 	bic.w	r2, r0, #255	@ 0xff
 c046642:	42a2      	cmp	r2, r4
 c046644:	d17f      	bne.n	c046746 <psa_key_derivation_input_internal+0x15a>
    switch( step )
 c046646:	f240 2202 	movw	r2, #514	@ 0x202
                                 PSA_ALG_HKDF_GET_HASH( kdf_alg ),
 c04664a:	b2c0      	uxtb	r0, r0
    switch( step )
 c04664c:	4291      	cmp	r1, r2
        status = psa_hkdf_input( &operation->ctx.hkdf,
 c04664e:	f040 7600 	orr.w	r6, r0, #33554432	@ 0x2000000
 c046652:	9301      	str	r3, [sp, #4]
    switch( step )
 c046654:	d042      	beq.n	c0466dc <psa_key_derivation_input_internal+0xf0>
 c046656:	f240 2203 	movw	r2, #515	@ 0x203
 c04665a:	4291      	cmp	r1, r2
 c04665c:	d056      	beq.n	c04670c <psa_key_derivation_input_internal+0x120>
 c04665e:	f240 1301 	movw	r3, #257	@ 0x101
 c046662:	4299      	cmp	r1, r3
 c046664:	d1e1      	bne.n	c04662a <psa_key_derivation_input_internal+0x3e>
            if( hkdf->state == HKDF_STATE_INIT )
 c046666:	7eab      	ldrb	r3, [r5, #26]
 c046668:	f013 0303 	ands.w	r3, r3, #3
 c04666c:	d10d      	bne.n	c04668a <psa_key_derivation_input_internal+0x9e>
                status = psa_key_derivation_start_hmac( &hkdf->hmac,
 c04666e:	461a      	mov	r2, r3
 c046670:	4631      	mov	r1, r6
 c046672:	f105 00a0 	add.w	r0, r5, #160	@ 0xa0
 c046676:	f7fe f8db 	bl	c044830 <psa_key_derivation_start_hmac>
                if( status != PSA_SUCCESS )
 c04667a:	4604      	mov	r4, r0
 c04667c:	2800      	cmp	r0, #0
 c04667e:	d1d6      	bne.n	c04662e <psa_key_derivation_input_internal+0x42>
                hkdf->state = HKDF_STATE_STARTED;
 c046680:	2201      	movs	r2, #1
 c046682:	7eab      	ldrb	r3, [r5, #26]
 c046684:	f362 0301 	bfi	r3, r2, #0, #2
 c046688:	76ab      	strb	r3, [r5, #26]
            if( hkdf->state != HKDF_STATE_STARTED )
 c04668a:	7eab      	ldrb	r3, [r5, #26]
 c04668c:	f003 0303 	and.w	r3, r3, #3
 c046690:	2b01      	cmp	r3, #1
 c046692:	d152      	bne.n	c04673a <psa_key_derivation_input_internal+0x14e>
            status = psa_mac_update( &hkdf->hmac,
 c046694:	f105 08a0 	add.w	r8, r5, #160	@ 0xa0
 c046698:	4639      	mov	r1, r7
 c04669a:	4640      	mov	r0, r8
 c04669c:	9a01      	ldr	r2, [sp, #4]
 c04669e:	f7ff f9d9 	bl	c045a54 <mbedcrypto__psa_mac_update>
            if( status != PSA_SUCCESS )
 c0466a2:	4604      	mov	r4, r0
 c0466a4:	2800      	cmp	r0, #0
 c0466a6:	d1c2      	bne.n	c04662e <psa_key_derivation_input_internal+0x42>
            status = psa_mac_sign_finish( &hkdf->hmac,
 c0466a8:	2240      	movs	r2, #64	@ 0x40
 c0466aa:	4640      	mov	r0, r8
 c0466ac:	ab01      	add	r3, sp, #4
 c0466ae:	f105 015b 	add.w	r1, r5, #91	@ 0x5b
 c0466b2:	f7ff f9e3 	bl	c045a7c <mbedcrypto__psa_mac_sign_finish>
            if( status != PSA_SUCCESS )
 c0466b6:	4604      	mov	r4, r0
 c0466b8:	2800      	cmp	r0, #0
 c0466ba:	d1b8      	bne.n	c04662e <psa_key_derivation_input_internal+0x42>
            hkdf->offset_in_block = PSA_HASH_LENGTH( hash_alg );
 c0466bc:	4b31      	ldr	r3, [pc, #196]	@ (c046784 <psa_key_derivation_input_internal+0x198>)
 c0466be:	429e      	cmp	r6, r3
 c0466c0:	d022      	beq.n	c046708 <psa_key_derivation_input_internal+0x11c>
 c0466c2:	f106 467e 	add.w	r6, r6, #4261412864	@ 0xfe000000
 c0466c6:	3e02      	subs	r6, #2
 c0466c8:	2e11      	cmp	r6, #17
 c0466ca:	d801      	bhi.n	c0466d0 <psa_key_derivation_input_internal+0xe4>
 c0466cc:	4b2e      	ldr	r3, [pc, #184]	@ (c046788 <psa_key_derivation_input_internal+0x19c>)
 c0466ce:	5d98      	ldrb	r0, [r3, r6]
            hkdf->block_number = 0;
 c0466d0:	2300      	movs	r3, #0
            hkdf->state = HKDF_STATE_KEYED;
 c0466d2:	2202      	movs	r2, #2
            hkdf->block_number = 0;
 c0466d4:	766b      	strb	r3, [r5, #25]
            hkdf->offset_in_block = PSA_HASH_LENGTH( hash_alg );
 c0466d6:	7628      	strb	r0, [r5, #24]
            hkdf->state = HKDF_STATE_KEYED;
 c0466d8:	7eab      	ldrb	r3, [r5, #26]
 c0466da:	e00d      	b.n	c0466f8 <psa_key_derivation_input_internal+0x10c>
            if( hkdf->state != HKDF_STATE_INIT )
 c0466dc:	7eaa      	ldrb	r2, [r5, #26]
 c0466de:	0791      	lsls	r1, r2, #30
 c0466e0:	d12b      	bne.n	c04673a <psa_key_derivation_input_internal+0x14e>
                status = psa_key_derivation_start_hmac( &hkdf->hmac,
 c0466e2:	463a      	mov	r2, r7
 c0466e4:	4631      	mov	r1, r6
 c0466e6:	f105 00a0 	add.w	r0, r5, #160	@ 0xa0
 c0466ea:	f7fe f8a1 	bl	c044830 <psa_key_derivation_start_hmac>
                if( status != PSA_SUCCESS )
 c0466ee:	4604      	mov	r4, r0
 c0466f0:	2800      	cmp	r0, #0
 c0466f2:	d19c      	bne.n	c04662e <psa_key_derivation_input_internal+0x42>
                hkdf->state = HKDF_STATE_STARTED;
 c0466f4:	2201      	movs	r2, #1
 c0466f6:	7eab      	ldrb	r3, [r5, #26]
            hkdf->state = HKDF_STATE_KEYED;
 c0466f8:	f362 0301 	bfi	r3, r2, #0, #2
            hkdf->info_set = 1;
 c0466fc:	76ab      	strb	r3, [r5, #26]
        return( PSA_ERROR_BAD_STATE );
 c0466fe:	2400      	movs	r4, #0
}
 c046700:	4620      	mov	r0, r4
 c046702:	b002      	add	sp, #8
 c046704:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
            hkdf->offset_in_block = PSA_HASH_LENGTH( hash_alg );
 c046708:	2010      	movs	r0, #16
 c04670a:	e7e1      	b.n	c0466d0 <psa_key_derivation_input_internal+0xe4>
            if( hkdf->state == HKDF_STATE_OUTPUT )
 c04670c:	7eaa      	ldrb	r2, [r5, #26]
 c04670e:	f002 0103 	and.w	r1, r2, #3
 c046712:	2903      	cmp	r1, #3
 c046714:	d011      	beq.n	c04673a <psa_key_derivation_input_internal+0x14e>
            if( hkdf->info_set )
 c046716:	0752      	lsls	r2, r2, #29
 c046718:	d40f      	bmi.n	c04673a <psa_key_derivation_input_internal+0x14e>
            hkdf->info_length = data_length;
 c04671a:	616b      	str	r3, [r5, #20]
            if( data_length != 0 )
 c04671c:	b14b      	cbz	r3, c046732 <psa_key_derivation_input_internal+0x146>
                hkdf->info = mbedtls_calloc( 1, data_length );
 c04671e:	4619      	mov	r1, r3
 c046720:	2001      	movs	r0, #1
 c046722:	f7f4 fe3f 	bl	c03b3a4 <mbedtls_calloc>
 c046726:	6128      	str	r0, [r5, #16]
                if( hkdf->info == NULL )
 c046728:	b150      	cbz	r0, c046740 <psa_key_derivation_input_internal+0x154>
                memcpy( hkdf->info, data, data_length );
 c04672a:	4639      	mov	r1, r7
 c04672c:	9a01      	ldr	r2, [sp, #4]
 c04672e:	f014 ff8d 	bl	c05b64c <memcpy>
            hkdf->info_set = 1;
 c046732:	7eab      	ldrb	r3, [r5, #26]
 c046734:	f043 0304 	orr.w	r3, r3, #4
 c046738:	e7e0      	b.n	c0466fc <psa_key_derivation_input_internal+0x110>
                return( PSA_ERROR_BAD_STATE );
 c04673a:	f06f 0488 	mvn.w	r4, #136	@ 0x88
 c04673e:	e776      	b.n	c04662e <psa_key_derivation_input_internal+0x42>
                    return( PSA_ERROR_INSUFFICIENT_MEMORY );
 c046740:	f06f 048c 	mvn.w	r4, #140	@ 0x8c
 c046744:	e773      	b.n	c04662e <psa_key_derivation_input_internal+0x42>
    if( PSA_ALG_IS_TLS12_PRF( kdf_alg ) )
 c046746:	4811      	ldr	r0, [pc, #68]	@ (c04678c <psa_key_derivation_input_internal+0x1a0>)
 c046748:	4282      	cmp	r2, r0
 c04674a:	d108      	bne.n	c04675e <psa_key_derivation_input_internal+0x172>
        status = psa_tls12_prf_input( &operation->ctx.tls12_prf,
 c04674c:	463a      	mov	r2, r7
 c04674e:	f105 0010 	add.w	r0, r5, #16
 c046752:	f7fd fd81 	bl	c044258 <psa_tls12_prf_input>
        return( psa_tls12_prf_psk_to_ms_set_key( prf,
 c046756:	4604      	mov	r4, r0
    if( status != PSA_SUCCESS )
 c046758:	2800      	cmp	r0, #0
 c04675a:	d0d0      	beq.n	c0466fe <psa_key_derivation_input_internal+0x112>
 c04675c:	e767      	b.n	c04662e <psa_key_derivation_input_internal+0x42>
    if( PSA_ALG_IS_TLS12_PSK_TO_MS( kdf_alg ) )
 c04675e:	480c      	ldr	r0, [pc, #48]	@ (c046790 <psa_key_derivation_input_internal+0x1a4>)
 c046760:	4282      	cmp	r2, r0
 c046762:	d10a      	bne.n	c04677a <psa_key_derivation_input_internal+0x18e>
    if( step == PSA_KEY_DERIVATION_INPUT_SECRET )
 c046764:	f240 1201 	movw	r2, #257	@ 0x101
 c046768:	4291      	cmp	r1, r2
 c04676a:	d1ef      	bne.n	c04674c <psa_key_derivation_input_internal+0x160>
        return( psa_tls12_prf_psk_to_ms_set_key( prf,
 c04676c:	461a      	mov	r2, r3
 c04676e:	4639      	mov	r1, r7
 c046770:	f105 0010 	add.w	r0, r5, #16
 c046774:	f7fd fe0e 	bl	c044394 <psa_tls12_prf_psk_to_ms_set_key>
 c046778:	e7ed      	b.n	c046756 <psa_key_derivation_input_internal+0x16a>
        return( PSA_ERROR_BAD_STATE );
 c04677a:	f06f 0488 	mvn.w	r4, #136	@ 0x88
 c04677e:	e7bf      	b.n	c046700 <psa_key_derivation_input_internal+0x114>
 c046780:	08000100 	.word	0x08000100
 c046784:	02000001 	.word	0x02000001
 c046788:	0c060e58 	.word	0x0c060e58
 c04678c:	08000200 	.word	0x08000200
 c046790:	08000300 	.word	0x08000300

0c046794 <mbedcrypto__psa_key_derivation_get_capacity>:
    if( operation->alg == 0 )
 c046794:	6803      	ldr	r3, [r0, #0]
 c046796:	b11b      	cbz	r3, c0467a0 <mbedcrypto__psa_key_derivation_get_capacity+0xc>
    *capacity = operation->capacity;
 c046798:	6883      	ldr	r3, [r0, #8]
    return( PSA_SUCCESS );
 c04679a:	2000      	movs	r0, #0
    *capacity = operation->capacity;
 c04679c:	600b      	str	r3, [r1, #0]
    return( PSA_SUCCESS );
 c04679e:	4770      	bx	lr
        return( PSA_ERROR_BAD_STATE );
 c0467a0:	f06f 0088 	mvn.w	r0, #136	@ 0x88
}
 c0467a4:	4770      	bx	lr

0c0467a6 <mbedcrypto__psa_key_derivation_set_capacity>:
    if( operation->alg == 0 )
 c0467a6:	6803      	ldr	r3, [r0, #0]
 c0467a8:	b12b      	cbz	r3, c0467b6 <mbedcrypto__psa_key_derivation_set_capacity+0x10>
    if( capacity > operation->capacity )
 c0467aa:	6883      	ldr	r3, [r0, #8]
 c0467ac:	428b      	cmp	r3, r1
 c0467ae:	d305      	bcc.n	c0467bc <mbedcrypto__psa_key_derivation_set_capacity+0x16>
    operation->capacity = capacity;
 c0467b0:	6081      	str	r1, [r0, #8]
    return( PSA_SUCCESS );
 c0467b2:	2000      	movs	r0, #0
 c0467b4:	4770      	bx	lr
        return( PSA_ERROR_BAD_STATE );
 c0467b6:	f06f 0088 	mvn.w	r0, #136	@ 0x88
 c0467ba:	4770      	bx	lr
        return( PSA_ERROR_INVALID_ARGUMENT );
 c0467bc:	f06f 0086 	mvn.w	r0, #134	@ 0x86
}
 c0467c0:	4770      	bx	lr
	...

0c0467c4 <mbedcrypto__psa_key_derivation_output_bytes>:
{
 c0467c4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    if ( PSA_ALG_IS_KEY_AGREEMENT( operation->alg ) )
 c0467c8:	6806      	ldr	r6, [r0, #0]
{
 c0467ca:	b085      	sub	sp, #20
    if ( PSA_ALG_IS_KEY_AGREEMENT( operation->alg ) )
 c0467cc:	f006 43fe 	and.w	r3, r6, #2130706432	@ 0x7f000000
 c0467d0:	f1b3 6f10 	cmp.w	r3, #150994944	@ 0x9000000
{
 c0467d4:	4604      	mov	r4, r0
 c0467d6:	4617      	mov	r7, r2
 c0467d8:	9101      	str	r1, [sp, #4]
    if ( PSA_ALG_IS_KEY_AGREEMENT( operation->alg ) )
 c0467da:	d117      	bne.n	c04680c <mbedcrypto__psa_key_derivation_output_bytes+0x48>
        return( PSA_ALG_KEY_AGREEMENT_GET_KDF( operation->alg ) );
 c0467dc:	f026 661f 	bic.w	r6, r6, #166723584	@ 0x9f00000
 c0467e0:	f426 2670 	bic.w	r6, r6, #983040	@ 0xf0000
 c0467e4:	f046 6600 	orr.w	r6, r6, #134217728	@ 0x8000000
    if( output_length > operation->capacity )
 c0467e8:	68a3      	ldr	r3, [r4, #8]
 c0467ea:	42bb      	cmp	r3, r7
 c0467ec:	d216      	bcs.n	c04681c <mbedcrypto__psa_key_derivation_output_bytes+0x58>
        operation->capacity = 0;
 c0467ee:	2300      	movs	r3, #0
        status = PSA_ERROR_INSUFFICIENT_DATA;
 c0467f0:	f06f 058e 	mvn.w	r5, #142	@ 0x8e
        operation->capacity = 0;
 c0467f4:	60a3      	str	r3, [r4, #8]
        psa_algorithm_t alg = operation->alg;
 c0467f6:	6826      	ldr	r6, [r4, #0]
        psa_key_derivation_abort( operation );
 c0467f8:	4620      	mov	r0, r4
 c0467fa:	f7ff fea9 	bl	c046550 <mbedcrypto__psa_key_derivation_abort>
        memset( output, '!', output_length );
 c0467fe:	463a      	mov	r2, r7
 c046800:	2121      	movs	r1, #33	@ 0x21
 c046802:	9801      	ldr	r0, [sp, #4]
        operation->alg = alg;
 c046804:	6026      	str	r6, [r4, #0]
        memset( output, '!', output_length );
 c046806:	f014 ff92 	bl	c05b72e <memset>
 c04680a:	e003      	b.n	c046814 <mbedcrypto__psa_key_derivation_output_bytes+0x50>
    if( operation->alg == 0 )
 c04680c:	2e00      	cmp	r6, #0
 c04680e:	d1eb      	bne.n	c0467e8 <mbedcrypto__psa_key_derivation_output_bytes+0x24>
        return( PSA_ERROR_BAD_STATE );
 c046810:	f06f 0588 	mvn.w	r5, #136	@ 0x88
}
 c046814:	4628      	mov	r0, r5
 c046816:	b005      	add	sp, #20
 c046818:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if( output_length == 0 && operation->capacity == 0 )
 c04681c:	ea53 0207 	orrs.w	r2, r3, r7
 c046820:	f000 80d0 	beq.w	c0469c4 <mbedcrypto__psa_key_derivation_output_bytes+0x200>
    operation->capacity -= output_length;
 c046824:	1bdb      	subs	r3, r3, r7
 c046826:	60a3      	str	r3, [r4, #8]
    if( PSA_ALG_IS_HKDF( kdf_alg ) )
 c046828:	4b68      	ldr	r3, [pc, #416]	@ (c0469cc <mbedcrypto__psa_key_derivation_output_bytes+0x208>)
 c04682a:	f026 02ff 	bic.w	r2, r6, #255	@ 0xff
 c04682e:	429a      	cmp	r2, r3
 c046830:	d176      	bne.n	c046920 <mbedcrypto__psa_key_derivation_output_bytes+0x15c>
    uint8_t hash_length = PSA_HASH_LENGTH( hash_alg );
 c046832:	4b67      	ldr	r3, [pc, #412]	@ (c0469d0 <mbedcrypto__psa_key_derivation_output_bytes+0x20c>)
        psa_algorithm_t hash_alg = PSA_ALG_HKDF_GET_HASH( kdf_alg );
 c046834:	b2f6      	uxtb	r6, r6
 c046836:	f046 7600 	orr.w	r6, r6, #33554432	@ 0x2000000
    uint8_t hash_length = PSA_HASH_LENGTH( hash_alg );
 c04683a:	429e      	cmp	r6, r3
 c04683c:	d061      	beq.n	c046902 <mbedcrypto__psa_key_derivation_output_bytes+0x13e>
 c04683e:	f106 437e 	add.w	r3, r6, #4261412864	@ 0xfe000000
 c046842:	3b02      	subs	r3, #2
 c046844:	2b11      	cmp	r3, #17
 c046846:	d85f      	bhi.n	c046908 <mbedcrypto__psa_key_derivation_output_bytes+0x144>
 c046848:	4a62      	ldr	r2, [pc, #392]	@ (c0469d4 <mbedcrypto__psa_key_derivation_output_bytes+0x210>)
 c04684a:	f812 9003 	ldrb.w	r9, [r2, r3]
    if( hkdf->state < HKDF_STATE_KEYED || ! hkdf->info_set )
 c04684e:	7ea3      	ldrb	r3, [r4, #26]
 c046850:	f003 0203 	and.w	r2, r3, #3
 c046854:	2a01      	cmp	r2, #1
 c046856:	d97e      	bls.n	c046956 <mbedcrypto__psa_key_derivation_output_bytes+0x192>
 c046858:	075a      	lsls	r2, r3, #29
 c04685a:	d57c      	bpl.n	c046956 <mbedcrypto__psa_key_derivation_output_bytes+0x192>
    hkdf->state = HKDF_STATE_OUTPUT;
 c04685c:	f043 0303 	orr.w	r3, r3, #3
 c046860:	76a3      	strb	r3, [r4, #26]
    while( output_length != 0 )
 c046862:	2f00      	cmp	r7, #0
 c046864:	f000 808d 	beq.w	c046982 <mbedcrypto__psa_key_derivation_output_bytes+0x1be>
 c046868:	46ba      	mov	sl, r7
        memcpy( output, hkdf->output_block + hkdf->offset_in_block, n );
 c04686a:	f104 031b 	add.w	r3, r4, #27
 c04686e:	f8dd b004 	ldr.w	fp, [sp, #4]
 c046872:	9300      	str	r3, [sp, #0]
        status = psa_key_derivation_start_hmac( &hkdf->hmac,
 c046874:	f104 08a0 	add.w	r8, r4, #160	@ 0xa0
        uint8_t n = hash_length - hkdf->offset_in_block;
 c046878:	7e21      	ldrb	r1, [r4, #24]
        memcpy( output, hkdf->output_block + hkdf->offset_in_block, n );
 c04687a:	9b00      	ldr	r3, [sp, #0]
        uint8_t n = hash_length - hkdf->offset_in_block;
 c04687c:	eba9 0501 	sub.w	r5, r9, r1
 c046880:	b2ed      	uxtb	r5, r5
        if( n > output_length )
 c046882:	4555      	cmp	r5, sl
            n = (uint8_t) output_length;
 c046884:	bf88      	it	hi
 c046886:	fa5f f58a 	uxtbhi.w	r5, sl
        memcpy( output, hkdf->output_block + hkdf->offset_in_block, n );
 c04688a:	4658      	mov	r0, fp
 c04688c:	4419      	add	r1, r3
 c04688e:	462a      	mov	r2, r5
 c046890:	f014 fedc 	bl	c05b64c <memcpy>
        hkdf->offset_in_block += n;
 c046894:	7e23      	ldrb	r3, [r4, #24]
        if( output_length == 0 )
 c046896:	ebba 0a05 	subs.w	sl, sl, r5
        hkdf->offset_in_block += n;
 c04689a:	442b      	add	r3, r5
        output += n;
 c04689c:	44ab      	add	fp, r5
        hkdf->offset_in_block += n;
 c04689e:	7623      	strb	r3, [r4, #24]
        if( output_length == 0 )
 c0468a0:	d06f      	beq.n	c046982 <mbedcrypto__psa_key_derivation_output_bytes+0x1be>
        if( hkdf->block_number == 0xff )
 c0468a2:	7e63      	ldrb	r3, [r4, #25]
 c0468a4:	2bff      	cmp	r3, #255	@ 0xff
 c0468a6:	d056      	beq.n	c046956 <mbedcrypto__psa_key_derivation_output_bytes+0x192>
        ++hkdf->block_number;
 c0468a8:	3301      	adds	r3, #1
 c0468aa:	7663      	strb	r3, [r4, #25]
        hkdf->offset_in_block = 0;
 c0468ac:	f04f 0300 	mov.w	r3, #0
        status = psa_key_derivation_start_hmac( &hkdf->hmac,
 c0468b0:	4631      	mov	r1, r6
        hkdf->offset_in_block = 0;
 c0468b2:	7623      	strb	r3, [r4, #24]
        status = psa_key_derivation_start_hmac( &hkdf->hmac,
 c0468b4:	4640      	mov	r0, r8
 c0468b6:	464b      	mov	r3, r9
 c0468b8:	f104 025b 	add.w	r2, r4, #91	@ 0x5b
 c0468bc:	f7fd ffb8 	bl	c044830 <psa_key_derivation_start_hmac>
        if( status != PSA_SUCCESS )
 c0468c0:	4605      	mov	r5, r0
 c0468c2:	2800      	cmp	r0, #0
 c0468c4:	d197      	bne.n	c0467f6 <mbedcrypto__psa_key_derivation_output_bytes+0x32>
        if( hkdf->block_number != 1 )
 c0468c6:	7e63      	ldrb	r3, [r4, #25]
 c0468c8:	2b01      	cmp	r3, #1
 c0468ca:	d120      	bne.n	c04690e <mbedcrypto__psa_key_derivation_output_bytes+0x14a>
        status = psa_mac_update( &hkdf->hmac,
 c0468cc:	e9d4 1204 	ldrd	r1, r2, [r4, #16]
 c0468d0:	4640      	mov	r0, r8
 c0468d2:	f7ff f8bf 	bl	c045a54 <mbedcrypto__psa_mac_update>
        if( status != PSA_SUCCESS )
 c0468d6:	4605      	mov	r5, r0
 c0468d8:	2800      	cmp	r0, #0
 c0468da:	d18c      	bne.n	c0467f6 <mbedcrypto__psa_key_derivation_output_bytes+0x32>
        status = psa_mac_update( &hkdf->hmac,
 c0468dc:	2201      	movs	r2, #1
 c0468de:	4640      	mov	r0, r8
 c0468e0:	f104 0119 	add.w	r1, r4, #25
 c0468e4:	f7ff f8b6 	bl	c045a54 <mbedcrypto__psa_mac_update>
        if( status != PSA_SUCCESS )
 c0468e8:	4605      	mov	r5, r0
 c0468ea:	2800      	cmp	r0, #0
 c0468ec:	d183      	bne.n	c0467f6 <mbedcrypto__psa_key_derivation_output_bytes+0x32>
        status = psa_mac_sign_finish( &hkdf->hmac,
 c0468ee:	2240      	movs	r2, #64	@ 0x40
 c0468f0:	4640      	mov	r0, r8
 c0468f2:	9900      	ldr	r1, [sp, #0]
 c0468f4:	ab03      	add	r3, sp, #12
 c0468f6:	f7ff f8c1 	bl	c045a7c <mbedcrypto__psa_mac_sign_finish>
        if( status != PSA_SUCCESS )
 c0468fa:	4605      	mov	r5, r0
 c0468fc:	2800      	cmp	r0, #0
 c0468fe:	d0bb      	beq.n	c046878 <mbedcrypto__psa_key_derivation_output_bytes+0xb4>
 c046900:	e779      	b.n	c0467f6 <mbedcrypto__psa_key_derivation_output_bytes+0x32>
    uint8_t hash_length = PSA_HASH_LENGTH( hash_alg );
 c046902:	f04f 0910 	mov.w	r9, #16
 c046906:	e7a2      	b.n	c04684e <mbedcrypto__psa_key_derivation_output_bytes+0x8a>
 c046908:	f04f 0900 	mov.w	r9, #0
 c04690c:	e79f      	b.n	c04684e <mbedcrypto__psa_key_derivation_output_bytes+0x8a>
            status = psa_mac_update( &hkdf->hmac,
 c04690e:	464a      	mov	r2, r9
 c046910:	4640      	mov	r0, r8
 c046912:	9900      	ldr	r1, [sp, #0]
 c046914:	f7ff f89e 	bl	c045a54 <mbedcrypto__psa_mac_update>
            if( status != PSA_SUCCESS )
 c046918:	4605      	mov	r5, r0
 c04691a:	2800      	cmp	r0, #0
 c04691c:	d0d6      	beq.n	c0468cc <mbedcrypto__psa_key_derivation_output_bytes+0x108>
 c04691e:	e76a      	b.n	c0467f6 <mbedcrypto__psa_key_derivation_output_bytes+0x32>
    if( PSA_ALG_IS_TLS12_PRF( kdf_alg ) ||
 c046920:	4a2d      	ldr	r2, [pc, #180]	@ (c0469d8 <mbedcrypto__psa_key_derivation_output_bytes+0x214>)
 c046922:	f426 73ff 	bic.w	r3, r6, #510	@ 0x1fe
 c046926:	f023 0301 	bic.w	r3, r3, #1
 c04692a:	4293      	cmp	r3, r2
 c04692c:	f47f af70 	bne.w	c046810 <mbedcrypto__psa_key_derivation_output_bytes+0x4c>
    uint8_t hash_length = PSA_HASH_LENGTH( hash_alg );
 c046930:	4a27      	ldr	r2, [pc, #156]	@ (c0469d0 <mbedcrypto__psa_key_derivation_output_bytes+0x20c>)
    psa_algorithm_t hash_alg = PSA_ALG_TLS12_PRF_GET_HASH( alg );
 c046932:	b2f3      	uxtb	r3, r6
 c046934:	f043 7300 	orr.w	r3, r3, #33554432	@ 0x2000000
    uint8_t hash_length = PSA_HASH_LENGTH( hash_alg );
 c046938:	4293      	cmp	r3, r2
 c04693a:	d00f      	beq.n	c04695c <mbedcrypto__psa_key_derivation_output_bytes+0x198>
 c04693c:	f103 437e 	add.w	r3, r3, #4261412864	@ 0xfe000000
 c046940:	3b02      	subs	r3, #2
 c046942:	2b11      	cmp	r3, #17
 c046944:	d80d      	bhi.n	c046962 <mbedcrypto__psa_key_derivation_output_bytes+0x19e>
 c046946:	4a25      	ldr	r2, [pc, #148]	@ (c0469dc <mbedcrypto__psa_key_derivation_output_bytes+0x218>)
 c046948:	f812 a003 	ldrb.w	sl, [r2, r3]
    switch( tls12_prf->state )
 c04694c:	7ca2      	ldrb	r2, [r4, #18]
 c04694e:	2a03      	cmp	r2, #3
 c046950:	d00a      	beq.n	c046968 <mbedcrypto__psa_key_derivation_output_bytes+0x1a4>
 c046952:	2a04      	cmp	r2, #4
 c046954:	d00a      	beq.n	c04696c <mbedcrypto__psa_key_derivation_output_bytes+0x1a8>
            return( PSA_ERROR_BAD_STATE );
 c046956:	f06f 0588 	mvn.w	r5, #136	@ 0x88
 c04695a:	e74c      	b.n	c0467f6 <mbedcrypto__psa_key_derivation_output_bytes+0x32>
    uint8_t hash_length = PSA_HASH_LENGTH( hash_alg );
 c04695c:	f04f 0a10 	mov.w	sl, #16
 c046960:	e7f4      	b.n	c04694c <mbedcrypto__psa_key_derivation_output_bytes+0x188>
 c046962:	f04f 0a00 	mov.w	sl, #0
 c046966:	e7f1      	b.n	c04694c <mbedcrypto__psa_key_derivation_output_bytes+0x188>
            tls12_prf->state = PSA_TLS12_PRF_STATE_OUTPUT;
 c046968:	2204      	movs	r2, #4
 c04696a:	74a2      	strb	r2, [r4, #18]
        status = psa_key_derivation_tls12_prf_read( &operation->ctx.tls12_prf,
 c04696c:	46b8      	mov	r8, r7
 c04696e:	f104 0310 	add.w	r3, r4, #16
 c046972:	f8dd 9004 	ldr.w	r9, [sp, #4]
 c046976:	9300      	str	r3, [sp, #0]
        memcpy( output, tls12_prf->output_block + offset, length );
 c046978:	f104 0b6c 	add.w	fp, r4, #108	@ 0x6c
    while( output_length != 0 )
 c04697c:	f1b8 0f00 	cmp.w	r8, #0
 c046980:	d101      	bne.n	c046986 <mbedcrypto__psa_key_derivation_output_bytes+0x1c2>
        return( PSA_ERROR_INSUFFICIENT_DATA );
 c046982:	2500      	movs	r5, #0
 c046984:	e746      	b.n	c046814 <mbedcrypto__psa_key_derivation_output_bytes+0x50>
        if( tls12_prf->left_in_block == 0 )
 c046986:	7c21      	ldrb	r1, [r4, #16]
 c046988:	b941      	cbnz	r1, c04699c <mbedcrypto__psa_key_derivation_output_bytes+0x1d8>
            status = psa_key_derivation_tls12_prf_generate_next_block( tls12_prf,
 c04698a:	4631      	mov	r1, r6
 c04698c:	9800      	ldr	r0, [sp, #0]
 c04698e:	f7ff f8a3 	bl	c045ad8 <psa_key_derivation_tls12_prf_generate_next_block>
            if( status != PSA_SUCCESS )
 c046992:	4605      	mov	r5, r0
 c046994:	2800      	cmp	r0, #0
 c046996:	f47f af2e 	bne.w	c0467f6 <mbedcrypto__psa_key_derivation_output_bytes+0x32>
 c04699a:	e7f4      	b.n	c046986 <mbedcrypto__psa_key_derivation_output_bytes+0x1c2>
        if( tls12_prf->left_in_block > output_length )
 c04699c:	4541      	cmp	r1, r8
        if( tls12_prf->left_in_block == 0 )
 c04699e:	bf94      	ite	ls
 c0469a0:	460d      	movls	r5, r1
            length = (uint8_t) output_length;
 c0469a2:	fa5f f588 	uxtbhi.w	r5, r8
        offset = hash_length - tls12_prf->left_in_block;
 c0469a6:	ebaa 0101 	sub.w	r1, sl, r1
        memcpy( output, tls12_prf->output_block + offset, length );
 c0469aa:	462a      	mov	r2, r5
 c0469ac:	4648      	mov	r0, r9
 c0469ae:	fa5b f181 	uxtab	r1, fp, r1
 c0469b2:	f014 fe4b 	bl	c05b64c <memcpy>
        tls12_prf->left_in_block -= length;
 c0469b6:	7c22      	ldrb	r2, [r4, #16]
        output += length;
 c0469b8:	44a9      	add	r9, r5
        tls12_prf->left_in_block -= length;
 c0469ba:	1b52      	subs	r2, r2, r5
        output_length -= length;
 c0469bc:	eba8 0805 	sub.w	r8, r8, r5
        tls12_prf->left_in_block -= length;
 c0469c0:	7422      	strb	r2, [r4, #16]
 c0469c2:	e7db      	b.n	c04697c <mbedcrypto__psa_key_derivation_output_bytes+0x1b8>
        return( PSA_ERROR_INSUFFICIENT_DATA );
 c0469c4:	f06f 058e 	mvn.w	r5, #142	@ 0x8e
 c0469c8:	e724      	b.n	c046814 <mbedcrypto__psa_key_derivation_output_bytes+0x50>
 c0469ca:	bf00      	nop
 c0469cc:	08000100 	.word	0x08000100
 c0469d0:	02000001 	.word	0x02000001
 c0469d4:	0c060e58 	.word	0x0c060e58
 c0469d8:	08000200 	.word	0x08000200
 c0469dc:	0c060e58 	.word	0x0c060e58

0c0469e0 <mbedcrypto__psa_key_derivation_output_key>:
    psa_key_slot_t *slot = NULL;
 c0469e0:	2300      	movs	r3, #0
{
 c0469e2:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 c0469e6:	b095      	sub	sp, #84	@ 0x54
    psa_se_drv_table_entry_t *driver = NULL;
 c0469e8:	e9cd 3305 	strd	r3, r3, [sp, #20]
    *key = MBEDTLS_SVC_KEY_ID_INIT;
 c0469ec:	e9c2 3300 	strd	r3, r3, [r2]
    if( psa_get_key_bits( attributes ) == 0 )
 c0469f0:	8843      	ldrh	r3, [r0, #2]
{
 c0469f2:	4606      	mov	r6, r0
 c0469f4:	4689      	mov	r9, r1
 c0469f6:	4617      	mov	r7, r2
    if( psa_get_key_bits( attributes ) == 0 )
 c0469f8:	2b00      	cmp	r3, #0
 c0469fa:	d06c      	beq.n	c046ad6 <mbedcrypto__psa_key_derivation_output_key+0xf6>
    if( operation->alg == PSA_ALG_NONE )
 c0469fc:	680b      	ldr	r3, [r1, #0]
 c0469fe:	2b00      	cmp	r3, #0
 c046a00:	d06c      	beq.n	c046adc <mbedcrypto__psa_key_derivation_output_key+0xfc>
    if( ! operation->can_output_key )
 c046a02:	790b      	ldrb	r3, [r1, #4]
 c046a04:	07da      	lsls	r2, r3, #31
 c046a06:	d56c      	bpl.n	c046ae2 <mbedcrypto__psa_key_derivation_output_key+0x102>
    status = psa_start_key_creation( PSA_KEY_CREATION_DERIVE, attributes,
 c046a08:	4601      	mov	r1, r0
 c046a0a:	ab06      	add	r3, sp, #24
 c046a0c:	2002      	movs	r0, #2
 c046a0e:	aa05      	add	r2, sp, #20
 c046a10:	f7fe fa88 	bl	c044f24 <psa_start_key_creation>
    if( driver != NULL )
 c046a14:	9b06      	ldr	r3, [sp, #24]
    status = psa_start_key_creation( PSA_KEY_CREATION_DERIVE, attributes,
 c046a16:	4604      	mov	r4, r0
    if( driver != NULL )
 c046a18:	2b00      	cmp	r3, #0
 c046a1a:	d159      	bne.n	c046ad0 <mbedcrypto__psa_key_derivation_output_key+0xf0>
        status = psa_generate_derived_key_internal( slot,
 c046a1c:	9d05      	ldr	r5, [sp, #20]
    if( status == PSA_SUCCESS )
 c046a1e:	b958      	cbnz	r0, c046a38 <mbedcrypto__psa_key_derivation_output_key+0x58>
                                                    attributes->core.bits,
 c046a20:	8872      	ldrh	r2, [r6, #2]
    if( ! key_type_is_raw_bytes( slot->attr.type ) )
 c046a22:	8828      	ldrh	r0, [r5, #0]
    size_t bytes = PSA_BITS_TO_BYTES( bits );
 c046a24:	f102 0807 	add.w	r8, r2, #7
 c046a28:	9207      	str	r2, [sp, #28]
 c046a2a:	ea4f 08d8 	mov.w	r8, r8, lsr #3
    if( ! key_type_is_raw_bytes( slot->attr.type ) )
 c046a2e:	f7fd f997 	bl	c043d60 <key_type_is_raw_bytes>
 c046a32:	b928      	cbnz	r0, c046a40 <mbedcrypto__psa_key_derivation_output_key+0x60>
        return( PSA_ERROR_INVALID_ARGUMENT );
 c046a34:	f06f 0486 	mvn.w	r4, #134	@ 0x86
        psa_fail_key_creation( slot, driver );
 c046a38:	9805      	ldr	r0, [sp, #20]
 c046a3a:	f7fe fb74 	bl	c045126 <psa_fail_key_creation.constprop.0>
 c046a3e:	e043      	b.n	c046ac8 <mbedcrypto__psa_key_derivation_output_key+0xe8>
    if( bits % 8 != 0 )
 c046a40:	0753      	lsls	r3, r2, #29
 c046a42:	d1f7      	bne.n	c046a34 <mbedcrypto__psa_key_derivation_output_key+0x54>
    data = mbedtls_calloc( 1, bytes );
 c046a44:	4641      	mov	r1, r8
 c046a46:	2001      	movs	r0, #1
 c046a48:	f7f4 fcac 	bl	c03b3a4 <mbedtls_calloc>
    if( data == NULL )
 c046a4c:	4606      	mov	r6, r0
 c046a4e:	b910      	cbnz	r0, c046a56 <mbedcrypto__psa_key_derivation_output_key+0x76>
        return( PSA_ERROR_INSUFFICIENT_MEMORY );
 c046a50:	f06f 048c 	mvn.w	r4, #140	@ 0x8c
 c046a54:	e7f0      	b.n	c046a38 <mbedcrypto__psa_key_derivation_output_key+0x58>
    status = psa_key_derivation_output_bytes( operation, data, bytes );
 c046a56:	4601      	mov	r1, r0
 c046a58:	4642      	mov	r2, r8
 c046a5a:	4648      	mov	r0, r9
 c046a5c:	f7ff feb2 	bl	c0467c4 <mbedcrypto__psa_key_derivation_output_bytes>
    if( status != PSA_SUCCESS )
 c046a60:	4604      	mov	r4, r0
 c046a62:	bb20      	cbnz	r0, c046aae <mbedcrypto__psa_key_derivation_output_key+0xce>
    status = psa_allocate_buffer_to_slot( slot, bytes );
 c046a64:	4641      	mov	r1, r8
 c046a66:	4628      	mov	r0, r5
 c046a68:	f7fe fa35 	bl	c044ed6 <psa_allocate_buffer_to_slot>
    if( status != PSA_SUCCESS )
 c046a6c:	4604      	mov	r4, r0
 c046a6e:	b9f0      	cbnz	r0, c046aae <mbedcrypto__psa_key_derivation_output_key+0xce>
    attributes.core = slot->attr;
 c046a70:	46ac      	mov	ip, r5
    slot->attr.bits = (psa_key_bits_t) bits;
 c046a72:	9b07      	ldr	r3, [sp, #28]
    attributes.core = slot->attr;
 c046a74:	ac08      	add	r4, sp, #32
    slot->attr.bits = (psa_key_bits_t) bits;
 c046a76:	806b      	strh	r3, [r5, #2]
    attributes.core = slot->attr;
 c046a78:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 c046a7c:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 c046a7e:	e89c 000f 	ldmia.w	ip, {r0, r1, r2, r3}
 c046a82:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
    status = psa_driver_wrapper_import_key( &attributes,
 c046a86:	ab07      	add	r3, sp, #28
 c046a88:	9302      	str	r3, [sp, #8]
 c046a8a:	f105 0328 	add.w	r3, r5, #40	@ 0x28
 c046a8e:	9301      	str	r3, [sp, #4]
 c046a90:	6aab      	ldr	r3, [r5, #40]	@ 0x28
 c046a92:	4642      	mov	r2, r8
 c046a94:	9300      	str	r3, [sp, #0]
 c046a96:	6a6b      	ldr	r3, [r5, #36]	@ 0x24
 c046a98:	4631      	mov	r1, r6
 c046a9a:	a808      	add	r0, sp, #32
 c046a9c:	f000 ff1a 	bl	c0478d4 <psa_driver_wrapper_import_key>
    if( bits != slot->attr.bits )
 c046aa0:	886a      	ldrh	r2, [r5, #2]
 c046aa2:	9b07      	ldr	r3, [sp, #28]
        status = PSA_ERROR_INVALID_ARGUMENT;
 c046aa4:	429a      	cmp	r2, r3
 c046aa6:	bf0c      	ite	eq
 c046aa8:	4604      	moveq	r4, r0
 c046aaa:	f06f 0486 	mvnne.w	r4, #134	@ 0x86
    mbedtls_free( data );
 c046aae:	4630      	mov	r0, r6
 c046ab0:	f7f4 fc7e 	bl	c03b3b0 <mbedtls_free>
    if( status == PSA_SUCCESS )
 c046ab4:	2c00      	cmp	r4, #0
 c046ab6:	d1bf      	bne.n	c046a38 <mbedcrypto__psa_key_derivation_output_key+0x58>
        status = psa_finish_key_creation( slot, driver, key );
 c046ab8:	e9dd 0105 	ldrd	r0, r1, [sp, #20]
 c046abc:	463a      	mov	r2, r7
 c046abe:	f7fd fc9d 	bl	c0443fc <psa_finish_key_creation>
    if( status != PSA_SUCCESS )
 c046ac2:	4604      	mov	r4, r0
 c046ac4:	2800      	cmp	r0, #0
 c046ac6:	d1b7      	bne.n	c046a38 <mbedcrypto__psa_key_derivation_output_key+0x58>
}
 c046ac8:	4620      	mov	r0, r4
 c046aca:	b015      	add	sp, #84	@ 0x54
 c046acc:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        status = PSA_ERROR_NOT_SUPPORTED;
 c046ad0:	f06f 0485 	mvn.w	r4, #133	@ 0x85
 c046ad4:	e7b0      	b.n	c046a38 <mbedcrypto__psa_key_derivation_output_key+0x58>
        return( PSA_ERROR_INVALID_ARGUMENT );
 c046ad6:	f06f 0486 	mvn.w	r4, #134	@ 0x86
 c046ada:	e7f5      	b.n	c046ac8 <mbedcrypto__psa_key_derivation_output_key+0xe8>
        return( PSA_ERROR_BAD_STATE );
 c046adc:	f06f 0488 	mvn.w	r4, #136	@ 0x88
 c046ae0:	e7f2      	b.n	c046ac8 <mbedcrypto__psa_key_derivation_output_key+0xe8>
        return( PSA_ERROR_NOT_PERMITTED );
 c046ae2:	f06f 0484 	mvn.w	r4, #132	@ 0x84
 c046ae6:	e7ef      	b.n	c046ac8 <mbedcrypto__psa_key_derivation_output_key+0xe8>

0c046ae8 <mbedcrypto__psa_key_derivation_setup>:
{
 c046ae8:	b538      	push	{r3, r4, r5, lr}
    if( operation->alg != 0 )
 c046aea:	6803      	ldr	r3, [r0, #0]
{
 c046aec:	4605      	mov	r5, r0
 c046aee:	460c      	mov	r4, r1
    if( operation->alg != 0 )
 c046af0:	b9b3      	cbnz	r3, c046b20 <mbedcrypto__psa_key_derivation_setup+0x38>
    if( PSA_ALG_IS_RAW_KEY_AGREEMENT( alg ) )
 c046af2:	f001 43fe 	and.w	r3, r1, #2130706432	@ 0x7f000000
 c046af6:	f1b3 6f10 	cmp.w	r3, #150994944	@ 0x9000000
 c046afa:	d10b      	bne.n	c046b14 <mbedcrypto__psa_key_derivation_setup+0x2c>
 c046afc:	f021 611f 	bic.w	r1, r1, #166723584	@ 0x9f00000
 c046b00:	f421 2170 	bic.w	r1, r1, #983040	@ 0xf0000
 c046b04:	b149      	cbz	r1, c046b1a <mbedcrypto__psa_key_derivation_setup+0x32>
        status = psa_key_derivation_setup_kdf( operation, kdf_alg );
 c046b06:	f041 6100 	orr.w	r1, r1, #134217728	@ 0x8000000
        status = psa_key_derivation_setup_kdf( operation, alg );
 c046b0a:	f7fd fbe7 	bl	c0442dc <psa_key_derivation_setup_kdf>
    if( status == PSA_SUCCESS )
 c046b0e:	b900      	cbnz	r0, c046b12 <mbedcrypto__psa_key_derivation_setup+0x2a>
        operation->alg = alg;
 c046b10:	602c      	str	r4, [r5, #0]
}
 c046b12:	bd38      	pop	{r3, r4, r5, pc}
    else if( PSA_ALG_IS_KEY_DERIVATION( alg ) )
 c046b14:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
 c046b18:	d0f7      	beq.n	c046b0a <mbedcrypto__psa_key_derivation_setup+0x22>
        return( PSA_ERROR_INVALID_ARGUMENT );
 c046b1a:	f06f 0086 	mvn.w	r0, #134	@ 0x86
 c046b1e:	e7f8      	b.n	c046b12 <mbedcrypto__psa_key_derivation_setup+0x2a>
        return( PSA_ERROR_BAD_STATE );
 c046b20:	f06f 0088 	mvn.w	r0, #136	@ 0x88
 c046b24:	e7f5      	b.n	c046b12 <mbedcrypto__psa_key_derivation_setup+0x2a>

0c046b26 <mbedcrypto__psa_key_derivation_input_bytes>:
{
 c046b26:	b507      	push	{r0, r1, r2, lr}
    return( psa_key_derivation_input_internal( operation, step,
 c046b28:	9300      	str	r3, [sp, #0]
 c046b2a:	4613      	mov	r3, r2
 c046b2c:	2200      	movs	r2, #0
 c046b2e:	f7ff fd5d 	bl	c0465ec <psa_key_derivation_input_internal>
}
 c046b32:	b003      	add	sp, #12
 c046b34:	f85d fb04 	ldr.w	pc, [sp], #4

0c046b38 <mbedcrypto__psa_key_derivation_input_key>:
{
 c046b38:	b570      	push	{r4, r5, r6, lr}
 c046b3a:	b086      	sub	sp, #24
 c046b3c:	460e      	mov	r6, r1
 c046b3e:	a902      	add	r1, sp, #8
 c046b40:	e881 000c 	stmia.w	r1, {r2, r3}
    status = psa_get_and_lock_transparent_key_slot_with_policy(
 c046b44:	6803      	ldr	r3, [r0, #0]
{
 c046b46:	4604      	mov	r4, r0
    status = psa_get_and_lock_transparent_key_slot_with_policy(
 c046b48:	9300      	str	r3, [sp, #0]
 c046b4a:	aa05      	add	r2, sp, #20
 c046b4c:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
 c046b50:	c903      	ldmia	r1, {r0, r1}
 c046b52:	f7fd fe53 	bl	c0447fc <psa_get_and_lock_transparent_key_slot_with_policy>
    if( status != PSA_SUCCESS )
 c046b56:	4605      	mov	r5, r0
 c046b58:	b128      	cbz	r0, c046b66 <mbedcrypto__psa_key_derivation_input_key+0x2e>
        psa_key_derivation_abort( operation );
 c046b5a:	4620      	mov	r0, r4
 c046b5c:	f7ff fcf8 	bl	c046550 <mbedcrypto__psa_key_derivation_abort>
}
 c046b60:	4628      	mov	r0, r5
 c046b62:	b006      	add	sp, #24
 c046b64:	bd70      	pop	{r4, r5, r6, pc}
    if( step == PSA_KEY_DERIVATION_INPUT_SECRET )
 c046b66:	f240 1301 	movw	r3, #257	@ 0x101
 c046b6a:	429e      	cmp	r6, r3
        operation->can_output_key = 1;
 c046b6c:	bf08      	it	eq
 c046b6e:	7923      	ldrbeq	r3, [r4, #4]
    status = psa_key_derivation_input_internal( operation,
 c046b70:	4620      	mov	r0, r4
        operation->can_output_key = 1;
 c046b72:	bf04      	itt	eq
 c046b74:	f043 0301 	orreq.w	r3, r3, #1
 c046b78:	7123      	strbeq	r3, [r4, #4]
                                                step, slot->attr.type,
 c046b7a:	9b05      	ldr	r3, [sp, #20]
    status = psa_key_derivation_input_internal( operation,
 c046b7c:	6a99      	ldr	r1, [r3, #40]	@ 0x28
 c046b7e:	881a      	ldrh	r2, [r3, #0]
 c046b80:	9100      	str	r1, [sp, #0]
 c046b82:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 c046b84:	4631      	mov	r1, r6
 c046b86:	f7ff fd31 	bl	c0465ec <psa_key_derivation_input_internal>
 c046b8a:	4604      	mov	r4, r0
    unlock_status = psa_unlock_key_slot( slot );
 c046b8c:	9805      	ldr	r0, [sp, #20]
 c046b8e:	f002 fa91 	bl	c0490b4 <psa_unlock_key_slot>
    return( ( status == PSA_SUCCESS ) ? unlock_status : status );
 c046b92:	2c00      	cmp	r4, #0
 c046b94:	bf14      	ite	ne
 c046b96:	4625      	movne	r5, r4
 c046b98:	4605      	moveq	r5, r0
 c046b9a:	e7e1      	b.n	c046b60 <mbedcrypto__psa_key_derivation_input_key+0x28>

0c046b9c <mbedcrypto__psa_key_derivation_key_agreement>:
psa_status_t psa_key_derivation_key_agreement( psa_key_derivation_operation_t *operation,
                                               psa_key_derivation_step_t step,
                                               mbedtls_svc_key_id_t private_key,
                                               const uint8_t *peer_key,
                                               size_t peer_key_length )
{
 c046b9c:	b5f0      	push	{r4, r5, r6, r7, lr}
 c046b9e:	b09b      	sub	sp, #108	@ 0x6c
 c046ba0:	460e      	mov	r6, r1
 c046ba2:	a904      	add	r1, sp, #16
 c046ba4:	e881 000c 	stmia.w	r1, {r2, r3}
    psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
    psa_status_t unlock_status = PSA_ERROR_CORRUPTION_DETECTED;
    psa_key_slot_t *slot;

    if( ! PSA_ALG_IS_KEY_AGREEMENT( operation->alg ) )
 c046ba8:	6803      	ldr	r3, [r0, #0]
{
 c046baa:	4605      	mov	r5, r0
    if( ! PSA_ALG_IS_KEY_AGREEMENT( operation->alg ) )
 c046bac:	f003 42fe 	and.w	r2, r3, #2130706432	@ 0x7f000000
 c046bb0:	f1b2 6f10 	cmp.w	r2, #150994944	@ 0x9000000
 c046bb4:	d13d      	bne.n	c046c32 <mbedcrypto__psa_key_derivation_key_agreement+0x96>
        return( PSA_ERROR_INVALID_ARGUMENT );
    status = psa_get_and_lock_transparent_key_slot_with_policy(
 c046bb6:	9300      	str	r3, [sp, #0]
 c046bb8:	aa07      	add	r2, sp, #28
 c046bba:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
 c046bbe:	c903      	ldmia	r1, {r0, r1}
 c046bc0:	f7fd fe1c 	bl	c0447fc <psa_get_and_lock_transparent_key_slot_with_policy>
                 private_key, &slot, PSA_KEY_USAGE_DERIVE, operation->alg );
    if( status != PSA_SUCCESS )
 c046bc4:	bb50      	cbnz	r0, c046c1c <mbedcrypto__psa_key_derivation_key_agreement+0x80>
    psa_algorithm_t ka_alg = PSA_ALG_KEY_AGREEMENT_GET_BASE( operation->alg );
 c046bc6:	682b      	ldr	r3, [r5, #0]
    size_t shared_secret_length = 0;
 c046bc8:	9008      	str	r0, [sp, #32]
    psa_algorithm_t ka_alg = PSA_ALG_KEY_AGREEMENT_GET_BASE( operation->alg );
 c046bca:	481b      	ldr	r0, [pc, #108]	@ (c046c38 <mbedcrypto__psa_key_derivation_key_agreement+0x9c>)
    status = psa_key_agreement_raw_internal( ka_alg,
 c046bcc:	af09      	add	r7, sp, #36	@ 0x24
    psa_algorithm_t ka_alg = PSA_ALG_KEY_AGREEMENT_GET_BASE( operation->alg );
 c046bce:	4018      	ands	r0, r3
    status = psa_key_agreement_raw_internal( ka_alg,
 c046bd0:	ab08      	add	r3, sp, #32
 c046bd2:	9302      	str	r3, [sp, #8]
 c046bd4:	2342      	movs	r3, #66	@ 0x42
 c046bd6:	9907      	ldr	r1, [sp, #28]
 c046bd8:	9301      	str	r3, [sp, #4]
 c046bda:	9700      	str	r7, [sp, #0]
 c046bdc:	f040 6010 	orr.w	r0, r0, #150994944	@ 0x9000000
 c046be0:	e9dd 2320 	ldrd	r2, r3, [sp, #128]	@ 0x80
 c046be4:	f7fe f8f0 	bl	c044dc8 <psa_key_agreement_raw_internal>
    if( status != PSA_SUCCESS )
 c046be8:	4604      	mov	r4, r0
 c046bea:	b948      	cbnz	r0, c046c00 <mbedcrypto__psa_key_derivation_key_agreement+0x64>
    status = psa_key_derivation_input_internal( operation, step,
 c046bec:	9b08      	ldr	r3, [sp, #32]
 c046bee:	f44f 5290 	mov.w	r2, #4608	@ 0x1200
 c046bf2:	9300      	str	r3, [sp, #0]
 c046bf4:	4631      	mov	r1, r6
 c046bf6:	463b      	mov	r3, r7
 c046bf8:	4628      	mov	r0, r5
 c046bfa:	f7ff fcf7 	bl	c0465ec <psa_key_derivation_input_internal>
 c046bfe:	4604      	mov	r4, r0
    mbedtls_platform_zeroize( shared_secret, shared_secret_length );
 c046c00:	4638      	mov	r0, r7
 c046c02:	9908      	ldr	r1, [sp, #32]
 c046c04:	f7f4 fbe4 	bl	c03b3d0 <mbedtls_platform_zeroize>
        return( status );
    status = psa_key_agreement_internal( operation, step,
                                         slot,
                                         peer_key, peer_key_length );
    if( status != PSA_SUCCESS )
 c046c08:	b154      	cbz	r4, c046c20 <mbedcrypto__psa_key_derivation_key_agreement+0x84>
        psa_key_derivation_abort( operation );
 c046c0a:	4628      	mov	r0, r5
 c046c0c:	f7ff fca0 	bl	c046550 <mbedcrypto__psa_key_derivation_abort>
         * key material to be used as a key in PSA Crypto. */
        if( step == PSA_KEY_DERIVATION_INPUT_SECRET )
            operation->can_output_key = 1;
    }

    unlock_status = psa_unlock_key_slot( slot );
 c046c10:	9807      	ldr	r0, [sp, #28]
 c046c12:	f002 fa4f 	bl	c0490b4 <psa_unlock_key_slot>

    return( ( status == PSA_SUCCESS ) ? unlock_status : status );
 c046c16:	2c00      	cmp	r4, #0
 c046c18:	bf18      	it	ne
 c046c1a:	4620      	movne	r0, r4
}
 c046c1c:	b01b      	add	sp, #108	@ 0x6c
 c046c1e:	bdf0      	pop	{r4, r5, r6, r7, pc}
        if( step == PSA_KEY_DERIVATION_INPUT_SECRET )
 c046c20:	f240 1301 	movw	r3, #257	@ 0x101
 c046c24:	429e      	cmp	r6, r3
            operation->can_output_key = 1;
 c046c26:	bf02      	ittt	eq
 c046c28:	792b      	ldrbeq	r3, [r5, #4]
 c046c2a:	f043 0301 	orreq.w	r3, r3, #1
 c046c2e:	712b      	strbeq	r3, [r5, #4]
 c046c30:	e7ee      	b.n	c046c10 <mbedcrypto__psa_key_derivation_key_agreement+0x74>
        return( PSA_ERROR_INVALID_ARGUMENT );
 c046c32:	f06f 0086 	mvn.w	r0, #134	@ 0x86
 c046c36:	e7f1      	b.n	c046c1c <mbedcrypto__psa_key_derivation_key_agreement+0x80>
 c046c38:	f6ff0000 	.word	0xf6ff0000

0c046c3c <mbedcrypto__psa_generate_random>:
#endif /* MBEDTLS_PSA_CRYPTO_EXTERNAL_RNG */
}

psa_status_t psa_generate_random( uint8_t *output,
                                  size_t output_size )
{
 c046c3c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    GUARD_MODULE_INITIALIZED;
 c046c3e:	4e10      	ldr	r6, [pc, #64]	@ (c046c80 <mbedcrypto__psa_generate_random+0x44>)
{
 c046c40:	4605      	mov	r5, r0
    GUARD_MODULE_INITIALIZED;
 c046c42:	7833      	ldrb	r3, [r6, #0]
{
 c046c44:	460c      	mov	r4, r1
    GUARD_MODULE_INITIALIZED;
 c046c46:	07db      	lsls	r3, r3, #31
 c046c48:	d517      	bpl.n	c046c7a <mbedcrypto__psa_generate_random+0x3e>
    {
        size_t request_size =
            ( output_size > MBEDTLS_PSA_RANDOM_MAX_REQUEST ?
              MBEDTLS_PSA_RANDOM_MAX_REQUEST :
              output_size );
        int ret = mbedtls_psa_get_random( MBEDTLS_PSA_RANDOM_STATE,
 c046c4a:	f506 7622 	add.w	r6, r6, #648	@ 0x288
    while( output_size > 0 )
 c046c4e:	b90c      	cbnz	r4, c046c54 <mbedcrypto__psa_generate_random+0x18>
        if( ret != 0 )
            return( mbedtls_to_psa_error( ret ) );
        output_size -= request_size;
        output += request_size;
    }
    return( PSA_SUCCESS );
 c046c50:	4620      	mov	r0, r4
#endif /* MBEDTLS_PSA_CRYPTO_EXTERNAL_RNG */
}
 c046c52:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        size_t request_size =
 c046c54:	f5b4 6f80 	cmp.w	r4, #1024	@ 0x400
 c046c58:	4627      	mov	r7, r4
 c046c5a:	bf28      	it	cs
 c046c5c:	f44f 6780 	movcs.w	r7, #1024	@ 0x400
        int ret = mbedtls_psa_get_random( MBEDTLS_PSA_RANDOM_STATE,
 c046c60:	4629      	mov	r1, r5
 c046c62:	463a      	mov	r2, r7
 c046c64:	4630      	mov	r0, r6
 c046c66:	f00f f87d 	bl	c055d64 <mbedtls_ctr_drbg_random>
        if( ret != 0 )
 c046c6a:	b118      	cbz	r0, c046c74 <mbedcrypto__psa_generate_random+0x38>
}
 c046c6c:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
            return( mbedtls_to_psa_error( ret ) );
 c046c70:	f7fd be26 	b.w	c0448c0 <mbedtls_to_psa_error>
        output_size -= request_size;
 c046c74:	1be4      	subs	r4, r4, r7
        output += request_size;
 c046c76:	443d      	add	r5, r7
 c046c78:	e7e9      	b.n	c046c4e <mbedcrypto__psa_generate_random+0x12>
    GUARD_MODULE_INITIALIZED;
 c046c7a:	f06f 0088 	mvn.w	r0, #136	@ 0x88
 c046c7e:	e7e8      	b.n	c046c52 <mbedcrypto__psa_generate_random+0x16>
 c046c80:	30030f00 	.word	0x30030f00

0c046c84 <mbedcrypto__psa_cipher_generate_iv>:
{
 c046c84:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
 c046c88:	461f      	mov	r7, r3
    if( operation->id == 0 )
 c046c8a:	6803      	ldr	r3, [r0, #0]
{
 c046c8c:	4605      	mov	r5, r0
 c046c8e:	4688      	mov	r8, r1
    if( operation->id == 0 )
 c046c90:	b323      	cbz	r3, c046cdc <mbedcrypto__psa_cipher_generate_iv+0x58>
    if( operation->iv_set || ! operation->iv_required )
 c046c92:	7903      	ldrb	r3, [r0, #4]
 c046c94:	f003 0303 	and.w	r3, r3, #3
 c046c98:	2b01      	cmp	r3, #1
 c046c9a:	d11f      	bne.n	c046cdc <mbedcrypto__psa_cipher_generate_iv+0x58>
    default_iv_length = operation->default_iv_length;
 c046c9c:	7946      	ldrb	r6, [r0, #5]
    if( iv_size < default_iv_length )
 c046c9e:	4296      	cmp	r6, r2
 c046ca0:	d824      	bhi.n	c046cec <mbedcrypto__psa_cipher_generate_iv+0x68>
    if( default_iv_length > PSA_CIPHER_IV_MAX_SIZE )
 c046ca2:	2e10      	cmp	r6, #16
 c046ca4:	d825      	bhi.n	c046cf2 <mbedcrypto__psa_cipher_generate_iv+0x6e>
    status = psa_generate_random( local_iv, default_iv_length );
 c046ca6:	4631      	mov	r1, r6
 c046ca8:	4668      	mov	r0, sp
 c046caa:	f7ff ffc7 	bl	c046c3c <mbedcrypto__psa_generate_random>
    if( status != PSA_SUCCESS )
 c046cae:	4604      	mov	r4, r0
 c046cb0:	b9b0      	cbnz	r0, c046ce0 <mbedcrypto__psa_cipher_generate_iv+0x5c>
    status = psa_driver_wrapper_cipher_set_iv( operation,
 c046cb2:	4632      	mov	r2, r6
 c046cb4:	4669      	mov	r1, sp
 c046cb6:	4628      	mov	r0, r5
 c046cb8:	f000 fed9 	bl	c047a6e <psa_driver_wrapper_cipher_set_iv>
    if( status == PSA_SUCCESS )
 c046cbc:	4604      	mov	r4, r0
 c046cbe:	b978      	cbnz	r0, c046ce0 <mbedcrypto__psa_cipher_generate_iv+0x5c>
        memcpy( iv, local_iv, default_iv_length );
 c046cc0:	4632      	mov	r2, r6
 c046cc2:	4669      	mov	r1, sp
 c046cc4:	4640      	mov	r0, r8
 c046cc6:	f014 fcc1 	bl	c05b64c <memcpy>
        *iv_length = default_iv_length;
 c046cca:	603e      	str	r6, [r7, #0]
        operation->iv_set = 1;
 c046ccc:	792b      	ldrb	r3, [r5, #4]
 c046cce:	f043 0302 	orr.w	r3, r3, #2
 c046cd2:	712b      	strb	r3, [r5, #4]
}
 c046cd4:	4620      	mov	r0, r4
 c046cd6:	b004      	add	sp, #16
 c046cd8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        status = PSA_ERROR_BAD_STATE;
 c046cdc:	f06f 0488 	mvn.w	r4, #136	@ 0x88
        *iv_length = 0;
 c046ce0:	2300      	movs	r3, #0
        psa_cipher_abort( operation );
 c046ce2:	4628      	mov	r0, r5
        *iv_length = 0;
 c046ce4:	603b      	str	r3, [r7, #0]
        psa_cipher_abort( operation );
 c046ce6:	f7ff fa09 	bl	c0460fc <mbedcrypto__psa_cipher_abort>
    return( status );
 c046cea:	e7f3      	b.n	c046cd4 <mbedcrypto__psa_cipher_generate_iv+0x50>
        status = PSA_ERROR_BUFFER_TOO_SMALL;
 c046cec:	f06f 0489 	mvn.w	r4, #137	@ 0x89
 c046cf0:	e7f6      	b.n	c046ce0 <mbedcrypto__psa_cipher_generate_iv+0x5c>
        status = PSA_ERROR_GENERIC_ERROR;
 c046cf2:	f06f 0483 	mvn.w	r4, #131	@ 0x83
 c046cf6:	e7f3      	b.n	c046ce0 <mbedcrypto__psa_cipher_generate_iv+0x5c>

0c046cf8 <mbedcrypto__psa_raw_key_agreement>:
{
 c046cf8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 c046cfc:	4605      	mov	r5, r0
 c046cfe:	4699      	mov	r9, r3
    psa_key_slot_t *slot = NULL;
 c046d00:	2300      	movs	r3, #0
{
 c046d02:	b089      	sub	sp, #36	@ 0x24
    psa_key_slot_t *slot = NULL;
 c046d04:	9307      	str	r3, [sp, #28]
    if( ! PSA_ALG_IS_KEY_AGREEMENT( alg ) )
 c046d06:	f005 43fe 	and.w	r3, r5, #2130706432	@ 0x7f000000
{
 c046d0a:	a804      	add	r0, sp, #16
    if( ! PSA_ALG_IS_KEY_AGREEMENT( alg ) )
 c046d0c:	f1b3 6f10 	cmp.w	r3, #150994944	@ 0x9000000
{
 c046d10:	e880 0006 	stmia.w	r0, {r1, r2}
 c046d14:	e9dd 8611 	ldrd	r8, r6, [sp, #68]	@ 0x44
 c046d18:	9f13      	ldr	r7, [sp, #76]	@ 0x4c
    if( ! PSA_ALG_IS_KEY_AGREEMENT( alg ) )
 c046d1a:	d122      	bne.n	c046d62 <mbedcrypto__psa_raw_key_agreement+0x6a>
    status = psa_get_and_lock_transparent_key_slot_with_policy(
 c046d1c:	9500      	str	r5, [sp, #0]
 c046d1e:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
 c046d22:	c803      	ldmia	r0, {r0, r1}
 c046d24:	aa07      	add	r2, sp, #28
 c046d26:	f7fd fd69 	bl	c0447fc <psa_get_and_lock_transparent_key_slot_with_policy>
    if( status != PSA_SUCCESS )
 c046d2a:	4604      	mov	r4, r0
 c046d2c:	b958      	cbnz	r0, c046d46 <mbedcrypto__psa_raw_key_agreement+0x4e>
    status = psa_key_agreement_raw_internal( alg, slot,
 c046d2e:	464a      	mov	r2, r9
 c046d30:	4628      	mov	r0, r5
 c046d32:	e9cd 6701 	strd	r6, r7, [sp, #4]
 c046d36:	9b10      	ldr	r3, [sp, #64]	@ 0x40
 c046d38:	9907      	ldr	r1, [sp, #28]
 c046d3a:	f8cd 8000 	str.w	r8, [sp]
 c046d3e:	f7fe f843 	bl	c044dc8 <psa_key_agreement_raw_internal>
    if( status != PSA_SUCCESS )
 c046d42:	4604      	mov	r4, r0
 c046d44:	b120      	cbz	r0, c046d50 <mbedcrypto__psa_raw_key_agreement+0x58>
        psa_generate_random( output, output_size );
 c046d46:	4631      	mov	r1, r6
 c046d48:	4640      	mov	r0, r8
 c046d4a:	f7ff ff77 	bl	c046c3c <mbedcrypto__psa_generate_random>
        *output_length = output_size;
 c046d4e:	603e      	str	r6, [r7, #0]
    unlock_status = psa_unlock_key_slot( slot );
 c046d50:	9807      	ldr	r0, [sp, #28]
 c046d52:	f002 f9af 	bl	c0490b4 <psa_unlock_key_slot>
}
 c046d56:	2c00      	cmp	r4, #0
 c046d58:	bf18      	it	ne
 c046d5a:	4620      	movne	r0, r4
 c046d5c:	b009      	add	sp, #36	@ 0x24
 c046d5e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        status = PSA_ERROR_INVALID_ARGUMENT;
 c046d62:	f06f 0486 	mvn.w	r4, #134	@ 0x86
 c046d66:	e7ee      	b.n	c046d46 <mbedcrypto__psa_raw_key_agreement+0x4e>

0c046d68 <psa_generate_key_internal>:
}

psa_status_t psa_generate_key_internal(
    const psa_key_attributes_t *attributes,
    uint8_t *key_buffer, size_t key_buffer_size, size_t *key_buffer_length )
{
 c046d68:	b570      	push	{r4, r5, r6, lr}
 c046d6a:	461e      	mov	r6, r3
    psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
    psa_key_type_t type = attributes->core.type;

    if( ( attributes->domain_parameters == NULL ) &&
 c046d6c:	6a83      	ldr	r3, [r0, #40]	@ 0x28
{
 c046d6e:	460d      	mov	r5, r1
 c046d70:	4604      	mov	r4, r0
    psa_key_type_t type = attributes->core.type;
 c046d72:	8801      	ldrh	r1, [r0, #0]
    if( ( attributes->domain_parameters == NULL ) &&
 c046d74:	b90b      	cbnz	r3, c046d7a <psa_generate_key_internal+0x12>
 c046d76:	6ac3      	ldr	r3, [r0, #44]	@ 0x2c
 c046d78:	bb03      	cbnz	r3, c046dbc <psa_generate_key_internal+0x54>
        ( attributes->domain_parameters_size != 0 ) )
        return( PSA_ERROR_INVALID_ARGUMENT );

    if( key_type_is_raw_bytes( type ) )
 c046d7a:	4608      	mov	r0, r1
 c046d7c:	f7fc fff0 	bl	c043d60 <key_type_is_raw_bytes>
 c046d80:	b128      	cbz	r0, c046d8e <psa_generate_key_internal+0x26>
    {
        status = psa_generate_random( key_buffer, key_buffer_size );
 c046d82:	4628      	mov	r0, r5
        (void)key_buffer_length;
        return( PSA_ERROR_NOT_SUPPORTED );
    }

    return( PSA_SUCCESS );
}
 c046d84:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        status = psa_generate_random( key_buffer, key_buffer_size );
 c046d88:	4611      	mov	r1, r2
 c046d8a:	f7ff bf57 	b.w	c046c3c <mbedcrypto__psa_generate_random>
    if ( type == PSA_KEY_TYPE_RSA_KEY_PAIR )
 c046d8e:	f247 0301 	movw	r3, #28673	@ 0x7001
 c046d92:	4299      	cmp	r1, r3
 c046d94:	d106      	bne.n	c046da4 <psa_generate_key_internal+0x3c>
        return( mbedtls_psa_rsa_generate_key( attributes,
 c046d96:	4633      	mov	r3, r6
 c046d98:	4629      	mov	r1, r5
 c046d9a:	4620      	mov	r0, r4
}
 c046d9c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        return( mbedtls_psa_rsa_generate_key( attributes,
 c046da0:	f001 be18 	b.w	c0489d4 <mbedtls_psa_rsa_generate_key>
    if ( PSA_KEY_TYPE_IS_ECC( type ) && PSA_KEY_TYPE_IS_KEY_PAIR( type ) )
 c046da4:	f021 01ff 	bic.w	r1, r1, #255	@ 0xff
 c046da8:	f5b1 4fe2 	cmp.w	r1, #28928	@ 0x7100
 c046dac:	d109      	bne.n	c046dc2 <psa_generate_key_internal+0x5a>
        return( mbedtls_psa_ecp_generate_key( attributes,
 c046dae:	4633      	mov	r3, r6
 c046db0:	4629      	mov	r1, r5
 c046db2:	4620      	mov	r0, r4
}
 c046db4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        return( mbedtls_psa_ecp_generate_key( attributes,
 c046db8:	f001 b876 	b.w	c047ea8 <mbedtls_psa_ecp_generate_key>
        return( PSA_ERROR_INVALID_ARGUMENT );
 c046dbc:	f06f 0086 	mvn.w	r0, #134	@ 0x86
}
 c046dc0:	bd70      	pop	{r4, r5, r6, pc}
        return( PSA_ERROR_NOT_SUPPORTED );
 c046dc2:	f06f 0085 	mvn.w	r0, #133	@ 0x85
 c046dc6:	e7fb      	b.n	c046dc0 <psa_generate_key_internal+0x58>

0c046dc8 <mbedcrypto__psa_generate_key>:

psa_status_t psa_generate_key( const psa_key_attributes_t *attributes,
                               mbedtls_svc_key_id_t *key )
{
 c046dc8:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
    psa_status_t status;
    psa_key_slot_t *slot = NULL;
 c046dcc:	2300      	movs	r3, #0
    psa_se_drv_table_entry_t *driver = NULL;
 c046dce:	e9cd 3301 	strd	r3, r3, [sp, #4]
    size_t key_buffer_size;

    *key = MBEDTLS_SVC_KEY_ID_INIT;
 c046dd2:	e9c1 3300 	strd	r3, r3, [r1]

    /* Reject any attempt to create a zero-length key so that we don't
     * risk tripping up later, e.g. on a malloc(0) that returns NULL. */
    if( psa_get_key_bits( attributes ) == 0 )
 c046dd6:	8843      	ldrh	r3, [r0, #2]
{
 c046dd8:	4606      	mov	r6, r0
 c046dda:	460d      	mov	r5, r1
    if( psa_get_key_bits( attributes ) == 0 )
 c046ddc:	2b00      	cmp	r3, #0
 c046dde:	f000 80a5 	beq.w	c046f2c <mbedcrypto__psa_generate_key+0x164>
        return( PSA_ERROR_INVALID_ARGUMENT );

    /* Reject any attempt to create a public key. */
    if( PSA_KEY_TYPE_IS_PUBLIC_KEY(attributes->core.type) )
 c046de2:	8803      	ldrh	r3, [r0, #0]
 c046de4:	f403 43e0 	and.w	r3, r3, #28672	@ 0x7000
 c046de8:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
 c046dec:	f000 809e 	beq.w	c046f2c <mbedcrypto__psa_generate_key+0x164>
        return( PSA_ERROR_INVALID_ARGUMENT );

    status = psa_start_key_creation( PSA_KEY_CREATION_GENERATE, attributes,
 c046df0:	4601      	mov	r1, r0
 c046df2:	ab02      	add	r3, sp, #8
 c046df4:	2001      	movs	r0, #1
 c046df6:	aa01      	add	r2, sp, #4
 c046df8:	f7fe f894 	bl	c044f24 <psa_start_key_creation>
                                     &slot, &driver );
    if( status != PSA_SUCCESS )
 c046dfc:	4604      	mov	r4, r0
 c046dfe:	2800      	cmp	r0, #0
 c046e00:	f040 808c 	bne.w	c046f1c <mbedcrypto__psa_generate_key+0x154>

    /* In the case of a transparent key or an opaque key stored in local
     * storage (thus not in the case of generating a key in a secure element
     * or cryptoprocessor with storage), we have to allocate a buffer to
     * hold the generated key material. */
    if( slot->key.data == NULL )
 c046e04:	9b01      	ldr	r3, [sp, #4]
 c046e06:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 c046e08:	b1bb      	cbz	r3, c046e3a <mbedcrypto__psa_generate_key+0x72>
        if( status != PSA_SUCCESS )
            goto exit;
    }

    status = psa_driver_wrapper_generate_key( attributes,
        slot->key.data, slot->key.bytes, &slot->key.bytes );
 c046e0a:	9901      	ldr	r1, [sp, #4]
    status = psa_driver_wrapper_generate_key( attributes,
 c046e0c:	4630      	mov	r0, r6
 c046e0e:	f101 0328 	add.w	r3, r1, #40	@ 0x28
 c046e12:	e9d1 1209 	ldrd	r1, r2, [r1, #36]	@ 0x24
 c046e16:	f000 fd2b 	bl	c047870 <psa_driver_wrapper_generate_key>

    if( status != PSA_SUCCESS )
 c046e1a:	4604      	mov	r4, r0
 c046e1c:	2800      	cmp	r0, #0
 c046e1e:	f040 8081 	bne.w	c046f24 <mbedcrypto__psa_generate_key+0x15c>
        psa_remove_key_data_from_memory( slot );

exit:
    if( status == PSA_SUCCESS )
        status = psa_finish_key_creation( slot, driver, key );
 c046e22:	e9dd 0101 	ldrd	r0, r1, [sp, #4]
 c046e26:	462a      	mov	r2, r5
 c046e28:	f7fd fae8 	bl	c0443fc <psa_finish_key_creation>
    if( status != PSA_SUCCESS )
 c046e2c:	4604      	mov	r4, r0
 c046e2e:	2800      	cmp	r0, #0
 c046e30:	d174      	bne.n	c046f1c <mbedcrypto__psa_generate_key+0x154>
        psa_fail_key_creation( slot, driver );

    return( status );
}
 c046e32:	4620      	mov	r0, r4
 c046e34:	b004      	add	sp, #16
 c046e36:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        if ( PSA_KEY_LIFETIME_GET_LOCATION( attributes->core.lifetime ) ==
 c046e3a:	6873      	ldr	r3, [r6, #4]
 c046e3c:	0a1f      	lsrs	r7, r3, #8
 c046e3e:	d166      	bne.n	c046f0e <mbedcrypto__psa_generate_key+0x146>
                attributes->core.type, attributes->core.bits );
 c046e40:	f8b6 8000 	ldrh.w	r8, [r6]
 c046e44:	8871      	ldrh	r1, [r6, #2]
    if( key_type_is_raw_bytes( type ) )
 c046e46:	4640      	mov	r0, r8
 c046e48:	f7fc ff8a 	bl	c043d60 <key_type_is_raw_bytes>
 c046e4c:	b180      	cbz	r0, c046e70 <mbedcrypto__psa_generate_key+0xa8>
        status = validate_unstructured_key_bit_size( type, bits );
 c046e4e:	4640      	mov	r0, r8
 c046e50:	f7fd fb32 	bl	c0444b8 <validate_unstructured_key_bit_size>
            if( status != PSA_SUCCESS )
 c046e54:	4604      	mov	r4, r0
 c046e56:	2800      	cmp	r0, #0
 c046e58:	d160      	bne.n	c046f1c <mbedcrypto__psa_generate_key+0x154>
            key_buffer_size = PSA_EXPORT_KEY_OUTPUT_SIZE(
 c046e5a:	f408 43e0 	and.w	r3, r8, #28672	@ 0x7000
 c046e5e:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 c046e62:	d002      	beq.n	c046e6a <mbedcrypto__psa_generate_key+0xa2>
 c046e64:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 c046e68:	d114      	bne.n	c046e94 <mbedcrypto__psa_generate_key+0xcc>
 c046e6a:	3107      	adds	r1, #7
 c046e6c:	10cf      	asrs	r7, r1, #3
 c046e6e:	e01c      	b.n	c046eaa <mbedcrypto__psa_generate_key+0xe2>
    if( PSA_KEY_TYPE_IS_RSA( type ) && PSA_KEY_TYPE_IS_KEY_PAIR( type ) )
 c046e70:	f247 0301 	movw	r3, #28673	@ 0x7001
 c046e74:	4598      	cmp	r8, r3
 c046e76:	d107      	bne.n	c046e88 <mbedcrypto__psa_generate_key+0xc0>
        if( bits > PSA_VENDOR_RSA_MAX_KEY_BITS )
 c046e78:	f5b1 5f80 	cmp.w	r1, #4096	@ 0x1000
 c046e7c:	d801      	bhi.n	c046e82 <mbedcrypto__psa_generate_key+0xba>
        if( bits % 8 != 0 )
 c046e7e:	074b      	lsls	r3, r1, #29
 c046e80:	d008      	beq.n	c046e94 <mbedcrypto__psa_generate_key+0xcc>
            return( PSA_ERROR_NOT_SUPPORTED );
 c046e82:	f06f 0485 	mvn.w	r4, #133	@ 0x85
 c046e86:	e049      	b.n	c046f1c <mbedcrypto__psa_generate_key+0x154>
    if( PSA_KEY_TYPE_IS_ECC( type ) && PSA_KEY_TYPE_IS_KEY_PAIR( type ) )
 c046e88:	f028 03ff 	bic.w	r3, r8, #255	@ 0xff
 c046e8c:	f5b3 4fe2 	cmp.w	r3, #28928	@ 0x7100
 c046e90:	d0e3      	beq.n	c046e5a <mbedcrypto__psa_generate_key+0x92>
 c046e92:	e7f6      	b.n	c046e82 <mbedcrypto__psa_generate_key+0xba>
            key_buffer_size = PSA_EXPORT_KEY_OUTPUT_SIZE(
 c046e94:	f247 0301 	movw	r3, #28673	@ 0x7001
 c046e98:	4598      	cmp	r8, r3
 c046e9a:	d10f      	bne.n	c046ebc <mbedcrypto__psa_generate_key+0xf4>
 c046e9c:	0849      	lsrs	r1, r1, #1
 c046e9e:	3101      	adds	r1, #1
 c046ea0:	10c9      	asrs	r1, r1, #3
 c046ea2:	eb01 01c1 	add.w	r1, r1, r1, lsl #3
 c046ea6:	f101 073b 	add.w	r7, r1, #59	@ 0x3b
 c046eaa:	9703      	str	r7, [sp, #12]
        status = psa_allocate_buffer_to_slot( slot, key_buffer_size );
 c046eac:	9903      	ldr	r1, [sp, #12]
 c046eae:	9801      	ldr	r0, [sp, #4]
 c046eb0:	f7fe f811 	bl	c044ed6 <psa_allocate_buffer_to_slot>
        if( status != PSA_SUCCESS )
 c046eb4:	4604      	mov	r4, r0
 c046eb6:	2800      	cmp	r0, #0
 c046eb8:	d0a7      	beq.n	c046e0a <mbedcrypto__psa_generate_key+0x42>
 c046eba:	e02f      	b.n	c046f1c <mbedcrypto__psa_generate_key+0x154>
            key_buffer_size = PSA_EXPORT_KEY_OUTPUT_SIZE(
 c046ebc:	f244 0301 	movw	r3, #16385	@ 0x4001
 c046ec0:	4598      	cmp	r8, r3
 c046ec2:	d103      	bne.n	c046ecc <mbedcrypto__psa_generate_key+0x104>
 c046ec4:	08c9      	lsrs	r1, r1, #3
 c046ec6:	f101 0710 	add.w	r7, r1, #16
 c046eca:	e7ee      	b.n	c046eaa <mbedcrypto__psa_generate_key+0xe2>
 c046ecc:	f247 0202 	movw	r2, #28674	@ 0x7002
 c046ed0:	4590      	cmp	r8, r2
 c046ed2:	d105      	bne.n	c046ee0 <mbedcrypto__psa_generate_key+0x118>
 c046ed4:	08c9      	lsrs	r1, r1, #3
 c046ed6:	eb01 0141 	add.w	r1, r1, r1, lsl #1
 c046eda:	f101 075a 	add.w	r7, r1, #90	@ 0x5a
 c046ede:	e7e4      	b.n	c046eaa <mbedcrypto__psa_generate_key+0xe2>
 c046ee0:	f244 0202 	movw	r2, #16386	@ 0x4002
 c046ee4:	4590      	cmp	r8, r2
 c046ee6:	d105      	bne.n	c046ef4 <mbedcrypto__psa_generate_key+0x12c>
 c046ee8:	08c9      	lsrs	r1, r1, #3
 c046eea:	eb01 0141 	add.w	r1, r1, r1, lsl #1
 c046eee:	f101 074a 	add.w	r7, r1, #74	@ 0x4a
 c046ef2:	e7da      	b.n	c046eaa <mbedcrypto__psa_generate_key+0xe2>
 c046ef4:	f028 00ff 	bic.w	r0, r8, #255	@ 0xff
 c046ef8:	f5b0 4fe2 	cmp.w	r0, #28928	@ 0x7100
 c046efc:	d0b5      	beq.n	c046e6a <mbedcrypto__psa_generate_key+0xa2>
 c046efe:	f5b0 4f82 	cmp.w	r0, #16640	@ 0x4100
 c046f02:	bf01      	itttt	eq
 c046f04:	3107      	addeq	r1, #7
 c046f06:	10c9      	asreq	r1, r1, #3
 c046f08:	0049      	lsleq	r1, r1, #1
 c046f0a:	1c4f      	addeq	r7, r1, #1
 c046f0c:	e7cd      	b.n	c046eaa <mbedcrypto__psa_generate_key+0xe2>
            status = psa_driver_wrapper_get_key_buffer_size(
 c046f0e:	4630      	mov	r0, r6
 c046f10:	a903      	add	r1, sp, #12
 c046f12:	f000 fca8 	bl	c047866 <psa_driver_wrapper_get_key_buffer_size>
            if( status != PSA_SUCCESS )
 c046f16:	4604      	mov	r4, r0
 c046f18:	2800      	cmp	r0, #0
 c046f1a:	d0c7      	beq.n	c046eac <mbedcrypto__psa_generate_key+0xe4>
        psa_fail_key_creation( slot, driver );
 c046f1c:	9801      	ldr	r0, [sp, #4]
 c046f1e:	f7fe f902 	bl	c045126 <psa_fail_key_creation.constprop.0>
 c046f22:	e786      	b.n	c046e32 <mbedcrypto__psa_generate_key+0x6a>
        psa_remove_key_data_from_memory( slot );
 c046f24:	9801      	ldr	r0, [sp, #4]
 c046f26:	f7fe f8df 	bl	c0450e8 <psa_remove_key_data_from_memory>
    if( status == PSA_SUCCESS )
 c046f2a:	e7f7      	b.n	c046f1c <mbedcrypto__psa_generate_key+0x154>
        return( PSA_ERROR_INVALID_ARGUMENT );
 c046f2c:	f06f 0486 	mvn.w	r4, #134	@ 0x86
 c046f30:	e77f      	b.n	c046e32 <mbedcrypto__psa_generate_key+0x6a>
	...

0c046f34 <mbedtls_psa_crypto_free>:
    return( PSA_SUCCESS );
}
#endif /* !defined(MBEDTLS_PSA_CRYPTO_EXTERNAL_RNG) */

void mbedtls_psa_crypto_free( void )
{
 c046f34:	b510      	push	{r4, lr}
    psa_wipe_all_key_slots( );
    if( global_data.rng_state != RNG_NOT_INITIALIZED )
 c046f36:	4c0c      	ldr	r4, [pc, #48]	@ (c046f68 <mbedtls_psa_crypto_free+0x34>)
    psa_wipe_all_key_slots( );
 c046f38:	f002 f800 	bl	c048f3c <psa_wipe_all_key_slots>
    if( global_data.rng_state != RNG_NOT_INITIALIZED )
 c046f3c:	7823      	ldrb	r3, [r4, #0]
 c046f3e:	f013 0f06 	tst.w	r3, #6
 c046f42:	d007      	beq.n	c046f54 <mbedtls_psa_crypto_free+0x20>
 * \param p_rng        Pointer to the Mbed TLS DRBG state.
 */
static inline void mbedtls_psa_drbg_free( mbedtls_psa_drbg_context_t *p_rng )
{
#if defined(MBEDTLS_CTR_DRBG_C)
    mbedtls_ctr_drbg_free( p_rng );
 c046f44:	f504 7022 	add.w	r0, r4, #648	@ 0x288
 c046f48:	f00e fe57 	bl	c055bfa <mbedtls_ctr_drbg_free>
    rng->entropy_free( &rng->entropy );
 c046f4c:	68e3      	ldr	r3, [r4, #12]
 c046f4e:	f104 0010 	add.w	r0, r4, #16
 c046f52:	4798      	blx	r3
        mbedtls_psa_random_free( &global_data.rng );
    }
    /* Wipe all remaining data, including configuration.
     * In particular, this sets all state indicator to the value
     * indicating "uninitialized". */
    mbedtls_platform_zeroize( &global_data, sizeof( global_data ) );
 c046f54:	f44f 7150 	mov.w	r1, #832	@ 0x340
 c046f58:	4803      	ldr	r0, [pc, #12]	@ (c046f68 <mbedtls_psa_crypto_free+0x34>)
 c046f5a:	f7f4 fa39 	bl	c03b3d0 <mbedtls_platform_zeroize>

    /* Terminate drivers */
    psa_driver_wrapper_free( );
}
 c046f5e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    psa_driver_wrapper_free( );
 c046f62:	f000 bc06 	b.w	c047772 <psa_driver_wrapper_free>
 c046f66:	bf00      	nop
 c046f68:	30030f00 	.word	0x30030f00

0c046f6c <mbedcrypto__psa_crypto_init>:
    }
}
#endif /* PSA_CRYPTO_STORAGE_HAS_TRANSACTIONS */

psa_status_t psa_crypto_init( void )
{
 c046f6c:	b530      	push	{r4, r5, lr}
    psa_status_t status;

    /* Double initialization is explicitly allowed. */
    if( global_data.initialized != 0 )
 c046f6e:	4b28      	ldr	r3, [pc, #160]	@ (c047010 <mbedcrypto__psa_crypto_init+0xa4>)
{
 c046f70:	b085      	sub	sp, #20
    if( global_data.initialized != 0 )
 c046f72:	781a      	ldrb	r2, [r3, #0]
 c046f74:	07d1      	lsls	r1, r2, #31
 c046f76:	d441      	bmi.n	c046ffc <mbedcrypto__psa_crypto_init+0x90>
    if( rng->entropy_init == NULL )
 c046f78:	689a      	ldr	r2, [r3, #8]
 c046f7a:	b90a      	cbnz	r2, c046f80 <mbedcrypto__psa_crypto_init+0x14>
        rng->entropy_init = mbedtls_entropy_init;
 c046f7c:	4a25      	ldr	r2, [pc, #148]	@ (c047014 <mbedcrypto__psa_crypto_init+0xa8>)
 c046f7e:	609a      	str	r2, [r3, #8]
    if( rng->entropy_free == NULL )
 c046f80:	68da      	ldr	r2, [r3, #12]
 c046f82:	b90a      	cbnz	r2, c046f88 <mbedcrypto__psa_crypto_init+0x1c>
        rng->entropy_free = mbedtls_entropy_free;
 c046f84:	4a24      	ldr	r2, [pc, #144]	@ (c047018 <mbedcrypto__psa_crypto_init+0xac>)
 c046f86:	60da      	str	r2, [r3, #12]
    rng->entropy_init( &rng->entropy );
 c046f88:	4d24      	ldr	r5, [pc, #144]	@ (c04701c <mbedcrypto__psa_crypto_init+0xb0>)
 c046f8a:	689b      	ldr	r3, [r3, #8]
 c046f8c:	4628      	mov	r0, r5
 c046f8e:	4798      	blx	r3
    mbedtls_ctr_drbg_init( p_rng );
 c046f90:	f505 701e 	add.w	r0, r5, #632	@ 0x278
 c046f94:	f00e fe24 	bl	c055be0 <mbedtls_ctr_drbg_init>
        return( PSA_SUCCESS );

    /* Initialize and seed the random generator. */
    mbedtls_psa_random_init( &global_data.rng );
    global_data.rng_state = RNG_INITIALIZED;
 c046f98:	2201      	movs	r2, #1
 c046f9a:	f815 3c10 	ldrb.w	r3, [r5, #-16]
static inline int mbedtls_psa_drbg_seed(
    mbedtls_entropy_context *entropy,
    const unsigned char *custom, size_t len )
{
#if defined(MBEDTLS_CTR_DRBG_C)
    return( mbedtls_ctr_drbg_seed( MBEDTLS_PSA_RANDOM_STATE,
 c046f9e:	4920      	ldr	r1, [pc, #128]	@ (c047020 <mbedcrypto__psa_crypto_init+0xb4>)
 c046fa0:	f362 0342 	bfi	r3, r2, #1, #2
 c046fa4:	f805 3c10 	strb.w	r3, [r5, #-16]
    const unsigned char drbg_seed[] = "PSA";
 c046fa8:	4b1e      	ldr	r3, [pc, #120]	@ (c047024 <mbedcrypto__psa_crypto_init+0xb8>)
 c046faa:	462a      	mov	r2, r5
 c046fac:	9303      	str	r3, [sp, #12]
 c046fae:	2303      	movs	r3, #3
 c046fb0:	f505 701e 	add.w	r0, r5, #632	@ 0x278
 c046fb4:	9300      	str	r3, [sp, #0]
 c046fb6:	ab03      	add	r3, sp, #12
 c046fb8:	f00e fe33 	bl	c055c22 <mbedtls_ctr_drbg_seed>
    return mbedtls_to_psa_error( ret );
 c046fbc:	f7fd fc80 	bl	c0448c0 <mbedtls_to_psa_error>
    status = mbedtls_psa_random_seed( &global_data.rng );
    if( status != PSA_SUCCESS )
 c046fc0:	4604      	mov	r4, r0
 c046fc2:	bb08      	cbnz	r0, c047008 <mbedcrypto__psa_crypto_init+0x9c>
        goto exit;
    global_data.rng_state = RNG_SEEDED;
 c046fc4:	2202      	movs	r2, #2
 c046fc6:	f815 3c10 	ldrb.w	r3, [r5, #-16]
 c046fca:	f362 0342 	bfi	r3, r2, #1, #2
 c046fce:	f805 3c10 	strb.w	r3, [r5, #-16]

    status = psa_initialize_key_slots( );
 c046fd2:	f001 ffa7 	bl	c048f24 <psa_initialize_key_slots>
    if( status != PSA_SUCCESS )
 c046fd6:	4604      	mov	r4, r0
 c046fd8:	b9b0      	cbnz	r0, c047008 <mbedcrypto__psa_crypto_init+0x9c>
        goto exit;

    /* Init drivers */
    status = psa_driver_wrapper_init( );
 c046fda:	f000 fbc8 	bl	c04776e <psa_driver_wrapper_init>
    if( status != PSA_SUCCESS )
 c046fde:	4604      	mov	r4, r0
 c046fe0:	b990      	cbnz	r0, c047008 <mbedcrypto__psa_crypto_init+0x9c>
        goto exit;

#if defined(PSA_CRYPTO_STORAGE_HAS_TRANSACTIONS)
    status = psa_crypto_load_transaction( );
 c046fe2:	f002 fa69 	bl	c0494b8 <psa_crypto_load_transaction>
    if( status == PSA_SUCCESS )
 c046fe6:	4604      	mov	r4, r0
 c046fe8:	b160      	cbz	r0, c047004 <mbedcrypto__psa_crypto_init+0x98>
        status = psa_crypto_recover_transaction( &psa_crypto_transaction );
        if( status != PSA_SUCCESS )
            goto exit;
        status = psa_crypto_stop_transaction( );
    }
    else if( status == PSA_ERROR_DOES_NOT_EXIST )
 c046fea:	f815 3c10 	ldrb.w	r3, [r5, #-16]
 c046fee:	f110 0f8c 	cmn.w	r0, #140	@ 0x8c
        status = PSA_SUCCESS;
    }
#endif /* PSA_CRYPTO_STORAGE_HAS_TRANSACTIONS */

    /* All done. */
    global_data.initialized = 1;
 c046ff2:	f043 0301 	orr.w	r3, r3, #1
 c046ff6:	f805 3c10 	strb.w	r3, [r5, #-16]
    else if( status == PSA_ERROR_DOES_NOT_EXIST )
 c046ffa:	d105      	bne.n	c047008 <mbedcrypto__psa_crypto_init+0x9c>
        return( PSA_SUCCESS );
 c046ffc:	2400      	movs	r4, #0

exit:
    if( status != PSA_SUCCESS )
        mbedtls_psa_crypto_free( );
    return( status );
}
 c046ffe:	4620      	mov	r0, r4
 c047000:	b005      	add	sp, #20
 c047002:	bd30      	pop	{r4, r5, pc}
        status = psa_crypto_recover_transaction( &psa_crypto_transaction );
 c047004:	f06f 0498 	mvn.w	r4, #152	@ 0x98
        mbedtls_psa_crypto_free( );
 c047008:	f7ff ff94 	bl	c046f34 <mbedtls_psa_crypto_free>
 c04700c:	e7f7      	b.n	c046ffe <mbedcrypto__psa_crypto_init+0x92>
 c04700e:	bf00      	nop
 c047010:	30030f00 	.word	0x30030f00
 c047014:	0c056361 	.word	0x0c056361
 c047018:	0c056307 	.word	0x0c056307
 c04701c:	30030f10 	.word	0x30030f10
 c047020:	0c056399 	.word	0x0c056399
 c047024:	00415350 	.word	0x00415350

0c047028 <psa_aead_setup>:
static psa_status_t psa_aead_setup(
    aead_operation_t *operation,
    const psa_key_attributes_t *attributes,
    const uint8_t *key_buffer,
    psa_algorithm_t alg )
{
 c047028:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 c04702c:	461c      	mov	r4, r3
    size_t key_bits;
    const mbedtls_cipher_info_t *cipher_info;
    mbedtls_cipher_id_t cipher_id;
    size_t full_tag_length = 0;

    key_bits = attributes->core.bits;
 c04702e:	f8b1 8002 	ldrh.w	r8, [r1, #2]
{
 c047032:	4605      	mov	r5, r0
 c047034:	460e      	mov	r6, r1
 c047036:	4617      	mov	r7, r2

    cipher_info = mbedtls_cipher_info_from_psa( alg,
 c047038:	4620      	mov	r0, r4
 c04703a:	4642      	mov	r2, r8
 c04703c:	8809      	ldrh	r1, [r1, #0]
 c04703e:	f10d 0307 	add.w	r3, sp, #7
 c047042:	f000 f977 	bl	c047334 <mbedtls_cipher_info_from_psa>
                                                attributes->core.type, key_bits,
                                                &cipher_id );
    if( cipher_info == NULL )
 c047046:	b140      	cbz	r0, c04705a <psa_aead_setup+0x32>
        return( PSA_ERROR_NOT_SUPPORTED );

    switch( PSA_ALG_AEAD_WITH_SHORTENED_TAG( alg, 0 ) )
 c047048:	4a4b      	ldr	r2, [pc, #300]	@ (c047178 <psa_aead_setup+0x150>)
 c04704a:	f424 137e 	bic.w	r3, r4, #4161536	@ 0x3f8000
 c04704e:	4293      	cmp	r3, r2
 c047050:	d006      	beq.n	c047060 <psa_aead_setup+0x38>
 c047052:	f502 7280 	add.w	r2, r2, #256	@ 0x100
 c047056:	4293      	cmp	r3, r2
 c047058:	d044      	beq.n	c0470e4 <psa_aead_setup+0xbc>
 c04705a:	f06f 0085 	mvn.w	r0, #133	@ 0x85
 c04705e:	e009      	b.n	c047074 <psa_aead_setup+0x4c>
    {
#if defined(MBEDTLS_PSA_BUILTIN_ALG_CCM)
        case PSA_ALG_AEAD_WITH_SHORTENED_TAG( PSA_ALG_CCM, 0 ):
            operation->core_alg = PSA_ALG_CCM;
 c047060:	4b46      	ldr	r3, [pc, #280]	@ (c04717c <psa_aead_setup+0x154>)
 c047062:	602b      	str	r3, [r5, #0]
            full_tag_length = 16;
            /* CCM allows the following tag lengths: 4, 6, 8, 10, 12, 14, 16.
             * The call to mbedtls_ccm_encrypt_and_tag or
             * mbedtls_ccm_auth_decrypt will validate the tag length. */
            if( PSA_BLOCK_CIPHER_BLOCK_LENGTH( attributes->core.type ) != 16 )
 c047064:	8833      	ldrh	r3, [r6, #0]
 c047066:	f403 42e0 	and.w	r2, r3, #28672	@ 0x7000
 c04706a:	f5b2 5f00 	cmp.w	r2, #8192	@ 0x2000
 c04706e:	d004      	beq.n	c04707a <psa_aead_setup+0x52>
                return( PSA_ERROR_INVALID_ARGUMENT );
 c047070:	f06f 0086 	mvn.w	r0, #134	@ 0x86
    operation->tag_length = PSA_AEAD_TAG_LENGTH( attributes->core.type,
                                                 key_bits,
                                                 alg );

    return( PSA_SUCCESS );
}
 c047074:	b003      	add	sp, #12
 c047076:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
            if( PSA_BLOCK_CIPHER_BLOCK_LENGTH( attributes->core.type ) != 16 )
 c04707a:	f3c3 2302 	ubfx	r3, r3, #8, #3
 c04707e:	2b04      	cmp	r3, #4
 c047080:	d1f6      	bne.n	c047070 <psa_aead_setup+0x48>
            mbedtls_ccm_init( &operation->ctx.ccm );
 c047082:	f105 0908 	add.w	r9, r5, #8
 c047086:	4648      	mov	r0, r9
 c047088:	f004 fff2 	bl	c04c070 <mbedtls_ccm_init>
            status = mbedtls_to_psa_error(
 c04708c:	4643      	mov	r3, r8
 c04708e:	463a      	mov	r2, r7
 c047090:	4648      	mov	r0, r9
 c047092:	f89d 1007 	ldrb.w	r1, [sp, #7]
 c047096:	f004 ffef 	bl	c04c078 <mbedtls_ccm_setkey>
 c04709a:	f7fd fc11 	bl	c0448c0 <mbedtls_to_psa_error>
            if( status != PSA_SUCCESS )
 c04709e:	2800      	cmp	r0, #0
 c0470a0:	d1e8      	bne.n	c047074 <psa_aead_setup+0x4c>
    if( PSA_AEAD_TAG_LENGTH( attributes->core.type,
 c0470a2:	8833      	ldrh	r3, [r6, #0]
 c0470a4:	f403 41e0 	and.w	r1, r3, #28672	@ 0x7000
 c0470a8:	f5b1 5f00 	cmp.w	r1, #8192	@ 0x2000
 c0470ac:	d15e      	bne.n	c04716c <psa_aead_setup+0x144>
 c0470ae:	f3c3 2202 	ubfx	r2, r3, #8, #3
 c0470b2:	2a04      	cmp	r2, #4
 c0470b4:	d12f      	bne.n	c047116 <psa_aead_setup+0xee>
 c0470b6:	f084 62aa 	eor.w	r2, r4, #89128960	@ 0x5500000
 c0470ba:	f482 7280 	eor.w	r2, r2, #256	@ 0x100
 c0470be:	f432 127e 	bics.w	r2, r2, #4161536	@ 0x3f8000
 c0470c2:	d033      	beq.n	c04712c <psa_aead_setup+0x104>
 c0470c4:	f084 62aa 	eor.w	r2, r4, #89128960	@ 0x5500000
 c0470c8:	f482 7200 	eor.w	r2, r2, #512	@ 0x200
 c0470cc:	f432 127e 	bics.w	r2, r2, #4161536	@ 0x3f8000
 c0470d0:	d02c      	beq.n	c04712c <psa_aead_setup+0x104>
    operation->tag_length = PSA_AEAD_TAG_LENGTH( attributes->core.type,
 c0470d2:	f084 63aa 	eor.w	r3, r4, #89128960	@ 0x5500000
 c0470d6:	f483 7300 	eor.w	r3, r3, #512	@ 0x200
 c0470da:	f433 137e 	bics.w	r3, r3, #4161536	@ 0x3f8000
 c0470de:	d037      	beq.n	c047150 <psa_aead_setup+0x128>
 c0470e0:	2400      	movs	r4, #0
 c0470e2:	e037      	b.n	c047154 <psa_aead_setup+0x12c>
            operation->core_alg = PSA_ALG_GCM;
 c0470e4:	4b26      	ldr	r3, [pc, #152]	@ (c047180 <psa_aead_setup+0x158>)
 c0470e6:	602b      	str	r3, [r5, #0]
            if( PSA_BLOCK_CIPHER_BLOCK_LENGTH( attributes->core.type ) != 16 )
 c0470e8:	8833      	ldrh	r3, [r6, #0]
 c0470ea:	f403 42e0 	and.w	r2, r3, #28672	@ 0x7000
 c0470ee:	f5b2 5f00 	cmp.w	r2, #8192	@ 0x2000
 c0470f2:	d1bd      	bne.n	c047070 <psa_aead_setup+0x48>
 c0470f4:	f3c3 2302 	ubfx	r3, r3, #8, #3
 c0470f8:	2b04      	cmp	r3, #4
 c0470fa:	d1b9      	bne.n	c047070 <psa_aead_setup+0x48>
            mbedtls_gcm_init( &operation->ctx.gcm );
 c0470fc:	f105 0908 	add.w	r9, r5, #8
 c047100:	4648      	mov	r0, r9
 c047102:	f006 ff33 	bl	c04df6c <mbedtls_gcm_init>
            status = mbedtls_to_psa_error(
 c047106:	4643      	mov	r3, r8
 c047108:	463a      	mov	r2, r7
 c04710a:	4648      	mov	r0, r9
 c04710c:	f89d 1007 	ldrb.w	r1, [sp, #7]
 c047110:	f006 ff42 	bl	c04df98 <mbedtls_gcm_setkey>
 c047114:	e7c1      	b.n	c04709a <psa_aead_setup+0x72>
    if( PSA_AEAD_TAG_LENGTH( attributes->core.type,
 c047116:	f242 0204 	movw	r2, #8196	@ 0x2004
 c04711a:	4293      	cmp	r3, r2
 c04711c:	d10d      	bne.n	c04713a <psa_aead_setup+0x112>
 c04711e:	f084 2205 	eor.w	r2, r4, #83887360	@ 0x5000500
 c047122:	f482 1280 	eor.w	r2, r2, #1048576	@ 0x100000
 c047126:	f432 127e 	bics.w	r2, r2, #4161536	@ 0x3f8000
 c04712a:	d1d9      	bne.n	c0470e0 <psa_aead_setup+0xb8>
 c04712c:	f3c4 4205 	ubfx	r2, r4, #16, #6
 c047130:	2a10      	cmp	r2, #16
 c047132:	d89d      	bhi.n	c047070 <psa_aead_setup+0x48>
    operation->tag_length = PSA_AEAD_TAG_LENGTH( attributes->core.type,
 c047134:	f5b1 5f00 	cmp.w	r1, #8192	@ 0x2000
 c047138:	d10f      	bne.n	c04715a <psa_aead_setup+0x132>
 c04713a:	f3c3 2202 	ubfx	r2, r3, #8, #3
 c04713e:	2a04      	cmp	r2, #4
 c047140:	d10b      	bne.n	c04715a <psa_aead_setup+0x132>
 c047142:	f084 63aa 	eor.w	r3, r4, #89128960	@ 0x5500000
 c047146:	f483 7380 	eor.w	r3, r3, #256	@ 0x100
 c04714a:	f433 137e 	bics.w	r3, r3, #4161536	@ 0x3f8000
 c04714e:	d1c0      	bne.n	c0470d2 <psa_aead_setup+0xaa>
 c047150:	f3c4 4405 	ubfx	r4, r4, #16, #6
    return( PSA_SUCCESS );
 c047154:	2000      	movs	r0, #0
    operation->tag_length = PSA_AEAD_TAG_LENGTH( attributes->core.type,
 c047156:	712c      	strb	r4, [r5, #4]
    return( PSA_SUCCESS );
 c047158:	e78c      	b.n	c047074 <psa_aead_setup+0x4c>
    operation->tag_length = PSA_AEAD_TAG_LENGTH( attributes->core.type,
 c04715a:	f242 0204 	movw	r2, #8196	@ 0x2004
 c04715e:	4293      	cmp	r3, r2
 c047160:	d1be      	bne.n	c0470e0 <psa_aead_setup+0xb8>
 c047162:	f084 2305 	eor.w	r3, r4, #83887360	@ 0x5000500
 c047166:	f483 1380 	eor.w	r3, r3, #1048576	@ 0x100000
 c04716a:	e7b6      	b.n	c0470da <psa_aead_setup+0xb2>
    if( PSA_AEAD_TAG_LENGTH( attributes->core.type,
 c04716c:	f242 0204 	movw	r2, #8196	@ 0x2004
 c047170:	4293      	cmp	r3, r2
 c047172:	d1b5      	bne.n	c0470e0 <psa_aead_setup+0xb8>
 c047174:	e7d3      	b.n	c04711e <psa_aead_setup+0xf6>
 c047176:	bf00      	nop
 c047178:	05400100 	.word	0x05400100
 c04717c:	05500100 	.word	0x05500100
 c047180:	05500200 	.word	0x05500200

0c047184 <psa_aead_abort_internal>:
    switch( operation->core_alg )
 c047184:	6803      	ldr	r3, [r0, #0]
 c047186:	4a07      	ldr	r2, [pc, #28]	@ (c0471a4 <psa_aead_abort_internal+0x20>)
 c047188:	4293      	cmp	r3, r2
 c04718a:	d004      	beq.n	c047196 <psa_aead_abort_internal+0x12>
 c04718c:	f502 7280 	add.w	r2, r2, #256	@ 0x100
 c047190:	4293      	cmp	r3, r2
 c047192:	d003      	beq.n	c04719c <psa_aead_abort_internal+0x18>
 c047194:	4770      	bx	lr
            mbedtls_ccm_free( &operation->ctx.ccm );
 c047196:	3008      	adds	r0, #8
 c047198:	f004 bfc6 	b.w	c04c128 <mbedtls_ccm_free>
            mbedtls_gcm_free( &operation->ctx.gcm );
 c04719c:	3008      	adds	r0, #8
 c04719e:	f007 b97f 	b.w	c04e4a0 <mbedtls_gcm_free>
 c0471a2:	bf00      	nop
 c0471a4:	05500100 	.word	0x05500100

0c0471a8 <mbedtls_psa_aead_encrypt>:
    psa_algorithm_t alg,
    const uint8_t *nonce, size_t nonce_length,
    const uint8_t *additional_data, size_t additional_data_length,
    const uint8_t *plaintext, size_t plaintext_length,
    uint8_t *ciphertext, size_t ciphertext_size, size_t *ciphertext_length )
{
 c0471a8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c0471ac:	4606      	mov	r6, r0
 c0471ae:	460f      	mov	r7, r1
 c0471b0:	4698      	mov	r8, r3
 c0471b2:	f5ad 7d01 	sub.w	sp, sp, #516	@ 0x204
    psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
    aead_operation_t operation = AEAD_OPERATION_INIT;
 c0471b6:	f44f 72f0 	mov.w	r2, #480	@ 0x1e0
{
 c0471ba:	e9dd 9a8c 	ldrd	r9, sl, [sp, #560]	@ 0x230
 c0471be:	e9dd b48e 	ldrd	fp, r4, [sp, #568]	@ 0x238
    aead_operation_t operation = AEAD_OPERATION_INIT;
 c0471c2:	2100      	movs	r1, #0
 c0471c4:	a808      	add	r0, sp, #32
{
 c0471c6:	9d90      	ldr	r5, [sp, #576]	@ 0x240
    aead_operation_t operation = AEAD_OPERATION_INIT;
 c0471c8:	f014 fab1 	bl	c05b72e <memset>
    uint8_t *tag;
    (void) key_buffer_size;

    status = psa_aead_setup( &operation, attributes, key_buffer, alg );
 c0471cc:	4631      	mov	r1, r6
 c0471ce:	4643      	mov	r3, r8
 c0471d0:	463a      	mov	r2, r7
 c0471d2:	a808      	add	r0, sp, #32
 c0471d4:	f7ff ff28 	bl	c047028 <psa_aead_setup>
    if( status != PSA_SUCCESS )
 c0471d8:	4606      	mov	r6, r0
 c0471da:	b9f8      	cbnz	r0, c04721c <mbedtls_psa_aead_encrypt+0x74>
        goto exit;

    /* For all currently supported modes, the tag is at the end of the
     * ciphertext. */
    if( ciphertext_size < ( plaintext_length + operation.tag_length ) )
 c0471dc:	f89d 3024 	ldrb.w	r3, [sp, #36]	@ 0x24
 c0471e0:	9a91      	ldr	r2, [sp, #580]	@ 0x244
 c0471e2:	1919      	adds	r1, r3, r4
 c0471e4:	4291      	cmp	r1, r2
 c0471e6:	d833      	bhi.n	c047250 <mbedtls_psa_aead_encrypt+0xa8>
        goto exit;
    }
    tag = ciphertext + plaintext_length;

#if defined(MBEDTLS_PSA_BUILTIN_ALG_CCM)
    if( operation.core_alg == PSA_ALG_CCM )
 c0471e8:	9908      	ldr	r1, [sp, #32]
 c0471ea:	481c      	ldr	r0, [pc, #112]	@ (c04725c <mbedtls_psa_aead_encrypt+0xb4>)
    tag = ciphertext + plaintext_length;
 c0471ec:	192a      	adds	r2, r5, r4
    if( operation.core_alg == PSA_ALG_CCM )
 c0471ee:	4281      	cmp	r1, r0
 c0471f0:	d11c      	bne.n	c04722c <mbedtls_psa_aead_encrypt+0x84>
    {
        status = mbedtls_to_psa_error(
 c0471f2:	e9cd 2304 	strd	r2, r3, [sp, #16]
 c0471f6:	e9dd 238a 	ldrd	r2, r3, [sp, #552]	@ 0x228
 c0471fa:	4621      	mov	r1, r4
 c0471fc:	e9cd b502 	strd	fp, r5, [sp, #8]
 c047200:	e9cd 9a00 	strd	r9, sl, [sp]
 c047204:	a80a      	add	r0, sp, #40	@ 0x28
 c047206:	f004 ffb2 	bl	c04c16e <mbedtls_ccm_encrypt_and_tag>
    else
#endif /* MBEDTLS_PSA_BUILTIN_ALG_CCM */
#if defined(MBEDTLS_PSA_BUILTIN_ALG_GCM)
    if( operation.core_alg == PSA_ALG_GCM )
    {
        status = mbedtls_to_psa_error(
 c04720a:	f7fd fb59 	bl	c0448c0 <mbedtls_to_psa_error>
 c04720e:	4606      	mov	r6, r0
        (void) additional_data_length;
        (void) plaintext;
        return( PSA_ERROR_NOT_SUPPORTED );
    }

    if( status == PSA_SUCCESS )
 c047210:	b920      	cbnz	r0, c04721c <mbedtls_psa_aead_encrypt+0x74>
        *ciphertext_length = plaintext_length + operation.tag_length;
 c047212:	f89d 3024 	ldrb.w	r3, [sp, #36]	@ 0x24
 c047216:	9a92      	ldr	r2, [sp, #584]	@ 0x248
 c047218:	4423      	add	r3, r4
 c04721a:	6013      	str	r3, [r2, #0]

exit:
    psa_aead_abort_internal( &operation );
 c04721c:	a808      	add	r0, sp, #32
 c04721e:	f7ff ffb1 	bl	c047184 <psa_aead_abort_internal>

    return( status );
}
 c047222:	4630      	mov	r0, r6
 c047224:	f50d 7d01 	add.w	sp, sp, #516	@ 0x204
 c047228:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if( operation.core_alg == PSA_ALG_GCM )
 c04722c:	480c      	ldr	r0, [pc, #48]	@ (c047260 <mbedtls_psa_aead_encrypt+0xb8>)
 c04722e:	4281      	cmp	r1, r0
 c047230:	d111      	bne.n	c047256 <mbedtls_psa_aead_encrypt+0xae>
        status = mbedtls_to_psa_error(
 c047232:	e9cd 3205 	strd	r3, r2, [sp, #20]
 c047236:	9b8b      	ldr	r3, [sp, #556]	@ 0x22c
 c047238:	4622      	mov	r2, r4
 c04723a:	9300      	str	r3, [sp, #0]
 c04723c:	2101      	movs	r1, #1
 c04723e:	e9cd b503 	strd	fp, r5, [sp, #12]
 c047242:	e9cd 9a01 	strd	r9, sl, [sp, #4]
 c047246:	9b8a      	ldr	r3, [sp, #552]	@ 0x228
 c047248:	a80a      	add	r0, sp, #40	@ 0x28
 c04724a:	f007 f8c5 	bl	c04e3d8 <mbedtls_gcm_crypt_and_tag>
 c04724e:	e7dc      	b.n	c04720a <mbedtls_psa_aead_encrypt+0x62>
        status = PSA_ERROR_BUFFER_TOO_SMALL;
 c047250:	f06f 0689 	mvn.w	r6, #137	@ 0x89
 c047254:	e7e2      	b.n	c04721c <mbedtls_psa_aead_encrypt+0x74>
        return( PSA_ERROR_NOT_SUPPORTED );
 c047256:	f06f 0685 	mvn.w	r6, #133	@ 0x85
 c04725a:	e7e2      	b.n	c047222 <mbedtls_psa_aead_encrypt+0x7a>
 c04725c:	05500100 	.word	0x05500100
 c047260:	05500200 	.word	0x05500200

0c047264 <mbedtls_psa_aead_decrypt>:
    psa_algorithm_t alg,
    const uint8_t *nonce, size_t nonce_length,
    const uint8_t *additional_data, size_t additional_data_length,
    const uint8_t *ciphertext, size_t ciphertext_length,
    uint8_t *plaintext, size_t plaintext_size, size_t *plaintext_length )
{
 c047264:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c047268:	4606      	mov	r6, r0
 c04726a:	460f      	mov	r7, r1
 c04726c:	4699      	mov	r9, r3
 c04726e:	b0ff      	sub	sp, #508	@ 0x1fc
    psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
    aead_operation_t operation = AEAD_OPERATION_INIT;
 c047270:	f44f 72f0 	mov.w	r2, #480	@ 0x1e0
{
 c047274:	e9dd a58b 	ldrd	sl, r5, [sp, #556]	@ 0x22c
 c047278:	e9dd 4b8d 	ldrd	r4, fp, [sp, #564]	@ 0x234
    aead_operation_t operation = AEAD_OPERATION_INIT;
 c04727c:	2100      	movs	r1, #0
 c04727e:	a806      	add	r0, sp, #24
{
 c047280:	f8dd 8240 	ldr.w	r8, [sp, #576]	@ 0x240
    aead_operation_t operation = AEAD_OPERATION_INIT;
 c047284:	f014 fa53 	bl	c05b72e <memset>
    const uint8_t *tag = NULL;
    (void) key_buffer_size;

    status = psa_aead_setup( &operation, attributes, key_buffer, alg );
 c047288:	4631      	mov	r1, r6
 c04728a:	464b      	mov	r3, r9
 c04728c:	463a      	mov	r2, r7
 c04728e:	a806      	add	r0, sp, #24
 c047290:	f7ff feca 	bl	c047028 <psa_aead_setup>
    if( status != PSA_SUCCESS )
 c047294:	4606      	mov	r6, r0
 c047296:	bb10      	cbnz	r0, c0472de <mbedtls_psa_aead_decrypt+0x7a>
        goto exit;

    status = psa_aead_unpadded_locate_tag( operation.tag_length,
 c047298:	f89d 301c 	ldrb.w	r3, [sp, #28]
    if( tag_length > ciphertext_length )
 c04729c:	42a3      	cmp	r3, r4
 c04729e:	d83c      	bhi.n	c04731a <mbedtls_psa_aead_decrypt+0xb6>
    if( payload_length > plaintext_size )
 c0472a0:	9a8f      	ldr	r2, [sp, #572]	@ 0x23c
    payload_length = ciphertext_length - tag_length;
 c0472a2:	1ae1      	subs	r1, r4, r3
    if( payload_length > plaintext_size )
 c0472a4:	428a      	cmp	r2, r1
 c0472a6:	d33b      	bcc.n	c047320 <mbedtls_psa_aead_decrypt+0xbc>
                                           plaintext_size, &tag );
    if( status != PSA_SUCCESS )
        goto exit;

#if defined(MBEDTLS_PSA_BUILTIN_ALG_CCM)
    if( operation.core_alg == PSA_ALG_CCM )
 c0472a8:	9806      	ldr	r0, [sp, #24]
 c0472aa:	4e20      	ldr	r6, [pc, #128]	@ (c04732c <mbedtls_psa_aead_decrypt+0xc8>)
    *p_tag = ciphertext + payload_length;
 c0472ac:	186a      	adds	r2, r5, r1
    if( operation.core_alg == PSA_ALG_CCM )
 c0472ae:	42b0      	cmp	r0, r6
 c0472b0:	d122      	bne.n	c0472f8 <mbedtls_psa_aead_decrypt+0x94>
    {
        status = mbedtls_to_psa_error(
 c0472b2:	e9cd 2304 	strd	r2, r3, [sp, #16]
 c0472b6:	9b8a      	ldr	r3, [sp, #552]	@ 0x228
 c0472b8:	e9cd 5b02 	strd	r5, fp, [sp, #8]
 c0472bc:	9300      	str	r3, [sp, #0]
 c0472be:	f8cd a004 	str.w	sl, [sp, #4]
 c0472c2:	a808      	add	r0, sp, #32
 c0472c4:	e9dd 2388 	ldrd	r2, r3, [sp, #544]	@ 0x220
 c0472c8:	f004 ff95 	bl	c04c1f6 <mbedtls_ccm_auth_decrypt>
    else
#endif /* MBEDTLS_PSA_BUILTIN_ALG_CCM */
#if defined(MBEDTLS_PSA_BUILTIN_ALG_GCM)
    if( operation.core_alg == PSA_ALG_GCM )
    {
        status = mbedtls_to_psa_error(
 c0472cc:	f7fd faf8 	bl	c0448c0 <mbedtls_to_psa_error>
 c0472d0:	4606      	mov	r6, r0
        (void) additional_data_length;
        (void) plaintext;
        return( PSA_ERROR_NOT_SUPPORTED );
    }

    if( status == PSA_SUCCESS )
 c0472d2:	b920      	cbnz	r0, c0472de <mbedtls_psa_aead_decrypt+0x7a>
        *plaintext_length = ciphertext_length - operation.tag_length;
 c0472d4:	f89d 301c 	ldrb.w	r3, [sp, #28]
 c0472d8:	1ae3      	subs	r3, r4, r3
 c0472da:	f8c8 3000 	str.w	r3, [r8]

exit:
    psa_aead_abort_internal( &operation );
 c0472de:	a806      	add	r0, sp, #24
 c0472e0:	f7ff ff50 	bl	c047184 <psa_aead_abort_internal>

    if( status == PSA_SUCCESS )
 c0472e4:	b926      	cbnz	r6, c0472f0 <mbedtls_psa_aead_decrypt+0x8c>
        *plaintext_length = ciphertext_length - operation.tag_length;
 c0472e6:	f89d 301c 	ldrb.w	r3, [sp, #28]
 c0472ea:	1ae4      	subs	r4, r4, r3
 c0472ec:	f8c8 4000 	str.w	r4, [r8]
    return( status );
}
 c0472f0:	4630      	mov	r0, r6
 c0472f2:	b07f      	add	sp, #508	@ 0x1fc
 c0472f4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if( operation.core_alg == PSA_ALG_GCM )
 c0472f8:	4e0d      	ldr	r6, [pc, #52]	@ (c047330 <mbedtls_psa_aead_decrypt+0xcc>)
 c0472fa:	42b0      	cmp	r0, r6
 c0472fc:	d113      	bne.n	c047326 <mbedtls_psa_aead_decrypt+0xc2>
        status = mbedtls_to_psa_error(
 c0472fe:	e9cd 2302 	strd	r2, r3, [sp, #8]
 c047302:	9b8a      	ldr	r3, [sp, #552]	@ 0x228
 c047304:	e9cd 5b04 	strd	r5, fp, [sp, #16]
 c047308:	9300      	str	r3, [sp, #0]
 c04730a:	f8cd a004 	str.w	sl, [sp, #4]
 c04730e:	a808      	add	r0, sp, #32
 c047310:	e9dd 2388 	ldrd	r2, r3, [sp, #544]	@ 0x220
 c047314:	f007 f883 	bl	c04e41e <mbedtls_gcm_auth_decrypt>
 c047318:	e7d8      	b.n	c0472cc <mbedtls_psa_aead_decrypt+0x68>
        return( PSA_ERROR_INVALID_ARGUMENT );
 c04731a:	f06f 0686 	mvn.w	r6, #134	@ 0x86
 c04731e:	e7de      	b.n	c0472de <mbedtls_psa_aead_decrypt+0x7a>
        return( PSA_ERROR_BUFFER_TOO_SMALL );
 c047320:	f06f 0689 	mvn.w	r6, #137	@ 0x89
 c047324:	e7db      	b.n	c0472de <mbedtls_psa_aead_decrypt+0x7a>
        return( PSA_ERROR_NOT_SUPPORTED );
 c047326:	f06f 0685 	mvn.w	r6, #133	@ 0x85
 c04732a:	e7e1      	b.n	c0472f0 <mbedtls_psa_aead_decrypt+0x8c>
 c04732c:	05500100 	.word	0x05500100
 c047330:	05500200 	.word	0x05500200

0c047334 <mbedtls_cipher_info_from_psa>:
const mbedtls_cipher_info_t *mbedtls_cipher_info_from_psa(
    psa_algorithm_t alg,
    psa_key_type_t key_type,
    size_t key_bits,
    mbedtls_cipher_id_t* cipher_id )
{
 c047334:	b410      	push	{r4}
 c047336:	460c      	mov	r4, r1
 c047338:	4611      	mov	r1, r2
    mbedtls_cipher_mode_t mode;
    mbedtls_cipher_id_t cipher_id_tmp;

    if( PSA_ALG_IS_AEAD( alg ) )
 c04733a:	f000 42fe 	and.w	r2, r0, #2130706432	@ 0x7f000000
 c04733e:	f1b2 6fa0 	cmp.w	r2, #83886080	@ 0x5000000
        alg = PSA_ALG_AEAD_WITH_SHORTENED_TAG( alg, 0 );
 c047342:	bf08      	it	eq
 c047344:	f420 107e 	biceq.w	r0, r0, #4161536	@ 0x3f8000

    if( PSA_ALG_IS_CIPHER( alg ) || PSA_ALG_IS_AEAD( alg ) )
 c047348:	f000 42fc 	and.w	r2, r0, #2113929216	@ 0x7e000000
 c04734c:	f1b2 6f80 	cmp.w	r2, #67108864	@ 0x4000000
 c047350:	d129      	bne.n	c0473a6 <mbedtls_cipher_info_from_psa+0x72>
    {
        switch( alg )
 c047352:	4a34      	ldr	r2, [pc, #208]	@ (c047424 <mbedtls_cipher_info_from_psa+0xf0>)
 c047354:	4290      	cmp	r0, r2
 c047356:	d02b      	beq.n	c0473b0 <mbedtls_cipher_info_from_psa+0x7c>
 c047358:	d814      	bhi.n	c047384 <mbedtls_cipher_info_from_psa+0x50>
 c04735a:	4a33      	ldr	r2, [pc, #204]	@ (c047428 <mbedtls_cipher_info_from_psa+0xf4>)
 c04735c:	4290      	cmp	r0, r2
 c04735e:	d025      	beq.n	c0473ac <mbedtls_cipher_info_from_psa+0x78>
 c047360:	d807      	bhi.n	c047372 <mbedtls_cipher_info_from_psa+0x3e>
 c047362:	f420 7080 	bic.w	r0, r0, #256	@ 0x100
 c047366:	f5a2 6280 	sub.w	r2, r2, #1024	@ 0x400
 c04736a:	4290      	cmp	r0, r2
 c04736c:	d107      	bne.n	c04737e <mbedtls_cipher_info_from_psa+0x4a>
                break;
            case PSA_ALG_CBC_NO_PADDING:
                mode = MBEDTLS_MODE_CBC;
                break;
            case PSA_ALG_CBC_PKCS7:
                mode = MBEDTLS_MODE_CBC;
 c04736e:	2202      	movs	r2, #2
 c047370:	e01f      	b.n	c0473b2 <mbedtls_cipher_info_from_psa+0x7e>
        switch( alg )
 c047372:	4a2e      	ldr	r2, [pc, #184]	@ (c04742c <mbedtls_cipher_info_from_psa+0xf8>)
 c047374:	4290      	cmp	r0, r2
 c047376:	d02e      	beq.n	c0473d6 <mbedtls_cipher_info_from_psa+0xa2>
 c047378:	4a2d      	ldr	r2, [pc, #180]	@ (c047430 <mbedtls_cipher_info_from_psa+0xfc>)
 c04737a:	4290      	cmp	r0, r2
 c04737c:	d02d      	beq.n	c0473da <mbedtls_cipher_info_from_psa+0xa6>
    if( cipher_id != NULL )
        *cipher_id = cipher_id_tmp;

    return( mbedtls_cipher_info_from_values( cipher_id_tmp,
                                             (int) key_bits, mode ) );
}
 c04737e:	2000      	movs	r0, #0
 c047380:	bc10      	pop	{r4}
 c047382:	4770      	bx	lr
        switch( alg )
 c047384:	4a2b      	ldr	r2, [pc, #172]	@ (c047434 <mbedtls_cipher_info_from_psa+0x100>)
 c047386:	4290      	cmp	r0, r2
 c047388:	d029      	beq.n	c0473de <mbedtls_cipher_info_from_psa+0xaa>
 c04738a:	d807      	bhi.n	c04739c <mbedtls_cipher_info_from_psa+0x68>
 c04738c:	4a2a      	ldr	r2, [pc, #168]	@ (c047438 <mbedtls_cipher_info_from_psa+0x104>)
 c04738e:	4290      	cmp	r0, r2
 c047390:	d027      	beq.n	c0473e2 <mbedtls_cipher_info_from_psa+0xae>
 c047392:	f1b0 2f05 	cmp.w	r0, #83887360	@ 0x5000500
 c047396:	d1f2      	bne.n	c04737e <mbedtls_cipher_info_from_psa+0x4a>
                mode = MBEDTLS_MODE_CHACHAPOLY;
 c047398:	220a      	movs	r2, #10
 c04739a:	e00a      	b.n	c0473b2 <mbedtls_cipher_info_from_psa+0x7e>
        switch( alg )
 c04739c:	4a27      	ldr	r2, [pc, #156]	@ (c04743c <mbedtls_cipher_info_from_psa+0x108>)
 c04739e:	4290      	cmp	r0, r2
 c0473a0:	d1ed      	bne.n	c04737e <mbedtls_cipher_info_from_psa+0x4a>
                mode = MBEDTLS_MODE_GCM;
 c0473a2:	2206      	movs	r2, #6
 c0473a4:	e005      	b.n	c0473b2 <mbedtls_cipher_info_from_psa+0x7e>
    else if( alg == PSA_ALG_CMAC )
 c0473a6:	4a26      	ldr	r2, [pc, #152]	@ (c047440 <mbedtls_cipher_info_from_psa+0x10c>)
 c0473a8:	4290      	cmp	r0, r2
 c0473aa:	d1e8      	bne.n	c04737e <mbedtls_cipher_info_from_psa+0x4a>
        mode = MBEDTLS_MODE_ECB;
 c0473ac:	2201      	movs	r2, #1
 c0473ae:	e000      	b.n	c0473b2 <mbedtls_cipher_info_from_psa+0x7e>
                mode = MBEDTLS_MODE_CFB;
 c0473b0:	2203      	movs	r2, #3
    switch( key_type )
 c0473b2:	f5b4 5f10 	cmp.w	r4, #9216	@ 0x2400
 c0473b6:	d02c      	beq.n	c047412 <mbedtls_cipher_info_from_psa+0xde>
 c0473b8:	d815      	bhi.n	c0473e6 <mbedtls_cipher_info_from_psa+0xb2>
 c0473ba:	f242 0004 	movw	r0, #8196	@ 0x2004
 c0473be:	4284      	cmp	r4, r0
 c0473c0:	d029      	beq.n	c047416 <mbedtls_cipher_info_from_psa+0xe2>
 c0473c2:	f242 3001 	movw	r0, #8961	@ 0x2301
 c0473c6:	4284      	cmp	r4, r0
 c0473c8:	d017      	beq.n	c0473fa <mbedtls_cipher_info_from_psa+0xc6>
 c0473ca:	f242 0002 	movw	r0, #8194	@ 0x2002
 c0473ce:	4284      	cmp	r4, r0
 c0473d0:	d1d5      	bne.n	c04737e <mbedtls_cipher_info_from_psa+0x4a>
            cipher_id_tmp = MBEDTLS_CIPHER_ID_ARC4;
 c0473d2:	2007      	movs	r0, #7
 c0473d4:	e018      	b.n	c047408 <mbedtls_cipher_info_from_psa+0xd4>
                mode = MBEDTLS_MODE_STREAM;
 c0473d6:	2207      	movs	r2, #7
 c0473d8:	e7eb      	b.n	c0473b2 <mbedtls_cipher_info_from_psa+0x7e>
        switch( alg )
 c0473da:	2205      	movs	r2, #5
 c0473dc:	e7e9      	b.n	c0473b2 <mbedtls_cipher_info_from_psa+0x7e>
                mode = MBEDTLS_MODE_CCM;
 c0473de:	2208      	movs	r2, #8
 c0473e0:	e7e7      	b.n	c0473b2 <mbedtls_cipher_info_from_psa+0x7e>
                mode = MBEDTLS_MODE_OFB;
 c0473e2:	2204      	movs	r2, #4
 c0473e4:	e7e5      	b.n	c0473b2 <mbedtls_cipher_info_from_psa+0x7e>
    switch( key_type )
 c0473e6:	f242 4003 	movw	r0, #9219	@ 0x2403
 c0473ea:	4284      	cmp	r4, r0
 c0473ec:	d015      	beq.n	c04741a <mbedtls_cipher_info_from_psa+0xe6>
 c0473ee:	f242 4006 	movw	r0, #9222	@ 0x2406
 c0473f2:	4284      	cmp	r4, r0
 c0473f4:	d1c3      	bne.n	c04737e <mbedtls_cipher_info_from_psa+0x4a>
 c0473f6:	2008      	movs	r0, #8
 c0473f8:	e006      	b.n	c047408 <mbedtls_cipher_info_from_psa+0xd4>
            if( key_bits == 64 )
 c0473fa:	2940      	cmp	r1, #64	@ 0x40
 c0473fc:	d00f      	beq.n	c04741e <mbedtls_cipher_info_from_psa+0xea>
            if( key_bits == 128 )
 c0473fe:	2980      	cmp	r1, #128	@ 0x80
                cipher_id_tmp = MBEDTLS_CIPHER_ID_3DES;
 c047400:	f04f 0004 	mov.w	r0, #4
            if( key_bits == 128 )
 c047404:	d100      	bne.n	c047408 <mbedtls_cipher_info_from_psa+0xd4>
                key_bits = 192;
 c047406:	21c0      	movs	r1, #192	@ 0xc0
    if( cipher_id != NULL )
 c047408:	b103      	cbz	r3, c04740c <mbedtls_cipher_info_from_psa+0xd8>
        *cipher_id = cipher_id_tmp;
 c04740a:	7018      	strb	r0, [r3, #0]
}
 c04740c:	bc10      	pop	{r4}
    return( mbedtls_cipher_info_from_values( cipher_id_tmp,
 c04740e:	f00d bde9 	b.w	c054fe4 <mbedtls_cipher_info_from_values>
            cipher_id_tmp = MBEDTLS_CIPHER_ID_AES;
 c047412:	2002      	movs	r0, #2
 c047414:	e7f8      	b.n	c047408 <mbedtls_cipher_info_from_psa+0xd4>
            cipher_id_tmp = MBEDTLS_CIPHER_ID_CHACHA20;
 c047416:	2009      	movs	r0, #9
 c047418:	e7f6      	b.n	c047408 <mbedtls_cipher_info_from_psa+0xd4>
            cipher_id_tmp = MBEDTLS_CIPHER_ID_CAMELLIA;
 c04741a:	2005      	movs	r0, #5
 c04741c:	e7f4      	b.n	c047408 <mbedtls_cipher_info_from_psa+0xd4>
                cipher_id_tmp = MBEDTLS_CIPHER_ID_DES;
 c04741e:	2003      	movs	r0, #3
 c047420:	e7f2      	b.n	c047408 <mbedtls_cipher_info_from_psa+0xd4>
 c047422:	bf00      	nop
 c047424:	04c01100 	.word	0x04c01100
 c047428:	04404400 	.word	0x04404400
 c04742c:	04800100 	.word	0x04800100
 c047430:	04c01000 	.word	0x04c01000
 c047434:	05400100 	.word	0x05400100
 c047438:	04c01200 	.word	0x04c01200
 c04743c:	05400200 	.word	0x05400200
 c047440:	03c00200 	.word	0x03c00200

0c047444 <psa_cipher_setup.constprop.0>:

#if defined(MBEDTLS_PSA_BUILTIN_CIPHER)

static psa_status_t psa_cipher_setup(
 c047444:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c047448:	460d      	mov	r5, r1
 c04744a:	461c      	mov	r4, r3
 c04744c:	4606      	mov	r6, r0
    const mbedtls_cipher_info_t *cipher_info = NULL;
    psa_key_type_t key_type = attributes->core.type;

    (void)key_buffer_size;

    mbedtls_cipher_init( &operation->ctx.cipher );
 c04744e:	f100 0808 	add.w	r8, r0, #8
 c047452:	4640      	mov	r0, r8
static psa_status_t psa_cipher_setup(
 c047454:	4691      	mov	r9, r2
    psa_key_type_t key_type = attributes->core.type;
 c047456:	880f      	ldrh	r7, [r1, #0]
static psa_status_t psa_cipher_setup(
 c047458:	f99d b028 	ldrsb.w	fp, [sp, #40]	@ 0x28
    mbedtls_cipher_init( &operation->ctx.cipher );
 c04745c:	f00d fdd8 	bl	c055010 <mbedtls_cipher_init>

    operation->alg = alg;
    key_bits = attributes->core.bits;
 c047460:	f8b5 a002 	ldrh.w	sl, [r5, #2]
    cipher_info = mbedtls_cipher_info_from_psa( alg, key_type,
 c047464:	4639      	mov	r1, r7
 c047466:	2300      	movs	r3, #0
 c047468:	4652      	mov	r2, sl
 c04746a:	4620      	mov	r0, r4
    operation->alg = alg;
 c04746c:	6034      	str	r4, [r6, #0]
    cipher_info = mbedtls_cipher_info_from_psa( alg, key_type,
 c04746e:	f7ff ff61 	bl	c047334 <mbedtls_cipher_info_from_psa>
                                                key_bits, NULL );
    if( cipher_info == NULL )
 c047472:	4601      	mov	r1, r0
 c047474:	2800      	cmp	r0, #0
 c047476:	d05e      	beq.n	c047536 <psa_cipher_setup.constprop.0+0xf2>
        return( PSA_ERROR_NOT_SUPPORTED );

    ret = mbedtls_cipher_setup( &operation->ctx.cipher, cipher_info );
 c047478:	4640      	mov	r0, r8
 c04747a:	f00d ffb9 	bl	c0553f0 <mbedtls_cipher_setup>
    if( ret != 0 )
 c04747e:	4605      	mov	r5, r0
 c047480:	bbd0      	cbnz	r0, c0474f8 <psa_cipher_setup.constprop.0+0xb4>
                                     192, cipher_operation );
    }
    else
#endif
    {
        ret = mbedtls_cipher_setkey( &operation->ctx.cipher, key_buffer,
 c047482:	465b      	mov	r3, fp
 c047484:	4652      	mov	r2, sl
 c047486:	4649      	mov	r1, r9
 c047488:	4640      	mov	r0, r8
 c04748a:	f00d fddd 	bl	c055048 <mbedtls_cipher_setkey>
                                     (int) key_bits, cipher_operation );
    }
    if( ret != 0 )
 c04748e:	4605      	mov	r5, r0
 c047490:	bb90      	cbnz	r0, c0474f8 <psa_cipher_setup.constprop.0+0xb4>
        goto exit;

#if defined(MBEDTLS_PSA_BUILTIN_ALG_CBC_NO_PADDING) || \
    defined(MBEDTLS_PSA_BUILTIN_ALG_CBC_PKCS7)
    switch( alg )
 c047492:	4b2b      	ldr	r3, [pc, #172]	@ (c047540 <psa_cipher_setup.constprop.0+0xfc>)
 c047494:	429c      	cmp	r4, r3
 c047496:	d034      	beq.n	c047502 <psa_cipher_setup.constprop.0+0xbe>
 c047498:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 c04749c:	429c      	cmp	r4, r3
 c04749e:	d038      	beq.n	c047512 <psa_cipher_setup.constprop.0+0xce>
    if( ret != 0 )
        goto exit;
#endif /* MBEDTLS_PSA_BUILTIN_ALG_CBC_NO_PADDING ||
          MBEDTLS_PSA_BUILTIN_ALG_CBC_PKCS7 */

    operation->block_length = ( PSA_ALG_IS_STREAM_CIPHER( alg ) ? 1 :
 c0474a0:	f004 43ff 	and.w	r3, r4, #2139095040	@ 0x7f800000
 c0474a4:	f1b3 6f90 	cmp.w	r3, #75497472	@ 0x4800000
 c0474a8:	f407 42e0 	and.w	r2, r7, #28672	@ 0x7000
 c0474ac:	d033      	beq.n	c047516 <psa_cipher_setup.constprop.0+0xd2>
 c0474ae:	f5b2 5f00 	cmp.w	r2, #8192	@ 0x2000
 c0474b2:	d132      	bne.n	c04751a <psa_cipher_setup.constprop.0+0xd6>
                                PSA_BLOCK_CIPHER_BLOCK_LENGTH( key_type ) );
 c0474b4:	2301      	movs	r3, #1
 c0474b6:	f3c7 2102 	ubfx	r1, r7, #8, #3
 c0474ba:	408b      	lsls	r3, r1
    operation->block_length = ( PSA_ALG_IS_STREAM_CIPHER( alg ) ? 1 :
 c0474bc:	b2db      	uxtb	r3, r3
    operation->iv_length = PSA_CIPHER_IV_LENGTH( key_type, alg );
 c0474be:	f5b2 5f00 	cmp.w	r2, #8192	@ 0x2000
    operation->block_length = ( PSA_ALG_IS_STREAM_CIPHER( alg ) ? 1 :
 c0474c2:	7173      	strb	r3, [r6, #5]
    operation->iv_length = PSA_CIPHER_IV_LENGTH( key_type, alg );
 c0474c4:	d12b      	bne.n	c04751e <psa_cipher_setup.constprop.0+0xda>
 c0474c6:	f417 6fe0 	tst.w	r7, #1792	@ 0x700
 c0474ca:	f3c7 2202 	ubfx	r2, r7, #8, #3
 c0474ce:	d026      	beq.n	c04751e <psa_cipher_setup.constprop.0+0xda>
 c0474d0:	491c      	ldr	r1, [pc, #112]	@ (c047544 <psa_cipher_setup.constprop.0+0x100>)
 c0474d2:	f424 7380 	bic.w	r3, r4, #256	@ 0x100
 c0474d6:	428b      	cmp	r3, r1
 c0474d8:	d00a      	beq.n	c0474f0 <psa_cipher_setup.constprop.0+0xac>
 c0474da:	f501 7100 	add.w	r1, r1, #512	@ 0x200
 c0474de:	428c      	cmp	r4, r1
 c0474e0:	d006      	beq.n	c0474f0 <psa_cipher_setup.constprop.0+0xac>
 c0474e2:	4919      	ldr	r1, [pc, #100]	@ (c047548 <psa_cipher_setup.constprop.0+0x104>)
 c0474e4:	428c      	cmp	r4, r1
 c0474e6:	d003      	beq.n	c0474f0 <psa_cipher_setup.constprop.0+0xac>
 c0474e8:	f5a1 413f 	sub.w	r1, r1, #48896	@ 0xbf00
 c0474ec:	428b      	cmp	r3, r1
 c0474ee:	d116      	bne.n	c04751e <psa_cipher_setup.constprop.0+0xda>
 c0474f0:	2401      	movs	r4, #1
 c0474f2:	4094      	lsls	r4, r2
 c0474f4:	b2e4      	uxtb	r4, r4
 c0474f6:	7134      	strb	r4, [r6, #4]

exit:
    return( mbedtls_to_psa_error( ret ) );
 c0474f8:	4628      	mov	r0, r5
}
 c0474fa:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    return( mbedtls_to_psa_error( ret ) );
 c0474fe:	f7fd b9df 	b.w	c0448c0 <mbedtls_to_psa_error>
            ret = mbedtls_cipher_set_padding_mode( &operation->ctx.cipher,
 c047502:	2104      	movs	r1, #4
            ret = mbedtls_cipher_set_padding_mode( &operation->ctx.cipher,
 c047504:	4640      	mov	r0, r8
 c047506:	f00d ff3b 	bl	c055380 <mbedtls_cipher_set_padding_mode>
    if( ret != 0 )
 c04750a:	2800      	cmp	r0, #0
 c04750c:	d0c8      	beq.n	c0474a0 <psa_cipher_setup.constprop.0+0x5c>
 c04750e:	4605      	mov	r5, r0
 c047510:	e7f2      	b.n	c0474f8 <psa_cipher_setup.constprop.0+0xb4>
            ret = mbedtls_cipher_set_padding_mode( &operation->ctx.cipher,
 c047512:	4601      	mov	r1, r0
 c047514:	e7f6      	b.n	c047504 <psa_cipher_setup.constprop.0+0xc0>
    operation->block_length = ( PSA_ALG_IS_STREAM_CIPHER( alg ) ? 1 :
 c047516:	2301      	movs	r3, #1
 c047518:	e7d1      	b.n	c0474be <psa_cipher_setup.constprop.0+0x7a>
 c04751a:	2300      	movs	r3, #0
 c04751c:	e7cf      	b.n	c0474be <psa_cipher_setup.constprop.0+0x7a>
    operation->iv_length = PSA_CIPHER_IV_LENGTH( key_type, alg );
 c04751e:	f242 0304 	movw	r3, #8196	@ 0x2004
 c047522:	429f      	cmp	r7, r3
 c047524:	d105      	bne.n	c047532 <psa_cipher_setup.constprop.0+0xee>
 c047526:	4b09      	ldr	r3, [pc, #36]	@ (c04754c <psa_cipher_setup.constprop.0+0x108>)
 c047528:	429c      	cmp	r4, r3
 c04752a:	bf0c      	ite	eq
 c04752c:	240c      	moveq	r4, #12
 c04752e:	2400      	movne	r4, #0
 c047530:	e7e1      	b.n	c0474f6 <psa_cipher_setup.constprop.0+0xb2>
 c047532:	2400      	movs	r4, #0
 c047534:	e7df      	b.n	c0474f6 <psa_cipher_setup.constprop.0+0xb2>
}
 c047536:	f06f 0085 	mvn.w	r0, #133	@ 0x85
 c04753a:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 c04753e:	bf00      	nop
 c047540:	04404000 	.word	0x04404000
 c047544:	04c01000 	.word	0x04c01000
 c047548:	0440ff00 	.word	0x0440ff00
 c04754c:	04800100 	.word	0x04800100

0c047550 <mbedtls_psa_cipher_encrypt_setup>:
psa_status_t mbedtls_psa_cipher_encrypt_setup(
    mbedtls_psa_cipher_operation_t *operation,
    const psa_key_attributes_t *attributes,
    const uint8_t *key_buffer, size_t key_buffer_size,
    psa_algorithm_t alg )
{
 c047550:	b410      	push	{r4}
    return( psa_cipher_setup( operation, attributes,
 c047552:	2401      	movs	r4, #1
{
 c047554:	9b01      	ldr	r3, [sp, #4]
    return( psa_cipher_setup( operation, attributes,
 c047556:	9401      	str	r4, [sp, #4]
                              key_buffer, key_buffer_size,
                              alg, MBEDTLS_ENCRYPT ) );
}
 c047558:	bc10      	pop	{r4}
    return( psa_cipher_setup( operation, attributes,
 c04755a:	f7ff bf73 	b.w	c047444 <psa_cipher_setup.constprop.0>

0c04755e <mbedtls_psa_cipher_decrypt_setup>:
psa_status_t mbedtls_psa_cipher_decrypt_setup(
    mbedtls_psa_cipher_operation_t *operation,
    const psa_key_attributes_t *attributes,
    const uint8_t *key_buffer, size_t key_buffer_size,
    psa_algorithm_t alg )
{
 c04755e:	b410      	push	{r4}
    return( psa_cipher_setup( operation, attributes,
 c047560:	2400      	movs	r4, #0
{
 c047562:	9b01      	ldr	r3, [sp, #4]
    return( psa_cipher_setup( operation, attributes,
 c047564:	9401      	str	r4, [sp, #4]
                              key_buffer, key_buffer_size,
                              alg, MBEDTLS_DECRYPT ) );
}
 c047566:	bc10      	pop	{r4}
    return( psa_cipher_setup( operation, attributes,
 c047568:	f7ff bf6c 	b.w	c047444 <psa_cipher_setup.constprop.0>

0c04756c <mbedtls_psa_cipher_set_iv>:

psa_status_t mbedtls_psa_cipher_set_iv(
    mbedtls_psa_cipher_operation_t *operation,
    const uint8_t *iv, size_t iv_length )
{
 c04756c:	b508      	push	{r3, lr}
    if( iv_length != operation->iv_length )
 c04756e:	7903      	ldrb	r3, [r0, #4]
 c047570:	4293      	cmp	r3, r2
 c047572:	d106      	bne.n	c047582 <mbedtls_psa_cipher_set_iv+0x16>
        return( PSA_ERROR_INVALID_ARGUMENT );

    return( mbedtls_to_psa_error(
 c047574:	3008      	adds	r0, #8
 c047576:	f00d fd87 	bl	c055088 <mbedtls_cipher_set_iv>
                mbedtls_cipher_set_iv( &operation->ctx.cipher,
                                       iv, iv_length ) ) );
}
 c04757a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    return( mbedtls_to_psa_error(
 c04757e:	f7fd b99f 	b.w	c0448c0 <mbedtls_to_psa_error>
}
 c047582:	f06f 0086 	mvn.w	r0, #134	@ 0x86
 c047586:	bd08      	pop	{r3, pc}

0c047588 <mbedtls_psa_cipher_update>:

psa_status_t mbedtls_psa_cipher_update(
    mbedtls_psa_cipher_operation_t *operation,
    const uint8_t *input, size_t input_length,
    uint8_t *output, size_t output_size, size_t *output_length )
{
 c047588:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c04758c:	4615      	mov	r5, r2
    psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
    size_t expected_output_size;

    if( ! PSA_ALG_IS_STREAM_CIPHER( operation->alg ) )
 c04758e:	6802      	ldr	r2, [r0, #0]
{
 c047590:	469b      	mov	fp, r3
    if( ! PSA_ALG_IS_STREAM_CIPHER( operation->alg ) )
 c047592:	f002 43ff 	and.w	r3, r2, #2139095040	@ 0x7f800000
 c047596:	f1b3 6f90 	cmp.w	r3, #75497472	@ 0x4800000
        /* Take the unprocessed partial block left over from previous
         * update calls, if any, plus the input to this call. Remove
         * the last partial block, if any. You get the data that will be
         * output in this call. */
        expected_output_size =
            ( operation->ctx.cipher.unprocessed_len + input_length )
 c04759a:	bf18      	it	ne
 c04759c:	6ac3      	ldrne	r3, [r0, #44]	@ 0x2c
{
 c04759e:	460e      	mov	r6, r1
            / operation->block_length * operation->block_length;
 c0475a0:	bf1d      	ittte	ne
 c0475a2:	7941      	ldrbne	r1, [r0, #5]
            ( operation->ctx.cipher.unprocessed_len + input_length )
 c0475a4:	195b      	addne	r3, r3, r5
        expected_output_size =
 c0475a6:	fbb3 f3f1 	udivne	r3, r3, r1
 c0475aa:	462b      	moveq	r3, r5
 c0475ac:	bf18      	it	ne
 c0475ae:	434b      	mulne	r3, r1
{
 c0475b0:	b085      	sub	sp, #20
 c0475b2:	e9dd 870e 	ldrd	r8, r7, [sp, #56]	@ 0x38
    else
    {
        expected_output_size = input_length;
    }

    if( output_size < expected_output_size )
 c0475b6:	4543      	cmp	r3, r8
{
 c0475b8:	4604      	mov	r4, r0
    if( output_size < expected_output_size )
 c0475ba:	d86a      	bhi.n	c047692 <mbedtls_psa_cipher_update+0x10a>
        return( PSA_ERROR_BUFFER_TOO_SMALL );

    if( operation->alg == PSA_ALG_ECB_NO_PADDING )
 c0475bc:	4b36      	ldr	r3, [pc, #216]	@ (c047698 <mbedtls_psa_cipher_update+0x110>)
    {
        /* mbedtls_cipher_update has an API inconsistency: it will only
        * process a single block at a time in ECB mode. Abstract away that
        * inconsistency here to match the PSA API behaviour. */
        status = psa_cipher_update_ecb( &operation->ctx.cipher,
 c0475be:	f100 0908 	add.w	r9, r0, #8
    if( operation->alg == PSA_ALG_ECB_NO_PADDING )
 c0475c2:	429a      	cmp	r2, r3
 c0475c4:	d156      	bne.n	c047674 <mbedtls_psa_cipher_update+0xec>
    size_t block_size = ctx->cipher_info->block_size;
 c0475c6:	6883      	ldr	r3, [r0, #8]
 c0475c8:	f8d3 8014 	ldr.w	r8, [r3, #20]
    size_t internal_output_length = 0;
 c0475cc:	2300      	movs	r3, #0
 c0475ce:	9303      	str	r3, [sp, #12]
    *output_length = 0;
 c0475d0:	603b      	str	r3, [r7, #0]
    if( input_length == 0 )
 c0475d2:	2d00      	cmp	r5, #0
 c0475d4:	d035      	beq.n	c047642 <mbedtls_psa_cipher_update+0xba>
    if( ctx->unprocessed_len > 0 )
 c0475d6:	6ac0      	ldr	r0, [r0, #44]	@ 0x2c
 c0475d8:	b320      	cbz	r0, c047624 <mbedtls_psa_cipher_update+0x9c>
        size_t bytes_to_copy = block_size - ctx->unprocessed_len;
 c0475da:	eba8 0a00 	sub.w	sl, r8, r0
 c0475de:	45aa      	cmp	sl, r5
 c0475e0:	bf28      	it	cs
 c0475e2:	46aa      	movcs	sl, r5
        memcpy( &( ctx->unprocessed_data[ctx->unprocessed_len] ),
 c0475e4:	301c      	adds	r0, #28
 c0475e6:	4631      	mov	r1, r6
 c0475e8:	4652      	mov	r2, sl
 c0475ea:	4420      	add	r0, r4
 c0475ec:	f014 f82e 	bl	c05b64c <memcpy>
        ctx->unprocessed_len += bytes_to_copy;
 c0475f0:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
        input_length -= bytes_to_copy;
 c0475f2:	eba5 050a 	sub.w	r5, r5, sl
        ctx->unprocessed_len += bytes_to_copy;
 c0475f6:	4453      	add	r3, sl
        if( ctx->unprocessed_len == block_size )
 c0475f8:	4598      	cmp	r8, r3
        input += bytes_to_copy;
 c0475fa:	4456      	add	r6, sl
        ctx->unprocessed_len += bytes_to_copy;
 c0475fc:	62e3      	str	r3, [r4, #44]	@ 0x2c
        if( ctx->unprocessed_len == block_size )
 c0475fe:	d111      	bne.n	c047624 <mbedtls_psa_cipher_update+0x9c>
            status = mbedtls_to_psa_error(
 c047600:	ab03      	add	r3, sp, #12
 c047602:	4642      	mov	r2, r8
 c047604:	9300      	str	r3, [sp, #0]
 c047606:	f104 011c 	add.w	r1, r4, #28
 c04760a:	465b      	mov	r3, fp
 c04760c:	4648      	mov	r0, r9
 c04760e:	f00d fd5b 	bl	c0550c8 <mbedtls_cipher_update>
 c047612:	f7fd f955 	bl	c0448c0 <mbedtls_to_psa_error>
            if( status != PSA_SUCCESS )
 c047616:	b9a8      	cbnz	r0, c047644 <mbedtls_psa_cipher_update+0xbc>
            *output_length += internal_output_length;
 c047618:	683b      	ldr	r3, [r7, #0]
            output += internal_output_length;
 c04761a:	9a03      	ldr	r2, [sp, #12]
            *output_length += internal_output_length;
 c04761c:	4413      	add	r3, r2
 c04761e:	603b      	str	r3, [r7, #0]
            output += internal_output_length;
 c047620:	4493      	add	fp, r2
            ctx->unprocessed_len = 0;
 c047622:	62e0      	str	r0, [r4, #44]	@ 0x2c
        status = mbedtls_to_psa_error(
 c047624:	f10d 0a0c 	add.w	sl, sp, #12
    while( input_length >= block_size )
 c047628:	45a8      	cmp	r8, r5
 c04762a:	d90e      	bls.n	c04764a <mbedtls_psa_cipher_update+0xc2>
    if( input_length > 0 )
 c04762c:	b14d      	cbz	r5, c047642 <mbedtls_psa_cipher_update+0xba>
        memcpy( &( ctx->unprocessed_data[ctx->unprocessed_len] ),
 c04762e:	6ae0      	ldr	r0, [r4, #44]	@ 0x2c
 c047630:	462a      	mov	r2, r5
 c047632:	301c      	adds	r0, #28
 c047634:	4631      	mov	r1, r6
 c047636:	4420      	add	r0, r4
 c047638:	f014 f808 	bl	c05b64c <memcpy>
        ctx->unprocessed_len += input_length;
 c04763c:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
 c04763e:	442b      	add	r3, r5
 c047640:	62e3      	str	r3, [r4, #44]	@ 0x2c
        status = PSA_SUCCESS;
 c047642:	2000      	movs	r0, #0
        if( *output_length > output_size )
            return( PSA_ERROR_CORRUPTION_DETECTED );
    }

    return( status );
}
 c047644:	b005      	add	sp, #20
 c047646:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        status = mbedtls_to_psa_error(
 c04764a:	465b      	mov	r3, fp
 c04764c:	4642      	mov	r2, r8
 c04764e:	4631      	mov	r1, r6
 c047650:	4648      	mov	r0, r9
 c047652:	f8cd a000 	str.w	sl, [sp]
 c047656:	f00d fd37 	bl	c0550c8 <mbedtls_cipher_update>
 c04765a:	f7fd f931 	bl	c0448c0 <mbedtls_to_psa_error>
        if( status != PSA_SUCCESS )
 c04765e:	2800      	cmp	r0, #0
 c047660:	d1f0      	bne.n	c047644 <mbedtls_psa_cipher_update+0xbc>
        output += internal_output_length;
 c047662:	9a03      	ldr	r2, [sp, #12]
        *output_length += internal_output_length;
 c047664:	683b      	ldr	r3, [r7, #0]
        input_length -= block_size;
 c047666:	eba5 0508 	sub.w	r5, r5, r8
        *output_length += internal_output_length;
 c04766a:	4413      	add	r3, r2
        input += block_size;
 c04766c:	4446      	add	r6, r8
        output += internal_output_length;
 c04766e:	4493      	add	fp, r2
        *output_length += internal_output_length;
 c047670:	603b      	str	r3, [r7, #0]
 c047672:	e7d9      	b.n	c047628 <mbedtls_psa_cipher_update+0xa0>
        status = mbedtls_to_psa_error(
 c047674:	465b      	mov	r3, fp
 c047676:	462a      	mov	r2, r5
 c047678:	4631      	mov	r1, r6
 c04767a:	4648      	mov	r0, r9
 c04767c:	9700      	str	r7, [sp, #0]
 c04767e:	f00d fd23 	bl	c0550c8 <mbedtls_cipher_update>
 c047682:	f7fd f91d 	bl	c0448c0 <mbedtls_to_psa_error>
        if( *output_length > output_size )
 c047686:	683b      	ldr	r3, [r7, #0]
            return( PSA_ERROR_CORRUPTION_DETECTED );
 c047688:	4543      	cmp	r3, r8
 c04768a:	bf88      	it	hi
 c04768c:	f06f 0096 	mvnhi.w	r0, #150	@ 0x96
 c047690:	e7d8      	b.n	c047644 <mbedtls_psa_cipher_update+0xbc>
        return( PSA_ERROR_BUFFER_TOO_SMALL );
 c047692:	f06f 0089 	mvn.w	r0, #137	@ 0x89
 c047696:	e7d5      	b.n	c047644 <mbedtls_psa_cipher_update+0xbc>
 c047698:	04404400 	.word	0x04404400

0c04769c <mbedtls_psa_cipher_finish>:

psa_status_t mbedtls_psa_cipher_finish(
    mbedtls_psa_cipher_operation_t *operation,
    uint8_t *output, size_t output_size, size_t *output_length )
{
 c04769c:	b5f0      	push	{r4, r5, r6, r7, lr}
 c04769e:	461d      	mov	r5, r3
    psa_status_t status = PSA_ERROR_GENERIC_ERROR;
    uint8_t temp_output_buffer[MBEDTLS_MAX_BLOCK_LENGTH];

    if( operation->ctx.cipher.unprocessed_len != 0 )
 c0476a0:	6ac3      	ldr	r3, [r0, #44]	@ 0x2c
{
 c0476a2:	460e      	mov	r6, r1
 c0476a4:	4617      	mov	r7, r2
 c0476a6:	b085      	sub	sp, #20
    if( operation->ctx.cipher.unprocessed_len != 0 )
 c0476a8:	b12b      	cbz	r3, c0476b6 <mbedtls_psa_cipher_finish+0x1a>
    {
        if( operation->alg == PSA_ALG_ECB_NO_PADDING ||
 c0476aa:	6803      	ldr	r3, [r0, #0]
 c0476ac:	4a11      	ldr	r2, [pc, #68]	@ (c0476f4 <mbedtls_psa_cipher_finish+0x58>)
 c0476ae:	f423 6380 	bic.w	r3, r3, #1024	@ 0x400
 c0476b2:	4293      	cmp	r3, r2
 c0476b4:	d017      	beq.n	c0476e6 <mbedtls_psa_cipher_finish+0x4a>
            status = PSA_ERROR_INVALID_ARGUMENT;
            goto exit;
        }
    }

    status = mbedtls_to_psa_error(
 c0476b6:	462a      	mov	r2, r5
 c0476b8:	4669      	mov	r1, sp
 c0476ba:	3008      	adds	r0, #8
 c0476bc:	f00d fe00 	bl	c0552c0 <mbedtls_cipher_finish>
 c0476c0:	f7fd f8fe 	bl	c0448c0 <mbedtls_to_psa_error>
        mbedtls_cipher_finish( &operation->ctx.cipher,
                               temp_output_buffer,
                               output_length ) );
    if( status != PSA_SUCCESS )
 c0476c4:	4604      	mov	r4, r0
 c0476c6:	b938      	cbnz	r0, c0476d8 <mbedtls_psa_cipher_finish+0x3c>
        goto exit;

    if( *output_length == 0 )
 c0476c8:	682a      	ldr	r2, [r5, #0]
 c0476ca:	b12a      	cbz	r2, c0476d8 <mbedtls_psa_cipher_finish+0x3c>
        ; /* Nothing to copy. Note that output may be NULL in this case. */
    else if( output_size >= *output_length )
 c0476cc:	42ba      	cmp	r2, r7
 c0476ce:	d80d      	bhi.n	c0476ec <mbedtls_psa_cipher_finish+0x50>
        memcpy( output, temp_output_buffer, *output_length );
 c0476d0:	4669      	mov	r1, sp
 c0476d2:	4630      	mov	r0, r6
 c0476d4:	f013 ffba 	bl	c05b64c <memcpy>
    else
        status = PSA_ERROR_BUFFER_TOO_SMALL;

exit:
    mbedtls_platform_zeroize( temp_output_buffer,
 c0476d8:	4668      	mov	r0, sp
 c0476da:	2110      	movs	r1, #16
 c0476dc:	f7f3 fe78 	bl	c03b3d0 <mbedtls_platform_zeroize>
                              sizeof( temp_output_buffer ) );

    return( status );
}
 c0476e0:	4620      	mov	r0, r4
 c0476e2:	b005      	add	sp, #20
 c0476e4:	bdf0      	pop	{r4, r5, r6, r7, pc}
            status = PSA_ERROR_INVALID_ARGUMENT;
 c0476e6:	f06f 0486 	mvn.w	r4, #134	@ 0x86
 c0476ea:	e7f5      	b.n	c0476d8 <mbedtls_psa_cipher_finish+0x3c>
        status = PSA_ERROR_BUFFER_TOO_SMALL;
 c0476ec:	f06f 0489 	mvn.w	r4, #137	@ 0x89
 c0476f0:	e7f2      	b.n	c0476d8 <mbedtls_psa_cipher_finish+0x3c>
 c0476f2:	bf00      	nop
 c0476f4:	04404000 	.word	0x04404000

0c0476f8 <mbedtls_psa_cipher_abort>:

psa_status_t mbedtls_psa_cipher_abort(
    mbedtls_psa_cipher_operation_t *operation )
{
 c0476f8:	b508      	push	{r3, lr}
    /* Sanity check (shouldn't happen: operation->alg should
     * always have been initialized to a valid value). */
    if( ! PSA_ALG_IS_CIPHER( operation->alg ) )
 c0476fa:	6803      	ldr	r3, [r0, #0]
 c0476fc:	f003 43fe 	and.w	r3, r3, #2130706432	@ 0x7f000000
 c047700:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
 c047704:	d104      	bne.n	c047710 <mbedtls_psa_cipher_abort+0x18>
        return( PSA_ERROR_BAD_STATE );

    mbedtls_cipher_free( &operation->ctx.cipher );
 c047706:	3008      	adds	r0, #8
 c047708:	f00d fc86 	bl	c055018 <mbedtls_cipher_free>

    return( PSA_SUCCESS );
 c04770c:	2000      	movs	r0, #0
}
 c04770e:	bd08      	pop	{r3, pc}
        return( PSA_ERROR_BAD_STATE );
 c047710:	f06f 0088 	mvn.w	r0, #136	@ 0x88
 c047714:	e7fb      	b.n	c04770e <mbedtls_psa_cipher_abort+0x16>

0c047716 <mbedcrypto__psa_reset_key_attributes>:
#define mbedtls_calloc calloc
#define mbedtls_free   free
#endif

void psa_reset_key_attributes( psa_key_attributes_t *attributes )
{
 c047716:	b510      	push	{r4, lr}
 c047718:	4604      	mov	r4, r0
    mbedtls_free( attributes->domain_parameters );
 c04771a:	6a80      	ldr	r0, [r0, #40]	@ 0x28
 c04771c:	f7f3 fe48 	bl	c03b3b0 <mbedtls_free>
    memset( attributes, 0, sizeof( *attributes ) );
 c047720:	4620      	mov	r0, r4
}
 c047722:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    memset( attributes, 0, sizeof( *attributes ) );
 c047726:	2230      	movs	r2, #48	@ 0x30
 c047728:	2100      	movs	r1, #0
 c04772a:	f014 b800 	b.w	c05b72e <memset>

0c04772e <mbedcrypto__psa_set_key_domain_parameters>:

psa_status_t psa_set_key_domain_parameters( psa_key_attributes_t *attributes,
                                            psa_key_type_t type,
                                            const uint8_t *data,
                                            size_t data_length )
{
 c04772e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 c047732:	4605      	mov	r5, r0
 c047734:	460f      	mov	r7, r1
 c047736:	4690      	mov	r8, r2
    uint8_t *copy = NULL;

    if( data_length != 0 )
 c047738:	461c      	mov	r4, r3
 c04773a:	b19b      	cbz	r3, c047764 <mbedcrypto__psa_set_key_domain_parameters+0x36>
    {
        copy = mbedtls_calloc( 1, data_length );
 c04773c:	4619      	mov	r1, r3
 c04773e:	2001      	movs	r0, #1
 c047740:	f7f3 fe30 	bl	c03b3a4 <mbedtls_calloc>
        if( copy == NULL )
 c047744:	4606      	mov	r6, r0
 c047746:	b178      	cbz	r0, c047768 <mbedcrypto__psa_set_key_domain_parameters+0x3a>
            return( PSA_ERROR_INSUFFICIENT_MEMORY );
        memcpy( copy, data, data_length );
 c047748:	4622      	mov	r2, r4
 c04774a:	4641      	mov	r1, r8
 c04774c:	f013 ff7e 	bl	c05b64c <memcpy>
    }
    /* After this point, this function is guaranteed to succeed, so it
     * can start modifying `*attributes`. */

    if( attributes->domain_parameters != NULL )
 c047750:	6aa8      	ldr	r0, [r5, #40]	@ 0x28
 c047752:	b108      	cbz	r0, c047758 <mbedcrypto__psa_set_key_domain_parameters+0x2a>
    {
        mbedtls_free( attributes->domain_parameters );
 c047754:	f7f3 fe2c 	bl	c03b3b0 <mbedtls_free>
    }

    attributes->domain_parameters = copy;
    attributes->domain_parameters_size = data_length;
    attributes->core.type = type;
    return( PSA_SUCCESS );
 c047758:	2000      	movs	r0, #0
    attributes->domain_parameters_size = data_length;
 c04775a:	e9c5 640a 	strd	r6, r4, [r5, #40]	@ 0x28
    attributes->core.type = type;
 c04775e:	802f      	strh	r7, [r5, #0]
}
 c047760:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    uint8_t *copy = NULL;
 c047764:	461e      	mov	r6, r3
 c047766:	e7f3      	b.n	c047750 <mbedcrypto__psa_set_key_domain_parameters+0x22>
            return( PSA_ERROR_INSUFFICIENT_MEMORY );
 c047768:	f06f 008c 	mvn.w	r0, #140	@ 0x8c
 c04776c:	e7f8      	b.n	c047760 <mbedcrypto__psa_set_key_domain_parameters+0x32>

0c04776e <psa_driver_wrapper_init>:
psa_status_t psa_driver_wrapper_init( void )
{
    psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;

#if defined(MBEDTLS_PSA_CRYPTO_SE_C)
    status = psa_init_all_se_drivers( );
 c04776e:	f001 bb0d 	b.w	c048d8c <psa_init_all_se_drivers>

0c047772 <psa_driver_wrapper_free>:
void psa_driver_wrapper_free( void )
{
#if defined(MBEDTLS_PSA_CRYPTO_SE_C)
    /* Unregister all secure element drivers, so that we restart from
     * a pristine state. */
    psa_unregister_all_se_drivers( );
 c047772:	f001 bb6b 	b.w	c048e4c <psa_unregister_all_se_drivers>

0c047776 <psa_driver_wrapper_sign_message>:
            /* Key is declared with a lifetime not known to us */
            (void)status;
            break;
    }

    return( psa_sign_message_builtin( attributes,
 c047776:	f7fe ba51 	b.w	c045c1c <psa_sign_message_builtin>

0c04777a <psa_driver_wrapper_verify_message>:
            /* Key is declared with a lifetime not known to us */
            (void)status;
            break;
    }

    return( psa_verify_message_builtin( attributes,
 c04777a:	f7fe ba9b 	b.w	c045cb4 <psa_verify_message_builtin>

0c04777e <psa_driver_wrapper_sign_hash>:
psa_status_t psa_driver_wrapper_sign_hash(
    const psa_key_attributes_t *attributes,
    const uint8_t *key_buffer, size_t key_buffer_size,
    psa_algorithm_t alg, const uint8_t *hash, size_t hash_length,
    uint8_t *signature, size_t signature_size, size_t *signature_length )
{
 c04777e:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c047782:	b089      	sub	sp, #36	@ 0x24
 c047784:	4604      	mov	r4, r0
 c047786:	e9dd 9a14 	ldrd	r9, sl, [sp, #80]	@ 0x50
 c04778a:	460d      	mov	r5, r1
 c04778c:	4616      	mov	r6, r2
    /* Try dynamically-registered SE interface first */
#if defined(MBEDTLS_PSA_CRYPTO_SE_C)
    const psa_drv_se_t *drv;
    psa_drv_se_context_t *drv_context;

    if( psa_get_se_driver( attributes->core.lifetime, &drv, &drv_context ) )
 c04778e:	6840      	ldr	r0, [r0, #4]
 c047790:	aa07      	add	r2, sp, #28
 c047792:	a906      	add	r1, sp, #24
{
 c047794:	4698      	mov	r8, r3
 c047796:	9f12      	ldr	r7, [sp, #72]	@ 0x48
 c047798:	f8dd b058 	ldr.w	fp, [sp, #88]	@ 0x58
    if( psa_get_se_driver( attributes->core.lifetime, &drv, &drv_context ) )
 c04779c:	f001 fa64 	bl	c048c68 <psa_get_se_driver>
 c0477a0:	b1a0      	cbz	r0, c0477cc <psa_driver_wrapper_sign_hash+0x4e>
    {
        if( drv->asymmetric == NULL ||
 c0477a2:	9a06      	ldr	r2, [sp, #24]
 c0477a4:	69d2      	ldr	r2, [r2, #28]
 c0477a6:	b312      	cbz	r2, c0477ee <psa_driver_wrapper_sign_hash+0x70>
            drv->asymmetric->p_sign == NULL )
 c0477a8:	6811      	ldr	r1, [r2, #0]
        if( drv->asymmetric == NULL ||
 c0477aa:	b301      	cbz	r1, c0477ee <psa_driver_wrapper_sign_hash+0x70>
        {
            /* Key is defined in SE, but we have no way to exercise it */
            return( PSA_ERROR_NOT_SUPPORTED );
        }
        return( drv->asymmetric->p_sign(
 c0477ac:	9b13      	ldr	r3, [sp, #76]	@ 0x4c
 c0477ae:	e9cd ab04 	strd	sl, fp, [sp, #16]
 c0477b2:	e9cd 7301 	strd	r7, r3, [sp, #4]
 c0477b6:	f8cd 900c 	str.w	r9, [sp, #12]
 c0477ba:	f8cd 8000 	str.w	r8, [sp]
 c0477be:	9807      	ldr	r0, [sp, #28]
 c0477c0:	e9d5 2300 	ldrd	r2, r3, [r5]
 c0477c4:	4788      	blx	r1
        default:
            /* Key is declared with a lifetime not known to us */
            (void)status;
            return( PSA_ERROR_INVALID_ARGUMENT );
    }
}
 c0477c6:	b009      	add	sp, #36	@ 0x24
 c0477c8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    psa_key_location_t location =
 c0477cc:	6862      	ldr	r2, [r4, #4]
    switch( location )
 c0477ce:	0a12      	lsrs	r2, r2, #8
 c0477d0:	d110      	bne.n	c0477f4 <psa_driver_wrapper_sign_hash+0x76>
            return( psa_sign_hash_builtin( attributes,
 c0477d2:	9b13      	ldr	r3, [sp, #76]	@ 0x4c
 c0477d4:	4632      	mov	r2, r6
 c0477d6:	e9cd 7300 	strd	r7, r3, [sp]
 c0477da:	4629      	mov	r1, r5
 c0477dc:	4643      	mov	r3, r8
 c0477de:	4620      	mov	r0, r4
 c0477e0:	e9cd ab03 	strd	sl, fp, [sp, #12]
 c0477e4:	f8cd 9008 	str.w	r9, [sp, #8]
 c0477e8:	f7fe faae 	bl	c045d48 <psa_sign_hash_builtin>
 c0477ec:	e7eb      	b.n	c0477c6 <psa_driver_wrapper_sign_hash+0x48>
            return( PSA_ERROR_NOT_SUPPORTED );
 c0477ee:	f06f 0085 	mvn.w	r0, #133	@ 0x85
 c0477f2:	e7e8      	b.n	c0477c6 <psa_driver_wrapper_sign_hash+0x48>
            return( PSA_ERROR_INVALID_ARGUMENT );
 c0477f4:	f06f 0086 	mvn.w	r0, #134	@ 0x86
 c0477f8:	e7e5      	b.n	c0477c6 <psa_driver_wrapper_sign_hash+0x48>

0c0477fa <psa_driver_wrapper_verify_hash>:
psa_status_t psa_driver_wrapper_verify_hash(
    const psa_key_attributes_t *attributes,
    const uint8_t *key_buffer, size_t key_buffer_size,
    psa_algorithm_t alg, const uint8_t *hash, size_t hash_length,
    const uint8_t *signature, size_t signature_length )
{
 c0477fa:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c0477fe:	b089      	sub	sp, #36	@ 0x24
 c047800:	4604      	mov	r4, r0
 c047802:	e9dd 8912 	ldrd	r8, r9, [sp, #72]	@ 0x48
 c047806:	e9dd ab14 	ldrd	sl, fp, [sp, #80]	@ 0x50
 c04780a:	460d      	mov	r5, r1
 c04780c:	4617      	mov	r7, r2
    /* Try dynamically-registered SE interface first */
#if defined(MBEDTLS_PSA_CRYPTO_SE_C)
    const psa_drv_se_t *drv;
    psa_drv_se_context_t *drv_context;

    if( psa_get_se_driver( attributes->core.lifetime, &drv, &drv_context ) )
 c04780e:	6840      	ldr	r0, [r0, #4]
 c047810:	aa07      	add	r2, sp, #28
 c047812:	a906      	add	r1, sp, #24
{
 c047814:	461e      	mov	r6, r3
    if( psa_get_se_driver( attributes->core.lifetime, &drv, &drv_context ) )
 c047816:	f001 fa27 	bl	c048c68 <psa_get_se_driver>
 c04781a:	b180      	cbz	r0, c04783e <psa_driver_wrapper_verify_hash+0x44>
    {
        if( drv->asymmetric == NULL ||
 c04781c:	9b06      	ldr	r3, [sp, #24]
 c04781e:	69db      	ldr	r3, [r3, #28]
 c047820:	b1db      	cbz	r3, c04785a <psa_driver_wrapper_verify_hash+0x60>
            drv->asymmetric->p_verify == NULL )
 c047822:	6859      	ldr	r1, [r3, #4]
        if( drv->asymmetric == NULL ||
 c047824:	b1c9      	cbz	r1, c04785a <psa_driver_wrapper_verify_hash+0x60>
        {
            /* Key is defined in SE, but we have no way to exercise it */
            return( PSA_ERROR_NOT_SUPPORTED );
        }
        return( drv->asymmetric->p_verify(
 c047826:	e9cd ab03 	strd	sl, fp, [sp, #12]
 c04782a:	e9cd 8901 	strd	r8, r9, [sp, #4]
 c04782e:	9600      	str	r6, [sp, #0]
 c047830:	9807      	ldr	r0, [sp, #28]
 c047832:	e9d5 2300 	ldrd	r2, r3, [r5]
 c047836:	4788      	blx	r1
        default:
            /* Key is declared with a lifetime not known to us */
            (void)status;
            return( PSA_ERROR_INVALID_ARGUMENT );
    }
}
 c047838:	b009      	add	sp, #36	@ 0x24
 c04783a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    psa_key_location_t location =
 c04783e:	6863      	ldr	r3, [r4, #4]
    switch( location )
 c047840:	0a1b      	lsrs	r3, r3, #8
 c047842:	d10d      	bne.n	c047860 <psa_driver_wrapper_verify_hash+0x66>
            return( psa_verify_hash_builtin( attributes,
 c047844:	4633      	mov	r3, r6
 c047846:	463a      	mov	r2, r7
 c047848:	4629      	mov	r1, r5
 c04784a:	4620      	mov	r0, r4
 c04784c:	e9cd ab02 	strd	sl, fp, [sp, #8]
 c047850:	e9cd 8900 	strd	r8, r9, [sp]
 c047854:	f7fe fade 	bl	c045e14 <psa_verify_hash_builtin>
 c047858:	e7ee      	b.n	c047838 <psa_driver_wrapper_verify_hash+0x3e>
            return( PSA_ERROR_NOT_SUPPORTED );
 c04785a:	f06f 0085 	mvn.w	r0, #133	@ 0x85
 c04785e:	e7eb      	b.n	c047838 <psa_driver_wrapper_verify_hash+0x3e>
            return( PSA_ERROR_INVALID_ARGUMENT );
 c047860:	f06f 0086 	mvn.w	r0, #134	@ 0x86
 c047864:	e7e8      	b.n	c047838 <psa_driver_wrapper_verify_hash+0x3e>

0c047866 <psa_driver_wrapper_get_key_buffer_size>:
{
    psa_key_location_t location = PSA_KEY_LIFETIME_GET_LOCATION( attributes->core.lifetime );
    psa_key_type_t key_type = attributes->core.type;
    size_t key_bits = attributes->core.bits;

    *key_buffer_size = 0;
 c047866:	2300      	movs	r3, #0
        default:
            (void)key_type;
            (void)key_bits;
            return( PSA_ERROR_NOT_SUPPORTED );
    }
}
 c047868:	f06f 0085 	mvn.w	r0, #133	@ 0x85
    *key_buffer_size = 0;
 c04786c:	600b      	str	r3, [r1, #0]
}
 c04786e:	4770      	bx	lr

0c047870 <psa_driver_wrapper_generate_key>:

psa_status_t psa_driver_wrapper_generate_key(
    const psa_key_attributes_t *attributes,
    uint8_t *key_buffer, size_t key_buffer_size, size_t *key_buffer_length )
{
 c047870:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
    psa_key_location_t location =
        PSA_KEY_LIFETIME_GET_LOCATION(attributes->core.lifetime);
 c047874:	f8d0 8004 	ldr.w	r8, [r0, #4]
{
 c047878:	b088      	sub	sp, #32
 c04787a:	4604      	mov	r4, r0
 c04787c:	460d      	mov	r5, r1
 c04787e:	4616      	mov	r6, r2
    /* Try dynamically-registered SE interface first */
#if defined(MBEDTLS_PSA_CRYPTO_SE_C)
    const psa_drv_se_t *drv;
    psa_drv_se_context_t *drv_context;

    if( psa_get_se_driver( attributes->core.lifetime, &drv, &drv_context ) )
 c047880:	4640      	mov	r0, r8
 c047882:	aa06      	add	r2, sp, #24
 c047884:	a905      	add	r1, sp, #20
{
 c047886:	461f      	mov	r7, r3
    if( psa_get_se_driver( attributes->core.lifetime, &drv, &drv_context ) )
 c047888:	f001 f9ee 	bl	c048c68 <psa_get_se_driver>
 c04788c:	b1a8      	cbz	r0, c0478ba <psa_driver_wrapper_generate_key+0x4a>
    {
        size_t pubkey_length = 0; /* We don't support this feature yet */
 c04788e:	2300      	movs	r3, #0
        if( drv->key_management == NULL ||
 c047890:	9a05      	ldr	r2, [sp, #20]
        size_t pubkey_length = 0; /* We don't support this feature yet */
 c047892:	9307      	str	r3, [sp, #28]
        if( drv->key_management == NULL ||
 c047894:	68d2      	ldr	r2, [r2, #12]
 c047896:	b16a      	cbz	r2, c0478b4 <psa_driver_wrapper_generate_key+0x44>
            drv->key_management->p_generate == NULL )
 c047898:	68d1      	ldr	r1, [r2, #12]
        if( drv->key_management == NULL ||
 c04789a:	b159      	cbz	r1, c0478b4 <psa_driver_wrapper_generate_key+0x44>
        {
            /* Key is defined as being in SE, but we have no way to generate it */
            return( PSA_ERROR_NOT_SUPPORTED );
        }
        return( drv->key_management->p_generate(
 c04789c:	aa07      	add	r2, sp, #28
 c04789e:	e9cd 3202 	strd	r3, r2, [sp, #8]
 c0478a2:	e9cd 4300 	strd	r4, r3, [sp]
 c0478a6:	9806      	ldr	r0, [sp, #24]
 c0478a8:	e9d5 2300 	ldrd	r2, r3, [r5]
 c0478ac:	4788      	blx	r1
            status = PSA_ERROR_INVALID_ARGUMENT;
            break;
    }

    return( status );
}
 c0478ae:	b008      	add	sp, #32
 c0478b0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
            return( PSA_ERROR_NOT_SUPPORTED );
 c0478b4:	f06f 0085 	mvn.w	r0, #133	@ 0x85
 c0478b8:	e7f9      	b.n	c0478ae <psa_driver_wrapper_generate_key+0x3e>
    switch( location )
 c0478ba:	ea5f 2818 	movs.w	r8, r8, lsr #8
 c0478be:	d106      	bne.n	c0478ce <psa_driver_wrapper_generate_key+0x5e>
            status = psa_generate_key_internal(
 c0478c0:	463b      	mov	r3, r7
 c0478c2:	4632      	mov	r2, r6
 c0478c4:	4629      	mov	r1, r5
 c0478c6:	4620      	mov	r0, r4
 c0478c8:	f7ff fa4e 	bl	c046d68 <psa_generate_key_internal>
            break;
 c0478cc:	e7ef      	b.n	c0478ae <psa_driver_wrapper_generate_key+0x3e>
            status = PSA_ERROR_INVALID_ARGUMENT;
 c0478ce:	f06f 0086 	mvn.w	r0, #134	@ 0x86
 c0478d2:	e7ec      	b.n	c0478ae <psa_driver_wrapper_generate_key+0x3e>

0c0478d4 <psa_driver_wrapper_import_key>:
    size_t data_length,
    uint8_t *key_buffer,
    size_t key_buffer_size,
    size_t *key_buffer_length,
    size_t *bits )
{
 c0478d4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    return( attributes->core.lifetime );
 c0478d8:	f8d0 9004 	ldr.w	r9, [r0, #4]
 c0478dc:	b087      	sub	sp, #28
 c0478de:	4604      	mov	r4, r0
 c0478e0:	460d      	mov	r5, r1
 c0478e2:	4616      	mov	r6, r2
    /* Try dynamically-registered SE interface first */
#if defined(MBEDTLS_PSA_CRYPTO_SE_C)
    const psa_drv_se_t *drv;
    psa_drv_se_context_t *drv_context;

    if( psa_get_se_driver( attributes->core.lifetime, &drv, &drv_context ) )
 c0478e4:	4648      	mov	r0, r9
 c0478e6:	aa05      	add	r2, sp, #20
 c0478e8:	a904      	add	r1, sp, #16
{
 c0478ea:	461f      	mov	r7, r3
 c0478ec:	f8dd 8040 	ldr.w	r8, [sp, #64]	@ 0x40
    if( psa_get_se_driver( attributes->core.lifetime, &drv, &drv_context ) )
 c0478f0:	f001 f9ba 	bl	c048c68 <psa_get_se_driver>
 c0478f4:	b1f0      	cbz	r0, c047934 <psa_driver_wrapper_import_key+0x60>
    {
        if( drv->key_management == NULL ||
 c0478f6:	9b04      	ldr	r3, [sp, #16]
 c0478f8:	68db      	ldr	r3, [r3, #12]
 c0478fa:	b10b      	cbz	r3, c047900 <psa_driver_wrapper_import_key+0x2c>
            drv->key_management->p_import == NULL )
 c0478fc:	6899      	ldr	r1, [r3, #8]
        if( drv->key_management == NULL ||
 c0478fe:	b921      	cbnz	r1, c04790a <psa_driver_wrapper_import_key+0x36>
            return( PSA_ERROR_NOT_SUPPORTED );
 c047900:	f06f 0085 	mvn.w	r0, #133	@ 0x85
             * Return in error indicating that the lifetime is not valid. */
            (void)status;
            return( PSA_ERROR_INVALID_ARGUMENT );
    }

}
 c047904:	b007      	add	sp, #28
 c047906:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        *bits = PSA_MAX_KEY_BITS + 1;
 c04790a:	f64f 73f9 	movw	r3, #65529	@ 0xfff9
 c04790e:	f8c8 3000 	str.w	r3, [r8]
        status = drv->key_management->p_import(
 c047912:	e9cd 6802 	strd	r6, r8, [sp, #8]
 c047916:	e9cd 4500 	strd	r4, r5, [sp]
 c04791a:	9805      	ldr	r0, [sp, #20]
 c04791c:	e9d7 2300 	ldrd	r2, r3, [r7]
 c047920:	4788      	blx	r1
        if( status != PSA_SUCCESS )
 c047922:	2800      	cmp	r0, #0
 c047924:	d1ee      	bne.n	c047904 <psa_driver_wrapper_import_key+0x30>
        if( (*bits) > PSA_MAX_KEY_BITS )
 c047926:	f64f 73f8 	movw	r3, #65528	@ 0xfff8
 c04792a:	f8d8 2000 	ldr.w	r2, [r8]
 c04792e:	429a      	cmp	r2, r3
 c047930:	d9e8      	bls.n	c047904 <psa_driver_wrapper_import_key+0x30>
 c047932:	e7e5      	b.n	c047900 <psa_driver_wrapper_import_key+0x2c>
    switch( location )
 c047934:	ea5f 2919 	movs.w	r9, r9, lsr #8
 c047938:	d10c      	bne.n	c047954 <psa_driver_wrapper_import_key+0x80>
            return( psa_import_key_into_slot( attributes,
 c04793a:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
 c04793c:	4632      	mov	r2, r6
 c04793e:	9301      	str	r3, [sp, #4]
 c047940:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
 c047942:	4629      	mov	r1, r5
 c047944:	9300      	str	r3, [sp, #0]
 c047946:	4620      	mov	r0, r4
 c047948:	463b      	mov	r3, r7
 c04794a:	f8cd 8008 	str.w	r8, [sp, #8]
 c04794e:	f7fd fb7b 	bl	c045048 <psa_import_key_into_slot>
 c047952:	e7d7      	b.n	c047904 <psa_driver_wrapper_import_key+0x30>
            return( PSA_ERROR_INVALID_ARGUMENT );
 c047954:	f06f 0086 	mvn.w	r0, #134	@ 0x86
 c047958:	e7d4      	b.n	c047904 <psa_driver_wrapper_import_key+0x30>

0c04795a <psa_driver_wrapper_export_key>:
psa_status_t psa_driver_wrapper_export_key(
    const psa_key_attributes_t *attributes,
    const uint8_t *key_buffer, size_t key_buffer_size,
    uint8_t *data, size_t data_size, size_t *data_length )

{
 c04795a:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 c04795e:	f8d0 8004 	ldr.w	r8, [r0, #4]
 c047962:	b086      	sub	sp, #24
 c047964:	4604      	mov	r4, r0
 c047966:	e9dd 9a0e 	ldrd	r9, sl, [sp, #56]	@ 0x38
 c04796a:	460d      	mov	r5, r1
 c04796c:	4617      	mov	r7, r2
    /* Try dynamically-registered SE interface first */
#if defined(MBEDTLS_PSA_CRYPTO_SE_C)
    const psa_drv_se_t *drv;
    psa_drv_se_context_t *drv_context;

    if( psa_get_se_driver( attributes->core.lifetime, &drv, &drv_context ) )
 c04796e:	4640      	mov	r0, r8
 c047970:	aa05      	add	r2, sp, #20
 c047972:	a904      	add	r1, sp, #16
{
 c047974:	461e      	mov	r6, r3
    if( psa_get_se_driver( attributes->core.lifetime, &drv, &drv_context ) )
 c047976:	f001 f977 	bl	c048c68 <psa_get_se_driver>
 c04797a:	b170      	cbz	r0, c04799a <psa_driver_wrapper_export_key+0x40>
    {
        if( ( drv->key_management == NULL   ) ||
 c04797c:	9b04      	ldr	r3, [sp, #16]
 c04797e:	68db      	ldr	r3, [r3, #12]
 c047980:	b1bb      	cbz	r3, c0479b2 <psa_driver_wrapper_export_key+0x58>
            ( drv->key_management->p_export == NULL ) )
 c047982:	6959      	ldr	r1, [r3, #20]
        if( ( drv->key_management == NULL   ) ||
 c047984:	b1a9      	cbz	r1, c0479b2 <psa_driver_wrapper_export_key+0x58>
        {
            return( PSA_ERROR_NOT_SUPPORTED );
        }

        return( drv->key_management->p_export(
 c047986:	e9cd 9a01 	strd	r9, sl, [sp, #4]
 c04798a:	9600      	str	r6, [sp, #0]
 c04798c:	9805      	ldr	r0, [sp, #20]
 c04798e:	e9d5 2300 	ldrd	r2, r3, [r5]
 c047992:	4788      	blx	r1
#endif /* PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT */
        default:
            /* Key is declared with a lifetime not known to us */
            return( status );
    }
}
 c047994:	b006      	add	sp, #24
 c047996:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    switch( location )
 c04799a:	ea5f 2818 	movs.w	r8, r8, lsr #8
 c04799e:	d10b      	bne.n	c0479b8 <psa_driver_wrapper_export_key+0x5e>
            return( psa_export_key_internal( attributes,
 c0479a0:	4633      	mov	r3, r6
 c0479a2:	463a      	mov	r2, r7
 c0479a4:	4629      	mov	r1, r5
 c0479a6:	4620      	mov	r0, r4
 c0479a8:	e9cd 9a00 	strd	r9, sl, [sp]
 c0479ac:	f7fd fcca 	bl	c045344 <psa_export_key_internal>
 c0479b0:	e7f0      	b.n	c047994 <psa_driver_wrapper_export_key+0x3a>
            return( PSA_ERROR_NOT_SUPPORTED );
 c0479b2:	f06f 0085 	mvn.w	r0, #133	@ 0x85
 c0479b6:	e7ed      	b.n	c047994 <psa_driver_wrapper_export_key+0x3a>
            return( status );
 c0479b8:	f06f 0086 	mvn.w	r0, #134	@ 0x86
 c0479bc:	e7ea      	b.n	c047994 <psa_driver_wrapper_export_key+0x3a>

0c0479be <psa_driver_wrapper_export_public_key>:
psa_status_t psa_driver_wrapper_export_public_key(
    const psa_key_attributes_t *attributes,
    const uint8_t *key_buffer, size_t key_buffer_size,
    uint8_t *data, size_t data_size, size_t *data_length )

{
 c0479be:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 c0479c2:	f8d0 8004 	ldr.w	r8, [r0, #4]
 c0479c6:	b086      	sub	sp, #24
 c0479c8:	4604      	mov	r4, r0
 c0479ca:	e9dd 9a0e 	ldrd	r9, sl, [sp, #56]	@ 0x38
 c0479ce:	460d      	mov	r5, r1
 c0479d0:	4617      	mov	r7, r2
    /* Try dynamically-registered SE interface first */
#if defined(MBEDTLS_PSA_CRYPTO_SE_C)
    const psa_drv_se_t *drv;
    psa_drv_se_context_t *drv_context;

    if( psa_get_se_driver( attributes->core.lifetime, &drv, &drv_context ) )
 c0479d2:	4640      	mov	r0, r8
 c0479d4:	aa05      	add	r2, sp, #20
 c0479d6:	a904      	add	r1, sp, #16
{
 c0479d8:	461e      	mov	r6, r3
    if( psa_get_se_driver( attributes->core.lifetime, &drv, &drv_context ) )
 c0479da:	f001 f945 	bl	c048c68 <psa_get_se_driver>
 c0479de:	b170      	cbz	r0, c0479fe <psa_driver_wrapper_export_public_key+0x40>
    {
        if( ( drv->key_management == NULL ) ||
 c0479e0:	9b04      	ldr	r3, [sp, #16]
 c0479e2:	68db      	ldr	r3, [r3, #12]
 c0479e4:	b1bb      	cbz	r3, c047a16 <psa_driver_wrapper_export_public_key+0x58>
            ( drv->key_management->p_export_public == NULL ) )
 c0479e6:	6999      	ldr	r1, [r3, #24]
        if( ( drv->key_management == NULL ) ||
 c0479e8:	b1a9      	cbz	r1, c047a16 <psa_driver_wrapper_export_public_key+0x58>
        {
            return( PSA_ERROR_NOT_SUPPORTED );
        }

        return( drv->key_management->p_export_public(
 c0479ea:	e9cd 9a01 	strd	r9, sl, [sp, #4]
 c0479ee:	9600      	str	r6, [sp, #0]
 c0479f0:	9805      	ldr	r0, [sp, #20]
 c0479f2:	e9d5 2300 	ldrd	r2, r3, [r5]
 c0479f6:	4788      	blx	r1
#endif /* PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT */
        default:
            /* Key is declared with a lifetime not known to us */
            return( status );
    }
}
 c0479f8:	b006      	add	sp, #24
 c0479fa:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    switch( location )
 c0479fe:	ea5f 2818 	movs.w	r8, r8, lsr #8
 c047a02:	d10b      	bne.n	c047a1c <psa_driver_wrapper_export_public_key+0x5e>
            return( psa_export_public_key_internal( attributes,
 c047a04:	4633      	mov	r3, r6
 c047a06:	463a      	mov	r2, r7
 c047a08:	4629      	mov	r1, r5
 c047a0a:	4620      	mov	r0, r4
 c047a0c:	e9cd 9a00 	strd	r9, sl, [sp]
 c047a10:	f7fd fcfb 	bl	c04540a <psa_export_public_key_internal>
 c047a14:	e7f0      	b.n	c0479f8 <psa_driver_wrapper_export_public_key+0x3a>
            return( PSA_ERROR_NOT_SUPPORTED );
 c047a16:	f06f 0085 	mvn.w	r0, #133	@ 0x85
 c047a1a:	e7ed      	b.n	c0479f8 <psa_driver_wrapper_export_public_key+0x3a>
            return( status );
 c047a1c:	f06f 0086 	mvn.w	r0, #134	@ 0x86
 c047a20:	e7ea      	b.n	c0479f8 <psa_driver_wrapper_export_public_key+0x3a>

0c047a22 <psa_driver_wrapper_cipher_encrypt_setup>:
psa_status_t psa_driver_wrapper_cipher_encrypt_setup(
    psa_cipher_operation_t *operation,
    const psa_key_attributes_t *attributes,
    const uint8_t *key_buffer, size_t key_buffer_size,
    psa_algorithm_t alg )
{
 c047a22:	b513      	push	{r0, r1, r4, lr}
 c047a24:	4604      	mov	r4, r0
    psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
    psa_key_location_t location =
 c047a26:	6848      	ldr	r0, [r1, #4]
        PSA_KEY_LIFETIME_GET_LOCATION( attributes->core.lifetime );

    switch( location )
 c047a28:	0a00      	lsrs	r0, r0, #8
 c047a2a:	d10a      	bne.n	c047a42 <psa_driver_wrapper_cipher_encrypt_setup+0x20>
                return( status );
#endif /* PSA_CRYPTO_DRIVER_TEST */
#endif /* PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT */
#if defined(MBEDTLS_PSA_BUILTIN_CIPHER)
            /* Fell through, meaning no accelerator supports this operation */
            status = mbedtls_psa_cipher_encrypt_setup( &operation->ctx.mbedtls_ctx,
 c047a2c:	9804      	ldr	r0, [sp, #16]
 c047a2e:	9000      	str	r0, [sp, #0]
 c047a30:	f104 0008 	add.w	r0, r4, #8
 c047a34:	f7ff fd8c 	bl	c047550 <mbedtls_psa_cipher_encrypt_setup>
                                                       attributes,
                                                       key_buffer,
                                                       key_buffer_size,
                                                       alg );
            if( status == PSA_SUCCESS )
 c047a38:	b908      	cbnz	r0, c047a3e <psa_driver_wrapper_cipher_encrypt_setup+0x1c>
                operation->id = PSA_CRYPTO_MBED_TLS_DRIVER_ID;
 c047a3a:	2301      	movs	r3, #1
 c047a3c:	6023      	str	r3, [r4, #0]
            (void)key_buffer;
            (void)key_buffer_size;
            (void)alg;
            return( PSA_ERROR_INVALID_ARGUMENT );
    }
}
 c047a3e:	b002      	add	sp, #8
 c047a40:	bd10      	pop	{r4, pc}
            return( PSA_ERROR_INVALID_ARGUMENT );
 c047a42:	f06f 0086 	mvn.w	r0, #134	@ 0x86
 c047a46:	e7fa      	b.n	c047a3e <psa_driver_wrapper_cipher_encrypt_setup+0x1c>

0c047a48 <psa_driver_wrapper_cipher_decrypt_setup>:
psa_status_t psa_driver_wrapper_cipher_decrypt_setup(
    psa_cipher_operation_t *operation,
    const psa_key_attributes_t *attributes,
    const uint8_t *key_buffer, size_t key_buffer_size,
    psa_algorithm_t alg )
{
 c047a48:	b513      	push	{r0, r1, r4, lr}
 c047a4a:	4604      	mov	r4, r0
    psa_status_t status = PSA_ERROR_NOT_SUPPORTED;
    psa_key_location_t location =
 c047a4c:	6848      	ldr	r0, [r1, #4]
        PSA_KEY_LIFETIME_GET_LOCATION( attributes->core.lifetime );

    switch( location )
 c047a4e:	0a00      	lsrs	r0, r0, #8
 c047a50:	d10a      	bne.n	c047a68 <psa_driver_wrapper_cipher_decrypt_setup+0x20>
                return( status );
#endif /* PSA_CRYPTO_DRIVER_TEST */
#endif /* PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT */
#if defined(MBEDTLS_PSA_BUILTIN_CIPHER)
            /* Fell through, meaning no accelerator supports this operation */
            status = mbedtls_psa_cipher_decrypt_setup( &operation->ctx.mbedtls_ctx,
 c047a52:	9804      	ldr	r0, [sp, #16]
 c047a54:	9000      	str	r0, [sp, #0]
 c047a56:	f104 0008 	add.w	r0, r4, #8
 c047a5a:	f7ff fd80 	bl	c04755e <mbedtls_psa_cipher_decrypt_setup>
                                                       attributes,
                                                       key_buffer,
                                                       key_buffer_size,
                                                       alg );
            if( status == PSA_SUCCESS )
 c047a5e:	b908      	cbnz	r0, c047a64 <psa_driver_wrapper_cipher_decrypt_setup+0x1c>
                operation->id = PSA_CRYPTO_MBED_TLS_DRIVER_ID;
 c047a60:	2301      	movs	r3, #1
 c047a62:	6023      	str	r3, [r4, #0]
            (void)key_buffer;
            (void)key_buffer_size;
            (void)alg;
            return( PSA_ERROR_INVALID_ARGUMENT );
    }
}
 c047a64:	b002      	add	sp, #8
 c047a66:	bd10      	pop	{r4, pc}
            return( PSA_ERROR_INVALID_ARGUMENT );
 c047a68:	f06f 0086 	mvn.w	r0, #134	@ 0x86
 c047a6c:	e7fa      	b.n	c047a64 <psa_driver_wrapper_cipher_decrypt_setup+0x1c>

0c047a6e <psa_driver_wrapper_cipher_set_iv>:
psa_status_t psa_driver_wrapper_cipher_set_iv(
    psa_cipher_operation_t *operation,
    const uint8_t *iv,
    size_t iv_length )
{
    switch( operation->id )
 c047a6e:	6803      	ldr	r3, [r0, #0]
 c047a70:	2b01      	cmp	r3, #1
 c047a72:	d102      	bne.n	c047a7a <psa_driver_wrapper_cipher_set_iv+0xc>
    {
#if defined(MBEDTLS_PSA_BUILTIN_CIPHER)
        case PSA_CRYPTO_MBED_TLS_DRIVER_ID:
            return( mbedtls_psa_cipher_set_iv( &operation->ctx.mbedtls_ctx,
 c047a74:	3008      	adds	r0, #8
 c047a76:	f7ff bd79 	b.w	c04756c <mbedtls_psa_cipher_set_iv>

    (void)iv;
    (void)iv_length;

    return( PSA_ERROR_INVALID_ARGUMENT );
}
 c047a7a:	f06f 0086 	mvn.w	r0, #134	@ 0x86
 c047a7e:	4770      	bx	lr

0c047a80 <psa_driver_wrapper_cipher_update>:
    const uint8_t *input,
    size_t input_length,
    uint8_t *output,
    size_t output_size,
    size_t *output_length )
{
 c047a80:	b470      	push	{r4, r5, r6}
    switch( operation->id )
 c047a82:	6806      	ldr	r6, [r0, #0]
{
 c047a84:	e9dd 4503 	ldrd	r4, r5, [sp, #12]
    switch( operation->id )
 c047a88:	2e01      	cmp	r6, #1
 c047a8a:	d105      	bne.n	c047a98 <psa_driver_wrapper_cipher_update+0x18>
    {
#if defined(MBEDTLS_PSA_BUILTIN_CIPHER)
        case PSA_CRYPTO_MBED_TLS_DRIVER_ID:
            return( mbedtls_psa_cipher_update( &operation->ctx.mbedtls_ctx,
 c047a8c:	e9cd 4503 	strd	r4, r5, [sp, #12]
    (void)output;
    (void)output_size;
    (void)output_length;

    return( PSA_ERROR_INVALID_ARGUMENT );
}
 c047a90:	bc70      	pop	{r4, r5, r6}
            return( mbedtls_psa_cipher_update( &operation->ctx.mbedtls_ctx,
 c047a92:	3008      	adds	r0, #8
 c047a94:	f7ff bd78 	b.w	c047588 <mbedtls_psa_cipher_update>
}
 c047a98:	f06f 0086 	mvn.w	r0, #134	@ 0x86
 c047a9c:	bc70      	pop	{r4, r5, r6}
 c047a9e:	4770      	bx	lr

0c047aa0 <psa_driver_wrapper_cipher_finish>:
psa_status_t psa_driver_wrapper_cipher_finish(
    psa_cipher_operation_t *operation,
    uint8_t *output,
    size_t output_size,
    size_t *output_length )
{
 c047aa0:	b410      	push	{r4}
    switch( operation->id )
 c047aa2:	6804      	ldr	r4, [r0, #0]
 c047aa4:	2c01      	cmp	r4, #1
 c047aa6:	d103      	bne.n	c047ab0 <psa_driver_wrapper_cipher_finish+0x10>
    (void)output;
    (void)output_size;
    (void)output_length;

    return( PSA_ERROR_INVALID_ARGUMENT );
}
 c047aa8:	bc10      	pop	{r4}
            return( mbedtls_psa_cipher_finish( &operation->ctx.mbedtls_ctx,
 c047aaa:	3008      	adds	r0, #8
 c047aac:	f7ff bdf6 	b.w	c04769c <mbedtls_psa_cipher_finish>
}
 c047ab0:	f06f 0086 	mvn.w	r0, #134	@ 0x86
 c047ab4:	bc10      	pop	{r4}
 c047ab6:	4770      	bx	lr

0c047ab8 <psa_driver_wrapper_cipher_abort>:
psa_status_t psa_driver_wrapper_cipher_abort(
    psa_cipher_operation_t *operation )
{
    psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;

    switch( operation->id )
 c047ab8:	6803      	ldr	r3, [r0, #0]
 c047aba:	2b01      	cmp	r3, #1
 c047abc:	d102      	bne.n	c047ac4 <psa_driver_wrapper_cipher_abort+0xc>
    {
#if defined(MBEDTLS_PSA_BUILTIN_CIPHER)
        case PSA_CRYPTO_MBED_TLS_DRIVER_ID:
            return( mbedtls_psa_cipher_abort( &operation->ctx.mbedtls_ctx ) );
 c047abe:	3008      	adds	r0, #8
 c047ac0:	f7ff be1a 	b.w	c0476f8 <mbedtls_psa_cipher_abort>
#endif /* PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT */
    }

    (void)status;
    return( PSA_ERROR_INVALID_ARGUMENT );
}
 c047ac4:	f06f 0086 	mvn.w	r0, #134	@ 0x86
 c047ac8:	4770      	bx	lr

0c047aca <psa_driver_wrapper_hash_compute>:
        return( status );
#endif

    /* If software fallback is compiled in, try fallback */
#if defined(MBEDTLS_PSA_BUILTIN_HASH)
    status = mbedtls_psa_hash_compute( alg, input, input_length,
 c047aca:	f000 bc4b 	b.w	c048364 <mbedtls_psa_hash_compute>

0c047ace <psa_driver_wrapper_hash_setup>:
}

psa_status_t psa_driver_wrapper_hash_setup(
    psa_hash_operation_t *operation,
    psa_algorithm_t alg )
{
 c047ace:	b510      	push	{r4, lr}
 c047ad0:	4604      	mov	r4, r0
        return( status );
#endif

    /* If software fallback is compiled in, try fallback */
#if defined(MBEDTLS_PSA_BUILTIN_HASH)
    status = mbedtls_psa_hash_setup( &operation->ctx.mbedtls_ctx, alg );
 c047ad2:	3008      	adds	r0, #8
 c047ad4:	f000 fb66 	bl	c0481a4 <mbedtls_psa_hash_setup>
    if( status == PSA_SUCCESS )
 c047ad8:	b908      	cbnz	r0, c047ade <psa_driver_wrapper_hash_setup+0x10>
        operation->id = PSA_CRYPTO_MBED_TLS_DRIVER_ID;
 c047ada:	2301      	movs	r3, #1
 c047adc:	6023      	str	r3, [r4, #0]
    /* Nothing left to try if we fall through here */
    (void) status;
    (void) operation;
    (void) alg;
    return( PSA_ERROR_NOT_SUPPORTED );
}
 c047ade:	bd10      	pop	{r4, pc}

0c047ae0 <psa_driver_wrapper_hash_clone>:

psa_status_t psa_driver_wrapper_hash_clone(
    const psa_hash_operation_t *source_operation,
    psa_hash_operation_t *target_operation )
{
    switch( source_operation->id )
 c047ae0:	6803      	ldr	r3, [r0, #0]
 c047ae2:	2b01      	cmp	r3, #1
 c047ae4:	d104      	bne.n	c047af0 <psa_driver_wrapper_hash_clone+0x10>
    {
#if defined(MBEDTLS_PSA_BUILTIN_HASH)
        case PSA_CRYPTO_MBED_TLS_DRIVER_ID:
            target_operation->id = PSA_CRYPTO_MBED_TLS_DRIVER_ID;
 c047ae6:	f841 3b08 	str.w	r3, [r1], #8
            return( mbedtls_psa_hash_clone( &source_operation->ctx.mbedtls_ctx,
 c047aea:	3008      	adds	r0, #8
 c047aec:	f000 bba4 	b.w	c048238 <mbedtls_psa_hash_clone>
#endif
        default:
            (void) target_operation;
            return( PSA_ERROR_BAD_STATE );
    }
}
 c047af0:	f06f 0088 	mvn.w	r0, #136	@ 0x88
 c047af4:	4770      	bx	lr

0c047af6 <psa_driver_wrapper_hash_update>:
psa_status_t psa_driver_wrapper_hash_update(
    psa_hash_operation_t *operation,
    const uint8_t *input,
    size_t input_length )
{
    switch( operation->id )
 c047af6:	6803      	ldr	r3, [r0, #0]
 c047af8:	2b01      	cmp	r3, #1
 c047afa:	d102      	bne.n	c047b02 <psa_driver_wrapper_hash_update+0xc>
    {
#if defined(MBEDTLS_PSA_BUILTIN_HASH)
        case PSA_CRYPTO_MBED_TLS_DRIVER_ID:
            return( mbedtls_psa_hash_update( &operation->ctx.mbedtls_ctx,
 c047afc:	3008      	adds	r0, #8
 c047afe:	f000 bbc7 	b.w	c048290 <mbedtls_psa_hash_update>
        default:
            (void) input;
            (void) input_length;
            return( PSA_ERROR_BAD_STATE );
    }
}
 c047b02:	f06f 0088 	mvn.w	r0, #136	@ 0x88
 c047b06:	4770      	bx	lr

0c047b08 <psa_driver_wrapper_hash_finish>:
psa_status_t psa_driver_wrapper_hash_finish(
    psa_hash_operation_t *operation,
    uint8_t *hash,
    size_t hash_size,
    size_t *hash_length )
{
 c047b08:	b410      	push	{r4}
    switch( operation->id )
 c047b0a:	6804      	ldr	r4, [r0, #0]
 c047b0c:	2c01      	cmp	r4, #1
 c047b0e:	d103      	bne.n	c047b18 <psa_driver_wrapper_hash_finish+0x10>
            (void) hash;
            (void) hash_size;
            (void) hash_length;
            return( PSA_ERROR_BAD_STATE );
    }
}
 c047b10:	bc10      	pop	{r4}
            return( mbedtls_psa_hash_finish( &operation->ctx.mbedtls_ctx,
 c047b12:	3008      	adds	r0, #8
 c047b14:	f000 bbda 	b.w	c0482cc <mbedtls_psa_hash_finish>
}
 c047b18:	f06f 0088 	mvn.w	r0, #136	@ 0x88
 c047b1c:	bc10      	pop	{r4}
 c047b1e:	4770      	bx	lr

0c047b20 <psa_driver_wrapper_hash_abort>:

psa_status_t psa_driver_wrapper_hash_abort(
    psa_hash_operation_t *operation )
{
    switch( operation->id )
 c047b20:	6803      	ldr	r3, [r0, #0]
 c047b22:	2b01      	cmp	r3, #1
 c047b24:	d102      	bne.n	c047b2c <psa_driver_wrapper_hash_abort+0xc>
    {
#if defined(MBEDTLS_PSA_BUILTIN_HASH)
        case PSA_CRYPTO_MBED_TLS_DRIVER_ID:
            return( mbedtls_psa_hash_abort( &operation->ctx.mbedtls_ctx ) );
 c047b26:	3008      	adds	r0, #8
 c047b28:	f000 bb1e 	b.w	c048168 <mbedtls_psa_hash_abort>
                        &operation->ctx.test_driver_ctx ) );
#endif
        default:
            return( PSA_ERROR_BAD_STATE );
    }
}
 c047b2c:	f06f 0088 	mvn.w	r0, #136	@ 0x88
 c047b30:	4770      	bx	lr

0c047b32 <psa_driver_wrapper_aead_encrypt>:
    psa_algorithm_t alg,
    const uint8_t *nonce, size_t nonce_length,
    const uint8_t *additional_data, size_t additional_data_length,
    const uint8_t *plaintext, size_t plaintext_length,
    uint8_t *ciphertext, size_t ciphertext_size, size_t *ciphertext_length )
{
 c047b32:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
    psa_key_location_t location =
 c047b36:	6844      	ldr	r4, [r0, #4]
{
 c047b38:	f8dd b044 	ldr.w	fp, [sp, #68]	@ 0x44
        PSA_KEY_LIFETIME_GET_LOCATION( attributes->core.lifetime );

    switch( location )
 c047b3c:	0a24      	lsrs	r4, r4, #8
{
 c047b3e:	e9dd 5609 	ldrd	r5, r6, [sp, #36]	@ 0x24
 c047b42:	e9dd 7c0b 	ldrd	r7, ip, [sp, #44]	@ 0x2c
 c047b46:	e9dd e80d 	ldrd	lr, r8, [sp, #52]	@ 0x34
 c047b4a:	e9dd 9a0f 	ldrd	r9, sl, [sp, #60]	@ 0x3c
    switch( location )
 c047b4e:	d10c      	bne.n	c047b6a <psa_driver_wrapper_aead_encrypt+0x38>
                return( status );
#endif /* PSA_CRYPTO_DRIVER_TEST */
#endif /* PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT */

            /* Fell through, meaning no accelerator supports this operation */
            return( mbedtls_psa_aead_encrypt(
 c047b50:	e9cd ab10 	strd	sl, fp, [sp, #64]	@ 0x40
 c047b54:	e9cd 890e 	strd	r8, r9, [sp, #56]	@ 0x38
 c047b58:	e9cd ce0c 	strd	ip, lr, [sp, #48]	@ 0x30
 c047b5c:	e9cd 670a 	strd	r6, r7, [sp, #40]	@ 0x28
 c047b60:	9509      	str	r5, [sp, #36]	@ 0x24
        default:
            /* Key is declared with a lifetime not known to us */
            (void)status;
            return( PSA_ERROR_INVALID_ARGUMENT );
    }
}
 c047b62:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
            return( mbedtls_psa_aead_encrypt(
 c047b66:	f7ff bb1f 	b.w	c0471a8 <mbedtls_psa_aead_encrypt>
}
 c047b6a:	f06f 0086 	mvn.w	r0, #134	@ 0x86
 c047b6e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0c047b72 <psa_driver_wrapper_aead_decrypt>:
    psa_algorithm_t alg,
    const uint8_t *nonce, size_t nonce_length,
    const uint8_t *additional_data, size_t additional_data_length,
    const uint8_t *ciphertext, size_t ciphertext_length,
    uint8_t *plaintext, size_t plaintext_size, size_t *plaintext_length )
{
 c047b72:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
    psa_key_location_t location =
 c047b76:	6844      	ldr	r4, [r0, #4]
{
 c047b78:	f8dd b044 	ldr.w	fp, [sp, #68]	@ 0x44
        PSA_KEY_LIFETIME_GET_LOCATION( attributes->core.lifetime );

    switch( location )
 c047b7c:	0a24      	lsrs	r4, r4, #8
{
 c047b7e:	e9dd 5609 	ldrd	r5, r6, [sp, #36]	@ 0x24
 c047b82:	e9dd 7c0b 	ldrd	r7, ip, [sp, #44]	@ 0x2c
 c047b86:	e9dd e80d 	ldrd	lr, r8, [sp, #52]	@ 0x34
 c047b8a:	e9dd 9a0f 	ldrd	r9, sl, [sp, #60]	@ 0x3c
    switch( location )
 c047b8e:	d10c      	bne.n	c047baa <psa_driver_wrapper_aead_decrypt+0x38>
                return( status );
#endif /* PSA_CRYPTO_DRIVER_TEST */
#endif /* PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT */

            /* Fell through, meaning no accelerator supports this operation */
            return( mbedtls_psa_aead_decrypt(
 c047b90:	e9cd ab10 	strd	sl, fp, [sp, #64]	@ 0x40
 c047b94:	e9cd 890e 	strd	r8, r9, [sp, #56]	@ 0x38
 c047b98:	e9cd ce0c 	strd	ip, lr, [sp, #48]	@ 0x30
 c047b9c:	e9cd 670a 	strd	r6, r7, [sp, #40]	@ 0x28
 c047ba0:	9509      	str	r5, [sp, #36]	@ 0x24
        default:
            /* Key is declared with a lifetime not known to us */
            (void)status;
            return( PSA_ERROR_INVALID_ARGUMENT );
    }
}
 c047ba2:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
            return( mbedtls_psa_aead_decrypt(
 c047ba6:	f7ff bb5d 	b.w	c047264 <mbedtls_psa_aead_decrypt>
}
 c047baa:	f06f 0086 	mvn.w	r0, #134	@ 0x86
 c047bae:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0c047bb2 <psa_driver_wrapper_mac_sign_setup>:
    psa_mac_operation_t *operation,
    const psa_key_attributes_t *attributes,
    const uint8_t *key_buffer,
    size_t key_buffer_size,
    psa_algorithm_t alg )
{
 c047bb2:	b513      	push	{r0, r1, r4, lr}
 c047bb4:	4604      	mov	r4, r0
    psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
    psa_key_location_t location =
 c047bb6:	6848      	ldr	r0, [r1, #4]
        PSA_KEY_LIFETIME_GET_LOCATION( attributes->core.lifetime );

    switch( location )
 c047bb8:	0a00      	lsrs	r0, r0, #8
 c047bba:	d10a      	bne.n	c047bd2 <psa_driver_wrapper_mac_sign_setup+0x20>
                return( status );
#endif /* PSA_CRYPTO_DRIVER_TEST */
#endif /* PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT */
#if defined(MBEDTLS_PSA_BUILTIN_MAC)
            /* Fell through, meaning no accelerator supports this operation */
            status = mbedtls_psa_mac_sign_setup( &operation->ctx.mbedtls_ctx,
 c047bbc:	9804      	ldr	r0, [sp, #16]
 c047bbe:	9000      	str	r0, [sp, #0]
 c047bc0:	f104 0008 	add.w	r0, r4, #8
 c047bc4:	f000 fd82 	bl	c0486cc <mbedtls_psa_mac_sign_setup>
                                                 attributes,
                                                 key_buffer, key_buffer_size,
                                                 alg );
            if( status == PSA_SUCCESS )
 c047bc8:	b908      	cbnz	r0, c047bce <psa_driver_wrapper_mac_sign_setup+0x1c>
                operation->id = PSA_CRYPTO_MBED_TLS_DRIVER_ID;
 c047bca:	2301      	movs	r3, #1
 c047bcc:	6023      	str	r3, [r4, #0]
            (void) key_buffer;
            (void) key_buffer_size;
            (void) alg;
            return( PSA_ERROR_INVALID_ARGUMENT );
    }
}
 c047bce:	b002      	add	sp, #8
 c047bd0:	bd10      	pop	{r4, pc}
            return( PSA_ERROR_INVALID_ARGUMENT );
 c047bd2:	f06f 0086 	mvn.w	r0, #134	@ 0x86
 c047bd6:	e7fa      	b.n	c047bce <psa_driver_wrapper_mac_sign_setup+0x1c>

0c047bd8 <psa_driver_wrapper_mac_verify_setup>:
    psa_mac_operation_t *operation,
    const psa_key_attributes_t *attributes,
    const uint8_t *key_buffer,
    size_t key_buffer_size,
    psa_algorithm_t alg )
{
 c047bd8:	b513      	push	{r0, r1, r4, lr}
 c047bda:	4604      	mov	r4, r0
    psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
    psa_key_location_t location =
 c047bdc:	6848      	ldr	r0, [r1, #4]
        PSA_KEY_LIFETIME_GET_LOCATION( attributes->core.lifetime );

    switch( location )
 c047bde:	0a00      	lsrs	r0, r0, #8
 c047be0:	d10a      	bne.n	c047bf8 <psa_driver_wrapper_mac_verify_setup+0x20>
                return( status );
#endif /* PSA_CRYPTO_DRIVER_TEST */
#endif /* PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT */
#if defined(MBEDTLS_PSA_BUILTIN_MAC)
            /* Fell through, meaning no accelerator supports this operation */
            status = mbedtls_psa_mac_verify_setup( &operation->ctx.mbedtls_ctx,
 c047be2:	9804      	ldr	r0, [sp, #16]
 c047be4:	9000      	str	r0, [sp, #0]
 c047be6:	f104 0008 	add.w	r0, r4, #8
 c047bea:	f000 fd71 	bl	c0486d0 <mbedtls_psa_mac_verify_setup>
                                                   attributes,
                                                   key_buffer, key_buffer_size,
                                                   alg );
            if( status == PSA_SUCCESS )
 c047bee:	b908      	cbnz	r0, c047bf4 <psa_driver_wrapper_mac_verify_setup+0x1c>
                operation->id = PSA_CRYPTO_MBED_TLS_DRIVER_ID;
 c047bf0:	2301      	movs	r3, #1
 c047bf2:	6023      	str	r3, [r4, #0]
            (void) key_buffer;
            (void) key_buffer_size;
            (void) alg;
            return( PSA_ERROR_INVALID_ARGUMENT );
    }
}
 c047bf4:	b002      	add	sp, #8
 c047bf6:	bd10      	pop	{r4, pc}
            return( PSA_ERROR_INVALID_ARGUMENT );
 c047bf8:	f06f 0086 	mvn.w	r0, #134	@ 0x86
 c047bfc:	e7fa      	b.n	c047bf4 <psa_driver_wrapper_mac_verify_setup+0x1c>

0c047bfe <psa_driver_wrapper_mac_update>:
psa_status_t psa_driver_wrapper_mac_update(
    psa_mac_operation_t *operation,
    const uint8_t *input,
    size_t input_length )
{
    switch( operation->id )
 c047bfe:	6803      	ldr	r3, [r0, #0]
 c047c00:	2b01      	cmp	r3, #1
 c047c02:	d102      	bne.n	c047c0a <psa_driver_wrapper_mac_update+0xc>
    {
#if defined(MBEDTLS_PSA_BUILTIN_MAC)
        case PSA_CRYPTO_MBED_TLS_DRIVER_ID:
            return( mbedtls_psa_mac_update( &operation->ctx.mbedtls_ctx,
 c047c04:	3008      	adds	r0, #8
 c047c06:	f000 bd65 	b.w	c0486d4 <mbedtls_psa_mac_update>
        default:
            (void) input;
            (void) input_length;
            return( PSA_ERROR_INVALID_ARGUMENT );
    }
}
 c047c0a:	f06f 0086 	mvn.w	r0, #134	@ 0x86
 c047c0e:	4770      	bx	lr

0c047c10 <psa_driver_wrapper_mac_sign_finish>:
psa_status_t psa_driver_wrapper_mac_sign_finish(
    psa_mac_operation_t *operation,
    uint8_t *mac,
    size_t mac_size,
    size_t *mac_length )
{
 c047c10:	b410      	push	{r4}
    switch( operation->id )
 c047c12:	6804      	ldr	r4, [r0, #0]
 c047c14:	2c01      	cmp	r4, #1
 c047c16:	d103      	bne.n	c047c20 <psa_driver_wrapper_mac_sign_finish+0x10>
            (void) mac;
            (void) mac_size;
            (void) mac_length;
            return( PSA_ERROR_INVALID_ARGUMENT );
    }
}
 c047c18:	bc10      	pop	{r4}
            return( mbedtls_psa_mac_sign_finish( &operation->ctx.mbedtls_ctx,
 c047c1a:	3008      	adds	r0, #8
 c047c1c:	f000 bd7a 	b.w	c048714 <mbedtls_psa_mac_sign_finish>
}
 c047c20:	f06f 0086 	mvn.w	r0, #134	@ 0x86
 c047c24:	bc10      	pop	{r4}
 c047c26:	4770      	bx	lr

0c047c28 <psa_driver_wrapper_mac_verify_finish>:
psa_status_t psa_driver_wrapper_mac_verify_finish(
    psa_mac_operation_t *operation,
    const uint8_t *mac,
    size_t mac_length )
{
    switch( operation->id )
 c047c28:	6803      	ldr	r3, [r0, #0]
 c047c2a:	2b01      	cmp	r3, #1
 c047c2c:	d102      	bne.n	c047c34 <psa_driver_wrapper_mac_verify_finish+0xc>
    {
#if defined(MBEDTLS_PSA_BUILTIN_MAC)
        case PSA_CRYPTO_MBED_TLS_DRIVER_ID:
            return( mbedtls_psa_mac_verify_finish( &operation->ctx.mbedtls_ctx,
 c047c2e:	3008      	adds	r0, #8
 c047c30:	f000 bd7d 	b.w	c04872e <mbedtls_psa_mac_verify_finish>
        default:
            (void) mac;
            (void) mac_length;
            return( PSA_ERROR_INVALID_ARGUMENT );
    }
}
 c047c34:	f06f 0086 	mvn.w	r0, #134	@ 0x86
 c047c38:	4770      	bx	lr

0c047c3a <psa_driver_wrapper_mac_abort>:

psa_status_t psa_driver_wrapper_mac_abort(
    psa_mac_operation_t *operation )
{
    switch( operation->id )
 c047c3a:	6803      	ldr	r3, [r0, #0]
 c047c3c:	2b01      	cmp	r3, #1
 c047c3e:	d102      	bne.n	c047c46 <psa_driver_wrapper_mac_abort+0xc>
    {
#if defined(MBEDTLS_PSA_BUILTIN_MAC)
        case PSA_CRYPTO_MBED_TLS_DRIVER_ID:
            return( mbedtls_psa_mac_abort( &operation->ctx.mbedtls_ctx ) );
 c047c40:	3008      	adds	r0, #8
 c047c42:	f000 bc3b 	b.w	c0484bc <mbedtls_psa_mac_abort>
#endif /* PSA_CRYPTO_DRIVER_TEST */
#endif /* PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT */
        default:
            return( PSA_ERROR_INVALID_ARGUMENT );
    }
}
 c047c46:	f06f 0086 	mvn.w	r0, #134	@ 0x86
 c047c4a:	4770      	bx	lr

0c047c4c <mbedtls_psa_ecp_load_representation>:
    defined(MBEDTLS_PSA_BUILTIN_ALG_ECDH)
psa_status_t mbedtls_psa_ecp_load_representation(
    psa_key_type_t type, size_t curve_bits,
    const uint8_t *data, size_t data_length,
    mbedtls_ecp_keypair **p_ecp )
{
 c047c4c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 c047c50:	f400 49e0 	and.w	r9, r0, #28672	@ 0x7000
    psa_status_t status;
    mbedtls_ecp_keypair *ecp = NULL;
    size_t curve_bytes = data_length;
    int explicit_bits = ( curve_bits != 0 );

    if( PSA_KEY_TYPE_IS_PUBLIC_KEY( type ) &&
 c047c54:	f5b9 4f80 	cmp.w	r9, #16384	@ 0x4000
{
 c047c58:	4604      	mov	r4, r0
 c047c5a:	468a      	mov	sl, r1
 c047c5c:	4690      	mov	r8, r2
 c047c5e:	461f      	mov	r7, r3
    if( PSA_KEY_TYPE_IS_PUBLIC_KEY( type ) &&
 c047c60:	d150      	bne.n	c047d04 <mbedtls_psa_ecp_load_representation+0xb8>
        PSA_KEY_TYPE_ECC_GET_FAMILY( type ) != PSA_ECC_FAMILY_MONTGOMERY )
 c047c62:	f400 434f 	and.w	r3, r0, #52992	@ 0xcf00
    if( PSA_KEY_TYPE_IS_PUBLIC_KEY( type ) &&
 c047c66:	f5b3 4f82 	cmp.w	r3, #16640	@ 0x4100
 c047c6a:	d102      	bne.n	c047c72 <mbedtls_psa_ecp_load_representation+0x26>
        PSA_KEY_TYPE_ECC_GET_FAMILY( type ) != PSA_ECC_FAMILY_MONTGOMERY )
 c047c6c:	b2c3      	uxtb	r3, r0
 c047c6e:	2b41      	cmp	r3, #65	@ 0x41
 c047c70:	d048      	beq.n	c047d04 <mbedtls_psa_ecp_load_representation+0xb8>
         * - The byte 0x04;
         * - `x_P` as a `ceiling(m/8)`-byte string, big-endian;
         * - `y_P` as a `ceiling(m/8)`-byte string, big-endian.
         * So its data length is 2m+1 where m is the curve size in bits.
         */
        if( ( data_length & 1 ) == 0 )
 c047c72:	07fb      	lsls	r3, r7, #31
 c047c74:	d55d      	bpl.n	c047d32 <mbedtls_psa_ecp_load_representation+0xe6>
            return( PSA_ERROR_INVALID_ARGUMENT );
        curve_bytes = data_length / 2;
 c047c76:	087b      	lsrs	r3, r7, #1

        /* Private keys are represented in uncompressed private random integer
         * format, meaning their curve_bytes is equal to the amount of input. */
    }

    if( explicit_bits )
 c047c78:	f1ba 0f00 	cmp.w	sl, #0
 c047c7c:	d044      	beq.n	c047d08 <mbedtls_psa_ecp_load_representation+0xbc>
    {
        /* With an explicit bit-size, the data must have the matching length. */
        if( curve_bytes != PSA_BITS_TO_BYTES( curve_bits ) )
 c047c7e:	f10a 0207 	add.w	r2, sl, #7
 c047c82:	ebb3 0fd2 	cmp.w	r3, r2, lsr #3
 c047c86:	d154      	bne.n	c047d32 <mbedtls_psa_ecp_load_representation+0xe6>
 c047c88:	4656      	mov	r6, sl
         * at this stage is rounded up to the nearest multiple of 8. */
        curve_bits = PSA_BYTES_TO_BITS( curve_bytes );
    }

    /* Allocate and initialize a key representation. */
    ecp = mbedtls_calloc( 1, sizeof( mbedtls_ecp_keypair ) );
 c047c8a:	21d0      	movs	r1, #208	@ 0xd0
 c047c8c:	2001      	movs	r0, #1
 c047c8e:	f7f3 fb89 	bl	c03b3a4 <mbedtls_calloc>
    if( ecp == NULL )
 c047c92:	4605      	mov	r5, r0
 c047c94:	2800      	cmp	r0, #0
 c047c96:	d04f      	beq.n	c047d38 <mbedtls_psa_ecp_load_representation+0xec>
        return( PSA_ERROR_INSUFFICIENT_MEMORY );
    mbedtls_ecp_keypair_init( ecp );
 c047c98:	f004 fddf 	bl	c04c85a <mbedtls_ecp_keypair_init>

    /* Load the group. */
    grp_id = mbedtls_ecc_group_of_psa( PSA_KEY_TYPE_ECC_GET_FAMILY( type ),
 c047c9c:	f424 5343 	bic.w	r3, r4, #12480	@ 0x30c0
 c047ca0:	f023 033f 	bic.w	r3, r3, #63	@ 0x3f
 c047ca4:	f5b3 4f82 	cmp.w	r3, #16640	@ 0x4100
 c047ca8:	bf18      	it	ne
 c047caa:	2400      	movne	r4, #0
 c047cac:	faba f28a 	clz	r2, sl
 c047cb0:	4631      	mov	r1, r6
 c047cb2:	0952      	lsrs	r2, r2, #5
 c047cb4:	b2e0      	uxtb	r0, r4
 c047cb6:	f7fd f8bb 	bl	c044e30 <mbedtls_ecc_group_of_psa>
                                       curve_bits, !explicit_bits );
    if( grp_id == MBEDTLS_ECP_DP_NONE )
 c047cba:	4601      	mov	r1, r0
 c047cbc:	b368      	cbz	r0, c047d1a <mbedtls_psa_ecp_load_representation+0xce>
         * at build time, return NOT_SUPPORTED. */
        status = PSA_ERROR_NOT_SUPPORTED;
        goto exit;
    }

    status = mbedtls_to_psa_error(
 c047cbe:	4628      	mov	r0, r5
 c047cc0:	f005 fe96 	bl	c04d9f0 <mbedtls_ecp_group_load>
 c047cc4:	f7fc fdfc 	bl	c0448c0 <mbedtls_to_psa_error>
                mbedtls_ecp_group_load( &ecp->grp, grp_id ) );
    if( status != PSA_SUCCESS )
 c047cc8:	4606      	mov	r6, r0
 c047cca:	bb80      	cbnz	r0, c047d2e <mbedtls_psa_ecp_load_representation+0xe2>
        goto exit;

    /* Load the key material. */
    if( PSA_KEY_TYPE_IS_PUBLIC_KEY( type ) )
 c047ccc:	f5b9 4f80 	cmp.w	r9, #16384	@ 0x4000
 c047cd0:	d11c      	bne.n	c047d0c <mbedtls_psa_ecp_load_representation+0xc0>
    {
        /* Load the public value. */
        status = mbedtls_to_psa_error(
 c047cd2:	f105 09ac 	add.w	r9, r5, #172	@ 0xac
 c047cd6:	463b      	mov	r3, r7
 c047cd8:	4642      	mov	r2, r8
 c047cda:	4649      	mov	r1, r9
 c047cdc:	4628      	mov	r0, r5
 c047cde:	f004 fef1 	bl	c04cac4 <mbedtls_ecp_point_read_binary>
 c047ce2:	f7fc fded 	bl	c0448c0 <mbedtls_to_psa_error>
            mbedtls_ecp_point_read_binary( &ecp->grp, &ecp->Q,
                                           data,
                                           data_length ) );
        if( status != PSA_SUCCESS )
 c047ce6:	4604      	mov	r4, r0
 c047ce8:	b9c8      	cbnz	r0, c047d1e <mbedtls_psa_ecp_load_representation+0xd2>
            goto exit;

        /* Check that the point is on the curve. */
        status = mbedtls_to_psa_error(
 c047cea:	4649      	mov	r1, r9
 c047cec:	4628      	mov	r0, r5
 c047cee:	f004 ff59 	bl	c04cba4 <mbedtls_ecp_check_pubkey>
            goto exit;
    }
    else
    {
        /* Load and validate the secret value. */
        status = mbedtls_to_psa_error(
 c047cf2:	f7fc fde5 	bl	c0448c0 <mbedtls_to_psa_error>
            mbedtls_ecp_read_key( ecp->grp.id,
                                  ecp,
                                  data,
                                  data_length ) );
        if( status != PSA_SUCCESS )
 c047cf6:	4604      	mov	r4, r0
 c047cf8:	b988      	cbnz	r0, c047d1e <mbedtls_psa_ecp_load_representation+0xd2>
            goto exit;
    }

    *p_ecp = ecp;
 c047cfa:	9b08      	ldr	r3, [sp, #32]
 c047cfc:	601d      	str	r5, [r3, #0]
        mbedtls_ecp_keypair_free( ecp );
        mbedtls_free( ecp );
    }

    return( status );
}
 c047cfe:	4630      	mov	r0, r6
 c047d00:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 c047d04:	463b      	mov	r3, r7
 c047d06:	e7b7      	b.n	c047c78 <mbedtls_psa_ecp_load_representation+0x2c>
        curve_bits = PSA_BYTES_TO_BITS( curve_bytes );
 c047d08:	00de      	lsls	r6, r3, #3
 c047d0a:	e7be      	b.n	c047c8a <mbedtls_psa_ecp_load_representation+0x3e>
        status = mbedtls_to_psa_error(
 c047d0c:	463b      	mov	r3, r7
 c047d0e:	4642      	mov	r2, r8
 c047d10:	4629      	mov	r1, r5
 c047d12:	7828      	ldrb	r0, [r5, #0]
 c047d14:	f005 fb98 	bl	c04d448 <mbedtls_ecp_read_key>
 c047d18:	e7eb      	b.n	c047cf2 <mbedtls_psa_ecp_load_representation+0xa6>
        status = PSA_ERROR_NOT_SUPPORTED;
 c047d1a:	f06f 0485 	mvn.w	r4, #133	@ 0x85
        mbedtls_ecp_keypair_free( ecp );
 c047d1e:	4628      	mov	r0, r5
 c047d20:	f004 fe1d 	bl	c04c95e <mbedtls_ecp_keypair_free>
        mbedtls_free( ecp );
 c047d24:	4628      	mov	r0, r5
 c047d26:	f7f3 fb43 	bl	c03b3b0 <mbedtls_free>
 c047d2a:	4626      	mov	r6, r4
 c047d2c:	e7e7      	b.n	c047cfe <mbedtls_psa_ecp_load_representation+0xb2>
 c047d2e:	4604      	mov	r4, r0
 c047d30:	e7f5      	b.n	c047d1e <mbedtls_psa_ecp_load_representation+0xd2>
            return( PSA_ERROR_INVALID_ARGUMENT );
 c047d32:	f06f 0686 	mvn.w	r6, #134	@ 0x86
 c047d36:	e7e2      	b.n	c047cfe <mbedtls_psa_ecp_load_representation+0xb2>
        return( PSA_ERROR_INSUFFICIENT_MEMORY );
 c047d38:	f06f 068c 	mvn.w	r6, #140	@ 0x8c
 c047d3c:	e7df      	b.n	c047cfe <mbedtls_psa_ecp_load_representation+0xb2>
	...

0c047d40 <mbedtls_psa_ecp_export_key>:
psa_status_t mbedtls_psa_ecp_export_key( psa_key_type_t type,
                                         mbedtls_ecp_keypair *ecp,
                                         uint8_t *data,
                                         size_t data_size,
                                         size_t *data_length )
{
 c047d40:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
    psa_status_t status;

    if( PSA_KEY_TYPE_IS_PUBLIC_KEY( type ) )
 c047d44:	f400 40e0 	and.w	r0, r0, #28672	@ 0x7000
 c047d48:	f5b0 4f80 	cmp.w	r0, #16384	@ 0x4000
{
 c047d4c:	460d      	mov	r5, r1
 c047d4e:	4616      	mov	r6, r2
 c047d50:	461f      	mov	r7, r3
 c047d52:	f8dd 8028 	ldr.w	r8, [sp, #40]	@ 0x28
    if( PSA_KEY_TYPE_IS_PUBLIC_KEY( type ) )
 c047d56:	d12d      	bne.n	c047db4 <mbedtls_psa_ecp_export_key+0x74>
    {
        /* Check whether the public part is loaded */
        if( mbedtls_ecp_is_zero( &ecp->Q ) )
 c047d58:	f101 09ac 	add.w	r9, r1, #172	@ 0xac
 c047d5c:	4648      	mov	r0, r9
 c047d5e:	f004 fe3b 	bl	c04c9d8 <mbedtls_ecp_is_zero>
 c047d62:	b988      	cbnz	r0, c047d88 <mbedtls_psa_ecp_export_key+0x48>
                                 MBEDTLS_PSA_RANDOM_STATE ) );
            if( status != PSA_SUCCESS )
                return( status );
        }

        status = mbedtls_to_psa_error(
 c047d64:	4643      	mov	r3, r8
 c047d66:	2200      	movs	r2, #0
 c047d68:	4649      	mov	r1, r9
 c047d6a:	4628      	mov	r0, r5
 c047d6c:	e9cd 6700 	strd	r6, r7, [sp]
 c047d70:	f004 fe3c 	bl	c04c9ec <mbedtls_ecp_point_write_binary>
 c047d74:	f7fc fda4 	bl	c0448c0 <mbedtls_to_psa_error>
                    mbedtls_ecp_point_write_binary( &ecp->grp, &ecp->Q,
                                                    MBEDTLS_ECP_PF_UNCOMPRESSED,
                                                    data_length,
                                                    data,
                                                    data_size ) );
        if( status != PSA_SUCCESS )
 c047d78:	4604      	mov	r4, r0
 c047d7a:	b380      	cbz	r0, c047dde <mbedtls_psa_ecp_export_key+0x9e>
                                           data,
                                           PSA_BITS_TO_BYTES( ecp->grp.nbits ) ) );
        if( status == PSA_SUCCESS )
            *data_length = PSA_BITS_TO_BYTES( ecp->grp.nbits );
        else
            memset( data, 0, data_size );
 c047d7c:	463a      	mov	r2, r7
 c047d7e:	2100      	movs	r1, #0
 c047d80:	4630      	mov	r0, r6
 c047d82:	f013 fcd4 	bl	c05b72e <memset>
 c047d86:	e011      	b.n	c047dac <mbedtls_psa_ecp_export_key+0x6c>
            status = mbedtls_to_psa_error(
 c047d88:	4b17      	ldr	r3, [pc, #92]	@ (c047de8 <mbedtls_psa_ecp_export_key+0xa8>)
 c047d8a:	4649      	mov	r1, r9
 c047d8c:	681b      	ldr	r3, [r3, #0]
 c047d8e:	f105 02a0 	add.w	r2, r5, #160	@ 0xa0
 c047d92:	9301      	str	r3, [sp, #4]
 c047d94:	4b15      	ldr	r3, [pc, #84]	@ (c047dec <mbedtls_psa_ecp_export_key+0xac>)
 c047d96:	4628      	mov	r0, r5
 c047d98:	9300      	str	r3, [sp, #0]
 c047d9a:	f105 0328 	add.w	r3, r5, #40	@ 0x28
 c047d9e:	f005 fa87 	bl	c04d2b0 <mbedtls_ecp_mul>
 c047da2:	f7fc fd8d 	bl	c0448c0 <mbedtls_to_psa_error>
            if( status != PSA_SUCCESS )
 c047da6:	4604      	mov	r4, r0
 c047da8:	2800      	cmp	r0, #0
 c047daa:	d0db      	beq.n	c047d64 <mbedtls_psa_ecp_export_key+0x24>

        return( status );
    }
}
 c047dac:	4620      	mov	r0, r4
 c047dae:	b003      	add	sp, #12
 c047db0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        if( data_size < PSA_BITS_TO_BYTES( ecp->grp.nbits ) )
 c047db4:	6dcb      	ldr	r3, [r1, #92]	@ 0x5c
 c047db6:	3307      	adds	r3, #7
 c047db8:	ebb7 0fd3 	cmp.w	r7, r3, lsr #3
 c047dbc:	ea4f 02d3 	mov.w	r2, r3, lsr #3
 c047dc0:	d30f      	bcc.n	c047de2 <mbedtls_psa_ecp_export_key+0xa2>
        status = mbedtls_to_psa_error(
 c047dc2:	4631      	mov	r1, r6
 c047dc4:	4628      	mov	r0, r5
 c047dc6:	f005 fbad 	bl	c04d524 <mbedtls_ecp_write_key>
 c047dca:	f7fc fd79 	bl	c0448c0 <mbedtls_to_psa_error>
        if( status == PSA_SUCCESS )
 c047dce:	4604      	mov	r4, r0
 c047dd0:	2800      	cmp	r0, #0
 c047dd2:	d1d3      	bne.n	c047d7c <mbedtls_psa_ecp_export_key+0x3c>
            *data_length = PSA_BITS_TO_BYTES( ecp->grp.nbits );
 c047dd4:	6deb      	ldr	r3, [r5, #92]	@ 0x5c
 c047dd6:	3307      	adds	r3, #7
 c047dd8:	08db      	lsrs	r3, r3, #3
 c047dda:	f8c8 3000 	str.w	r3, [r8]
            return( PSA_ERROR_BUFFER_TOO_SMALL );
 c047dde:	2400      	movs	r4, #0
 c047de0:	e7e4      	b.n	c047dac <mbedtls_psa_ecp_export_key+0x6c>
 c047de2:	f06f 0489 	mvn.w	r4, #137	@ 0x89
 c047de6:	e7e1      	b.n	c047dac <mbedtls_psa_ecp_export_key+0x6c>
 c047de8:	0c060e6c 	.word	0x0c060e6c
 c047dec:	0c055d65 	.word	0x0c055d65

0c047df0 <mbedtls_psa_ecp_import_key>:
{
 c047df0:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
 c047df2:	461e      	mov	r6, r3
    mbedtls_ecp_keypair *ecp = NULL;
 c047df4:	2300      	movs	r3, #0
 c047df6:	9303      	str	r3, [sp, #12]
    status = mbedtls_psa_ecp_load_representation( attributes->core.type,
 c047df8:	ab03      	add	r3, sp, #12
 c047dfa:	9300      	str	r3, [sp, #0]
{
 c047dfc:	4605      	mov	r5, r0
    status = mbedtls_psa_ecp_load_representation( attributes->core.type,
 c047dfe:	4613      	mov	r3, r2
 c047e00:	460a      	mov	r2, r1
 c047e02:	8841      	ldrh	r1, [r0, #2]
 c047e04:	8800      	ldrh	r0, [r0, #0]
 c047e06:	f7ff ff21 	bl	c047c4c <mbedtls_psa_ecp_load_representation>
    if( status != PSA_SUCCESS )
 c047e0a:	4604      	mov	r4, r0
 c047e0c:	b9a0      	cbnz	r0, c047e38 <mbedtls_psa_ecp_import_key+0x48>
    if( PSA_KEY_TYPE_ECC_GET_FAMILY( attributes->core.type ) ==
 c047e0e:	8828      	ldrh	r0, [r5, #0]
        *bits = ecp->grp.nbits + 1;
 c047e10:	9903      	ldr	r1, [sp, #12]
    if( PSA_KEY_TYPE_ECC_GET_FAMILY( attributes->core.type ) ==
 c047e12:	f400 424f 	and.w	r2, r0, #52992	@ 0xcf00
 c047e16:	f5b2 4f82 	cmp.w	r2, #16640	@ 0x4100
        *bits = ecp->grp.nbits + 1;
 c047e1a:	6dcb      	ldr	r3, [r1, #92]	@ 0x5c
    if( PSA_KEY_TYPE_ECC_GET_FAMILY( attributes->core.type ) ==
 c047e1c:	d103      	bne.n	c047e26 <mbedtls_psa_ecp_import_key+0x36>
 c047e1e:	b2c2      	uxtb	r2, r0
 c047e20:	2a41      	cmp	r2, #65	@ 0x41
        *bits = ecp->grp.nbits + 1;
 c047e22:	bf08      	it	eq
 c047e24:	3301      	addeq	r3, #1
 c047e26:	9a0a      	ldr	r2, [sp, #40]	@ 0x28
 c047e28:	6013      	str	r3, [r2, #0]
    status = mbedtls_psa_ecp_export_key( attributes->core.type,
 c047e2a:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 c047e2c:	4632      	mov	r2, r6
 c047e2e:	9300      	str	r3, [sp, #0]
 c047e30:	9b08      	ldr	r3, [sp, #32]
 c047e32:	f7ff ff85 	bl	c047d40 <mbedtls_psa_ecp_export_key>
 c047e36:	4604      	mov	r4, r0
    mbedtls_ecp_keypair_free( ecp );
 c047e38:	9d03      	ldr	r5, [sp, #12]
 c047e3a:	4628      	mov	r0, r5
 c047e3c:	f004 fd8f 	bl	c04c95e <mbedtls_ecp_keypair_free>
    mbedtls_free( ecp );
 c047e40:	4628      	mov	r0, r5
 c047e42:	f7f3 fab5 	bl	c03b3b0 <mbedtls_free>
}
 c047e46:	4620      	mov	r0, r4
 c047e48:	b004      	add	sp, #16
 c047e4a:	bd70      	pop	{r4, r5, r6, pc}

0c047e4c <mbedtls_psa_ecp_export_public_key>:

psa_status_t mbedtls_psa_ecp_export_public_key(
    const psa_key_attributes_t *attributes,
    const uint8_t *key_buffer, size_t key_buffer_size,
    uint8_t *data, size_t data_size, size_t *data_length )
{
 c047e4c:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
 c047e4e:	461e      	mov	r6, r3
    psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
    mbedtls_ecp_keypair *ecp = NULL;
 c047e50:	2300      	movs	r3, #0
 c047e52:	9303      	str	r3, [sp, #12]

    status = mbedtls_psa_ecp_load_representation(
 c047e54:	ab03      	add	r3, sp, #12
 c047e56:	9300      	str	r3, [sp, #0]
{
 c047e58:	4605      	mov	r5, r0
    status = mbedtls_psa_ecp_load_representation(
 c047e5a:	4613      	mov	r3, r2
 c047e5c:	460a      	mov	r2, r1
 c047e5e:	8841      	ldrh	r1, [r0, #2]
 c047e60:	8800      	ldrh	r0, [r0, #0]
 c047e62:	f7ff fef3 	bl	c047c4c <mbedtls_psa_ecp_load_representation>
        attributes->core.type, attributes->core.bits,
        key_buffer, key_buffer_size, &ecp );
    if( status != PSA_SUCCESS )
 c047e66:	4604      	mov	r4, r0
 c047e68:	b9d0      	cbnz	r0, c047ea0 <mbedtls_psa_ecp_export_public_key+0x54>
        return( status );

    status = mbedtls_psa_ecp_export_key(
                 PSA_KEY_TYPE_ECC_PUBLIC_KEY(
 c047e6a:	8828      	ldrh	r0, [r5, #0]
    status = mbedtls_psa_ecp_export_key(
 c047e6c:	9d03      	ldr	r5, [sp, #12]
                 PSA_KEY_TYPE_ECC_PUBLIC_KEY(
 c047e6e:	f400 434f 	and.w	r3, r0, #52992	@ 0xcf00
    status = mbedtls_psa_ecp_export_key(
 c047e72:	f5b3 4f82 	cmp.w	r3, #16640	@ 0x4100
 c047e76:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 c047e78:	bf0c      	ite	eq
 c047e7a:	b2c0      	uxtbeq	r0, r0
 c047e7c:	f44f 4082 	movne.w	r0, #16640	@ 0x4100
 c047e80:	4632      	mov	r2, r6
 c047e82:	4629      	mov	r1, r5
 c047e84:	bf08      	it	eq
 c047e86:	f440 4082 	orreq.w	r0, r0, #16640	@ 0x4100
 c047e8a:	9300      	str	r3, [sp, #0]
 c047e8c:	9b08      	ldr	r3, [sp, #32]
 c047e8e:	f7ff ff57 	bl	c047d40 <mbedtls_psa_ecp_export_key>
 c047e92:	4604      	mov	r4, r0
                     PSA_KEY_TYPE_ECC_GET_FAMILY( attributes->core.type ) ),
                 ecp, data, data_size, data_length );

    mbedtls_ecp_keypair_free( ecp );
 c047e94:	4628      	mov	r0, r5
 c047e96:	f004 fd62 	bl	c04c95e <mbedtls_ecp_keypair_free>
    mbedtls_free( ecp );
 c047e9a:	4628      	mov	r0, r5
 c047e9c:	f7f3 fa88 	bl	c03b3b0 <mbedtls_free>

    return( status );
}
 c047ea0:	4620      	mov	r0, r4
 c047ea2:	b004      	add	sp, #16
 c047ea4:	bd70      	pop	{r4, r5, r6, pc}
	...

0c047ea8 <mbedtls_psa_ecp_generate_key>:

#if defined(MBEDTLS_PSA_BUILTIN_KEY_TYPE_ECC_KEY_PAIR)
psa_status_t mbedtls_psa_ecp_generate_key(
    const psa_key_attributes_t *attributes,
    uint8_t *key_buffer, size_t key_buffer_size, size_t *key_buffer_length )
{
 c047ea8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 c047eac:	4604      	mov	r4, r0
    psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;

    psa_ecc_family_t curve = PSA_KEY_TYPE_ECC_GET_FAMILY(
 c047eae:	8800      	ldrh	r0, [r0, #0]
{
 c047eb0:	461f      	mov	r7, r3
    psa_ecc_family_t curve = PSA_KEY_TYPE_ECC_GET_FAMILY(
 c047eb2:	f400 434f 	and.w	r3, r0, #52992	@ 0xcf00
 c047eb6:	f5b3 4f82 	cmp.w	r3, #16640	@ 0x4100
 c047eba:	bf18      	it	ne
 c047ebc:	2000      	movne	r0, #0
{
 c047ebe:	b0b4      	sub	sp, #208	@ 0xd0
 c047ec0:	4688      	mov	r8, r1
 c047ec2:	4615      	mov	r5, r2
                                 attributes->core.type );
    mbedtls_ecp_group_id grp_id =
         mbedtls_ecc_group_of_psa( curve, attributes->core.bits, 0 );
 c047ec4:	8861      	ldrh	r1, [r4, #2]
 c047ec6:	2200      	movs	r2, #0
 c047ec8:	b2c0      	uxtb	r0, r0
 c047eca:	f7fc ffb1 	bl	c044e30 <mbedtls_ecc_group_of_psa>
 c047ece:	4606      	mov	r6, r0

    const mbedtls_ecp_curve_info *curve_info =
        mbedtls_ecp_curve_info_from_grp_id( grp_id );
 c047ed0:	f004 fc76 	bl	c04c7c0 <mbedtls_ecp_curve_info_from_grp_id>
    mbedtls_ecp_keypair ecp;

    if( attributes->domain_parameters_size != 0 )
 c047ed4:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
 c047ed6:	bb3b      	cbnz	r3, c047f28 <mbedtls_psa_ecp_generate_key+0x80>
        return( PSA_ERROR_NOT_SUPPORTED );

    if( grp_id == MBEDTLS_ECP_DP_NONE || curve_info == NULL )
 c047ed8:	b336      	cbz	r6, c047f28 <mbedtls_psa_ecp_generate_key+0x80>
 c047eda:	b328      	cbz	r0, c047f28 <mbedtls_psa_ecp_generate_key+0x80>
        return( PSA_ERROR_NOT_SUPPORTED );

    mbedtls_ecp_keypair_init( &ecp );
 c047edc:	4668      	mov	r0, sp
 c047ede:	f004 fcbc 	bl	c04c85a <mbedtls_ecp_keypair_init>
    ret = mbedtls_ecp_gen_key( grp_id, &ecp,
 c047ee2:	4b13      	ldr	r3, [pc, #76]	@ (c047f30 <mbedtls_psa_ecp_generate_key+0x88>)
 c047ee4:	4669      	mov	r1, sp
 c047ee6:	4630      	mov	r0, r6
 c047ee8:	681b      	ldr	r3, [r3, #0]
 c047eea:	4a12      	ldr	r2, [pc, #72]	@ (c047f34 <mbedtls_psa_ecp_generate_key+0x8c>)
 c047eec:	f005 fa98 	bl	c04d420 <mbedtls_ecp_gen_key>
                               mbedtls_psa_get_random,
                               MBEDTLS_PSA_RANDOM_STATE );
    if( ret != 0 )
 c047ef0:	4604      	mov	r4, r0
 c047ef2:	b150      	cbz	r0, c047f0a <mbedtls_psa_ecp_generate_key+0x62>
    {
        mbedtls_ecp_keypair_free( &ecp );
 c047ef4:	4668      	mov	r0, sp
 c047ef6:	f004 fd32 	bl	c04c95e <mbedtls_ecp_keypair_free>
        return( mbedtls_to_psa_error( ret ) );
 c047efa:	4620      	mov	r0, r4
 c047efc:	f7fc fce0 	bl	c0448c0 <mbedtls_to_psa_error>
 c047f00:	4604      	mov	r4, r0

    if( status == PSA_SUCCESS )
        *key_buffer_length = key_buffer_size;

    return( status );
}
 c047f02:	4620      	mov	r0, r4
 c047f04:	b034      	add	sp, #208	@ 0xd0
 c047f06:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    status = mbedtls_to_psa_error(
 c047f0a:	462a      	mov	r2, r5
 c047f0c:	4641      	mov	r1, r8
 c047f0e:	4668      	mov	r0, sp
 c047f10:	f005 fb08 	bl	c04d524 <mbedtls_ecp_write_key>
 c047f14:	f7fc fcd4 	bl	c0448c0 <mbedtls_to_psa_error>
 c047f18:	4604      	mov	r4, r0
    mbedtls_ecp_keypair_free( &ecp );
 c047f1a:	4668      	mov	r0, sp
 c047f1c:	f004 fd1f 	bl	c04c95e <mbedtls_ecp_keypair_free>
    if( status == PSA_SUCCESS )
 c047f20:	2c00      	cmp	r4, #0
 c047f22:	d1ee      	bne.n	c047f02 <mbedtls_psa_ecp_generate_key+0x5a>
        *key_buffer_length = key_buffer_size;
 c047f24:	603d      	str	r5, [r7, #0]
 c047f26:	e7ec      	b.n	c047f02 <mbedtls_psa_ecp_generate_key+0x5a>
        return( PSA_ERROR_NOT_SUPPORTED );
 c047f28:	f06f 0485 	mvn.w	r4, #133	@ 0x85
 c047f2c:	e7e9      	b.n	c047f02 <mbedtls_psa_ecp_generate_key+0x5a>
 c047f2e:	bf00      	nop
 c047f30:	0c060e6c 	.word	0x0c060e6c
 c047f34:	0c055d65 	.word	0x0c055d65

0c047f38 <mbedtls_psa_ecdsa_sign_hash>:
psa_status_t mbedtls_psa_ecdsa_sign_hash(
    const psa_key_attributes_t *attributes,
    const uint8_t *key_buffer, size_t key_buffer_size,
    psa_algorithm_t alg, const uint8_t *hash, size_t hash_length,
    uint8_t *signature, size_t signature_size, size_t *signature_length )
{
 c047f38:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c047f3c:	461c      	mov	r4, r3
    psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
    mbedtls_ecp_keypair *ecp = NULL;
 c047f3e:	2300      	movs	r3, #0
{
 c047f40:	b08f      	sub	sp, #60	@ 0x3c
    mbedtls_ecp_keypair *ecp = NULL;
 c047f42:	9307      	str	r3, [sp, #28]
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    size_t curve_bytes;
    mbedtls_mpi r, s;

    status = mbedtls_psa_ecp_load_representation( attributes->core.type,
 c047f44:	ab07      	add	r3, sp, #28
 c047f46:	9300      	str	r3, [sp, #0]
 c047f48:	4613      	mov	r3, r2
 c047f4a:	460a      	mov	r2, r1
 c047f4c:	8841      	ldrh	r1, [r0, #2]
 c047f4e:	8800      	ldrh	r0, [r0, #0]
{
 c047f50:	f8dd 8068 	ldr.w	r8, [sp, #104]	@ 0x68
    status = mbedtls_psa_ecp_load_representation( attributes->core.type,
 c047f54:	f7ff fe7a 	bl	c047c4c <mbedtls_psa_ecp_load_representation>
                                                  attributes->core.bits,
                                                  key_buffer,
                                                  key_buffer_size,
                                                  &ecp );
    if( status != PSA_SUCCESS )
 c047f58:	4681      	mov	r9, r0
 c047f5a:	2800      	cmp	r0, #0
 c047f5c:	d167      	bne.n	c04802e <mbedtls_psa_ecdsa_sign_hash+0xf6>
        return( status );

    curve_bytes = PSA_BITS_TO_BYTES( ecp->grp.pbits );
 c047f5e:	9e07      	ldr	r6, [sp, #28]
    mbedtls_mpi_init( &r );
 c047f60:	a808      	add	r0, sp, #32
    curve_bytes = PSA_BITS_TO_BYTES( ecp->grp.pbits );
 c047f62:	6db5      	ldr	r5, [r6, #88]	@ 0x58
    mbedtls_mpi_init( &r );
 c047f64:	f00b f9c7 	bl	c0532f6 <mbedtls_mpi_init>
    mbedtls_mpi_init( &s );
 c047f68:	a80b      	add	r0, sp, #44	@ 0x2c
 c047f6a:	f00b f9c4 	bl	c0532f6 <mbedtls_mpi_init>
    curve_bytes = PSA_BITS_TO_BYTES( ecp->grp.pbits );
 c047f6e:	3507      	adds	r5, #7

    if( signature_size < 2 * curve_bytes )
 c047f70:	9b1b      	ldr	r3, [sp, #108]	@ 0x6c
    curve_bytes = PSA_BITS_TO_BYTES( ecp->grp.pbits );
 c047f72:	08ed      	lsrs	r5, r5, #3
    if( signature_size < 2 * curve_bytes )
 c047f74:	ebb3 0f45 	cmp.w	r3, r5, lsl #1
 c047f78:	ea4f 0745 	mov.w	r7, r5, lsl #1
 c047f7c:	d36c      	bcc.n	c048058 <mbedtls_psa_ecdsa_sign_hash+0x120>
    {
#if defined(MBEDTLS_PSA_BUILTIN_ALG_DETERMINISTIC_ECDSA)
        psa_algorithm_t hash_alg = PSA_ALG_SIGN_GET_HASH( alg );
        const mbedtls_md_info_t *md_info = mbedtls_md_info_from_psa( hash_alg );
        mbedtls_md_type_t md_alg = mbedtls_md_get_type( md_info );
        MBEDTLS_MPI_CHK( mbedtls_ecdsa_sign_det_ext(
 c047f7e:	4937      	ldr	r1, [pc, #220]	@ (c04805c <mbedtls_psa_ecdsa_sign_hash+0x124>)
    if( PSA_ALG_ECDSA_IS_DETERMINISTIC( alg ) )
 c047f80:	05e3      	lsls	r3, r4, #23
        MBEDTLS_MPI_CHK( mbedtls_ecdsa_sign_det_ext(
 c047f82:	f8d1 b000 	ldr.w	fp, [r1]
 c047f86:	f106 0aa0 	add.w	sl, r6, #160	@ 0xa0
    if( PSA_ALG_ECDSA_IS_DETERMINISTIC( alg ) )
 c047f8a:	d556      	bpl.n	c04803a <mbedtls_psa_ecdsa_sign_hash+0x102>
        psa_algorithm_t hash_alg = PSA_ALG_SIGN_GET_HASH( alg );
 c047f8c:	4834      	ldr	r0, [pc, #208]	@ (c048060 <mbedtls_psa_ecdsa_sign_hash+0x128>)
 c047f8e:	f424 71ff 	bic.w	r1, r4, #510	@ 0x1fe
 c047f92:	f021 0101 	bic.w	r1, r1, #1
 c047f96:	4281      	cmp	r1, r0
 c047f98:	d00e      	beq.n	c047fb8 <mbedtls_psa_ecdsa_sign_hash+0x80>
 c047f9a:	4932      	ldr	r1, [pc, #200]	@ (c048064 <mbedtls_psa_ecdsa_sign_hash+0x12c>)
 c047f9c:	f024 00ff 	bic.w	r0, r4, #255	@ 0xff
 c047fa0:	4288      	cmp	r0, r1
 c047fa2:	d009      	beq.n	c047fb8 <mbedtls_psa_ecdsa_sign_hash+0x80>
 c047fa4:	4b30      	ldr	r3, [pc, #192]	@ (c048068 <mbedtls_psa_ecdsa_sign_hash+0x130>)
 c047fa6:	f424 717f 	bic.w	r1, r4, #1020	@ 0x3fc
 c047faa:	f021 0103 	bic.w	r1, r1, #3
 c047fae:	4299      	cmp	r1, r3
 c047fb0:	d002      	beq.n	c047fb8 <mbedtls_psa_ecdsa_sign_hash+0x80>
 c047fb2:	492e      	ldr	r1, [pc, #184]	@ (c04806c <mbedtls_psa_ecdsa_sign_hash+0x134>)
 c047fb4:	4288      	cmp	r0, r1
 c047fb6:	d13e      	bne.n	c048036 <mbedtls_psa_ecdsa_sign_hash+0xfe>
 c047fb8:	f014 00ff 	ands.w	r0, r4, #255	@ 0xff
 c047fbc:	d001      	beq.n	c047fc2 <mbedtls_psa_ecdsa_sign_hash+0x8a>
 c047fbe:	f040 7000 	orr.w	r0, r0, #33554432	@ 0x2000000
        const mbedtls_md_info_t *md_info = mbedtls_md_info_from_psa( hash_alg );
 c047fc2:	f000 f8c5 	bl	c048150 <mbedtls_md_info_from_psa>
        mbedtls_md_type_t md_alg = mbedtls_md_get_type( md_info );
 c047fc6:	f00e fd52 	bl	c056a6e <mbedtls_md_get_type>
        MBEDTLS_MPI_CHK( mbedtls_ecdsa_sign_det_ext(
 c047fca:	9b19      	ldr	r3, [sp, #100]	@ 0x64
 c047fcc:	4a28      	ldr	r2, [pc, #160]	@ (c048070 <mbedtls_psa_ecdsa_sign_hash+0x138>)
 c047fce:	9301      	str	r3, [sp, #4]
 c047fd0:	9b18      	ldr	r3, [sp, #96]	@ 0x60
 c047fd2:	e9cd 0202 	strd	r0, r2, [sp, #8]
 c047fd6:	9300      	str	r3, [sp, #0]
 c047fd8:	4630      	mov	r0, r6
 c047fda:	4653      	mov	r3, sl
 c047fdc:	f8cd b010 	str.w	fp, [sp, #16]
 c047fe0:	aa0b      	add	r2, sp, #44	@ 0x2c
 c047fe2:	a908      	add	r1, sp, #32
 c047fe4:	f00e f82c 	bl	c056040 <mbedtls_ecdsa_sign_det_ext>
 c047fe8:	4604      	mov	r4, r0
 c047fea:	b968      	cbnz	r0, c048008 <mbedtls_psa_ecdsa_sign_hash+0xd0>
                                             hash, hash_length,
                                             mbedtls_psa_get_random,
                                             MBEDTLS_PSA_RANDOM_STATE ) );
    }

    MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( &r,
 c047fec:	462a      	mov	r2, r5
 c047fee:	4641      	mov	r1, r8
 c047ff0:	a808      	add	r0, sp, #32
 c047ff2:	f00b fb31 	bl	c053658 <mbedtls_mpi_write_binary>
 c047ff6:	4604      	mov	r4, r0
 c047ff8:	b930      	cbnz	r0, c048008 <mbedtls_psa_ecdsa_sign_hash+0xd0>
                                               signature,
                                               curve_bytes ) );
    MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( &s,
 c047ffa:	462a      	mov	r2, r5
 c047ffc:	eb08 0105 	add.w	r1, r8, r5
 c048000:	a80b      	add	r0, sp, #44	@ 0x2c
 c048002:	f00b fb29 	bl	c053658 <mbedtls_mpi_write_binary>
 c048006:	4604      	mov	r4, r0
                                               signature + curve_bytes,
                                               curve_bytes ) );
cleanup:
    mbedtls_mpi_free( &r );
 c048008:	a808      	add	r0, sp, #32
 c04800a:	f00b f97a 	bl	c053302 <mbedtls_mpi_free>
    mbedtls_mpi_free( &s );
 c04800e:	a80b      	add	r0, sp, #44	@ 0x2c
 c048010:	f00b f977 	bl	c053302 <mbedtls_mpi_free>
    if( ret == 0 )
 c048014:	b90c      	cbnz	r4, c04801a <mbedtls_psa_ecdsa_sign_hash+0xe2>
        *signature_length = 2 * curve_bytes;
 c048016:	9b1c      	ldr	r3, [sp, #112]	@ 0x70
 c048018:	601f      	str	r7, [r3, #0]

    mbedtls_ecp_keypair_free( ecp );
 c04801a:	4630      	mov	r0, r6
 c04801c:	f004 fc9f 	bl	c04c95e <mbedtls_ecp_keypair_free>
    mbedtls_free( ecp );
 c048020:	4630      	mov	r0, r6
 c048022:	f7f3 f9c5 	bl	c03b3b0 <mbedtls_free>

    return( mbedtls_to_psa_error( ret ) );
 c048026:	4620      	mov	r0, r4
 c048028:	f7fc fc4a 	bl	c0448c0 <mbedtls_to_psa_error>
 c04802c:	4681      	mov	r9, r0
}
 c04802e:	4648      	mov	r0, r9
 c048030:	b00f      	add	sp, #60	@ 0x3c
 c048032:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        psa_algorithm_t hash_alg = PSA_ALG_SIGN_GET_HASH( alg );
 c048036:	4648      	mov	r0, r9
 c048038:	e7c3      	b.n	c047fc2 <mbedtls_psa_ecdsa_sign_hash+0x8a>
        MBEDTLS_MPI_CHK( mbedtls_ecdsa_sign( &ecp->grp, &r, &s, &ecp->d,
 c04803a:	9b19      	ldr	r3, [sp, #100]	@ 0x64
 c04803c:	4a0c      	ldr	r2, [pc, #48]	@ (c048070 <mbedtls_psa_ecdsa_sign_hash+0x138>)
 c04803e:	9301      	str	r3, [sp, #4]
 c048040:	9b18      	ldr	r3, [sp, #96]	@ 0x60
 c048042:	9202      	str	r2, [sp, #8]
 c048044:	9300      	str	r3, [sp, #0]
 c048046:	4630      	mov	r0, r6
 c048048:	4653      	mov	r3, sl
 c04804a:	f8cd b00c 	str.w	fp, [sp, #12]
 c04804e:	aa0b      	add	r2, sp, #44	@ 0x2c
 c048050:	a908      	add	r1, sp, #32
 c048052:	f004 f92d 	bl	c04c2b0 <mbedtls_ecdsa_sign>
 c048056:	e7c7      	b.n	c047fe8 <mbedtls_psa_ecdsa_sign_hash+0xb0>
        ret = MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL;
 c048058:	4c06      	ldr	r4, [pc, #24]	@ (c048074 <mbedtls_psa_ecdsa_sign_hash+0x13c>)
 c04805a:	e7d5      	b.n	c048008 <mbedtls_psa_ecdsa_sign_hash+0xd0>
 c04805c:	0c060e6c 	.word	0x0c060e6c
 c048060:	06000200 	.word	0x06000200
 c048064:	06001300 	.word	0x06001300
 c048068:	06000400 	.word	0x06000400
 c04806c:	06000900 	.word	0x06000900
 c048070:	0c055d65 	.word	0x0c055d65
 c048074:	ffffb100 	.word	0xffffb100

0c048078 <mbedtls_psa_ecdsa_verify_hash>:
psa_status_t mbedtls_psa_ecdsa_verify_hash(
    const psa_key_attributes_t *attributes,
    const uint8_t *key_buffer, size_t key_buffer_size,
    psa_algorithm_t alg, const uint8_t *hash, size_t hash_length,
    const uint8_t *signature, size_t signature_length )
{
 c048078:	4613      	mov	r3, r2
    psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
    mbedtls_ecp_keypair *ecp = NULL;
 c04807a:	2200      	movs	r2, #0
{
 c04807c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 c048080:	b08b      	sub	sp, #44	@ 0x2c
    mbedtls_ecp_keypair *ecp = NULL;
 c048082:	9203      	str	r2, [sp, #12]
    size_t curve_bytes;
    mbedtls_mpi r, s;

    (void)alg;

    status = mbedtls_psa_ecp_load_representation( attributes->core.type,
 c048084:	aa03      	add	r2, sp, #12
 c048086:	9200      	str	r2, [sp, #0]
 c048088:	460a      	mov	r2, r1
 c04808a:	8841      	ldrh	r1, [r0, #2]
 c04808c:	8800      	ldrh	r0, [r0, #0]
{
 c04808e:	f8dd 8050 	ldr.w	r8, [sp, #80]	@ 0x50
    status = mbedtls_psa_ecp_load_representation( attributes->core.type,
 c048092:	f7ff fddb 	bl	c047c4c <mbedtls_psa_ecp_load_representation>
                                                  attributes->core.bits,
                                                  key_buffer,
                                                  key_buffer_size,
                                                  &ecp );
    if( status != PSA_SUCCESS )
 c048096:	2800      	cmp	r0, #0
 c048098:	d13d      	bne.n	c048116 <mbedtls_psa_ecdsa_verify_hash+0x9e>
        return( status );

    curve_bytes = PSA_BITS_TO_BYTES( ecp->grp.pbits );
 c04809a:	9d03      	ldr	r5, [sp, #12]
    mbedtls_mpi_init( &r );
 c04809c:	af04      	add	r7, sp, #16
    curve_bytes = PSA_BITS_TO_BYTES( ecp->grp.pbits );
 c04809e:	6daa      	ldr	r2, [r5, #88]	@ 0x58
    mbedtls_mpi_init( &r );
 c0480a0:	4638      	mov	r0, r7
    curve_bytes = PSA_BITS_TO_BYTES( ecp->grp.pbits );
 c0480a2:	3207      	adds	r2, #7
    mbedtls_mpi_init( &s );
 c0480a4:	ae07      	add	r6, sp, #28
    curve_bytes = PSA_BITS_TO_BYTES( ecp->grp.pbits );
 c0480a6:	ea4f 09d2 	mov.w	r9, r2, lsr #3
    mbedtls_mpi_init( &r );
 c0480aa:	f00b f924 	bl	c0532f6 <mbedtls_mpi_init>
    mbedtls_mpi_init( &s );
 c0480ae:	4630      	mov	r0, r6
 c0480b0:	f00b f921 	bl	c0532f6 <mbedtls_mpi_init>

    if( signature_length != 2 * curve_bytes )
 c0480b4:	9b15      	ldr	r3, [sp, #84]	@ 0x54
 c0480b6:	ebb3 0f49 	cmp.w	r3, r9, lsl #1
 c0480ba:	d140      	bne.n	c04813e <mbedtls_psa_ecdsa_verify_hash+0xc6>
    {
        ret = MBEDTLS_ERR_ECP_VERIFY_FAILED;
        goto cleanup;
    }

    MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( &r,
 c0480bc:	464a      	mov	r2, r9
 c0480be:	4641      	mov	r1, r8
 c0480c0:	4638      	mov	r0, r7
 c0480c2:	f00b fa72 	bl	c0535aa <mbedtls_mpi_read_binary>
 c0480c6:	4604      	mov	r4, r0
 c0480c8:	b9b0      	cbnz	r0, c0480f8 <mbedtls_psa_ecdsa_verify_hash+0x80>
                                              signature,
                                              curve_bytes ) );
    MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( &s,
 c0480ca:	464a      	mov	r2, r9
 c0480cc:	4630      	mov	r0, r6
 c0480ce:	eb08 0109 	add.w	r1, r8, r9
 c0480d2:	f00b fa6a 	bl	c0535aa <mbedtls_mpi_read_binary>
 c0480d6:	4604      	mov	r4, r0
 c0480d8:	b970      	cbnz	r0, c0480f8 <mbedtls_psa_ecdsa_verify_hash+0x80>
                                              signature + curve_bytes,
                                              curve_bytes ) );

    /* Check whether the public part is loaded. If not, load it. */
    if( mbedtls_ecp_is_zero( &ecp->Q ) )
 c0480da:	f105 08ac 	add.w	r8, r5, #172	@ 0xac
 c0480de:	4640      	mov	r0, r8
 c0480e0:	f004 fc7a 	bl	c04c9d8 <mbedtls_ecp_is_zero>
 c0480e4:	b9d0      	cbnz	r0, c04811c <mbedtls_psa_ecdsa_verify_hash+0xa4>
        MBEDTLS_MPI_CHK(
            mbedtls_ecp_mul( &ecp->grp, &ecp->Q, &ecp->d, &ecp->grp.G,
                             mbedtls_psa_get_random, MBEDTLS_PSA_RANDOM_STATE ) );
    }

    ret = mbedtls_ecdsa_verify( &ecp->grp, hash, hash_length,
 c0480e6:	e9dd 1212 	ldrd	r1, r2, [sp, #72]	@ 0x48
 c0480ea:	4643      	mov	r3, r8
 c0480ec:	4628      	mov	r0, r5
 c0480ee:	e9cd 7600 	strd	r7, r6, [sp]
 c0480f2:	f004 f9db 	bl	c04c4ac <mbedtls_ecdsa_verify>
 c0480f6:	4604      	mov	r4, r0
                                &ecp->Q, &r, &s );

cleanup:
    mbedtls_mpi_free( &r );
 c0480f8:	4638      	mov	r0, r7
 c0480fa:	f00b f902 	bl	c053302 <mbedtls_mpi_free>
    mbedtls_mpi_free( &s );
 c0480fe:	4630      	mov	r0, r6
 c048100:	f00b f8ff 	bl	c053302 <mbedtls_mpi_free>
    mbedtls_ecp_keypair_free( ecp );
 c048104:	4628      	mov	r0, r5
 c048106:	f004 fc2a 	bl	c04c95e <mbedtls_ecp_keypair_free>
    mbedtls_free( ecp );
 c04810a:	4628      	mov	r0, r5
 c04810c:	f7f3 f950 	bl	c03b3b0 <mbedtls_free>

    return( mbedtls_to_psa_error( ret ) );
 c048110:	4620      	mov	r0, r4
 c048112:	f7fc fbd5 	bl	c0448c0 <mbedtls_to_psa_error>
}
 c048116:	b00b      	add	sp, #44	@ 0x2c
 c048118:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        MBEDTLS_MPI_CHK(
 c04811c:	4b09      	ldr	r3, [pc, #36]	@ (c048144 <mbedtls_psa_ecdsa_verify_hash+0xcc>)
 c04811e:	4641      	mov	r1, r8
 c048120:	681b      	ldr	r3, [r3, #0]
 c048122:	4628      	mov	r0, r5
 c048124:	9301      	str	r3, [sp, #4]
 c048126:	4b08      	ldr	r3, [pc, #32]	@ (c048148 <mbedtls_psa_ecdsa_verify_hash+0xd0>)
 c048128:	f105 02a0 	add.w	r2, r5, #160	@ 0xa0
 c04812c:	9300      	str	r3, [sp, #0]
 c04812e:	f105 0328 	add.w	r3, r5, #40	@ 0x28
 c048132:	f005 f8bd 	bl	c04d2b0 <mbedtls_ecp_mul>
 c048136:	4604      	mov	r4, r0
 c048138:	2800      	cmp	r0, #0
 c04813a:	d0d4      	beq.n	c0480e6 <mbedtls_psa_ecdsa_verify_hash+0x6e>
 c04813c:	e7dc      	b.n	c0480f8 <mbedtls_psa_ecdsa_verify_hash+0x80>
        ret = MBEDTLS_ERR_ECP_VERIFY_FAILED;
 c04813e:	4c03      	ldr	r4, [pc, #12]	@ (c04814c <mbedtls_psa_ecdsa_verify_hash+0xd4>)
 c048140:	e7da      	b.n	c0480f8 <mbedtls_psa_ecdsa_verify_hash+0x80>
 c048142:	bf00      	nop
 c048144:	0c060e6c 	.word	0x0c060e6c
 c048148:	0c055d65 	.word	0x0c055d65
 c04814c:	ffffb200 	.word	0xffffb200

0c048150 <mbedtls_md_info_from_psa>:
    defined(MBEDTLS_PSA_BUILTIN_ALG_RSA_OAEP) || \
    defined(MBEDTLS_PSA_BUILTIN_ALG_RSA_PSS) || \
    defined(MBEDTLS_PSA_BUILTIN_ALG_DETERMINISTIC_ECDSA)
const mbedtls_md_info_t *mbedtls_md_info_from_psa( psa_algorithm_t alg )
{
    switch( alg )
 c048150:	f100 407e 	add.w	r0, r0, #4261412864	@ 0xfe000000
 c048154:	3808      	subs	r0, #8
 c048156:	2803      	cmp	r0, #3
 c048158:	bf9a      	itte	ls
 c04815a:	4b02      	ldrls	r3, [pc, #8]	@ (c048164 <mbedtls_md_info_from_psa+0x14>)
 c04815c:	f853 0020 	ldrls.w	r0, [r3, r0, lsl #2]
{
 c048160:	2000      	movhi	r0, #0
            return( &mbedtls_sha512_info );
#endif
        default:
            return( NULL );
    }
}
 c048162:	4770      	bx	lr
 c048164:	0c060e84 	.word	0x0c060e84

0c048168 <mbedtls_psa_hash_abort>:

#if defined(MBEDTLS_PSA_BUILTIN_HASH)
psa_status_t mbedtls_psa_hash_abort(
    mbedtls_psa_hash_operation_t *operation )
{
    switch( operation->alg )
 c048168:	6803      	ldr	r3, [r0, #0]
 c04816a:	4a0d      	ldr	r2, [pc, #52]	@ (c0481a0 <mbedtls_psa_hash_abort+0x38>)
{
 c04816c:	b510      	push	{r4, lr}
    switch( operation->alg )
 c04816e:	4293      	cmp	r3, r2
{
 c048170:	4604      	mov	r4, r0
    switch( operation->alg )
 c048172:	d806      	bhi.n	c048182 <mbedtls_psa_hash_abort+0x1a>
 c048174:	3a02      	subs	r2, #2
 c048176:	4293      	cmp	r3, r2
 c048178:	d80c      	bhi.n	c048194 <mbedtls_psa_hash_abort+0x2c>
 c04817a:	b173      	cbz	r3, c04819a <mbedtls_psa_hash_abort+0x32>
 c04817c:	f06f 0088 	mvn.w	r0, #136	@ 0x88
 c048180:	e00d      	b.n	c04819e <mbedtls_psa_hash_abort+0x36>
 c048182:	f103 437e 	add.w	r3, r3, #4261412864	@ 0xfe000000
 c048186:	3b0a      	subs	r3, #10
 c048188:	2b01      	cmp	r3, #1
 c04818a:	d8f7      	bhi.n	c04817c <mbedtls_psa_hash_abort+0x14>
            mbedtls_sha256_free( &operation->ctx.sha256 );
            break;
#endif
#if defined(MBEDTLS_PSA_BUILTIN_ALG_SHA_384)
        case PSA_ALG_SHA_384:
            mbedtls_sha512_free( &operation->ctx.sha512 );
 c04818c:	3008      	adds	r0, #8
 c04818e:	f010 f87e 	bl	c05828e <mbedtls_sha512_free>
            break;
 c048192:	e002      	b.n	c04819a <mbedtls_psa_hash_abort+0x32>
            mbedtls_sha256_free( &operation->ctx.sha256 );
 c048194:	3008      	adds	r0, #8
 c048196:	f008 fc07 	bl	c0509a8 <mbedtls_sha256_free>
            break;
#endif
        default:
            return( PSA_ERROR_BAD_STATE );
    }
    operation->alg = 0;
 c04819a:	2000      	movs	r0, #0
 c04819c:	6020      	str	r0, [r4, #0]
    return( PSA_SUCCESS );
}
 c04819e:	bd10      	pop	{r4, pc}
 c0481a0:	02000009 	.word	0x02000009

0c0481a4 <mbedtls_psa_hash_setup>:
    psa_algorithm_t alg )
{
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;

    /* A context must be freshly initialized before it can be set up. */
    if( operation->alg != 0 )
 c0481a4:	6803      	ldr	r3, [r0, #0]
{
 c0481a6:	b570      	push	{r4, r5, r6, lr}
 c0481a8:	4605      	mov	r5, r0
 c0481aa:	460e      	mov	r6, r1
    if( operation->alg != 0 )
 c0481ac:	2b00      	cmp	r3, #0
 c0481ae:	d13f      	bne.n	c048230 <mbedtls_psa_hash_setup+0x8c>
    {
        return( PSA_ERROR_BAD_STATE );
    }

    switch( alg )
 c0481b0:	f101 437e 	add.w	r3, r1, #4261412864	@ 0xfe000000
 c0481b4:	3b08      	subs	r3, #8
 c0481b6:	2b03      	cmp	r3, #3
 c0481b8:	d82c      	bhi.n	c048214 <mbedtls_psa_hash_setup+0x70>
 c0481ba:	e8df f003 	tbb	[pc, r3]
 c0481be:	1302      	.short	0x1302
 c0481c0:	241a      	.short	0x241a
            ret = mbedtls_sha1_starts_ret( &operation->ctx.sha1 );
            break;
#endif
#if defined(MBEDTLS_PSA_BUILTIN_ALG_SHA_224)
        case PSA_ALG_SHA_224:
            mbedtls_sha256_init( &operation->ctx.sha256 );
 c0481c2:	f100 0408 	add.w	r4, r0, #8
 c0481c6:	4620      	mov	r0, r4
 c0481c8:	f008 fbd4 	bl	c050974 <mbedtls_sha256_init>
            ret = mbedtls_sha256_starts_ret( &operation->ctx.sha256, 1 );
 c0481cc:	2101      	movs	r1, #1
            break;
#endif
#if defined(MBEDTLS_PSA_BUILTIN_ALG_SHA_256)
        case PSA_ALG_SHA_256:
            mbedtls_sha256_init( &operation->ctx.sha256 );
            ret = mbedtls_sha256_starts_ret( &operation->ctx.sha256, 0 );
 c0481ce:	4620      	mov	r0, r4
 c0481d0:	f008 fbfa 	bl	c0509c8 <mbedtls_sha256_starts_ret>
            break;
#endif
#if defined(MBEDTLS_PSA_BUILTIN_ALG_SHA_512)
        case PSA_ALG_SHA_512:
            mbedtls_sha512_init( &operation->ctx.sha512 );
            ret = mbedtls_sha512_starts_ret( &operation->ctx.sha512, 0 );
 c0481d4:	4604      	mov	r4, r0
        default:
            return( PSA_ALG_IS_HASH( alg ) ?
                    PSA_ERROR_NOT_SUPPORTED :
                    PSA_ERROR_INVALID_ARGUMENT );
    }
    if( ret == 0 )
 c0481d6:	bb38      	cbnz	r0, c048228 <mbedtls_psa_hash_setup+0x84>
        operation->alg = alg;
 c0481d8:	602e      	str	r6, [r5, #0]
    else
        mbedtls_psa_hash_abort( operation );
    return( mbedtls_to_psa_error( ret ) );
 c0481da:	4620      	mov	r0, r4
}
 c0481dc:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    return( mbedtls_to_psa_error( ret ) );
 c0481e0:	f7fc bb6e 	b.w	c0448c0 <mbedtls_to_psa_error>
            mbedtls_sha256_init( &operation->ctx.sha256 );
 c0481e4:	f100 0408 	add.w	r4, r0, #8
 c0481e8:	4620      	mov	r0, r4
 c0481ea:	f008 fbc3 	bl	c050974 <mbedtls_sha256_init>
            ret = mbedtls_sha256_starts_ret( &operation->ctx.sha256, 0 );
 c0481ee:	2100      	movs	r1, #0
 c0481f0:	e7ed      	b.n	c0481ce <mbedtls_psa_hash_setup+0x2a>
            mbedtls_sha512_init( &operation->ctx.sha512 );
 c0481f2:	f100 0408 	add.w	r4, r0, #8
 c0481f6:	4620      	mov	r0, r4
 c0481f8:	f010 f845 	bl	c058286 <mbedtls_sha512_init>
            ret = mbedtls_sha512_starts_ret( &operation->ctx.sha512, 1 );
 c0481fc:	2101      	movs	r1, #1
            ret = mbedtls_sha512_starts_ret( &operation->ctx.sha512, 0 );
 c0481fe:	4620      	mov	r0, r4
 c048200:	f010 f852 	bl	c0582a8 <mbedtls_sha512_starts_ret>
 c048204:	e7e6      	b.n	c0481d4 <mbedtls_psa_hash_setup+0x30>
            mbedtls_sha512_init( &operation->ctx.sha512 );
 c048206:	f100 0408 	add.w	r4, r0, #8
 c04820a:	4620      	mov	r0, r4
 c04820c:	f010 f83b 	bl	c058286 <mbedtls_sha512_init>
            ret = mbedtls_sha512_starts_ret( &operation->ctx.sha512, 0 );
 c048210:	2100      	movs	r1, #0
 c048212:	e7f4      	b.n	c0481fe <mbedtls_psa_hash_setup+0x5a>
            return( PSA_ALG_IS_HASH( alg ) ?
 c048214:	f001 46fe 	and.w	r6, r1, #2130706432	@ 0x7f000000
                    PSA_ERROR_NOT_SUPPORTED :
 c048218:	f1b6 7f00 	cmp.w	r6, #33554432	@ 0x2000000
 c04821c:	bf14      	ite	ne
 c04821e:	f06f 0086 	mvnne.w	r0, #134	@ 0x86
 c048222:	f06f 0085 	mvneq.w	r0, #133	@ 0x85
}
 c048226:	bd70      	pop	{r4, r5, r6, pc}
        mbedtls_psa_hash_abort( operation );
 c048228:	4628      	mov	r0, r5
 c04822a:	f7ff ff9d 	bl	c048168 <mbedtls_psa_hash_abort>
 c04822e:	e7d4      	b.n	c0481da <mbedtls_psa_hash_setup+0x36>
        return( PSA_ERROR_BAD_STATE );
 c048230:	f06f 0088 	mvn.w	r0, #136	@ 0x88
 c048234:	e7f7      	b.n	c048226 <mbedtls_psa_hash_setup+0x82>
	...

0c048238 <mbedtls_psa_hash_clone>:

psa_status_t mbedtls_psa_hash_clone(
    const mbedtls_psa_hash_operation_t *source_operation,
    mbedtls_psa_hash_operation_t *target_operation )
{
 c048238:	b538      	push	{r3, r4, r5, lr}
    switch( source_operation->alg )
 c04823a:	4a14      	ldr	r2, [pc, #80]	@ (c04828c <mbedtls_psa_hash_clone+0x54>)
 c04823c:	6803      	ldr	r3, [r0, #0]
{
 c04823e:	4604      	mov	r4, r0
    switch( source_operation->alg )
 c048240:	4293      	cmp	r3, r2
{
 c048242:	460d      	mov	r5, r1
    switch( source_operation->alg )
 c048244:	d809      	bhi.n	c04825a <mbedtls_psa_hash_clone+0x22>
 c048246:	3a02      	subs	r2, #2
 c048248:	4293      	cmp	r3, r2
 c04824a:	d80e      	bhi.n	c04826a <mbedtls_psa_hash_clone+0x32>
 c04824c:	2b00      	cmp	r3, #0
 c04824e:	bf0c      	ite	eq
 c048250:	f06f 0088 	mvneq.w	r0, #136	@ 0x88
 c048254:	f06f 0085 	mvnne.w	r0, #133	@ 0x85
            return( PSA_ERROR_NOT_SUPPORTED );
    }

    target_operation->alg = source_operation->alg;
    return( PSA_SUCCESS );
}
 c048258:	bd38      	pop	{r3, r4, r5, pc}
    switch( source_operation->alg )
 c04825a:	f103 437e 	add.w	r3, r3, #4261412864	@ 0xfe000000
 c04825e:	3b0a      	subs	r3, #10
 c048260:	2b01      	cmp	r3, #1
 c048262:	d90c      	bls.n	c04827e <mbedtls_psa_hash_clone+0x46>
 c048264:	f06f 0085 	mvn.w	r0, #133	@ 0x85
 c048268:	e7f6      	b.n	c048258 <mbedtls_psa_hash_clone+0x20>
            mbedtls_sha256_clone( &target_operation->ctx.sha256,
 c04826a:	f100 0108 	add.w	r1, r0, #8
 c04826e:	f105 0008 	add.w	r0, r5, #8
 c048272:	f008 fba3 	bl	c0509bc <mbedtls_sha256_clone>
    target_operation->alg = source_operation->alg;
 c048276:	6823      	ldr	r3, [r4, #0]
    return( PSA_SUCCESS );
 c048278:	2000      	movs	r0, #0
    target_operation->alg = source_operation->alg;
 c04827a:	602b      	str	r3, [r5, #0]
    return( PSA_SUCCESS );
 c04827c:	e7ec      	b.n	c048258 <mbedtls_psa_hash_clone+0x20>
            mbedtls_sha512_clone( &target_operation->ctx.sha512,
 c04827e:	f100 0108 	add.w	r1, r0, #8
 c048282:	f105 0008 	add.w	r0, r5, #8
 c048286:	f010 f807 	bl	c058298 <mbedtls_sha512_clone>
            break;
 c04828a:	e7f4      	b.n	c048276 <mbedtls_psa_hash_clone+0x3e>
 c04828c:	02000009 	.word	0x02000009

0c048290 <mbedtls_psa_hash_update>:

psa_status_t mbedtls_psa_hash_update(
    mbedtls_psa_hash_operation_t *operation,
    const uint8_t *input,
    size_t input_length )
{
 c048290:	b510      	push	{r4, lr}
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;

    switch( operation->alg )
 c048292:	6803      	ldr	r3, [r0, #0]
 c048294:	4c0c      	ldr	r4, [pc, #48]	@ (c0482c8 <mbedtls_psa_hash_update+0x38>)
 c048296:	42a3      	cmp	r3, r4
 c048298:	d809      	bhi.n	c0482ae <mbedtls_psa_hash_update+0x1e>
 c04829a:	3c02      	subs	r4, #2
 c04829c:	42a3      	cmp	r3, r4
 c04829e:	d90b      	bls.n	c0482b8 <mbedtls_psa_hash_update+0x28>
                                           input, input_length );
            break;
#endif
#if defined(MBEDTLS_PSA_BUILTIN_ALG_SHA_224)
        case PSA_ALG_SHA_224:
            ret = mbedtls_sha256_update_ret( &operation->ctx.sha256,
 c0482a0:	3008      	adds	r0, #8
 c0482a2:	f008 fbb1 	bl	c050a08 <mbedtls_sha256_update_ret>
            (void) input_length;
            return( PSA_ERROR_BAD_STATE );
    }

    return( mbedtls_to_psa_error( ret ) );
}
 c0482a6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    return( mbedtls_to_psa_error( ret ) );
 c0482aa:	f7fc bb09 	b.w	c0448c0 <mbedtls_to_psa_error>
    switch( operation->alg )
 c0482ae:	f103 437e 	add.w	r3, r3, #4261412864	@ 0xfe000000
 c0482b2:	3b0a      	subs	r3, #10
 c0482b4:	2b01      	cmp	r3, #1
 c0482b6:	d902      	bls.n	c0482be <mbedtls_psa_hash_update+0x2e>
}
 c0482b8:	f06f 0088 	mvn.w	r0, #136	@ 0x88
 c0482bc:	bd10      	pop	{r4, pc}
            ret = mbedtls_sha512_update_ret( &operation->ctx.sha512,
 c0482be:	3008      	adds	r0, #8
 c0482c0:	f010 fd68 	bl	c058d94 <mbedtls_sha512_update_ret>
            break;
 c0482c4:	e7ef      	b.n	c0482a6 <mbedtls_psa_hash_update+0x16>
 c0482c6:	bf00      	nop
 c0482c8:	02000009 	.word	0x02000009

0c0482cc <mbedtls_psa_hash_finish>:
psa_status_t mbedtls_psa_hash_finish(
    mbedtls_psa_hash_operation_t *operation,
    uint8_t *hash,
    size_t hash_size,
    size_t *hash_length )
{
 c0482cc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    psa_status_t status;
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    size_t actual_hash_length = PSA_HASH_LENGTH( operation->alg );
 c0482d0:	7804      	ldrb	r4, [r0, #0]
{
 c0482d2:	461d      	mov	r5, r3
    size_t actual_hash_length = PSA_HASH_LENGTH( operation->alg );
 c0482d4:	4b20      	ldr	r3, [pc, #128]	@ (c048358 <mbedtls_psa_hash_finish+0x8c>)
 c0482d6:	f044 7400 	orr.w	r4, r4, #33554432	@ 0x2000000
 c0482da:	429c      	cmp	r4, r3
{
 c0482dc:	4606      	mov	r6, r0
 c0482de:	460f      	mov	r7, r1
 c0482e0:	4690      	mov	r8, r2
    size_t actual_hash_length = PSA_HASH_LENGTH( operation->alg );
 c0482e2:	d01c      	beq.n	c04831e <mbedtls_psa_hash_finish+0x52>
 c0482e4:	f104 447e 	add.w	r4, r4, #4261412864	@ 0xfe000000
 c0482e8:	3c02      	subs	r4, #2
 c0482ea:	2c11      	cmp	r4, #17
 c0482ec:	d819      	bhi.n	c048322 <mbedtls_psa_hash_finish+0x56>
 c0482ee:	4b1b      	ldr	r3, [pc, #108]	@ (c04835c <mbedtls_psa_hash_finish+0x90>)
 c0482f0:	5d1c      	ldrb	r4, [r3, r4]

    /* Fill the output buffer with something that isn't a valid hash
     * (barring an attack on the hash and deliberately-crafted input),
     * in case the caller doesn't check the return status properly. */
    *hash_length = hash_size;
 c0482f2:	f8c5 8000 	str.w	r8, [r5]
    /* If hash_size is 0 then hash may be NULL and then the
     * call to memset would have undefined behavior. */
    if( hash_size != 0 )
 c0482f6:	f1b8 0f00 	cmp.w	r8, #0
 c0482fa:	d004      	beq.n	c048306 <mbedtls_psa_hash_finish+0x3a>
        memset( hash, '!', hash_size );
 c0482fc:	4642      	mov	r2, r8
 c0482fe:	2121      	movs	r1, #33	@ 0x21
 c048300:	4638      	mov	r0, r7
 c048302:	f013 fa14 	bl	c05b72e <memset>

    if( hash_size < actual_hash_length )
 c048306:	4544      	cmp	r4, r8
 c048308:	d823      	bhi.n	c048352 <mbedtls_psa_hash_finish+0x86>
    {
        status = PSA_ERROR_BUFFER_TOO_SMALL;
        goto exit;
    }

    switch( operation->alg )
 c04830a:	6832      	ldr	r2, [r6, #0]
 c04830c:	4b14      	ldr	r3, [pc, #80]	@ (c048360 <mbedtls_psa_hash_finish+0x94>)
 c04830e:	429a      	cmp	r2, r3
 c048310:	d809      	bhi.n	c048326 <mbedtls_psa_hash_finish+0x5a>
 c048312:	3b02      	subs	r3, #2
 c048314:	429a      	cmp	r2, r3
 c048316:	d811      	bhi.n	c04833c <mbedtls_psa_hash_finish+0x70>
 c048318:	f06f 0088 	mvn.w	r0, #136	@ 0x88
 c04831c:	e017      	b.n	c04834e <mbedtls_psa_hash_finish+0x82>
    size_t actual_hash_length = PSA_HASH_LENGTH( operation->alg );
 c04831e:	2410      	movs	r4, #16
 c048320:	e7e7      	b.n	c0482f2 <mbedtls_psa_hash_finish+0x26>
 c048322:	2400      	movs	r4, #0
 c048324:	e7e5      	b.n	c0482f2 <mbedtls_psa_hash_finish+0x26>
    switch( operation->alg )
 c048326:	f102 427e 	add.w	r2, r2, #4261412864	@ 0xfe000000
 c04832a:	3a0a      	subs	r2, #10
 c04832c:	2a01      	cmp	r2, #1
 c04832e:	d8f3      	bhi.n	c048318 <mbedtls_psa_hash_finish+0x4c>
            ret = mbedtls_sha256_finish_ret( &operation->ctx.sha256, hash );
            break;
#endif
#if defined(MBEDTLS_PSA_BUILTIN_ALG_SHA_384)
        case PSA_ALG_SHA_384:
            ret = mbedtls_sha512_finish_ret( &operation->ctx.sha512, hash );
 c048330:	4639      	mov	r1, r7
 c048332:	f106 0008 	add.w	r0, r6, #8
 c048336:	f010 fd73 	bl	c058e20 <mbedtls_sha512_finish_ret>
            break;
 c04833a:	e004      	b.n	c048346 <mbedtls_psa_hash_finish+0x7a>
            ret = mbedtls_sha256_finish_ret( &operation->ctx.sha256, hash );
 c04833c:	4639      	mov	r1, r7
 c04833e:	f106 0008 	add.w	r0, r6, #8
 c048342:	f008 fbc8 	bl	c050ad6 <mbedtls_sha256_finish_ret>
#endif
        default:
            (void) hash;
            return( PSA_ERROR_BAD_STATE );
    }
    status = mbedtls_to_psa_error( ret );
 c048346:	f7fc fabb 	bl	c0448c0 <mbedtls_to_psa_error>

exit:
    if( status == PSA_SUCCESS )
 c04834a:	b900      	cbnz	r0, c04834e <mbedtls_psa_hash_finish+0x82>
        *hash_length = actual_hash_length;
 c04834c:	602c      	str	r4, [r5, #0]
    return( status );
}
 c04834e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        status = PSA_ERROR_BUFFER_TOO_SMALL;
 c048352:	f06f 0089 	mvn.w	r0, #137	@ 0x89
 c048356:	e7fa      	b.n	c04834e <mbedtls_psa_hash_finish+0x82>
 c048358:	02000001 	.word	0x02000001
 c04835c:	0c060e70 	.word	0x0c060e70
 c048360:	02000009 	.word	0x02000009

0c048364 <mbedtls_psa_hash_compute>:
    const uint8_t *input,
    size_t input_length,
    uint8_t *hash,
    size_t hash_size,
    size_t *hash_length)
{
 c048364:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 c048368:	4604      	mov	r4, r0
 c04836a:	b0e1      	sub	sp, #388	@ 0x184
 c04836c:	460e      	mov	r6, r1
 c04836e:	e9dd 8968 	ldrd	r8, r9, [sp, #416]	@ 0x1a0
    mbedtls_psa_hash_operation_t operation = MBEDTLS_PSA_HASH_OPERATION_INIT;
 c048372:	2100      	movs	r1, #0
{
 c048374:	4617      	mov	r7, r2
    mbedtls_psa_hash_operation_t operation = MBEDTLS_PSA_HASH_OPERATION_INIT;
 c048376:	4668      	mov	r0, sp
 c048378:	f44f 72c0 	mov.w	r2, #384	@ 0x180
{
 c04837c:	461d      	mov	r5, r3
    mbedtls_psa_hash_operation_t operation = MBEDTLS_PSA_HASH_OPERATION_INIT;
 c04837e:	f013 f9d6 	bl	c05b72e <memset>
    psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
    psa_status_t abort_status = PSA_ERROR_CORRUPTION_DETECTED;

    *hash_length = hash_size;
    status = mbedtls_psa_hash_setup( &operation, alg );
 c048382:	4621      	mov	r1, r4
 c048384:	4668      	mov	r0, sp
    *hash_length = hash_size;
 c048386:	f8c9 8000 	str.w	r8, [r9]
    status = mbedtls_psa_hash_setup( &operation, alg );
 c04838a:	f7ff ff0b 	bl	c0481a4 <mbedtls_psa_hash_setup>
    if( status != PSA_SUCCESS )
 c04838e:	4604      	mov	r4, r0
 c048390:	b968      	cbnz	r0, c0483ae <mbedtls_psa_hash_compute+0x4a>
        goto exit;
    status = mbedtls_psa_hash_update( &operation, input, input_length );
 c048392:	463a      	mov	r2, r7
 c048394:	4631      	mov	r1, r6
 c048396:	4668      	mov	r0, sp
 c048398:	f7ff ff7a 	bl	c048290 <mbedtls_psa_hash_update>
    if( status != PSA_SUCCESS )
 c04839c:	4604      	mov	r4, r0
 c04839e:	b930      	cbnz	r0, c0483ae <mbedtls_psa_hash_compute+0x4a>
        goto exit;
    status = mbedtls_psa_hash_finish( &operation, hash, hash_size, hash_length );
 c0483a0:	464b      	mov	r3, r9
 c0483a2:	4642      	mov	r2, r8
 c0483a4:	4629      	mov	r1, r5
 c0483a6:	4668      	mov	r0, sp
 c0483a8:	f7ff ff90 	bl	c0482cc <mbedtls_psa_hash_finish>
 c0483ac:	4604      	mov	r4, r0
    if( status != PSA_SUCCESS )
        goto exit;

exit:
    abort_status = mbedtls_psa_hash_abort( &operation );
 c0483ae:	4668      	mov	r0, sp
 c0483b0:	f7ff feda 	bl	c048168 <mbedtls_psa_hash_abort>
    if( status == PSA_SUCCESS )
        return( abort_status );
    else
        return( status );

}
 c0483b4:	2c00      	cmp	r4, #0
 c0483b6:	bf18      	it	ne
 c0483b8:	4620      	movne	r0, r4
 c0483ba:	b061      	add	sp, #388	@ 0x184
 c0483bc:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

0c0483c0 <psa_mac_finish_internal>:
}

static psa_status_t psa_mac_finish_internal(
    mbedtls_psa_mac_operation_t *operation,
    uint8_t *mac, size_t mac_size )
{
 c0483c0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 c0483c4:	4616      	mov	r6, r2
#if defined(MBEDTLS_PSA_BUILTIN_ALG_CMAC)
    if( PSA_ALG_FULL_LENGTH_MAC( operation->alg ) == PSA_ALG_CMAC )
 c0483c6:	6802      	ldr	r2, [r0, #0]
 c0483c8:	4b38      	ldr	r3, [pc, #224]	@ (c0484ac <psa_mac_finish_internal+0xec>)
{
 c0483ca:	460d      	mov	r5, r1
    if( PSA_ALG_FULL_LENGTH_MAC( operation->alg ) == PSA_ALG_CMAC )
 c0483cc:	f422 117e 	bic.w	r1, r2, #4161536	@ 0x3f8000
 c0483d0:	4299      	cmp	r1, r3
{
 c0483d2:	4680      	mov	r8, r0
 c0483d4:	b092      	sub	sp, #72	@ 0x48
    if( PSA_ALG_FULL_LENGTH_MAC( operation->alg ) == PSA_ALG_CMAC )
 c0483d6:	d116      	bne.n	c048406 <psa_mac_finish_internal+0x46>
    {
        uint8_t tmp[PSA_BLOCK_CIPHER_BLOCK_MAX_SIZE];
        int ret = mbedtls_cipher_cmac_finish( &operation->ctx.cmac, tmp );
 c0483d8:	a902      	add	r1, sp, #8
 c0483da:	3008      	adds	r0, #8
 c0483dc:	f00d f934 	bl	c055648 <mbedtls_cipher_cmac_finish>
        if( ret == 0 )
 c0483e0:	4604      	mov	r4, r0
 c0483e2:	b920      	cbnz	r0, c0483ee <psa_mac_finish_internal+0x2e>
            memcpy( mac, tmp, mac_size );
 c0483e4:	4632      	mov	r2, r6
 c0483e6:	4628      	mov	r0, r5
 c0483e8:	a902      	add	r1, sp, #8
 c0483ea:	f013 f92f 	bl	c05b64c <memcpy>
        mbedtls_platform_zeroize( tmp, sizeof( tmp ) );
 c0483ee:	2110      	movs	r1, #16
 c0483f0:	a802      	add	r0, sp, #8
 c0483f2:	f7f2 ffed 	bl	c03b3d0 <mbedtls_platform_zeroize>
        return( mbedtls_to_psa_error( ret ) );
 c0483f6:	4620      	mov	r0, r4
 c0483f8:	f7fc fa62 	bl	c0448c0 <mbedtls_to_psa_error>
 c0483fc:	4604      	mov	r4, r0
        (void) operation;
        (void) mac;
        (void) mac_size;
        return( PSA_ERROR_BAD_STATE );
    }
}
 c0483fe:	4620      	mov	r0, r4
 c048400:	b012      	add	sp, #72	@ 0x48
 c048402:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if( PSA_ALG_IS_HMAC( operation->alg ) )
 c048406:	4b2a      	ldr	r3, [pc, #168]	@ (c0484b0 <psa_mac_finish_internal+0xf0>)
 c048408:	4013      	ands	r3, r2
 c04840a:	f1b3 7f60 	cmp.w	r3, #58720256	@ 0x3800000
 c04840e:	d149      	bne.n	c0484a4 <psa_mac_finish_internal+0xe4>
    size_t hash_size = 0;
 c048410:	2200      	movs	r2, #0
    psa_algorithm_t hash_alg = hmac->alg;
 c048412:	f8d0 a008 	ldr.w	sl, [r0, #8]
    size_t block_size = PSA_HASH_BLOCK_LENGTH( hash_alg );
 c048416:	4927      	ldr	r1, [pc, #156]	@ (c0484b4 <psa_mac_finish_internal+0xf4>)
 c048418:	fa5f f38a 	uxtb.w	r3, sl
 c04841c:	f043 7300 	orr.w	r3, r3, #33554432	@ 0x2000000
 c048420:	428b      	cmp	r3, r1
    size_t hash_size = 0;
 c048422:	9201      	str	r2, [sp, #4]
    size_t block_size = PSA_HASH_BLOCK_LENGTH( hash_alg );
 c048424:	d039      	beq.n	c04849a <psa_mac_finish_internal+0xda>
 c048426:	f103 437e 	add.w	r3, r3, #4261412864	@ 0xfe000000
 c04842a:	3b02      	subs	r3, #2
 c04842c:	2b11      	cmp	r3, #17
 c04842e:	d837      	bhi.n	c0484a0 <psa_mac_finish_internal+0xe0>
 c048430:	4a21      	ldr	r2, [pc, #132]	@ (c0484b8 <psa_mac_finish_internal+0xf8>)
 c048432:	f812 9003 	ldrb.w	r9, [r2, r3]
    status = psa_hash_finish( &hmac->hash_ctx, tmp, sizeof( tmp ), &hash_size );
 c048436:	f108 0710 	add.w	r7, r8, #16
 c04843a:	2240      	movs	r2, #64	@ 0x40
 c04843c:	4638      	mov	r0, r7
 c04843e:	ab01      	add	r3, sp, #4
 c048440:	a902      	add	r1, sp, #8
 c048442:	f7fd f991 	bl	c045768 <mbedcrypto__psa_hash_finish>
    if( status != PSA_SUCCESS )
 c048446:	4604      	mov	r4, r0
 c048448:	2800      	cmp	r0, #0
 c04844a:	d1d8      	bne.n	c0483fe <psa_mac_finish_internal+0x3e>
    status = psa_hash_setup( &hmac->hash_ctx, hash_alg );
 c04844c:	4651      	mov	r1, sl
 c04844e:	4638      	mov	r0, r7
 c048450:	f7fd f956 	bl	c045700 <mbedcrypto__psa_hash_setup>
    if( status != PSA_SUCCESS )
 c048454:	4604      	mov	r4, r0
 c048456:	b9d8      	cbnz	r0, c048490 <psa_mac_finish_internal+0xd0>
    status = psa_hash_update( &hmac->hash_ctx, hmac->opad, block_size );
 c048458:	464a      	mov	r2, r9
 c04845a:	4638      	mov	r0, r7
 c04845c:	f508 71cc 	add.w	r1, r8, #408	@ 0x198
 c048460:	f7fd f96e 	bl	c045740 <mbedcrypto__psa_hash_update>
    if( status != PSA_SUCCESS )
 c048464:	4604      	mov	r4, r0
 c048466:	b998      	cbnz	r0, c048490 <psa_mac_finish_internal+0xd0>
    status = psa_hash_update( &hmac->hash_ctx, tmp, hash_size );
 c048468:	4638      	mov	r0, r7
 c04846a:	9a01      	ldr	r2, [sp, #4]
 c04846c:	a902      	add	r1, sp, #8
 c04846e:	f7fd f967 	bl	c045740 <mbedcrypto__psa_hash_update>
    if( status != PSA_SUCCESS )
 c048472:	4604      	mov	r4, r0
 c048474:	b960      	cbnz	r0, c048490 <psa_mac_finish_internal+0xd0>
    status = psa_hash_finish( &hmac->hash_ctx, tmp, sizeof( tmp ), &hash_size );
 c048476:	2240      	movs	r2, #64	@ 0x40
 c048478:	4638      	mov	r0, r7
 c04847a:	ab01      	add	r3, sp, #4
 c04847c:	a902      	add	r1, sp, #8
 c04847e:	f7fd f973 	bl	c045768 <mbedcrypto__psa_hash_finish>
    if( status != PSA_SUCCESS )
 c048482:	4604      	mov	r4, r0
 c048484:	b920      	cbnz	r0, c048490 <psa_mac_finish_internal+0xd0>
    memcpy( mac, tmp, mac_size );
 c048486:	4632      	mov	r2, r6
 c048488:	4628      	mov	r0, r5
 c04848a:	a902      	add	r1, sp, #8
 c04848c:	f013 f8de 	bl	c05b64c <memcpy>
    mbedtls_platform_zeroize( tmp, hash_size );
 c048490:	9901      	ldr	r1, [sp, #4]
 c048492:	a802      	add	r0, sp, #8
 c048494:	f7f2 ff9c 	bl	c03b3d0 <mbedtls_platform_zeroize>
        return( psa_hmac_finish_internal( &operation->ctx.hmac,
 c048498:	e7b1      	b.n	c0483fe <psa_mac_finish_internal+0x3e>
    size_t block_size = PSA_HASH_BLOCK_LENGTH( hash_alg );
 c04849a:	f04f 0910 	mov.w	r9, #16
 c04849e:	e7ca      	b.n	c048436 <psa_mac_finish_internal+0x76>
 c0484a0:	4691      	mov	r9, r2
 c0484a2:	e7c8      	b.n	c048436 <psa_mac_finish_internal+0x76>
        return( PSA_ERROR_BAD_STATE );
 c0484a4:	f06f 0488 	mvn.w	r4, #136	@ 0x88
 c0484a8:	e7a9      	b.n	c0483fe <psa_mac_finish_internal+0x3e>
 c0484aa:	bf00      	nop
 c0484ac:	03c00200 	.word	0x03c00200
 c0484b0:	7fc00000 	.word	0x7fc00000
 c0484b4:	02000001 	.word	0x02000001
 c0484b8:	0c060e94 	.word	0x0c060e94

0c0484bc <mbedtls_psa_mac_abort>:
    if( operation->alg == 0 )
 c0484bc:	6802      	ldr	r2, [r0, #0]
{
 c0484be:	b538      	push	{r3, r4, r5, lr}
 c0484c0:	4604      	mov	r4, r0
    if( operation->alg == 0 )
 c0484c2:	b14a      	cbz	r2, c0484d8 <mbedtls_psa_mac_abort+0x1c>
    if( PSA_ALG_FULL_LENGTH_MAC( operation->alg ) == PSA_ALG_CMAC )
 c0484c4:	4b11      	ldr	r3, [pc, #68]	@ (c04850c <mbedtls_psa_mac_abort+0x50>)
 c0484c6:	f422 117e 	bic.w	r1, r2, #4161536	@ 0x3f8000
 c0484ca:	4299      	cmp	r1, r3
 c0484cc:	d106      	bne.n	c0484dc <mbedtls_psa_mac_abort+0x20>
        mbedtls_cipher_free( &operation->ctx.cmac );
 c0484ce:	3008      	adds	r0, #8
 c0484d0:	f00c fda2 	bl	c055018 <mbedtls_cipher_free>
    operation->alg = 0;
 c0484d4:	2300      	movs	r3, #0
 c0484d6:	6023      	str	r3, [r4, #0]
        return( PSA_SUCCESS );
 c0484d8:	2000      	movs	r0, #0
 c0484da:	e015      	b.n	c048508 <mbedtls_psa_mac_abort+0x4c>
    if( PSA_ALG_IS_HMAC( operation->alg ) )
 c0484dc:	4b0c      	ldr	r3, [pc, #48]	@ (c048510 <mbedtls_psa_mac_abort+0x54>)
 c0484de:	4013      	ands	r3, r2
 c0484e0:	f1b3 7f60 	cmp.w	r3, #58720256	@ 0x3800000
 c0484e4:	d109      	bne.n	c0484fa <mbedtls_psa_mac_abort+0x3e>
    mbedtls_platform_zeroize( hmac->opad, sizeof( hmac->opad ) );
 c0484e6:	2180      	movs	r1, #128	@ 0x80
 c0484e8:	f500 70cc 	add.w	r0, r0, #408	@ 0x198
 c0484ec:	f7f2 ff70 	bl	c03b3d0 <mbedtls_platform_zeroize>
    return( psa_hash_abort( &hmac->hash_ctx ) );
 c0484f0:	f104 0010 	add.w	r0, r4, #16
 c0484f4:	f7fd f8f9 	bl	c0456ea <mbedcrypto__psa_hash_abort>
 c0484f8:	e7ec      	b.n	c0484d4 <mbedtls_psa_mac_abort+0x18>
    memset( operation, 0, sizeof( *operation ) );
 c0484fa:	f44f 7206 	mov.w	r2, #536	@ 0x218
 c0484fe:	2100      	movs	r1, #0
 c048500:	f013 f915 	bl	c05b72e <memset>
 c048504:	f06f 0088 	mvn.w	r0, #136	@ 0x88
}
 c048508:	bd38      	pop	{r3, r4, r5, pc}
 c04850a:	bf00      	nop
 c04850c:	03c00200 	.word	0x03c00200
 c048510:	7fc00000 	.word	0x7fc00000

0c048514 <psa_mac_setup>:
{
 c048514:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    if( operation->alg != 0 )
 c048518:	f8d0 8000 	ldr.w	r8, [r0]
{
 c04851c:	b0a4      	sub	sp, #144	@ 0x90
 c04851e:	4614      	mov	r4, r2
 c048520:	4605      	mov	r5, r0
 c048522:	460f      	mov	r7, r1
 c048524:	461a      	mov	r2, r3
 c048526:	9e2c      	ldr	r6, [sp, #176]	@ 0xb0
    if( operation->alg != 0 )
 c048528:	f1b8 0f00 	cmp.w	r8, #0
 c04852c:	f040 80bf 	bne.w	c0486ae <psa_mac_setup+0x19a>
    if( PSA_ALG_FULL_LENGTH_MAC( operation->alg ) == PSA_ALG_CMAC )
 c048530:	4b60      	ldr	r3, [pc, #384]	@ (c0486b4 <psa_mac_setup+0x1a0>)
 c048532:	f426 197e 	bic.w	r9, r6, #4161536	@ 0x3f8000
 c048536:	4599      	cmp	r9, r3
    operation->alg = alg;
 c048538:	6006      	str	r6, [r0, #0]
    if( PSA_ALG_FULL_LENGTH_MAC( operation->alg ) == PSA_ALG_CMAC )
 c04853a:	d112      	bne.n	c048562 <psa_mac_setup+0x4e>
        mbedtls_cipher_init( &operation->ctx.cmac );
 c04853c:	f100 0608 	add.w	r6, r0, #8
 c048540:	4630      	mov	r0, r6
 c048542:	f00c fd65 	bl	c055010 <mbedtls_cipher_init>
        mbedtls_cipher_info_from_psa(
 c048546:	8839      	ldrh	r1, [r7, #0]
 c048548:	4643      	mov	r3, r8
 c04854a:	4648      	mov	r0, r9
 c04854c:	887a      	ldrh	r2, [r7, #2]
 c04854e:	f7fe fef1 	bl	c047334 <mbedtls_cipher_info_from_psa>
    if( cipher_info == NULL )
 c048552:	4601      	mov	r1, r0
 c048554:	bb88      	cbnz	r0, c0485ba <psa_mac_setup+0xa6>
    for( i = 0; i < key_length; i++ )
 c048556:	f06f 0485 	mvn.w	r4, #133	@ 0x85
        mbedtls_psa_mac_abort( operation );
 c04855a:	4628      	mov	r0, r5
 c04855c:	f7ff ffae 	bl	c0484bc <mbedtls_psa_mac_abort>
 c048560:	e00b      	b.n	c04857a <psa_mac_setup+0x66>
    if( PSA_ALG_IS_HMAC( operation->alg ) )
 c048562:	4b55      	ldr	r3, [pc, #340]	@ (c0486b8 <psa_mac_setup+0x1a4>)
 c048564:	4033      	ands	r3, r6
 c048566:	f1b3 7f60 	cmp.w	r3, #58720256	@ 0x3800000
 c04856a:	d00a      	beq.n	c048582 <psa_mac_setup+0x6e>
        memset( operation, 0, sizeof( *operation ) );
 c04856c:	f44f 7206 	mov.w	r2, #536	@ 0x218
 c048570:	4641      	mov	r1, r8
 c048572:	f013 f8dc 	bl	c05b72e <memset>
        status = PSA_ERROR_NOT_SUPPORTED;
 c048576:	f06f 0485 	mvn.w	r4, #133	@ 0x85
}
 c04857a:	4620      	mov	r0, r4
 c04857c:	b024      	add	sp, #144	@ 0x90
 c04857e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    size_t hash_size = PSA_HASH_LENGTH( hash_alg );
 c048582:	4b4e      	ldr	r3, [pc, #312]	@ (c0486bc <psa_mac_setup+0x1a8>)
                                          PSA_ALG_HMAC_GET_HASH( alg ) );
 c048584:	b2f6      	uxtb	r6, r6
        status = psa_hmac_setup_internal( &operation->ctx.hmac,
 c048586:	f046 7600 	orr.w	r6, r6, #33554432	@ 0x2000000
    size_t hash_size = PSA_HASH_LENGTH( hash_alg );
 c04858a:	429e      	cmp	r6, r3
 c04858c:	9203      	str	r2, [sp, #12]
 c04858e:	d123      	bne.n	c0485d8 <psa_mac_setup+0xc4>
    size_t block_size = PSA_HASH_BLOCK_LENGTH( hash_alg );
 c048590:	2710      	movs	r7, #16
    hmac->alg = hash_alg;
 c048592:	6086      	str	r6, [r0, #8]
    if( key_length > block_size )
 c048594:	42ba      	cmp	r2, r7
 c048596:	d94a      	bls.n	c04862e <psa_mac_setup+0x11a>
        status = psa_hash_compute( hash_alg, key, key_length,
 c048598:	ab03      	add	r3, sp, #12
 c04859a:	9301      	str	r3, [sp, #4]
 c04859c:	2380      	movs	r3, #128	@ 0x80
 c04859e:	4621      	mov	r1, r4
 c0485a0:	9300      	str	r3, [sp, #0]
 c0485a2:	4630      	mov	r0, r6
 c0485a4:	ab04      	add	r3, sp, #16
 c0485a6:	f7fd f91e 	bl	c0457e6 <mbedcrypto__psa_hash_compute>
        if( status != PSA_SUCCESS )
 c0485aa:	4604      	mov	r4, r0
 c0485ac:	2800      	cmp	r0, #0
 c0485ae:	d043      	beq.n	c048638 <psa_mac_setup+0x124>
    mbedtls_platform_zeroize( ipad, sizeof( ipad ) );
 c0485b0:	2180      	movs	r1, #128	@ 0x80
 c0485b2:	a804      	add	r0, sp, #16
 c0485b4:	f7f2 ff0c 	bl	c03b3d0 <mbedtls_platform_zeroize>
    return( status );
 c0485b8:	e00b      	b.n	c0485d2 <psa_mac_setup+0xbe>
    ret = mbedtls_cipher_setup( &operation->ctx.cmac, cipher_info );
 c0485ba:	4630      	mov	r0, r6
 c0485bc:	f00c ff18 	bl	c0553f0 <mbedtls_cipher_setup>
    if( ret != 0 )
 c0485c0:	b920      	cbnz	r0, c0485cc <psa_mac_setup+0xb8>
    ret = mbedtls_cipher_cmac_starts( &operation->ctx.cmac,
 c0485c2:	4621      	mov	r1, r4
 c0485c4:	4630      	mov	r0, r6
 c0485c6:	887a      	ldrh	r2, [r7, #2]
 c0485c8:	f00c ffb4 	bl	c055534 <mbedtls_cipher_cmac_starts>
    return( mbedtls_to_psa_error( ret ) );
 c0485cc:	f7fc f978 	bl	c0448c0 <mbedtls_to_psa_error>
 c0485d0:	4604      	mov	r4, r0
    if( status != PSA_SUCCESS )
 c0485d2:	2c00      	cmp	r4, #0
 c0485d4:	d0d1      	beq.n	c04857a <psa_mac_setup+0x66>
 c0485d6:	e7c0      	b.n	c04855a <psa_mac_setup+0x46>
 c0485d8:	f106 437e 	add.w	r3, r6, #4261412864	@ 0xfe000000
 c0485dc:	3b02      	subs	r3, #2
 c0485de:	2b11      	cmp	r3, #17
 c0485e0:	d81e      	bhi.n	c048620 <psa_mac_setup+0x10c>
 c0485e2:	4937      	ldr	r1, [pc, #220]	@ (c0486c0 <psa_mac_setup+0x1ac>)
 c0485e4:	5cc9      	ldrb	r1, [r1, r3]
    size_t block_size = PSA_HASH_BLOCK_LENGTH( hash_alg );
 c0485e6:	2b11      	cmp	r3, #17
 c0485e8:	d81b      	bhi.n	c048622 <psa_mac_setup+0x10e>
 c0485ea:	e8df f003 	tbb	[pc, r3]
 c0485ee:	0e0e      	.short	0x0e0e
 c0485f0:	1a1a0e0e 	.word	0x1a1a0e0e
 c0485f4:	11110e0e 	.word	0x11110e0e
 c0485f8:	1a1a1e1e 	.word	0x1a1a1e1e
 c0485fc:	1c091417 	.word	0x1c091417
    size_t hash_size = PSA_HASH_LENGTH( hash_alg );
 c048600:	2768      	movs	r7, #104	@ 0x68
    if( block_size < hash_size )
 c048602:	428f      	cmp	r7, r1
    hmac->alg = hash_alg;
 c048604:	60ae      	str	r6, [r5, #8]
    if( block_size < hash_size )
 c048606:	d2c5      	bcs.n	c048594 <psa_mac_setup+0x80>
 c048608:	e7a5      	b.n	c048556 <psa_mac_setup+0x42>
    size_t block_size = PSA_HASH_BLOCK_LENGTH( hash_alg );
 c04860a:	2740      	movs	r7, #64	@ 0x40
    hmac->alg = hash_alg;
 c04860c:	60ae      	str	r6, [r5, #8]
 c04860e:	e7c1      	b.n	c048594 <psa_mac_setup+0x80>
    size_t block_size = PSA_HASH_BLOCK_LENGTH( hash_alg );
 c048610:	2780      	movs	r7, #128	@ 0x80
    hmac->alg = hash_alg;
 c048612:	60ae      	str	r6, [r5, #8]
 c048614:	e7be      	b.n	c048594 <psa_mac_setup+0x80>
 c048616:	4b2b      	ldr	r3, [pc, #172]	@ (c0486c4 <psa_mac_setup+0x1b0>)
 c048618:	60ab      	str	r3, [r5, #8]
    if( block_size > sizeof( ipad ) )
 c04861a:	e79c      	b.n	c048556 <psa_mac_setup+0x42>
    hmac->alg = hash_alg;
 c04861c:	4b2a      	ldr	r3, [pc, #168]	@ (c0486c8 <psa_mac_setup+0x1b4>)
 c04861e:	e7fb      	b.n	c048618 <psa_mac_setup+0x104>
    size_t hash_size = PSA_HASH_LENGTH( hash_alg );
 c048620:	4641      	mov	r1, r8
    size_t block_size = PSA_HASH_BLOCK_LENGTH( hash_alg );
 c048622:	2700      	movs	r7, #0
 c048624:	e7ed      	b.n	c048602 <psa_mac_setup+0xee>
    size_t hash_size = PSA_HASH_LENGTH( hash_alg );
 c048626:	2748      	movs	r7, #72	@ 0x48
 c048628:	e7eb      	b.n	c048602 <psa_mac_setup+0xee>
 c04862a:	2780      	movs	r7, #128	@ 0x80
 c04862c:	e7e9      	b.n	c048602 <psa_mac_setup+0xee>
    else if( key_length != 0 )
 c04862e:	b11a      	cbz	r2, c048638 <psa_mac_setup+0x124>
        memcpy( ipad, key, key_length );
 c048630:	4621      	mov	r1, r4
 c048632:	a804      	add	r0, sp, #16
 c048634:	f013 f80a 	bl	c05b64c <memcpy>
 c048638:	f10d 0a10 	add.w	sl, sp, #16
    for( i = 0; i < key_length; i++ )
 c04863c:	4653      	mov	r3, sl
 c04863e:	9c03      	ldr	r4, [sp, #12]
 c048640:	45a0      	cmp	r8, r4
 c048642:	d125      	bne.n	c048690 <psa_mac_setup+0x17c>
    memset( ipad + key_length, 0x36, block_size - key_length );
 c048644:	ab04      	add	r3, sp, #16
 c048646:	eba7 0904 	sub.w	r9, r7, r4
 c04864a:	464a      	mov	r2, r9
 c04864c:	1918      	adds	r0, r3, r4
 c04864e:	2136      	movs	r1, #54	@ 0x36
 c048650:	f013 f86d 	bl	c05b72e <memset>
    for( i = 0; i < key_length; i++ )
 c048654:	f204 1397 	addw	r3, r4, #407	@ 0x197
 c048658:	f205 1297 	addw	r2, r5, #407	@ 0x197
 c04865c:	442b      	add	r3, r5
 c04865e:	429a      	cmp	r2, r3
 c048660:	d11e      	bne.n	c0486a0 <psa_mac_setup+0x18c>
    memset( hmac->opad + key_length, 0x5C, block_size - key_length );
 c048662:	f505 70cc 	add.w	r0, r5, #408	@ 0x198
 c048666:	464a      	mov	r2, r9
 c048668:	215c      	movs	r1, #92	@ 0x5c
 c04866a:	4420      	add	r0, r4
    status = psa_hash_setup( &hmac->hash_ctx, hash_alg );
 c04866c:	f105 0810 	add.w	r8, r5, #16
    memset( hmac->opad + key_length, 0x5C, block_size - key_length );
 c048670:	f013 f85d 	bl	c05b72e <memset>
    status = psa_hash_setup( &hmac->hash_ctx, hash_alg );
 c048674:	4631      	mov	r1, r6
 c048676:	4640      	mov	r0, r8
 c048678:	f7fd f842 	bl	c045700 <mbedcrypto__psa_hash_setup>
    if( status != PSA_SUCCESS )
 c04867c:	4604      	mov	r4, r0
 c04867e:	2800      	cmp	r0, #0
 c048680:	d196      	bne.n	c0485b0 <psa_mac_setup+0x9c>
    status = psa_hash_update( &hmac->hash_ctx, ipad, block_size );
 c048682:	463a      	mov	r2, r7
 c048684:	4640      	mov	r0, r8
 c048686:	a904      	add	r1, sp, #16
 c048688:	f7fd f85a 	bl	c045740 <mbedcrypto__psa_hash_update>
 c04868c:	4604      	mov	r4, r0
 c04868e:	e78f      	b.n	c0485b0 <psa_mac_setup+0x9c>
        ipad[i] ^= 0x36;
 c048690:	781a      	ldrb	r2, [r3, #0]
    for( i = 0; i < key_length; i++ )
 c048692:	f108 0801 	add.w	r8, r8, #1
        ipad[i] ^= 0x36;
 c048696:	f082 0236 	eor.w	r2, r2, #54	@ 0x36
 c04869a:	f803 2b01 	strb.w	r2, [r3], #1
    for( i = 0; i < key_length; i++ )
 c04869e:	e7cf      	b.n	c048640 <psa_mac_setup+0x12c>
        hmac->opad[i] = ipad[i] ^ 0x36 ^ 0x5C;
 c0486a0:	f81a 1b01 	ldrb.w	r1, [sl], #1
 c0486a4:	f081 016a 	eor.w	r1, r1, #106	@ 0x6a
 c0486a8:	f802 1f01 	strb.w	r1, [r2, #1]!
    for( i = 0; i < key_length; i++ )
 c0486ac:	e7d7      	b.n	c04865e <psa_mac_setup+0x14a>
        return( PSA_ERROR_BAD_STATE );
 c0486ae:	f06f 0488 	mvn.w	r4, #136	@ 0x88
 c0486b2:	e762      	b.n	c04857a <psa_mac_setup+0x66>
 c0486b4:	03c00200 	.word	0x03c00200
 c0486b8:	7fc00000 	.word	0x7fc00000
 c0486bc:	02000001 	.word	0x02000001
 c0486c0:	0c060ea6 	.word	0x0c060ea6
 c0486c4:	02000011 	.word	0x02000011
 c0486c8:	02000010 	.word	0x02000010

0c0486cc <mbedtls_psa_mac_sign_setup>:
    return( psa_mac_setup( operation, attributes,
 c0486cc:	f7ff bf22 	b.w	c048514 <psa_mac_setup>

0c0486d0 <mbedtls_psa_mac_verify_setup>:
psa_status_t mbedtls_psa_mac_verify_setup(
 c0486d0:	f7ff bf20 	b.w	c048514 <psa_mac_setup>

0c0486d4 <mbedtls_psa_mac_update>:
{
 c0486d4:	b538      	push	{r3, r4, r5, lr}
    if( operation->alg == 0 )
 c0486d6:	6804      	ldr	r4, [r0, #0]
 c0486d8:	b1ac      	cbz	r4, c048706 <mbedtls_psa_mac_update+0x32>
    if( PSA_ALG_FULL_LENGTH_MAC( operation->alg ) == PSA_ALG_CMAC )
 c0486da:	4b0c      	ldr	r3, [pc, #48]	@ (c04870c <mbedtls_psa_mac_update+0x38>)
 c0486dc:	f424 157e 	bic.w	r5, r4, #4161536	@ 0x3f8000
 c0486e0:	429d      	cmp	r5, r3
 c0486e2:	d106      	bne.n	c0486f2 <mbedtls_psa_mac_update+0x1e>
        return( mbedtls_to_psa_error(
 c0486e4:	3008      	adds	r0, #8
 c0486e6:	f00c ff4b 	bl	c055580 <mbedtls_cipher_cmac_update>
}
 c0486ea:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
        return( mbedtls_to_psa_error(
 c0486ee:	f7fc b8e7 	b.w	c0448c0 <mbedtls_to_psa_error>
    if( PSA_ALG_IS_HMAC( operation->alg ) )
 c0486f2:	4b07      	ldr	r3, [pc, #28]	@ (c048710 <mbedtls_psa_mac_update+0x3c>)
 c0486f4:	4023      	ands	r3, r4
 c0486f6:	f1b3 7f60 	cmp.w	r3, #58720256	@ 0x3800000
 c0486fa:	d104      	bne.n	c048706 <mbedtls_psa_mac_update+0x32>
}
 c0486fc:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    return( psa_hash_update( &hmac->hash_ctx, data, data_length ) );
 c048700:	3010      	adds	r0, #16
 c048702:	f7fd b81d 	b.w	c045740 <mbedcrypto__psa_hash_update>
}
 c048706:	f06f 0088 	mvn.w	r0, #136	@ 0x88
 c04870a:	bd38      	pop	{r3, r4, r5, pc}
 c04870c:	03c00200 	.word	0x03c00200
 c048710:	7fc00000 	.word	0x7fc00000

0c048714 <mbedtls_psa_mac_sign_finish>:
psa_status_t mbedtls_psa_mac_sign_finish(
    mbedtls_psa_mac_operation_t *operation,
    uint8_t *mac,
    size_t mac_size,
    size_t *mac_length )
{
 c048714:	b538      	push	{r3, r4, r5, lr}
 c048716:	461c      	mov	r4, r3
    psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;

    if( operation->alg == 0 )
 c048718:	6803      	ldr	r3, [r0, #0]
{
 c04871a:	4615      	mov	r5, r2
    if( operation->alg == 0 )
 c04871c:	b123      	cbz	r3, c048728 <mbedtls_psa_mac_sign_finish+0x14>
        return( PSA_ERROR_BAD_STATE );

    status = psa_mac_finish_internal( operation, mac, mac_size );
 c04871e:	f7ff fe4f 	bl	c0483c0 <psa_mac_finish_internal>
    if( status == PSA_SUCCESS )
 c048722:	b900      	cbnz	r0, c048726 <mbedtls_psa_mac_sign_finish+0x12>
        *mac_length = mac_size;
 c048724:	6025      	str	r5, [r4, #0]

    return( status );
}
 c048726:	bd38      	pop	{r3, r4, r5, pc}
        return( PSA_ERROR_BAD_STATE );
 c048728:	f06f 0088 	mvn.w	r0, #136	@ 0x88
 c04872c:	e7fb      	b.n	c048726 <mbedtls_psa_mac_sign_finish+0x12>

0c04872e <mbedtls_psa_mac_verify_finish>:

psa_status_t mbedtls_psa_mac_verify_finish(
    mbedtls_psa_mac_operation_t *operation,
    const uint8_t *mac,
    size_t mac_length )
{
 c04872e:	b570      	push	{r4, r5, r6, lr}
    uint8_t actual_mac[PSA_MAC_MAX_SIZE];
    psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;

    if( operation->alg == 0 )
 c048730:	6803      	ldr	r3, [r0, #0]
{
 c048732:	460d      	mov	r5, r1
 c048734:	4616      	mov	r6, r2
 c048736:	b090      	sub	sp, #64	@ 0x40
    if( operation->alg == 0 )
 c048738:	b1f3      	cbz	r3, c048778 <mbedtls_psa_mac_verify_finish+0x4a>
        return( PSA_ERROR_BAD_STATE );

    /* Consistency check: requested MAC length fits our local buffer */
    if( mac_length > sizeof( actual_mac ) )
 c04873a:	2a40      	cmp	r2, #64	@ 0x40
 c04873c:	d81f      	bhi.n	c04877e <mbedtls_psa_mac_verify_finish+0x50>
        return( PSA_ERROR_INVALID_ARGUMENT );

    status = psa_mac_finish_internal( operation, actual_mac, mac_length );
 c04873e:	4669      	mov	r1, sp
 c048740:	f7ff fe3e 	bl	c0483c0 <psa_mac_finish_internal>
    if( status != PSA_SUCCESS )
 c048744:	4604      	mov	r4, r0
 c048746:	b948      	cbnz	r0, c04875c <mbedtls_psa_mac_verify_finish+0x2e>
 c048748:	4629      	mov	r1, r5
 c04874a:	4668      	mov	r0, sp
    unsigned char diff = 0;
 c04874c:	4623      	mov	r3, r4
 c04874e:	442e      	add	r6, r5
    for( i = 0; i < n; i++ )
 c048750:	42b1      	cmp	r1, r6
 c048752:	d10a      	bne.n	c04876a <mbedtls_psa_mac_verify_finish+0x3c>
        goto cleanup;

    if( mbedtls_psa_safer_memcmp( mac, actual_mac, mac_length ) != 0 )
        status = PSA_ERROR_INVALID_SIGNATURE;
 c048754:	2b00      	cmp	r3, #0
 c048756:	bf18      	it	ne
 c048758:	f06f 0494 	mvnne.w	r4, #148	@ 0x94

cleanup:
    mbedtls_platform_zeroize( actual_mac, sizeof( actual_mac ) );
 c04875c:	2140      	movs	r1, #64	@ 0x40
 c04875e:	4668      	mov	r0, sp
 c048760:	f7f2 fe36 	bl	c03b3d0 <mbedtls_platform_zeroize>

    return( status );
}
 c048764:	4620      	mov	r0, r4
 c048766:	b010      	add	sp, #64	@ 0x40
 c048768:	bd70      	pop	{r4, r5, r6, pc}
        diff |= a[i] ^ b[i];
 c04876a:	f811 2b01 	ldrb.w	r2, [r1], #1
 c04876e:	f810 5b01 	ldrb.w	r5, [r0], #1
 c048772:	406a      	eors	r2, r5
 c048774:	4313      	orrs	r3, r2
    for( i = 0; i < n; i++ )
 c048776:	e7eb      	b.n	c048750 <mbedtls_psa_mac_verify_finish+0x22>
        return( PSA_ERROR_BAD_STATE );
 c048778:	f06f 0488 	mvn.w	r4, #136	@ 0x88
 c04877c:	e7f2      	b.n	c048764 <mbedtls_psa_mac_verify_finish+0x36>
        return( PSA_ERROR_INVALID_ARGUMENT );
 c04877e:	f06f 0486 	mvn.w	r4, #134	@ 0x86
 c048782:	e7ef      	b.n	c048764 <mbedtls_psa_mac_verify_finish+0x36>

0c048784 <psa_rsa_decode_md_type>:
/* Decode the hash algorithm from alg and store the mbedtls encoding in
 * md_alg. Verify that the hash length is acceptable. */
static psa_status_t psa_rsa_decode_md_type( psa_algorithm_t alg,
                                            size_t hash_length,
                                            mbedtls_md_type_t *md_alg )
{
 c048784:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 c048786:	4617      	mov	r7, r2
    psa_algorithm_t hash_alg = PSA_ALG_SIGN_GET_HASH( alg );
 c048788:	f420 73ff 	bic.w	r3, r0, #510	@ 0x1fe
 c04878c:	4a19      	ldr	r2, [pc, #100]	@ (c0487f4 <psa_rsa_decode_md_type+0x70>)
 c04878e:	f023 0301 	bic.w	r3, r3, #1
 c048792:	4293      	cmp	r3, r2
{
 c048794:	4604      	mov	r4, r0
 c048796:	460e      	mov	r6, r1
    psa_algorithm_t hash_alg = PSA_ALG_SIGN_GET_HASH( alg );
 c048798:	d00e      	beq.n	c0487b8 <psa_rsa_decode_md_type+0x34>
 c04879a:	4b17      	ldr	r3, [pc, #92]	@ (c0487f8 <psa_rsa_decode_md_type+0x74>)
 c04879c:	f020 02ff 	bic.w	r2, r0, #255	@ 0xff
 c0487a0:	429a      	cmp	r2, r3
 c0487a2:	d009      	beq.n	c0487b8 <psa_rsa_decode_md_type+0x34>
 c0487a4:	4915      	ldr	r1, [pc, #84]	@ (c0487fc <psa_rsa_decode_md_type+0x78>)
 c0487a6:	f420 737f 	bic.w	r3, r0, #1020	@ 0x3fc
 c0487aa:	f023 0303 	bic.w	r3, r3, #3
 c0487ae:	428b      	cmp	r3, r1
 c0487b0:	d002      	beq.n	c0487b8 <psa_rsa_decode_md_type+0x34>
 c0487b2:	4b13      	ldr	r3, [pc, #76]	@ (c048800 <psa_rsa_decode_md_type+0x7c>)
 c0487b4:	429a      	cmp	r2, r3
 c0487b6:	d115      	bne.n	c0487e4 <psa_rsa_decode_md_type+0x60>
 c0487b8:	f014 00ff 	ands.w	r0, r4, #255	@ 0xff
 c0487bc:	d001      	beq.n	c0487c2 <psa_rsa_decode_md_type+0x3e>
 c0487be:	f040 7000 	orr.w	r0, r0, #33554432	@ 0x2000000
    const mbedtls_md_info_t *md_info = mbedtls_md_info_from_psa( hash_alg );
 c0487c2:	f7ff fcc5 	bl	c048150 <mbedtls_md_info_from_psa>
 c0487c6:	4605      	mov	r5, r0
    *md_alg = mbedtls_md_get_type( md_info );
 c0487c8:	f00e f951 	bl	c056a6e <mbedtls_md_get_type>
    if( hash_length > UINT_MAX )
        return( PSA_ERROR_INVALID_ARGUMENT );
#endif

    /* For signatures using a hash, the hash length must be correct. */
    if( alg != PSA_ALG_RSA_PKCS1V15_SIGN_RAW )
 c0487cc:	4b09      	ldr	r3, [pc, #36]	@ (c0487f4 <psa_rsa_decode_md_type+0x70>)
    *md_alg = mbedtls_md_get_type( md_info );
 c0487ce:	7038      	strb	r0, [r7, #0]
    if( alg != PSA_ALG_RSA_PKCS1V15_SIGN_RAW )
 c0487d0:	429c      	cmp	r4, r3
 c0487d2:	d005      	beq.n	c0487e0 <psa_rsa_decode_md_type+0x5c>
    {
        if( md_info == NULL )
 c0487d4:	b145      	cbz	r5, c0487e8 <psa_rsa_decode_md_type+0x64>
            return( PSA_ERROR_NOT_SUPPORTED );
        if( mbedtls_md_get_size( md_info ) != hash_length )
 c0487d6:	4628      	mov	r0, r5
 c0487d8:	f00e f946 	bl	c056a68 <mbedtls_md_get_size>
 c0487dc:	42b0      	cmp	r0, r6
 c0487de:	d106      	bne.n	c0487ee <psa_rsa_decode_md_type+0x6a>
            return( PSA_ERROR_INVALID_ARGUMENT );
    }

    return( PSA_SUCCESS );
 c0487e0:	2000      	movs	r0, #0
}
 c0487e2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    psa_algorithm_t hash_alg = PSA_ALG_SIGN_GET_HASH( alg );
 c0487e4:	2000      	movs	r0, #0
 c0487e6:	e7ec      	b.n	c0487c2 <psa_rsa_decode_md_type+0x3e>
            return( PSA_ERROR_NOT_SUPPORTED );
 c0487e8:	f06f 0085 	mvn.w	r0, #133	@ 0x85
 c0487ec:	e7f9      	b.n	c0487e2 <psa_rsa_decode_md_type+0x5e>
            return( PSA_ERROR_INVALID_ARGUMENT );
 c0487ee:	f06f 0086 	mvn.w	r0, #134	@ 0x86
 c0487f2:	e7f6      	b.n	c0487e2 <psa_rsa_decode_md_type+0x5e>
 c0487f4:	06000200 	.word	0x06000200
 c0487f8:	06001300 	.word	0x06001300
 c0487fc:	06000400 	.word	0x06000400
 c048800:	06000900 	.word	0x06000900

0c048804 <mbedtls_psa_rsa_load_representation>:
{
 c048804:	b5f0      	push	{r4, r5, r6, r7, lr}
 c048806:	4604      	mov	r4, r0
 c048808:	b089      	sub	sp, #36	@ 0x24
    mbedtls_pk_init( &ctx );
 c04880a:	a803      	add	r0, sp, #12
    if( PSA_KEY_TYPE_IS_KEY_PAIR( type ) )
 c04880c:	f404 44e0 	and.w	r4, r4, #28672	@ 0x7000
{
 c048810:	460d      	mov	r5, r1
 c048812:	4617      	mov	r7, r2
 c048814:	461e      	mov	r6, r3
    mbedtls_pk_init( &ctx );
 c048816:	f00e faeb 	bl	c056df0 <mbedtls_pk_init>
    if( PSA_KEY_TYPE_IS_KEY_PAIR( type ) )
 c04881a:	f5b4 4fe0 	cmp.w	r4, #28672	@ 0x7000
 c04881e:	d13b      	bne.n	c048898 <mbedtls_psa_rsa_load_representation+0x94>
        status = mbedtls_to_psa_error(
 c048820:	2300      	movs	r3, #0
 c048822:	463a      	mov	r2, r7
 c048824:	4629      	mov	r1, r5
 c048826:	9300      	str	r3, [sp, #0]
 c048828:	a803      	add	r0, sp, #12
 c04882a:	f00e ff3b 	bl	c0576a4 <mbedtls_pk_parse_key>
        status = mbedtls_to_psa_error(
 c04882e:	f7fc f847 	bl	c0448c0 <mbedtls_to_psa_error>
 c048832:	4604      	mov	r4, r0
    if( status != PSA_SUCCESS )
 c048834:	bb50      	cbnz	r0, c04888c <mbedtls_psa_rsa_load_representation+0x88>
    if( mbedtls_pk_get_type( &ctx ) != MBEDTLS_PK_RSA )
 c048836:	a803      	add	r0, sp, #12
 c048838:	f00e fb10 	bl	c056e5c <mbedtls_pk_get_type>
 c04883c:	2801      	cmp	r0, #1
 c04883e:	d131      	bne.n	c0488a4 <mbedtls_psa_rsa_load_representation+0xa0>
    bits = PSA_BYTES_TO_BITS( mbedtls_rsa_get_len( mbedtls_pk_rsa( ctx ) ) );
 c048840:	9804      	ldr	r0, [sp, #16]
 c048842:	f006 ff15 	bl	c04f670 <mbedtls_rsa_get_len>
 c048846:	00c0      	lsls	r0, r0, #3
    if( bits > PSA_VENDOR_RSA_MAX_KEY_BITS )
 c048848:	f5b0 5f80 	cmp.w	r0, #4096	@ 0x1000
 c04884c:	d82d      	bhi.n	c0488aa <mbedtls_psa_rsa_load_representation+0xa6>
    status = psa_check_rsa_key_byte_aligned( mbedtls_pk_rsa( ctx ) );
 c04884e:	9d04      	ldr	r5, [sp, #16]
    mbedtls_mpi_init( &n );
 c048850:	a805      	add	r0, sp, #20
 c048852:	f00a fd50 	bl	c0532f6 <mbedtls_mpi_init>
    status = mbedtls_to_psa_error(
 c048856:	4623      	mov	r3, r4
 c048858:	4622      	mov	r2, r4
 c04885a:	e9cd 4400 	strd	r4, r4, [sp]
 c04885e:	a905      	add	r1, sp, #20
 c048860:	4628      	mov	r0, r5
 c048862:	f006 fe41 	bl	c04f4e8 <mbedtls_rsa_export>
 c048866:	f7fc f82b 	bl	c0448c0 <mbedtls_to_psa_error>
    if( status == PSA_SUCCESS )
 c04886a:	4604      	mov	r4, r0
 c04886c:	b938      	cbnz	r0, c04887e <mbedtls_psa_rsa_load_representation+0x7a>
        if( mbedtls_mpi_bitlen( &n ) % 8 != 0 )
 c04886e:	a805      	add	r0, sp, #20
 c048870:	f00a fe55 	bl	c05351e <mbedtls_mpi_bitlen>
            status = PSA_ERROR_NOT_SUPPORTED;
 c048874:	f010 0f07 	tst.w	r0, #7
 c048878:	bf18      	it	ne
 c04887a:	f06f 0485 	mvnne.w	r4, #133	@ 0x85
    mbedtls_mpi_free( &n );
 c04887e:	a805      	add	r0, sp, #20
 c048880:	f00a fd3f 	bl	c053302 <mbedtls_mpi_free>
    if( status != PSA_SUCCESS )
 c048884:	b914      	cbnz	r4, c04888c <mbedtls_psa_rsa_load_representation+0x88>
    *p_rsa = mbedtls_pk_rsa( ctx );
 c048886:	9b04      	ldr	r3, [sp, #16]
    ctx.pk_info = NULL;
 c048888:	9403      	str	r4, [sp, #12]
    *p_rsa = mbedtls_pk_rsa( ctx );
 c04888a:	6033      	str	r3, [r6, #0]
    mbedtls_pk_free( &ctx );
 c04888c:	a803      	add	r0, sp, #12
 c04888e:	f00e fab3 	bl	c056df8 <mbedtls_pk_free>
}
 c048892:	4620      	mov	r0, r4
 c048894:	b009      	add	sp, #36	@ 0x24
 c048896:	bdf0      	pop	{r4, r5, r6, r7, pc}
        status = mbedtls_to_psa_error(
 c048898:	463a      	mov	r2, r7
 c04889a:	4629      	mov	r1, r5
 c04889c:	a803      	add	r0, sp, #12
 c04889e:	f00e ff97 	bl	c0577d0 <mbedtls_pk_parse_public_key>
 c0488a2:	e7c4      	b.n	c04882e <mbedtls_psa_rsa_load_representation+0x2a>
        status = PSA_ERROR_INVALID_ARGUMENT;
 c0488a4:	f06f 0486 	mvn.w	r4, #134	@ 0x86
 c0488a8:	e7f0      	b.n	c04888c <mbedtls_psa_rsa_load_representation+0x88>
        status = PSA_ERROR_NOT_SUPPORTED;
 c0488aa:	f06f 0485 	mvn.w	r4, #133	@ 0x85
 c0488ae:	e7ed      	b.n	c04888c <mbedtls_psa_rsa_load_representation+0x88>

0c0488b0 <mbedtls_psa_rsa_export_key>:
{
 c0488b0:	b5f0      	push	{r4, r5, r6, r7, lr}
 c0488b2:	4605      	mov	r5, r0
 c0488b4:	460f      	mov	r7, r1
 c0488b6:	b085      	sub	sp, #20
 c0488b8:	461c      	mov	r4, r3
    mbedtls_pk_init( &pk );
 c0488ba:	a802      	add	r0, sp, #8
    uint8_t *pos = data + data_size;
 c0488bc:	18d3      	adds	r3, r2, r3
 c0488be:	9301      	str	r3, [sp, #4]
{
 c0488c0:	4616      	mov	r6, r2
    if( PSA_KEY_TYPE_IS_KEY_PAIR( type ) )
 c0488c2:	f405 45e0 	and.w	r5, r5, #28672	@ 0x7000
    mbedtls_pk_init( &pk );
 c0488c6:	f00e fa93 	bl	c056df0 <mbedtls_pk_init>
    pk.pk_info = &mbedtls_rsa_info;
 c0488ca:	4b1e      	ldr	r3, [pc, #120]	@ (c048944 <mbedtls_psa_rsa_export_key+0x94>)
    if( PSA_KEY_TYPE_IS_KEY_PAIR( type ) )
 c0488cc:	f5b5 4fe0 	cmp.w	r5, #28672	@ 0x7000
    pk.pk_ctx = rsa;
 c0488d0:	e9cd 3702 	strd	r3, r7, [sp, #8]
    if( PSA_KEY_TYPE_IS_KEY_PAIR( type ) )
 c0488d4:	d111      	bne.n	c0488fa <mbedtls_psa_rsa_export_key+0x4a>
        ret = mbedtls_pk_write_key_der( &pk, data, data_size );
 c0488d6:	4622      	mov	r2, r4
 c0488d8:	4631      	mov	r1, r6
 c0488da:	a802      	add	r0, sp, #8
 c0488dc:	f00f f844 	bl	c057968 <mbedtls_pk_write_key_der>
    if( ret < 0 )
 c0488e0:	2800      	cmp	r0, #0
        ret = mbedtls_pk_write_pubkey( &pos, data, &pk );
 c0488e2:	4605      	mov	r5, r0
    if( ret < 0 )
 c0488e4:	da0f      	bge.n	c048906 <mbedtls_psa_rsa_export_key+0x56>
        memset( data, 0, data_size );
 c0488e6:	4622      	mov	r2, r4
 c0488e8:	2100      	movs	r1, #0
 c0488ea:	4630      	mov	r0, r6
 c0488ec:	f012 ff1f 	bl	c05b72e <memset>
        return( mbedtls_to_psa_error( ret ) );
 c0488f0:	4628      	mov	r0, r5
 c0488f2:	f7fb ffe5 	bl	c0448c0 <mbedtls_to_psa_error>
}
 c0488f6:	b005      	add	sp, #20
 c0488f8:	bdf0      	pop	{r4, r5, r6, r7, pc}
        ret = mbedtls_pk_write_pubkey( &pos, data, &pk );
 c0488fa:	4631      	mov	r1, r6
 c0488fc:	aa02      	add	r2, sp, #8
 c0488fe:	a801      	add	r0, sp, #4
 c048900:	f00e ffcc 	bl	c05789c <mbedtls_pk_write_pubkey>
 c048904:	e7ec      	b.n	c0488e0 <mbedtls_psa_rsa_export_key+0x30>
    if( 2 * (size_t) ret <= data_size )
 c048906:	ebb4 0f40 	cmp.w	r4, r0, lsl #1
 c04890a:	d30f      	bcc.n	c04892c <mbedtls_psa_rsa_export_key+0x7c>
        memcpy( data, data + data_size - ret, ret );
 c04890c:	1a24      	subs	r4, r4, r0
 c04890e:	4434      	add	r4, r6
 c048910:	4602      	mov	r2, r0
 c048912:	4621      	mov	r1, r4
 c048914:	4630      	mov	r0, r6
 c048916:	f012 fe99 	bl	c05b64c <memcpy>
        memset( data + data_size - ret, 0, ret );
 c04891a:	462a      	mov	r2, r5
 c04891c:	2100      	movs	r1, #0
 c04891e:	4620      	mov	r0, r4
        memset( data + ret, 0, data_size - ret );
 c048920:	f012 ff05 	bl	c05b72e <memset>
    *data_length = ret;
 c048924:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
    return( PSA_SUCCESS );
 c048926:	2000      	movs	r0, #0
    *data_length = ret;
 c048928:	601d      	str	r5, [r3, #0]
    return( PSA_SUCCESS );
 c04892a:	e7e4      	b.n	c0488f6 <mbedtls_psa_rsa_export_key+0x46>
    else if( (size_t) ret < data_size )
 c04892c:	42a0      	cmp	r0, r4
 c04892e:	d2f9      	bcs.n	c048924 <mbedtls_psa_rsa_export_key+0x74>
        memmove( data, data + data_size - ret, ret );
 c048930:	1a24      	subs	r4, r4, r0
 c048932:	4602      	mov	r2, r0
 c048934:	1931      	adds	r1, r6, r4
 c048936:	4630      	mov	r0, r6
 c048938:	f012 feb9 	bl	c05b6ae <memmove>
        memset( data + ret, 0, data_size - ret );
 c04893c:	4622      	mov	r2, r4
 c04893e:	2100      	movs	r1, #0
 c048940:	1970      	adds	r0, r6, r5
 c048942:	e7ed      	b.n	c048920 <mbedtls_psa_rsa_export_key+0x70>
 c048944:	0c060e28 	.word	0x0c060e28

0c048948 <mbedtls_psa_rsa_import_key>:
{
 c048948:	b5f0      	push	{r4, r5, r6, r7, lr}
 c04894a:	461e      	mov	r6, r3
    mbedtls_rsa_context *rsa = NULL;
 c04894c:	2300      	movs	r3, #0
{
 c04894e:	b085      	sub	sp, #20
    mbedtls_rsa_context *rsa = NULL;
 c048950:	9303      	str	r3, [sp, #12]
{
 c048952:	4605      	mov	r5, r0
    status = mbedtls_psa_rsa_load_representation( attributes->core.type,
 c048954:	ab03      	add	r3, sp, #12
 c048956:	8800      	ldrh	r0, [r0, #0]
 c048958:	f7ff ff54 	bl	c048804 <mbedtls_psa_rsa_load_representation>
    if( status != PSA_SUCCESS )
 c04895c:	4604      	mov	r4, r0
 c04895e:	b980      	cbnz	r0, c048982 <mbedtls_psa_rsa_import_key+0x3a>
    *bits = (psa_key_bits_t) PSA_BYTES_TO_BITS( mbedtls_rsa_get_len( rsa ) );
 c048960:	9f03      	ldr	r7, [sp, #12]
 c048962:	4638      	mov	r0, r7
 c048964:	f006 fe84 	bl	c04f670 <mbedtls_rsa_get_len>
 c048968:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
 c04896a:	00c4      	lsls	r4, r0, #3
 c04896c:	b2a4      	uxth	r4, r4
 c04896e:	601c      	str	r4, [r3, #0]
    status = mbedtls_psa_rsa_export_key( attributes->core.type,
 c048970:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 c048972:	4632      	mov	r2, r6
 c048974:	9300      	str	r3, [sp, #0]
 c048976:	4639      	mov	r1, r7
 c048978:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 c04897a:	8828      	ldrh	r0, [r5, #0]
 c04897c:	f7ff ff98 	bl	c0488b0 <mbedtls_psa_rsa_export_key>
 c048980:	4604      	mov	r4, r0
    mbedtls_rsa_free( rsa );
 c048982:	9d03      	ldr	r5, [sp, #12]
 c048984:	4628      	mov	r0, r5
 c048986:	f007 febf 	bl	c050708 <mbedtls_rsa_free>
    mbedtls_free( rsa );
 c04898a:	4628      	mov	r0, r5
 c04898c:	f7f2 fd10 	bl	c03b3b0 <mbedtls_free>
}
 c048990:	4620      	mov	r0, r4
 c048992:	b005      	add	sp, #20
 c048994:	bdf0      	pop	{r4, r5, r6, r7, pc}

0c048996 <mbedtls_psa_rsa_export_public_key>:
{
 c048996:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
 c048998:	461e      	mov	r6, r3
    mbedtls_rsa_context *rsa = NULL;
 c04899a:	2300      	movs	r3, #0
    status = mbedtls_psa_rsa_load_representation(
 c04899c:	8800      	ldrh	r0, [r0, #0]
    mbedtls_rsa_context *rsa = NULL;
 c04899e:	9303      	str	r3, [sp, #12]
    status = mbedtls_psa_rsa_load_representation(
 c0489a0:	ab03      	add	r3, sp, #12
 c0489a2:	f7ff ff2f 	bl	c048804 <mbedtls_psa_rsa_load_representation>
    if( status != PSA_SUCCESS )
 c0489a6:	4604      	mov	r4, r0
 c0489a8:	b980      	cbnz	r0, c0489cc <mbedtls_psa_rsa_export_public_key+0x36>
    status = mbedtls_psa_rsa_export_key( PSA_KEY_TYPE_RSA_PUBLIC_KEY,
 c0489aa:	9d03      	ldr	r5, [sp, #12]
 c0489ac:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 c0489ae:	4632      	mov	r2, r6
 c0489b0:	4629      	mov	r1, r5
 c0489b2:	9300      	str	r3, [sp, #0]
 c0489b4:	f244 0001 	movw	r0, #16385	@ 0x4001
 c0489b8:	9b08      	ldr	r3, [sp, #32]
 c0489ba:	f7ff ff79 	bl	c0488b0 <mbedtls_psa_rsa_export_key>
 c0489be:	4604      	mov	r4, r0
    mbedtls_rsa_free( rsa );
 c0489c0:	4628      	mov	r0, r5
 c0489c2:	f007 fea1 	bl	c050708 <mbedtls_rsa_free>
    mbedtls_free( rsa );
 c0489c6:	4628      	mov	r0, r5
 c0489c8:	f7f2 fcf2 	bl	c03b3b0 <mbedtls_free>
}
 c0489cc:	4620      	mov	r0, r4
 c0489ce:	b004      	add	sp, #16
 c0489d0:	bd70      	pop	{r4, r5, r6, pc}
	...

0c0489d4 <mbedtls_psa_rsa_generate_key>:
{
 c0489d4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 c0489d8:	4605      	mov	r5, r0
 c0489da:	4698      	mov	r8, r3
                                    attributes->domain_parameters_size,
 c0489dc:	e9d0 030a 	ldrd	r0, r3, [r0, #40]	@ 0x28
{
 c0489e0:	460e      	mov	r6, r1
 c0489e2:	4617      	mov	r7, r2
 c0489e4:	b0b0      	sub	sp, #192	@ 0xc0
    if( domain_parameters_size == 0 )
 c0489e6:	b173      	cbz	r3, c048a06 <mbedtls_psa_rsa_generate_key+0x32>
    if( domain_parameters_size > sizeof( acc ) )
 c0489e8:	2b04      	cmp	r3, #4
 c0489ea:	d809      	bhi.n	c048a00 <mbedtls_psa_rsa_generate_key+0x2c>
    uint32_t acc = 0;
 c0489ec:	2400      	movs	r4, #0
 c0489ee:	4403      	add	r3, r0
        acc = ( acc << 8 ) | domain_parameters[i];
 c0489f0:	f810 2b01 	ldrb.w	r2, [r0], #1
    for( i = 0; i < domain_parameters_size; i++ )
 c0489f4:	4283      	cmp	r3, r0
        acc = ( acc << 8 ) | domain_parameters[i];
 c0489f6:	ea42 2404 	orr.w	r4, r2, r4, lsl #8
    for( i = 0; i < domain_parameters_size; i++ )
 c0489fa:	d1f9      	bne.n	c0489f0 <mbedtls_psa_rsa_generate_key+0x1c>
    if( acc > INT_MAX )
 c0489fc:	2c00      	cmp	r4, #0
 c0489fe:	da04      	bge.n	c048a0a <mbedtls_psa_rsa_generate_key+0x36>
        return( PSA_ERROR_NOT_SUPPORTED );
 c048a00:	f06f 0485 	mvn.w	r4, #133	@ 0x85
 c048a04:	e012      	b.n	c048a2c <mbedtls_psa_rsa_generate_key+0x58>
        *exponent = 65537;
 c048a06:	f04f 1401 	mov.w	r4, #65537	@ 0x10001
    mbedtls_rsa_init( &rsa, MBEDTLS_RSA_PKCS_V15, MBEDTLS_MD_NONE );
 c048a0a:	2200      	movs	r2, #0
 c048a0c:	a802      	add	r0, sp, #8
 c048a0e:	4611      	mov	r1, r2
 c048a10:	f006 fe20 	bl	c04f654 <mbedtls_rsa_init>
    ret = mbedtls_rsa_gen_key( &rsa,
 c048a14:	4a0e      	ldr	r2, [pc, #56]	@ (c048a50 <mbedtls_psa_rsa_generate_key+0x7c>)
 c048a16:	9400      	str	r4, [sp, #0]
 c048a18:	886b      	ldrh	r3, [r5, #2]
 c048a1a:	6812      	ldr	r2, [r2, #0]
 c048a1c:	490d      	ldr	r1, [pc, #52]	@ (c048a54 <mbedtls_psa_rsa_generate_key+0x80>)
 c048a1e:	a802      	add	r0, sp, #8
 c048a20:	f007 feb0 	bl	c050784 <mbedtls_rsa_gen_key>
    if( ret != 0 )
 c048a24:	b130      	cbz	r0, c048a34 <mbedtls_psa_rsa_generate_key+0x60>
        return( mbedtls_to_psa_error( ret ) );
 c048a26:	f7fb ff4b 	bl	c0448c0 <mbedtls_to_psa_error>
 c048a2a:	4604      	mov	r4, r0
}
 c048a2c:	4620      	mov	r0, r4
 c048a2e:	b030      	add	sp, #192	@ 0xc0
 c048a30:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    status = mbedtls_psa_rsa_export_key( attributes->core.type,
 c048a34:	f8cd 8000 	str.w	r8, [sp]
 c048a38:	463b      	mov	r3, r7
 c048a3a:	4632      	mov	r2, r6
 c048a3c:	8828      	ldrh	r0, [r5, #0]
 c048a3e:	a902      	add	r1, sp, #8
 c048a40:	f7ff ff36 	bl	c0488b0 <mbedtls_psa_rsa_export_key>
 c048a44:	4604      	mov	r4, r0
    mbedtls_rsa_free( &rsa );
 c048a46:	a802      	add	r0, sp, #8
 c048a48:	f007 fe5e 	bl	c050708 <mbedtls_rsa_free>
    return( status );
 c048a4c:	e7ee      	b.n	c048a2c <mbedtls_psa_rsa_generate_key+0x58>
 c048a4e:	bf00      	nop
 c048a50:	0c060e6c 	.word	0x0c060e6c
 c048a54:	0c055d65 	.word	0x0c055d65

0c048a58 <mbedtls_psa_rsa_sign_hash>:
psa_status_t mbedtls_psa_rsa_sign_hash(
    const psa_key_attributes_t *attributes,
    const uint8_t *key_buffer, size_t key_buffer_size,
    psa_algorithm_t alg, const uint8_t *hash, size_t hash_length,
    uint8_t *signature, size_t signature_size, size_t *signature_length )
{
 c048a58:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 c048a5c:	461d      	mov	r5, r3
    psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
    mbedtls_rsa_context *rsa = NULL;
 c048a5e:	2300      	movs	r3, #0
{
 c048a60:	b087      	sub	sp, #28
    mbedtls_rsa_context *rsa = NULL;
 c048a62:	9305      	str	r3, [sp, #20]
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    mbedtls_md_type_t md_alg;

    status = mbedtls_psa_rsa_load_representation( attributes->core.type,
 c048a64:	8800      	ldrh	r0, [r0, #0]
 c048a66:	ab05      	add	r3, sp, #20
{
 c048a68:	f8dd 9040 	ldr.w	r9, [sp, #64]	@ 0x40
 c048a6c:	e9dd 870e 	ldrd	r8, r7, [sp, #56]	@ 0x38
    status = mbedtls_psa_rsa_load_representation( attributes->core.type,
 c048a70:	f7ff fec8 	bl	c048804 <mbedtls_psa_rsa_load_representation>
                                                  key_buffer,
                                                  key_buffer_size,
                                                  &rsa );
    if( status != PSA_SUCCESS )
 c048a74:	4604      	mov	r4, r0
 c048a76:	2800      	cmp	r0, #0
 c048a78:	d136      	bne.n	c048ae8 <mbedtls_psa_rsa_sign_hash+0x90>
        return( status );

    status = psa_rsa_decode_md_type( alg, hash_length, &md_alg );
 c048a7a:	4639      	mov	r1, r7
 c048a7c:	4628      	mov	r0, r5
 c048a7e:	f10d 0213 	add.w	r2, sp, #19
 c048a82:	f7ff fe7f 	bl	c048784 <psa_rsa_decode_md_type>
    if( status != PSA_SUCCESS )
        goto exit;

    if( signature_size < mbedtls_rsa_get_len( rsa ) )
 c048a86:	9e05      	ldr	r6, [sp, #20]
    if( status != PSA_SUCCESS )
 c048a88:	4604      	mov	r4, r0
 c048a8a:	bb38      	cbnz	r0, c048adc <mbedtls_psa_rsa_sign_hash+0x84>
    if( signature_size < mbedtls_rsa_get_len( rsa ) )
 c048a8c:	4630      	mov	r0, r6
 c048a8e:	f006 fdef 	bl	c04f670 <mbedtls_rsa_get_len>
 c048a92:	9b11      	ldr	r3, [sp, #68]	@ 0x44
 c048a94:	4298      	cmp	r0, r3
 c048a96:	d844      	bhi.n	c048b22 <mbedtls_psa_rsa_sign_hash+0xca>
        status = PSA_ERROR_BUFFER_TOO_SMALL;
        goto exit;
    }

#if defined(MBEDTLS_PSA_BUILTIN_ALG_RSA_PKCS1V15_SIGN)
    if( PSA_ALG_IS_RSA_PKCS1V15_SIGN( alg ) )
 c048a98:	4b25      	ldr	r3, [pc, #148]	@ (c048b30 <mbedtls_psa_rsa_sign_hash+0xd8>)
 c048a9a:	f025 02ff 	bic.w	r2, r5, #255	@ 0xff
 c048a9e:	429a      	cmp	r2, r3
 c048aa0:	d126      	bne.n	c048af0 <mbedtls_psa_rsa_sign_hash+0x98>
    {
        mbedtls_rsa_set_padding( rsa, MBEDTLS_RSA_PKCS_V15,
 c048aa2:	4622      	mov	r2, r4
 c048aa4:	4621      	mov	r1, r4
 c048aa6:	4630      	mov	r0, r6
 c048aa8:	f006 fddf 	bl	c04f66a <mbedtls_rsa_set_padding>
                                 MBEDTLS_MD_NONE );
        ret = mbedtls_rsa_pkcs1_sign( rsa,
 c048aac:	f89d 3013 	ldrb.w	r3, [sp, #19]
 c048ab0:	4a20      	ldr	r2, [pc, #128]	@ (c048b34 <mbedtls_psa_rsa_sign_hash+0xdc>)
 c048ab2:	9300      	str	r3, [sp, #0]
 c048ab4:	4630      	mov	r0, r6
 c048ab6:	2301      	movs	r3, #1
 c048ab8:	e9cd 8902 	strd	r8, r9, [sp, #8]
 c048abc:	6812      	ldr	r2, [r2, #0]
 c048abe:	491e      	ldr	r1, [pc, #120]	@ (c048b38 <mbedtls_psa_rsa_sign_hash+0xe0>)
 c048ac0:	9701      	str	r7, [sp, #4]
 c048ac2:	f007 fc8f 	bl	c0503e4 <mbedtls_rsa_pkcs1_sign>
#endif /* MBEDTLS_PSA_BUILTIN_ALG_RSA_PKCS1V15_SIGN */
#if defined(MBEDTLS_PSA_BUILTIN_ALG_RSA_PSS)
    if( PSA_ALG_IS_RSA_PSS( alg ) )
    {
        mbedtls_rsa_set_padding( rsa, MBEDTLS_RSA_PKCS_V21, md_alg );
        ret = mbedtls_rsa_rsassa_pss_sign( rsa,
 c048ac6:	4604      	mov	r4, r0
    {
        status = PSA_ERROR_INVALID_ARGUMENT;
        goto exit;
    }

    if( ret == 0 )
 c048ac8:	b920      	cbnz	r0, c048ad4 <mbedtls_psa_rsa_sign_hash+0x7c>
        *signature_length = mbedtls_rsa_get_len( rsa );
 c048aca:	4630      	mov	r0, r6
 c048acc:	f006 fdd0 	bl	c04f670 <mbedtls_rsa_get_len>
 c048ad0:	9b12      	ldr	r3, [sp, #72]	@ 0x48
 c048ad2:	6018      	str	r0, [r3, #0]
    status = mbedtls_to_psa_error( ret );
 c048ad4:	4620      	mov	r0, r4
 c048ad6:	f7fb fef3 	bl	c0448c0 <mbedtls_to_psa_error>
 c048ada:	4604      	mov	r4, r0

exit:
    mbedtls_rsa_free( rsa );
 c048adc:	4630      	mov	r0, r6
 c048ade:	f007 fe13 	bl	c050708 <mbedtls_rsa_free>
    mbedtls_free( rsa );
 c048ae2:	4630      	mov	r0, r6
 c048ae4:	f7f2 fc64 	bl	c03b3b0 <mbedtls_free>

    return( status );
}
 c048ae8:	4620      	mov	r0, r4
 c048aea:	b007      	add	sp, #28
 c048aec:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    if( PSA_ALG_IS_RSA_PSS( alg ) )
 c048af0:	4b12      	ldr	r3, [pc, #72]	@ (c048b3c <mbedtls_psa_rsa_sign_hash+0xe4>)
 c048af2:	f425 5587 	bic.w	r5, r5, #4320	@ 0x10e0
 c048af6:	f025 051f 	bic.w	r5, r5, #31
 c048afa:	429d      	cmp	r5, r3
 c048afc:	d114      	bne.n	c048b28 <mbedtls_psa_rsa_sign_hash+0xd0>
        mbedtls_rsa_set_padding( rsa, MBEDTLS_RSA_PKCS_V21, md_alg );
 c048afe:	4630      	mov	r0, r6
 c048b00:	f89d 2013 	ldrb.w	r2, [sp, #19]
 c048b04:	2101      	movs	r1, #1
 c048b06:	f006 fdb0 	bl	c04f66a <mbedtls_rsa_set_padding>
        ret = mbedtls_rsa_rsassa_pss_sign( rsa,
 c048b0a:	4a0a      	ldr	r2, [pc, #40]	@ (c048b34 <mbedtls_psa_rsa_sign_hash+0xdc>)
 c048b0c:	2301      	movs	r3, #1
 c048b0e:	4630      	mov	r0, r6
 c048b10:	e9cd 8902 	strd	r8, r9, [sp, #8]
 c048b14:	e9cd 4700 	strd	r4, r7, [sp]
 c048b18:	6812      	ldr	r2, [r2, #0]
 c048b1a:	4907      	ldr	r1, [pc, #28]	@ (c048b38 <mbedtls_psa_rsa_sign_hash+0xe0>)
 c048b1c:	f007 fbe0 	bl	c0502e0 <mbedtls_rsa_rsassa_pss_sign>
 c048b20:	e7d1      	b.n	c048ac6 <mbedtls_psa_rsa_sign_hash+0x6e>
        status = PSA_ERROR_BUFFER_TOO_SMALL;
 c048b22:	f06f 0489 	mvn.w	r4, #137	@ 0x89
 c048b26:	e7d9      	b.n	c048adc <mbedtls_psa_rsa_sign_hash+0x84>
        status = PSA_ERROR_INVALID_ARGUMENT;
 c048b28:	f06f 0486 	mvn.w	r4, #134	@ 0x86
 c048b2c:	e7d6      	b.n	c048adc <mbedtls_psa_rsa_sign_hash+0x84>
 c048b2e:	bf00      	nop
 c048b30:	06000200 	.word	0x06000200
 c048b34:	0c060e6c 	.word	0x0c060e6c
 c048b38:	0c055d65 	.word	0x0c055d65
 c048b3c:	06000300 	.word	0x06000300

0c048b40 <mbedtls_psa_rsa_verify_hash>:
psa_status_t mbedtls_psa_rsa_verify_hash(
    const psa_key_attributes_t *attributes,
    const uint8_t *key_buffer, size_t key_buffer_size,
    psa_algorithm_t alg, const uint8_t *hash, size_t hash_length,
    const uint8_t *signature, size_t signature_length )
{
 c048b40:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 c048b44:	4699      	mov	r9, r3
    psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
    mbedtls_rsa_context *rsa = NULL;
 c048b46:	2300      	movs	r3, #0
{
 c048b48:	b089      	sub	sp, #36	@ 0x24
    mbedtls_rsa_context *rsa = NULL;
 c048b4a:	9307      	str	r3, [sp, #28]
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    mbedtls_md_type_t md_alg;

    status = mbedtls_psa_rsa_load_representation( attributes->core.type,
 c048b4c:	8800      	ldrh	r0, [r0, #0]
 c048b4e:	ab07      	add	r3, sp, #28
{
 c048b50:	f8dd 8048 	ldr.w	r8, [sp, #72]	@ 0x48
 c048b54:	e9dd 7610 	ldrd	r7, r6, [sp, #64]	@ 0x40
    status = mbedtls_psa_rsa_load_representation( attributes->core.type,
 c048b58:	f7ff fe54 	bl	c048804 <mbedtls_psa_rsa_load_representation>
                                                  key_buffer,
                                                  key_buffer_size,
                                                  &rsa );
    if( status != PSA_SUCCESS )
 c048b5c:	4604      	mov	r4, r0
 c048b5e:	b980      	cbnz	r0, c048b82 <mbedtls_psa_rsa_verify_hash+0x42>
        goto exit;

    status = psa_rsa_decode_md_type( alg, hash_length, &md_alg );
 c048b60:	4631      	mov	r1, r6
 c048b62:	4648      	mov	r0, r9
 c048b64:	f10d 021b 	add.w	r2, sp, #27
 c048b68:	f7ff fe0c 	bl	c048784 <psa_rsa_decode_md_type>
    if( status != PSA_SUCCESS )
 c048b6c:	4604      	mov	r4, r0
 c048b6e:	b940      	cbnz	r0, c048b82 <mbedtls_psa_rsa_verify_hash+0x42>
        goto exit;

    if( signature_length != mbedtls_rsa_get_len( rsa ) )
 c048b70:	9d07      	ldr	r5, [sp, #28]
 c048b72:	4628      	mov	r0, r5
 c048b74:	f006 fd7c 	bl	c04f670 <mbedtls_rsa_get_len>
 c048b78:	9b13      	ldr	r3, [sp, #76]	@ 0x4c
 c048b7a:	4298      	cmp	r0, r3
 c048b7c:	d00c      	beq.n	c048b98 <mbedtls_psa_rsa_verify_hash+0x58>
    {
        status = PSA_ERROR_INVALID_SIGNATURE;
 c048b7e:	f06f 0494 	mvn.w	r4, #148	@ 0x94
    status = ( ret == MBEDTLS_ERR_RSA_INVALID_PADDING ) ?
             PSA_ERROR_INVALID_SIGNATURE :
             mbedtls_to_psa_error( ret );

exit:
    mbedtls_rsa_free( rsa );
 c048b82:	9d07      	ldr	r5, [sp, #28]
 c048b84:	4628      	mov	r0, r5
 c048b86:	f007 fdbf 	bl	c050708 <mbedtls_rsa_free>
    mbedtls_free( rsa );
 c048b8a:	4628      	mov	r0, r5
 c048b8c:	f7f2 fc10 	bl	c03b3b0 <mbedtls_free>

    return( status );
}
 c048b90:	4620      	mov	r0, r4
 c048b92:	b009      	add	sp, #36	@ 0x24
 c048b94:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    if( PSA_ALG_IS_RSA_PKCS1V15_SIGN( alg ) )
 c048b98:	4a24      	ldr	r2, [pc, #144]	@ (c048c2c <mbedtls_psa_rsa_verify_hash+0xec>)
 c048b9a:	f029 03ff 	bic.w	r3, r9, #255	@ 0xff
 c048b9e:	4293      	cmp	r3, r2
 c048ba0:	d118      	bne.n	c048bd4 <mbedtls_psa_rsa_verify_hash+0x94>
        mbedtls_rsa_set_padding( rsa, MBEDTLS_RSA_PKCS_V15,
 c048ba2:	4622      	mov	r2, r4
 c048ba4:	4621      	mov	r1, r4
 c048ba6:	4628      	mov	r0, r5
 c048ba8:	f006 fd5f 	bl	c04f66a <mbedtls_rsa_set_padding>
        ret = mbedtls_rsa_pkcs1_verify( rsa,
 c048bac:	f89d 301b 	ldrb.w	r3, [sp, #27]
 c048bb0:	4a1f      	ldr	r2, [pc, #124]	@ (c048c30 <mbedtls_psa_rsa_verify_hash+0xf0>)
 c048bb2:	9300      	str	r3, [sp, #0]
 c048bb4:	4628      	mov	r0, r5
 c048bb6:	4623      	mov	r3, r4
 c048bb8:	e9cd 7802 	strd	r7, r8, [sp, #8]
 c048bbc:	6812      	ldr	r2, [r2, #0]
 c048bbe:	491d      	ldr	r1, [pc, #116]	@ (c048c34 <mbedtls_psa_rsa_verify_hash+0xf4>)
 c048bc0:	9601      	str	r6, [sp, #4]
 c048bc2:	f007 fd7f 	bl	c0506c4 <mbedtls_rsa_pkcs1_verify>
             PSA_ERROR_INVALID_SIGNATURE :
 c048bc6:	f510 4f82 	cmn.w	r0, #16640	@ 0x4100
 c048bca:	d0d8      	beq.n	c048b7e <mbedtls_psa_rsa_verify_hash+0x3e>
             mbedtls_to_psa_error( ret );
 c048bcc:	f7fb fe78 	bl	c0448c0 <mbedtls_to_psa_error>
 c048bd0:	4604      	mov	r4, r0
 c048bd2:	e7d6      	b.n	c048b82 <mbedtls_psa_rsa_verify_hash+0x42>
    if( PSA_ALG_IS_RSA_PSS( alg ) )
 c048bd4:	4a18      	ldr	r2, [pc, #96]	@ (c048c38 <mbedtls_psa_rsa_verify_hash+0xf8>)
 c048bd6:	4293      	cmp	r3, r2
 c048bd8:	d006      	beq.n	c048be8 <mbedtls_psa_rsa_verify_hash+0xa8>
 c048bda:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
 c048bde:	4293      	cmp	r3, r2
 c048be0:	d021      	beq.n	c048c26 <mbedtls_psa_rsa_verify_hash+0xe6>
        status = PSA_ERROR_INVALID_ARGUMENT;
 c048be2:	f06f 0486 	mvn.w	r4, #134	@ 0x86
 c048be6:	e7cc      	b.n	c048b82 <mbedtls_psa_rsa_verify_hash+0x42>
    int klen = (int) mbedtls_rsa_get_len( rsa ); // known to fit
 c048be8:	4628      	mov	r0, r5
 c048bea:	f006 fd41 	bl	c04f670 <mbedtls_rsa_get_len>
    int room = klen - 2 - hlen;
 c048bee:	3802      	subs	r0, #2
    if( room < 0 )
 c048bf0:	1b80      	subs	r0, r0, r6
 c048bf2:	d403      	bmi.n	c048bfc <mbedtls_psa_rsa_verify_hash+0xbc>
    else if( room > hlen )
 c048bf4:	42b0      	cmp	r0, r6
 c048bf6:	bfa8      	it	ge
 c048bf8:	4630      	movge	r0, r6
 c048bfa:	4604      	mov	r4, r0
        mbedtls_rsa_set_padding( rsa, MBEDTLS_RSA_PKCS_V21, md_alg );
 c048bfc:	f89d 901b 	ldrb.w	r9, [sp, #27]
 c048c00:	4628      	mov	r0, r5
 c048c02:	464a      	mov	r2, r9
 c048c04:	2101      	movs	r1, #1
 c048c06:	f006 fd30 	bl	c04f66a <mbedtls_rsa_set_padding>
        ret = mbedtls_rsa_rsassa_pss_verify_ext( rsa,
 c048c0a:	4a09      	ldr	r2, [pc, #36]	@ (c048c30 <mbedtls_psa_rsa_verify_hash+0xf0>)
 c048c0c:	2300      	movs	r3, #0
 c048c0e:	4628      	mov	r0, r5
 c048c10:	e9cd 4804 	strd	r4, r8, [sp, #16]
 c048c14:	e9cd 7902 	strd	r7, r9, [sp, #8]
 c048c18:	e9cd 9600 	strd	r9, r6, [sp]
 c048c1c:	6812      	ldr	r2, [r2, #0]
 c048c1e:	4905      	ldr	r1, [pc, #20]	@ (c048c34 <mbedtls_psa_rsa_verify_hash+0xf4>)
 c048c20:	f007 fc02 	bl	c050428 <mbedtls_rsa_rsassa_pss_verify_ext>
    {
 c048c24:	e7cf      	b.n	c048bc6 <mbedtls_psa_rsa_verify_hash+0x86>
        return( MBEDTLS_RSA_SALT_LEN_ANY );
 c048c26:	f04f 34ff 	mov.w	r4, #4294967295	@ 0xffffffff
 c048c2a:	e7e7      	b.n	c048bfc <mbedtls_psa_rsa_verify_hash+0xbc>
 c048c2c:	06000200 	.word	0x06000200
 c048c30:	0c060e6c 	.word	0x0c060e6c
 c048c34:	0c055d65 	.word	0x0c055d65
 c048c38:	06000300 	.word	0x06000300

0c048c3c <psa_get_se_driver_entry>:
    psa_key_location_t location = PSA_KEY_LIFETIME_GET_LOCATION( lifetime );
    /* In the driver table, location=0 means an entry that isn't used.
     * No driver has a location of 0 because it's a reserved value
     * (which designates transparent keys). Make sure we never return
     * a driver entry for location 0. */
    if( location == 0 )
 c048c3c:	0a00      	lsrs	r0, r0, #8
{
 c048c3e:	b530      	push	{r4, r5, lr}
    if( location == 0 )
 c048c40:	d009      	beq.n	c048c56 <psa_get_se_driver_entry+0x1a>
        return( NULL );
    for( i = 0; i < PSA_MAX_SE_DRIVERS; i++ )
 c048c42:	2300      	movs	r3, #0
 c048c44:	2414      	movs	r4, #20
    {
        if( driver_table[i].location == location )
 c048c46:	4a07      	ldr	r2, [pc, #28]	@ (c048c64 <psa_get_se_driver_entry+0x28>)
 c048c48:	fb04 f103 	mul.w	r1, r4, r3
 c048c4c:	188d      	adds	r5, r1, r2
 c048c4e:	5851      	ldr	r1, [r2, r1]
 c048c50:	4281      	cmp	r1, r0
 c048c52:	d101      	bne.n	c048c58 <psa_get_se_driver_entry+0x1c>
            return( &driver_table[i] );
 c048c54:	4628      	mov	r0, r5
    }
    return( NULL );
}
 c048c56:	bd30      	pop	{r4, r5, pc}
    for( i = 0; i < PSA_MAX_SE_DRIVERS; i++ )
 c048c58:	3301      	adds	r3, #1
 c048c5a:	2b04      	cmp	r3, #4
 c048c5c:	d1f4      	bne.n	c048c48 <psa_get_se_driver_entry+0xc>
        return( NULL );
 c048c5e:	2000      	movs	r0, #0
 c048c60:	e7f9      	b.n	c048c56 <psa_get_se_driver_entry+0x1a>
 c048c62:	bf00      	nop
 c048c64:	30031240 	.word	0x30031240

0c048c68 <psa_get_se_driver>:
}

int psa_get_se_driver( psa_key_lifetime_t lifetime,
                       const psa_drv_se_t **p_methods,
                       psa_drv_se_context_t **p_drv_context)
{
 c048c68:	b538      	push	{r3, r4, r5, lr}
 c048c6a:	460d      	mov	r5, r1
 c048c6c:	4614      	mov	r4, r2
    psa_se_drv_table_entry_t *driver = psa_get_se_driver_entry( lifetime );
 c048c6e:	f7ff ffe5 	bl	c048c3c <psa_get_se_driver_entry>
    if( p_methods != NULL )
 c048c72:	b115      	cbz	r5, c048c7a <psa_get_se_driver+0x12>
        *p_methods = ( driver ? driver->methods : NULL );
 c048c74:	b150      	cbz	r0, c048c8c <psa_get_se_driver+0x24>
 c048c76:	6843      	ldr	r3, [r0, #4]
 c048c78:	602b      	str	r3, [r5, #0]
    if( p_drv_context != NULL )
 c048c7a:	b11c      	cbz	r4, c048c84 <psa_get_se_driver+0x1c>
        *p_drv_context = ( driver ? &driver->u.context : NULL );
 c048c7c:	b140      	cbz	r0, c048c90 <psa_get_se_driver+0x28>
 c048c7e:	f100 0308 	add.w	r3, r0, #8
 c048c82:	6023      	str	r3, [r4, #0]
    return( driver != NULL );
}
 c048c84:	3800      	subs	r0, #0
 c048c86:	bf18      	it	ne
 c048c88:	2001      	movne	r0, #1
 c048c8a:	bd38      	pop	{r3, r4, r5, pc}
        *p_methods = ( driver ? driver->methods : NULL );
 c048c8c:	4603      	mov	r3, r0
 c048c8e:	e7f3      	b.n	c048c78 <psa_get_se_driver+0x10>
        *p_drv_context = ( driver ? &driver->u.context : NULL );
 c048c90:	4603      	mov	r3, r0
 c048c92:	e7f6      	b.n	c048c82 <psa_get_se_driver+0x1a>

0c048c94 <psa_load_se_persistent_data>:
    return( PSA_SUCCESS );
}

psa_status_t psa_load_se_persistent_data(
    const psa_se_drv_table_entry_t *driver )
{
 c048c94:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 c048c96:	6801      	ldr	r1, [r0, #0]
    if( driver->location > PSA_MAX_SE_LOCATION )
 c048c98:	29ff      	cmp	r1, #255	@ 0xff
 c048c9a:	d80d      	bhi.n	c048cb8 <psa_load_se_persistent_data+0x24>
     * in storage is smaller, silently keep what is already at the end
     * of the output buffer. */
    /* psa_get_se_driver_its_file_uid ensures that the size_t
     * persistent_data_size is in range, but compilers don't know that,
     * so cast to reassure them. */
    return( psa_its_get( uid, 0,
 c048c9c:	2200      	movs	r2, #0
 c048c9e:	ab03      	add	r3, sp, #12
 c048ca0:	9301      	str	r3, [sp, #4]
 c048ca2:	6883      	ldr	r3, [r0, #8]
 c048ca4:	9300      	str	r3, [sp, #0]
 c048ca6:	68c3      	ldr	r3, [r0, #12]
 c048ca8:	f5a1 7000 	sub.w	r0, r1, #512	@ 0x200
 c048cac:	4611      	mov	r1, r2
 c048cae:	f7f3 fcf0 	bl	c03c692 <psa_its_get>
                         (uint32_t) driver->u.internal.persistent_data_size,
                         driver->u.internal.persistent_data,
                         &length ) );
}
 c048cb2:	b005      	add	sp, #20
 c048cb4:	f85d fb04 	ldr.w	pc, [sp], #4
        return( PSA_ERROR_NOT_SUPPORTED );
 c048cb8:	f06f 0085 	mvn.w	r0, #133	@ 0x85
 c048cbc:	e7f9      	b.n	c048cb2 <psa_load_se_persistent_data+0x1e>

0c048cbe <psa_save_se_persistent_data>:

psa_status_t psa_save_se_persistent_data(
    const psa_se_drv_table_entry_t *driver )
{
 c048cbe:	b513      	push	{r0, r1, r4, lr}
 c048cc0:	6804      	ldr	r4, [r0, #0]
    if( driver->location > PSA_MAX_SE_LOCATION )
 c048cc2:	2cff      	cmp	r4, #255	@ 0xff
 c048cc4:	d809      	bhi.n	c048cda <psa_save_se_persistent_data+0x1c>
    *uid = PSA_CRYPTO_SE_DRIVER_ITS_UID_BASE + driver->location;
 c048cc6:	2100      	movs	r1, #0
        return( status );

    /* psa_get_se_driver_its_file_uid ensures that the size_t
     * persistent_data_size is in range, but compilers don't know that,
     * so cast to reassure them. */
    return( psa_its_set( uid,
 c048cc8:	9100      	str	r1, [sp, #0]
 c048cca:	e9d0 3202 	ldrd	r3, r2, [r0, #8]
 c048cce:	f5a4 7000 	sub.w	r0, r4, #512	@ 0x200
 c048cd2:	f7f3 fcb9 	bl	c03c648 <psa_its_set>
                         (uint32_t) driver->u.internal.persistent_data_size,
                         driver->u.internal.persistent_data,
                         0 ) );
}
 c048cd6:	b002      	add	sp, #8
 c048cd8:	bd10      	pop	{r4, pc}
        return( PSA_ERROR_NOT_SUPPORTED );
 c048cda:	f06f 0085 	mvn.w	r0, #133	@ 0x85
 c048cde:	e7fa      	b.n	c048cd6 <psa_save_se_persistent_data+0x18>

0c048ce0 <psa_find_se_slot_for_key>:
psa_status_t psa_find_se_slot_for_key(
    const psa_key_attributes_t *attributes,
    psa_key_creation_method_t method,
    psa_se_drv_table_entry_t *driver,
    psa_key_slot_number_t *slot_number )
{
 c048ce0:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
 c048ce4:	4614      	mov	r4, r2
 c048ce6:	461f      	mov	r7, r3
    psa_status_t status;
    psa_key_location_t key_location =
 c048ce8:	6842      	ldr	r2, [r0, #4]
        PSA_KEY_LIFETIME_GET_LOCATION( psa_get_key_lifetime( attributes ) );

    /* If the location is wrong, it's a bug in the library. */
    if( driver->location != key_location )
 c048cea:	6823      	ldr	r3, [r4, #0]
{
 c048cec:	4605      	mov	r5, r0
    if( driver->location != key_location )
 c048cee:	ebb3 2f12 	cmp.w	r3, r2, lsr #8
{
 c048cf2:	460e      	mov	r6, r1
    if( driver->location != key_location )
 c048cf4:	d12e      	bne.n	c048d54 <psa_find_se_slot_for_key+0x74>
        return( PSA_ERROR_CORRUPTION_DETECTED );

    /* If the driver doesn't support key creation in any way, give up now. */
    if( driver->methods->key_management == NULL )
 c048cf6:	6863      	ldr	r3, [r4, #4]
 c048cf8:	68db      	ldr	r3, [r3, #12]
 c048cfa:	b923      	cbnz	r3, c048d06 <psa_find_se_slot_for_key+0x26>
        return( PSA_ERROR_NOT_SUPPORTED );
 c048cfc:	f06f 0085 	mvn.w	r0, #133	@ 0x85
                             driver->u.internal.persistent_data,
                             attributes, method,
                             slot_number );
    }
    return( status );
}
 c048d00:	b002      	add	sp, #8
 c048d02:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if( psa_get_key_slot_number( attributes, slot_number ) == PSA_SUCCESS )
 c048d06:	4639      	mov	r1, r7
 c048d08:	f7fc fb10 	bl	c04532c <psa_get_key_slot_number>
 c048d0c:	b988      	cbnz	r0, c048d32 <psa_find_se_slot_for_key+0x52>
            driver->methods->key_management->p_validate_slot_number;
 c048d0e:	6863      	ldr	r3, [r4, #4]
        psa_drv_se_validate_slot_number_t p_validate_slot_number =
 c048d10:	68db      	ldr	r3, [r3, #12]
 c048d12:	f8d3 8004 	ldr.w	r8, [r3, #4]
        if( p_validate_slot_number == NULL )
 c048d16:	f1b8 0f00 	cmp.w	r8, #0
 c048d1a:	d0ef      	beq.n	c048cfc <psa_find_se_slot_for_key+0x1c>
        status = p_validate_slot_number( &driver->u.context,
 c048d1c:	e9d7 2300 	ldrd	r2, r3, [r7]
 c048d20:	e9cd 2300 	strd	r2, r3, [sp]
 c048d24:	f104 0008 	add.w	r0, r4, #8
 c048d28:	4633      	mov	r3, r6
 c048d2a:	462a      	mov	r2, r5
 c048d2c:	68a1      	ldr	r1, [r4, #8]
 c048d2e:	47c0      	blx	r8
 c048d30:	e7e6      	b.n	c048d00 <psa_find_se_slot_for_key+0x20>
    else if( method == PSA_KEY_CREATION_REGISTER )
 c048d32:	2e04      	cmp	r6, #4
 c048d34:	d011      	beq.n	c048d5a <psa_find_se_slot_for_key+0x7a>
            driver->methods->key_management->p_allocate;
 c048d36:	6863      	ldr	r3, [r4, #4]
        psa_drv_se_allocate_key_t p_allocate =
 c048d38:	68db      	ldr	r3, [r3, #12]
 c048d3a:	f8d3 8000 	ldr.w	r8, [r3]
        if( p_allocate == NULL )
 c048d3e:	f1b8 0f00 	cmp.w	r8, #0
 c048d42:	d0db      	beq.n	c048cfc <psa_find_se_slot_for_key+0x1c>
        status = p_allocate( &driver->u.context,
 c048d44:	9700      	str	r7, [sp, #0]
 c048d46:	4633      	mov	r3, r6
 c048d48:	462a      	mov	r2, r5
 c048d4a:	68a1      	ldr	r1, [r4, #8]
 c048d4c:	f104 0008 	add.w	r0, r4, #8
 c048d50:	47c0      	blx	r8
 c048d52:	e7d5      	b.n	c048d00 <psa_find_se_slot_for_key+0x20>
        return( PSA_ERROR_CORRUPTION_DETECTED );
 c048d54:	f06f 0096 	mvn.w	r0, #150	@ 0x96
 c048d58:	e7d2      	b.n	c048d00 <psa_find_se_slot_for_key+0x20>
        return( PSA_ERROR_INVALID_ARGUMENT );
 c048d5a:	f06f 0086 	mvn.w	r0, #134	@ 0x86
 c048d5e:	e7cf      	b.n	c048d00 <psa_find_se_slot_for_key+0x20>

0c048d60 <psa_destroy_se_key>:
     * be able to destroy it. The only use case for a driver that
     * does not have a way to destroy keys at all is if the keys are
     * locked in a read-only state: we can use the keys but not
     * destroy them. Hence, if the driver doesn't support destroying
     * keys, it's really a lack of permission. */
    if( driver->methods->key_management == NULL ||
 c048d60:	6841      	ldr	r1, [r0, #4]
{
 c048d62:	b538      	push	{r3, r4, r5, lr}
    if( driver->methods->key_management == NULL ||
 c048d64:	68c9      	ldr	r1, [r1, #12]
{
 c048d66:	4604      	mov	r4, r0
    if( driver->methods->key_management == NULL ||
 c048d68:	b161      	cbz	r1, c048d84 <psa_destroy_se_key+0x24>
        driver->methods->key_management->p_destroy == NULL )
 c048d6a:	690d      	ldr	r5, [r1, #16]
    if( driver->methods->key_management == NULL ||
 c048d6c:	b155      	cbz	r5, c048d84 <psa_destroy_se_key+0x24>
        return( PSA_ERROR_NOT_PERMITTED );
    status = driver->methods->key_management->p_destroy(
 c048d6e:	6881      	ldr	r1, [r0, #8]
 c048d70:	3008      	adds	r0, #8
 c048d72:	47a8      	blx	r5
 c048d74:	4605      	mov	r5, r0
        &driver->u.context,
        driver->u.internal.persistent_data,
        slot_number );
    storage_status = psa_save_se_persistent_data( driver );
 c048d76:	4620      	mov	r0, r4
 c048d78:	f7ff ffa1 	bl	c048cbe <psa_save_se_persistent_data>
    return( status == PSA_SUCCESS ? storage_status : status );
 c048d7c:	2d00      	cmp	r5, #0
 c048d7e:	bf18      	it	ne
 c048d80:	4628      	movne	r0, r5
}
 c048d82:	bd38      	pop	{r3, r4, r5, pc}
        return( PSA_ERROR_NOT_PERMITTED );
 c048d84:	f06f 0084 	mvn.w	r0, #132	@ 0x84
 c048d88:	e7fb      	b.n	c048d82 <psa_destroy_se_key+0x22>
	...

0c048d8c <psa_init_all_se_drivers>:

psa_status_t psa_init_all_se_drivers( void )
{
 c048d8c:	b538      	push	{r3, r4, r5, lr}
    size_t i;
    for( i = 0; i < PSA_MAX_SE_DRIVERS; i++ )
 c048d8e:	2500      	movs	r5, #0
 c048d90:	4c0c      	ldr	r4, [pc, #48]	@ (c048dc4 <psa_init_all_se_drivers+0x38>)
    {
        psa_se_drv_table_entry_t *driver = &driver_table[i];
        if( driver->location == 0 )
 c048d92:	6822      	ldr	r2, [r4, #0]
 c048d94:	b932      	cbnz	r2, c048da4 <psa_init_all_se_drivers+0x18>
    for( i = 0; i < PSA_MAX_SE_DRIVERS; i++ )
 c048d96:	3501      	adds	r5, #1
 c048d98:	2d04      	cmp	r5, #4
 c048d9a:	f104 0414 	add.w	r4, r4, #20
 c048d9e:	d1f8      	bne.n	c048d92 <psa_init_all_se_drivers+0x6>
            status = psa_save_se_persistent_data( driver );
            if( status != PSA_SUCCESS )
                return( status );
        }
    }
    return( PSA_SUCCESS );
 c048da0:	2000      	movs	r0, #0
}
 c048da2:	bd38      	pop	{r3, r4, r5, pc}
        if( methods->p_init != NULL )
 c048da4:	6863      	ldr	r3, [r4, #4]
 c048da6:	689b      	ldr	r3, [r3, #8]
 c048da8:	2b00      	cmp	r3, #0
 c048daa:	d0f4      	beq.n	c048d96 <psa_init_all_se_drivers+0xa>
            psa_status_t status = methods->p_init(
 c048dac:	68a1      	ldr	r1, [r4, #8]
 c048dae:	f104 0008 	add.w	r0, r4, #8
 c048db2:	4798      	blx	r3
            if( status != PSA_SUCCESS )
 c048db4:	2800      	cmp	r0, #0
 c048db6:	d1f4      	bne.n	c048da2 <psa_init_all_se_drivers+0x16>
            status = psa_save_se_persistent_data( driver );
 c048db8:	4620      	mov	r0, r4
 c048dba:	f7ff ff80 	bl	c048cbe <psa_save_se_persistent_data>
            if( status != PSA_SUCCESS )
 c048dbe:	2800      	cmp	r0, #0
 c048dc0:	d0e9      	beq.n	c048d96 <psa_init_all_se_drivers+0xa>
 c048dc2:	e7ee      	b.n	c048da2 <psa_init_all_se_drivers+0x16>
 c048dc4:	30031240 	.word	0x30031240

0c048dc8 <psa_register_se_driver>:
/****************************************************************/

psa_status_t psa_register_se_driver(
    psa_key_location_t location,
    const psa_drv_se_t *methods)
{
 c048dc8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    size_t i;
    psa_status_t status;

    if( methods->hal_version != PSA_DRV_SE_HAL_VERSION )
 c048dca:	680b      	ldr	r3, [r1, #0]
 c048dcc:	2b05      	cmp	r3, #5
 c048dce:	d134      	bne.n	c048e3a <psa_register_se_driver+0x72>
     * location because it means a transparent key. */
#if defined(static_assert)
    static_assert( PSA_KEY_LOCATION_LOCAL_STORAGE == 0,
                   "Secure element support requires 0 to mean a local key" );
#endif
    if( location == PSA_KEY_LOCATION_LOCAL_STORAGE )
 c048dd0:	b380      	cbz	r0, c048e34 <psa_register_se_driver+0x6c>
        return( PSA_ERROR_INVALID_ARGUMENT );
    if( location > PSA_MAX_SE_LOCATION )
 c048dd2:	28ff      	cmp	r0, #255	@ 0xff
 c048dd4:	d831      	bhi.n	c048e3a <psa_register_se_driver+0x72>
        return( PSA_ERROR_NOT_SUPPORTED );

    for( i = 0; i < PSA_MAX_SE_DRIVERS; i++ )
 c048dd6:	2300      	movs	r3, #0
    {
        if( driver_table[i].location == 0 )
 c048dd8:	2714      	movs	r7, #20
 c048dda:	4c1b      	ldr	r4, [pc, #108]	@ (c048e48 <psa_register_se_driver+0x80>)
 c048ddc:	fb07 f203 	mul.w	r2, r7, r3
 c048de0:	58a6      	ldr	r6, [r4, r2]
 c048de2:	1915      	adds	r5, r2, r4
 c048de4:	b146      	cbz	r6, c048df8 <psa_register_se_driver+0x30>
            break;
        /* Check that location isn't already in use up to the first free
         * entry. Since entries are created in order and never deleted,
         * there can't be a used entry after the first free entry. */
        if( driver_table[i].location == location )
 c048de6:	4286      	cmp	r6, r0
 c048de8:	d02a      	beq.n	c048e40 <psa_register_se_driver+0x78>
    for( i = 0; i < PSA_MAX_SE_DRIVERS; i++ )
 c048dea:	3301      	adds	r3, #1
 c048dec:	2b04      	cmp	r3, #4
 c048dee:	d1f5      	bne.n	c048ddc <psa_register_se_driver+0x14>
            return( PSA_ERROR_ALREADY_EXISTS );
    }
    if( i == PSA_MAX_SE_DRIVERS )
        return( PSA_ERROR_INSUFFICIENT_MEMORY );
 c048df0:	f06f 048c 	mvn.w	r4, #140	@ 0x8c
    return( PSA_SUCCESS );

error:
    memset( &driver_table[i], 0, sizeof( driver_table[i] ) );
    return( status );
}
 c048df4:	4620      	mov	r0, r4
 c048df6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    driver_table[i].methods = methods;
 c048df8:	6069      	str	r1, [r5, #4]
        methods->persistent_data_size;
 c048dfa:	6849      	ldr	r1, [r1, #4]
    driver_table[i].location = location;
 c048dfc:	50a0      	str	r0, [r4, r2]
    driver_table[i].u.internal.persistent_data_size =
 c048dfe:	60e9      	str	r1, [r5, #12]
    if( methods->persistent_data_size != 0 )
 c048e00:	b909      	cbnz	r1, c048e06 <psa_register_se_driver+0x3e>
    return( PSA_SUCCESS );
 c048e02:	2400      	movs	r4, #0
 c048e04:	e7f6      	b.n	c048df4 <psa_register_se_driver+0x2c>
            mbedtls_calloc( 1, methods->persistent_data_size );
 c048e06:	2001      	movs	r0, #1
 c048e08:	f7f2 facc 	bl	c03b3a4 <mbedtls_calloc>
        driver_table[i].u.internal.persistent_data =
 c048e0c:	60a8      	str	r0, [r5, #8]
        if( driver_table[i].u.internal.persistent_data == NULL )
 c048e0e:	b170      	cbz	r0, c048e2e <psa_register_se_driver+0x66>
        status = psa_load_se_persistent_data( &driver_table[i] );
 c048e10:	4628      	mov	r0, r5
 c048e12:	f7ff ff3f 	bl	c048c94 <psa_load_se_persistent_data>
        if( status != PSA_SUCCESS && status != PSA_ERROR_DOES_NOT_EXIST )
 c048e16:	4604      	mov	r4, r0
 c048e18:	2800      	cmp	r0, #0
 c048e1a:	d0f2      	beq.n	c048e02 <psa_register_se_driver+0x3a>
 c048e1c:	f110 0f8c 	cmn.w	r0, #140	@ 0x8c
 c048e20:	d0ef      	beq.n	c048e02 <psa_register_se_driver+0x3a>
    memset( &driver_table[i], 0, sizeof( driver_table[i] ) );
 c048e22:	2214      	movs	r2, #20
 c048e24:	2100      	movs	r1, #0
 c048e26:	4628      	mov	r0, r5
 c048e28:	f012 fc81 	bl	c05b72e <memset>
    return( status );
 c048e2c:	e7e2      	b.n	c048df4 <psa_register_se_driver+0x2c>
            status = PSA_ERROR_INSUFFICIENT_MEMORY;
 c048e2e:	f06f 048c 	mvn.w	r4, #140	@ 0x8c
 c048e32:	e7f6      	b.n	c048e22 <psa_register_se_driver+0x5a>
        return( PSA_ERROR_INVALID_ARGUMENT );
 c048e34:	f06f 0486 	mvn.w	r4, #134	@ 0x86
 c048e38:	e7dc      	b.n	c048df4 <psa_register_se_driver+0x2c>
        return( PSA_ERROR_NOT_SUPPORTED );
 c048e3a:	f06f 0485 	mvn.w	r4, #133	@ 0x85
 c048e3e:	e7d9      	b.n	c048df4 <psa_register_se_driver+0x2c>
            return( PSA_ERROR_ALREADY_EXISTS );
 c048e40:	f06f 048a 	mvn.w	r4, #138	@ 0x8a
 c048e44:	e7d6      	b.n	c048df4 <psa_register_se_driver+0x2c>
 c048e46:	bf00      	nop
 c048e48:	30031240 	.word	0x30031240

0c048e4c <psa_unregister_all_se_drivers>:

void psa_unregister_all_se_drivers( void )
{
 c048e4c:	b538      	push	{r3, r4, r5, lr}
 c048e4e:	2404      	movs	r4, #4
 c048e50:	4d07      	ldr	r5, [pc, #28]	@ (c048e70 <psa_unregister_all_se_drivers+0x24>)
    size_t i;
    for( i = 0; i < PSA_MAX_SE_DRIVERS; i++ )
    {
        if( driver_table[i].u.internal.persistent_data != NULL )
 c048e52:	68a8      	ldr	r0, [r5, #8]
 c048e54:	b108      	cbz	r0, c048e5a <psa_unregister_all_se_drivers+0xe>
            mbedtls_free( driver_table[i].u.internal.persistent_data );
 c048e56:	f7f2 faab 	bl	c03b3b0 <mbedtls_free>
    for( i = 0; i < PSA_MAX_SE_DRIVERS; i++ )
 c048e5a:	3c01      	subs	r4, #1
 c048e5c:	f105 0514 	add.w	r5, r5, #20
 c048e60:	d1f7      	bne.n	c048e52 <psa_unregister_all_se_drivers+0x6>
    }
    memset( driver_table, 0, sizeof( driver_table ) );
 c048e62:	4621      	mov	r1, r4
}
 c048e64:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    memset( driver_table, 0, sizeof( driver_table ) );
 c048e68:	2250      	movs	r2, #80	@ 0x50
 c048e6a:	4801      	ldr	r0, [pc, #4]	@ (c048e70 <psa_unregister_all_se_drivers+0x24>)
 c048e6c:	f012 bc5f 	b.w	c05b72e <memset>
 c048e70:	30031240 	.word	0x30031240

0c048e74 <psa_is_valid_key_id>:
} psa_global_data_t;

static psa_global_data_t global_data;

int psa_is_valid_key_id( mbedtls_svc_key_id_t key, int vendor_ok )
{
 c048e74:	b082      	sub	sp, #8
 c048e76:	ab02      	add	r3, sp, #8
 c048e78:	e903 0003 	stmdb	r3, {r0, r1}
 c048e7c:	4610      	mov	r0, r2
    psa_key_id_t key_id = MBEDTLS_SVC_KEY_ID_GET_KEY_ID( key );

    if( ( PSA_KEY_ID_USER_MIN <= key_id ) &&
 c048e7e:	f06f 4240 	mvn.w	r2, #3221225472	@ 0xc0000000
    psa_key_id_t key_id = MBEDTLS_SVC_KEY_ID_GET_KEY_ID( key );
 c048e82:	9b00      	ldr	r3, [sp, #0]
    if( ( PSA_KEY_ID_USER_MIN <= key_id ) &&
 c048e84:	1e59      	subs	r1, r3, #1
 c048e86:	4291      	cmp	r1, r2
 c048e88:	d308      	bcc.n	c048e9c <psa_is_valid_key_id+0x28>
        ( key_id <= PSA_KEY_ID_USER_MAX ) )
        return( 1 );

    if( vendor_ok &&
 c048e8a:	b128      	cbz	r0, c048e98 <psa_is_valid_key_id+0x24>
 c048e8c:	f103 4340 	add.w	r3, r3, #3221225472	@ 0xc0000000
 c048e90:	4293      	cmp	r3, r2
 c048e92:	bf8c      	ite	hi
 c048e94:	2000      	movhi	r0, #0
 c048e96:	2001      	movls	r0, #1
        ( PSA_KEY_ID_VENDOR_MIN <= key_id ) &&
        ( key_id <= PSA_KEY_ID_VENDOR_MAX ) )
        return( 1 );

    return( 0 );
}
 c048e98:	b002      	add	sp, #8
 c048e9a:	4770      	bx	lr
        return( 1 );
 c048e9c:	2001      	movs	r0, #1
 c048e9e:	e7fb      	b.n	c048e98 <psa_is_valid_key_id+0x24>

0c048ea0 <psa_get_and_lock_key_slot_in_memory>:
 * \retval #PSA_ERROR_DOES_NOT_EXIST
 *         There is no key with key identifier \p key in the key slots.
 */
static psa_status_t psa_get_and_lock_key_slot_in_memory(
    mbedtls_svc_key_id_t key, psa_key_slot_t **p_slot )
{
 c048ea0:	b573      	push	{r0, r1, r4, r5, r6, lr}
 c048ea2:	466b      	mov	r3, sp
 c048ea4:	4614      	mov	r4, r2
    return( ( key_id >= PSA_KEY_ID_VOLATILE_MIN ) &&
 c048ea6:	f100 4200 	add.w	r2, r0, #2147483648	@ 0x80000000
 c048eaa:	3220      	adds	r2, #32
    psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
    psa_key_id_t key_id = MBEDTLS_SVC_KEY_ID_GET_KEY_ID( key );
    size_t slot_idx;
    psa_key_slot_t *slot = NULL;

    if( psa_key_id_is_volatile( key_id ) )
 c048eac:	2a1f      	cmp	r2, #31
 c048eae:	460e      	mov	r6, r1
 c048eb0:	4605      	mov	r5, r0
{
 c048eb2:	e883 0003 	stmia.w	r3, {r0, r1}
    if( psa_key_id_is_volatile( key_id ) )
 c048eb6:	d812      	bhi.n	c048ede <psa_get_and_lock_key_slot_in_memory+0x3e>
 * \return Non-zero if the two key identifier are equal, zero otherwise.
 */
static inline int mbedtls_svc_key_id_equal( mbedtls_svc_key_id_t id1,
                                            mbedtls_svc_key_id_t id2 )
{
    return( ( id1.key_id == id2.key_id ) &&
 c048eb8:	212c      	movs	r1, #44	@ 0x2c
 c048eba:	4b19      	ldr	r3, [pc, #100]	@ (c048f20 <psa_get_and_lock_key_slot_in_memory+0x80>)
 c048ebc:	fb01 3302 	mla	r3, r1, r2, r3
 c048ec0:	689a      	ldr	r2, [r3, #8]
 c048ec2:	4290      	cmp	r0, r2
 c048ec4:	d11f      	bne.n	c048f06 <psa_get_and_lock_key_slot_in_memory+0x66>
 c048ec6:	68da      	ldr	r2, [r3, #12]
 c048ec8:	4296      	cmp	r6, r2
 c048eca:	d11c      	bne.n	c048f06 <psa_get_and_lock_key_slot_in_memory+0x66>
    if( slot->lock_count >= SIZE_MAX )
 c048ecc:	6a19      	ldr	r1, [r3, #32]
 c048ece:	1c4a      	adds	r2, r1, #1
 c048ed0:	d023      	beq.n	c048f1a <psa_get_and_lock_key_slot_in_memory+0x7a>
                 PSA_SUCCESS : PSA_ERROR_DOES_NOT_EXIST;
    }

    if( status == PSA_SUCCESS )
    {
        status = psa_lock_key_slot( slot );
 c048ed2:	2000      	movs	r0, #0
    slot->lock_count++;
 c048ed4:	3101      	adds	r1, #1
 c048ed6:	6219      	str	r1, [r3, #32]
        if( status == PSA_SUCCESS )
            *p_slot = slot;
 c048ed8:	6023      	str	r3, [r4, #0]
    }

    return( status );
}
 c048eda:	b002      	add	sp, #8
 c048edc:	bd70      	pop	{r4, r5, r6, pc}
        if ( !psa_is_valid_key_id( key, 1 ) )
 c048ede:	2201      	movs	r2, #1
 c048ee0:	e893 0003 	ldmia.w	r3, {r0, r1}
 c048ee4:	f7ff ffc6 	bl	c048e74 <psa_is_valid_key_id>
 c048ee8:	b1a0      	cbz	r0, c048f14 <psa_get_and_lock_key_slot_in_memory+0x74>
 c048eea:	490d      	ldr	r1, [pc, #52]	@ (c048f20 <psa_get_and_lock_key_slot_in_memory+0x80>)
        for( slot_idx = 0; slot_idx < MBEDTLS_PSA_KEY_SLOT_COUNT; slot_idx++ )
 c048eec:	2000      	movs	r0, #0
 c048eee:	460b      	mov	r3, r1
 c048ef0:	688a      	ldr	r2, [r1, #8]
 c048ef2:	42aa      	cmp	r2, r5
 c048ef4:	d102      	bne.n	c048efc <psa_get_and_lock_key_slot_in_memory+0x5c>
 c048ef6:	68ca      	ldr	r2, [r1, #12]
 c048ef8:	4296      	cmp	r6, r2
 c048efa:	d007      	beq.n	c048f0c <psa_get_and_lock_key_slot_in_memory+0x6c>
 c048efc:	3001      	adds	r0, #1
 c048efe:	2820      	cmp	r0, #32
 c048f00:	f101 012c 	add.w	r1, r1, #44	@ 0x2c
 c048f04:	d1f4      	bne.n	c048ef0 <psa_get_and_lock_key_slot_in_memory+0x50>
                 PSA_SUCCESS : PSA_ERROR_DOES_NOT_EXIST;
 c048f06:	f06f 008b 	mvn.w	r0, #139	@ 0x8b
 c048f0a:	e7e6      	b.n	c048eda <psa_get_and_lock_key_slot_in_memory+0x3a>
            slot = &global_data.key_slots[ slot_idx ];
 c048f0c:	222c      	movs	r2, #44	@ 0x2c
 c048f0e:	fb02 3300 	mla	r3, r2, r0, r3
 c048f12:	e7db      	b.n	c048ecc <psa_get_and_lock_key_slot_in_memory+0x2c>
            return( PSA_ERROR_INVALID_HANDLE );
 c048f14:	f06f 0087 	mvn.w	r0, #135	@ 0x87
 c048f18:	e7df      	b.n	c048eda <psa_get_and_lock_key_slot_in_memory+0x3a>
        return( PSA_ERROR_CORRUPTION_DETECTED );
 c048f1a:	f06f 0096 	mvn.w	r0, #150	@ 0x96
 c048f1e:	e7dc      	b.n	c048eda <psa_get_and_lock_key_slot_in_memory+0x3a>
 c048f20:	30031290 	.word	0x30031290

0c048f24 <psa_initialize_key_slots>:
psa_status_t psa_initialize_key_slots( void )
{
    /* Nothing to do: program startup and psa_wipe_all_key_slots() both
     * guarantee that the key slots are initialized to all-zero, which
     * means that all the key slots are in a valid, empty state. */
    global_data.key_slots_initialized = 1;
 c048f24:	4a04      	ldr	r2, [pc, #16]	@ (c048f38 <psa_initialize_key_slots+0x14>)
    return( PSA_SUCCESS );
}
 c048f26:	2000      	movs	r0, #0
    global_data.key_slots_initialized = 1;
 c048f28:	f892 3580 	ldrb.w	r3, [r2, #1408]	@ 0x580
 c048f2c:	f043 0301 	orr.w	r3, r3, #1
 c048f30:	f882 3580 	strb.w	r3, [r2, #1408]	@ 0x580
}
 c048f34:	4770      	bx	lr
 c048f36:	bf00      	nop
 c048f38:	30031290 	.word	0x30031290

0c048f3c <psa_wipe_all_key_slots>:

void psa_wipe_all_key_slots( void )
{
 c048f3c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 c048f3e:	4c09      	ldr	r4, [pc, #36]	@ (c048f64 <psa_wipe_all_key_slots+0x28>)
 c048f40:	2520      	movs	r5, #32
 c048f42:	4626      	mov	r6, r4
    size_t slot_idx;

    for( slot_idx = 0; slot_idx < MBEDTLS_PSA_KEY_SLOT_COUNT; slot_idx++ )
    {
        psa_key_slot_t *slot = &global_data.key_slots[ slot_idx ];
        slot->lock_count = 1;
 c048f44:	2701      	movs	r7, #1
        (void) psa_wipe_key_slot( slot );
 c048f46:	4620      	mov	r0, r4
        slot->lock_count = 1;
 c048f48:	6227      	str	r7, [r4, #32]
        (void) psa_wipe_key_slot( slot );
 c048f4a:	f7fc f8db 	bl	c045104 <psa_wipe_key_slot>
    for( slot_idx = 0; slot_idx < MBEDTLS_PSA_KEY_SLOT_COUNT; slot_idx++ )
 c048f4e:	3d01      	subs	r5, #1
 c048f50:	f104 042c 	add.w	r4, r4, #44	@ 0x2c
 c048f54:	d1f7      	bne.n	c048f46 <psa_wipe_all_key_slots+0xa>
    }
    global_data.key_slots_initialized = 0;
 c048f56:	f896 3580 	ldrb.w	r3, [r6, #1408]	@ 0x580
 c048f5a:	f365 0300 	bfi	r3, r5, #0, #1
 c048f5e:	f886 3580 	strb.w	r3, [r6, #1408]	@ 0x580
}
 c048f62:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 c048f64:	30031290 	.word	0x30031290

0c048f68 <psa_get_empty_key_slot>:

psa_status_t psa_get_empty_key_slot( psa_key_id_t *volatile_key_id,
                                     psa_key_slot_t **p_slot )
{
 c048f68:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
    size_t slot_idx;
    psa_key_slot_t *selected_slot, *unlocked_persistent_key_slot;

    if( ! global_data.key_slots_initialized )
 c048f6a:	4c1e      	ldr	r4, [pc, #120]	@ (c048fe4 <psa_get_empty_key_slot+0x7c>)
{
 c048f6c:	4606      	mov	r6, r0
    if( ! global_data.key_slots_initialized )
 c048f6e:	f894 3580 	ldrb.w	r3, [r4, #1408]	@ 0x580
{
 c048f72:	460f      	mov	r7, r1
    if( ! global_data.key_slots_initialized )
 c048f74:	07d8      	lsls	r0, r3, #31
 c048f76:	d52b      	bpl.n	c048fd0 <psa_get_empty_key_slot+0x68>
    {
        status = PSA_ERROR_BAD_STATE;
        goto error;
    }

    selected_slot = unlocked_persistent_key_slot = NULL;
 c048f78:	2500      	movs	r5, #0
 c048f7a:	4623      	mov	r3, r4
    for( slot_idx = 0; slot_idx < MBEDTLS_PSA_KEY_SLOT_COUNT; slot_idx++ )
 c048f7c:	4629      	mov	r1, r5
    {
        psa_key_slot_t *slot = &global_data.key_slots[ slot_idx ];
        if( ! psa_is_key_slot_occupied( slot ) )
 c048f7e:	8818      	ldrh	r0, [r3, #0]
        psa_key_slot_t *slot = &global_data.key_slots[ slot_idx ];
 c048f80:	461a      	mov	r2, r3
        if( ! psa_is_key_slot_occupied( slot ) )
 c048f82:	b1a8      	cbz	r0, c048fb0 <psa_get_empty_key_slot+0x48>
        {
            selected_slot = slot;
            break;
        }

        if( ( unlocked_persistent_key_slot == NULL ) &&
 c048f84:	b92d      	cbnz	r5, c048f92 <psa_get_empty_key_slot+0x2a>
 c048f86:	791a      	ldrb	r2, [r3, #4]
 c048f88:	b11a      	cbz	r2, c048f92 <psa_get_empty_key_slot+0x2a>
            ( ! PSA_KEY_LIFETIME_IS_VOLATILE( slot->attr.lifetime ) ) &&
 c048f8a:	6a1a      	ldr	r2, [r3, #32]
        psa_key_slot_t *slot = &global_data.key_slots[ slot_idx ];
 c048f8c:	2a00      	cmp	r2, #0
 c048f8e:	bf08      	it	eq
 c048f90:	461d      	moveq	r5, r3
    for( slot_idx = 0; slot_idx < MBEDTLS_PSA_KEY_SLOT_COUNT; slot_idx++ )
 c048f92:	3101      	adds	r1, #1
 c048f94:	2920      	cmp	r1, #32
 c048f96:	f103 032c 	add.w	r3, r3, #44	@ 0x2c
 c048f9a:	d1f0      	bne.n	c048f7e <psa_get_empty_key_slot+0x16>
     * slot containing the description of a persistent key, recycle the first
     * such key slot we encountered. If we later need to operate on the
     * persistent key we are evicting now, we will reload its description from
     * storage.
     */
    if( ( selected_slot == NULL ) &&
 c048f9c:	b915      	cbnz	r5, c048fa4 <psa_get_empty_key_slot+0x3c>
            ( (psa_key_id_t)( selected_slot - global_data.key_slots ) );
        *p_slot = selected_slot;

        return( PSA_SUCCESS );
    }
    status = PSA_ERROR_INSUFFICIENT_MEMORY;
 c048f9e:	f06f 008c 	mvn.w	r0, #140	@ 0x8c
 c048fa2:	e017      	b.n	c048fd4 <psa_get_empty_key_slot+0x6c>
        selected_slot->lock_count = 1;
 c048fa4:	2301      	movs	r3, #1
        psa_wipe_key_slot( selected_slot );
 c048fa6:	4628      	mov	r0, r5
        selected_slot->lock_count = 1;
 c048fa8:	622b      	str	r3, [r5, #32]
        psa_wipe_key_slot( selected_slot );
 c048faa:	f7fc f8ab 	bl	c045104 <psa_wipe_key_slot>
 c048fae:	462a      	mov	r2, r5
    if( slot->lock_count >= SIZE_MAX )
 c048fb0:	6a13      	ldr	r3, [r2, #32]
 c048fb2:	1c59      	adds	r1, r3, #1
 c048fb4:	d012      	beq.n	c048fdc <psa_get_empty_key_slot+0x74>
        return( PSA_SUCCESS );
 c048fb6:	2000      	movs	r0, #0
    slot->lock_count++;
 c048fb8:	3301      	adds	r3, #1
 c048fba:	6213      	str	r3, [r2, #32]
            ( (psa_key_id_t)( selected_slot - global_data.key_slots ) );
 c048fbc:	1b14      	subs	r4, r2, r4
 c048fbe:	4b0a      	ldr	r3, [pc, #40]	@ (c048fe8 <psa_get_empty_key_slot+0x80>)
 c048fc0:	10a4      	asrs	r4, r4, #2
 c048fc2:	435c      	muls	r4, r3
        *volatile_key_id = PSA_KEY_ID_VOLATILE_MIN +
 c048fc4:	f104 4400 	add.w	r4, r4, #2147483648	@ 0x80000000
 c048fc8:	3c20      	subs	r4, #32
 c048fca:	6034      	str	r4, [r6, #0]
        *p_slot = selected_slot;
 c048fcc:	603a      	str	r2, [r7, #0]
error:
    *p_slot = NULL;
    *volatile_key_id = 0;

    return( status );
}
 c048fce:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        status = PSA_ERROR_BAD_STATE;
 c048fd0:	f06f 0088 	mvn.w	r0, #136	@ 0x88
    *p_slot = NULL;
 c048fd4:	2300      	movs	r3, #0
 c048fd6:	603b      	str	r3, [r7, #0]
    *volatile_key_id = 0;
 c048fd8:	6033      	str	r3, [r6, #0]
    return( status );
 c048fda:	e7f8      	b.n	c048fce <psa_get_empty_key_slot+0x66>
        return( PSA_ERROR_CORRUPTION_DETECTED );
 c048fdc:	f06f 0096 	mvn.w	r0, #150	@ 0x96
 c048fe0:	e7f8      	b.n	c048fd4 <psa_get_empty_key_slot+0x6c>
 c048fe2:	bf00      	nop
 c048fe4:	30031290 	.word	0x30031290
 c048fe8:	ba2e8ba3 	.word	0xba2e8ba3

0c048fec <psa_get_and_lock_key_slot>:
}
#endif /* MBEDTLS_PSA_CRYPTO_BUILTIN_KEYS */

psa_status_t psa_get_and_lock_key_slot( mbedtls_svc_key_id_t key,
                                        psa_key_slot_t **p_slot )
{
 c048fec:	b5f0      	push	{r4, r5, r6, r7, lr}
    psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;

    *p_slot = NULL;
 c048fee:	2300      	movs	r3, #0
{
 c048ff0:	b089      	sub	sp, #36	@ 0x24
 c048ff2:	466d      	mov	r5, sp
    *p_slot = NULL;
 c048ff4:	6013      	str	r3, [r2, #0]
    if( ! global_data.key_slots_initialized )
 c048ff6:	4b2e      	ldr	r3, [pc, #184]	@ (c0490b0 <psa_get_and_lock_key_slot+0xc4>)
{
 c048ff8:	4616      	mov	r6, r2
    if( ! global_data.key_slots_initialized )
 c048ffa:	f893 3580 	ldrb.w	r3, [r3, #1408]	@ 0x580
{
 c048ffe:	e885 0003 	stmia.w	r5, {r0, r1}
    if( ! global_data.key_slots_initialized )
 c049002:	07dc      	lsls	r4, r3, #31
 c049004:	d551      	bpl.n	c0490aa <psa_get_and_lock_key_slot+0xbe>

    /*
     * On success, the pointer to the slot is passed directly to the caller
     * thus no need to unlock the key slot here.
     */
    status = psa_get_and_lock_key_slot_in_memory( key, p_slot );
 c049006:	e895 0003 	ldmia.w	r5, {r0, r1}
 c04900a:	f7ff ff49 	bl	c048ea0 <psa_get_and_lock_key_slot_in_memory>
    if( status != PSA_ERROR_DOES_NOT_EXIST )
 c04900e:	f110 0f8c 	cmn.w	r0, #140	@ 0x8c
    status = psa_get_and_lock_key_slot_in_memory( key, p_slot );
 c049012:	4604      	mov	r4, r0
    if( status != PSA_ERROR_DOES_NOT_EXIST )
 c049014:	d132      	bne.n	c04907c <psa_get_and_lock_key_slot+0x90>
    /* Loading keys from storage requires support for such a mechanism */
#if defined(MBEDTLS_PSA_CRYPTO_STORAGE_C) || \
    defined(MBEDTLS_PSA_CRYPTO_BUILTIN_KEYS)
    psa_key_id_t volatile_key_id;

    status = psa_get_empty_key_slot( &volatile_key_id, p_slot );
 c049016:	4631      	mov	r1, r6
 c049018:	a803      	add	r0, sp, #12
 c04901a:	f7ff ffa5 	bl	c048f68 <psa_get_empty_key_slot>
    if( status != PSA_SUCCESS )
 c04901e:	4604      	mov	r4, r0
 c049020:	bb60      	cbnz	r0, c04907c <psa_get_and_lock_key_slot+0x90>
        return( status );

    (*p_slot)->attr.id = key;
 c049022:	e895 0003 	ldmia.w	r5, {r0, r1}
 c049026:	6837      	ldr	r7, [r6, #0]
    status = psa_load_persistent_key( &slot->attr,
 c049028:	aa05      	add	r2, sp, #20
    (*p_slot)->attr.id = key;
 c04902a:	f107 0308 	add.w	r3, r7, #8
 c04902e:	e883 0003 	stmia.w	r3, {r0, r1}
    (*p_slot)->attr.lifetime = PSA_KEY_LIFETIME_PERSISTENT;
 c049032:	2301      	movs	r3, #1
    status = psa_load_persistent_key( &slot->attr,
 c049034:	4638      	mov	r0, r7
    (*p_slot)->attr.lifetime = PSA_KEY_LIFETIME_PERSISTENT;
 c049036:	607b      	str	r3, [r7, #4]
    status = psa_load_persistent_key( &slot->attr,
 c049038:	a904      	add	r1, sp, #16
    size_t key_data_length = 0;
 c04903a:	e9cd 4404 	strd	r4, r4, [sp, #16]
    status = psa_load_persistent_key( &slot->attr,
 c04903e:	f000 f9cd 	bl	c0493dc <psa_load_persistent_key>
    if( status != PSA_SUCCESS )
 c049042:	4604      	mov	r4, r0
 c049044:	b968      	cbnz	r0, c049062 <psa_get_and_lock_key_slot+0x76>
    if( psa_get_se_driver( slot->attr.lifetime, &drv, &drv_context ) )
 c049046:	6878      	ldr	r0, [r7, #4]
 c049048:	aa07      	add	r2, sp, #28
 c04904a:	a906      	add	r1, sp, #24
 c04904c:	f7ff fe0c 	bl	c048c68 <psa_get_se_driver>
 c049050:	b1b8      	cbz	r0, c049082 <psa_get_and_lock_key_slot+0x96>
        if( key_data_length != sizeof( *data ) )
 c049052:	e9dd 1204 	ldrd	r1, r2, [sp, #16]
 c049056:	2a08      	cmp	r2, #8
 c049058:	d116      	bne.n	c049088 <psa_get_and_lock_key_slot+0x9c>
    status = psa_copy_key_material_into_slot( slot, key_data, key_data_length );
 c04905a:	4638      	mov	r0, r7
 c04905c:	f7fb ff51 	bl	c044f02 <psa_copy_key_material_into_slot>
 c049060:	4604      	mov	r4, r0
    psa_free_persistent_key_data( key_data, key_data_length );
 c049062:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 c049066:	f000 f9af 	bl	c0493c8 <psa_free_persistent_key_data>
#if defined(MBEDTLS_PSA_CRYPTO_STORAGE_C)
    if( status == PSA_ERROR_DOES_NOT_EXIST )
        status = psa_load_persistent_key_into_slot( *p_slot );
#endif /* defined(MBEDTLS_PSA_CRYPTO_STORAGE_C) */

    if( status != PSA_SUCCESS )
 c04906a:	b184      	cbz	r4, c04908e <psa_get_and_lock_key_slot+0xa2>
    {
        psa_wipe_key_slot( *p_slot );
 c04906c:	6830      	ldr	r0, [r6, #0]
 c04906e:	f7fc f849 	bl	c045104 <psa_wipe_key_slot>
        if( status == PSA_ERROR_DOES_NOT_EXIST )
            status = PSA_ERROR_INVALID_HANDLE;
 c049072:	f114 0f8c 	cmn.w	r4, #140	@ 0x8c
 c049076:	bf08      	it	eq
 c049078:	f06f 0487 	mvneq.w	r4, #135	@ 0x87

    return( status );
#else /* MBEDTLS_PSA_CRYPTO_STORAGE_C || MBEDTLS_PSA_CRYPTO_BUILTIN_KEYS */
    return( PSA_ERROR_INVALID_HANDLE );
#endif /* MBEDTLS_PSA_CRYPTO_STORAGE_C || MBEDTLS_PSA_CRYPTO_BUILTIN_KEYS */
}
 c04907c:	4620      	mov	r0, r4
 c04907e:	b009      	add	sp, #36	@ 0x24
 c049080:	bdf0      	pop	{r4, r5, r6, r7, pc}
    status = psa_copy_key_material_into_slot( slot, key_data, key_data_length );
 c049082:	e9dd 1204 	ldrd	r1, r2, [sp, #16]
 c049086:	e7e8      	b.n	c04905a <psa_get_and_lock_key_slot+0x6e>
            status = PSA_ERROR_DATA_INVALID;
 c049088:	f06f 0498 	mvn.w	r4, #152	@ 0x98
 c04908c:	e7e9      	b.n	c049062 <psa_get_and_lock_key_slot+0x76>
        psa_extend_key_usage_flags( &(*p_slot)->attr.policy.usage );
 c04908e:	6833      	ldr	r3, [r6, #0]
    if( *usage_flags & PSA_KEY_USAGE_SIGN_HASH )
 c049090:	691a      	ldr	r2, [r3, #16]
 c049092:	04d0      	lsls	r0, r2, #19
        *usage_flags |= PSA_KEY_USAGE_SIGN_MESSAGE;
 c049094:	bf44      	itt	mi
 c049096:	f442 6280 	orrmi.w	r2, r2, #1024	@ 0x400
 c04909a:	611a      	strmi	r2, [r3, #16]
    if( *usage_flags & PSA_KEY_USAGE_VERIFY_HASH )
 c04909c:	691a      	ldr	r2, [r3, #16]
 c04909e:	0491      	lsls	r1, r2, #18
 c0490a0:	d5ec      	bpl.n	c04907c <psa_get_and_lock_key_slot+0x90>
        *usage_flags |= PSA_KEY_USAGE_VERIFY_MESSAGE;
 c0490a2:	f442 6200 	orr.w	r2, r2, #2048	@ 0x800
 c0490a6:	611a      	str	r2, [r3, #16]
 c0490a8:	e7e8      	b.n	c04907c <psa_get_and_lock_key_slot+0x90>
        return( PSA_ERROR_BAD_STATE );
 c0490aa:	f06f 0488 	mvn.w	r4, #136	@ 0x88
 c0490ae:	e7e5      	b.n	c04907c <psa_get_and_lock_key_slot+0x90>
 c0490b0:	30031290 	.word	0x30031290

0c0490b4 <psa_unlock_key_slot>:

psa_status_t psa_unlock_key_slot( psa_key_slot_t *slot )
{
    if( slot == NULL )
 c0490b4:	b118      	cbz	r0, c0490be <psa_unlock_key_slot+0xa>
        return( PSA_SUCCESS );

    if( slot->lock_count > 0 )
 c0490b6:	6a03      	ldr	r3, [r0, #32]
 c0490b8:	b11b      	cbz	r3, c0490c2 <psa_unlock_key_slot+0xe>
    {
        slot->lock_count--;
 c0490ba:	3b01      	subs	r3, #1
 c0490bc:	6203      	str	r3, [r0, #32]
        return( PSA_SUCCESS );
 c0490be:	2000      	movs	r0, #0
 c0490c0:	4770      	bx	lr
     */
#ifdef MBEDTLS_CHECK_PARAMS
    MBEDTLS_PARAM_FAILED( slot->lock_count > 0 );
#endif

    return( PSA_ERROR_CORRUPTION_DETECTED );
 c0490c2:	f06f 0096 	mvn.w	r0, #150	@ 0x96
}
 c0490c6:	4770      	bx	lr

0c0490c8 <psa_validate_key_location>:

psa_status_t psa_validate_key_location( psa_key_lifetime_t lifetime,
                                        psa_se_drv_table_entry_t **p_drv )
{
    if ( psa_key_lifetime_is_external( lifetime ) )
 c0490c8:	0a03      	lsrs	r3, r0, #8
{
 c0490ca:	b510      	push	{r4, lr}
 c0490cc:	460c      	mov	r4, r1
    if ( psa_key_lifetime_is_external( lifetime ) )
 c0490ce:	d101      	bne.n	c0490d4 <psa_validate_key_location+0xc>
        psa_se_drv_table_entry_t *driver = psa_get_se_driver_entry( lifetime );
        if( driver != NULL )
        {
            if (p_drv != NULL)
                *p_drv = driver;
            return( PSA_SUCCESS );
 c0490d0:	2000      	movs	r0, #0
#endif /* MBEDTLS_PSA_CRYPTO_DRIVERS */
    }
    else
        /* Local/internal keys are always valid */
        return( PSA_SUCCESS );
}
 c0490d2:	bd10      	pop	{r4, pc}
        psa_se_drv_table_entry_t *driver = psa_get_se_driver_entry( lifetime );
 c0490d4:	f7ff fdb2 	bl	c048c3c <psa_get_se_driver_entry>
        if( driver != NULL )
 c0490d8:	b118      	cbz	r0, c0490e2 <psa_validate_key_location+0x1a>
            if (p_drv != NULL)
 c0490da:	2c00      	cmp	r4, #0
 c0490dc:	d0f8      	beq.n	c0490d0 <psa_validate_key_location+0x8>
                *p_drv = driver;
 c0490de:	6020      	str	r0, [r4, #0]
 c0490e0:	e7f6      	b.n	c0490d0 <psa_validate_key_location+0x8>
        return( PSA_ERROR_INVALID_ARGUMENT );
 c0490e2:	f06f 0086 	mvn.w	r0, #134	@ 0x86
 c0490e6:	e7f4      	b.n	c0490d2 <psa_validate_key_location+0xa>

0c0490e8 <psa_validate_key_persistence>:
        return( PSA_SUCCESS );
#else /* MBEDTLS_PSA_CRYPTO_STORAGE_C */
        return( PSA_ERROR_NOT_SUPPORTED );
#endif /* !MBEDTLS_PSA_CRYPTO_STORAGE_C */
    }
}
 c0490e8:	2000      	movs	r0, #0
 c0490ea:	4770      	bx	lr

0c0490ec <mbedcrypto__psa_open_key>:

psa_status_t psa_open_key( mbedtls_svc_key_id_t key, psa_key_handle_t *handle )
{
 c0490ec:	b530      	push	{r4, r5, lr}
 c0490ee:	b085      	sub	sp, #20
 c0490f0:	466d      	mov	r5, sp
 c0490f2:	e885 0003 	stmia.w	r5, {r0, r1}
 c0490f6:	4614      	mov	r4, r2
#if defined(MBEDTLS_PSA_CRYPTO_STORAGE_C) || \
    defined(MBEDTLS_PSA_CRYPTO_BUILTIN_KEYS)
    psa_status_t status;
    psa_key_slot_t *slot;

    status = psa_get_and_lock_key_slot( key, &slot );
 c0490f8:	e895 0003 	ldmia.w	r5, {r0, r1}
 c0490fc:	aa03      	add	r2, sp, #12
 c0490fe:	f7ff ff75 	bl	c048fec <psa_get_and_lock_key_slot>
    if( status != PSA_SUCCESS )
 c049102:	b948      	cbnz	r0, c049118 <mbedcrypto__psa_open_key+0x2c>
            status = PSA_ERROR_DOES_NOT_EXIST;

        return( status );
    }

    *handle = key;
 c049104:	e895 0003 	ldmia.w	r5, {r0, r1}
 c049108:	e884 0003 	stmia.w	r4, {r0, r1}

    return( psa_unlock_key_slot( slot ) );
 c04910c:	9803      	ldr	r0, [sp, #12]
#else /* MBEDTLS_PSA_CRYPTO_STORAGE_C || MBEDTLS_PSA_CRYPTO_BUILTIN_KEYS */
    (void) key;
    *handle = PSA_KEY_HANDLE_INIT;
    return( PSA_ERROR_NOT_SUPPORTED );
#endif /* MBEDTLS_PSA_CRYPTO_STORAGE_C || MBEDTLS_PSA_CRYPTO_BUILTIN_KEYS */
}
 c04910e:	b005      	add	sp, #20
 c049110:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    return( psa_unlock_key_slot( slot ) );
 c049114:	f7ff bfce 	b.w	c0490b4 <psa_unlock_key_slot>
            status = PSA_ERROR_DOES_NOT_EXIST;
 c049118:	f110 0f88 	cmn.w	r0, #136	@ 0x88
        *handle = PSA_KEY_HANDLE_INIT;
 c04911c:	f04f 0300 	mov.w	r3, #0
            status = PSA_ERROR_DOES_NOT_EXIST;
 c049120:	bf08      	it	eq
 c049122:	f06f 008b 	mvneq.w	r0, #139	@ 0x8b
        *handle = PSA_KEY_HANDLE_INIT;
 c049126:	e9c4 3300 	strd	r3, r3, [r4]
}
 c04912a:	b005      	add	sp, #20
 c04912c:	bd30      	pop	{r4, r5, pc}

0c04912e <mbedcrypto__psa_close_key>:

psa_status_t psa_close_key( psa_key_handle_t handle )
{
 c04912e:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 c049130:	466b      	mov	r3, sp
 c049132:	e883 0003 	stmia.w	r3, {r0, r1}
    psa_status_t status;
    psa_key_slot_t *slot;

    if( psa_key_handle_is_null( handle ) )
 c049136:	b150      	cbz	r0, c04914e <mbedcrypto__psa_close_key+0x20>
        return( PSA_SUCCESS );

    status = psa_get_and_lock_key_slot_in_memory( handle, &slot );
 c049138:	e893 0003 	ldmia.w	r3, {r0, r1}
 c04913c:	aa03      	add	r2, sp, #12
 c04913e:	f7ff feaf 	bl	c048ea0 <psa_get_and_lock_key_slot_in_memory>
    if( status != PSA_SUCCESS )
 c049142:	b138      	cbz	r0, c049154 <mbedcrypto__psa_close_key+0x26>
    {
        if( status == PSA_ERROR_DOES_NOT_EXIST )
            status = PSA_ERROR_INVALID_HANDLE;
 c049144:	f110 0f8c 	cmn.w	r0, #140	@ 0x8c
 c049148:	bf08      	it	eq
 c04914a:	f06f 0087 	mvneq.w	r0, #135	@ 0x87
    }
    if( slot->lock_count <= 1 )
        return( psa_wipe_key_slot( slot ) );
    else
        return( psa_unlock_key_slot( slot ) );
}
 c04914e:	b005      	add	sp, #20
 c049150:	f85d fb04 	ldr.w	pc, [sp], #4
    if( slot->lock_count <= 1 )
 c049154:	9803      	ldr	r0, [sp, #12]
 c049156:	6a03      	ldr	r3, [r0, #32]
 c049158:	2b01      	cmp	r3, #1
 c04915a:	d804      	bhi.n	c049166 <mbedcrypto__psa_close_key+0x38>
}
 c04915c:	b005      	add	sp, #20
 c04915e:	f85d eb04 	ldr.w	lr, [sp], #4
        return( psa_wipe_key_slot( slot ) );
 c049162:	f7fb bfcf 	b.w	c045104 <psa_wipe_key_slot>
}
 c049166:	b005      	add	sp, #20
 c049168:	f85d eb04 	ldr.w	lr, [sp], #4
        return( psa_unlock_key_slot( slot ) );
 c04916c:	f7ff bfa2 	b.w	c0490b4 <psa_unlock_key_slot>

0c049170 <mbedcrypto__psa_purge_key>:

psa_status_t psa_purge_key( mbedtls_svc_key_id_t key )
{
 c049170:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 c049172:	466b      	mov	r3, sp
 c049174:	e883 0003 	stmia.w	r3, {r0, r1}
    psa_status_t status;
    psa_key_slot_t *slot;

    status = psa_get_and_lock_key_slot_in_memory( key, &slot );
 c049178:	aa03      	add	r2, sp, #12
 c04917a:	e893 0003 	ldmia.w	r3, {r0, r1}
 c04917e:	f7ff fe8f 	bl	c048ea0 <psa_get_and_lock_key_slot_in_memory>
    if( status != PSA_SUCCESS )
 c049182:	b978      	cbnz	r0, c0491a4 <mbedcrypto__psa_purge_key+0x34>
        return( status );

    if( ( ! PSA_KEY_LIFETIME_IS_VOLATILE( slot->attr.lifetime ) ) &&
 c049184:	9803      	ldr	r0, [sp, #12]
 c049186:	7903      	ldrb	r3, [r0, #4]
 c049188:	b13b      	cbz	r3, c04919a <mbedcrypto__psa_purge_key+0x2a>
 c04918a:	6a03      	ldr	r3, [r0, #32]
 c04918c:	2b01      	cmp	r3, #1
 c04918e:	d804      	bhi.n	c04919a <mbedcrypto__psa_purge_key+0x2a>
        ( slot->lock_count <= 1 ) )
        return( psa_wipe_key_slot( slot ) );
    else
        return( psa_unlock_key_slot( slot ) );
}
 c049190:	b005      	add	sp, #20
 c049192:	f85d eb04 	ldr.w	lr, [sp], #4
        return( psa_wipe_key_slot( slot ) );
 c049196:	f7fb bfb5 	b.w	c045104 <psa_wipe_key_slot>
}
 c04919a:	b005      	add	sp, #20
 c04919c:	f85d eb04 	ldr.w	lr, [sp], #4
        return( psa_unlock_key_slot( slot ) );
 c0491a0:	f7ff bf88 	b.w	c0490b4 <psa_unlock_key_slot>
}
 c0491a4:	b005      	add	sp, #20
 c0491a6:	f85d fb04 	ldr.w	pc, [sp], #4

0c0491aa <psa_is_key_present_in_storage>:

    return( status );
}

int psa_is_key_present_in_storage( const mbedtls_svc_key_id_t key )
{
 c0491aa:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
 c0491ac:	466b      	mov	r3, sp
    psa_status_t ret;
    psa_storage_uid_t data_identifier = psa_its_identifier_of_slot( key );
    struct psa_storage_info_t data_identifier_info;

    ret = psa_its_get_info( data_identifier, &data_identifier_info );
 c0491ae:	aa03      	add	r2, sp, #12
{
 c0491b0:	e883 0003 	stmia.w	r3, {r0, r1}
    ret = psa_its_get_info( data_identifier, &data_identifier_info );
 c0491b4:	f7f3 fa9d 	bl	c03c6f2 <psa_its_get_info>

    if( ret == PSA_ERROR_DOES_NOT_EXIST )
        return( 0 );
    return( 1 );
}
 c0491b8:	308c      	adds	r0, #140	@ 0x8c
 c0491ba:	bf18      	it	ne
 c0491bc:	2001      	movne	r0, #1
 c0491be:	b007      	add	sp, #28
 c0491c0:	f85d fb04 	ldr.w	pc, [sp], #4

0c0491c4 <psa_destroy_persistent_key>:
    }
    return( status );
}

psa_status_t psa_destroy_persistent_key( const mbedtls_svc_key_id_t key )
{
 c0491c4:	b530      	push	{r4, r5, lr}
 c0491c6:	b087      	sub	sp, #28
 c0491c8:	466b      	mov	r3, sp
    psa_status_t ret;
    psa_storage_uid_t data_identifier = psa_its_identifier_of_slot( key );
    struct psa_storage_info_t data_identifier_info;

    ret = psa_its_get_info( data_identifier, &data_identifier_info );
 c0491ca:	aa03      	add	r2, sp, #12
    return(  ( (uint64_t) unsigned_owner_id << 32 ) |
 c0491cc:	4605      	mov	r5, r0
 c0491ce:	460c      	mov	r4, r1
{
 c0491d0:	e883 0003 	stmia.w	r3, {r0, r1}
    ret = psa_its_get_info( data_identifier, &data_identifier_info );
 c0491d4:	f7f3 fa8d 	bl	c03c6f2 <psa_its_get_info>
    if( ret == PSA_ERROR_DOES_NOT_EXIST )
 c0491d8:	308c      	adds	r0, #140	@ 0x8c
 c0491da:	d102      	bne.n	c0491e2 <psa_destroy_persistent_key+0x1e>
        return( PSA_SUCCESS );
 c0491dc:	2000      	movs	r0, #0
    ret = psa_its_get_info( data_identifier, &data_identifier_info );
    if( ret != PSA_ERROR_DOES_NOT_EXIST )
        return( PSA_ERROR_DATA_INVALID );

    return( PSA_SUCCESS );
}
 c0491de:	b007      	add	sp, #28
 c0491e0:	bd30      	pop	{r4, r5, pc}
    if( psa_its_remove( data_identifier ) != PSA_SUCCESS )
 c0491e2:	4628      	mov	r0, r5
 c0491e4:	4621      	mov	r1, r4
 c0491e6:	f7f3 faa7 	bl	c03c738 <psa_its_remove>
 c0491ea:	b110      	cbz	r0, c0491f2 <psa_destroy_persistent_key+0x2e>
        return( PSA_ERROR_DATA_INVALID );
 c0491ec:	f06f 0098 	mvn.w	r0, #152	@ 0x98
 c0491f0:	e7f5      	b.n	c0491de <psa_destroy_persistent_key+0x1a>
    ret = psa_its_get_info( data_identifier, &data_identifier_info );
 c0491f2:	4628      	mov	r0, r5
 c0491f4:	4621      	mov	r1, r4
 c0491f6:	aa03      	add	r2, sp, #12
 c0491f8:	f7f3 fa7b 	bl	c03c6f2 <psa_its_get_info>
    if( ret != PSA_ERROR_DOES_NOT_EXIST )
 c0491fc:	308c      	adds	r0, #140	@ 0x8c
 c0491fe:	d0ed      	beq.n	c0491dc <psa_destroy_persistent_key+0x18>
 c049200:	e7f4      	b.n	c0491ec <psa_destroy_persistent_key+0x28>
	...

0c049204 <psa_format_key_data_for_storage>:

void psa_format_key_data_for_storage( const uint8_t *data,
                                      const size_t data_length,
                                      const psa_core_key_attributes_t *attr,
                                      uint8_t *storage_data )
{
 c049204:	b430      	push	{r4, r5}
    psa_persistent_key_storage_format *storage_format =
        (psa_persistent_key_storage_format *) storage_data;

    memcpy( storage_format->magic, PSA_KEY_STORAGE_MAGIC_HEADER, PSA_KEY_STORAGE_MAGIC_HEADER_LENGTH );
 c049206:	4d22      	ldr	r5, [pc, #136]	@ (c049290 <psa_format_key_data_for_storage+0x8c>)
 c049208:	682c      	ldr	r4, [r5, #0]
 c04920a:	601c      	str	r4, [r3, #0]
 c04920c:	686c      	ldr	r4, [r5, #4]
 c04920e:	605c      	str	r4, [r3, #4]
    MBEDTLS_PUT_UINT32_LE( 0, storage_format->version, 0 );
 c049210:	2400      	movs	r4, #0
 c049212:	721c      	strb	r4, [r3, #8]
 c049214:	725c      	strb	r4, [r3, #9]
 c049216:	729c      	strb	r4, [r3, #10]
 c049218:	72dc      	strb	r4, [r3, #11]
    MBEDTLS_PUT_UINT32_LE( attr->lifetime, storage_format->lifetime, 0 );
 c04921a:	6854      	ldr	r4, [r2, #4]
 c04921c:	0a25      	lsrs	r5, r4, #8
 c04921e:	731c      	strb	r4, [r3, #12]
 c049220:	735d      	strb	r5, [r3, #13]
 c049222:	0c25      	lsrs	r5, r4, #16
 c049224:	0e24      	lsrs	r4, r4, #24
 c049226:	739d      	strb	r5, [r3, #14]
 c049228:	73dc      	strb	r4, [r3, #15]
    MBEDTLS_PUT_UINT16_LE( (uint16_t) attr->type, storage_format->type, 0 );
 c04922a:	8814      	ldrh	r4, [r2, #0]
 c04922c:	741c      	strb	r4, [r3, #16]
 c04922e:	0a24      	lsrs	r4, r4, #8
 c049230:	745c      	strb	r4, [r3, #17]
    MBEDTLS_PUT_UINT16_LE( (uint16_t) attr->bits, storage_format->bits, 0 );
 c049232:	8854      	ldrh	r4, [r2, #2]
 c049234:	749c      	strb	r4, [r3, #18]
 c049236:	0a24      	lsrs	r4, r4, #8
 c049238:	74dc      	strb	r4, [r3, #19]
    MBEDTLS_PUT_UINT32_LE( attr->policy.usage, storage_format->policy, 0 );
 c04923a:	6914      	ldr	r4, [r2, #16]
 c04923c:	0a25      	lsrs	r5, r4, #8
 c04923e:	751c      	strb	r4, [r3, #20]
 c049240:	755d      	strb	r5, [r3, #21]
 c049242:	0c25      	lsrs	r5, r4, #16
 c049244:	0e24      	lsrs	r4, r4, #24
 c049246:	759d      	strb	r5, [r3, #22]
 c049248:	75dc      	strb	r4, [r3, #23]
    MBEDTLS_PUT_UINT32_LE( attr->policy.alg, storage_format->policy, sizeof( uint32_t ) );
 c04924a:	6954      	ldr	r4, [r2, #20]
 c04924c:	0a25      	lsrs	r5, r4, #8
 c04924e:	761c      	strb	r4, [r3, #24]
 c049250:	765d      	strb	r5, [r3, #25]
 c049252:	0c25      	lsrs	r5, r4, #16
 c049254:	0e24      	lsrs	r4, r4, #24
 c049256:	769d      	strb	r5, [r3, #26]
 c049258:	76dc      	strb	r4, [r3, #27]
    MBEDTLS_PUT_UINT32_LE( attr->policy.alg2, storage_format->policy, 2 * sizeof( uint32_t ) );
 c04925a:	6992      	ldr	r2, [r2, #24]
 c04925c:	0a14      	lsrs	r4, r2, #8
 c04925e:	771a      	strb	r2, [r3, #28]
 c049260:	775c      	strb	r4, [r3, #29]
 c049262:	0c14      	lsrs	r4, r2, #16
 c049264:	0e12      	lsrs	r2, r2, #24
 c049266:	77da      	strb	r2, [r3, #31]
    MBEDTLS_PUT_UINT32_LE( data_length, storage_format->data_len, 0 );
 c049268:	0a0a      	lsrs	r2, r1, #8
 c04926a:	f883 2021 	strb.w	r2, [r3, #33]	@ 0x21
 c04926e:	0c0a      	lsrs	r2, r1, #16
 c049270:	f883 2022 	strb.w	r2, [r3, #34]	@ 0x22
 c049274:	0e0a      	lsrs	r2, r1, #24
    MBEDTLS_PUT_UINT32_LE( attr->policy.alg2, storage_format->policy, 2 * sizeof( uint32_t ) );
 c049276:	779c      	strb	r4, [r3, #30]
    MBEDTLS_PUT_UINT32_LE( data_length, storage_format->data_len, 0 );
 c049278:	f883 1020 	strb.w	r1, [r3, #32]
 c04927c:	f883 2023 	strb.w	r2, [r3, #35]	@ 0x23
    memcpy( storage_format->key_data, data, data_length );
}
 c049280:	bc30      	pop	{r4, r5}
    memcpy( storage_format->key_data, data, data_length );
 c049282:	460a      	mov	r2, r1
 c049284:	4601      	mov	r1, r0
 c049286:	f103 0024 	add.w	r0, r3, #36	@ 0x24
 c04928a:	f012 b9df 	b.w	c05b64c <memcpy>
 c04928e:	bf00      	nop
 c049290:	0c060eb8 	.word	0x0c060eb8

0c049294 <psa_parse_key_data_from_storage>:
psa_status_t psa_parse_key_data_from_storage( const uint8_t *storage_data,
                                              size_t storage_data_length,
                                              uint8_t **key_data,
                                              size_t *key_data_length,
                                              psa_core_key_attributes_t *attr )
{
 c049294:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    psa_status_t status;
    const psa_persistent_key_storage_format *storage_format =
        (const psa_persistent_key_storage_format *)storage_data;
    uint32_t version;

    if( storage_data_length < sizeof(*storage_format) )
 c049298:	2923      	cmp	r1, #35	@ 0x23
{
 c04929a:	4604      	mov	r4, r0
 c04929c:	460f      	mov	r7, r1
 c04929e:	4691      	mov	r9, r2
 c0492a0:	4698      	mov	r8, r3
 c0492a2:	9e08      	ldr	r6, [sp, #32]
    if( storage_data_length < sizeof(*storage_format) )
 c0492a4:	d804      	bhi.n	c0492b0 <psa_parse_key_data_from_storage+0x1c>
        return( PSA_ERROR_DATA_INVALID );
 c0492a6:	f06f 0598 	mvn.w	r5, #152	@ 0x98
    attr->policy.usage = MBEDTLS_GET_UINT32_LE( storage_format->policy, 0 );
    attr->policy.alg = MBEDTLS_GET_UINT32_LE( storage_format->policy, sizeof( uint32_t ) );
    attr->policy.alg2 = MBEDTLS_GET_UINT32_LE( storage_format->policy, 2 * sizeof( uint32_t ) );

    return( PSA_SUCCESS );
}
 c0492aa:	4628      	mov	r0, r5
 c0492ac:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    if( memcmp( data, PSA_KEY_STORAGE_MAGIC_HEADER,
 c0492b0:	2208      	movs	r2, #8
 c0492b2:	4919      	ldr	r1, [pc, #100]	@ (c049318 <psa_parse_key_data_from_storage+0x84>)
 c0492b4:	f012 f9ba 	bl	c05b62c <memcmp>
 c0492b8:	4605      	mov	r5, r0
 c0492ba:	2800      	cmp	r0, #0
 c0492bc:	d1f3      	bne.n	c0492a6 <psa_parse_key_data_from_storage+0x12>
    version = MBEDTLS_GET_UINT32_LE( storage_format->version, 0 );
 c0492be:	68a3      	ldr	r3, [r4, #8]
    if( version != 0 )
 c0492c0:	2b00      	cmp	r3, #0
 c0492c2:	d1f0      	bne.n	c0492a6 <psa_parse_key_data_from_storage+0x12>
    *key_data_length = MBEDTLS_GET_UINT32_LE( storage_format->data_len, 0 );
 c0492c4:	6a21      	ldr	r1, [r4, #32]
    if( *key_data_length > ( storage_data_length - sizeof(*storage_format) ) ||
 c0492c6:	3f24      	subs	r7, #36	@ 0x24
 c0492c8:	42b9      	cmp	r1, r7
    *key_data_length = MBEDTLS_GET_UINT32_LE( storage_format->data_len, 0 );
 c0492ca:	f8c8 1000 	str.w	r1, [r8]
    if( *key_data_length > ( storage_data_length - sizeof(*storage_format) ) ||
 c0492ce:	d8ea      	bhi.n	c0492a6 <psa_parse_key_data_from_storage+0x12>
 c0492d0:	f5b1 5f00 	cmp.w	r1, #8192	@ 0x2000
 c0492d4:	d2e7      	bcs.n	c0492a6 <psa_parse_key_data_from_storage+0x12>
    if( *key_data_length == 0 )
 c0492d6:	b971      	cbnz	r1, c0492f6 <psa_parse_key_data_from_storage+0x62>
        *key_data = NULL;
 c0492d8:	f8c9 0000 	str.w	r0, [r9]
    attr->lifetime = MBEDTLS_GET_UINT32_LE( storage_format->lifetime, 0 );
 c0492dc:	68e3      	ldr	r3, [r4, #12]
 c0492de:	6073      	str	r3, [r6, #4]
    attr->type = MBEDTLS_GET_UINT16_LE( storage_format->type, 0 );
 c0492e0:	8a23      	ldrh	r3, [r4, #16]
 c0492e2:	8033      	strh	r3, [r6, #0]
    attr->bits = MBEDTLS_GET_UINT16_LE( storage_format->bits, 0 );
 c0492e4:	8a63      	ldrh	r3, [r4, #18]
 c0492e6:	8073      	strh	r3, [r6, #2]
    attr->policy.usage = MBEDTLS_GET_UINT32_LE( storage_format->policy, 0 );
 c0492e8:	6963      	ldr	r3, [r4, #20]
 c0492ea:	6133      	str	r3, [r6, #16]
    attr->policy.alg = MBEDTLS_GET_UINT32_LE( storage_format->policy, sizeof( uint32_t ) );
 c0492ec:	69a3      	ldr	r3, [r4, #24]
 c0492ee:	6173      	str	r3, [r6, #20]
    attr->policy.alg2 = MBEDTLS_GET_UINT32_LE( storage_format->policy, 2 * sizeof( uint32_t ) );
 c0492f0:	69e3      	ldr	r3, [r4, #28]
 c0492f2:	61b3      	str	r3, [r6, #24]
    return( PSA_SUCCESS );
 c0492f4:	e7d9      	b.n	c0492aa <psa_parse_key_data_from_storage+0x16>
        *key_data = mbedtls_calloc( 1, *key_data_length );
 c0492f6:	2001      	movs	r0, #1
 c0492f8:	f7f2 f854 	bl	c03b3a4 <mbedtls_calloc>
 c0492fc:	f8c9 0000 	str.w	r0, [r9]
        if( *key_data == NULL )
 c049300:	b130      	cbz	r0, c049310 <psa_parse_key_data_from_storage+0x7c>
        memcpy( *key_data, storage_format->key_data, *key_data_length );
 c049302:	f8d8 2000 	ldr.w	r2, [r8]
 c049306:	f104 0124 	add.w	r1, r4, #36	@ 0x24
 c04930a:	f012 f99f 	bl	c05b64c <memcpy>
 c04930e:	e7e5      	b.n	c0492dc <psa_parse_key_data_from_storage+0x48>
            return( PSA_ERROR_INSUFFICIENT_MEMORY );
 c049310:	f06f 058c 	mvn.w	r5, #140	@ 0x8c
 c049314:	e7c9      	b.n	c0492aa <psa_parse_key_data_from_storage+0x16>
 c049316:	bf00      	nop
 c049318:	0c060eb8 	.word	0x0c060eb8

0c04931c <psa_save_persistent_key>:

psa_status_t psa_save_persistent_key( const psa_core_key_attributes_t *attr,
                                      const uint8_t *data,
                                      const size_t data_length )
{
 c04931c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 c049320:	4604      	mov	r4, r0
 c049322:	4616      	mov	r6, r2
    size_t storage_data_length;
    uint8_t *storage_data;
    psa_status_t status;

    /* All keys saved to persistent storage always have a key context */
    if( data == NULL || data_length == 0 )
 c049324:	460f      	mov	r7, r1
{
 c049326:	b088      	sub	sp, #32
    if( data == NULL || data_length == 0 )
 c049328:	2900      	cmp	r1, #0
 c04932a:	d044      	beq.n	c0493b6 <psa_save_persistent_key+0x9a>
 c04932c:	2a00      	cmp	r2, #0
 c04932e:	d042      	beq.n	c0493b6 <psa_save_persistent_key+0x9a>
        return( PSA_ERROR_INVALID_ARGUMENT );

    if( data_length > PSA_CRYPTO_MAX_STORAGE_SIZE )
 c049330:	f5b2 5f00 	cmp.w	r2, #8192	@ 0x2000
 c049334:	d242      	bcs.n	c0493bc <psa_save_persistent_key+0xa0>
        return( PSA_ERROR_INSUFFICIENT_STORAGE );
    storage_data_length = data_length + sizeof( psa_persistent_key_storage_format );
 c049336:	f102 0824 	add.w	r8, r2, #36	@ 0x24

    storage_data = mbedtls_calloc( 1, storage_data_length );
 c04933a:	4641      	mov	r1, r8
 c04933c:	2001      	movs	r0, #1
 c04933e:	f7f2 f831 	bl	c03b3a4 <mbedtls_calloc>
    if( storage_data == NULL )
 c049342:	4605      	mov	r5, r0
 c049344:	2800      	cmp	r0, #0
 c049346:	d03c      	beq.n	c0493c2 <psa_save_persistent_key+0xa6>
        return( PSA_ERROR_INSUFFICIENT_MEMORY );

    psa_format_key_data_for_storage( data, data_length, attr, storage_data );
 c049348:	4603      	mov	r3, r0
 c04934a:	4631      	mov	r1, r6
 c04934c:	4638      	mov	r0, r7
 c04934e:	4622      	mov	r2, r4
 c049350:	f7ff ff58 	bl	c049204 <psa_format_key_data_for_storage>

    status = psa_crypto_storage_store( attr->id,
 c049354:	e9d4 0102 	ldrd	r0, r1, [r4, #8]
 c049358:	ab03      	add	r3, sp, #12
    return(  ( (uint64_t) unsigned_owner_id << 32 ) |
 c04935a:	4607      	mov	r7, r0
 c04935c:	460e      	mov	r6, r1
 c04935e:	e883 0003 	stmia.w	r3, {r0, r1}
    if( psa_is_key_present_in_storage( key ) == 1 )
 c049362:	f7ff ff22 	bl	c0491aa <psa_is_key_present_in_storage>
 c049366:	2801      	cmp	r0, #1
 c049368:	d01f      	beq.n	c0493aa <psa_save_persistent_key+0x8e>
    status = psa_its_set( data_identifier, (uint32_t) data_length, data, 0 );
 c04936a:	2300      	movs	r3, #0
 c04936c:	4642      	mov	r2, r8
 c04936e:	9300      	str	r3, [sp, #0]
 c049370:	4638      	mov	r0, r7
 c049372:	462b      	mov	r3, r5
 c049374:	4631      	mov	r1, r6
 c049376:	f7f3 f967 	bl	c03c648 <psa_its_set>
    if( status != PSA_SUCCESS )
 c04937a:	b9c8      	cbnz	r0, c0493b0 <psa_save_persistent_key+0x94>
    status = psa_its_get_info( data_identifier, &data_identifier_info );
 c04937c:	4638      	mov	r0, r7
 c04937e:	4631      	mov	r1, r6
 c049380:	aa05      	add	r2, sp, #20
 c049382:	f7f3 f9b6 	bl	c03c6f2 <psa_its_get_info>
    if( status != PSA_SUCCESS )
 c049386:	4604      	mov	r4, r0
 c049388:	b920      	cbnz	r0, c049394 <psa_save_persistent_key+0x78>
    if( data_identifier_info.size != data_length )
 c04938a:	9b06      	ldr	r3, [sp, #24]
 c04938c:	4598      	cmp	r8, r3
 c04938e:	d005      	beq.n	c04939c <psa_save_persistent_key+0x80>
        status = PSA_ERROR_DATA_INVALID;
 c049390:	f06f 0498 	mvn.w	r4, #152	@ 0x98
        (void) psa_its_remove( data_identifier );
 c049394:	4638      	mov	r0, r7
 c049396:	4631      	mov	r1, r6
 c049398:	f7f3 f9ce 	bl	c03c738 <psa_its_remove>
                                       storage_data, storage_data_length );

    mbedtls_free( storage_data );
 c04939c:	4628      	mov	r0, r5
 c04939e:	f7f2 f807 	bl	c03b3b0 <mbedtls_free>

    return( status );
}
 c0493a2:	4620      	mov	r0, r4
 c0493a4:	b008      	add	sp, #32
 c0493a6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        return( PSA_ERROR_ALREADY_EXISTS );
 c0493aa:	f06f 048a 	mvn.w	r4, #138	@ 0x8a
 c0493ae:	e7f5      	b.n	c04939c <psa_save_persistent_key+0x80>
        return( PSA_ERROR_DATA_INVALID );
 c0493b0:	f06f 0498 	mvn.w	r4, #152	@ 0x98
 c0493b4:	e7f2      	b.n	c04939c <psa_save_persistent_key+0x80>
        return( PSA_ERROR_INVALID_ARGUMENT );
 c0493b6:	f06f 0486 	mvn.w	r4, #134	@ 0x86
 c0493ba:	e7f2      	b.n	c0493a2 <psa_save_persistent_key+0x86>
        return( PSA_ERROR_INSUFFICIENT_STORAGE );
 c0493bc:	f06f 048d 	mvn.w	r4, #141	@ 0x8d
 c0493c0:	e7ef      	b.n	c0493a2 <psa_save_persistent_key+0x86>
        return( PSA_ERROR_INSUFFICIENT_MEMORY );
 c0493c2:	f06f 048c 	mvn.w	r4, #140	@ 0x8c
 c0493c6:	e7ec      	b.n	c0493a2 <psa_save_persistent_key+0x86>

0c0493c8 <psa_free_persistent_key_data>:

void psa_free_persistent_key_data( uint8_t *key_data, size_t key_data_length )
{
 c0493c8:	b510      	push	{r4, lr}
    if( key_data != NULL )
 c0493ca:	4604      	mov	r4, r0
 c0493cc:	b108      	cbz	r0, c0493d2 <psa_free_persistent_key_data+0xa>
    {
        mbedtls_platform_zeroize( key_data, key_data_length );
 c0493ce:	f7f1 ffff 	bl	c03b3d0 <mbedtls_platform_zeroize>
    }
    mbedtls_free( key_data );
 c0493d2:	4620      	mov	r0, r4
}
 c0493d4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mbedtls_free( key_data );
 c0493d8:	f7f1 bfea 	b.w	c03b3b0 <mbedtls_free>

0c0493dc <psa_load_persistent_key>:

psa_status_t psa_load_persistent_key( psa_core_key_attributes_t *attr,
                                      uint8_t **data,
                                      size_t *data_length )
{
 c0493dc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c0493e0:	b087      	sub	sp, #28
    return(  ( (uint64_t) unsigned_owner_id << 32 ) |
 c0493e2:	e9d0 ba02 	ldrd	fp, sl, [r0, #8]
{
 c0493e6:	4606      	mov	r6, r0
 c0493e8:	4688      	mov	r8, r1
 c0493ea:	4617      	mov	r7, r2
    status = psa_its_get_info( data_identifier, &data_identifier_info );
 c0493ec:	4658      	mov	r0, fp
 c0493ee:	4651      	mov	r1, sl
 c0493f0:	aa03      	add	r2, sp, #12
 c0493f2:	f7f3 f97e 	bl	c03c6f2 <psa_its_get_info>
    if( status != PSA_SUCCESS )
 c0493f6:	4604      	mov	r4, r0
 c0493f8:	bb10      	cbnz	r0, c049440 <psa_load_persistent_key+0x64>
    *data_length = (size_t) data_identifier_info.size;
 c0493fa:	f8dd 9010 	ldr.w	r9, [sp, #16]

    status = psa_crypto_storage_get_data_length( key, &storage_data_length );
    if( status != PSA_SUCCESS )
        return( status );

    loaded_data = mbedtls_calloc( 1, storage_data_length );
 c0493fe:	2001      	movs	r0, #1
 c049400:	4649      	mov	r1, r9
 c049402:	f7f1 ffcf 	bl	c03b3a4 <mbedtls_calloc>

    if( loaded_data == NULL )
 c049406:	4605      	mov	r5, r0
 c049408:	2800      	cmp	r0, #0
 c04940a:	d035      	beq.n	c049478 <psa_load_persistent_key+0x9c>
    status = psa_its_get_info( data_identifier, &data_identifier_info );
 c04940c:	4658      	mov	r0, fp
 c04940e:	4651      	mov	r1, sl
 c049410:	aa03      	add	r2, sp, #12
    size_t data_length = 0;
 c049412:	9402      	str	r4, [sp, #8]
    status = psa_its_get_info( data_identifier, &data_identifier_info );
 c049414:	f7f3 f96d 	bl	c03c6f2 <psa_its_get_info>
    if( status  != PSA_SUCCESS )
 c049418:	4604      	mov	r4, r0
 c04941a:	b970      	cbnz	r0, c04943a <psa_load_persistent_key+0x5e>
    status = psa_its_get( data_identifier, 0, (uint32_t) data_size, data, &data_length );
 c04941c:	ab02      	add	r3, sp, #8
 c04941e:	4602      	mov	r2, r0
 c049420:	e9cd 5300 	strd	r5, r3, [sp]
 c049424:	4658      	mov	r0, fp
 c049426:	464b      	mov	r3, r9
 c049428:	4651      	mov	r1, sl
 c04942a:	f7f3 f932 	bl	c03c692 <psa_its_get>
    if( data_size  != data_length )
 c04942e:	9b02      	ldr	r3, [sp, #8]
    status = psa_its_get( data_identifier, 0, (uint32_t) data_size, data, &data_length );
 c049430:	4604      	mov	r4, r0
    if( data_size  != data_length )
 c049432:	4599      	cmp	r9, r3
 c049434:	d008      	beq.n	c049448 <psa_load_persistent_key+0x6c>
        return( PSA_ERROR_DATA_INVALID );
 c049436:	f06f 0498 	mvn.w	r4, #152	@ 0x98
    if( status == PSA_SUCCESS &&
        ( *data == NULL || *data_length == 0 ) )
        status = PSA_ERROR_STORAGE_FAILURE;

exit:
    mbedtls_free( loaded_data );
 c04943a:	4628      	mov	r0, r5
 c04943c:	f7f1 ffb8 	bl	c03b3b0 <mbedtls_free>
    return( status );
}
 c049440:	4620      	mov	r0, r4
 c049442:	b007      	add	sp, #28
 c049444:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if( status != PSA_SUCCESS )
 c049448:	2800      	cmp	r0, #0
 c04944a:	d1f6      	bne.n	c04943a <psa_load_persistent_key+0x5e>
    status = psa_parse_key_data_from_storage( loaded_data, storage_data_length,
 c04944c:	463b      	mov	r3, r7
 c04944e:	4642      	mov	r2, r8
 c049450:	4649      	mov	r1, r9
 c049452:	4628      	mov	r0, r5
 c049454:	9600      	str	r6, [sp, #0]
 c049456:	f7ff ff1d 	bl	c049294 <psa_parse_key_data_from_storage>
    if( status == PSA_SUCCESS &&
 c04945a:	4604      	mov	r4, r0
 c04945c:	2800      	cmp	r0, #0
 c04945e:	d1ec      	bne.n	c04943a <psa_load_persistent_key+0x5e>
 c049460:	f8d8 3000 	ldr.w	r3, [r8]
 c049464:	b12b      	cbz	r3, c049472 <psa_load_persistent_key+0x96>
        ( *data == NULL || *data_length == 0 ) )
 c049466:	683b      	ldr	r3, [r7, #0]
        status = PSA_ERROR_STORAGE_FAILURE;
 c049468:	2b00      	cmp	r3, #0
 c04946a:	bf08      	it	eq
 c04946c:	f06f 0491 	mvneq.w	r4, #145	@ 0x91
 c049470:	e7e3      	b.n	c04943a <psa_load_persistent_key+0x5e>
 c049472:	f06f 0491 	mvn.w	r4, #145	@ 0x91
 c049476:	e7e0      	b.n	c04943a <psa_load_persistent_key+0x5e>
        return( PSA_ERROR_INSUFFICIENT_MEMORY );
 c049478:	f06f 048c 	mvn.w	r4, #140	@ 0x8c
 c04947c:	e7e0      	b.n	c049440 <psa_load_persistent_key+0x64>
	...

0c049480 <psa_crypto_save_transaction>:
#if defined(PSA_CRYPTO_STORAGE_HAS_TRANSACTIONS)

psa_crypto_transaction_t psa_crypto_transaction;

psa_status_t psa_crypto_save_transaction( void )
{
 c049480:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    struct psa_storage_info_t p_info;
    psa_status_t status;
    status = psa_its_get_info( PSA_CRYPTO_ITS_TRANSACTION_UID, &p_info );
 c049482:	f06f 008b 	mvn.w	r0, #139	@ 0x8b
 c049486:	2100      	movs	r1, #0
 c049488:	aa03      	add	r2, sp, #12
 c04948a:	f7f3 f932 	bl	c03c6f2 <psa_its_get_info>
    if( status == PSA_SUCCESS )
 c04948e:	b170      	cbz	r0, c0494ae <psa_crypto_save_transaction+0x2e>
    {
        /* This shouldn't happen: we're trying to start a transaction while
         * there is still a transaction that hasn't been replayed. */
        return( PSA_ERROR_CORRUPTION_DETECTED );
    }
    else if( status != PSA_ERROR_DOES_NOT_EXIST )
 c049490:	f110 0f8c 	cmn.w	r0, #140	@ 0x8c
 c049494:	d108      	bne.n	c0494a8 <psa_crypto_save_transaction+0x28>
        return( status );
    return( psa_its_set( PSA_CRYPTO_ITS_TRANSACTION_UID,
 c049496:	2300      	movs	r3, #0
 c049498:	2218      	movs	r2, #24
 c04949a:	9300      	str	r3, [sp, #0]
 c04949c:	f06f 008b 	mvn.w	r0, #139	@ 0x8b
 c0494a0:	2100      	movs	r1, #0
 c0494a2:	4b04      	ldr	r3, [pc, #16]	@ (c0494b4 <psa_crypto_save_transaction+0x34>)
 c0494a4:	f7f3 f8d0 	bl	c03c648 <psa_its_set>
                         sizeof( psa_crypto_transaction ),
                         &psa_crypto_transaction,
                         0 ) );
}
 c0494a8:	b007      	add	sp, #28
 c0494aa:	f85d fb04 	ldr.w	pc, [sp], #4
        return( PSA_ERROR_CORRUPTION_DETECTED );
 c0494ae:	f06f 0096 	mvn.w	r0, #150	@ 0x96
 c0494b2:	e7f9      	b.n	c0494a8 <psa_crypto_save_transaction+0x28>
 c0494b4:	30031818 	.word	0x30031818

0c0494b8 <psa_crypto_load_transaction>:

psa_status_t psa_crypto_load_transaction( void )
{
 c0494b8:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    psa_status_t status;
    size_t length;
    status = psa_its_get( PSA_CRYPTO_ITS_TRANSACTION_UID, 0,
 c0494ba:	ab03      	add	r3, sp, #12
 c0494bc:	9301      	str	r3, [sp, #4]
 c0494be:	4b09      	ldr	r3, [pc, #36]	@ (c0494e4 <psa_crypto_load_transaction+0x2c>)
 c0494c0:	2200      	movs	r2, #0
 c0494c2:	9300      	str	r3, [sp, #0]
 c0494c4:	f06f 008b 	mvn.w	r0, #139	@ 0x8b
 c0494c8:	2318      	movs	r3, #24
 c0494ca:	2100      	movs	r1, #0
 c0494cc:	f7f3 f8e1 	bl	c03c692 <psa_its_get>
                          sizeof( psa_crypto_transaction ),
                          &psa_crypto_transaction, &length );
    if( status != PSA_SUCCESS )
 c0494d0:	b920      	cbnz	r0, c0494dc <psa_crypto_load_transaction+0x24>
        return( status );
    if( length != sizeof( psa_crypto_transaction ) )
 c0494d2:	9b03      	ldr	r3, [sp, #12]
        return( PSA_ERROR_DATA_INVALID );
 c0494d4:	2b18      	cmp	r3, #24
 c0494d6:	bf18      	it	ne
 c0494d8:	f06f 0098 	mvnne.w	r0, #152	@ 0x98
    return( PSA_SUCCESS );
}
 c0494dc:	b005      	add	sp, #20
 c0494de:	f85d fb04 	ldr.w	pc, [sp], #4
 c0494e2:	bf00      	nop
 c0494e4:	30031818 	.word	0x30031818

0c0494e8 <psa_crypto_stop_transaction>:

psa_status_t psa_crypto_stop_transaction( void )
{
 c0494e8:	b510      	push	{r4, lr}
    psa_status_t status = psa_its_remove( PSA_CRYPTO_ITS_TRANSACTION_UID );
 c0494ea:	2100      	movs	r1, #0
 c0494ec:	f06f 008b 	mvn.w	r0, #139	@ 0x8b
 c0494f0:	f7f3 f922 	bl	c03c738 <psa_its_remove>
 c0494f4:	4604      	mov	r4, r0
    /* Whether or not updating the storage succeeded, the transaction is
     * finished now. It's too late to go back, so zero out the in-memory
     * data. */
    memset( &psa_crypto_transaction, 0, sizeof( psa_crypto_transaction ) );
 c0494f6:	2218      	movs	r2, #24
 c0494f8:	2100      	movs	r1, #0
 c0494fa:	4802      	ldr	r0, [pc, #8]	@ (c049504 <psa_crypto_stop_transaction+0x1c>)
 c0494fc:	f012 f917 	bl	c05b72e <memset>
    return( status );
}
 c049500:	4620      	mov	r0, r4
 c049502:	bd10      	pop	{r4, pc}
 c049504:	30031818 	.word	0x30031818

0c049508 <ps_crypto_setkey>:
     */
    return PSA_SUCCESS;
}

psa_status_t ps_crypto_setkey(void)
{
 c049508:	b510      	push	{r4, lr}
 c04950a:	b088      	sub	sp, #32
    psa_status_t status;
    psa_key_attributes_t attributes = PSA_KEY_ATTRIBUTES_INIT;
 c04950c:	2100      	movs	r1, #0
 c04950e:	2218      	movs	r2, #24
 c049510:	a802      	add	r0, sp, #8
 c049512:	f012 f90c 	bl	c05b72e <memset>
    psa_key_derivation_operation_t op = PSA_KEY_DERIVATION_OPERATION_INIT;
 c049516:	2300      	movs	r3, #0
}

static inline void psa_set_key_algorithm(psa_key_attributes_t *attributes,
                                         psa_algorithm_t alg)
{
    attributes->alg = alg;
 c049518:	f44f 7140 	mov.w	r1, #768	@ 0x300
 c04951c:	9301      	str	r3, [sp, #4]
 c04951e:	4b14      	ldr	r3, [pc, #80]	@ (c049570 <ps_crypto_setkey+0x68>)
#else
    psa_set_key_bits(&attributes, PSA_BYTES_TO_BITS(PS_KEY_LEN_BYTES));
#endif

    /* Set up a key derivation operation with HUK derivation as the alg */
    status = psa_key_derivation_setup(&op, TFM_CRYPTO_ALG_HUK_DERIVATION);
 c049520:	a801      	add	r0, sp, #4
 c049522:	e9cd 3104 	strd	r3, r1, [sp, #16]
}

static inline void psa_set_key_type(psa_key_attributes_t *attributes,
                                    psa_key_type_t type)
{
    attributes->type = type;
 c049526:	f44f 5310 	mov.w	r3, #9216	@ 0x2400
 c04952a:	4912      	ldr	r1, [pc, #72]	@ (c049574 <ps_crypto_setkey+0x6c>)
 c04952c:	f8ad 301c 	strh.w	r3, [sp, #28]
 c049530:	f7f2 fffc 	bl	c03c52c <psa_key_derivation_setup>
    if (status != PSA_SUCCESS) {
 c049534:	b9d0      	cbnz	r0, c04956c <ps_crypto_setkey+0x64>
        return status;
    }

    /* Supply the PS key label as an input to the key derivation */
    status = psa_key_derivation_input_bytes(&op, PSA_KEY_DERIVATION_INPUT_LABEL,
 c049536:	230c      	movs	r3, #12
 c049538:	f240 2101 	movw	r1, #513	@ 0x201
 c04953c:	4a0e      	ldr	r2, [pc, #56]	@ (c049578 <ps_crypto_setkey+0x70>)
 c04953e:	a801      	add	r0, sp, #4
 c049540:	f7f3 f821 	bl	c03c586 <psa_key_derivation_input_bytes>
                                            ps_key_label,
                                            sizeof(ps_key_label));
    if (status != PSA_SUCCESS) {
 c049544:	b968      	cbnz	r0, c049562 <ps_crypto_setkey+0x5a>
        goto err_release_op;
    }

    /* Create the storage key from the key derivation operation */
    status = psa_key_derivation_output_key(&attributes, &op, &ps_key);
 c049546:	4c0d      	ldr	r4, [pc, #52]	@ (c04957c <ps_crypto_setkey+0x74>)
 c049548:	a901      	add	r1, sp, #4
 c04954a:	4622      	mov	r2, r4
 c04954c:	a802      	add	r0, sp, #8
 c04954e:	f7f3 f849 	bl	c03c5e4 <psa_key_derivation_output_key>
    if (status != PSA_SUCCESS) {
 c049552:	b930      	cbnz	r0, c049562 <ps_crypto_setkey+0x5a>
        goto err_release_op;
    }

    /* Free resources associated with the key derivation operation */
    status = psa_key_derivation_abort(&op);
 c049554:	a801      	add	r0, sp, #4
 c049556:	f7f2 ffbe 	bl	c03c4d6 <psa_key_derivation_abort>
    if (status != PSA_SUCCESS) {
 c04955a:	b138      	cbz	r0, c04956c <ps_crypto_setkey+0x64>
    }

    return PSA_SUCCESS;

err_release_key:
    (void)psa_destroy_key(ps_key);
 c04955c:	6820      	ldr	r0, [r4, #0]
 c04955e:	f7f2 fda3 	bl	c03c0a8 <psa_destroy_key>

err_release_op:
    (void)psa_key_derivation_abort(&op);
 c049562:	a801      	add	r0, sp, #4
 c049564:	f7f2 ffb7 	bl	c03c4d6 <psa_key_derivation_abort>

    return PSA_ERROR_GENERIC_ERROR;
 c049568:	f06f 0083 	mvn.w	r0, #131	@ 0x83
}
 c04956c:	b008      	add	sp, #32
 c04956e:	bd10      	pop	{r4, pc}
 c049570:	05500200 	.word	0x05500200
 c049574:	b0000f00 	.word	0xb0000f00
 c049578:	0c0615eb 	.word	0x0c0615eb
 c04957c:	3003f20c 	.word	0x3003f20c

0c049580 <ps_crypto_destroykey>:

psa_status_t ps_crypto_destroykey(void)
{
 c049580:	b508      	push	{r3, lr}
    psa_status_t status;

    /* Destroy the transient key */
    status = psa_destroy_key(ps_key);
 c049582:	4b04      	ldr	r3, [pc, #16]	@ (c049594 <ps_crypto_destroykey+0x14>)
 c049584:	6818      	ldr	r0, [r3, #0]
 c049586:	f7f2 fd8f 	bl	c03c0a8 <psa_destroy_key>
    if (status != PSA_SUCCESS) {
        return PSA_ERROR_GENERIC_ERROR;
 c04958a:	2800      	cmp	r0, #0
    }

    return PSA_SUCCESS;
}
 c04958c:	bf18      	it	ne
 c04958e:	f06f 0083 	mvnne.w	r0, #131	@ 0x83
 c049592:	bd08      	pop	{r3, pc}
 c049594:	3003f20c 	.word	0x3003f20c

0c049598 <ps_crypto_set_iv>:
    return (memcpy(dest, src, num));
 c049598:	4a03      	ldr	r2, [pc, #12]	@ (c0495a8 <ps_crypto_set_iv+0x10>)
 c04959a:	6903      	ldr	r3, [r0, #16]
 c04959c:	6013      	str	r3, [r2, #0]
 c04959e:	6943      	ldr	r3, [r0, #20]
 c0495a0:	6053      	str	r3, [r2, #4]
 c0495a2:	6983      	ldr	r3, [r0, #24]
 c0495a4:	6093      	str	r3, [r2, #8]

void ps_crypto_set_iv(const union ps_crypto_t *crypto)
{
    (void)tfm_memcpy(ps_crypto_iv_buf, crypto->ref.iv, PS_IV_LEN_BYTES);
}
 c0495a6:	4770      	bx	lr
 c0495a8:	3003f200 	.word	0x3003f200

0c0495ac <ps_crypto_get_iv>:

void ps_crypto_get_iv(union ps_crypto_t *crypto)
{
 c0495ac:	b530      	push	{r4, r5, lr}
 c0495ae:	4b0a      	ldr	r3, [pc, #40]	@ (c0495d8 <ps_crypto_get_iv+0x2c>)
 c0495b0:	681a      	ldr	r2, [r3, #0]
 c0495b2:	6859      	ldr	r1, [r3, #4]
    uint64_t iv_l;
    uint32_t iv_h;

    (void)tfm_memcpy(&iv_l, ps_crypto_iv_buf, sizeof(iv_l));
    (void)tfm_memcpy(&iv_h, (ps_crypto_iv_buf+sizeof(iv_l)), sizeof(iv_h));
    iv_l++;
 c0495b4:	3201      	adds	r2, #1
 c0495b6:	f141 0100 	adc.w	r1, r1, #0
 c0495ba:	601a      	str	r2, [r3, #0]
 c0495bc:	689c      	ldr	r4, [r3, #8]
    /* If overflow, increment the MSBs */
    if (iv_l == 0) {
 c0495be:	ea52 0501 	orrs.w	r5, r2, r1
 c0495c2:	681a      	ldr	r2, [r3, #0]
 c0495c4:	6059      	str	r1, [r3, #4]
        iv_h++;
 c0495c6:	bf08      	it	eq
 c0495c8:	3401      	addeq	r4, #1
 c0495ca:	6102      	str	r2, [r0, #16]
 c0495cc:	685a      	ldr	r2, [r3, #4]
 c0495ce:	609c      	str	r4, [r3, #8]
 c0495d0:	6142      	str	r2, [r0, #20]
 c0495d2:	689a      	ldr	r2, [r3, #8]
 c0495d4:	6182      	str	r2, [r0, #24]
    /* Update the local buffer */
    (void)tfm_memcpy(ps_crypto_iv_buf, &iv_l, sizeof(iv_l));
    (void)tfm_memcpy((ps_crypto_iv_buf + sizeof(iv_l)), &iv_h, sizeof(iv_h));
    /* Update the caller buffer */
    (void)tfm_memcpy(crypto->ref.iv, ps_crypto_iv_buf, PS_IV_LEN_BYTES);
}
 c0495d6:	bd30      	pop	{r4, r5, pc}
 c0495d8:	3003f200 	.word	0x3003f200

0c0495dc <ps_crypto_encrypt_and_tag>:
                                       const uint8_t *in,
                                       size_t in_len,
                                       uint8_t *out,
                                       size_t out_size,
                                       size_t *out_len)
{
 c0495dc:	b570      	push	{r4, r5, r6, lr}
 c0495de:	4605      	mov	r5, r0
 c0495e0:	b088      	sub	sp, #32
    psa_status_t status;

    status = psa_aead_encrypt(ps_key, PS_CRYPTO_ALG,
 c0495e2:	980e      	ldr	r0, [sp, #56]	@ 0x38
{
 c0495e4:	9c0d      	ldr	r4, [sp, #52]	@ 0x34
    status = psa_aead_encrypt(ps_key, PS_CRYPTO_ALG,
 c0495e6:	e9cd 1200 	strd	r1, r2, [sp]
 c0495ea:	e9cd 4004 	strd	r4, r0, [sp, #16]
 c0495ee:	980c      	ldr	r0, [sp, #48]	@ 0x30
{
 c0495f0:	9e0f      	ldr	r6, [sp, #60]	@ 0x3c
    status = psa_aead_encrypt(ps_key, PS_CRYPTO_ALG,
 c0495f2:	e9cd 3002 	strd	r3, r0, [sp, #8]
 c0495f6:	480d      	ldr	r0, [pc, #52]	@ (c04962c <ps_crypto_encrypt_and_tag+0x50>)
 c0495f8:	9606      	str	r6, [sp, #24]
 c0495fa:	230c      	movs	r3, #12
 c0495fc:	490c      	ldr	r1, [pc, #48]	@ (c049630 <ps_crypto_encrypt_and_tag+0x54>)
 c0495fe:	6800      	ldr	r0, [r0, #0]
 c049600:	f105 0210 	add.w	r2, r5, #16
 c049604:	f7f2 fe8d 	bl	c03c322 <psa_aead_encrypt>
                              crypto->ref.iv, PS_IV_LEN_BYTES,
                              add, add_len,
                              in, in_len,
                              out, out_size, out_len);
    if (status != PSA_SUCCESS) {
 c049608:	b968      	cbnz	r0, c049626 <ps_crypto_encrypt_and_tag+0x4a>
        return PSA_ERROR_GENERIC_ERROR;
    }

    /* Copy the tag out of the output buffer */
    *out_len -= PS_TAG_LEN_BYTES;
 c04960a:	6833      	ldr	r3, [r6, #0]
 c04960c:	3b10      	subs	r3, #16
 c04960e:	6033      	str	r3, [r6, #0]
    (void)tfm_memcpy(crypto->ref.tag, (out + *out_len), PS_TAG_LEN_BYTES);
 c049610:	4423      	add	r3, r4
 c049612:	f103 0210 	add.w	r2, r3, #16
 c049616:	f853 1b04 	ldr.w	r1, [r3], #4
 c04961a:	4293      	cmp	r3, r2
 c04961c:	f845 1b04 	str.w	r1, [r5], #4
 c049620:	d1f9      	bne.n	c049616 <ps_crypto_encrypt_and_tag+0x3a>

    return PSA_SUCCESS;
}
 c049622:	b008      	add	sp, #32
 c049624:	bd70      	pop	{r4, r5, r6, pc}
        return PSA_ERROR_GENERIC_ERROR;
 c049626:	f06f 0083 	mvn.w	r0, #131	@ 0x83
 c04962a:	e7fa      	b.n	c049622 <ps_crypto_encrypt_and_tag+0x46>
 c04962c:	3003f20c 	.word	0x3003f20c
 c049630:	05500200 	.word	0x05500200

0c049634 <ps_crypto_auth_and_decrypt>:
                                        uint8_t *in,
                                        size_t in_len,
                                        uint8_t *out,
                                        size_t out_size,
                                        size_t *out_len)
{
 c049634:	b5f0      	push	{r4, r5, r6, r7, lr}
 c049636:	4615      	mov	r5, r2
 c049638:	4602      	mov	r2, r0
 c04963a:	b089      	sub	sp, #36	@ 0x24
 c04963c:	9c0e      	ldr	r4, [sp, #56]	@ 0x38
 c04963e:	f102 0610 	add.w	r6, r2, #16
 c049642:	1918      	adds	r0, r3, r4
 c049644:	f852 7b04 	ldr.w	r7, [r2], #4
 c049648:	42b2      	cmp	r2, r6
 c04964a:	f840 7b04 	str.w	r7, [r0], #4
 c04964e:	d1f9      	bne.n	c049644 <ps_crypto_auth_and_decrypt+0x10>

    /* Copy the tag into the input buffer */
    (void)tfm_memcpy((in + in_len), crypto->ref.tag, PS_TAG_LEN_BYTES);
    in_len += PS_TAG_LEN_BYTES;

    status = psa_aead_decrypt(ps_key, PS_CRYPTO_ALG,
 c049650:	9811      	ldr	r0, [sp, #68]	@ 0x44
    in_len += PS_TAG_LEN_BYTES;
 c049652:	3410      	adds	r4, #16
    status = psa_aead_decrypt(ps_key, PS_CRYPTO_ALG,
 c049654:	9006      	str	r0, [sp, #24]
 c049656:	9810      	ldr	r0, [sp, #64]	@ 0x40
 c049658:	e9cd 3402 	strd	r3, r4, [sp, #8]
 c04965c:	9005      	str	r0, [sp, #20]
 c04965e:	980f      	ldr	r0, [sp, #60]	@ 0x3c
 c049660:	e9cd 1500 	strd	r1, r5, [sp]
 c049664:	9004      	str	r0, [sp, #16]
 c049666:	4806      	ldr	r0, [pc, #24]	@ (c049680 <ps_crypto_auth_and_decrypt+0x4c>)
 c049668:	230c      	movs	r3, #12
 c04966a:	4906      	ldr	r1, [pc, #24]	@ (c049684 <ps_crypto_auth_and_decrypt+0x50>)
 c04966c:	6800      	ldr	r0, [r0, #0]
 c04966e:	f7f2 fea9 	bl	c03c3c4 <psa_aead_decrypt>
                              crypto->ref.iv, PS_IV_LEN_BYTES,
                              add, add_len,
                              in, in_len,
                              out, out_size, out_len);
    if (status != PSA_SUCCESS) {
        return PSA_ERROR_INVALID_SIGNATURE;
 c049672:	2800      	cmp	r0, #0
    }

    return PSA_SUCCESS;
}
 c049674:	bf18      	it	ne
 c049676:	f06f 0094 	mvnne.w	r0, #148	@ 0x94
 c04967a:	b009      	add	sp, #36	@ 0x24
 c04967c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 c04967e:	bf00      	nop
 c049680:	3003f20c 	.word	0x3003f20c
 c049684:	05500200 	.word	0x05500200

0c049688 <ps_crypto_generate_auth_tag>:

psa_status_t ps_crypto_generate_auth_tag(union ps_crypto_t *crypto,
                                         const uint8_t *add,
                                         uint32_t add_len)
{
 c049688:	b500      	push	{lr}
 c04968a:	b08b      	sub	sp, #44	@ 0x2c
    psa_status_t status;
    size_t out_len;

    status = psa_aead_encrypt(ps_key, PS_CRYPTO_ALG,
 c04968c:	ab09      	add	r3, sp, #36	@ 0x24
 c04968e:	9306      	str	r3, [sp, #24]
 c049690:	2310      	movs	r3, #16
 c049692:	e9cd 0304 	strd	r0, r3, [sp, #16]
 c049696:	2300      	movs	r3, #0
 c049698:	e9cd 1200 	strd	r1, r2, [sp]
 c04969c:	e9cd 3302 	strd	r3, r3, [sp, #8]
 c0496a0:	f100 0210 	add.w	r2, r0, #16
 c0496a4:	4808      	ldr	r0, [pc, #32]	@ (c0496c8 <ps_crypto_generate_auth_tag+0x40>)
 c0496a6:	230c      	movs	r3, #12
 c0496a8:	4908      	ldr	r1, [pc, #32]	@ (c0496cc <ps_crypto_generate_auth_tag+0x44>)
 c0496aa:	6800      	ldr	r0, [r0, #0]
 c0496ac:	f7f2 fe39 	bl	c03c322 <psa_aead_encrypt>
                              crypto->ref.iv, PS_IV_LEN_BYTES,
                              add, add_len,
                              0, 0,
                              crypto->ref.tag, PS_TAG_LEN_BYTES, &out_len);
    if (status != PSA_SUCCESS || out_len != PS_TAG_LEN_BYTES) {
 c0496b0:	b938      	cbnz	r0, c0496c2 <ps_crypto_generate_auth_tag+0x3a>
 c0496b2:	9b09      	ldr	r3, [sp, #36]	@ 0x24
        return PSA_ERROR_GENERIC_ERROR;
 c0496b4:	2b10      	cmp	r3, #16
 c0496b6:	bf18      	it	ne
 c0496b8:	f06f 0083 	mvnne.w	r0, #131	@ 0x83
    }

    return PSA_SUCCESS;
}
 c0496bc:	b00b      	add	sp, #44	@ 0x2c
 c0496be:	f85d fb04 	ldr.w	pc, [sp], #4
        return PSA_ERROR_GENERIC_ERROR;
 c0496c2:	f06f 0083 	mvn.w	r0, #131	@ 0x83
 c0496c6:	e7f9      	b.n	c0496bc <ps_crypto_generate_auth_tag+0x34>
 c0496c8:	3003f20c 	.word	0x3003f20c
 c0496cc:	05500200 	.word	0x05500200

0c0496d0 <ps_crypto_authenticate>:

psa_status_t ps_crypto_authenticate(const union ps_crypto_t *crypto,
                                    const uint8_t *add,
                                    uint32_t add_len)
{
 c0496d0:	b500      	push	{lr}
 c0496d2:	b08b      	sub	sp, #44	@ 0x2c
    psa_status_t status;
    size_t out_len;

    status = psa_aead_decrypt(ps_key, PS_CRYPTO_ALG,
 c0496d4:	ab09      	add	r3, sp, #36	@ 0x24
 c0496d6:	9306      	str	r3, [sp, #24]
 c0496d8:	2300      	movs	r3, #0
 c0496da:	e9cd 3304 	strd	r3, r3, [sp, #16]
 c0496de:	2310      	movs	r3, #16
 c0496e0:	e9cd 1200 	strd	r1, r2, [sp]
 c0496e4:	e9cd 0302 	strd	r0, r3, [sp, #8]
 c0496e8:	f100 0210 	add.w	r2, r0, #16
 c0496ec:	4807      	ldr	r0, [pc, #28]	@ (c04970c <ps_crypto_authenticate+0x3c>)
 c0496ee:	230c      	movs	r3, #12
 c0496f0:	4907      	ldr	r1, [pc, #28]	@ (c049710 <ps_crypto_authenticate+0x40>)
 c0496f2:	6800      	ldr	r0, [r0, #0]
 c0496f4:	f7f2 fe66 	bl	c03c3c4 <psa_aead_decrypt>
                              0, 0, &out_len);
    if (status != PSA_SUCCESS || out_len != 0) {
        return PSA_ERROR_INVALID_SIGNATURE;
    }

    return PSA_SUCCESS;
 c0496f8:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 c0496fa:	4318      	orrs	r0, r3
}
 c0496fc:	bf14      	ite	ne
 c0496fe:	f06f 0094 	mvnne.w	r0, #148	@ 0x94
 c049702:	2000      	moveq	r0, #0
 c049704:	b00b      	add	sp, #44	@ 0x2c
 c049706:	f85d fb04 	ldr.w	pc, [sp], #4
 c04970a:	bf00      	nop
 c04970c:	3003f20c 	.word	0x3003f20c
 c049710:	05500200 	.word	0x05500200

0c049714 <ps_encrypted_object_read>:
    psa_status_t err;
    uint32_t decrypt_size;
    size_t data_length;

    /* Read the encrypted object from the the persistent area */
    err = psa_its_get(fid, PS_OBJECT_START_POSITION,
 c049714:	2200      	movs	r2, #0
{
 c049716:	b570      	push	{r4, r5, r6, lr}
 c049718:	b088      	sub	sp, #32
    err = psa_its_get(fid, PS_OBJECT_START_POSITION,
 c04971a:	ab05      	add	r3, sp, #20
 c04971c:	9301      	str	r3, [sp, #4]
                      PS_MAX_OBJECT_SIZE,
                      (void *)obj->header.crypto.ref.iv,
 c04971e:	f101 0310 	add.w	r3, r1, #16
{
 c049722:	460d      	mov	r5, r1
    err = psa_its_get(fid, PS_OBJECT_START_POSITION,
 c049724:	9300      	str	r3, [sp, #0]
 c049726:	4611      	mov	r1, r2
 c049728:	f640 0338 	movw	r3, #2104	@ 0x838
{
 c04972c:	4606      	mov	r6, r0
    err = psa_its_get(fid, PS_OBJECT_START_POSITION,
 c04972e:	f7f2 ffb0 	bl	c03c692 <psa_its_get>
                      &data_length);
    if (err != PSA_SUCCESS) {
 c049732:	bb08      	cbnz	r0, c049778 <ps_encrypted_object_read+0x64>
        return err;
    }

    /* Get the decrypt size */
    decrypt_size = data_length - sizeof(obj->header.crypto.ref.iv);
 c049734:	9c05      	ldr	r4, [sp, #20]

    /* Decrypt the object data */
    err = ps_object_auth_decrypt(fid, decrypt_size, obj);
 c049736:	9606      	str	r6, [sp, #24]
    err = ps_crypto_setkey();
 c049738:	f7ff fee6 	bl	c049508 <ps_crypto_setkey>
    if (err != PSA_SUCCESS) {
 c04973c:	b9e0      	cbnz	r0, c049778 <ps_encrypted_object_read+0x64>
    decrypt_size = data_length - sizeof(obj->header.crypto.ref.iv);
 c04973e:	3c0c      	subs	r4, #12
    uint8_t *p_obj_data = (uint8_t *)&obj->header.info;
 c049740:	f105 061c 	add.w	r6, r5, #28
 c049744:	4622      	mov	r2, r4
 c049746:	4631      	mov	r1, r6
 c049748:	480e      	ldr	r0, [pc, #56]	@ (c049784 <ps_encrypted_object_read+0x70>)
 c04974a:	f011 ff7f 	bl	c05b64c <memcpy>
    err = ps_crypto_auth_and_decrypt(&obj->header.crypto,
 c04974e:	ab07      	add	r3, sp, #28
 c049750:	9303      	str	r3, [sp, #12]
 c049752:	f640 031c 	movw	r3, #2076	@ 0x81c
 c049756:	2204      	movs	r2, #4
 c049758:	e9cd 6301 	strd	r6, r3, [sp, #4]
 c04975c:	4628      	mov	r0, r5
 c04975e:	4b09      	ldr	r3, [pc, #36]	@ (c049784 <ps_encrypted_object_read+0x70>)
 c049760:	9400      	str	r4, [sp, #0]
 c049762:	a906      	add	r1, sp, #24
 c049764:	f7ff ff66 	bl	c049634 <ps_crypto_auth_and_decrypt>
    if (err != PSA_SUCCESS || out_len != cur_size) {
 c049768:	b910      	cbnz	r0, c049770 <ps_encrypted_object_read+0x5c>
 c04976a:	9b07      	ldr	r3, [sp, #28]
 c04976c:	429c      	cmp	r4, r3
 c04976e:	d005      	beq.n	c04977c <ps_encrypted_object_read+0x68>
        (void)ps_crypto_destroykey();
 c049770:	f7ff ff06 	bl	c049580 <ps_crypto_destroykey>
        return PSA_ERROR_GENERIC_ERROR;
 c049774:	f06f 0083 	mvn.w	r0, #131	@ 0x83
    if (err != PSA_SUCCESS) {
        return err;
    }

    return PSA_SUCCESS;
}
 c049778:	b008      	add	sp, #32
 c04977a:	bd70      	pop	{r4, r5, r6, pc}
    return ps_crypto_destroykey();
 c04977c:	f7ff ff00 	bl	c049580 <ps_crypto_destroykey>
 c049780:	e7fa      	b.n	c049778 <ps_encrypted_object_read+0x64>
 c049782:	bf00      	nop
 c049784:	3003f210 	.word	0x3003f210

0c049788 <ps_encrypted_object_write>:

psa_status_t ps_encrypted_object_write(uint32_t fid, struct ps_object_t *obj)
{
 c049788:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 c04978c:	b086      	sub	sp, #24
 c04978e:	460d      	mov	r5, r1
    psa_status_t err;
    uint32_t wrt_size;

    wrt_size = PS_ENCRYPT_SIZE(obj->header.info.current_size);
 c049790:	69cc      	ldr	r4, [r1, #28]
{
 c049792:	4606      	mov	r6, r0
 c049794:	9004      	str	r0, [sp, #16]
    err = ps_crypto_setkey();
 c049796:	f7ff feb7 	bl	c049508 <ps_crypto_setkey>
    if (err != PSA_SUCCESS) {
 c04979a:	4601      	mov	r1, r0
 c04979c:	b9f0      	cbnz	r0, c0497dc <ps_encrypted_object_write+0x54>
    ps_crypto_get_iv(&obj->header.crypto);
 c04979e:	4628      	mov	r0, r5
 c0497a0:	f7ff ff04 	bl	c0495ac <ps_crypto_get_iv>
    err = ps_crypto_encrypt_and_tag(&obj->header.crypto,
 c0497a4:	ab05      	add	r3, sp, #20
 c0497a6:	9303      	str	r3, [sp, #12]
 c0497a8:	f640 032c 	movw	r3, #2092	@ 0x82c
 c0497ac:	f8df 805c 	ldr.w	r8, [pc, #92]	@ c04980c <ps_encrypted_object_write+0x84>

    wrt_size = GET_ALIGNED_FLASH_BYTES(wrt_size);
 c0497b0:	341b      	adds	r4, #27
 c0497b2:	f024 040f 	bic.w	r4, r4, #15
    uint8_t *p_obj_data = (uint8_t *)&obj->header.info;
 c0497b6:	f105 071c 	add.w	r7, r5, #28
    err = ps_crypto_encrypt_and_tag(&obj->header.crypto,
 c0497ba:	9302      	str	r3, [sp, #8]
 c0497bc:	2204      	movs	r2, #4
 c0497be:	463b      	mov	r3, r7
 c0497c0:	4628      	mov	r0, r5
 c0497c2:	e9cd 4800 	strd	r4, r8, [sp]
 c0497c6:	a904      	add	r1, sp, #16
 c0497c8:	f7ff ff08 	bl	c0495dc <ps_crypto_encrypt_and_tag>
    if (err != PSA_SUCCESS || out_len != cur_size) {
 c0497cc:	b910      	cbnz	r0, c0497d4 <ps_encrypted_object_write+0x4c>
 c0497ce:	9b05      	ldr	r3, [sp, #20]
 c0497d0:	429c      	cmp	r4, r3
 c0497d2:	d007      	beq.n	c0497e4 <ps_encrypted_object_write+0x5c>
        (void)ps_crypto_destroykey();
 c0497d4:	f7ff fed4 	bl	c049580 <ps_crypto_destroykey>
        return PSA_ERROR_GENERIC_ERROR;
 c0497d8:	f06f 0183 	mvn.w	r1, #131	@ 0x83
    /* Write the encrypted object to the persistent area. The tag values is not
     * copied as it is stored in the object table.
     */
    return psa_its_set(fid, wrt_size, (const void *)obj->header.crypto.ref.iv,
                       PSA_STORAGE_FLAG_NONE);
}
 c0497dc:	4608      	mov	r0, r1
 c0497de:	b006      	add	sp, #24
 c0497e0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 c0497e4:	4641      	mov	r1, r8
 c0497e6:	4622      	mov	r2, r4
 c0497e8:	4638      	mov	r0, r7
 c0497ea:	f011 ff2f 	bl	c05b64c <memcpy>
    return ps_crypto_destroykey();
 c0497ee:	f7ff fec7 	bl	c049580 <ps_crypto_destroykey>
    if (err != PSA_SUCCESS) {
 c0497f2:	4601      	mov	r1, r0
 c0497f4:	2800      	cmp	r0, #0
 c0497f6:	d1f1      	bne.n	c0497dc <ps_encrypted_object_write+0x54>
    return psa_its_set(fid, wrt_size, (const void *)obj->header.crypto.ref.iv,
 c0497f8:	9000      	str	r0, [sp, #0]
 c0497fa:	f105 0310 	add.w	r3, r5, #16
 c0497fe:	4630      	mov	r0, r6
 c049800:	f104 020c 	add.w	r2, r4, #12
 c049804:	f7f2 ff20 	bl	c03c648 <psa_its_set>
 c049808:	4601      	mov	r1, r0
 c04980a:	e7e7      	b.n	c0497dc <ps_encrypted_object_write+0x54>
 c04980c:	3003f210 	.word	0x3003f210

0c049810 <ps_remove_old_data>:
 * \param[in] old_fid  Old file ID to remove.
 *
 * \return Returns error code as specified in \ref psa_status_t
 */
static psa_status_t ps_remove_old_data(uint32_t old_fid)
{
 c049810:	b510      	push	{r4, lr}
 c049812:	4604      	mov	r4, r0
    psa_status_t err;

    /* Delete old object table from the persistent area */
    err = ps_object_table_delete_old_table();
 c049814:	f000 fae4 	bl	c049de0 <ps_object_table_delete_old_table>
 c049818:	4601      	mov	r1, r0
    if (err != PSA_SUCCESS) {
 c04981a:	b920      	cbnz	r0, c049826 <ps_remove_old_data+0x16>
        return err;
    }

    /* Delete old file from the persistent area */
    return psa_its_remove(old_fid);
 c04981c:	4620      	mov	r0, r4
}
 c04981e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    return psa_its_remove(old_fid);
 c049822:	f7f2 bf89 	b.w	c03c738 <psa_its_remove>
}
 c049826:	bd10      	pop	{r4, pc}

0c049828 <ps_system_prepare>:
}

#endif /* !PS_ENCRYPTION */

psa_status_t ps_system_prepare(void)
{
 c049828:	b510      	push	{r4, lr}
    /* Reuse the allocated g_ps_object.data to store a temporary object table
     * data to be validate inside the function.
     * The stored date will be cleaned up when the g_ps_object.data will
     * be used for the first time in the object system.
     */
    err = ps_object_table_init(g_ps_object.data);
 c04982a:	4c04      	ldr	r4, [pc, #16]	@ (c04983c <ps_system_prepare+0x14>)
 c04982c:	4620      	mov	r0, r4
 c04982e:	f000 f965 	bl	c049afc <ps_object_table_init>

#ifdef PS_ENCRYPTION
    g_obj_tbl_info.tag = g_ps_object.header.crypto.ref.tag;
 c049832:	4b03      	ldr	r3, [pc, #12]	@ (c049840 <ps_system_prepare+0x18>)
 c049834:	3c28      	subs	r4, #40	@ 0x28
 c049836:	605c      	str	r4, [r3, #4]
#endif

    return err;
}
 c049838:	bd10      	pop	{r4, pc}
 c04983a:	bf00      	nop
 c04983c:	3003fa6c 	.word	0x3003fa6c
 c049840:	3003fa3c 	.word	0x3003fa3c

0c049844 <ps_object_read>:

psa_status_t ps_object_read(psa_storage_uid_t uid, int32_t client_id,
                            uint32_t offset, uint32_t size,
                            size_t *p_data_length)
{
 c049844:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    psa_status_t err;

    /* Retrieve the object information from the object table if the object
     * exists.
     */
    err = ps_object_table_get_obj_tbl_info(uid, client_id, &g_obj_tbl_info);
 c049846:	4d14      	ldr	r5, [pc, #80]	@ (c049898 <ps_object_read+0x54>)
{
 c049848:	461e      	mov	r6, r3
    err = ps_object_table_get_obj_tbl_info(uid, client_id, &g_obj_tbl_info);
 c04984a:	462b      	mov	r3, r5
 c04984c:	f000 fa7c 	bl	c049d48 <ps_object_table_get_obj_tbl_info>
    if (err != PSA_SUCCESS) {
 c049850:	4604      	mov	r4, r0
 c049852:	b9e0      	cbnz	r0, c04988e <ps_object_read+0x4a>
        return err;
    }

    /* Read object */
#ifdef PS_ENCRYPTION
    err = ps_encrypted_object_read(g_obj_tbl_info.fid, &g_ps_object);
 c049854:	4f11      	ldr	r7, [pc, #68]	@ (c04989c <ps_object_read+0x58>)
 c049856:	6828      	ldr	r0, [r5, #0]
 c049858:	4639      	mov	r1, r7
 c04985a:	f7ff ff5b 	bl	c049714 <ps_encrypted_object_read>
#else
    /* Read object header */
    err = ps_read_object(READ_ALL_OBJECT);
#endif
    if (err != PSA_SUCCESS) {
 c04985e:	4604      	mov	r4, r0
 c049860:	b978      	cbnz	r0, c049882 <ps_object_read+0x3e>
        goto clear_data_and_return;
    }

    /* Boundary check the incoming request */
    if (offset > g_ps_object.header.info.current_size) {
 c049862:	69fd      	ldr	r5, [r7, #28]
 c049864:	42b5      	cmp	r5, r6
 c049866:	d314      	bcc.n	c049892 <ps_object_read+0x4e>
       err = PSA_ERROR_INVALID_ARGUMENT;
       goto clear_data_and_return;
    }

    size = PS_UTILS_MIN(size,
 c049868:	9b06      	ldr	r3, [sp, #24]
 c04986a:	1bad      	subs	r5, r5, r6
 c04986c:	429d      	cmp	r5, r3
 c04986e:	bf28      	it	cs
 c049870:	461d      	movcs	r5, r3
                        g_ps_object.header.info.current_size - offset);

    /* Copy the decrypted object data to the output buffer */
    ps_req_mngr_write_asset_data(g_ps_object.data + offset, size);
 c049872:	f107 0028 	add.w	r0, r7, #40	@ 0x28
 c049876:	4629      	mov	r1, r5
 c049878:	4430      	add	r0, r6
 c04987a:	f001 fdd7 	bl	c04b42c <ps_req_mngr_write_asset_data>

    *p_data_length = size;
 c04987e:	9b07      	ldr	r3, [sp, #28]
 c049880:	601d      	str	r5, [r3, #0]
    return (memset(ptr, value, num));
 c049882:	f640 0238 	movw	r2, #2104	@ 0x838
 c049886:	2100      	movs	r1, #0
 c049888:	4804      	ldr	r0, [pc, #16]	@ (c04989c <ps_object_read+0x58>)
 c04988a:	f011 ff50 	bl	c05b72e <memset>
    /* Remove data stored in the object before leaving the function */
    (void)tfm_memset(&g_ps_object, PS_DEFAULT_EMPTY_BUFF_VAL,
                     PS_MAX_OBJECT_SIZE);

    return err;
}
 c04988e:	4620      	mov	r0, r4
 c049890:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
       err = PSA_ERROR_INVALID_ARGUMENT;
 c049892:	f06f 0486 	mvn.w	r4, #134	@ 0x86
 c049896:	e7f4      	b.n	c049882 <ps_object_read+0x3e>
 c049898:	3003fa3c 	.word	0x3003fa3c
 c04989c:	3003fa44 	.word	0x3003fa44

0c0498a0 <ps_object_create>:

psa_status_t ps_object_create(psa_storage_uid_t uid, int32_t client_id,
                              psa_storage_create_flags_t create_flags,
                              uint32_t size)
{
 c0498a0:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c0498a4:	9e0c      	ldr	r6, [sp, #48]	@ 0x30
 c0498a6:	4682      	mov	sl, r0
#ifndef PS_ENCRYPTION
    uint32_t wrt_size;
#endif

    /* Boundary check the incoming request */
    if (size > PS_MAX_ASSET_SIZE) {
 c0498a8:	f5b6 6f00 	cmp.w	r6, #2048	@ 0x800
{
 c0498ac:	4693      	mov	fp, r2
 c0498ae:	461f      	mov	r7, r3
 c0498b0:	9101      	str	r1, [sp, #4]
    if (size > PS_MAX_ASSET_SIZE) {
 c0498b2:	d85f      	bhi.n	c049974 <ps_object_create+0xd4>
    }

    /* Retrieve the object information from the object table if the object
     * exists.
     */
    err = ps_object_table_get_obj_tbl_info(uid, client_id, &g_obj_tbl_info);
 c0498b4:	4d31      	ldr	r5, [pc, #196]	@ (c04997c <ps_object_create+0xdc>)
 c0498b6:	462b      	mov	r3, r5
 c0498b8:	f000 fa46 	bl	c049d48 <ps_object_table_get_obj_tbl_info>
    if (err == PSA_SUCCESS) {
 c0498bc:	4604      	mov	r4, r0
 c0498be:	2800      	cmp	r0, #0
 c0498c0:	d13c      	bne.n	c04993c <ps_object_create+0x9c>
#ifdef PS_ENCRYPTION
        /* Read the object */
        err = ps_encrypted_object_read(g_obj_tbl_info.fid, &g_ps_object);
 c0498c2:	f8df 80bc 	ldr.w	r8, [pc, #188]	@ c049980 <ps_object_create+0xe0>
 c0498c6:	6828      	ldr	r0, [r5, #0]
 c0498c8:	4641      	mov	r1, r8
 c0498ca:	f7ff ff23 	bl	c049714 <ps_encrypted_object_read>
#else
        /* Read the object header */
        err = ps_read_object(READ_HEADER_ONLY);
#endif
        if (err != PSA_SUCCESS) {
 c0498ce:	4604      	mov	r4, r0
 c0498d0:	bb50      	cbnz	r0, c049928 <ps_object_create+0x88>

        /* If the object exists and has the write once flag set, then it cannot
         * be modified.
         */
        if (g_ps_object.header.info.create_flags
            & PSA_STORAGE_FLAG_WRITE_ONCE) {
 c0498d2:	f8d8 3024 	ldr.w	r3, [r8, #36]	@ 0x24
        if (g_ps_object.header.info.create_flags
 c0498d6:	07db      	lsls	r3, r3, #31
 c0498d8:	d449      	bmi.n	c04996e <ps_object_create+0xce>
    uint32_t fid_am_reserved = 1;
 c0498da:	f04f 0901 	mov.w	r9, #1
            goto clear_data_and_return;
        }

        /* Update the create flags and max object size */
        g_ps_object.header.info.create_flags = create_flags;
        g_ps_object.header.info.max_size = size;
 c0498de:	e9c8 6708 	strd	r6, r7, [r8, #32]

        /* Save old file ID */
        old_fid = g_obj_tbl_info.fid;
 c0498e2:	682f      	ldr	r7, [r5, #0]
    } else {
        goto clear_data_and_return;
    }

    /* Update the object data */
    err = ps_req_mngr_read_asset_data(g_ps_object.data, size);
 c0498e4:	4631      	mov	r1, r6
 c0498e6:	4827      	ldr	r0, [pc, #156]	@ (c049984 <ps_object_create+0xe4>)
 c0498e8:	f001 fd8e 	bl	c04b408 <ps_req_mngr_read_asset_data>
    if (err != PSA_SUCCESS) {
 c0498ec:	4604      	mov	r4, r0
 c0498ee:	b9d8      	cbnz	r0, c049928 <ps_object_create+0x88>
        goto clear_data_and_return;
    }

    /* Update the current object size */
    g_ps_object.header.info.current_size = size;
 c0498f0:	f8df 808c 	ldr.w	r8, [pc, #140]	@ c049980 <ps_object_create+0xe0>

    /* Get new file ID */
    err = ps_object_table_get_free_fid(fid_am_reserved,
 c0498f4:	4648      	mov	r0, r9
 c0498f6:	4921      	ldr	r1, [pc, #132]	@ (c04997c <ps_object_create+0xdc>)
    g_ps_object.header.info.current_size = size;
 c0498f8:	f8c8 601c 	str.w	r6, [r8, #28]
    err = ps_object_table_get_free_fid(fid_am_reserved,
 c0498fc:	f000 f98e 	bl	c049c1c <ps_object_table_get_free_fid>
                                       &g_obj_tbl_info.fid);
    if (err != PSA_SUCCESS) {
 c049900:	4604      	mov	r4, r0
 c049902:	b988      	cbnz	r0, c049928 <ps_object_create+0x88>
        goto clear_data_and_return;
    }

#ifdef PS_ENCRYPTION
    err = ps_encrypted_object_write(g_obj_tbl_info.fid, &g_ps_object);
 c049904:	4641      	mov	r1, r8
 c049906:	6828      	ldr	r0, [r5, #0]
 c049908:	f7ff ff3e 	bl	c049788 <ps_encrypted_object_write>
    wrt_size = PS_OBJECT_SIZE(g_ps_object.header.info.current_size);

    /* Write g_ps_object */
    err = ps_write_object(wrt_size);
#endif
    if (err != PSA_SUCCESS) {
 c04990c:	4604      	mov	r4, r0
 c04990e:	b958      	cbnz	r0, c049928 <ps_object_create+0x88>
    }

    /* Update the table with the new internal ID and version for the object, and
     * store it in the persistent area.
     */
    err = ps_object_table_set_obj_tbl_info(uid, client_id, &g_obj_tbl_info);
 c049910:	465a      	mov	r2, fp
 c049912:	4650      	mov	r0, sl
 c049914:	4b19      	ldr	r3, [pc, #100]	@ (c04997c <ps_object_create+0xdc>)
 c049916:	9901      	ldr	r1, [sp, #4]
 c049918:	f000 f9ac 	bl	c049c74 <ps_object_table_set_obj_tbl_info>
    if (err != PSA_SUCCESS) {
 c04991c:	4604      	mov	r4, r0
 c04991e:	b1e8      	cbz	r0, c04995c <ps_object_create+0xbc>
        /* Remove new object as object table is not persistent and propagate
         * object table manipulation error.
         */
        (void)psa_its_remove(g_obj_tbl_info.fid);
 c049920:	2100      	movs	r1, #0
 c049922:	6828      	ldr	r0, [r5, #0]
 c049924:	f7f2 ff08 	bl	c03c738 <psa_its_remove>
 c049928:	f640 0238 	movw	r2, #2104	@ 0x838
 c04992c:	2100      	movs	r1, #0
 c04992e:	4814      	ldr	r0, [pc, #80]	@ (c049980 <ps_object_create+0xe0>)
 c049930:	f011 fefd 	bl	c05b72e <memset>
    /* Remove data stored in the object before leaving the function */
    (void)tfm_memset(&g_ps_object, PS_DEFAULT_EMPTY_BUFF_VAL,
                     PS_MAX_OBJECT_SIZE);

    return err;
}
 c049934:	4620      	mov	r0, r4
 c049936:	b003      	add	sp, #12
 c049938:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    } else if (err == PSA_ERROR_DOES_NOT_EXIST) {
 c04993c:	f110 0f8c 	cmn.w	r0, #140	@ 0x8c
 c049940:	d1f2      	bne.n	c049928 <ps_object_create+0x88>
 c049942:	4b0f      	ldr	r3, [pc, #60]	@ (c049980 <ps_object_create+0xe0>)
 c049944:	f640 0238 	movw	r2, #2104	@ 0x838
 c049948:	2100      	movs	r1, #0
 c04994a:	4618      	mov	r0, r3
 c04994c:	f011 feef 	bl	c05b72e <memset>
        fid_am_reserved = 2;
 c049950:	f04f 0902 	mov.w	r9, #2
    obj->header.info.create_flags = create_flags;
 c049954:	e9c0 6708 	strd	r6, r7, [r0, #32]
    uint32_t old_fid = PS_INVALID_FID;
 c049958:	2700      	movs	r7, #0
}
 c04995a:	e7c3      	b.n	c0498e4 <ps_object_create+0x44>
    if (old_fid == PS_INVALID_FID) {
 c04995c:	b91f      	cbnz	r7, c049966 <ps_object_create+0xc6>
        err = ps_object_table_delete_old_table();
 c04995e:	f000 fa3f 	bl	c049de0 <ps_object_table_delete_old_table>
        err = ps_remove_old_data(old_fid);
 c049962:	4604      	mov	r4, r0
 c049964:	e7e0      	b.n	c049928 <ps_object_create+0x88>
 c049966:	4638      	mov	r0, r7
 c049968:	f7ff ff52 	bl	c049810 <ps_remove_old_data>
 c04996c:	e7f9      	b.n	c049962 <ps_object_create+0xc2>
            err = PSA_ERROR_NOT_PERMITTED;
 c04996e:	f06f 0484 	mvn.w	r4, #132	@ 0x84
 c049972:	e7d9      	b.n	c049928 <ps_object_create+0x88>
        return PSA_ERROR_INVALID_ARGUMENT;
 c049974:	f06f 0486 	mvn.w	r4, #134	@ 0x86
 c049978:	e7dc      	b.n	c049934 <ps_object_create+0x94>
 c04997a:	bf00      	nop
 c04997c:	3003fa3c 	.word	0x3003fa3c
 c049980:	3003fa44 	.word	0x3003fa44
 c049984:	3003fa6c 	.word	0x3003fa6c

0c049988 <ps_object_get_info>:
    return err;
}

psa_status_t ps_object_get_info(psa_storage_uid_t uid, int32_t client_id,
                                struct psa_storage_info_t *info)
{
 c049988:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    psa_status_t err;

    /* Retrieve the object information from the object table if the object
     * exists.
     */
    err = ps_object_table_get_obj_tbl_info(uid, client_id, &g_obj_tbl_info);
 c04998a:	4f0d      	ldr	r7, [pc, #52]	@ (c0499c0 <ps_object_get_info+0x38>)
{
 c04998c:	461d      	mov	r5, r3
    err = ps_object_table_get_obj_tbl_info(uid, client_id, &g_obj_tbl_info);
 c04998e:	463b      	mov	r3, r7
 c049990:	f000 f9da 	bl	c049d48 <ps_object_table_get_obj_tbl_info>
    if (err != PSA_SUCCESS) {
 c049994:	4604      	mov	r4, r0
 c049996:	b980      	cbnz	r0, c0499ba <ps_object_get_info+0x32>
        return err;
    }

#ifdef PS_ENCRYPTION
    err = ps_encrypted_object_read(g_obj_tbl_info.fid, &g_ps_object);
 c049998:	4e0a      	ldr	r6, [pc, #40]	@ (c0499c4 <ps_object_get_info+0x3c>)
 c04999a:	6838      	ldr	r0, [r7, #0]
 c04999c:	4631      	mov	r1, r6
 c04999e:	f7ff feb9 	bl	c049714 <ps_encrypted_object_read>
#else
    err = ps_read_object(READ_HEADER_ONLY);
#endif
    if (err != PSA_SUCCESS) {
 c0499a2:	4604      	mov	r4, r0
 c0499a4:	b918      	cbnz	r0, c0499ae <ps_object_get_info+0x26>
        goto clear_data_and_return;
    }

    /* Copy PS object info to the PSA PS info struct */
    info->size = g_ps_object.header.info.current_size;
 c0499a6:	69f3      	ldr	r3, [r6, #28]
 c0499a8:	606b      	str	r3, [r5, #4]
    info->flags = g_ps_object.header.info.create_flags;
 c0499aa:	6a73      	ldr	r3, [r6, #36]	@ 0x24
 c0499ac:	60ab      	str	r3, [r5, #8]
 c0499ae:	f640 0238 	movw	r2, #2104	@ 0x838
 c0499b2:	2100      	movs	r1, #0
 c0499b4:	4803      	ldr	r0, [pc, #12]	@ (c0499c4 <ps_object_get_info+0x3c>)
 c0499b6:	f011 feba 	bl	c05b72e <memset>
    /* Remove data stored in the object before leaving the function */
    (void)tfm_memset(&g_ps_object, PS_DEFAULT_EMPTY_BUFF_VAL,
                     PS_MAX_OBJECT_SIZE);

    return err;
}
 c0499ba:	4620      	mov	r0, r4
 c0499bc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 c0499be:	bf00      	nop
 c0499c0:	3003fa3c 	.word	0x3003fa3c
 c0499c4:	3003fa44 	.word	0x3003fa44

0c0499c8 <ps_object_delete>:

psa_status_t ps_object_delete(psa_storage_uid_t uid, int32_t client_id)
{
 c0499c8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    psa_status_t err;

    /* Retrieve the object information from the object table if the object
     * exists.
     */
    err = ps_object_table_get_obj_tbl_info(uid, client_id, &g_obj_tbl_info);
 c0499cc:	4d15      	ldr	r5, [pc, #84]	@ (c049a24 <ps_object_delete+0x5c>)
{
 c0499ce:	4607      	mov	r7, r0
    err = ps_object_table_get_obj_tbl_info(uid, client_id, &g_obj_tbl_info);
 c0499d0:	462b      	mov	r3, r5
{
 c0499d2:	460e      	mov	r6, r1
 c0499d4:	4690      	mov	r8, r2
    err = ps_object_table_get_obj_tbl_info(uid, client_id, &g_obj_tbl_info);
 c0499d6:	f000 f9b7 	bl	c049d48 <ps_object_table_get_obj_tbl_info>
    if (err != PSA_SUCCESS) {
 c0499da:	4604      	mov	r4, r0
 c0499dc:	b9e0      	cbnz	r0, c049a18 <ps_object_delete+0x50>
        return err;
    }

#ifdef PS_ENCRYPTION
    err = ps_encrypted_object_read(g_obj_tbl_info.fid, &g_ps_object);
 c0499de:	f8df 9048 	ldr.w	r9, [pc, #72]	@ c049a28 <ps_object_delete+0x60>
 c0499e2:	6828      	ldr	r0, [r5, #0]
 c0499e4:	4649      	mov	r1, r9
 c0499e6:	f7ff fe95 	bl	c049714 <ps_encrypted_object_read>
#else
    err = ps_read_object(READ_HEADER_ONLY);
#endif
    if (err != PSA_SUCCESS) {
 c0499ea:	4604      	mov	r4, r0
 c0499ec:	b970      	cbnz	r0, c049a0c <ps_object_delete+0x44>
        goto clear_data_and_return;
    }

    /* Check that the write once flag is not set */
    if (g_ps_object.header.info.create_flags & PSA_STORAGE_FLAG_WRITE_ONCE) {
 c0499ee:	f8d9 3024 	ldr.w	r3, [r9, #36]	@ 0x24
 c0499f2:	07db      	lsls	r3, r3, #31
 c0499f4:	d413      	bmi.n	c049a1e <ps_object_delete+0x56>
    }

    /* Delete object from the table and stores the table in the persistent
     * area.
     */
    err = ps_object_table_delete_object(uid, client_id);
 c0499f6:	4642      	mov	r2, r8
 c0499f8:	4638      	mov	r0, r7
 c0499fa:	4631      	mov	r1, r6
 c0499fc:	f000 f9c4 	bl	c049d88 <ps_object_table_delete_object>
    if (err != PSA_SUCCESS) {
 c049a00:	4604      	mov	r4, r0
 c049a02:	b918      	cbnz	r0, c049a0c <ps_object_delete+0x44>
        goto clear_data_and_return;
    }

    /* Remove old object table and file */
    err = ps_remove_old_data(g_obj_tbl_info.fid);
 c049a04:	6828      	ldr	r0, [r5, #0]
 c049a06:	f7ff ff03 	bl	c049810 <ps_remove_old_data>
 c049a0a:	4604      	mov	r4, r0
 c049a0c:	f640 0238 	movw	r2, #2104	@ 0x838
 c049a10:	2100      	movs	r1, #0
 c049a12:	4805      	ldr	r0, [pc, #20]	@ (c049a28 <ps_object_delete+0x60>)
 c049a14:	f011 fe8b 	bl	c05b72e <memset>
    /* Remove data stored in the object before leaving the function */
    (void)tfm_memset(&g_ps_object, PS_DEFAULT_EMPTY_BUFF_VAL,
                     PS_MAX_OBJECT_SIZE);

    return err;
}
 c049a18:	4620      	mov	r0, r4
 c049a1a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        err = PSA_ERROR_NOT_PERMITTED;
 c049a1e:	f06f 0484 	mvn.w	r4, #132	@ 0x84
 c049a22:	e7f3      	b.n	c049a0c <ps_object_delete+0x44>
 c049a24:	3003fa3c 	.word	0x3003fa3c
 c049a28:	3003fa44 	.word	0x3003fa44

0c049a2c <ps_system_wipe_all>:
     * This could be asynchronous to normal system operation
     * and state of the ps system lock is unknown. Hence
     * this function doesn't block on the lock and directly
     * moves to erasing the flash instead.
     */
    return ps_object_table_create();
 c049a2c:	f000 b854 	b.w	c049ad8 <ps_object_table_create>

0c049a30 <ps_get_object_entry_idx>:
 *         in the table. Otherwise, it returns PSA_ERROR_DOES_NOT_EXIST.
 */
static psa_status_t ps_get_object_entry_idx(psa_storage_uid_t uid,
                                            int32_t client_id,
                                            uint32_t *idx)
{
 c049a30:	b5f0      	push	{r4, r5, r6, r7, lr}
    uint32_t i;
    struct ps_obj_table_t *p_table = &ps_obj_table_ctx.obj_table;

    for (i = 0; i < PS_OBJ_TABLE_ENTRIES; i++) {
 c049a32:	2500      	movs	r5, #0
 c049a34:	4c0a      	ldr	r4, [pc, #40]	@ (c049a60 <ps_get_object_entry_idx+0x30>)
        if (p_table->obj_db[i].uid == uid
 c049a36:	e9d4 760c 	ldrd	r7, r6, [r4, #48]	@ 0x30
 c049a3a:	428e      	cmp	r6, r1
 c049a3c:	bf08      	it	eq
 c049a3e:	4287      	cmpeq	r7, r0
 c049a40:	d105      	bne.n	c049a4e <ps_get_object_entry_idx+0x1e>
            && p_table->obj_db[i].client_id == client_id) {
 c049a42:	6ba6      	ldr	r6, [r4, #56]	@ 0x38
 c049a44:	4296      	cmp	r6, r2
 c049a46:	d102      	bne.n	c049a4e <ps_get_object_entry_idx+0x1e>
            *idx = i;
            return PSA_SUCCESS;
 c049a48:	2000      	movs	r0, #0
            *idx = i;
 c049a4a:	601d      	str	r5, [r3, #0]
        }
    }

    return PSA_ERROR_DOES_NOT_EXIST;
}
 c049a4c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    for (i = 0; i < PS_OBJ_TABLE_ENTRIES; i++) {
 c049a4e:	3501      	adds	r5, #1
 c049a50:	2d0b      	cmp	r5, #11
 c049a52:	f104 0420 	add.w	r4, r4, #32
 c049a56:	d1ee      	bne.n	c049a36 <ps_get_object_entry_idx+0x6>
    return PSA_ERROR_DOES_NOT_EXIST;
 c049a58:	f06f 008b 	mvn.w	r0, #139	@ 0x8b
 c049a5c:	e7f6      	b.n	c049a4c <ps_get_object_entry_idx+0x1c>
 c049a5e:	bf00      	nop
 c049a60:	30040280 	.word	0x30040280

0c049a64 <ps_object_table_save_table.constprop.0>:
static psa_status_t ps_object_table_save_table(
 c049a64:	b573      	push	{r0, r1, r4, r5, r6, lr}
    obj_table->swap_count++;
 c049a66:	4d1b      	ldr	r5, [pc, #108]	@ (c049ad4 <ps_object_table_save_table.constprop.0+0x70>)
 c049a68:	7f6b      	ldrb	r3, [r5, #29]
 c049a6a:	3301      	adds	r3, #1
 c049a6c:	b2db      	uxtb	r3, r3
        obj_table->swap_count = 0;
 c049a6e:	2bff      	cmp	r3, #255	@ 0xff
 c049a70:	bf08      	it	eq
 c049a72:	2300      	moveq	r3, #0
 c049a74:	776b      	strb	r3, [r5, #29]
    err = ps_crypto_setkey();
 c049a76:	f7ff fd47 	bl	c049508 <ps_crypto_setkey>
    if (err != PSA_SUCCESS) {
 c049a7a:	4604      	mov	r4, r0
 c049a7c:	b968      	cbnz	r0, c049a9a <ps_object_table_save_table.constprop.0+0x36>
    ps_crypto_get_iv(crypto);
 c049a7e:	4628      	mov	r0, r5
 c049a80:	f7ff fd94 	bl	c0495ac <ps_crypto_get_iv>
    return ps_crypto_generate_auth_tag(crypto,
 c049a84:	f44f 72b2 	mov.w	r2, #356	@ 0x164
 c049a88:	4628      	mov	r0, r5
 c049a8a:	f105 011c 	add.w	r1, r5, #28
 c049a8e:	f7ff fdfb 	bl	c049688 <ps_crypto_generate_auth_tag>
    if (err != PSA_SUCCESS) {
 c049a92:	4604      	mov	r4, r0
 c049a94:	b120      	cbz	r0, c049aa0 <ps_object_table_save_table.constprop.0+0x3c>
        (void)ps_crypto_destroykey();
 c049a96:	f7ff fd73 	bl	c049580 <ps_crypto_destroykey>
}
 c049a9a:	4620      	mov	r0, r4
 c049a9c:	b002      	add	sp, #8
 c049a9e:	bd70      	pop	{r4, r5, r6, pc}
    err = ps_crypto_destroykey();
 c049aa0:	f7ff fd6e 	bl	c049580 <ps_crypto_destroykey>
    if (err != PSA_SUCCESS) {
 c049aa4:	4604      	mov	r4, r0
 c049aa6:	2800      	cmp	r0, #0
 c049aa8:	d1f7      	bne.n	c049a9a <ps_object_table_save_table.constprop.0+0x36>
    uint32_t obj_table_id = PS_TABLE_FS_ID(ps_obj_table_ctx.scratch_table);
 c049aaa:	f895 6181 	ldrb.w	r6, [r5, #385]	@ 0x181
    err = psa_its_set(obj_table_id,
 c049aae:	462b      	mov	r3, r5
 c049ab0:	9000      	str	r0, [sp, #0]
 c049ab2:	f44f 72c0 	mov.w	r2, #384	@ 0x180
 c049ab6:	2100      	movs	r1, #0
 c049ab8:	1c70      	adds	r0, r6, #1
 c049aba:	f7f2 fdc5 	bl	c03c648 <psa_its_set>
    if (err != PSA_SUCCESS) {
 c049abe:	4604      	mov	r4, r0
 c049ac0:	2800      	cmp	r0, #0
 c049ac2:	d1ea      	bne.n	c049a9a <ps_object_table_save_table.constprop.0+0x36>
    ps_obj_table_ctx.scratch_table = ps_obj_table_ctx.active_table;
 c049ac4:	f895 3180 	ldrb.w	r3, [r5, #384]	@ 0x180
    ps_obj_table_ctx.active_table = swap_table_idxs;
 c049ac8:	f885 6180 	strb.w	r6, [r5, #384]	@ 0x180
    ps_obj_table_ctx.scratch_table = ps_obj_table_ctx.active_table;
 c049acc:	f885 3181 	strb.w	r3, [r5, #385]	@ 0x181
    return PSA_SUCCESS;
 c049ad0:	e7e3      	b.n	c049a9a <ps_object_table_save_table.constprop.0+0x36>
 c049ad2:	bf00      	nop
 c049ad4:	30040280 	.word	0x30040280

0c049ad8 <ps_object_table_create>:
    (void)tfm_memset(&ps_obj_table_ctx.obj_table.obj_db[idx],
                     PS_DEFAULT_EMPTY_BUFF_VAL, PS_OBJECTS_TABLE_ENTRY_SIZE);
}

psa_status_t ps_object_table_create(void)
{
 c049ad8:	b508      	push	{r3, lr}
 c049ada:	4b07      	ldr	r3, [pc, #28]	@ (c049af8 <ps_object_table_create+0x20>)
 c049adc:	f44f 72c4 	mov.w	r2, #392	@ 0x188
 c049ae0:	4618      	mov	r0, r3
 c049ae2:	2100      	movs	r1, #0
 c049ae4:	f011 fe23 	bl	c05b72e <memset>
                     sizeof(struct ps_obj_table_ctx_t));

    /* Invert the other in the context as ps_object_table_save_table will
     * use the scratch index to create and store the current table.
     */
    ps_obj_table_ctx.active_table  = PS_OBJ_TABLE_IDX_1;
 c049ae8:	2201      	movs	r2, #1
 c049aea:	f880 2180 	strb.w	r2, [r0, #384]	@ 0x180
    ps_obj_table_ctx.scratch_table = PS_OBJ_TABLE_IDX_0;

    p_table->version = PS_OBJECT_SYSTEM_VERSION;
 c049aee:	7702      	strb	r2, [r0, #28]

    /* Save object table contents */
    return ps_object_table_save_table(p_table);
}
 c049af0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    return ps_object_table_save_table(p_table);
 c049af4:	f7ff bfb6 	b.w	c049a64 <ps_object_table_save_table.constprop.0>
 c049af8:	30040280 	.word	0x30040280

0c049afc <ps_object_table_init>:

psa_status_t ps_object_table_init(uint8_t *obj_data)
{
 c049afc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    err = psa_its_get(PS_TABLE_FS_ID(PS_OBJ_TABLE_IDX_0),
 c049b00:	4d45      	ldr	r5, [pc, #276]	@ (c049c18 <ps_object_table_init+0x11c>)
{
 c049b02:	b086      	sub	sp, #24
    err = psa_its_get(PS_TABLE_FS_ID(PS_OBJ_TABLE_IDX_0),
 c049b04:	ac03      	add	r4, sp, #12
{
 c049b06:	4606      	mov	r6, r0
    err = psa_its_get(PS_TABLE_FS_ID(PS_OBJ_TABLE_IDX_0),
 c049b08:	f44f 73c0 	mov.w	r3, #384	@ 0x180
 c049b0c:	2200      	movs	r2, #0
 c049b0e:	2100      	movs	r1, #0
 c049b10:	9401      	str	r4, [sp, #4]
 c049b12:	2001      	movs	r0, #1
 c049b14:	9500      	str	r5, [sp, #0]
 c049b16:	f7f2 fdbc 	bl	c03c692 <psa_its_get>
    err = psa_its_get(PS_TABLE_FS_ID(PS_OBJ_TABLE_IDX_1),
 c049b1a:	f44f 73c0 	mov.w	r3, #384	@ 0x180
 c049b1e:	2200      	movs	r2, #0
 c049b20:	2100      	movs	r1, #0
 c049b22:	e9cd 6400 	strd	r6, r4, [sp]
    err = psa_its_get(PS_TABLE_FS_ID(PS_OBJ_TABLE_IDX_0),
 c049b26:	4607      	mov	r7, r0
    err = psa_its_get(PS_TABLE_FS_ID(PS_OBJ_TABLE_IDX_1),
 c049b28:	2002      	movs	r0, #2
 c049b2a:	f7f2 fdb2 	bl	c03c692 <psa_its_get>
 c049b2e:	4680      	mov	r8, r0
    /* Read table from the file system */
    ps_object_table_fs_read_table(&init_ctx);

#ifdef PS_ENCRYPTION
    /* Set object table key */
    err = ps_crypto_setkey();
 c049b30:	f7ff fcea 	bl	c049508 <ps_crypto_setkey>
    if (err != PSA_SUCCESS) {
 c049b34:	4604      	mov	r4, r0
 c049b36:	2800      	cmp	r0, #0
 c049b38:	d14a      	bne.n	c049bd0 <ps_object_table_init+0xd4>
    if (init_ctx->table_state[PS_OBJ_TABLE_IDX_0] != PS_OBJ_TABLE_INVALID) {
 c049b3a:	2f00      	cmp	r7, #0
 c049b3c:	d14c      	bne.n	c049bd8 <ps_object_table_init+0xdc>
        err = ps_crypto_authenticate(crypto,
 c049b3e:	f44f 72b2 	mov.w	r2, #356	@ 0x164
 c049b42:	4628      	mov	r0, r5
 c049b44:	f105 011c 	add.w	r1, r5, #28
 c049b48:	f7ff fdc2 	bl	c0496d0 <ps_crypto_authenticate>
        if (err != PSA_SUCCESS) {
 c049b4c:	1e07      	subs	r7, r0, #0
 c049b4e:	bf18      	it	ne
 c049b50:	2701      	movne	r7, #1
    if (init_ctx->table_state[PS_OBJ_TABLE_IDX_1] != PS_OBJ_TABLE_INVALID) {
 c049b52:	f1b8 0f00 	cmp.w	r8, #0
 c049b56:	d141      	bne.n	c049bdc <ps_object_table_init+0xe0>
        err = ps_crypto_authenticate(crypto,
 c049b58:	f44f 72b2 	mov.w	r2, #356	@ 0x164
 c049b5c:	4630      	mov	r0, r6
 c049b5e:	f106 011c 	add.w	r1, r6, #28
 c049b62:	f7ff fdb5 	bl	c0496d0 <ps_crypto_authenticate>
        if (err != PSA_SUCCESS) {
 c049b66:	f1b0 0800 	subs.w	r8, r0, #0
 c049b6a:	bf18      	it	ne
 c049b6c:	f04f 0801 	movne.w	r8, #1
    }
#else
    ps_object_table_authenticate_ctx_tables(&init_ctx);
#endif /* PS_ROLLBACK_PROTECTION */

    err = ps_crypto_destroykey();
 c049b70:	f7ff fd06 	bl	c049580 <ps_crypto_destroykey>
    if (err != PSA_SUCCESS) {
 c049b74:	4604      	mov	r4, r0
 c049b76:	bb58      	cbnz	r0, c049bd0 <ps_object_table_init+0xd4>
    if (PS_OBJECT_SYSTEM_VERSION !=
 c049b78:	7f2b      	ldrb	r3, [r5, #28]
    if ((init_ctx->table_state[PS_OBJ_TABLE_IDX_0] == PS_OBJ_TABLE_INVALID)
 c049b7a:	f240 1101 	movw	r1, #257	@ 0x101
        init_ctx->table_state[PS_OBJ_TABLE_IDX_0] = PS_OBJ_TABLE_INVALID;
 c049b7e:	2b01      	cmp	r3, #1
    if (PS_OBJECT_SYSTEM_VERSION !=
 c049b80:	7f33      	ldrb	r3, [r6, #28]
        init_ctx->table_state[PS_OBJ_TABLE_IDX_0] = PS_OBJ_TABLE_INVALID;
 c049b82:	bf18      	it	ne
 c049b84:	2701      	movne	r7, #1
        init_ctx->table_state[PS_OBJ_TABLE_IDX_1] = PS_OBJ_TABLE_INVALID;
 c049b86:	2b01      	cmp	r3, #1
 c049b88:	bf18      	it	ne
 c049b8a:	f04f 0801 	movne.w	r8, #1
         && (init_ctx->table_state[PS_OBJ_TABLE_IDX_1] ==
 c049b8e:	f88d 7014 	strb.w	r7, [sp, #20]
 c049b92:	f88d 8015 	strb.w	r8, [sp, #21]
    if ((init_ctx->table_state[PS_OBJ_TABLE_IDX_0] == PS_OBJ_TABLE_INVALID)
 c049b96:	f8bd 0014 	ldrh.w	r0, [sp, #20]
    uint8_t table0_swap_count =
 c049b9a:	7f6a      	ldrb	r2, [r5, #29]
    if ((init_ctx->table_state[PS_OBJ_TABLE_IDX_0] == PS_OBJ_TABLE_INVALID)
 c049b9c:	4288      	cmp	r0, r1
    uint8_t table1_swap_count =
 c049b9e:	7f73      	ldrb	r3, [r6, #29]
    if ((init_ctx->table_state[PS_OBJ_TABLE_IDX_0] == PS_OBJ_TABLE_INVALID)
 c049ba0:	d035      	beq.n	c049c0e <ps_object_table_init+0x112>
    } else if (init_ctx->table_state[PS_OBJ_TABLE_IDX_0] ==
 c049ba2:	2f01      	cmp	r7, #1
 c049ba4:	d11d      	bne.n	c049be2 <ps_object_table_init+0xe6>
          ps_obj_table_ctx.active_table  = PS_OBJ_TABLE_IDX_1;
 c049ba6:	f8a5 7180 	strh.w	r7, [r5, #384]	@ 0x180
    return (memcpy(dest, src, num));
 c049baa:	f44f 72c0 	mov.w	r2, #384	@ 0x180
 c049bae:	4631      	mov	r1, r6
 c049bb0:	4819      	ldr	r0, [pc, #100]	@ (c049c18 <ps_object_table_init+0x11c>)
 c049bb2:	f011 fd4b 	bl	c05b64c <memcpy>
    if (err != PSA_SUCCESS) {
        return err;
    }

    /* Remove the old object table file */
    err = psa_its_remove(PS_TABLE_FS_ID(ps_obj_table_ctx.scratch_table));
 c049bb6:	f895 0181 	ldrb.w	r0, [r5, #385]	@ 0x181
 c049bba:	2100      	movs	r1, #0
 c049bbc:	3001      	adds	r0, #1
 c049bbe:	f7f2 fdbb 	bl	c03c738 <psa_its_remove>
    if (err != PSA_SUCCESS && err != PSA_ERROR_DOES_NOT_EXIST) {
 c049bc2:	b110      	cbz	r0, c049bca <ps_object_table_init+0xce>
 c049bc4:	f110 0f8c 	cmn.w	r0, #140	@ 0x8c
 c049bc8:	d124      	bne.n	c049c14 <ps_object_table_init+0x118>
        return err;
    }
#endif /* PS_ROLLBACK_PROTECTION */

#ifdef PS_ENCRYPTION
    ps_crypto_set_iv(&ps_obj_table_ctx.obj_table.crypto);
 c049bca:	4813      	ldr	r0, [pc, #76]	@ (c049c18 <ps_object_table_init+0x11c>)
 c049bcc:	f7ff fce4 	bl	c049598 <ps_crypto_set_iv>
#endif

    return PSA_SUCCESS;
}
 c049bd0:	4620      	mov	r0, r4
 c049bd2:	b006      	add	sp, #24
 c049bd4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 c049bd8:	2701      	movs	r7, #1
 c049bda:	e7ba      	b.n	c049b52 <ps_object_table_init+0x56>
 c049bdc:	f04f 0801 	mov.w	r8, #1
 c049be0:	e7c6      	b.n	c049b70 <ps_object_table_init+0x74>
    } else if (init_ctx->table_state[PS_OBJ_TABLE_IDX_1] ==
 c049be2:	f1b8 0f01 	cmp.w	r8, #1
 c049be6:	d104      	bne.n	c049bf2 <ps_object_table_init+0xf6>
        ps_obj_table_ctx.active_table  = PS_OBJ_TABLE_IDX_0;
 c049be8:	f44f 7380 	mov.w	r3, #256	@ 0x100
 c049bec:	f8a5 3180 	strh.w	r3, [r5, #384]	@ 0x180
    if (ps_obj_table_ctx.active_table == PS_OBJ_TABLE_IDX_1) {
 c049bf0:	e7e1      	b.n	c049bb6 <ps_object_table_init+0xba>
    if ((table1_swap_count == 0) && (table0_swap_count != 1)) {
 c049bf2:	b92b      	cbnz	r3, c049c00 <ps_object_table_init+0x104>
 c049bf4:	2a01      	cmp	r2, #1
 c049bf6:	d0f7      	beq.n	c049be8 <ps_object_table_init+0xec>
        ps_obj_table_ctx.active_table  = PS_OBJ_TABLE_IDX_1;
 c049bf8:	2301      	movs	r3, #1
 c049bfa:	f8a5 3180 	strh.w	r3, [r5, #384]	@ 0x180
 c049bfe:	e7d4      	b.n	c049baa <ps_object_table_init+0xae>
    } else if ((table0_swap_count == 0) && (table1_swap_count != 1)) {
 c049c00:	b912      	cbnz	r2, c049c08 <ps_object_table_init+0x10c>
 c049c02:	2b01      	cmp	r3, #1
 c049c04:	d1f0      	bne.n	c049be8 <ps_object_table_init+0xec>
 c049c06:	e7f7      	b.n	c049bf8 <ps_object_table_init+0xfc>
    } else if (table1_swap_count > table0_swap_count) {
 c049c08:	429a      	cmp	r2, r3
 c049c0a:	d3f5      	bcc.n	c049bf8 <ps_object_table_init+0xfc>
 c049c0c:	e7ec      	b.n	c049be8 <ps_object_table_init+0xec>
        return PSA_ERROR_GENERIC_ERROR;
 c049c0e:	f06f 0483 	mvn.w	r4, #131	@ 0x83
 c049c12:	e7dd      	b.n	c049bd0 <ps_object_table_init+0xd4>
 c049c14:	4604      	mov	r4, r0
 c049c16:	e7db      	b.n	c049bd0 <ps_object_table_init+0xd4>
 c049c18:	30040280 	.word	0x30040280

0c049c1c <ps_object_table_get_free_fid>:
    return ps_get_object_entry_idx(uid, client_id, &idx);
}

psa_status_t ps_object_table_get_free_fid(uint32_t fid_num,
                                          uint32_t *p_fid)
{
 c049c1c:	b570      	push	{r4, r5, r6, lr}
 c049c1e:	460d      	mov	r5, r1
    if (idx_num == 0) {
 c049c20:	b310      	cbz	r0, c049c68 <ps_object_table_get_free_fid+0x4c>
    uint32_t last_free = 0;
 c049c22:	2300      	movs	r3, #0
    for (i = 0; i < PS_OBJ_TABLE_ENTRIES && idx_num > 0; i++) {
 c049c24:	461c      	mov	r4, r3
 c049c26:	4a12      	ldr	r2, [pc, #72]	@ (c049c70 <ps_object_table_get_free_fid+0x54>)
        if (p_table->obj_db[i].uid == TFM_PS_INVALID_UID) {
 c049c28:	e9d2 160c 	ldrd	r1, r6, [r2, #48]	@ 0x30
 c049c2c:	4331      	orrs	r1, r6
            idx_num--;
 c049c2e:	bf08      	it	eq
 c049c30:	4623      	moveq	r3, r4
    for (i = 0; i < PS_OBJ_TABLE_ENTRIES && idx_num > 0; i++) {
 c049c32:	f104 0401 	add.w	r4, r4, #1
            idx_num--;
 c049c36:	bf08      	it	eq
 c049c38:	f100 30ff 	addeq.w	r0, r0, #4294967295	@ 0xffffffff
    for (i = 0; i < PS_OBJ_TABLE_ENTRIES && idx_num > 0; i++) {
 c049c3c:	2c0b      	cmp	r4, #11
 c049c3e:	d00e      	beq.n	c049c5e <ps_object_table_get_free_fid+0x42>
 c049c40:	3220      	adds	r2, #32
 c049c42:	2800      	cmp	r0, #0
 c049c44:	d1f0      	bne.n	c049c28 <ps_object_table_get_free_fid+0xc>
    }

    /* There first two file IDs are reserved for the active table
     * and scratch table files.
     */
    fid = PS_OBJECT_FS_ID(idx);
 c049c46:	1cdc      	adds	r4, r3, #3

    /* If there is a file in the persistent area with that ID then remove it.
     * That can happen when the system is rebooted (e.g. power cut, ...) in the
     * middle of a create, write or delete operation.
     */
    err = psa_its_remove(fid);
 c049c48:	4620      	mov	r0, r4
 c049c4a:	2100      	movs	r1, #0
 c049c4c:	f7f2 fd74 	bl	c03c738 <psa_its_remove>
    if (err != PSA_SUCCESS && err != PSA_ERROR_DOES_NOT_EXIST) {
 c049c50:	b110      	cbz	r0, c049c58 <ps_object_table_get_free_fid+0x3c>
 c049c52:	f110 0f8c 	cmn.w	r0, #140	@ 0x8c
 c049c56:	d101      	bne.n	c049c5c <ps_object_table_get_free_fid+0x40>
        return err;
    }

    *p_fid = fid;

    return PSA_SUCCESS;
 c049c58:	2000      	movs	r0, #0
    *p_fid = fid;
 c049c5a:	602c      	str	r4, [r5, #0]
}
 c049c5c:	bd70      	pop	{r4, r5, r6, pc}
    if (idx_num != 0) {
 c049c5e:	2800      	cmp	r0, #0
 c049c60:	d0f1      	beq.n	c049c46 <ps_object_table_get_free_fid+0x2a>
        return PSA_ERROR_INSUFFICIENT_STORAGE;
 c049c62:	f06f 008d 	mvn.w	r0, #141	@ 0x8d
 c049c66:	e7f9      	b.n	c049c5c <ps_object_table_get_free_fid+0x40>
        return PSA_ERROR_INVALID_ARGUMENT;
 c049c68:	f06f 0086 	mvn.w	r0, #134	@ 0x86
 c049c6c:	e7f6      	b.n	c049c5c <ps_object_table_get_free_fid+0x40>
 c049c6e:	bf00      	nop
 c049c70:	30040280 	.word	0x30040280

0c049c74 <ps_object_table_set_obj_tbl_info>:

psa_status_t ps_object_table_set_obj_tbl_info(psa_storage_uid_t uid,
                                              int32_t client_id,
                                const struct ps_obj_table_info_t *obj_tbl_info)
{
 c049c74:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 c049c78:	4682      	mov	sl, r0
 c049c7a:	4689      	mov	r9, r1
 c049c7c:	4690      	mov	r8, r2
    psa_status_t err;
    uint32_t idx = 0;
    uint32_t backup_idx = 0;
 c049c7e:	2600      	movs	r6, #0
{
 c049c80:	b08a      	sub	sp, #40	@ 0x28
    struct ps_obj_table_entry_t backup_entry = {
 c049c82:	4d2f      	ldr	r5, [pc, #188]	@ (c049d40 <ps_object_table_set_obj_tbl_info+0xcc>)
 c049c84:	ac02      	add	r4, sp, #8
{
 c049c86:	461f      	mov	r7, r3
    struct ps_obj_table_entry_t backup_entry = {
 c049c88:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 c049c8a:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 c049c8c:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
 c049c90:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
        .uid = TFM_PS_INVALID_UID,
        .client_id = 0,
    };
    struct ps_obj_table_t *p_table = &ps_obj_table_ctx.obj_table;

    err = ps_get_object_entry_idx(uid, client_id, &backup_idx);
 c049c94:	4642      	mov	r2, r8
 c049c96:	4650      	mov	r0, sl
 c049c98:	4649      	mov	r1, r9
 c049c9a:	ab01      	add	r3, sp, #4
    uint32_t backup_idx = 0;
 c049c9c:	9601      	str	r6, [sp, #4]
    err = ps_get_object_entry_idx(uid, client_id, &backup_idx);
 c049c9e:	f7ff fec7 	bl	c049a30 <ps_get_object_entry_idx>
    if (err == PSA_SUCCESS) {
 c049ca2:	4c28      	ldr	r4, [pc, #160]	@ (c049d44 <ps_object_table_set_obj_tbl_info+0xd0>)
 c049ca4:	4686      	mov	lr, r0
 c049ca6:	2800      	cmp	r0, #0
 c049ca8:	d148      	bne.n	c049d3c <ps_object_table_set_obj_tbl_info+0xc8>
        /* If an entry exists for this UID, it creates a backup copy in case
         * an error happens while updating the new table in the filesystem.
         */
        (void)tfm_memcpy(&backup_entry, &p_table->obj_db[backup_idx],
 c049caa:	9b01      	ldr	r3, [sp, #4]
 c049cac:	ad02      	add	r5, sp, #8
 c049cae:	3301      	adds	r3, #1
 c049cb0:	eb04 1c43 	add.w	ip, r4, r3, lsl #5
 c049cb4:	4666      	mov	r6, ip
 c049cb6:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 c049cb8:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 c049cba:	e896 000f 	ldmia.w	r6, {r0, r1, r2, r3}
 c049cbe:	e885 000f 	stmia.w	r5, {r0, r1, r2, r3}
 c049cc2:	4606      	mov	r6, r0
    return (memset(ptr, value, num));
 c049cc4:	2220      	movs	r2, #32
 c049cc6:	4671      	mov	r1, lr
 c049cc8:	4660      	mov	r0, ip
    return (memcpy(dest, src, num));
 c049cca:	f8dc 5014 	ldr.w	r5, [ip, #20]
    return (memset(ptr, value, num));
 c049cce:	f011 fd2e 	bl	c05b72e <memset>

        /* Deletes old object information if it exist in the table */
        ps_table_delete_entry(backup_idx);
    }

    idx = PS_OBJECT_FS_ID_TO_IDX(obj_tbl_info->fid);
 c049cd2:	683a      	ldr	r2, [r7, #0]
 c049cd4:	1ed3      	subs	r3, r2, #3
    p_table->obj_db[idx].uid = uid;
 c049cd6:	eb04 1343 	add.w	r3, r4, r3, lsl #5
    p_table->obj_db[idx].client_id = client_id;
 c049cda:	f8c3 8038 	str.w	r8, [r3, #56]	@ 0x38

    /* Add new object information */
#ifdef PS_ENCRYPTION
    (void)tfm_memcpy(p_table->obj_db[idx].tag, obj_tbl_info->tag,
 c049cde:	f1a2 0802 	sub.w	r8, r2, #2
 c049ce2:	eb04 1848 	add.w	r8, r4, r8, lsl #5
    p_table->obj_db[idx].uid = uid;
 c049ce6:	e9c3 a90c 	strd	sl, r9, [r3, #48]	@ 0x30
    return (memcpy(dest, src, num));
 c049cea:	687b      	ldr	r3, [r7, #4]
 c049cec:	4647      	mov	r7, r8
 c049cee:	f103 0c10 	add.w	ip, r3, #16
 c049cf2:	463a      	mov	r2, r7
 c049cf4:	6818      	ldr	r0, [r3, #0]
 c049cf6:	6859      	ldr	r1, [r3, #4]
 c049cf8:	3308      	adds	r3, #8
 c049cfa:	c203      	stmia	r2!, {r0, r1}
 c049cfc:	4563      	cmp	r3, ip
 c049cfe:	4617      	mov	r7, r2
 c049d00:	d1f7      	bne.n	c049cf2 <ps_object_table_set_obj_tbl_info+0x7e>
                     PS_TAG_LEN_BYTES);
#else
    p_table->obj_db[idx].version = obj_tbl_info->version;
#endif

    err = ps_object_table_save_table(p_table);
 c049d02:	f7ff feaf 	bl	c049a64 <ps_object_table_save_table.constprop.0>
    if (err != PSA_SUCCESS) {
 c049d06:	4607      	mov	r7, r0
 c049d08:	b1a0      	cbz	r0, c049d34 <ps_object_table_set_obj_tbl_info+0xc0>
        if (backup_entry.uid != TFM_PS_INVALID_UID) {
 c049d0a:	ea56 0305 	orrs.w	r3, r6, r5
 c049d0e:	d00c      	beq.n	c049d2a <ps_object_table_set_obj_tbl_info+0xb6>
            /* Rollback the change in the table */
            (void)tfm_memcpy(&p_table->obj_db[backup_idx], &backup_entry,
 c049d10:	9b01      	ldr	r3, [sp, #4]
 c049d12:	e9cd 6506 	strd	r6, r5, [sp, #24]
 c049d16:	3301      	adds	r3, #1
 c049d18:	eb04 1443 	add.w	r4, r4, r3, lsl #5
 c049d1c:	ad02      	add	r5, sp, #8
 c049d1e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 c049d20:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 c049d22:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
 c049d26:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
    return (memset(ptr, value, num));
 c049d2a:	2220      	movs	r2, #32
 c049d2c:	2100      	movs	r1, #0
 c049d2e:	4640      	mov	r0, r8
 c049d30:	f011 fcfd 	bl	c05b72e <memset>

        ps_table_delete_entry(idx);
    }

    return err;
}
 c049d34:	4638      	mov	r0, r7
 c049d36:	b00a      	add	sp, #40	@ 0x28
 c049d38:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    struct ps_obj_table_entry_t backup_entry = {
 c049d3c:	4635      	mov	r5, r6
 c049d3e:	e7c8      	b.n	c049cd2 <ps_object_table_set_obj_tbl_info+0x5e>
 c049d40:	0c0615f8 	.word	0x0c0615f8
 c049d44:	30040280 	.word	0x30040280

0c049d48 <ps_object_table_get_obj_tbl_info>:

psa_status_t ps_object_table_get_obj_tbl_info(psa_storage_uid_t uid,
                                              int32_t client_id,
                                      struct ps_obj_table_info_t *obj_tbl_info)
{
 c049d48:	b573      	push	{r0, r1, r4, r5, r6, lr}
 c049d4a:	461d      	mov	r5, r3
    psa_status_t err;
    uint32_t idx;
    struct ps_obj_table_t *p_table = &ps_obj_table_ctx.obj_table;

    err = ps_get_object_entry_idx(uid, client_id, &idx);
 c049d4c:	ab01      	add	r3, sp, #4
 c049d4e:	f7ff fe6f 	bl	c049a30 <ps_get_object_entry_idx>
    if (err != PSA_SUCCESS) {
 c049d52:	4604      	mov	r4, r0
 c049d54:	b990      	cbnz	r0, c049d7c <ps_object_table_get_obj_tbl_info+0x34>
        return err;
    }

    obj_tbl_info->fid = PS_OBJECT_FS_ID(idx);
 c049d56:	9b01      	ldr	r3, [sp, #4]
 c049d58:	1cda      	adds	r2, r3, #3
 c049d5a:	602a      	str	r2, [r5, #0]

#ifdef PS_ENCRYPTION
    (void)tfm_memcpy(obj_tbl_info->tag, p_table->obj_db[idx].tag,
 c049d5c:	4a09      	ldr	r2, [pc, #36]	@ (c049d84 <ps_object_table_get_obj_tbl_info+0x3c>)
 c049d5e:	3301      	adds	r3, #1
 c049d60:	eb02 1243 	add.w	r2, r2, r3, lsl #5
    return (memcpy(dest, src, num));
 c049d64:	686d      	ldr	r5, [r5, #4]
 c049d66:	f102 0610 	add.w	r6, r2, #16
 c049d6a:	4613      	mov	r3, r2
 c049d6c:	cb03      	ldmia	r3!, {r0, r1}
 c049d6e:	42b3      	cmp	r3, r6
 c049d70:	6028      	str	r0, [r5, #0]
 c049d72:	6069      	str	r1, [r5, #4]
 c049d74:	461a      	mov	r2, r3
 c049d76:	f105 0508 	add.w	r5, r5, #8
 c049d7a:	d1f6      	bne.n	c049d6a <ps_object_table_get_obj_tbl_info+0x22>
#else
    obj_tbl_info->version = p_table->obj_db[idx].version;
#endif

    return PSA_SUCCESS;
}
 c049d7c:	4620      	mov	r0, r4
 c049d7e:	b002      	add	sp, #8
 c049d80:	bd70      	pop	{r4, r5, r6, pc}
 c049d82:	bf00      	nop
 c049d84:	30040280 	.word	0x30040280

0c049d88 <ps_object_table_delete_object>:

psa_status_t ps_object_table_delete_object(psa_storage_uid_t uid,
                                           int32_t client_id)
{
    uint32_t backup_idx = 0;
 c049d88:	2300      	movs	r3, #0
{
 c049d8a:	b5f0      	push	{r4, r5, r6, r7, lr}
 c049d8c:	b08b      	sub	sp, #44	@ 0x2c
    uint32_t backup_idx = 0;
 c049d8e:	9301      	str	r3, [sp, #4]
    struct ps_obj_table_t *p_table = &ps_obj_table_ctx.obj_table;

    /* Create a backup copy in case an error happens while updating the new
     * table in the filesystem.
     */
    err = ps_get_object_entry_idx(uid, client_id, &backup_idx);
 c049d90:	ab01      	add	r3, sp, #4
 c049d92:	f7ff fe4d 	bl	c049a30 <ps_get_object_entry_idx>
    if (err != PSA_SUCCESS) {
 c049d96:	4607      	mov	r7, r0
 c049d98:	b9e0      	cbnz	r0, c049dd4 <ps_object_table_delete_object+0x4c>
         * key.
         */
        return err;
    }

    (void)tfm_memcpy(&backup_entry, &p_table->obj_db[backup_idx],
 c049d9a:	9b01      	ldr	r3, [sp, #4]
 c049d9c:	4c0f      	ldr	r4, [pc, #60]	@ (c049ddc <ps_object_table_delete_object+0x54>)
 c049d9e:	3301      	adds	r3, #1
 c049da0:	eb04 1443 	add.w	r4, r4, r3, lsl #5
 c049da4:	4626      	mov	r6, r4
 c049da6:	ad02      	add	r5, sp, #8
 c049da8:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 c049daa:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 c049dac:	e896 000f 	ldmia.w	r6, {r0, r1, r2, r3}
 c049db0:	e885 000f 	stmia.w	r5, {r0, r1, r2, r3}
    return (memset(ptr, value, num));
 c049db4:	4639      	mov	r1, r7
 c049db6:	2220      	movs	r2, #32
 c049db8:	4620      	mov	r0, r4
 c049dba:	f011 fcb8 	bl	c05b72e <memset>
                     PS_OBJECTS_TABLE_ENTRY_SIZE);

    ps_table_delete_entry(backup_idx);

    err = ps_object_table_save_table(p_table);
 c049dbe:	f7ff fe51 	bl	c049a64 <ps_object_table_save_table.constprop.0>
    if (err != PSA_SUCCESS) {
 c049dc2:	4607      	mov	r7, r0
 c049dc4:	b130      	cbz	r0, c049dd4 <ps_object_table_delete_object+0x4c>
    return (memcpy(dest, src, num));
 c049dc6:	ad02      	add	r5, sp, #8
 c049dc8:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 c049dca:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 c049dcc:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
 c049dd0:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
       (void)tfm_memcpy(&p_table->obj_db[backup_idx], &backup_entry,
                        PS_OBJECTS_TABLE_ENTRY_SIZE);
    }

    return err;
}
 c049dd4:	4638      	mov	r0, r7
 c049dd6:	b00b      	add	sp, #44	@ 0x2c
 c049dd8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 c049dda:	bf00      	nop
 c049ddc:	30040280 	.word	0x30040280

0c049de0 <ps_object_table_delete_old_table>:

psa_status_t ps_object_table_delete_old_table(void)
{
    uint32_t table_id = PS_TABLE_FS_ID(ps_obj_table_ctx.scratch_table);
 c049de0:	4b03      	ldr	r3, [pc, #12]	@ (c049df0 <ps_object_table_delete_old_table+0x10>)

    return psa_its_remove(table_id);
 c049de2:	2100      	movs	r1, #0
    uint32_t table_id = PS_TABLE_FS_ID(ps_obj_table_ctx.scratch_table);
 c049de4:	f893 0181 	ldrb.w	r0, [r3, #385]	@ 0x181
    return psa_its_remove(table_id);
 c049de8:	3001      	adds	r0, #1
 c049dea:	f7f2 bca5 	b.w	c03c738 <psa_its_remove>
 c049dee:	bf00      	nop
 c049df0:	30040280 	.word	0x30040280

0c049df4 <tfm_spm_get_lifecycle_state>:
    /*
     * FixMe: return PSA_LIFECYCLE_UNKNOWN to the caller directly. It will be
     * implemented in the future.
     */
    return PSA_LIFECYCLE_UNKNOWN;
}
 c049df4:	2000      	movs	r0, #0
 c049df6:	4770      	bx	lr

0c049df8 <tfm_spm_psa_framework_version>:

uint32_t tfm_spm_psa_framework_version(void)
{
    return tfm_spm_client_psa_framework_version();
 c049df8:	f000 bf2e 	b.w	c04ac58 <tfm_spm_client_psa_framework_version>

0c049dfc <tfm_spm_psa_version>:
    uint32_t sid;

    TFM_CORE_ASSERT(args != NULL);
    sid = (uint32_t)args[0];

    return tfm_spm_client_psa_version(sid, ns_caller);
 c049dfc:	6800      	ldr	r0, [r0, #0]
 c049dfe:	f000 bf2e 	b.w	c04ac5e <tfm_spm_client_psa_version>

0c049e02 <tfm_spm_psa_connect>:
}

psa_status_t tfm_spm_psa_connect(uint32_t *args, bool ns_caller)
{
 c049e02:	460a      	mov	r2, r1

    TFM_CORE_ASSERT(args != NULL);
    sid = (uint32_t)args[0];
    version = (uint32_t)args[1];

    return tfm_spm_client_psa_connect(sid, version, ns_caller);
 c049e04:	e9d0 0100 	ldrd	r0, r1, [r0]
 c049e08:	f000 bf3c 	b.w	c04ac84 <tfm_spm_client_psa_connect>

0c049e0c <tfm_spm_psa_call>:
}

psa_status_t tfm_spm_psa_call(uint32_t *args, bool ns_caller, uint32_t lr)
{
 c049e0c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c049e10:	b089      	sub	sp, #36	@ 0x24
 c049e12:	4604      	mov	r4, r0
 c049e14:	460d      	mov	r5, r1
    uint32_t privileged;
    int32_t type;
    struct tfm_control_parameter_t ctrl_param;

    TFM_CORE_ASSERT(args != NULL);
    handle = (psa_handle_t)args[0];
 c049e16:	f8d0 8000 	ldr.w	r8, [r0]

    partition = tfm_spm_get_running_partition();
 c049e1a:	f012 fc7b 	bl	c05c714 <tfm_spm_get_running_partition>
    if (!partition) {
 c049e1e:	4606      	mov	r6, r0
 c049e20:	b908      	cbnz	r0, c049e26 <tfm_spm_psa_call+0x1a>
        tfm_core_panic();
 c049e22:	f014 fc61 	bl	c05e6e8 <tfm_core_panic>
    }
    privileged = tfm_spm_partition_get_privileged_mode(
        partition->p_static->flags);
 c049e26:	6833      	ldr	r3, [r6, #0]
    privileged = tfm_spm_partition_get_privileged_mode(
 c049e28:	6898      	ldr	r0, [r3, #8]
 c049e2a:	f012 fc5b 	bl	c05c6e4 <tfm_spm_partition_get_privileged_mode>

    /*
     * Read parameters from the arguments. It is a PROGRAMMER ERROR if the
     * memory reference for buffer is invalid or not readable.
     */
    if (tfm_memory_check((const void *)args[1],
 c049e2e:	9000      	str	r0, [sp, #0]
    privileged = tfm_spm_partition_get_privileged_mode(
 c049e30:	4606      	mov	r6, r0
    if (tfm_memory_check((const void *)args[1],
 c049e32:	2302      	movs	r3, #2
 c049e34:	462a      	mov	r2, r5
 c049e36:	210c      	movs	r1, #12
 c049e38:	6860      	ldr	r0, [r4, #4]
 c049e3a:	f012 fd51 	bl	c05c8e0 <tfm_memory_check>
 c049e3e:	b138      	cbz	r0, c049e50 <tfm_spm_psa_call+0x44>
        sizeof(struct tfm_control_parameter_t), ns_caller,
        TFM_MEMORY_ACCESS_RW, privileged) != SPM_SUCCESS) {
        TFM_PROGRAMMER_ERROR(ns_caller, PSA_ERROR_PROGRAMMER_ERROR);
 c049e40:	b125      	cbz	r5, c049e4c <tfm_spm_psa_call+0x40>
 c049e42:	f06f 0080 	mvn.w	r0, #128	@ 0x80
        TFM_PROGRAMMER_ERROR(ns_caller, PSA_ERROR_PROGRAMMER_ERROR);
    }

    return tfm_spm_client_psa_call(handle, type, inptr, in_num, outptr, out_num,
                                   ns_caller, privileged);
}
 c049e46:	b009      	add	sp, #36	@ 0x24
 c049e48:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        TFM_PROGRAMMER_ERROR(ns_caller, PSA_ERROR_PROGRAMMER_ERROR);
 c049e4c:	f014 fc4c 	bl	c05e6e8 <tfm_core_panic>
    spm_memcpy(&ctrl_param, (const void *)args[1], sizeof(ctrl_param));
 c049e50:	6861      	ldr	r1, [r4, #4]
 c049e52:	220c      	movs	r2, #12
 c049e54:	a805      	add	r0, sp, #20
 c049e56:	f013 fdd5 	bl	c05da04 <spm_memcpy>
    in_num = ctrl_param.in_len;
 c049e5a:	e9dd 7a05 	ldrd	r7, sl, [sp, #20]
    outptr = (psa_outvec *)args[3];
 c049e5e:	e9d4 9402 	ldrd	r9, r4, [r4, #8]
    if (type < 0) {
 c049e62:	2f00      	cmp	r7, #0
    out_num = ctrl_param.out_len;
 c049e64:	f8dd b01c 	ldr.w	fp, [sp, #28]
    if (type < 0) {
 c049e68:	da03      	bge.n	c049e72 <tfm_spm_psa_call+0x66>
        TFM_PROGRAMMER_ERROR(ns_caller, PSA_ERROR_PROGRAMMER_ERROR);
 c049e6a:	2d00      	cmp	r5, #0
 c049e6c:	d1e9      	bne.n	c049e42 <tfm_spm_psa_call+0x36>
 c049e6e:	f014 fc3b 	bl	c05e6e8 <tfm_core_panic>
    return tfm_spm_client_psa_call(handle, type, inptr, in_num, outptr, out_num,
 c049e72:	4653      	mov	r3, sl
 c049e74:	464a      	mov	r2, r9
 c049e76:	4639      	mov	r1, r7
 c049e78:	4640      	mov	r0, r8
 c049e7a:	e9cd 5602 	strd	r5, r6, [sp, #8]
 c049e7e:	e9cd 4b00 	strd	r4, fp, [sp]
 c049e82:	f000 ff59 	bl	c04ad38 <tfm_spm_client_psa_call>
 c049e86:	e7de      	b.n	c049e46 <tfm_spm_psa_call+0x3a>

0c049e88 <tfm_spm_psa_close>:
    psa_handle_t handle;

    TFM_CORE_ASSERT(args != NULL);
    handle = args[0];

    tfm_spm_client_psa_close(handle, ns_caller);
 c049e88:	6800      	ldr	r0, [r0, #0]
 c049e8a:	f001 b881 	b.w	c04af90 <tfm_spm_client_psa_close>

0c049e8e <tfm_spm_psa_wait>:
}

/********************* SPM functions for PSA Service APIs ********************/

psa_signal_t tfm_spm_psa_wait(uint32_t *args)
{
 c049e8e:	b570      	push	{r4, r5, r6, lr}
    uint32_t timeout;
    struct partition_t *partition = NULL;

    TFM_CORE_ASSERT(args != NULL);
    signal_mask = (psa_signal_t)args[0];
    timeout = args[1];
 c049e90:	e9d0 5600 	ldrd	r5, r6, [r0]
     * Timeout[30:0] are reserved for future use.
     * SPM must ignore the value of RES.
     */
    timeout &= PSA_TIMEOUT_MASK;

    partition = tfm_spm_get_running_partition();
 c049e94:	f012 fc3e 	bl	c05c714 <tfm_spm_get_running_partition>
    if (!partition) {
 c049e98:	4604      	mov	r4, r0
 c049e9a:	b908      	cbnz	r0, c049ea0 <tfm_spm_psa_wait+0x12>
        tfm_core_panic();
 c049e9c:	f014 fc24 	bl	c05e6e8 <tfm_core_panic>

    /*
     * It is a PROGRAMMER ERROR if the signal_mask does not include any assigned
     * signals.
     */
    if ((partition->signals_allowed & signal_mask) == 0) {
 c049ea0:	6ee3      	ldr	r3, [r4, #108]	@ 0x6c
 c049ea2:	421d      	tst	r5, r3
 c049ea4:	d101      	bne.n	c049eaa <tfm_spm_psa_wait+0x1c>
        tfm_core_panic();
 c049ea6:	f014 fc1f 	bl	c05e6e8 <tfm_core_panic>
     * tfm_event_wait() blocks the caller thread if no signals are available.
     * In this case, the return value of this function is temporary set into
     * runtime context. After new signal(s) are available, the return value
     * is updated with the available signal(s) and blocked thread gets to run.
     */
    if (timeout == PSA_BLOCK &&
 c049eaa:	2e00      	cmp	r6, #0
 c049eac:	da07      	bge.n	c049ebe <tfm_spm_psa_wait+0x30>
        (partition->signals_asserted & signal_mask) == 0) {
 c049eae:	6f63      	ldr	r3, [r4, #116]	@ 0x74
    if (timeout == PSA_BLOCK &&
 c049eb0:	421d      	tst	r5, r3
 c049eb2:	d104      	bne.n	c049ebe <tfm_spm_psa_wait+0x30>
        partition->signals_waiting = signal_mask;
 c049eb4:	6725      	str	r5, [r4, #112]	@ 0x70
        tfm_event_wait(&partition->event);
 c049eb6:	f104 005c 	add.w	r0, r4, #92	@ 0x5c
 c049eba:	f014 fbc5 	bl	c05e648 <tfm_event_wait>
    }

    return partition->signals_asserted & signal_mask;
 c049ebe:	6f60      	ldr	r0, [r4, #116]	@ 0x74
}
 c049ec0:	4028      	ands	r0, r5
 c049ec2:	bd70      	pop	{r4, r5, r6, pc}

0c049ec4 <tfm_spm_psa_get>:

psa_status_t tfm_spm_psa_get(uint32_t *args)
{
 c049ec4:	b573      	push	{r0, r1, r4, r5, r6, lr}
    struct partition_t *partition = NULL;
    uint32_t privileged;

    TFM_CORE_ASSERT(args != NULL);
    signal = (psa_signal_t)args[0];
    msg = (psa_msg_t *)args[1];
 c049ec6:	e9d0 5600 	ldrd	r5, r6, [r0]

    /*
     * Only one message could be retrieved every time for psa_get(). It is a
     * fatal error if the input signal has more than a signal bit set.
     */
    if (!IS_ONLY_ONE_BIT_IN_UINT32(signal)) {
 c049eca:	b115      	cbz	r5, c049ed2 <tfm_spm_psa_get+0xe>
 c049ecc:	1e6b      	subs	r3, r5, #1
 c049ece:	422b      	tst	r3, r5
 c049ed0:	d001      	beq.n	c049ed6 <tfm_spm_psa_get+0x12>
        tfm_core_panic();
 c049ed2:	f014 fc09 	bl	c05e6e8 <tfm_core_panic>
    }

    partition = tfm_spm_get_running_partition();
 c049ed6:	f012 fc1d 	bl	c05c714 <tfm_spm_get_running_partition>
    if (!partition) {
 c049eda:	4604      	mov	r4, r0
 c049edc:	b908      	cbnz	r0, c049ee2 <tfm_spm_psa_get+0x1e>
        tfm_core_panic();
 c049ede:	f014 fc03 	bl	c05e6e8 <tfm_core_panic>
    }
    privileged = tfm_spm_partition_get_privileged_mode(
        partition->p_static->flags);
 c049ee2:	6823      	ldr	r3, [r4, #0]
    privileged = tfm_spm_partition_get_privileged_mode(
 c049ee4:	6898      	ldr	r0, [r3, #8]
 c049ee6:	f012 fbfd 	bl	c05c6e4 <tfm_spm_partition_get_privileged_mode>

    /*
     * Write the message to the service buffer. It is a fatal error if the
     * input msg pointer is not a valid memory reference or not read-write.
     */
    if (tfm_memory_check(msg, sizeof(psa_msg_t), false, TFM_MEMORY_ACCESS_RW,
 c049eea:	2302      	movs	r3, #2
 c049eec:	9000      	str	r0, [sp, #0]
 c049eee:	2200      	movs	r2, #0
 c049ef0:	2130      	movs	r1, #48	@ 0x30
 c049ef2:	4630      	mov	r0, r6
 c049ef4:	f012 fcf4 	bl	c05c8e0 <tfm_memory_check>
 c049ef8:	b108      	cbz	r0, c049efe <tfm_spm_psa_get+0x3a>
        privileged) != SPM_SUCCESS) {
        tfm_core_panic();
 c049efa:	f014 fbf5 	bl	c05e6e8 <tfm_core_panic>
    /*
     * It is a fatal error if the caller call psa_get() when no message has
     * been set. The caller must call this function after an RoT Service signal
     * is returned by psa_wait().
     */
    if (partition->signals_asserted == 0) {
 c049efe:	6f63      	ldr	r3, [r4, #116]	@ 0x74
 c049f00:	b90b      	cbnz	r3, c049f06 <tfm_spm_psa_get+0x42>
        tfm_core_panic();
 c049f02:	f014 fbf1 	bl	c05e6e8 <tfm_core_panic>
    }

    /*
     * It is a fatal error if the RoT Service signal is not currently asserted.
     */
    if ((partition->signals_asserted & signal) == 0) {
 c049f06:	6f63      	ldr	r3, [r4, #116]	@ 0x74
 c049f08:	421d      	tst	r5, r3
 c049f0a:	d101      	bne.n	c049f10 <tfm_spm_psa_get+0x4c>
        tfm_core_panic();
 c049f0c:	f014 fbec 	bl	c05e6e8 <tfm_core_panic>

    /*
     * Get message by signal from partition. It is a fatal error if getting
     * failed, which means the input signal is not correspond to an RoT service.
     */
    tmp_msg = tfm_spm_get_msg_by_signal(partition, signal);
 c049f10:	4629      	mov	r1, r5
 c049f12:	4620      	mov	r0, r4
 c049f14:	f012 fbc7 	bl	c05c6a6 <tfm_spm_get_msg_by_signal>
    if (!tmp_msg) {
 c049f18:	b158      	cbz	r0, c049f32 <tfm_spm_psa_get+0x6e>
        return PSA_ERROR_DOES_NOT_EXIST;
    }

    (TFM_GET_CONTAINER_PTR(tmp_msg,
                           struct tfm_conn_handle_t,
                           internal_msg))->status = TFM_HANDLE_STATUS_ACTIVE;
 c049f1a:	2301      	movs	r3, #1

    spm_memcpy(msg, &tmp_msg->msg, sizeof(psa_msg_t));
 c049f1c:	f100 0110 	add.w	r1, r0, #16
                           internal_msg))->status = TFM_HANDLE_STATUS_ACTIVE;
 c049f20:	f840 3c08 	str.w	r3, [r0, #-8]
    spm_memcpy(msg, &tmp_msg->msg, sizeof(psa_msg_t));
 c049f24:	2230      	movs	r2, #48	@ 0x30
 c049f26:	4630      	mov	r0, r6
 c049f28:	f013 fd6c 	bl	c05da04 <spm_memcpy>

    return PSA_SUCCESS;
 c049f2c:	2000      	movs	r0, #0
}
 c049f2e:	b002      	add	sp, #8
 c049f30:	bd70      	pop	{r4, r5, r6, pc}
        return PSA_ERROR_DOES_NOT_EXIST;
 c049f32:	f06f 008b 	mvn.w	r0, #139	@ 0x8b
 c049f36:	e7fa      	b.n	c049f2e <tfm_spm_psa_get+0x6a>

0c049f38 <tfm_spm_psa_set_rhandle>:

void tfm_spm_psa_set_rhandle(uint32_t *args)
{
 c049f38:	b570      	push	{r4, r5, r6, lr}
    struct tfm_msg_body_t *msg = NULL;
    struct tfm_conn_handle_t *conn_handle;

    TFM_CORE_ASSERT(args != NULL);
    msg_handle = (psa_handle_t)args[0];
    rhandle = (void *)args[1];
 c049f3a:	e9d0 6500 	ldrd	r6, r5, [r0]

    /* It is a fatal error if message handle is invalid */
    msg = tfm_spm_get_msg_from_handle(msg_handle);
 c049f3e:	4630      	mov	r0, r6
 c049f40:	f012 fcb0 	bl	c05c8a4 <tfm_spm_get_msg_from_handle>
    if (!msg) {
 c049f44:	4604      	mov	r4, r0
 c049f46:	b908      	cbnz	r0, c049f4c <tfm_spm_psa_set_rhandle+0x14>
        tfm_core_panic();
 c049f48:	f014 fbce 	bl	c05e6e8 <tfm_core_panic>
    }

    /* It is a PROGRAMMER ERROR if a stateless service sets rhandle. */
    if (!msg->service->service_db->connection_based) {
 c049f4c:	6863      	ldr	r3, [r4, #4]
 c049f4e:	681b      	ldr	r3, [r3, #0]
 c049f50:	7c5b      	ldrb	r3, [r3, #17]
 c049f52:	b90b      	cbnz	r3, c049f58 <tfm_spm_psa_set_rhandle+0x20>
        tfm_core_panic();
 c049f54:	f014 fbc8 	bl	c05e6e8 <tfm_core_panic>
    }

    msg->msg.rhandle = rhandle;
    conn_handle = tfm_spm_to_handle_instance(msg_handle);
 c049f58:	4630      	mov	r0, r6
    msg->msg.rhandle = rhandle;
 c049f5a:	61e5      	str	r5, [r4, #28]
    conn_handle = tfm_spm_to_handle_instance(msg_handle);
 c049f5c:	f012 fb5c 	bl	c05c618 <tfm_spm_to_handle_instance>

    /* Store reverse handle for following client calls. */
    tfm_spm_set_rhandle(msg->service, conn_handle, rhandle);
 c049f60:	462a      	mov	r2, r5
    conn_handle = tfm_spm_to_handle_instance(msg_handle);
 c049f62:	4601      	mov	r1, r0
    tfm_spm_set_rhandle(msg->service, conn_handle, rhandle);
 c049f64:	6860      	ldr	r0, [r4, #4]
}
 c049f66:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    tfm_spm_set_rhandle(msg->service, conn_handle, rhandle);
 c049f6a:	f012 bb99 	b.w	c05c6a0 <tfm_spm_set_rhandle>

0c049f6e <tfm_spm_psa_read>:

size_t tfm_spm_psa_read(uint32_t *args)
{
 c049f6e:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
    struct partition_t *partition = NULL;

    TFM_CORE_ASSERT(args != NULL);
    msg_handle = (psa_handle_t)args[0];
    invec_idx = args[1];
    buffer = (void *)args[2];
 c049f72:	e9d0 7901 	ldrd	r7, r9, [r0, #4]
    num_bytes = (size_t)args[3];
 c049f76:	f8d0 a00c 	ldr.w	sl, [r0, #12]

    /* It is a fatal error if message handle is invalid */
    msg = tfm_spm_get_msg_from_handle(msg_handle);
 c049f7a:	6800      	ldr	r0, [r0, #0]
 c049f7c:	f012 fc92 	bl	c05c8a4 <tfm_spm_get_msg_from_handle>
    if (!msg) {
 c049f80:	4604      	mov	r4, r0
 c049f82:	b908      	cbnz	r0, c049f88 <tfm_spm_psa_read+0x1a>
        tfm_core_panic();
 c049f84:	f014 fbb0 	bl	c05e6e8 <tfm_core_panic>
    }

    partition = msg->service->partition;
 c049f88:	6863      	ldr	r3, [r4, #4]
    privileged = tfm_spm_partition_get_privileged_mode(
        partition->p_static->flags);
 c049f8a:	685b      	ldr	r3, [r3, #4]
 c049f8c:	681b      	ldr	r3, [r3, #0]
    privileged = tfm_spm_partition_get_privileged_mode(
 c049f8e:	6898      	ldr	r0, [r3, #8]
 c049f90:	f012 fba8 	bl	c05c6e4 <tfm_spm_partition_get_privileged_mode>

    /*
     * It is a fatal error if message handle does not refer to a request
     * message
     */
    if (msg->msg.type < PSA_IPC_CALL) {
 c049f94:	6923      	ldr	r3, [r4, #16]
    privileged = tfm_spm_partition_get_privileged_mode(
 c049f96:	4680      	mov	r8, r0
    if (msg->msg.type < PSA_IPC_CALL) {
 c049f98:	2b00      	cmp	r3, #0
 c049f9a:	da01      	bge.n	c049fa0 <tfm_spm_psa_read+0x32>
        tfm_core_panic();
 c049f9c:	f014 fba4 	bl	c05e6e8 <tfm_core_panic>

    /*
     * It is a fatal error if invec_idx is equal to or greater than
     * PSA_MAX_IOVEC
     */
    if (invec_idx >= PSA_MAX_IOVEC) {
 c049fa0:	2f03      	cmp	r7, #3
 c049fa2:	d901      	bls.n	c049fa8 <tfm_spm_psa_read+0x3a>
        tfm_core_panic();
 c049fa4:	f014 fba0 	bl	c05e6e8 <tfm_core_panic>
    }

    /* There was no remaining data in this input vector */
    if (msg->msg.in_size[invec_idx] == 0) {
 c049fa8:	eb04 0687 	add.w	r6, r4, r7, lsl #2
 c049fac:	6a35      	ldr	r5, [r6, #32]
 c049fae:	b1dd      	cbz	r5, c049fe8 <tfm_spm_psa_read+0x7a>

    /*
     * Copy the client data to the service buffer. It is a fatal error
     * if the memory reference for buffer is invalid or not read-write.
     */
    if (tfm_memory_check(buffer, num_bytes, false,
 c049fb0:	2302      	movs	r3, #2
 c049fb2:	2200      	movs	r2, #0
 c049fb4:	4651      	mov	r1, sl
 c049fb6:	4648      	mov	r0, r9
 c049fb8:	f8cd 8000 	str.w	r8, [sp]
 c049fbc:	f012 fc90 	bl	c05c8e0 <tfm_memory_check>
 c049fc0:	b108      	cbz	r0, c049fc6 <tfm_spm_psa_read+0x58>
        TFM_MEMORY_ACCESS_RW, privileged) != SPM_SUCCESS) {
        tfm_core_panic();
 c049fc2:	f014 fb91 	bl	c05e6e8 <tfm_core_panic>
    }

    bytes = num_bytes > msg->msg.in_size[invec_idx] ?
 c049fc6:	6a35      	ldr	r5, [r6, #32]
 c049fc8:	eb04 04c7 	add.w	r4, r4, r7, lsl #3
 c049fcc:	4555      	cmp	r5, sl
 c049fce:	bf28      	it	cs
 c049fd0:	4655      	movcs	r5, sl
                        msg->msg.in_size[invec_idx] : num_bytes;

    spm_memcpy(buffer, msg->invec[invec_idx].base, bytes);
 c049fd2:	4648      	mov	r0, r9
 c049fd4:	462a      	mov	r2, r5
 c049fd6:	6c21      	ldr	r1, [r4, #64]	@ 0x40
 c049fd8:	f013 fd14 	bl	c05da04 <spm_memcpy>

    /* There maybe some remaining data */
    msg->invec[invec_idx].base = (char *)msg->invec[invec_idx].base + bytes;
 c049fdc:	6c23      	ldr	r3, [r4, #64]	@ 0x40
 c049fde:	442b      	add	r3, r5
 c049fe0:	6423      	str	r3, [r4, #64]	@ 0x40
    msg->msg.in_size[invec_idx] -= bytes;
 c049fe2:	6a33      	ldr	r3, [r6, #32]
 c049fe4:	1b5b      	subs	r3, r3, r5
 c049fe6:	6233      	str	r3, [r6, #32]

    return bytes;
}
 c049fe8:	4628      	mov	r0, r5
 c049fea:	b002      	add	sp, #8
 c049fec:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

0c049ff0 <tfm_spm_psa_skip>:

size_t tfm_spm_psa_skip(uint32_t *args)
{
 c049ff0:	b570      	push	{r4, r5, r6, lr}
    struct tfm_msg_body_t *msg = NULL;

    TFM_CORE_ASSERT(args != NULL);
    msg_handle = (psa_handle_t)args[0];
    invec_idx = args[1];
    num_bytes = (size_t)args[2];
 c049ff2:	e9d0 6501 	ldrd	r6, r5, [r0, #4]

    /* It is a fatal error if message handle is invalid */
    msg = tfm_spm_get_msg_from_handle(msg_handle);
 c049ff6:	6800      	ldr	r0, [r0, #0]
 c049ff8:	f012 fc54 	bl	c05c8a4 <tfm_spm_get_msg_from_handle>
    if (!msg) {
 c049ffc:	4604      	mov	r4, r0
 c049ffe:	b908      	cbnz	r0, c04a004 <tfm_spm_psa_skip+0x14>
        tfm_core_panic();
 c04a000:	f014 fb72 	bl	c05e6e8 <tfm_core_panic>

    /*
     * It is a fatal error if message handle does not refer to a request
     * message
     */
    if (msg->msg.type < PSA_IPC_CALL) {
 c04a004:	6923      	ldr	r3, [r4, #16]
 c04a006:	2b00      	cmp	r3, #0
 c04a008:	da01      	bge.n	c04a00e <tfm_spm_psa_skip+0x1e>
        tfm_core_panic();
 c04a00a:	f014 fb6d 	bl	c05e6e8 <tfm_core_panic>

    /*
     * It is a fatal error if invec_idx is equal to or greater than
     * PSA_MAX_IOVEC
     */
    if (invec_idx >= PSA_MAX_IOVEC) {
 c04a00e:	2e03      	cmp	r6, #3
 c04a010:	d901      	bls.n	c04a016 <tfm_spm_psa_skip+0x26>
        tfm_core_panic();
 c04a012:	f014 fb69 	bl	c05e6e8 <tfm_core_panic>
    }

    /* There was no remaining data in this input vector */
    if (msg->msg.in_size[invec_idx] == 0) {
 c04a016:	eb04 0186 	add.w	r1, r4, r6, lsl #2
 c04a01a:	6a08      	ldr	r0, [r1, #32]
 c04a01c:	b158      	cbz	r0, c04a036 <tfm_spm_psa_skip+0x46>

    /*
     * If num_bytes is greater than the remaining size of the input vector then
     * the remaining size of the input vector is used.
     */
    if (num_bytes > msg->msg.in_size[invec_idx]) {
 c04a01e:	4285      	cmp	r5, r0
 c04a020:	462b      	mov	r3, r5
 c04a022:	bf28      	it	cs
 c04a024:	4603      	movcs	r3, r0
        num_bytes = msg->msg.in_size[invec_idx];
    }

    /* There maybe some remaining data */
    msg->invec[invec_idx].base = (char *)msg->invec[invec_idx].base +
 c04a026:	eb04 04c6 	add.w	r4, r4, r6, lsl #3
 c04a02a:	6c22      	ldr	r2, [r4, #64]	@ 0x40
                                 num_bytes;
    msg->msg.in_size[invec_idx] -= num_bytes;
 c04a02c:	1ac0      	subs	r0, r0, r3
    msg->invec[invec_idx].base = (char *)msg->invec[invec_idx].base +
 c04a02e:	441a      	add	r2, r3
 c04a030:	6422      	str	r2, [r4, #64]	@ 0x40
    msg->msg.in_size[invec_idx] -= num_bytes;
 c04a032:	6208      	str	r0, [r1, #32]

    return num_bytes;
 c04a034:	4618      	mov	r0, r3
}
 c04a036:	bd70      	pop	{r4, r5, r6, pc}

0c04a038 <tfm_spm_psa_write>:

void tfm_spm_psa_write(uint32_t *args)
{
 c04a038:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
    struct partition_t *partition = NULL;

    TFM_CORE_ASSERT(args != NULL);
    msg_handle = (psa_handle_t)args[0];
    outvec_idx = args[1];
    buffer = (void *)args[2];
 c04a03c:	e9d0 6901 	ldrd	r6, r9, [r0, #4]
    num_bytes = (size_t)args[3];
 c04a040:	68c7      	ldr	r7, [r0, #12]

    /* It is a fatal error if message handle is invalid */
    msg = tfm_spm_get_msg_from_handle(msg_handle);
 c04a042:	6800      	ldr	r0, [r0, #0]
 c04a044:	f012 fc2e 	bl	c05c8a4 <tfm_spm_get_msg_from_handle>
    if (!msg) {
 c04a048:	4604      	mov	r4, r0
 c04a04a:	b908      	cbnz	r0, c04a050 <tfm_spm_psa_write+0x18>
        tfm_core_panic();
 c04a04c:	f014 fb4c 	bl	c05e6e8 <tfm_core_panic>
    }

    partition = msg->service->partition;
 c04a050:	6863      	ldr	r3, [r4, #4]
    privileged = tfm_spm_partition_get_privileged_mode(
        partition->p_static->flags);
 c04a052:	685b      	ldr	r3, [r3, #4]
 c04a054:	681b      	ldr	r3, [r3, #0]
    privileged = tfm_spm_partition_get_privileged_mode(
 c04a056:	6898      	ldr	r0, [r3, #8]
 c04a058:	f012 fb44 	bl	c05c6e4 <tfm_spm_partition_get_privileged_mode>

    /*
     * It is a fatal error if message handle does not refer to a request
     * message
     */
    if (msg->msg.type < PSA_IPC_CALL) {
 c04a05c:	6923      	ldr	r3, [r4, #16]
    privileged = tfm_spm_partition_get_privileged_mode(
 c04a05e:	4680      	mov	r8, r0
    if (msg->msg.type < PSA_IPC_CALL) {
 c04a060:	2b00      	cmp	r3, #0
 c04a062:	da01      	bge.n	c04a068 <tfm_spm_psa_write+0x30>
        tfm_core_panic();
 c04a064:	f014 fb40 	bl	c05e6e8 <tfm_core_panic>

    /*
     * It is a fatal error if outvec_idx is equal to or greater than
     * PSA_MAX_IOVEC
     */
    if (outvec_idx >= PSA_MAX_IOVEC) {
 c04a068:	2e03      	cmp	r6, #3
 c04a06a:	d901      	bls.n	c04a070 <tfm_spm_psa_write+0x38>
        tfm_core_panic();
 c04a06c:	f014 fb3c 	bl	c05e6e8 <tfm_core_panic>

    /*
     * It is a fatal error if the call attempts to write data past the end of
     * the client output vector
     */
    if (num_bytes > msg->msg.out_size[outvec_idx] -
 c04a070:	eb04 05c6 	add.w	r5, r4, r6, lsl #3
 c04a074:	360c      	adds	r6, #12
 c04a076:	f854 3026 	ldr.w	r3, [r4, r6, lsl #2]
 c04a07a:	6e6a      	ldr	r2, [r5, #100]	@ 0x64
 c04a07c:	1a9b      	subs	r3, r3, r2
 c04a07e:	42bb      	cmp	r3, r7
 c04a080:	d201      	bcs.n	c04a086 <tfm_spm_psa_write+0x4e>
        msg->outvec[outvec_idx].len) {
        tfm_core_panic();
 c04a082:	f014 fb31 	bl	c05e6e8 <tfm_core_panic>

    /*
     * Copy the service buffer to client outvecs. It is a fatal error
     * if the memory reference for buffer is invalid or not readable.
     */
    if (tfm_memory_check(buffer, num_bytes, false,
 c04a086:	2301      	movs	r3, #1
 c04a088:	2200      	movs	r2, #0
 c04a08a:	4639      	mov	r1, r7
 c04a08c:	4648      	mov	r0, r9
 c04a08e:	f8cd 8000 	str.w	r8, [sp]
 c04a092:	f012 fc25 	bl	c05c8e0 <tfm_memory_check>
 c04a096:	b108      	cbz	r0, c04a09c <tfm_spm_psa_write+0x64>
        TFM_MEMORY_ACCESS_RO, privileged) != SPM_SUCCESS) {
        tfm_core_panic();
 c04a098:	f014 fb26 	bl	c05e6e8 <tfm_core_panic>
    }

    spm_memcpy((char *)msg->outvec[outvec_idx].base +
 c04a09c:	e9d5 0318 	ldrd	r0, r3, [r5, #96]	@ 0x60
 c04a0a0:	463a      	mov	r2, r7
 c04a0a2:	4649      	mov	r1, r9
 c04a0a4:	4418      	add	r0, r3
 c04a0a6:	f013 fcad 	bl	c05da04 <spm_memcpy>
               msg->outvec[outvec_idx].len, buffer, num_bytes);

    /* Update the write number */
    msg->outvec[outvec_idx].len += num_bytes;
 c04a0aa:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
 c04a0ac:	443b      	add	r3, r7
 c04a0ae:	666b      	str	r3, [r5, #100]	@ 0x64
}
 c04a0b0:	b003      	add	sp, #12
 c04a0b2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

0c04a0b6 <tfm_spm_psa_reply>:

void tfm_spm_psa_reply(uint32_t *args)
{
 c04a0b6:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    int32_t ret = PSA_SUCCESS;
    struct tfm_conn_handle_t *conn_handle;

    TFM_CORE_ASSERT(args != NULL);
    msg_handle = (psa_handle_t)args[0];
    status = (psa_status_t)args[1];
 c04a0ba:	e9d0 8500 	ldrd	r8, r5, [r0]

    /* It is a fatal error if message handle is invalid */
    msg = tfm_spm_get_msg_from_handle(msg_handle);
 c04a0be:	4640      	mov	r0, r8
 c04a0c0:	f012 fbf0 	bl	c05c8a4 <tfm_spm_get_msg_from_handle>
    if (!msg) {
 c04a0c4:	4604      	mov	r4, r0
 c04a0c6:	b908      	cbnz	r0, c04a0cc <tfm_spm_psa_reply+0x16>
        tfm_core_panic();
 c04a0c8:	f014 fb0e 	bl	c05e6e8 <tfm_core_panic>
    /*
     * RoT Service information is needed in this function, stored it in message
     * body structure. Only two parameters are passed in this function: handle
     * and status, so it is useful and simply to do like this.
     */
    service = msg->service;
 c04a0cc:	6867      	ldr	r7, [r4, #4]
    if (!service) {
 c04a0ce:	b90f      	cbnz	r7, c04a0d4 <tfm_spm_psa_reply+0x1e>
        tfm_core_panic();
 c04a0d0:	f014 fb0a 	bl	c05e6e8 <tfm_core_panic>

    /*
     * Three type of message are passed in this function: CONNECTION, REQUEST,
     * DISCONNECTION. It needs to process differently for each type.
     */
    conn_handle = tfm_spm_to_handle_instance(msg_handle);
 c04a0d4:	4640      	mov	r0, r8
 c04a0d6:	f012 fa9f 	bl	c05c618 <tfm_spm_to_handle_instance>
    switch (msg->msg.type) {
 c04a0da:	6923      	ldr	r3, [r4, #16]
    conn_handle = tfm_spm_to_handle_instance(msg_handle);
 c04a0dc:	4606      	mov	r6, r0
    switch (msg->msg.type) {
 c04a0de:	1c99      	adds	r1, r3, #2
 c04a0e0:	d012      	beq.n	c04a108 <tfm_spm_psa_reply+0x52>
 c04a0e2:	1c5a      	adds	r2, r3, #1
 c04a0e4:	d115      	bne.n	c04a112 <tfm_spm_psa_reply+0x5c>
        /*
         * Reply to PSA_IPC_CONNECT message. Connect handle is returned if the
         * input status is PSA_SUCCESS. Others return values are based on the
         * input status.
         */
        if (status == PSA_SUCCESS) {
 c04a0e6:	b34d      	cbz	r5, c04a13c <tfm_spm_psa_reply+0x86>
            ret = msg_handle;
        } else if (status == PSA_ERROR_CONNECTION_REFUSED) {
 c04a0e8:	f115 0f82 	cmn.w	r5, #130	@ 0x82
 c04a0ec:	d105      	bne.n	c04a0fa <tfm_spm_psa_reply+0x44>
            /* Refuse the client connection, indicating a permanent error. */
            tfm_spm_free_conn_handle(service, conn_handle);
 c04a0ee:	4601      	mov	r1, r0
 c04a0f0:	4638      	mov	r0, r7
 c04a0f2:	f012 fac7 	bl	c05c684 <tfm_spm_free_conn_handle>
            conn_handle->status = TFM_HANDLE_STATUS_CONNECT_ERROR;
        } else {
            tfm_core_panic();
        }
    } else {
        conn_handle->status = TFM_HANDLE_STATUS_IDLE;
 c04a0f6:	2300      	movs	r3, #0
 c04a0f8:	e01e      	b.n	c04a138 <tfm_spm_psa_reply+0x82>
        } else if (status == PSA_ERROR_CONNECTION_BUSY) {
 c04a0fa:	f115 0f83 	cmn.w	r5, #131	@ 0x83
 c04a0fe:	d0fa      	beq.n	c04a0f6 <tfm_spm_psa_reply+0x40>
            tfm_core_panic();
 c04a100:	f014 faf2 	bl	c05e6e8 <tfm_core_panic>
    int32_t ret = PSA_SUCCESS;
 c04a104:	2500      	movs	r5, #0
 c04a106:	e7f6      	b.n	c04a0f6 <tfm_spm_psa_reply+0x40>
        tfm_spm_free_conn_handle(service, conn_handle);
 c04a108:	4601      	mov	r1, r0
 c04a10a:	4638      	mov	r0, r7
 c04a10c:	f012 faba 	bl	c05c684 <tfm_spm_free_conn_handle>
    if (ret == PSA_ERROR_PROGRAMMER_ERROR) {
 c04a110:	e7f8      	b.n	c04a104 <tfm_spm_psa_reply+0x4e>
        if (msg->msg.type >= PSA_IPC_CALL) {
 c04a112:	2b00      	cmp	r3, #0
 c04a114:	dbf4      	blt.n	c04a100 <tfm_spm_psa_reply+0x4a>
            update_caller_outvec_len(msg);
 c04a116:	4620      	mov	r0, r4
 c04a118:	f012 fedb 	bl	c05ced2 <update_caller_outvec_len>
            if (!service->service_db->connection_based) {
 c04a11c:	683b      	ldr	r3, [r7, #0]
 c04a11e:	7c5b      	ldrb	r3, [r3, #17]
 c04a120:	b91b      	cbnz	r3, c04a12a <tfm_spm_psa_reply+0x74>
                tfm_spm_free_conn_handle(service, conn_handle);
 c04a122:	4631      	mov	r1, r6
 c04a124:	4638      	mov	r0, r7
 c04a126:	f012 faad 	bl	c05c684 <tfm_spm_free_conn_handle>
    if (ret == PSA_ERROR_PROGRAMMER_ERROR) {
 c04a12a:	f115 0f81 	cmn.w	r5, #129	@ 0x81
 c04a12e:	d1e2      	bne.n	c04a0f6 <tfm_spm_psa_reply+0x40>
        if (TFM_CLIENT_ID_IS_NS(msg->msg.client_id)) {
 c04a130:	69a3      	ldr	r3, [r4, #24]
 c04a132:	2b00      	cmp	r3, #0
 c04a134:	da04      	bge.n	c04a140 <tfm_spm_psa_reply+0x8a>
            conn_handle->status = TFM_HANDLE_STATUS_CONNECT_ERROR;
 c04a136:	2302      	movs	r3, #2
        conn_handle->status = TFM_HANDLE_STATUS_IDLE;
 c04a138:	6073      	str	r3, [r6, #4]
 c04a13a:	e003      	b.n	c04a144 <tfm_spm_psa_reply+0x8e>
            ret = msg_handle;
 c04a13c:	4645      	mov	r5, r8
 c04a13e:	e7f4      	b.n	c04a12a <tfm_spm_psa_reply+0x74>
            tfm_core_panic();
 c04a140:	f014 fad2 	bl	c05e6e8 <tfm_core_panic>
    }

    if (is_tfm_rpc_msg(msg)) {
        tfm_rpc_client_call_reply(msg, ret);
    } else {
        tfm_event_wake(&msg->ack_evnt, ret);
 c04a144:	4629      	mov	r1, r5
 c04a146:	f104 0008 	add.w	r0, r4, #8
    }
}
 c04a14a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
        tfm_event_wake(&msg->ack_evnt, ret);
 c04a14e:	f014 ba87 	b.w	c05e660 <tfm_event_wake>

0c04a152 <tfm_spm_psa_notify>:
    int32_t partition_id;

    TFM_CORE_ASSERT(args != NULL);
    partition_id = (int32_t)args[0];

    notify_with_signal(partition_id, PSA_DOORBELL);
 c04a152:	2108      	movs	r1, #8
 c04a154:	6800      	ldr	r0, [r0, #0]
 c04a156:	f012 bed0 	b.w	c05cefa <notify_with_signal>

0c04a15a <tfm_spm_psa_clear>:
}

void tfm_spm_psa_clear(void)
{
 c04a15a:	b510      	push	{r4, lr}
    struct partition_t *partition = NULL;

    partition = tfm_spm_get_running_partition();
 c04a15c:	f012 fada 	bl	c05c714 <tfm_spm_get_running_partition>
    if (!partition) {
 c04a160:	4604      	mov	r4, r0
 c04a162:	b908      	cbnz	r0, c04a168 <tfm_spm_psa_clear+0xe>
        tfm_core_panic();
 c04a164:	f014 fac0 	bl	c05e6e8 <tfm_core_panic>

    /*
     * It is a fatal error if the Secure Partition's doorbell signal is not
     * currently asserted.
     */
    if ((partition->signals_asserted & PSA_DOORBELL) == 0) {
 c04a168:	6f63      	ldr	r3, [r4, #116]	@ 0x74
 c04a16a:	071b      	lsls	r3, r3, #28
 c04a16c:	d401      	bmi.n	c04a172 <tfm_spm_psa_clear+0x18>
        tfm_core_panic();
 c04a16e:	f014 fabb 	bl	c05e6e8 <tfm_core_panic>
    }
    partition->signals_asserted &= ~PSA_DOORBELL;
 c04a172:	6f63      	ldr	r3, [r4, #116]	@ 0x74
 c04a174:	f023 0308 	bic.w	r3, r3, #8
 c04a178:	6763      	str	r3, [r4, #116]	@ 0x74
}
 c04a17a:	bd10      	pop	{r4, pc}

0c04a17c <tfm_spm_psa_eoi>:

void tfm_spm_psa_eoi(uint32_t *args)
{
 c04a17c:	b570      	push	{r4, r5, r6, lr}
    psa_signal_t irq_signal;
    int32_t irq_line = 0;
    struct partition_t *partition = NULL;

    TFM_CORE_ASSERT(args != NULL);
    irq_signal = (psa_signal_t)args[0];
 c04a17e:	6806      	ldr	r6, [r0, #0]

    partition = tfm_spm_get_running_partition();
 c04a180:	f012 fac8 	bl	c05c714 <tfm_spm_get_running_partition>
    if (!partition) {
 c04a184:	4605      	mov	r5, r0
 c04a186:	b908      	cbnz	r0, c04a18c <tfm_spm_psa_eoi+0x10>
        tfm_core_panic();
 c04a188:	f014 faae 	bl	c05e6e8 <tfm_core_panic>
    }

    irq_line = get_irq_line_for_signal(partition->p_static->pid, irq_signal);
 c04a18c:	682b      	ldr	r3, [r5, #0]
 c04a18e:	4631      	mov	r1, r6
 c04a190:	6858      	ldr	r0, [r3, #4]
 c04a192:	f012 fee3 	bl	c05cf5c <get_irq_line_for_signal>
    /* It is a fatal error if passed signal is not an interrupt signal. */
    if (irq_line < 0) {
 c04a196:	1e04      	subs	r4, r0, #0
 c04a198:	da01      	bge.n	c04a19e <tfm_spm_psa_eoi+0x22>
        tfm_core_panic();
 c04a19a:	f014 faa5 	bl	c05e6e8 <tfm_core_panic>
    }

    /* It is a fatal error if passed signal is not currently asserted */
    if ((partition->signals_asserted & irq_signal) == 0) {
 c04a19e:	6f6b      	ldr	r3, [r5, #116]	@ 0x74
 c04a1a0:	421e      	tst	r6, r3
 c04a1a2:	d101      	bne.n	c04a1a8 <tfm_spm_psa_eoi+0x2c>
        tfm_core_panic();
 c04a1a4:	f014 faa0 	bl	c05e6e8 <tfm_core_panic>
    }

    partition->signals_asserted &= ~irq_signal;
 c04a1a8:	6f6b      	ldr	r3, [r5, #116]	@ 0x74

    tfm_spm_hal_clear_pending_irq((IRQn_Type)irq_line);
 c04a1aa:	b264      	sxtb	r4, r4
    partition->signals_asserted &= ~irq_signal;
 c04a1ac:	ea23 0306 	bic.w	r3, r3, r6
    tfm_spm_hal_clear_pending_irq((IRQn_Type)irq_line);
 c04a1b0:	4620      	mov	r0, r4
    partition->signals_asserted &= ~irq_signal;
 c04a1b2:	676b      	str	r3, [r5, #116]	@ 0x74
    tfm_spm_hal_clear_pending_irq((IRQn_Type)irq_line);
 c04a1b4:	f006 fce2 	bl	c050b7c <tfm_spm_hal_clear_pending_irq>
    tfm_spm_hal_enable_irq((IRQn_Type)irq_line);
 c04a1b8:	4620      	mov	r0, r4
}
 c04a1ba:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    tfm_spm_hal_enable_irq((IRQn_Type)irq_line);
 c04a1be:	f006 bceb 	b.w	c050b98 <tfm_spm_hal_enable_irq>

0c04a1c2 <tfm_spm_psa_panic>:
{
    /*
     * PSA FF recommends that the SPM causes the system to restart when a secure
     * partition panics.
     */
    tfm_hal_system_reset();
 c04a1c2:	f008 bbd4 	b.w	c05296e <tfm_hal_system_reset>

0c04a1c6 <tfm_spm_irq_enable>:
}

void tfm_spm_irq_enable(uint32_t *args)
{
 c04a1c6:	b538      	push	{r3, r4, r5, lr}
    struct partition_t *partition;
    psa_signal_t irq_signal;
    int32_t irq_line;

    irq_signal = (psa_signal_t)args[0];
 c04a1c8:	6805      	ldr	r5, [r0, #0]

    partition = tfm_spm_get_running_partition();
 c04a1ca:	f012 faa3 	bl	c05c714 <tfm_spm_get_running_partition>
    if (!partition) {
 c04a1ce:	4604      	mov	r4, r0
 c04a1d0:	b908      	cbnz	r0, c04a1d6 <tfm_spm_irq_enable+0x10>
        tfm_core_panic();
 c04a1d2:	f014 fa89 	bl	c05e6e8 <tfm_core_panic>
    }

    irq_line = get_irq_line_for_signal(partition->p_static->pid, irq_signal);
 c04a1d6:	6823      	ldr	r3, [r4, #0]
 c04a1d8:	4629      	mov	r1, r5
 c04a1da:	6858      	ldr	r0, [r3, #4]
 c04a1dc:	f012 febe 	bl	c05cf5c <get_irq_line_for_signal>
    if (irq_line < 0) {
 c04a1e0:	1e04      	subs	r4, r0, #0
 c04a1e2:	da01      	bge.n	c04a1e8 <tfm_spm_irq_enable+0x22>
        tfm_core_panic();
 c04a1e4:	f014 fa80 	bl	c05e6e8 <tfm_core_panic>
    }

    tfm_spm_hal_enable_irq((IRQn_Type)irq_line);
 c04a1e8:	b260      	sxtb	r0, r4
}
 c04a1ea:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    tfm_spm_hal_enable_irq((IRQn_Type)irq_line);
 c04a1ee:	f006 bcd3 	b.w	c050b98 <tfm_spm_hal_enable_irq>

0c04a1f2 <tfm_spm_irq_disable>:

psa_irq_status_t tfm_spm_irq_disable(uint32_t *args)
{
 c04a1f2:	b538      	push	{r3, r4, r5, lr}
    struct partition_t *partition;
    psa_signal_t irq_signal;
    int32_t irq_line;

    irq_signal = (psa_signal_t)args[0];
 c04a1f4:	6805      	ldr	r5, [r0, #0]

    partition = tfm_spm_get_running_partition();
 c04a1f6:	f012 fa8d 	bl	c05c714 <tfm_spm_get_running_partition>
    if (!partition) {
 c04a1fa:	4604      	mov	r4, r0
 c04a1fc:	b908      	cbnz	r0, c04a202 <tfm_spm_irq_disable+0x10>
        tfm_core_panic();
 c04a1fe:	f014 fa73 	bl	c05e6e8 <tfm_core_panic>
    }

    irq_line = get_irq_line_for_signal(partition->p_static->pid, irq_signal);
 c04a202:	6823      	ldr	r3, [r4, #0]
 c04a204:	4629      	mov	r1, r5
 c04a206:	6858      	ldr	r0, [r3, #4]
 c04a208:	f012 fea8 	bl	c05cf5c <get_irq_line_for_signal>
    if (irq_line < 0) {
 c04a20c:	1e04      	subs	r4, r0, #0
 c04a20e:	da01      	bge.n	c04a214 <tfm_spm_irq_disable+0x22>
        tfm_core_panic();
 c04a210:	f014 fa6a 	bl	c05e6e8 <tfm_core_panic>
    }

    tfm_spm_hal_disable_irq((IRQn_Type)irq_line);
 c04a214:	b260      	sxtb	r0, r4
 c04a216:	f006 fccd 	bl	c050bb4 <tfm_spm_hal_disable_irq>

    return 1;
}
 c04a21a:	2001      	movs	r0, #1
 c04a21c:	bd38      	pop	{r3, r4, r5, pc}

0c04a21e <psa_key_attributes_init>:
{
 c04a21e:	b510      	push	{r4, lr}
 c04a220:	4604      	mov	r4, r0
    return( v );
 c04a222:	2230      	movs	r2, #48	@ 0x30
 c04a224:	2100      	movs	r1, #0
 c04a226:	f011 fa82 	bl	c05b72e <memset>
}
 c04a22a:	4620      	mov	r0, r4
 c04a22c:	bd10      	pop	{r4, pc}

0c04a22e <psa_set_key_usage_flags>:
    if( *usage_flags & PSA_KEY_USAGE_SIGN_HASH )
 c04a22e:	04ca      	lsls	r2, r1, #19
        *usage_flags |= PSA_KEY_USAGE_SIGN_MESSAGE;
 c04a230:	bf48      	it	mi
 c04a232:	f441 6180 	orrmi.w	r1, r1, #1024	@ 0x400
    if( *usage_flags & PSA_KEY_USAGE_VERIFY_HASH )
 c04a236:	048b      	lsls	r3, r1, #18
        *usage_flags |= PSA_KEY_USAGE_VERIFY_MESSAGE;
 c04a238:	bf48      	it	mi
 c04a23a:	f441 6100 	orrmi.w	r1, r1, #2048	@ 0x800
    attributes->core.policy.usage = usage_flags;
 c04a23e:	6101      	str	r1, [r0, #16]
}
 c04a240:	4770      	bx	lr

0c04a242 <psa_se_st_destroy_key>:
  psa_drv_se_context_t *drv_context,
  void *persistent_data,
  psa_key_slot_number_t key_slot)
{
  return PSA_SUCCESS;
}
 c04a242:	2000      	movs	r0, #0
 c04a244:	4770      	bx	lr

0c04a246 <psa_se_st_verify_fct>:
                                         size_t hash_length,
                                         const uint8_t *p_signature,
                                         size_t signature_length)
{
  return PSA_SUCCESS;
}
 c04a246:	2000      	movs	r0, #0
 c04a248:	4770      	bx	lr

0c04a24a <psa_se_st_export_public_fct>:
{
 c04a24a:	b5f0      	push	{r4, r5, r6, r7, lr}
 c04a24c:	4614      	mov	r4, r2
  size_t key_size = 0;
 c04a24e:	2200      	movs	r2, #0
 c04a250:	2c03      	cmp	r4, #3
{
 c04a252:	b085      	sub	sp, #20
 c04a254:	f173 0300 	sbcs.w	r3, r3, #0
 c04a258:	9f0a      	ldr	r7, [sp, #40]	@ 0x28
 c04a25a:	9e0c      	ldr	r6, [sp, #48]	@ 0x30
  size_t key_size = 0;
 c04a25c:	9203      	str	r2, [sp, #12]
  switch (key)
 c04a25e:	d229      	bcs.n	c04a2b4 <psa_se_st_export_public_fct+0x6a>
 c04a260:	b2e4      	uxtb	r4, r4
  ret = SE_Get_PubKey(slot, NULL, NULL, &key_size, &type);
 c04a262:	f10d 050b 	add.w	r5, sp, #11
 c04a266:	4611      	mov	r1, r2
 c04a268:	4620      	mov	r0, r4
 c04a26a:	9500      	str	r5, [sp, #0]
 c04a26c:	ab03      	add	r3, sp, #12
 c04a26e:	f00f fda3 	bl	c059db8 <SE_Get_PubKey>
  if ((ret != SE_OK) && (ret != SE_BUFFER_TOO_SHORT_ERROR))
 c04a272:	b128      	cbz	r0, c04a280 <psa_se_st_export_public_fct+0x36>
 c04a274:	2805      	cmp	r0, #5
 c04a276:	d003      	beq.n	c04a280 <psa_se_st_export_public_fct+0x36>
    return PSA_ERROR_HARDWARE_FAILURE;
 c04a278:	f06f 0092 	mvn.w	r0, #146	@ 0x92
}
 c04a27c:	b005      	add	sp, #20
 c04a27e:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if (data_size < (1 + key_size * 2))
 c04a280:	9a03      	ldr	r2, [sp, #12]
 c04a282:	990b      	ldr	r1, [sp, #44]	@ 0x2c
 c04a284:	0053      	lsls	r3, r2, #1
 c04a286:	3301      	adds	r3, #1
 c04a288:	428b      	cmp	r3, r1
 c04a28a:	d816      	bhi.n	c04a2ba <psa_se_st_export_public_fct+0x70>
  p_data[0] = 0x4;
 c04a28c:	2304      	movs	r3, #4
  ret = SE_Get_PubKey(slot, &p_data[1], &p_data[1 + key_size], &key_size, &type);
 c04a28e:	3201      	adds	r2, #1
  p_data[0] = 0x4;
 c04a290:	703b      	strb	r3, [r7, #0]
  ret = SE_Get_PubKey(slot, &p_data[1], &p_data[1 + key_size], &key_size, &type);
 c04a292:	4620      	mov	r0, r4
 c04a294:	9500      	str	r5, [sp, #0]
 c04a296:	ab03      	add	r3, sp, #12
 c04a298:	443a      	add	r2, r7
 c04a29a:	1c79      	adds	r1, r7, #1
 c04a29c:	f00f fd8c 	bl	c059db8 <SE_Get_PubKey>
  if (ret != SE_OK)
 c04a2a0:	2800      	cmp	r0, #0
 c04a2a2:	d1e9      	bne.n	c04a278 <psa_se_st_export_public_fct+0x2e>
  if (p_data_length != NULL)
 c04a2a4:	b90e      	cbnz	r6, c04a2aa <psa_se_st_export_public_fct+0x60>
  return PSA_SUCCESS;
 c04a2a6:	2000      	movs	r0, #0
 c04a2a8:	e7e8      	b.n	c04a27c <psa_se_st_export_public_fct+0x32>
    *p_data_length = 1 + key_size * 2;
 c04a2aa:	9b03      	ldr	r3, [sp, #12]
 c04a2ac:	005b      	lsls	r3, r3, #1
 c04a2ae:	3301      	adds	r3, #1
 c04a2b0:	6033      	str	r3, [r6, #0]
 c04a2b2:	e7f8      	b.n	c04a2a6 <psa_se_st_export_public_fct+0x5c>
      return PSA_ERROR_DOES_NOT_EXIST;
 c04a2b4:	f06f 008b 	mvn.w	r0, #139	@ 0x8b
 c04a2b8:	e7e0      	b.n	c04a27c <psa_se_st_export_public_fct+0x32>
    return PSA_ERROR_BUFFER_TOO_SMALL;
 c04a2ba:	f06f 0089 	mvn.w	r0, #137	@ 0x89
 c04a2be:	e7dd      	b.n	c04a27c <psa_se_st_export_public_fct+0x32>

0c04a2c0 <psa_set_key_type>:
{
 c04a2c0:	b410      	push	{r4}
    if( attributes->domain_parameters == NULL )
 c04a2c2:	6a84      	ldr	r4, [r0, #40]	@ 0x28
 c04a2c4:	b914      	cbnz	r4, c04a2cc <psa_set_key_type+0xc>
}
 c04a2c6:	bc10      	pop	{r4}
        attributes->core.type = type;
 c04a2c8:	8001      	strh	r1, [r0, #0]
}
 c04a2ca:	4770      	bx	lr
        (void) psa_set_key_domain_parameters( attributes, type, NULL, 0 );
 c04a2cc:	2300      	movs	r3, #0
}
 c04a2ce:	bc10      	pop	{r4}
        (void) psa_set_key_domain_parameters( attributes, type, NULL, 0 );
 c04a2d0:	461a      	mov	r2, r3
 c04a2d2:	f7fd ba2c 	b.w	c04772e <mbedcrypto__psa_set_key_domain_parameters>
	...

0c04a2d8 <register_key_in_all_domain>:
                                               psa_key_attributes_t *attr) {
 c04a2d8:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
 c04a2dc:	466e      	mov	r6, sp
 c04a2de:	e886 0003 	stmia.w	r6, {r0, r1}
  psa_status = psa_open_key(key, &key_handle);
 c04a2e2:	ad02      	add	r5, sp, #8
                                               psa_key_attributes_t *attr) {
 c04a2e4:	4614      	mov	r4, r2
 c04a2e6:	4607      	mov	r7, r0
 c04a2e8:	4688      	mov	r8, r1
  psa_status = psa_open_key(key, &key_handle);
 c04a2ea:	e896 0003 	ldmia.w	r6, {r0, r1}
 c04a2ee:	462a      	mov	r2, r5
 c04a2f0:	f7fe fefc 	bl	c0490ec <mbedcrypto__psa_open_key>
  if (psa_status != PSA_SUCCESS) {
 c04a2f4:	b180      	cbz	r0, c04a318 <register_key_in_all_domain+0x40>
    psa_key_lifetime_t lifetime = attributes->core.lifetime;
 c04a2f6:	6863      	ldr	r3, [r4, #4]
    attributes->core.id = key;
 c04a2f8:	e9c4 7802 	strd	r7, r8, [r4, #8]
    if( PSA_KEY_LIFETIME_IS_VOLATILE( lifetime ) )
 c04a2fc:	b2da      	uxtb	r2, r3
 c04a2fe:	b922      	cbnz	r2, c04a30a <register_key_in_all_domain+0x32>
            PSA_KEY_LIFETIME_FROM_PERSISTENCE_AND_LOCATION(
 c04a300:	f023 03ff 	bic.w	r3, r3, #255	@ 0xff
 c04a304:	f043 0301 	orr.w	r3, r3, #1
        attributes->core.lifetime =
 c04a308:	6063      	str	r3, [r4, #4]
    psa_status = mbedtls_psa_register_se_key(attr);
 c04a30a:	4620      	mov	r0, r4
 c04a30c:	f7fb f93f 	bl	c04558e <mbedtls_psa_register_se_key>
    if (psa_status != PSA_SUCCESS) {
 c04a310:	b130      	cbz	r0, c04a320 <register_key_in_all_domain+0x48>
}
 c04a312:	b004      	add	sp, #16
 c04a314:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    psa_close_key(key_handle);
 c04a318:	e895 0003 	ldmia.w	r5, {r0, r1}
 c04a31c:	f7fe ff07 	bl	c04912e <mbedcrypto__psa_close_key>
  if ((key.key_id == SE_ST_ID_TO_PSA_ID(SE_ST_PRIV_SLOT_0))
 c04a320:	f1b7 4f80 	cmp.w	r7, #1073741824	@ 0x40000000
 c04a324:	d002      	beq.n	c04a32c <register_key_in_all_domain+0x54>
       || (key.key_id == SE_ST_ID_TO_PSA_ID(SE_ST_SERIAL_NUMBER))) {
 c04a326:	4b10      	ldr	r3, [pc, #64]	@ (c04a368 <register_key_in_all_domain+0x90>)
 c04a328:	429f      	cmp	r7, r3
 c04a32a:	d11b      	bne.n	c04a364 <register_key_in_all_domain+0x8c>
    psa_status = psa_open_key(key, &key_handle);
 c04a32c:	f240 1805 	movw	r8, #261	@ 0x105
 c04a330:	f8cd 8004 	str.w	r8, [sp, #4]
 c04a334:	462a      	mov	r2, r5
 c04a336:	e896 0003 	ldmia.w	r6, {r0, r1}
 c04a33a:	f7fe fed7 	bl	c0490ec <mbedcrypto__psa_open_key>
    if (psa_status != PSA_SUCCESS) {
 c04a33e:	b168      	cbz	r0, c04a35c <register_key_in_all_domain+0x84>
    psa_key_lifetime_t lifetime = attributes->core.lifetime;
 c04a340:	6863      	ldr	r3, [r4, #4]
    attributes->core.id = key;
 c04a342:	e9c4 7802 	strd	r7, r8, [r4, #8]
    if( PSA_KEY_LIFETIME_IS_VOLATILE( lifetime ) )
 c04a346:	b2da      	uxtb	r2, r3
 c04a348:	b922      	cbnz	r2, c04a354 <register_key_in_all_domain+0x7c>
            PSA_KEY_LIFETIME_FROM_PERSISTENCE_AND_LOCATION(
 c04a34a:	f023 03ff 	bic.w	r3, r3, #255	@ 0xff
 c04a34e:	f043 0301 	orr.w	r3, r3, #1
        attributes->core.lifetime =
 c04a352:	6063      	str	r3, [r4, #4]
      psa_status = mbedtls_psa_register_se_key(attr);
 c04a354:	4620      	mov	r0, r4
 c04a356:	f7fb f91a 	bl	c04558e <mbedtls_psa_register_se_key>
 c04a35a:	e7da      	b.n	c04a312 <register_key_in_all_domain+0x3a>
      psa_close_key(key_handle);
 c04a35c:	e895 0003 	ldmia.w	r5, {r0, r1}
 c04a360:	f7fe fee5 	bl	c04912e <mbedcrypto__psa_close_key>
                                               psa_key_attributes_t *attr) {
 c04a364:	2000      	movs	r0, #0
  return psa_status;
 c04a366:	e7d4      	b.n	c04a312 <register_key_in_all_domain+0x3a>
 c04a368:	40000003 	.word	0x40000003

0c04a36c <register_function_key>:
{
 c04a36c:	b537      	push	{r0, r1, r2, r4, r5, lr}
 c04a36e:	460c      	mov	r4, r1
 c04a370:	4605      	mov	r5, r0
    mbedtls_svc_key_id_t mbedtls_id = {0,tfm_nspm_get_current_client_id()};
 c04a372:	f014 f837 	bl	c05e3e4 <tfm_nspm_get_current_client_id>
        attributes->core.bits = (psa_key_bits_t) bits;
 c04a376:	2308      	movs	r3, #8
 c04a378:	8063      	strh	r3, [r4, #2]
    attributes->core.lifetime = lifetime;
 c04a37a:	f240 13ff 	movw	r3, #511	@ 0x1ff
 c04a37e:	9001      	str	r0, [sp, #4]
 c04a380:	6063      	str	r3, [r4, #4]
    psa_set_key_usage_flags(attr, PSA_KEY_USAGE_EXPORT);
 c04a382:	4620      	mov	r0, r4
 c04a384:	2101      	movs	r1, #1
 c04a386:	f7ff ff52 	bl	c04a22e <psa_set_key_usage_flags>
    psa_set_key_type(attr, PSA_KEY_TYPE_RAW_DATA);
 c04a38a:	f241 0101 	movw	r1, #4097	@ 0x1001
 c04a38e:	f7ff ff97 	bl	c04a2c0 <psa_set_key_type>
 c04a392:	8ba3      	ldrh	r3, [r4, #28]
    return register_key_in_all_domain(mbedtls_id, attr);
 c04a394:	4622      	mov	r2, r4
 c04a396:	f043 0301 	orr.w	r3, r3, #1
 c04a39a:	83a3      	strh	r3, [r4, #28]
    psa_set_key_slot_number(attr, PSA_ID_TO_SE_ST_ID(key_id));
 c04a39c:	2300      	movs	r3, #0
    mbedtls_id.key_id = key_id,
 c04a39e:	9500      	str	r5, [sp, #0]
    psa_set_key_slot_number(attr, PSA_ID_TO_SE_ST_ID(key_id));
 c04a3a0:	6263      	str	r3, [r4, #36]	@ 0x24
 c04a3a2:	f105 4540 	add.w	r5, r5, #3221225472	@ 0xc0000000
    return register_key_in_all_domain(mbedtls_id, attr);
 c04a3a6:	ab02      	add	r3, sp, #8
    psa_set_key_slot_number(attr, PSA_ID_TO_SE_ST_ID(key_id));
 c04a3a8:	6225      	str	r5, [r4, #32]
    return register_key_in_all_domain(mbedtls_id, attr);
 c04a3aa:	e913 0003 	ldmdb	r3, {r0, r1}
}
 c04a3ae:	b003      	add	sp, #12
 c04a3b0:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    return register_key_in_all_domain(mbedtls_id, attr);
 c04a3b4:	f7ff bf90 	b.w	c04a2d8 <register_key_in_all_domain>

0c04a3b8 <debug_print>:
{
 c04a3b8:	b40f      	push	{r0, r1, r2, r3}
 c04a3ba:	b500      	push	{lr}
 c04a3bc:	b0ff      	sub	sp, #508	@ 0x1fc
 c04a3be:	ab80      	add	r3, sp, #512	@ 0x200
 c04a3c0:	f853 2b04 	ldr.w	r2, [r3], #4
  len = vsnprintf(trace_buf, sizeof(trace_buf), fmt, args);
 c04a3c4:	f44f 71fa 	mov.w	r1, #500	@ 0x1f4
 c04a3c8:	a801      	add	r0, sp, #4
  va_start(args, fmt);
 c04a3ca:	9300      	str	r3, [sp, #0]
  len = vsnprintf(trace_buf, sizeof(trace_buf), fmt, args);
 c04a3cc:	f7f8 f8ca 	bl	c042564 <vsniprintf>
 c04a3d0:	4601      	mov	r1, r0
  return tfm_hal_output_spm_log(trace_buf, len);
 c04a3d2:	a801      	add	r0, sp, #4
 c04a3d4:	f013 fdea 	bl	c05dfac <tfm_hal_output_spm_log>
}
 c04a3d8:	b07f      	add	sp, #508	@ 0x1fc
 c04a3da:	f85d eb04 	ldr.w	lr, [sp], #4
 c04a3de:	b004      	add	sp, #16
 c04a3e0:	4770      	bx	lr
	...

0c04a3e4 <psa_se_st_allocate_key>:
{
 c04a3e4:	b538      	push	{r3, r4, r5, lr}
  if ((method != PSA_KEY_CREATION_IMPORT) &&
 c04a3e6:	2b01      	cmp	r3, #1
{
 c04a3e8:	460d      	mov	r5, r1
 c04a3ea:	9c04      	ldr	r4, [sp, #16]
 c04a3ec:	4619      	mov	r1, r3
    return( attributes->core.type );
 c04a3ee:	8810      	ldrh	r0, [r2, #0]
  if ((method != PSA_KEY_CREATION_IMPORT) &&
 c04a3f0:	d905      	bls.n	c04a3fe <psa_se_st_allocate_key+0x1a>
    SE_ST_PSA_PRINT("Key allocation cannot operate with method : %x\n", method);
 c04a3f2:	481c      	ldr	r0, [pc, #112]	@ (c04a464 <psa_se_st_allocate_key+0x80>)
 c04a3f4:	f7ff ffe0 	bl	c04a3b8 <debug_print>
    return PSA_ERROR_NOT_SUPPORTED;
 c04a3f8:	f06f 0085 	mvn.w	r0, #133	@ 0x85
 c04a3fc:	e002      	b.n	c04a404 <psa_se_st_allocate_key+0x20>
  if (key_slot == NULL)
 c04a3fe:	b914      	cbnz	r4, c04a406 <psa_se_st_allocate_key+0x22>
    return PSA_ERROR_INVALID_ARGUMENT;
 c04a400:	f06f 0086 	mvn.w	r0, #134	@ 0x86
}
 c04a404:	bd38      	pop	{r3, r4, r5, pc}
  if (type == PSA_KEY_TYPE_RAW_DATA)
 c04a406:	f241 0301 	movw	r3, #4097	@ 0x1001
 c04a40a:	4298      	cmp	r0, r3
 c04a40c:	d10f      	bne.n	c04a42e <psa_se_st_allocate_key+0x4a>
    return( attributes->core.id );
 c04a40e:	6891      	ldr	r1, [r2, #8]
    uint32_t region = PSA_ID_TO_SE_ST_ID(id.key_id);
 c04a410:	f101 4140 	add.w	r1, r1, #3221225472	@ 0xc0000000
    if (region >= SE_ST_START_REGION)
 c04a414:	2905      	cmp	r1, #5
 c04a416:	d908      	bls.n	c04a42a <psa_se_st_allocate_key+0x46>
      if ((region - SE_ST_START_REGION) > p_data->map_size)
 c04a418:	f8d5 20c4 	ldr.w	r2, [r5, #196]	@ 0xc4
 c04a41c:	1f8b      	subs	r3, r1, #6
 c04a41e:	4293      	cmp	r3, r2
 c04a420:	d917      	bls.n	c04a452 <psa_se_st_allocate_key+0x6e>
        SE_ST_PSA_PRINT("Region %d out of range\n", region);
 c04a422:	4811      	ldr	r0, [pc, #68]	@ (c04a468 <psa_se_st_allocate_key+0x84>)
    SE_ST_PSA_PRINT("Region %d under the range\n", region);
 c04a424:	f7ff ffc8 	bl	c04a3b8 <debug_print>
    return PSA_ERROR_INVALID_ARGUMENT;
 c04a428:	e7ea      	b.n	c04a400 <psa_se_st_allocate_key+0x1c>
    SE_ST_PSA_PRINT("Region %d under the range\n", region);
 c04a42a:	4810      	ldr	r0, [pc, #64]	@ (c04a46c <psa_se_st_allocate_key+0x88>)
 c04a42c:	e7fa      	b.n	c04a424 <psa_se_st_allocate_key+0x40>
  if ((PSA_KEY_TYPE_ECC_GET_FAMILY(type) == PSA_ECC_FAMILY_SECP_R1)
 c04a42e:	f400 434f 	and.w	r3, r0, #52992	@ 0xcf00
 c04a432:	f5b3 4f82 	cmp.w	r3, #16640	@ 0x4100
 c04a436:	d1df      	bne.n	c04a3f8 <psa_se_st_allocate_key+0x14>
 c04a438:	b2c0      	uxtb	r0, r0
      || (PSA_KEY_TYPE_ECC_GET_FAMILY(type) == PSA_ECC_FAMILY_BRAINPOOL_P_R1))
 c04a43a:	2812      	cmp	r0, #18
 c04a43c:	d001      	beq.n	c04a442 <psa_se_st_allocate_key+0x5e>
 c04a43e:	2830      	cmp	r0, #48	@ 0x30
 c04a440:	d1da      	bne.n	c04a3f8 <psa_se_st_allocate_key+0x14>
 c04a442:	6891      	ldr	r1, [r2, #8]
    if ((key_id == SE_ST_PRIV_SLOT_1) || (key_id == SE_ST_PRIV_SLOT_FF))
 c04a444:	f101 4340 	add.w	r3, r1, #3221225472	@ 0xc0000000
 c04a448:	3b01      	subs	r3, #1
 c04a44a:	2b01      	cmp	r3, #1
 c04a44c:	d806      	bhi.n	c04a45c <psa_se_st_allocate_key+0x78>
    uint32_t key_id = PSA_ID_TO_SE_ST_ID(id.key_id);
 c04a44e:	f101 4140 	add.w	r1, r1, #3221225472	@ 0xc0000000
      *key_slot = region;
 c04a452:	2300      	movs	r3, #0
      return PSA_SUCCESS;
 c04a454:	2000      	movs	r0, #0
      *key_slot = region;
 c04a456:	e9c4 1300 	strd	r1, r3, [r4]
 c04a45a:	e7d3      	b.n	c04a404 <psa_se_st_allocate_key+0x20>
    return PSA_ERROR_INSUFFICIENT_STORAGE;
 c04a45c:	f06f 008d 	mvn.w	r0, #141	@ 0x8d
 c04a460:	e7d0      	b.n	c04a404 <psa_se_st_allocate_key+0x20>
 c04a462:	bf00      	nop
 c04a464:	0c06161c 	.word	0x0c06161c
 c04a468:	0c06164c 	.word	0x0c06164c
 c04a46c:	0c061664 	.word	0x0c061664

0c04a470 <psa_se_st_validate_slot_number_fct>:
{
 c04a470:	b538      	push	{r3, r4, r5, lr}
  if ((method != PSA_KEY_CREATION_REGISTER) &&
 c04a472:	2b04      	cmp	r3, #4
{
 c04a474:	4608      	mov	r0, r1
 c04a476:	e9dd 5404 	ldrd	r5, r4, [sp, #16]
 c04a47a:	4619      	mov	r1, r3
    return( attributes->core.type );
 c04a47c:	8812      	ldrh	r2, [r2, #0]
  if ((method != PSA_KEY_CREATION_REGISTER) &&
 c04a47e:	d00f      	beq.n	c04a4a0 <psa_se_st_validate_slot_number_fct+0x30>
 c04a480:	b13b      	cbz	r3, c04a492 <psa_se_st_validate_slot_number_fct+0x22>
      (method != PSA_KEY_CREATION_IMPORT)   &&
 c04a482:	2b01      	cmp	r3, #1
 c04a484:	d00c      	beq.n	c04a4a0 <psa_se_st_validate_slot_number_fct+0x30>
    SE_ST_PSA_PRINT("Key slot validation cannot operate with method : %x\n", method);
 c04a486:	481c      	ldr	r0, [pc, #112]	@ (c04a4f8 <psa_se_st_validate_slot_number_fct+0x88>)
      SE_ST_PSA_PRINT("This type cannot be imported  : %d\n", type);
 c04a488:	f7ff ff96 	bl	c04a3b8 <debug_print>
    return PSA_ERROR_NOT_SUPPORTED;
 c04a48c:	f06f 0085 	mvn.w	r0, #133	@ 0x85
 c04a490:	e02c      	b.n	c04a4ec <psa_se_st_validate_slot_number_fct+0x7c>
    if (type != PSA_KEY_TYPE_RAW_DATA)
 c04a492:	f241 0301 	movw	r3, #4097	@ 0x1001
 c04a496:	429a      	cmp	r2, r3
 c04a498:	d01a      	beq.n	c04a4d0 <psa_se_st_validate_slot_number_fct+0x60>
      SE_ST_PSA_PRINT("This type cannot be imported  : %d\n", type);
 c04a49a:	4611      	mov	r1, r2
 c04a49c:	4817      	ldr	r0, [pc, #92]	@ (c04a4fc <psa_se_st_validate_slot_number_fct+0x8c>)
 c04a49e:	e7f3      	b.n	c04a488 <psa_se_st_validate_slot_number_fct+0x18>
  if ((PSA_KEY_TYPE_ECC_GET_FAMILY(type) != PSA_ECC_FAMILY_SECP_R1) &&
 c04a4a0:	f402 434f 	and.w	r3, r2, #52992	@ 0xcf00
 c04a4a4:	f5b3 4f82 	cmp.w	r3, #16640	@ 0x4100
 c04a4a8:	d10a      	bne.n	c04a4c0 <psa_se_st_validate_slot_number_fct+0x50>
 c04a4aa:	b2d2      	uxtb	r2, r2
 c04a4ac:	2a12      	cmp	r2, #18
 c04a4ae:	d001      	beq.n	c04a4b4 <psa_se_st_validate_slot_number_fct+0x44>
 c04a4b0:	2a30      	cmp	r2, #48	@ 0x30
 c04a4b2:	d109      	bne.n	c04a4c8 <psa_se_st_validate_slot_number_fct+0x58>
    if ( (key_slot != SE_ST_PRIV_SLOT_0) &&
 c04a4b4:	2d03      	cmp	r5, #3
 c04a4b6:	f174 0400 	sbcs.w	r4, r4, #0
 c04a4ba:	d215      	bcs.n	c04a4e8 <psa_se_st_validate_slot_number_fct+0x78>
  return PSA_SUCCESS;
 c04a4bc:	2000      	movs	r0, #0
 c04a4be:	e015      	b.n	c04a4ec <psa_se_st_validate_slot_number_fct+0x7c>
      (PSA_KEY_TYPE_ECC_GET_FAMILY(type) != PSA_ECC_FAMILY_BRAINPOOL_P_R1) &&
 c04a4c0:	f241 0301 	movw	r3, #4097	@ 0x1001
 c04a4c4:	429a      	cmp	r2, r3
 c04a4c6:	d003      	beq.n	c04a4d0 <psa_se_st_validate_slot_number_fct+0x60>
    SE_ST_PSA_PRINT("Invalid key attributes\n");
 c04a4c8:	480d      	ldr	r0, [pc, #52]	@ (c04a500 <psa_se_st_validate_slot_number_fct+0x90>)
 c04a4ca:	f7ff ff75 	bl	c04a3b8 <debug_print>
    return PSA_ERROR_NOT_SUPPORTED;
 c04a4ce:	e7dd      	b.n	c04a48c <psa_se_st_validate_slot_number_fct+0x1c>
    if ((key_slot < SE_ST_START_REGION) || (key_slot > (SE_ST_START_REGION + p_data->map_size)))
 c04a4d0:	2d06      	cmp	r5, #6
 c04a4d2:	f174 0300 	sbcs.w	r3, r4, #0
 c04a4d6:	d30a      	bcc.n	c04a4ee <psa_se_st_validate_slot_number_fct+0x7e>
 c04a4d8:	f8d0 30c4 	ldr.w	r3, [r0, #196]	@ 0xc4
 c04a4dc:	2000      	movs	r0, #0
 c04a4de:	3306      	adds	r3, #6
 c04a4e0:	42ab      	cmp	r3, r5
 c04a4e2:	eb70 0404 	sbcs.w	r4, r0, r4
 c04a4e6:	d201      	bcs.n	c04a4ec <psa_se_st_validate_slot_number_fct+0x7c>
        return PSA_ERROR_INVALID_ARGUMENT;
 c04a4e8:	f06f 0086 	mvn.w	r0, #134	@ 0x86
}
 c04a4ec:	bd38      	pop	{r3, r4, r5, pc}
          (key_slot != SE_ST_MAPPING)       &&
 c04a4ee:	3d03      	subs	r5, #3
 c04a4f0:	f144 34ff 	adc.w	r4, r4, #4294967295	@ 0xffffffff
 c04a4f4:	e7de      	b.n	c04a4b4 <psa_se_st_validate_slot_number_fct+0x44>
 c04a4f6:	bf00      	nop
 c04a4f8:	0c06167f 	.word	0x0c06167f
 c04a4fc:	0c0616b4 	.word	0x0c0616b4
 c04a500:	0c0616d8 	.word	0x0c0616d8

0c04a504 <psa_se_st_init>:
{
 c04a504:	b510      	push	{r4, lr}
 c04a506:	460c      	mov	r4, r1
  if (drv_context == NULL)
 c04a508:	b340      	cbz	r0, c04a55c <psa_se_st_init+0x58>
  if (location != PSA_SE_ST_LOCATION)
 c04a50a:	2a01      	cmp	r2, #1
 c04a50c:	d005      	beq.n	c04a51a <psa_se_st_init+0x16>
    SE_ST_PSA_PRINT("Invalid driver\n");
 c04a50e:	4815      	ldr	r0, [pc, #84]	@ (c04a564 <psa_se_st_init+0x60>)
 c04a510:	f7ff ff52 	bl	c04a3b8 <debug_print>
    return PSA_ERROR_GENERIC_ERROR;
 c04a514:	f06f 0083 	mvn.w	r0, #131	@ 0x83
 c04a518:	e00a      	b.n	c04a530 <psa_se_st_init+0x2c>
  ret = SE_Init(0, SE_SECURITY_LEVEL_NONE, 0x20);
 c04a51a:	2100      	movs	r1, #0
 c04a51c:	2220      	movs	r2, #32
 c04a51e:	4608      	mov	r0, r1
 c04a520:	f00f f9b6 	bl	c059890 <SE_Init>
  if (ret != SE_OK)
 c04a524:	b128      	cbz	r0, c04a532 <psa_se_st_init+0x2e>
    SE_ST_PSA_PRINT("Secure Element driver initialization failure\n");
 c04a526:	4810      	ldr	r0, [pc, #64]	@ (c04a568 <psa_se_st_init+0x64>)
 c04a528:	f7ff ff46 	bl	c04a3b8 <debug_print>
    return PSA_ERROR_HARDWARE_FAILURE;
 c04a52c:	f06f 0092 	mvn.w	r0, #146	@ 0x92
}
 c04a530:	bd10      	pop	{r4, pc}
  ret = SE_Init_PubKeys(p_data->pub_keys, 2);
 c04a532:	2102      	movs	r1, #2
 c04a534:	4620      	mov	r0, r4
 c04a536:	f00f fc2b 	bl	c059d90 <SE_Init_PubKeys>
  if (ret != SE_OK)
 c04a53a:	2800      	cmp	r0, #0
 c04a53c:	d1ea      	bne.n	c04a514 <psa_se_st_init+0x10>
  if (p_data->map_size == 0)
 c04a53e:	f8d4 30c4 	ldr.w	r3, [r4, #196]	@ 0xc4
 c04a542:	b123      	cbz	r3, c04a54e <psa_se_st_init+0x4a>
  SE_ST_PSA_PRINT("Secure Element driver initialized\n");
 c04a544:	4809      	ldr	r0, [pc, #36]	@ (c04a56c <psa_se_st_init+0x68>)
 c04a546:	f7ff ff37 	bl	c04a3b8 <debug_print>
  return PSA_SUCCESS;
 c04a54a:	2000      	movs	r0, #0
 c04a54c:	e7f0      	b.n	c04a530 <psa_se_st_init+0x2c>
    ret = SE_GetMapping(NULL, &(p_data->map_size));
 c04a54e:	f104 01c4 	add.w	r1, r4, #196	@ 0xc4
 c04a552:	f00f fc07 	bl	c059d64 <SE_GetMapping>
    if (ret != SE_OK)
 c04a556:	2800      	cmp	r0, #0
 c04a558:	d0f4      	beq.n	c04a544 <psa_se_st_init+0x40>
 c04a55a:	e7db      	b.n	c04a514 <psa_se_st_init+0x10>
    return PSA_ERROR_INVALID_ARGUMENT;
 c04a55c:	f06f 0086 	mvn.w	r0, #134	@ 0x86
 c04a560:	e7e6      	b.n	c04a530 <psa_se_st_init+0x2c>
 c04a562:	bf00      	nop
 c04a564:	0c0616f0 	.word	0x0c0616f0
 c04a568:	0c061700 	.word	0x0c061700
 c04a56c:	0c06172e 	.word	0x0c06172e

0c04a570 <se_st_to_psa_error>:
  switch (ret)
 c04a570:	2805      	cmp	r0, #5
 c04a572:	bf9a      	itte	ls
 c04a574:	4b02      	ldrls	r3, [pc, #8]	@ (c04a580 <se_st_to_psa_error+0x10>)
 c04a576:	f933 0010 	ldrshls.w	r0, [r3, r0, lsl #1]
{
 c04a57a:	f06f 0092 	mvnhi.w	r0, #146	@ 0x92
}
 c04a57e:	4770      	bx	lr
 c04a580:	0c06188a 	.word	0x0c06188a

0c04a584 <psa_se_st_import>:
{
 c04a584:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  if (type != PSA_KEY_TYPE_RAW_DATA)
 c04a586:	9e08      	ldr	r6, [sp, #32]
  SE_psa_drv_se_persistent_t *p_data = (SE_psa_drv_se_persistent_t *)(drv_context->persistent_data);
 c04a588:	6801      	ldr	r1, [r0, #0]
  if (type != PSA_KEY_TYPE_RAW_DATA)
 c04a58a:	f8b6 c000 	ldrh.w	ip, [r6]
 c04a58e:	f241 0601 	movw	r6, #4097	@ 0x1001
  const uint16_t region = key_slot - SE_ST_START_REGION;
 c04a592:	1f90      	subs	r0, r2, #6
  if (type != PSA_KEY_TYPE_RAW_DATA)
 c04a594:	45b4      	cmp	ip, r6
{
 c04a596:	461c      	mov	r4, r3
 c04a598:	e9dd 3509 	ldrd	r3, r5, [sp, #36]	@ 0x24
 c04a59c:	9f0b      	ldr	r7, [sp, #44]	@ 0x2c
  const uint16_t region = key_slot - SE_ST_START_REGION;
 c04a59e:	b280      	uxth	r0, r0
  if (type != PSA_KEY_TYPE_RAW_DATA)
 c04a5a0:	d127      	bne.n	c04a5f2 <psa_se_st_import+0x6e>
  if ((key_slot < SE_ST_START_REGION) || (key_slot > (SE_ST_START_REGION + p_data->map_size)))
 c04a5a2:	2a06      	cmp	r2, #6
 c04a5a4:	f174 0600 	sbcs.w	r6, r4, #0
 c04a5a8:	d326      	bcc.n	c04a5f8 <psa_se_st_import+0x74>
 c04a5aa:	2600      	movs	r6, #0
 c04a5ac:	f8d1 10c4 	ldr.w	r1, [r1, #196]	@ 0xc4
 c04a5b0:	3106      	adds	r1, #6
 c04a5b2:	4291      	cmp	r1, r2
 c04a5b4:	eb76 0404 	sbcs.w	r4, r6, r4
 c04a5b8:	d31e      	bcc.n	c04a5f8 <psa_se_st_import+0x74>
  ASSERT_SUCCESS(SE_Update(region, 0, data_length, (uint8_t *)data));
 c04a5ba:	4631      	mov	r1, r6
 c04a5bc:	b2aa      	uxth	r2, r5
 c04a5be:	b2c0      	uxtb	r0, r0
 c04a5c0:	f00f fa9e 	bl	c059b00 <SE_Update>
 c04a5c4:	4604      	mov	r4, r0
 c04a5c6:	b168      	cbz	r0, c04a5e4 <psa_se_st_import+0x60>
 c04a5c8:	4603      	mov	r3, r0
 c04a5ca:	f240 22db 	movw	r2, #731	@ 0x2db
 c04a5ce:	490c      	ldr	r1, [pc, #48]	@ (c04a600 <psa_se_st_import+0x7c>)
 c04a5d0:	9600      	str	r6, [sp, #0]
 c04a5d2:	480c      	ldr	r0, [pc, #48]	@ (c04a604 <psa_se_st_import+0x80>)
 c04a5d4:	f7f7 ff12 	bl	c0423fc <iprintf>
 c04a5d8:	4620      	mov	r0, r4
}
 c04a5da:	b003      	add	sp, #12
 c04a5dc:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
  ASSERT_SUCCESS(SE_Update(region, 0, data_length, (uint8_t *)data));
 c04a5e0:	f7ff bfc6 	b.w	c04a570 <se_st_to_psa_error>
  if (bits != NULL)
 c04a5e4:	b917      	cbnz	r7, c04a5ec <psa_se_st_import+0x68>
  ASSERT_SUCCESS(SE_Update(region, 0, data_length, (uint8_t *)data));
 c04a5e6:	2000      	movs	r0, #0
}
 c04a5e8:	b003      	add	sp, #12
 c04a5ea:	bdf0      	pop	{r4, r5, r6, r7, pc}
    *bits = 8 * data_length;
 c04a5ec:	00ed      	lsls	r5, r5, #3
 c04a5ee:	603d      	str	r5, [r7, #0]
 c04a5f0:	e7f9      	b.n	c04a5e6 <psa_se_st_import+0x62>
    return PSA_ERROR_NOT_SUPPORTED;
 c04a5f2:	f06f 0085 	mvn.w	r0, #133	@ 0x85
 c04a5f6:	e7f7      	b.n	c04a5e8 <psa_se_st_import+0x64>
    return PSA_ERROR_INVALID_ARGUMENT;
 c04a5f8:	f06f 0086 	mvn.w	r0, #134	@ 0x86
 c04a5fc:	e7f4      	b.n	c04a5e8 <psa_se_st_import+0x64>
 c04a5fe:	bf00      	nop
 c04a600:	0c0618d0 	.word	0x0c0618d0
 c04a604:	0c061751 	.word	0x0c061751

0c04a608 <psa_se_st_export>:
{
 c04a608:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  const uint16_t region = key - SE_ST_START_REGION;
 c04a60c:	b295      	uxth	r5, r2
{
 c04a60e:	b0a5      	sub	sp, #148	@ 0x94
  switch (slot)
 c04a610:	2d04      	cmp	r5, #4
{
 c04a612:	9e2e      	ldr	r6, [sp, #184]	@ 0xb8
 c04a614:	e9dd 472c 	ldrd	r4, r7, [sp, #176]	@ 0xb0
  switch (slot)
 c04a618:	d029      	beq.n	c04a66e <psa_se_st_export+0x66>
 c04a61a:	2d05      	cmp	r5, #5
 c04a61c:	d07e      	beq.n	c04a71c <psa_se_st_export+0x114>
 c04a61e:	2d03      	cmp	r5, #3
 c04a620:	f040 80ef 	bne.w	c04a802 <psa_se_st_export+0x1fa>
      if (data_size < 9)
 c04a624:	2f08      	cmp	r7, #8
 c04a626:	d807      	bhi.n	c04a638 <psa_se_st_export+0x30>
        SE_ST_PSA_PRINT("Serial Number from slot %d cannot be set in a buffer of size : %d\n", slot, data_size);
 c04a628:	463a      	mov	r2, r7
 c04a62a:	4629      	mov	r1, r5
 c04a62c:	488a      	ldr	r0, [pc, #552]	@ (c04a858 <psa_se_st_export+0x250>)
          SE_ST_PSA_PRINT("slot %d cannot be set in a buffer of size : %d\n", slot, data_size);
 c04a62e:	f7ff fec3 	bl	c04a3b8 <debug_print>
          return PSA_ERROR_BUFFER_TOO_SMALL;
 c04a632:	f06f 0089 	mvn.w	r0, #137	@ 0x89
 c04a636:	e02d      	b.n	c04a694 <psa_se_st_export+0x8c>
      if (data_size >= 19)
 c04a638:	2f12      	cmp	r7, #18
 c04a63a:	d910      	bls.n	c04a65e <psa_se_st_export+0x56>
        ret = SE_GetSerial(data, SE_SERIAL_FORMAT_HEX);
 c04a63c:	2101      	movs	r1, #1
 c04a63e:	4620      	mov	r0, r4
 c04a640:	f00e fff2 	bl	c059628 <SE_GetSerial>
        if (p_data_length != NULL)
 c04a644:	b10e      	cbz	r6, c04a64a <psa_se_st_export+0x42>
          *p_data_length = 19;
 c04a646:	2313      	movs	r3, #19
          *p_data_length = 9;
 c04a648:	6033      	str	r3, [r6, #0]
      if (ret != SE_OK)
 c04a64a:	2800      	cmp	r0, #0
 c04a64c:	f000 80d2 	beq.w	c04a7f4 <psa_se_st_export+0x1ec>
        SE_ST_PSA_PRINT("Serial Number from slot %d cannot be recovered\n", slot);
 c04a650:	2103      	movs	r1, #3
 c04a652:	4882      	ldr	r0, [pc, #520]	@ (c04a85c <psa_se_st_export+0x254>)
 c04a654:	f7ff feb0 	bl	c04a3b8 <debug_print>
        return PSA_ERROR_HARDWARE_FAILURE;
 c04a658:	f06f 0092 	mvn.w	r0, #146	@ 0x92
 c04a65c:	e01a      	b.n	c04a694 <psa_se_st_export+0x8c>
        ret = SE_GetSerial(data, SE_SERIAL_FORMAT_RAW);
 c04a65e:	2100      	movs	r1, #0
 c04a660:	4620      	mov	r0, r4
 c04a662:	f00e ffe1 	bl	c059628 <SE_GetSerial>
        if (p_data_length != NULL)
 c04a666:	2e00      	cmp	r6, #0
 c04a668:	d0ef      	beq.n	c04a64a <psa_se_st_export+0x42>
          *p_data_length = 9;
 c04a66a:	2309      	movs	r3, #9
 c04a66c:	e7ec      	b.n	c04a648 <psa_se_st_export+0x40>
      uint32_t nb_region = 0;
 c04a66e:	2000      	movs	r0, #0
      ret = SE_GetMapping(NULL, &nb_region);
 c04a670:	a903      	add	r1, sp, #12
      uint32_t nb_region = 0;
 c04a672:	9003      	str	r0, [sp, #12]
      ret = SE_GetMapping(NULL, &nb_region);
 c04a674:	f00f fb76 	bl	c059d64 <SE_GetMapping>
      if (ret == SE_OK)
 c04a678:	4601      	mov	r1, r0
 c04a67a:	2800      	cmp	r0, #0
 c04a67c:	d14c      	bne.n	c04a718 <psa_se_st_export+0x110>
        if (nb_region > SE_ST_MAX_REGION)
 c04a67e:	f8dd 800c 	ldr.w	r8, [sp, #12]
 c04a682:	f1b8 0f08 	cmp.w	r8, #8
 c04a686:	d908      	bls.n	c04a69a <psa_se_st_export+0x92>
          SE_ST_PSA_PRINT("Not enough memory for processing up to %u regions\n", nb_region);
 c04a688:	4641      	mov	r1, r8
 c04a68a:	4875      	ldr	r0, [pc, #468]	@ (c04a860 <psa_se_st_export+0x258>)
 c04a68c:	f7ff fe94 	bl	c04a3b8 <debug_print>
          return PSA_ERROR_INVALID_ARGUMENT;
 c04a690:	f06f 0086 	mvn.w	r0, #134	@ 0x86
}
 c04a694:	b025      	add	sp, #148	@ 0x94
 c04a696:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        if (map_size > data_size)
 c04a69a:	2f61      	cmp	r7, #97	@ 0x61
 c04a69c:	d803      	bhi.n	c04a6a6 <psa_se_st_export+0x9e>
          SE_ST_PSA_PRINT("slot %d cannot be set in a buffer of size : %d\n", slot, data_size);
 c04a69e:	463a      	mov	r2, r7
 c04a6a0:	4629      	mov	r1, r5
 c04a6a2:	4870      	ldr	r0, [pc, #448]	@ (c04a864 <psa_se_st_export+0x25c>)
 c04a6a4:	e7c3      	b.n	c04a62e <psa_se_st_export+0x26>
        memset(map, 0, map_size - 2);
 c04a6a6:	2260      	movs	r2, #96	@ 0x60
 c04a6a8:	1ca0      	adds	r0, r4, #2
 c04a6aa:	f011 f840 	bl	c05b72e <memset>
        *((uint16_t *)data) = (uint16_t)(nb_region & 0xFFFF);
 c04a6ae:	f8a4 8000 	strh.w	r8, [r4]
        ret = SE_GetMapping(mapping, &nb_region);
 c04a6b2:	a903      	add	r1, sp, #12
 c04a6b4:	a804      	add	r0, sp, #16
 c04a6b6:	f00f fb55 	bl	c059d64 <SE_GetMapping>
        if (ret != SE_OK)
 c04a6ba:	b968      	cbnz	r0, c04a6d8 <psa_se_st_export+0xd0>
          map[i].lifetime = PSA_KEY_LIFETIME_FROM_PERSISTENCE_AND_LOCATION(
 c04a6bc:	f240 1501 	movw	r5, #257	@ 0x101
 c04a6c0:	f240 17ff 	movw	r7, #511	@ 0x1ff
 c04a6c4:	9903      	ldr	r1, [sp, #12]
 c04a6c6:	aa04      	add	r2, sp, #16
        for (int32_t i = 0; i < nb_region; i++)
 c04a6c8:	4288      	cmp	r0, r1
 c04a6ca:	d109      	bne.n	c04a6e0 <psa_se_st_export+0xd8>
        if (p_data_length != NULL)
 c04a6cc:	2e00      	cmp	r6, #0
 c04a6ce:	f000 8091 	beq.w	c04a7f4 <psa_se_st_export+0x1ec>
          *p_data_length = map_size;
 c04a6d2:	2362      	movs	r3, #98	@ 0x62
            *p_data_length = c_data_len;
 c04a6d4:	6033      	str	r3, [r6, #0]
          return PSA_SUCCESS;
 c04a6d6:	e08d      	b.n	c04a7f4 <psa_se_st_export+0x1ec>
          SE_ST_PSA_PRINT("Mapping cannot be read\n");
 c04a6d8:	4863      	ldr	r0, [pc, #396]	@ (c04a868 <psa_se_st_export+0x260>)
        SE_ST_PSA_PRINT("Preprovisionned slot cannot be read\n");
 c04a6da:	f7ff fe6d 	bl	c04a3b8 <debug_print>
 c04a6de:	e7bb      	b.n	c04a658 <psa_se_st_export+0x50>
          map[i].bits = (mapping[i].size + (((mapping[i].type & 0x1) == 1) ? 4 : 0)) * 8;
 c04a6e0:	7b13      	ldrb	r3, [r2, #12]
 c04a6e2:	f8b2 c002 	ldrh.w	ip, [r2, #2]
 c04a6e6:	009b      	lsls	r3, r3, #2
 c04a6e8:	f003 0304 	and.w	r3, r3, #4
 c04a6ec:	4463      	add	r3, ip
 c04a6ee:	00db      	lsls	r3, r3, #3
          map[i].lifetime = PSA_KEY_LIFETIME_FROM_PERSISTENCE_AND_LOCATION(
 c04a6f0:	f892 c006 	ldrb.w	ip, [r2, #6]
          map[i].bits = (mapping[i].size + (((mapping[i].type & 0x1) == 1) ? 4 : 0)) * 8;
 c04a6f4:	f8c4 3002 	str.w	r3, [r4, #2]
          map[i].id = SE_ST_ID_TO_PSA_ID(SE_ST_MEMORY_REGION_ID(i));
 c04a6f8:	f100 4380 	add.w	r3, r0, #1073741824	@ 0x40000000
 c04a6fc:	3306      	adds	r3, #6
 c04a6fe:	f8c4 300a 	str.w	r3, [r4, #10]
          map[i].lifetime = PSA_KEY_LIFETIME_FROM_PERSISTENCE_AND_LOCATION(
 c04a702:	f1bc 0f02 	cmp.w	ip, #2
 c04a706:	bf94      	ite	ls
 c04a708:	462b      	movls	r3, r5
 c04a70a:	463b      	movhi	r3, r7
        for (int32_t i = 0; i < nb_region; i++)
 c04a70c:	3001      	adds	r0, #1
          map[i].lifetime = PSA_KEY_LIFETIME_FROM_PERSISTENCE_AND_LOCATION(
 c04a70e:	f8c4 3006 	str.w	r3, [r4, #6]
        for (int32_t i = 0; i < nb_region; i++)
 c04a712:	3210      	adds	r2, #16
 c04a714:	340c      	adds	r4, #12
 c04a716:	e7d7      	b.n	c04a6c8 <psa_se_st_export+0xc0>
      SE_ST_PSA_PRINT("Region number cannot be obtained\n");
 c04a718:	4854      	ldr	r0, [pc, #336]	@ (c04a86c <psa_se_st_export+0x264>)
 c04a71a:	e7de      	b.n	c04a6da <psa_se_st_export+0xd2>
      ret = SE_Get_PubKey(SE_SLOT_PERMANENT, NULL, NULL, &key_size, &curve);
 c04a71c:	2200      	movs	r2, #0
 c04a71e:	ad03      	add	r5, sp, #12
 c04a720:	4611      	mov	r1, r2
 c04a722:	2001      	movs	r0, #1
 c04a724:	9500      	str	r5, [sp, #0]
 c04a726:	ab04      	add	r3, sp, #16
 c04a728:	f00f fb46 	bl	c059db8 <SE_Get_PubKey>
      if ((ret == SE_OK) || (ret == SE_BUFFER_TOO_SHORT_ERROR))
 c04a72c:	b108      	cbz	r0, c04a732 <psa_se_st_export+0x12a>
 c04a72e:	2805      	cmp	r0, #5
 c04a730:	d110      	bne.n	c04a754 <psa_se_st_export+0x14c>
        if (key_size != 0)
 c04a732:	9b04      	ldr	r3, [sp, #16]
          nb_key = 2;
 c04a734:	2b00      	cmp	r3, #0
 c04a736:	bf0c      	ite	eq
 c04a738:	f04f 0801 	moveq.w	r8, #1
 c04a73c:	f04f 0802 	movne.w	r8, #2
      key_map = sizeof(psa_se_st_key_attribute_t) * nb_key + 2;
 c04a740:	2218      	movs	r2, #24
 c04a742:	fb02 f208 	mul.w	r2, r2, r8
 c04a746:	f102 0902 	add.w	r9, r2, #2
      if (data_size < key_map)
 c04a74a:	45b9      	cmp	r9, r7
 c04a74c:	d905      	bls.n	c04a75a <psa_se_st_export+0x152>
        SE_ST_PSA_PRINT("slot %d cannot be set in a buffer of size : %d\n", slot, data_size);
 c04a74e:	463a      	mov	r2, r7
 c04a750:	2105      	movs	r1, #5
 c04a752:	e7a6      	b.n	c04a6a2 <psa_se_st_export+0x9a>
      size_t nb_key = 1;
 c04a754:	f04f 0801 	mov.w	r8, #1
 c04a758:	e7f2      	b.n	c04a740 <psa_se_st_export+0x138>
      memset(keys, 0, key_map - 2);
 c04a75a:	2100      	movs	r1, #0
 c04a75c:	1ca0      	adds	r0, r4, #2
 c04a75e:	f010 ffe6 	bl	c05b72e <memset>
      if ( nb_key == 2)
 c04a762:	f1b8 0f02 	cmp.w	r8, #2
      *((uint16_t *)data) = nb_key;
 c04a766:	f8a4 8000 	strh.w	r8, [r4]
      if ( nb_key == 2)
 c04a76a:	d11b      	bne.n	c04a7a4 <psa_se_st_export+0x19c>
        keys[1].alg = PSA_ALG_ECDSA(PSA_ALG_ANY_HASH);
 c04a76c:	4b40      	ldr	r3, [pc, #256]	@ (c04a870 <psa_se_st_export+0x268>)
        keys[1].type = PSA_KEY_TYPE_ECC_KEY_PAIR(SE_TO_PSA_CURVE(curve));
 c04a76e:	f247 1212 	movw	r2, #28946	@ 0x7112
        keys[1].alg = PSA_ALG_ECDSA(PSA_ALG_ANY_HASH);
 c04a772:	f8c4 3022 	str.w	r3, [r4, #34]	@ 0x22
        keys[1].lifetime = PSA_SE_ST_LIFETIME_DEFAULT;
 c04a776:	f240 1301 	movw	r3, #257	@ 0x101
 c04a77a:	f8c4 301a 	str.w	r3, [r4, #26]
        keys[1].usage = PSA_KEY_USAGE_SIGN | PSA_KEY_USAGE_EXPORT;
 c04a77e:	f241 0301 	movw	r3, #4097	@ 0x1001
 c04a782:	f8c4 3026 	str.w	r3, [r4, #38]	@ 0x26
        keys[1].id = SE_ST_ID_TO_PSA_ID(SE_ST_PRIV_SLOT_1);
 c04a786:	4b3b      	ldr	r3, [pc, #236]	@ (c04a874 <psa_se_st_export+0x26c>)
        keys[1].type = PSA_KEY_TYPE_ECC_KEY_PAIR(SE_TO_PSA_CURVE(curve));
 c04a788:	f89d 100c 	ldrb.w	r1, [sp, #12]
        keys[1].id = SE_ST_ID_TO_PSA_ID(SE_ST_PRIV_SLOT_1);
 c04a78c:	f8c4 301e 	str.w	r3, [r4, #30]
        keys[1].bits = key_size * 8;
 c04a790:	9b04      	ldr	r3, [sp, #16]
 c04a792:	00db      	lsls	r3, r3, #3
 c04a794:	f8c4 302a 	str.w	r3, [r4, #42]	@ 0x2a
        keys[1].type = PSA_KEY_TYPE_ECC_KEY_PAIR(SE_TO_PSA_CURVE(curve));
 c04a798:	f247 1330 	movw	r3, #28976	@ 0x7130
 c04a79c:	2901      	cmp	r1, #1
 c04a79e:	bf98      	it	ls
 c04a7a0:	4613      	movls	r3, r2
 c04a7a2:	85e3      	strh	r3, [r4, #46]	@ 0x2e
      ret = SE_Get_PubKey(SE_SLOT_PREPROVISIONNED, NULL, NULL, &key_size, &curve);
 c04a7a4:	2200      	movs	r2, #0
 c04a7a6:	9500      	str	r5, [sp, #0]
 c04a7a8:	4611      	mov	r1, r2
 c04a7aa:	4610      	mov	r0, r2
 c04a7ac:	ab04      	add	r3, sp, #16
 c04a7ae:	f00f fb03 	bl	c059db8 <SE_Get_PubKey>
      if ((ret == SE_OK) || (ret == SE_BUFFER_TOO_SHORT_ERROR))
 c04a7b2:	b108      	cbz	r0, c04a7b8 <psa_se_st_export+0x1b0>
 c04a7b4:	2805      	cmp	r0, #5
 c04a7b6:	d11f      	bne.n	c04a7f8 <psa_se_st_export+0x1f0>
        keys[0].alg = PSA_ALG_ECDSA(PSA_ALG_ANY_HASH);
 c04a7b8:	4b2d      	ldr	r3, [pc, #180]	@ (c04a870 <psa_se_st_export+0x268>)
        keys[0].type = PSA_KEY_TYPE_ECC_KEY_PAIR(SE_TO_PSA_CURVE(curve));
 c04a7ba:	f247 1212 	movw	r2, #28946	@ 0x7112
        keys[0].alg = PSA_ALG_ECDSA(PSA_ALG_ANY_HASH);
 c04a7be:	f8c4 300a 	str.w	r3, [r4, #10]
        keys[0].lifetime = PSA_SE_ST_LIFETIME_READ_ONLY;
 c04a7c2:	f240 13ff 	movw	r3, #511	@ 0x1ff
 c04a7c6:	f8c4 3002 	str.w	r3, [r4, #2]
        keys[0].usage = PSA_KEY_USAGE_SIGN | PSA_KEY_USAGE_EXPORT;
 c04a7ca:	f241 0301 	movw	r3, #4097	@ 0x1001
 c04a7ce:	f8c4 300e 	str.w	r3, [r4, #14]
        keys[0].id = SE_ST_ID_TO_PSA_ID(SE_ST_PRIV_SLOT_0);
 c04a7d2:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 c04a7d6:	f8c4 3006 	str.w	r3, [r4, #6]
        keys[0].bits = key_size * 8;
 c04a7da:	9b04      	ldr	r3, [sp, #16]
        keys[0].type = PSA_KEY_TYPE_ECC_KEY_PAIR(SE_TO_PSA_CURVE(curve));
 c04a7dc:	f89d 100c 	ldrb.w	r1, [sp, #12]
        keys[0].bits = key_size * 8;
 c04a7e0:	00db      	lsls	r3, r3, #3
 c04a7e2:	f8c4 3012 	str.w	r3, [r4, #18]
        keys[0].type = PSA_KEY_TYPE_ECC_KEY_PAIR(SE_TO_PSA_CURVE(curve));
 c04a7e6:	f247 1330 	movw	r3, #28976	@ 0x7130
 c04a7ea:	2901      	cmp	r1, #1
 c04a7ec:	bf98      	it	ls
 c04a7ee:	4613      	movls	r3, r2
 c04a7f0:	82e3      	strh	r3, [r4, #22]
      if (p_data_length != NULL)
 c04a7f2:	b91e      	cbnz	r6, c04a7fc <psa_se_st_export+0x1f4>
      return PSA_SUCCESS;
 c04a7f4:	2000      	movs	r0, #0
 c04a7f6:	e74d      	b.n	c04a694 <psa_se_st_export+0x8c>
        SE_ST_PSA_PRINT("Preprovisionned slot cannot be read\n");
 c04a7f8:	481f      	ldr	r0, [pc, #124]	@ (c04a878 <psa_se_st_export+0x270>)
 c04a7fa:	e76e      	b.n	c04a6da <psa_se_st_export+0xd2>
        *p_data_length = key_map;
 c04a7fc:	f8c6 9000 	str.w	r9, [r6]
 c04a800:	e7f8      	b.n	c04a7f4 <psa_se_st_export+0x1ec>
      if (slot >= SE_ST_START_REGION)
 c04a802:	2d05      	cmp	r5, #5
 c04a804:	d925      	bls.n	c04a852 <psa_se_st_export+0x24a>
  const uint16_t region = key - SE_ST_START_REGION;
 c04a806:	3d06      	subs	r5, #6
        ret = SE_MemoryCheck(region, 0, &c_data_len);
 c04a808:	b2ed      	uxtb	r5, r5
 c04a80a:	2100      	movs	r1, #0
 c04a80c:	aa04      	add	r2, sp, #16
 c04a80e:	4628      	mov	r0, r5
        uint16_t c_data_len = data_size;
 c04a810:	f8ad 7010 	strh.w	r7, [sp, #16]
        ret = SE_MemoryCheck(region, 0, &c_data_len);
 c04a814:	f00e ff5c 	bl	c0596d0 <SE_MemoryCheck>
          ASSERT_SUCCESS(SE_Read(region, 0, c_data_len, data));
 c04a818:	4623      	mov	r3, r4
 c04a81a:	2100      	movs	r1, #0
 c04a81c:	4628      	mov	r0, r5
 c04a81e:	f8bd 2010 	ldrh.w	r2, [sp, #16]
 c04a822:	f00e ff79 	bl	c059718 <SE_Read>
 c04a826:	4604      	mov	r4, r0
 c04a828:	b170      	cbz	r0, c04a848 <psa_se_st_export+0x240>
 c04a82a:	2300      	movs	r3, #0
 c04a82c:	f240 3299 	movw	r2, #921	@ 0x399
 c04a830:	9300      	str	r3, [sp, #0]
 c04a832:	4912      	ldr	r1, [pc, #72]	@ (c04a87c <psa_se_st_export+0x274>)
 c04a834:	4603      	mov	r3, r0
 c04a836:	4812      	ldr	r0, [pc, #72]	@ (c04a880 <psa_se_st_export+0x278>)
 c04a838:	f7f7 fde0 	bl	c0423fc <iprintf>
 c04a83c:	4620      	mov	r0, r4
}
 c04a83e:	b025      	add	sp, #148	@ 0x94
 c04a840:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
          ASSERT_SUCCESS(SE_Read(region, 0, c_data_len, data));
 c04a844:	f7ff be94 	b.w	c04a570 <se_st_to_psa_error>
          if (p_data_length != NULL)
 c04a848:	2e00      	cmp	r6, #0
 c04a84a:	d0d3      	beq.n	c04a7f4 <psa_se_st_export+0x1ec>
            *p_data_length = c_data_len;
 c04a84c:	f8bd 3010 	ldrh.w	r3, [sp, #16]
 c04a850:	e740      	b.n	c04a6d4 <psa_se_st_export+0xcc>
  psa_status_t status = PSA_ERROR_GENERIC_ERROR;
 c04a852:	f06f 0083 	mvn.w	r0, #131	@ 0x83
 c04a856:	e71d      	b.n	c04a694 <psa_se_st_export+0x8c>
 c04a858:	0c061784 	.word	0x0c061784
 c04a85c:	0c0617c7 	.word	0x0c0617c7
 c04a860:	0c0617f7 	.word	0x0c0617f7
 c04a864:	0c061797 	.word	0x0c061797
 c04a868:	0c06182a 	.word	0x0c06182a
 c04a86c:	0c061842 	.word	0x0c061842
 c04a870:	060006ff 	.word	0x060006ff
 c04a874:	40000001 	.word	0x40000001
 c04a878:	0c061864 	.word	0x0c061864
 c04a87c:	0c0618bf 	.word	0x0c0618bf
 c04a880:	0c061751 	.word	0x0c061751

0c04a884 <psa_se_st_gen_key_fct>:
{
 c04a884:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 c04a888:	e9dd 350a 	ldrd	r3, r5, [sp, #40]	@ 0x28
 c04a88c:	881c      	ldrh	r4, [r3, #0]
 c04a88e:	4607      	mov	r7, r0
 c04a890:	e9dd 060c 	ldrd	r0, r6, [sp, #48]	@ 0x30
  switch (PSA_KEY_TYPE_ECC_GET_FAMILY(type))
 c04a894:	f404 414f 	and.w	r1, r4, #52992	@ 0xcf00
 c04a898:	f5b1 4f82 	cmp.w	r1, #16640	@ 0x4100
    return( attributes->core.bits );
 c04a89c:	885b      	ldrh	r3, [r3, #2]
 c04a89e:	d104      	bne.n	c04a8aa <psa_se_st_gen_key_fct+0x26>
 c04a8a0:	b2e4      	uxtb	r4, r4
 c04a8a2:	2c12      	cmp	r4, #18
 c04a8a4:	d004      	beq.n	c04a8b0 <psa_se_st_gen_key_fct+0x2c>
 c04a8a6:	2c30      	cmp	r4, #48	@ 0x30
 c04a8a8:	d00b      	beq.n	c04a8c2 <psa_se_st_gen_key_fct+0x3e>
 c04a8aa:	f06f 0085 	mvn.w	r0, #133	@ 0x85
 c04a8ae:	e050      	b.n	c04a952 <psa_se_st_gen_key_fct+0xce>
      if (bits == 256)
 c04a8b0:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 c04a8b4:	d033      	beq.n	c04a91e <psa_se_st_gen_key_fct+0x9a>
      if (bits == 384)
 c04a8b6:	f5b3 7fc0 	cmp.w	r3, #384	@ 0x180
 c04a8ba:	d1f6      	bne.n	c04a8aa <psa_se_st_gen_key_fct+0x26>
        key_size = 48;
 c04a8bc:	2430      	movs	r4, #48	@ 0x30
        curve = SE_KEY_TYPE_NIST_384;
 c04a8be:	2101      	movs	r1, #1
 c04a8c0:	e006      	b.n	c04a8d0 <psa_se_st_gen_key_fct+0x4c>
      if (bits == 256)
 c04a8c2:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 c04a8c6:	d02d      	beq.n	c04a924 <psa_se_st_gen_key_fct+0xa0>
      if (bits == 384)
 c04a8c8:	f5b3 7fc0 	cmp.w	r3, #384	@ 0x180
 c04a8cc:	d1ed      	bne.n	c04a8aa <psa_se_st_gen_key_fct+0x26>
        curve = SE_KEY_TYPE_BP_384;
 c04a8ce:	2103      	movs	r1, #3
  if (pubkey != NULL && pubkey_size < 1 + ((bits / 8) * 2))
 c04a8d0:	b125      	cbz	r5, c04a8dc <psa_se_st_gen_key_fct+0x58>
 c04a8d2:	08db      	lsrs	r3, r3, #3
 c04a8d4:	005b      	lsls	r3, r3, #1
 c04a8d6:	3301      	adds	r3, #1
 c04a8d8:	4283      	cmp	r3, r0
 c04a8da:	d83d      	bhi.n	c04a958 <psa_se_st_gen_key_fct+0xd4>
  const uint16_t l_key = key_slot;
 c04a8dc:	b290      	uxth	r0, r2
  if ((l_key != SE_ST_PRIV_SLOT_1) && (l_key != SE_ST_PRIV_SLOT_FF))
 c04a8de:	1e43      	subs	r3, r0, #1
 c04a8e0:	2b01      	cmp	r3, #1
 c04a8e2:	d83c      	bhi.n	c04a95e <psa_se_st_gen_key_fct+0xda>
  if (l_key == SE_ST_PRIV_SLOT_FF)
 c04a8e4:	2802      	cmp	r0, #2
  SE_psa_drv_se_persistent_t *p_data = (SE_psa_drv_se_persistent_t *)(drv_context->persistent_data);
 c04a8e6:	683a      	ldr	r2, [r7, #0]
  if (l_key == SE_ST_PRIV_SLOT_FF)
 c04a8e8:	d03c      	beq.n	c04a964 <psa_se_st_gen_key_fct+0xe0>
    pub_y = p_data->pub_keys[0].public_key_y;
 c04a8ea:	4690      	mov	r8, r2
    p_data->pub_keys[0].public_key_curve = curve;
 c04a8ec:	2001      	movs	r0, #1
    pub_x = p_data->pub_keys[0].public_key_x;
 c04a8ee:	1c57      	adds	r7, r2, #1
    p_data->pub_keys[0].public_key_curve = curve;
 c04a8f0:	f808 1b31 	strb.w	r1, [r8], #49
  ASSERT_SUCCESS(SE_GenerateKeyPair(slot, curve, pub_x, pub_y));
 c04a8f4:	4643      	mov	r3, r8
 c04a8f6:	463a      	mov	r2, r7
 c04a8f8:	f00f f962 	bl	c059bc0 <SE_GenerateKeyPair>
 c04a8fc:	4681      	mov	r9, r0
 c04a8fe:	b1a0      	cbz	r0, c04a92a <psa_se_st_gen_key_fct+0xa6>
 c04a900:	2300      	movs	r3, #0
 c04a902:	f240 22a5 	movw	r2, #677	@ 0x2a5
 c04a906:	9300      	str	r3, [sp, #0]
 c04a908:	491a      	ldr	r1, [pc, #104]	@ (c04a974 <psa_se_st_gen_key_fct+0xf0>)
 c04a90a:	4603      	mov	r3, r0
 c04a90c:	481a      	ldr	r0, [pc, #104]	@ (c04a978 <psa_se_st_gen_key_fct+0xf4>)
 c04a90e:	f7f7 fd75 	bl	c0423fc <iprintf>
 c04a912:	4648      	mov	r0, r9
}
 c04a914:	b003      	add	sp, #12
 c04a916:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
  ASSERT_SUCCESS(SE_GenerateKeyPair(slot, curve, pub_x, pub_y));
 c04a91a:	f7ff be29 	b.w	c04a570 <se_st_to_psa_error>
        key_size = 32;
 c04a91e:	2420      	movs	r4, #32
        curve = SE_KEY_TYPE_NIST_256;
 c04a920:	2100      	movs	r1, #0
 c04a922:	e7d5      	b.n	c04a8d0 <psa_se_st_gen_key_fct+0x4c>
        key_size = 32;
 c04a924:	2420      	movs	r4, #32
        curve = SE_KEY_TYPE_BP_256;
 c04a926:	2102      	movs	r1, #2
 c04a928:	e7d2      	b.n	c04a8d0 <psa_se_st_gen_key_fct+0x4c>
  if (pubkey != NULL)
 c04a92a:	b16d      	cbz	r5, c04a948 <psa_se_st_gen_key_fct+0xc4>
    pubkey[0] = 0x4;
 c04a92c:	4628      	mov	r0, r5
 c04a92e:	2304      	movs	r3, #4
    memcpy(&pubkey[1], pub_x, key_size);
 c04a930:	4622      	mov	r2, r4
 c04a932:	4639      	mov	r1, r7
    pubkey[0] = 0x4;
 c04a934:	f800 3b01 	strb.w	r3, [r0], #1
    memcpy(&pubkey[1], pub_x, key_size);
 c04a938:	f010 fe88 	bl	c05b64c <memcpy>
    memcpy(&pubkey[1 + key_size], pub_y, key_size);
 c04a93c:	1c60      	adds	r0, r4, #1
 c04a93e:	4622      	mov	r2, r4
 c04a940:	4641      	mov	r1, r8
 c04a942:	4428      	add	r0, r5
 c04a944:	f010 fe82 	bl	c05b64c <memcpy>
  if (pubkey_length != NULL)
 c04a948:	b116      	cbz	r6, c04a950 <psa_se_st_gen_key_fct+0xcc>
    *pubkey_length = 1 + key_size * 2;
 c04a94a:	0064      	lsls	r4, r4, #1
 c04a94c:	3401      	adds	r4, #1
 c04a94e:	6034      	str	r4, [r6, #0]
  ASSERT_SUCCESS(SE_GenerateKeyPair(slot, curve, pub_x, pub_y));
 c04a950:	2000      	movs	r0, #0
}
 c04a952:	b003      	add	sp, #12
 c04a954:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    return PSA_ERROR_BUFFER_TOO_SMALL;
 c04a958:	f06f 0089 	mvn.w	r0, #137	@ 0x89
 c04a95c:	e7f9      	b.n	c04a952 <psa_se_st_gen_key_fct+0xce>
    return PSA_ERROR_INVALID_ARGUMENT;
 c04a95e:	f06f 0086 	mvn.w	r0, #134	@ 0x86
 c04a962:	e7f6      	b.n	c04a952 <psa_se_st_gen_key_fct+0xce>
    pub_x = p_data->pub_keys[1].public_key_x;
 c04a964:	f102 0762 	add.w	r7, r2, #98	@ 0x62
    pub_y = p_data->pub_keys[1].public_key_y;
 c04a968:	f102 0892 	add.w	r8, r2, #146	@ 0x92
    p_data->pub_keys[1].public_key_curve = curve;
 c04a96c:	f882 1061 	strb.w	r1, [r2, #97]	@ 0x61
 c04a970:	e7c0      	b.n	c04a8f4 <psa_se_st_gen_key_fct+0x70>
 c04a972:	bf00      	nop
 c04a974:	0c0618a9 	.word	0x0c0618a9
 c04a978:	0c061751 	.word	0x0c061751

0c04a97c <psa_se_st_sign_fct>:
{
 c04a97c:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
  if ((key_slot != SE_ST_PRIV_SLOT_0) && (key_slot != SE_ST_PRIV_SLOT_1))
 c04a980:	2a02      	cmp	r2, #2
 c04a982:	f173 0300 	sbcs.w	r3, r3, #0
{
 c04a986:	f8dd 903c 	ldr.w	r9, [sp, #60]	@ 0x3c
 c04a98a:	e9dd 780b 	ldrd	r7, r8, [sp, #44]	@ 0x2c
 c04a98e:	e9dd 6a0d 	ldrd	r6, sl, [sp, #52]	@ 0x34
  if ((key_slot != SE_ST_PRIV_SLOT_0) && (key_slot != SE_ST_PRIV_SLOT_1))
 c04a992:	d228      	bcs.n	c04a9e6 <psa_se_st_sign_fct+0x6a>
  if (key_slot == SE_ST_PRIV_SLOT_1)
 c04a994:	b2d4      	uxtb	r4, r2
  key_size = SE_GetKeySize(key_slot) / 8;
 c04a996:	4620      	mov	r0, r4
 c04a998:	f00f f9d0 	bl	c059d3c <SE_GetKeySize>
  if (key_size == 0)
 c04a99c:	2807      	cmp	r0, #7
  key_size = SE_GetKeySize(key_slot) / 8;
 c04a99e:	ea4f 05d0 	mov.w	r5, r0, lsr #3
  if (key_size == 0)
 c04a9a2:	d925      	bls.n	c04a9f0 <psa_se_st_sign_fct+0x74>
  if (signature_size < key_size * 2)
 c04a9a4:	ebba 0f45 	cmp.w	sl, r5, lsl #1
 c04a9a8:	ea4f 0345 	mov.w	r3, r5, lsl #1
 c04a9ac:	d323      	bcc.n	c04a9f6 <psa_se_st_sign_fct+0x7a>
  ASSERT_SUCCESS(SE_GenerateSignature(slot, p_hash, (uint16_t)hash_length, p_signature, p_signature + key_size));
 c04a9ae:	4435      	add	r5, r6
  *p_signature_length = key_size * 2;
 c04a9b0:	f8c9 3000 	str.w	r3, [r9]
  ASSERT_SUCCESS(SE_GenerateSignature(slot, p_hash, (uint16_t)hash_length, p_signature, p_signature + key_size));
 c04a9b4:	4620      	mov	r0, r4
 c04a9b6:	4633      	mov	r3, r6
 c04a9b8:	4639      	mov	r1, r7
 c04a9ba:	9500      	str	r5, [sp, #0]
 c04a9bc:	fa1f f288 	uxth.w	r2, r8
 c04a9c0:	f00f f964 	bl	c059c8c <SE_GenerateSignature>
 c04a9c4:	4604      	mov	r4, r0
 c04a9c6:	b180      	cbz	r0, c04a9ea <psa_se_st_sign_fct+0x6e>
 c04a9c8:	2300      	movs	r3, #0
 c04a9ca:	f240 423d 	movw	r2, #1085	@ 0x43d
 c04a9ce:	9300      	str	r3, [sp, #0]
 c04a9d0:	490a      	ldr	r1, [pc, #40]	@ (c04a9fc <psa_se_st_sign_fct+0x80>)
 c04a9d2:	4603      	mov	r3, r0
 c04a9d4:	480a      	ldr	r0, [pc, #40]	@ (c04aa00 <psa_se_st_sign_fct+0x84>)
 c04a9d6:	f7f7 fd11 	bl	c0423fc <iprintf>
 c04a9da:	4620      	mov	r0, r4
}
 c04a9dc:	b002      	add	sp, #8
 c04a9de:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  ASSERT_SUCCESS(SE_GenerateSignature(slot, p_hash, (uint16_t)hash_length, p_signature, p_signature + key_size));
 c04a9e2:	f7ff bdc5 	b.w	c04a570 <se_st_to_psa_error>
    return PSA_ERROR_NOT_SUPPORTED;
 c04a9e6:	f06f 0085 	mvn.w	r0, #133	@ 0x85
}
 c04a9ea:	b002      	add	sp, #8
 c04a9ec:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    return PSA_ERROR_HARDWARE_FAILURE;
 c04a9f0:	f06f 0092 	mvn.w	r0, #146	@ 0x92
 c04a9f4:	e7f9      	b.n	c04a9ea <psa_se_st_sign_fct+0x6e>
    return PSA_ERROR_BUFFER_TOO_SMALL;
 c04a9f6:	f06f 0089 	mvn.w	r0, #137	@ 0x89
 c04a9fa:	e7f6      	b.n	c04a9ea <psa_se_st_sign_fct+0x6e>
 c04a9fc:	0c061896 	.word	0x0c061896
 c04aa00:	0c061751 	.word	0x0c061751

0c04aa04 <register_se_keys>:
{
 c04aa04:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c04aa08:	b0af      	sub	sp, #188	@ 0xbc
    psa_key_attributes_t attributes = psa_key_attributes_init();
 c04aa0a:	a814      	add	r0, sp, #80	@ 0x50
 c04aa0c:	f7ff fc07 	bl	c04a21e <psa_key_attributes_init>
    return register_function_key( SE_ST_ID_TO_PSA_ID(SE_ST_SERIAL_NUMBER),
 c04aa10:	488e      	ldr	r0, [pc, #568]	@ (c04ac4c <register_se_keys+0x248>)
 c04aa12:	a914      	add	r1, sp, #80	@ 0x50
 c04aa14:	f7ff fcaa 	bl	c04a36c <register_function_key>
    if ((psa_status = register_se_serial_number_key()) != PSA_SUCCESS)
 c04aa18:	4604      	mov	r4, r0
 c04aa1a:	2800      	cmp	r0, #0
 c04aa1c:	f040 80e4 	bne.w	c04abe8 <register_se_keys+0x1e4>
    psa_key_attributes_t attributes = psa_key_attributes_init();
 c04aa20:	a808      	add	r0, sp, #32
 c04aa22:	f7ff fbfc 	bl	c04a21e <psa_key_attributes_init>
    mbedtls_svc_key_id_t mbedtls_id = {0,tfm_nspm_get_current_client_id()};
 c04aa26:	f013 fcdd 	bl	c05e3e4 <tfm_nspm_get_current_client_id>
    psa_status = register_function_key( SE_ST_ID_TO_PSA_ID(SE_ST_KEY_MAPPING),
 c04aa2a:	4d89      	ldr	r5, [pc, #548]	@ (c04ac50 <register_se_keys+0x24c>)
    mbedtls_svc_key_id_t mbedtls_id = {0,tfm_nspm_get_current_client_id()};
 c04aa2c:	9005      	str	r0, [sp, #20]
    psa_status = register_function_key( SE_ST_ID_TO_PSA_ID(SE_ST_KEY_MAPPING),
 c04aa2e:	a908      	add	r1, sp, #32
 c04aa30:	4628      	mov	r0, r5
    size_t data_size = 0;
 c04aa32:	9403      	str	r4, [sp, #12]
    psa_status = register_function_key( SE_ST_ID_TO_PSA_ID(SE_ST_KEY_MAPPING),
 c04aa34:	f7ff fc9a 	bl	c04a36c <register_function_key>
    if (psa_status != PSA_SUCCESS) {
 c04aa38:	4604      	mov	r4, r0
 c04aa3a:	2800      	cmp	r0, #0
 c04aa3c:	f040 80d4 	bne.w	c04abe8 <register_se_keys+0x1e4>
    mbedtls_id.key_id = SE_ST_ID_TO_PSA_ID(SE_ST_KEY_MAPPING);
 c04aa40:	9504      	str	r5, [sp, #16]
    attributes = psa_key_attributes_init();
 c04aa42:	a808      	add	r0, sp, #32
    psa_status = psa_open_key(mbedtls_id, &key_handle);
 c04aa44:	ad06      	add	r5, sp, #24
 c04aa46:	ae04      	add	r6, sp, #16
    attributes = psa_key_attributes_init();
 c04aa48:	f7ff fbe9 	bl	c04a21e <psa_key_attributes_init>
    psa_status = psa_open_key(mbedtls_id, &key_handle);
 c04aa4c:	e896 0003 	ldmia.w	r6, {r0, r1}
 c04aa50:	462a      	mov	r2, r5
 c04aa52:	f7fe fb4b 	bl	c0490ec <mbedcrypto__psa_open_key>
    if (psa_status != PSA_SUCCESS) {
 c04aa56:	4604      	mov	r4, r0
 c04aa58:	2800      	cmp	r0, #0
 c04aa5a:	f040 80c5 	bne.w	c04abe8 <register_se_keys+0x1e4>
    psa_status = psa_export_key(key_handle, data, sizeof(data), &data_size);
 c04aa5e:	af03      	add	r7, sp, #12
 c04aa60:	9700      	str	r7, [sp, #0]
 c04aa62:	2362      	movs	r3, #98	@ 0x62
 c04aa64:	e895 0003 	ldmia.w	r5, {r0, r1}
 c04aa68:	aa14      	add	r2, sp, #80	@ 0x50
 c04aa6a:	f7fa fc94 	bl	c045396 <mbedcrypto__psa_export_key>
    if (psa_status == PSA_SUCCESS) {
 c04aa6e:	2800      	cmp	r0, #0
 c04aa70:	f040 80b2 	bne.w	c04abd8 <register_se_keys+0x1d4>
        map.nb_key = *((uint16_t *)data);
 c04aa74:	f8bd 8050 	ldrh.w	r8, [sp, #80]	@ 0x50
        if (map.nb_key > SE_ST_PRIV_MAX_SLOT) {
 c04aa78:	f1b8 0f02 	cmp.w	r8, #2
 c04aa7c:	d93f      	bls.n	c04aafe <register_se_keys+0xfa>
            psa_close_key(key_handle);
 c04aa7e:	e895 0003 	ldmia.w	r5, {r0, r1}
 c04aa82:	f7fe fb54 	bl	c04912e <mbedcrypto__psa_close_key>
    mbedtls_svc_key_id_t mbedtls_id = {0,tfm_nspm_get_current_client_id()};
 c04aa86:	2400      	movs	r4, #0
    psa_key_attributes_t attributes = psa_key_attributes_init();
 c04aa88:	a808      	add	r0, sp, #32
 c04aa8a:	f7ff fbc8 	bl	c04a21e <psa_key_attributes_init>
    mbedtls_svc_key_id_t mbedtls_id = {0,tfm_nspm_get_current_client_id()};
 c04aa8e:	9404      	str	r4, [sp, #16]
 c04aa90:	f013 fca8 	bl	c05e3e4 <tfm_nspm_get_current_client_id>
    psa_status = register_function_key( SE_ST_ID_TO_PSA_ID(SE_ST_MAPPING),
 c04aa94:	f8df 81bc 	ldr.w	r8, [pc, #444]	@ c04ac54 <register_se_keys+0x250>
    mbedtls_svc_key_id_t mbedtls_id = {0,tfm_nspm_get_current_client_id()};
 c04aa98:	9005      	str	r0, [sp, #20]
    psa_status = register_function_key( SE_ST_ID_TO_PSA_ID(SE_ST_MAPPING),
 c04aa9a:	a908      	add	r1, sp, #32
 c04aa9c:	4640      	mov	r0, r8
    size_t data_size = 0;
 c04aa9e:	9403      	str	r4, [sp, #12]
    psa_status = register_function_key( SE_ST_ID_TO_PSA_ID(SE_ST_MAPPING),
 c04aaa0:	f7ff fc64 	bl	c04a36c <register_function_key>
    if (psa_status != PSA_SUCCESS) {
 c04aaa4:	4604      	mov	r4, r0
 c04aaa6:	2800      	cmp	r0, #0
 c04aaa8:	f040 809e 	bne.w	c04abe8 <register_se_keys+0x1e4>
    attributes = psa_key_attributes_init();
 c04aaac:	a808      	add	r0, sp, #32
 c04aaae:	f7ff fbb6 	bl	c04a21e <psa_key_attributes_init>
      mbedtls_id.key_id = SE_ST_ID_TO_PSA_ID(SE_ST_MAPPING);
 c04aab2:	f8cd 8010 	str.w	r8, [sp, #16]
      psa_status = psa_open_key(mbedtls_id, &key_handle);
 c04aab6:	462a      	mov	r2, r5
 c04aab8:	e896 0003 	ldmia.w	r6, {r0, r1}
 c04aabc:	f7fe fb16 	bl	c0490ec <mbedcrypto__psa_open_key>
      if (psa_status != PSA_SUCCESS) {
 c04aac0:	4604      	mov	r4, r0
 c04aac2:	2800      	cmp	r0, #0
 c04aac4:	f040 8090 	bne.w	c04abe8 <register_se_keys+0x1e4>
      psa_status = psa_export_key(key_handle, data, sizeof(data), &data_size);
 c04aac8:	9700      	str	r7, [sp, #0]
 c04aaca:	2362      	movs	r3, #98	@ 0x62
 c04aacc:	e895 0003 	ldmia.w	r5, {r0, r1}
 c04aad0:	aa14      	add	r2, sp, #80	@ 0x50
 c04aad2:	f7fa fc60 	bl	c045396 <mbedcrypto__psa_export_key>
      if (psa_status == PSA_SUCCESS) {
 c04aad6:	b960      	cbnz	r0, c04aaf2 <register_se_keys+0xee>
 c04aad8:	2706      	movs	r7, #6
 c04aada:	4680      	mov	r8, r0
    if( bits > PSA_MAX_KEY_BITS )
 c04aadc:	f64f 7af8 	movw	sl, #65528	@ 0xfff8
 c04aae0:	f64f 7bff 	movw	fp, #65535	@ 0xffff
 c04aae4:	f10d 0952 	add.w	r9, sp, #82	@ 0x52
          for (int i = 0; i < *((uint16_t*)data); i++)
 c04aae8:	f8bd 2050 	ldrh.w	r2, [sp, #80]	@ 0x50
 c04aaec:	1fbb      	subs	r3, r7, #6
 c04aaee:	429a      	cmp	r2, r3
 c04aaf0:	dc7e      	bgt.n	c04abf0 <register_se_keys+0x1ec>
      psa_status = psa_close_key(key_handle);
 c04aaf2:	e895 0003 	ldmia.w	r5, {r0, r1}
 c04aaf6:	f7fe fb1a 	bl	c04912e <mbedcrypto__psa_close_key>
 c04aafa:	4604      	mov	r4, r0
exit:
 c04aafc:	e074      	b.n	c04abe8 <register_se_keys+0x1e4>
        mbedtls_id.key_id = map.keys[0].id;
 c04aafe:	f8dd 3056 	ldr.w	r3, [sp, #86]	@ 0x56
    attributes->slot_number = slot_number;
 c04ab02:	2200      	movs	r2, #0
 c04ab04:	9304      	str	r3, [sp, #16]
    attributes->core.flags |= MBEDTLS_PSA_KA_FLAG_HAS_SLOT_NUMBER;
 c04ab06:	f8bd 303c 	ldrh.w	r3, [sp, #60]	@ 0x3c
 c04ab0a:	f64f 71f8 	movw	r1, #65528	@ 0xfff8
 c04ab0e:	f043 0301 	orr.w	r3, r3, #1
 c04ab12:	f8ad 303c 	strh.w	r3, [sp, #60]	@ 0x3c
    attributes->slot_number = slot_number;
 c04ab16:	2300      	movs	r3, #0
 c04ab18:	e9cd 2310 	strd	r2, r3, [sp, #64]	@ 0x40
 c04ab1c:	f64f 72ff 	movw	r2, #65535	@ 0xffff
        psa_set_key_lifetime(&attributes, map.keys[0].lifetime);
 c04ab20:	f8dd 3052 	ldr.w	r3, [sp, #82]	@ 0x52
        psa_set_key_usage_flags(&attributes, map.keys[0].usage);
 c04ab24:	a808      	add	r0, sp, #32
    attributes->core.lifetime = lifetime;
 c04ab26:	9309      	str	r3, [sp, #36]	@ 0x24
    if( PSA_KEY_LIFETIME_IS_VOLATILE( lifetime ) )
 c04ab28:	f013 03ff 	ands.w	r3, r3, #255	@ 0xff
        attributes->core.id.key_id = 0;
 c04ab2c:	bf08      	it	eq
 c04ab2e:	930a      	streq	r3, [sp, #40]	@ 0x28
        psa_set_key_bits(&attributes, map.keys[0].bits);
 c04ab30:	f8dd 3062 	ldr.w	r3, [sp, #98]	@ 0x62
    if( bits > PSA_MAX_KEY_BITS )
 c04ab34:	428b      	cmp	r3, r1
 c04ab36:	bf88      	it	hi
 c04ab38:	4613      	movhi	r3, r2
        psa_set_key_usage_flags(&attributes, map.keys[0].usage);
 c04ab3a:	f8dd 105e 	ldr.w	r1, [sp, #94]	@ 0x5e
 c04ab3e:	f8ad 3022 	strh.w	r3, [sp, #34]	@ 0x22
 c04ab42:	f7ff fb74 	bl	c04a22e <psa_set_key_usage_flags>
        psa_set_key_type(&attributes, map.keys[0].type);
 c04ab46:	f8bd 1066 	ldrh.w	r1, [sp, #102]	@ 0x66
 c04ab4a:	f7ff fbb9 	bl	c04a2c0 <psa_set_key_type>
        psa_status = register_key_in_all_domain(mbedtls_id, &attributes);
 c04ab4e:	e896 0003 	ldmia.w	r6, {r0, r1}
        psa_set_key_algorithm(&attributes, map.keys[0].alg);
 c04ab52:	f8dd 305a 	ldr.w	r3, [sp, #90]	@ 0x5a
        psa_status = register_key_in_all_domain(mbedtls_id, &attributes);
 c04ab56:	aa08      	add	r2, sp, #32
    attributes->core.policy.alg = alg;
 c04ab58:	930d      	str	r3, [sp, #52]	@ 0x34
 c04ab5a:	f7ff fbbd 	bl	c04a2d8 <register_key_in_all_domain>
        if (psa_status != PSA_SUCCESS) {
 c04ab5e:	4604      	mov	r4, r0
 c04ab60:	b120      	cbz	r0, c04ab6c <register_se_keys+0x168>
                  psa_close_key(key_handle);
 c04ab62:	e895 0003 	ldmia.w	r5, {r0, r1}
 c04ab66:	f7fe fae2 	bl	c04912e <mbedcrypto__psa_close_key>
                  goto exit;
 c04ab6a:	e03d      	b.n	c04abe8 <register_se_keys+0x1e4>
        if (map.nb_key > 1)
 c04ab6c:	f1b8 0f02 	cmp.w	r8, #2
 c04ab70:	d132      	bne.n	c04abd8 <register_se_keys+0x1d4>
          mbedtls_id.key_id = map.keys[1].id;
 c04ab72:	f8dd 306e 	ldr.w	r3, [sp, #110]	@ 0x6e
 c04ab76:	2201      	movs	r2, #1
 c04ab78:	9304      	str	r3, [sp, #16]
    attributes->core.flags |= MBEDTLS_PSA_KA_FLAG_HAS_SLOT_NUMBER;
 c04ab7a:	f8bd 303c 	ldrh.w	r3, [sp, #60]	@ 0x3c
    if( bits > PSA_MAX_KEY_BITS )
 c04ab7e:	f64f 71f8 	movw	r1, #65528	@ 0xfff8
 c04ab82:	f043 0301 	orr.w	r3, r3, #1
 c04ab86:	f8ad 303c 	strh.w	r3, [sp, #60]	@ 0x3c
    attributes->slot_number = slot_number;
 c04ab8a:	2300      	movs	r3, #0
 c04ab8c:	e9cd 2310 	strd	r2, r3, [sp, #64]	@ 0x40
 c04ab90:	f64f 72ff 	movw	r2, #65535	@ 0xffff
          psa_set_key_lifetime(&attributes, map.keys[1].lifetime);
 c04ab94:	f8dd 306a 	ldr.w	r3, [sp, #106]	@ 0x6a
          psa_set_key_usage_flags(&attributes, map.keys[1].usage);
 c04ab98:	a808      	add	r0, sp, #32
    attributes->core.lifetime = lifetime;
 c04ab9a:	9309      	str	r3, [sp, #36]	@ 0x24
    if( PSA_KEY_LIFETIME_IS_VOLATILE( lifetime ) )
 c04ab9c:	f013 03ff 	ands.w	r3, r3, #255	@ 0xff
        attributes->core.id.key_id = 0;
 c04aba0:	bf08      	it	eq
 c04aba2:	930a      	streq	r3, [sp, #40]	@ 0x28
          psa_set_key_bits(&attributes, map.keys[1].bits);
 c04aba4:	f8dd 307a 	ldr.w	r3, [sp, #122]	@ 0x7a
    if( bits > PSA_MAX_KEY_BITS )
 c04aba8:	428b      	cmp	r3, r1
 c04abaa:	bf88      	it	hi
 c04abac:	4613      	movhi	r3, r2
          psa_set_key_usage_flags(&attributes, map.keys[1].usage);
 c04abae:	f8dd 1076 	ldr.w	r1, [sp, #118]	@ 0x76
 c04abb2:	f8ad 3022 	strh.w	r3, [sp, #34]	@ 0x22
 c04abb6:	f7ff fb3a 	bl	c04a22e <psa_set_key_usage_flags>
          psa_set_key_type(&attributes, map.keys[1].type);
 c04abba:	f8bd 107e 	ldrh.w	r1, [sp, #126]	@ 0x7e
 c04abbe:	f7ff fb7f 	bl	c04a2c0 <psa_set_key_type>
          psa_status = register_key_in_all_domain(mbedtls_id, &attributes);
 c04abc2:	e896 0003 	ldmia.w	r6, {r0, r1}
          psa_set_key_algorithm(&attributes, map.keys[1].alg);
 c04abc6:	f8dd 3072 	ldr.w	r3, [sp, #114]	@ 0x72
          psa_status = register_key_in_all_domain(mbedtls_id, &attributes);
 c04abca:	aa08      	add	r2, sp, #32
    attributes->core.policy.alg = alg;
 c04abcc:	930d      	str	r3, [sp, #52]	@ 0x34
 c04abce:	f7ff fb83 	bl	c04a2d8 <register_key_in_all_domain>
          if (psa_status != PSA_SUCCESS) {
 c04abd2:	4604      	mov	r4, r0
 c04abd4:	2800      	cmp	r0, #0
 c04abd6:	d1c4      	bne.n	c04ab62 <register_se_keys+0x15e>
    psa_status = psa_close_key(key_handle);
 c04abd8:	e895 0003 	ldmia.w	r5, {r0, r1}
 c04abdc:	f7fe faa7 	bl	c04912e <mbedcrypto__psa_close_key>
    if ((psa_status = register_se_private_keys()) != PSA_SUCCESS)
 c04abe0:	4604      	mov	r4, r0
 c04abe2:	2800      	cmp	r0, #0
 c04abe4:	f43f af4f 	beq.w	c04aa86 <register_se_keys+0x82>
}
 c04abe8:	4620      	mov	r0, r4
 c04abea:	b02f      	add	sp, #188	@ 0xbc
 c04abec:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
              mbedtls_id.key_id = regions[i].id;
 c04abf0:	f8d9 3008 	ldr.w	r3, [r9, #8]
 c04abf4:	e9cd 7810 	strd	r7, r8, [sp, #64]	@ 0x40
 c04abf8:	9304      	str	r3, [sp, #16]
    attributes->core.flags |= MBEDTLS_PSA_KA_FLAG_HAS_SLOT_NUMBER;
 c04abfa:	f8bd 303c 	ldrh.w	r3, [sp, #60]	@ 0x3c
              psa_set_key_usage_flags(&attributes, PSA_KEY_USAGE_EXPORT);
 c04abfe:	a808      	add	r0, sp, #32
 c04ac00:	f043 0301 	orr.w	r3, r3, #1
 c04ac04:	f8ad 303c 	strh.w	r3, [sp, #60]	@ 0x3c
              psa_set_key_lifetime(&attributes, regions[i].lifetime);
 c04ac08:	f8d9 3004 	ldr.w	r3, [r9, #4]
              psa_set_key_usage_flags(&attributes, PSA_KEY_USAGE_EXPORT);
 c04ac0c:	2101      	movs	r1, #1
    attributes->core.lifetime = lifetime;
 c04ac0e:	9309      	str	r3, [sp, #36]	@ 0x24
    if( PSA_KEY_LIFETIME_IS_VOLATILE( lifetime ) )
 c04ac10:	f013 03ff 	ands.w	r3, r3, #255	@ 0xff
        attributes->core.id.key_id = 0;
 c04ac14:	bf08      	it	eq
 c04ac16:	930a      	streq	r3, [sp, #40]	@ 0x28
              psa_set_key_bits(&attributes, regions[i].bits);
 c04ac18:	f859 3b0c 	ldr.w	r3, [r9], #12
    if( bits > PSA_MAX_KEY_BITS )
 c04ac1c:	4553      	cmp	r3, sl
 c04ac1e:	bf88      	it	hi
 c04ac20:	465b      	movhi	r3, fp
 c04ac22:	f8ad 3022 	strh.w	r3, [sp, #34]	@ 0x22
              psa_set_key_usage_flags(&attributes, PSA_KEY_USAGE_EXPORT);
 c04ac26:	f7ff fb02 	bl	c04a22e <psa_set_key_usage_flags>
              psa_set_key_type(&attributes, PSA_KEY_TYPE_RAW_DATA);
 c04ac2a:	f241 0101 	movw	r1, #4097	@ 0x1001
 c04ac2e:	f7ff fb47 	bl	c04a2c0 <psa_set_key_type>
              psa_status = register_key_in_all_domain(mbedtls_id, &attributes);
 c04ac32:	e896 0003 	ldmia.w	r6, {r0, r1}
 c04ac36:	aa08      	add	r2, sp, #32
 c04ac38:	f7ff fb4e 	bl	c04a2d8 <register_key_in_all_domain>
              if (psa_status != PSA_SUCCESS) {
 c04ac3c:	3701      	adds	r7, #1
 c04ac3e:	4604      	mov	r4, r0
 c04ac40:	f148 0800 	adc.w	r8, r8, #0
 c04ac44:	2800      	cmp	r0, #0
 c04ac46:	f43f af4f 	beq.w	c04aae8 <register_se_keys+0xe4>
 c04ac4a:	e78a      	b.n	c04ab62 <register_se_keys+0x15e>
 c04ac4c:	40000003 	.word	0x40000003
 c04ac50:	40000005 	.word	0x40000005
 c04ac54:	40000004 	.word	0x40000004

0c04ac58 <tfm_spm_client_psa_framework_version>:
extern struct stateless_service_tracking_t stateless_service_ref[];

uint32_t tfm_spm_client_psa_framework_version(void)
{
    return PSA_FRAMEWORK_VERSION;
}
 c04ac58:	f240 1001 	movw	r0, #257	@ 0x101
 c04ac5c:	4770      	bx	lr

0c04ac5e <tfm_spm_client_psa_version>:

uint32_t tfm_spm_client_psa_version(uint32_t sid, bool ns_caller)
{
 c04ac5e:	b570      	push	{r4, r5, r6, lr}
 c04ac60:	4605      	mov	r5, r0
 c04ac62:	460e      	mov	r6, r1

    /*
     * It should return PSA_VERSION_NONE if the RoT Service is not
     * implemented.
     */
    service = tfm_spm_get_service_by_sid(sid);
 c04ac64:	f011 fd42 	bl	c05c6ec <tfm_spm_get_service_by_sid>
    if (!service) {
 c04ac68:	4604      	mov	r4, r0
 c04ac6a:	b908      	cbnz	r0, c04ac70 <tfm_spm_client_psa_version+0x12>
        return PSA_VERSION_NONE;
 c04ac6c:	2000      	movs	r0, #0
    if (tfm_spm_check_authorization(sid, service, ns_caller) != SPM_SUCCESS) {
        return PSA_VERSION_NONE;
    }

    return service->service_db->version;
}
 c04ac6e:	bd70      	pop	{r4, r5, r6, pc}
    if (tfm_spm_check_authorization(sid, service, ns_caller) != SPM_SUCCESS) {
 c04ac70:	4601      	mov	r1, r0
 c04ac72:	4632      	mov	r2, r6
 c04ac74:	4628      	mov	r0, r5
 c04ac76:	f011 fd69 	bl	c05c74c <tfm_spm_check_authorization>
 c04ac7a:	2800      	cmp	r0, #0
 c04ac7c:	d1f6      	bne.n	c04ac6c <tfm_spm_client_psa_version+0xe>
    return service->service_db->version;
 c04ac7e:	6823      	ldr	r3, [r4, #0]
 c04ac80:	6958      	ldr	r0, [r3, #20]
 c04ac82:	e7f4      	b.n	c04ac6e <tfm_spm_client_psa_version+0x10>

0c04ac84 <tfm_spm_client_psa_connect>:

psa_status_t tfm_spm_client_psa_connect(uint32_t sid, uint32_t version,
                                        bool ns_caller)
{
 c04ac84:	b5f0      	push	{r4, r5, r6, r7, lr}
 c04ac86:	b087      	sub	sp, #28
 c04ac88:	4607      	mov	r7, r0
 c04ac8a:	460e      	mov	r6, r1
 c04ac8c:	4614      	mov	r4, r2

    /*
     * It is a PROGRAMMER ERROR if the RoT Service does not exist on the
     * platform.
     */
    service = tfm_spm_get_service_by_sid(sid);
 c04ac8e:	f011 fd2d 	bl	c05c6ec <tfm_spm_get_service_by_sid>
    if (!service) {
 c04ac92:	4605      	mov	r5, r0
 c04ac94:	b930      	cbnz	r0, c04aca4 <tfm_spm_client_psa_connect+0x20>
        TFM_PROGRAMMER_ERROR(ns_caller, PSA_ERROR_CONNECTION_REFUSED);
 c04ac96:	b11c      	cbz	r4, c04aca0 <tfm_spm_client_psa_connect+0x1c>
 c04ac98:	f06f 0081 	mvn.w	r0, #129	@ 0x81
     * and scheduler triggered
     */
    tfm_spm_send_event(service, msg);

    return PSA_SUCCESS;
}
 c04ac9c:	b007      	add	sp, #28
 c04ac9e:	bdf0      	pop	{r4, r5, r6, r7, pc}
        TFM_PROGRAMMER_ERROR(ns_caller, PSA_ERROR_CONNECTION_REFUSED);
 c04aca0:	f013 fd22 	bl	c05e6e8 <tfm_core_panic>
    if (tfm_spm_check_authorization(sid, service, ns_caller) != SPM_SUCCESS) {
 c04aca4:	4622      	mov	r2, r4
 c04aca6:	4629      	mov	r1, r5
 c04aca8:	4638      	mov	r0, r7
 c04acaa:	f011 fd4f 	bl	c05c74c <tfm_spm_check_authorization>
 c04acae:	b118      	cbz	r0, c04acb8 <tfm_spm_client_psa_connect+0x34>
        TFM_PROGRAMMER_ERROR(ns_caller, PSA_ERROR_CONNECTION_REFUSED);
 c04acb0:	2c00      	cmp	r4, #0
 c04acb2:	d1f1      	bne.n	c04ac98 <tfm_spm_client_psa_connect+0x14>
 c04acb4:	f013 fd18 	bl	c05e6e8 <tfm_core_panic>
    if (tfm_spm_check_client_version(service, version) != SPM_SUCCESS) {
 c04acb8:	4631      	mov	r1, r6
 c04acba:	4628      	mov	r0, r5
 c04acbc:	f011 fd30 	bl	c05c720 <tfm_spm_check_client_version>
 c04acc0:	b118      	cbz	r0, c04acca <tfm_spm_client_psa_connect+0x46>
        TFM_PROGRAMMER_ERROR(ns_caller, PSA_ERROR_CONNECTION_REFUSED);
 c04acc2:	2c00      	cmp	r4, #0
 c04acc4:	d1e8      	bne.n	c04ac98 <tfm_spm_client_psa_connect+0x14>
 c04acc6:	f013 fd0f 	bl	c05e6e8 <tfm_core_panic>
    if (!service->service_db->connection_based) {
 c04acca:	682b      	ldr	r3, [r5, #0]
 c04accc:	7c5b      	ldrb	r3, [r3, #17]
 c04acce:	b92b      	cbnz	r3, c04acdc <tfm_spm_client_psa_connect+0x58>
        TFM_PROGRAMMER_ERROR(ns_caller, PSA_ERROR_PROGRAMMER_ERROR);
 c04acd0:	bb74      	cbnz	r4, c04ad30 <tfm_spm_client_psa_connect+0xac>
 c04acd2:	f013 fd09 	bl	c05e6e8 <tfm_core_panic>
        client_id = tfm_spm_partition_get_running_partition_id();
 c04acd6:	f011 fdda 	bl	c05c88e <tfm_spm_partition_get_running_partition_id>
 c04acda:	e003      	b.n	c04ace4 <tfm_spm_client_psa_connect+0x60>
    if (ns_caller) {
 c04acdc:	2c00      	cmp	r4, #0
 c04acde:	d0fa      	beq.n	c04acd6 <tfm_spm_client_psa_connect+0x52>
        client_id = tfm_nspm_get_current_client_id();
 c04ace0:	f013 fb80 	bl	c05e3e4 <tfm_nspm_get_current_client_id>
    connect_handle = tfm_spm_create_conn_handle(service, client_id);
 c04ace4:	4601      	mov	r1, r0
        client_id = tfm_spm_partition_get_running_partition_id();
 c04ace6:	4606      	mov	r6, r0
    connect_handle = tfm_spm_create_conn_handle(service, client_id);
 c04ace8:	4628      	mov	r0, r5
 c04acea:	f011 fc9d 	bl	c05c628 <tfm_spm_create_conn_handle>
    if (!connect_handle) {
 c04acee:	4604      	mov	r4, r0
 c04acf0:	b910      	cbnz	r0, c04acf8 <tfm_spm_client_psa_connect+0x74>
        return PSA_ERROR_CONNECTION_BUSY;
 c04acf2:	f06f 0082 	mvn.w	r0, #130	@ 0x82
 c04acf6:	e7d1      	b.n	c04ac9c <tfm_spm_client_psa_connect+0x18>
    msg = tfm_spm_get_msg_buffer_from_conn_handle(connect_handle);
 c04acf8:	f011 fd48 	bl	c05c78c <tfm_spm_get_msg_buffer_from_conn_handle>
    if (!msg) {
 c04acfc:	4607      	mov	r7, r0
 c04acfe:	2800      	cmp	r0, #0
 c04ad00:	d0f7      	beq.n	c04acf2 <tfm_spm_client_psa_connect+0x6e>
    handle = tfm_spm_to_user_handle(connect_handle);
 c04ad02:	4620      	mov	r0, r4
 c04ad04:	f011 fc78 	bl	c05c5f8 <tfm_spm_to_user_handle>
    tfm_spm_fill_msg(msg, service, handle, PSA_IPC_CONNECT,
 c04ad08:	2400      	movs	r4, #0
    handle = tfm_spm_to_user_handle(connect_handle);
 c04ad0a:	4602      	mov	r2, r0
    tfm_spm_fill_msg(msg, service, handle, PSA_IPC_CONNECT,
 c04ad0c:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 c04ad10:	4629      	mov	r1, r5
 c04ad12:	4638      	mov	r0, r7
 c04ad14:	e9cd 4404 	strd	r4, r4, [sp, #16]
 c04ad18:	e9cd 4402 	strd	r4, r4, [sp, #8]
 c04ad1c:	e9cd 6400 	strd	r6, r4, [sp]
 c04ad20:	f011 fd36 	bl	c05c790 <tfm_spm_fill_msg>
    tfm_spm_send_event(service, msg);
 c04ad24:	4628      	mov	r0, r5
 c04ad26:	4639      	mov	r1, r7
 c04ad28:	f011 fd82 	bl	c05c830 <tfm_spm_send_event>
    return PSA_SUCCESS;
 c04ad2c:	4620      	mov	r0, r4
 c04ad2e:	e7b5      	b.n	c04ac9c <tfm_spm_client_psa_connect+0x18>
        TFM_PROGRAMMER_ERROR(ns_caller, PSA_ERROR_PROGRAMMER_ERROR);
 c04ad30:	f06f 0080 	mvn.w	r0, #128	@ 0x80
 c04ad34:	e7b2      	b.n	c04ac9c <tfm_spm_client_psa_connect+0x18>
	...

0c04ad38 <tfm_spm_client_psa_call>:

psa_status_t tfm_spm_client_psa_call(psa_handle_t handle, int32_t type,
                                     const psa_invec *inptr, size_t in_num,
                                     psa_outvec *outptr, size_t out_num,
                                     bool ns_caller, uint32_t privileged)
{
 c04ad38:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    int i, j;
    int32_t client_id;
    uint32_t sid, version, index;

    /* It is a PROGRAMMER ERROR if in_len + out_len > PSA_MAX_IOVEC. */
    if ((in_num > PSA_MAX_IOVEC) ||
 c04ad3c:	2b04      	cmp	r3, #4
{
 c04ad3e:	b09b      	sub	sp, #108	@ 0x6c
 c04ad40:	4606      	mov	r6, r0
 c04ad42:	4691      	mov	r9, r2
 c04ad44:	461f      	mov	r7, r3
 c04ad46:	f89d 4098 	ldrb.w	r4, [sp, #152]	@ 0x98
 c04ad4a:	9108      	str	r1, [sp, #32]
    if ((in_num > PSA_MAX_IOVEC) ||
 c04ad4c:	d805      	bhi.n	c04ad5a <tfm_spm_client_psa_call+0x22>
 c04ad4e:	9b25      	ldr	r3, [sp, #148]	@ 0x94
 c04ad50:	2b04      	cmp	r3, #4
 c04ad52:	d802      	bhi.n	c04ad5a <tfm_spm_client_psa_call+0x22>
        (out_num > PSA_MAX_IOVEC) ||
        (in_num + out_num > PSA_MAX_IOVEC)) {
 c04ad54:	18fb      	adds	r3, r7, r3
        (out_num > PSA_MAX_IOVEC) ||
 c04ad56:	2b04      	cmp	r3, #4
 c04ad58:	d90a      	bls.n	c04ad70 <tfm_spm_client_psa_call+0x38>
        TFM_PROGRAMMER_ERROR(ns_caller, PSA_ERROR_PROGRAMMER_ERROR);
 c04ad5a:	b124      	cbz	r4, c04ad66 <tfm_spm_client_psa_call+0x2e>
 c04ad5c:	f06f 0080 	mvn.w	r0, #128	@ 0x80
     * and scheduler triggered
     */
    tfm_spm_send_event(service, msg);

    return PSA_SUCCESS;
}
 c04ad60:	b01b      	add	sp, #108	@ 0x6c
 c04ad62:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        TFM_PROGRAMMER_ERROR(ns_caller, PSA_ERROR_PROGRAMMER_ERROR);
 c04ad66:	f013 fcbf 	bl	c05e6e8 <tfm_core_panic>
        client_id = tfm_spm_partition_get_running_partition_id();
 c04ad6a:	f011 fd90 	bl	c05c88e <tfm_spm_partition_get_running_partition_id>
 c04ad6e:	e003      	b.n	c04ad78 <tfm_spm_client_psa_call+0x40>
    if (ns_caller) {
 c04ad70:	2c00      	cmp	r4, #0
 c04ad72:	d0fa      	beq.n	c04ad6a <tfm_spm_client_psa_call+0x32>
        client_id = tfm_nspm_get_current_client_id();
 c04ad74:	f013 fb36 	bl	c05e3e4 <tfm_nspm_get_current_client_id>
    if (IS_VALID_STATIC_HANDLE(handle)) {
 c04ad78:	0073      	lsls	r3, r6, #1
        client_id = tfm_spm_partition_get_running_partition_id();
 c04ad7a:	9007      	str	r0, [sp, #28]
    if (IS_VALID_STATIC_HANDLE(handle)) {
 c04ad7c:	f140 809e 	bpl.w	c04aebc <tfm_spm_client_psa_call+0x184>
 c04ad80:	b2f3      	uxtb	r3, r6
 c04ad82:	3b01      	subs	r3, #1
 c04ad84:	2b1f      	cmp	r3, #31
 c04ad86:	f200 8099 	bhi.w	c04aebc <tfm_spm_client_psa_call+0x184>
        service = GET_STATELESS_SERVICE(index);
 c04ad8a:	4880      	ldr	r0, [pc, #512]	@ (c04af8c <tfm_spm_client_psa_call+0x254>)
 c04ad8c:	eb00 02c3 	add.w	r2, r0, r3, lsl #3
 c04ad90:	f8d2 8004 	ldr.w	r8, [r2, #4]
        if (tfm_spm_check_authorization(sid, service, ns_caller)
 c04ad94:	f850 0033 	ldr.w	r0, [r0, r3, lsl #3]
 c04ad98:	4622      	mov	r2, r4
 c04ad9a:	4641      	mov	r1, r8
 c04ad9c:	f011 fcd6 	bl	c05c74c <tfm_spm_check_authorization>
 c04ada0:	b120      	cbz	r0, c04adac <tfm_spm_client_psa_call+0x74>
            TFM_PROGRAMMER_ERROR(ns_caller, PSA_ERROR_CONNECTION_REFUSED);
 c04ada2:	2c00      	cmp	r4, #0
 c04ada4:	f040 80ec 	bne.w	c04af80 <tfm_spm_client_psa_call+0x248>
 c04ada8:	f013 fc9e 	bl	c05e6e8 <tfm_core_panic>
        if (tfm_spm_check_client_version(service, version) != SPM_SUCCESS) {
 c04adac:	4640      	mov	r0, r8
 c04adae:	f3c6 2107 	ubfx	r1, r6, #8, #8
 c04adb2:	f011 fcb5 	bl	c05c720 <tfm_spm_check_client_version>
 c04adb6:	b118      	cbz	r0, c04adc0 <tfm_spm_client_psa_call+0x88>
            TFM_PROGRAMMER_ERROR(ns_caller, PSA_ERROR_PROGRAMMER_ERROR);
 c04adb8:	2c00      	cmp	r4, #0
 c04adba:	d1cf      	bne.n	c04ad5c <tfm_spm_client_psa_call+0x24>
 c04adbc:	f013 fc94 	bl	c05e6e8 <tfm_core_panic>
        conn_handle = tfm_spm_create_conn_handle(service, client_id);
 c04adc0:	4640      	mov	r0, r8
 c04adc2:	9907      	ldr	r1, [sp, #28]
 c04adc4:	f011 fc30 	bl	c05c628 <tfm_spm_create_conn_handle>
        if (!conn_handle) {
 c04adc8:	4605      	mov	r5, r0
 c04adca:	b920      	cbnz	r0, c04add6 <tfm_spm_client_psa_call+0x9e>
            TFM_PROGRAMMER_ERROR(ns_caller, PSA_ERROR_CONNECTION_BUSY);
 c04adcc:	2c00      	cmp	r4, #0
 c04adce:	f040 80da 	bne.w	c04af86 <tfm_spm_client_psa_call+0x24e>
 c04add2:	f013 fc89 	bl	c05e6e8 <tfm_core_panic>
        conn_handle->rhandle = NULL;
 c04add6:	2300      	movs	r3, #0
        handle = tfm_spm_to_user_handle(conn_handle);
 c04add8:	4628      	mov	r0, r5
        conn_handle->rhandle = NULL;
 c04adda:	602b      	str	r3, [r5, #0]
        handle = tfm_spm_to_user_handle(conn_handle);
 c04addc:	f011 fc0c 	bl	c05c5f8 <tfm_spm_to_user_handle>
 c04ade0:	4606      	mov	r6, r0
    if (!service) {
 c04ade2:	f1b8 0f00 	cmp.w	r8, #0
 c04ade6:	d101      	bne.n	c04adec <tfm_spm_client_psa_call+0xb4>
        tfm_core_panic();
 c04ade8:	f013 fc7e 	bl	c05e6e8 <tfm_core_panic>
    if (tfm_memory_check(inptr, in_num * sizeof(psa_invec), ns_caller,
 c04adec:	9b27      	ldr	r3, [sp, #156]	@ 0x9c
 c04adee:	ea4f 0bc7 	mov.w	fp, r7, lsl #3
 c04adf2:	9300      	str	r3, [sp, #0]
 c04adf4:	4622      	mov	r2, r4
 c04adf6:	2301      	movs	r3, #1
 c04adf8:	4659      	mov	r1, fp
 c04adfa:	4648      	mov	r0, r9
 c04adfc:	f011 fd70 	bl	c05c8e0 <tfm_memory_check>
 c04ae00:	b118      	cbz	r0, c04ae0a <tfm_spm_client_psa_call+0xd2>
        TFM_PROGRAMMER_ERROR(ns_caller, PSA_ERROR_PROGRAMMER_ERROR);
 c04ae02:	2c00      	cmp	r4, #0
 c04ae04:	d1aa      	bne.n	c04ad5c <tfm_spm_client_psa_call+0x24>
 c04ae06:	f013 fc6f 	bl	c05e6e8 <tfm_core_panic>
    if (tfm_memory_check(outptr, out_num * sizeof(psa_outvec), ns_caller,
 c04ae0a:	9b25      	ldr	r3, [sp, #148]	@ 0x94
 c04ae0c:	4622      	mov	r2, r4
 c04ae0e:	ea4f 0ac3 	mov.w	sl, r3, lsl #3
 c04ae12:	9b27      	ldr	r3, [sp, #156]	@ 0x9c
 c04ae14:	4651      	mov	r1, sl
 c04ae16:	9300      	str	r3, [sp, #0]
 c04ae18:	9824      	ldr	r0, [sp, #144]	@ 0x90
 c04ae1a:	2302      	movs	r3, #2
 c04ae1c:	f011 fd60 	bl	c05c8e0 <tfm_memory_check>
 c04ae20:	b118      	cbz	r0, c04ae2a <tfm_spm_client_psa_call+0xf2>
        TFM_PROGRAMMER_ERROR(ns_caller, PSA_ERROR_PROGRAMMER_ERROR);
 c04ae22:	2c00      	cmp	r4, #0
 c04ae24:	d19a      	bne.n	c04ad5c <tfm_spm_client_psa_call+0x24>
 c04ae26:	f013 fc5f 	bl	c05e6e8 <tfm_core_panic>
    spm_memset(invecs, 0, sizeof(invecs));
 c04ae2a:	2220      	movs	r2, #32
 c04ae2c:	2100      	movs	r1, #0
 c04ae2e:	a80a      	add	r0, sp, #40	@ 0x28
 c04ae30:	f012 fe19 	bl	c05da66 <spm_memset>
    spm_memset(outvecs, 0, sizeof(outvecs));
 c04ae34:	2220      	movs	r2, #32
 c04ae36:	2100      	movs	r1, #0
 c04ae38:	a812      	add	r0, sp, #72	@ 0x48
 c04ae3a:	f012 fe14 	bl	c05da66 <spm_memset>
    spm_memcpy(invecs, inptr, in_num * sizeof(psa_invec));
 c04ae3e:	465a      	mov	r2, fp
 c04ae40:	4649      	mov	r1, r9
 c04ae42:	a80a      	add	r0, sp, #40	@ 0x28
 c04ae44:	f012 fdde 	bl	c05da04 <spm_memcpy>
    spm_memcpy(outvecs, outptr, out_num * sizeof(psa_outvec));
 c04ae48:	f10d 0928 	add.w	r9, sp, #40	@ 0x28
 c04ae4c:	4652      	mov	r2, sl
 c04ae4e:	9924      	ldr	r1, [sp, #144]	@ 0x90
 c04ae50:	a812      	add	r0, sp, #72	@ 0x48
 c04ae52:	f012 fdd7 	bl	c05da04 <spm_memcpy>
    for (i = 0; i < in_num; i++) {
 c04ae56:	46ca      	mov	sl, r9
 c04ae58:	f04f 0b00 	mov.w	fp, #0
 c04ae5c:	45bb      	cmp	fp, r7
 c04ae5e:	d149      	bne.n	c04aef4 <tfm_spm_client_psa_call+0x1bc>
    for (i = 0; i + 1 < in_num; i++) {
 c04ae60:	f04f 0a00 	mov.w	sl, #0
 c04ae64:	f10a 0a01 	add.w	sl, sl, #1
 c04ae68:	4557      	cmp	r7, sl
 c04ae6a:	d873      	bhi.n	c04af54 <tfm_spm_client_psa_call+0x21c>
    for (i = 0; i < out_num; i++) {
 c04ae6c:	f04f 0a00 	mov.w	sl, #0
 c04ae70:	f10d 0948 	add.w	r9, sp, #72	@ 0x48
 c04ae74:	9b25      	ldr	r3, [sp, #148]	@ 0x94
 c04ae76:	459a      	cmp	sl, r3
 c04ae78:	d16f      	bne.n	c04af5a <tfm_spm_client_psa_call+0x222>
    msg = tfm_spm_get_msg_buffer_from_conn_handle(conn_handle);
 c04ae7a:	4628      	mov	r0, r5
 c04ae7c:	f011 fc86 	bl	c05c78c <tfm_spm_get_msg_buffer_from_conn_handle>
    if (!msg) {
 c04ae80:	4605      	mov	r5, r0
 c04ae82:	b920      	cbnz	r0, c04ae8e <tfm_spm_client_psa_call+0x156>
        TFM_PROGRAMMER_ERROR(ns_caller, PSA_ERROR_PROGRAMMER_ERROR);
 c04ae84:	2c00      	cmp	r4, #0
 c04ae86:	f47f af69 	bne.w	c04ad5c <tfm_spm_client_psa_call+0x24>
 c04ae8a:	f013 fc2d 	bl	c05e6e8 <tfm_core_panic>
    tfm_spm_fill_msg(msg, service, handle, type, client_id,
 c04ae8e:	9b24      	ldr	r3, [sp, #144]	@ 0x90
 c04ae90:	4632      	mov	r2, r6
 c04ae92:	9305      	str	r3, [sp, #20]
 c04ae94:	9b25      	ldr	r3, [sp, #148]	@ 0x94
 c04ae96:	4641      	mov	r1, r8
 c04ae98:	9304      	str	r3, [sp, #16]
 c04ae9a:	ab12      	add	r3, sp, #72	@ 0x48
 c04ae9c:	e9cd 7302 	strd	r7, r3, [sp, #8]
 c04aea0:	ab0a      	add	r3, sp, #40	@ 0x28
 c04aea2:	9301      	str	r3, [sp, #4]
 c04aea4:	9b07      	ldr	r3, [sp, #28]
 c04aea6:	4628      	mov	r0, r5
 c04aea8:	9300      	str	r3, [sp, #0]
 c04aeaa:	9b08      	ldr	r3, [sp, #32]
 c04aeac:	f011 fc70 	bl	c05c790 <tfm_spm_fill_msg>
    tfm_spm_send_event(service, msg);
 c04aeb0:	4640      	mov	r0, r8
 c04aeb2:	4629      	mov	r1, r5
 c04aeb4:	f011 fcbc 	bl	c05c830 <tfm_spm_send_event>
    return PSA_SUCCESS;
 c04aeb8:	2000      	movs	r0, #0
 c04aeba:	e751      	b.n	c04ad60 <tfm_spm_client_psa_call+0x28>
        conn_handle = tfm_spm_to_handle_instance(handle);
 c04aebc:	4630      	mov	r0, r6
 c04aebe:	f011 fbab 	bl	c05c618 <tfm_spm_to_handle_instance>
        if (tfm_spm_validate_conn_handle(conn_handle, client_id)
 c04aec2:	9907      	ldr	r1, [sp, #28]
        conn_handle = tfm_spm_to_handle_instance(handle);
 c04aec4:	4605      	mov	r5, r0
        if (tfm_spm_validate_conn_handle(conn_handle, client_id)
 c04aec6:	f011 fbc9 	bl	c05c65c <tfm_spm_validate_conn_handle>
 c04aeca:	b120      	cbz	r0, c04aed6 <tfm_spm_client_psa_call+0x19e>
            TFM_PROGRAMMER_ERROR(ns_caller, PSA_ERROR_PROGRAMMER_ERROR);
 c04aecc:	2c00      	cmp	r4, #0
 c04aece:	f47f af45 	bne.w	c04ad5c <tfm_spm_client_psa_call+0x24>
 c04aed2:	f013 fc09 	bl	c05e6e8 <tfm_core_panic>
        if (conn_handle->status == TFM_HANDLE_STATUS_ACTIVE) {
 c04aed6:	686b      	ldr	r3, [r5, #4]
 c04aed8:	2b01      	cmp	r3, #1
 c04aeda:	d104      	bne.n	c04aee6 <tfm_spm_client_psa_call+0x1ae>
            TFM_PROGRAMMER_ERROR(ns_caller, PSA_ERROR_PROGRAMMER_ERROR);
 c04aedc:	2c00      	cmp	r4, #0
 c04aede:	f47f af3d 	bne.w	c04ad5c <tfm_spm_client_psa_call+0x24>
 c04aee2:	f013 fc01 	bl	c05e6e8 <tfm_core_panic>
        if (conn_handle->status == TFM_HANDLE_STATUS_CONNECT_ERROR) {
 c04aee6:	686b      	ldr	r3, [r5, #4]
 c04aee8:	2b02      	cmp	r3, #2
 c04aeea:	f43f af37 	beq.w	c04ad5c <tfm_spm_client_psa_call+0x24>
        service = conn_handle->service;
 c04aeee:	f8d5 8098 	ldr.w	r8, [r5, #152]	@ 0x98
 c04aef2:	e776      	b.n	c04ade2 <tfm_spm_client_psa_call+0xaa>
        if (tfm_memory_check(invecs[i].base, invecs[i].len, ns_caller,
 c04aef4:	9b27      	ldr	r3, [sp, #156]	@ 0x9c
 c04aef6:	4622      	mov	r2, r4
 c04aef8:	9300      	str	r3, [sp, #0]
 c04aefa:	e9da 0100 	ldrd	r0, r1, [sl]
 c04aefe:	2301      	movs	r3, #1
 c04af00:	f011 fcee 	bl	c05c8e0 <tfm_memory_check>
 c04af04:	b120      	cbz	r0, c04af10 <tfm_spm_client_psa_call+0x1d8>
            TFM_PROGRAMMER_ERROR(ns_caller, PSA_ERROR_PROGRAMMER_ERROR);
 c04af06:	2c00      	cmp	r4, #0
 c04af08:	f47f af28 	bne.w	c04ad5c <tfm_spm_client_psa_call+0x24>
 c04af0c:	f013 fbec 	bl	c05e6e8 <tfm_core_panic>
    for (i = 0; i < in_num; i++) {
 c04af10:	f10b 0b01 	add.w	fp, fp, #1
 c04af14:	f10a 0a08 	add.w	sl, sl, #8
 c04af18:	e7a0      	b.n	c04ae5c <tfm_spm_client_psa_call+0x124>
            if (!((char *) invecs[j].base + invecs[j].len <=
 c04af1a:	f8db 0008 	ldr.w	r0, [fp, #8]
 c04af1e:	f8db 200c 	ldr.w	r2, [fp, #12]
                  (char *) invecs[i].base ||
 c04af22:	f8d9 1000 	ldr.w	r1, [r9]
            if (!((char *) invecs[j].base + invecs[j].len <=
 c04af26:	4402      	add	r2, r0
 c04af28:	4291      	cmp	r1, r2
 c04af2a:	d20b      	bcs.n	c04af44 <tfm_spm_client_psa_call+0x20c>
                  (char *) invecs[i].base + invecs[i].len)) {
 c04af2c:	f8d9 2004 	ldr.w	r2, [r9, #4]
 c04af30:	4411      	add	r1, r2
            if (!((char *) invecs[j].base + invecs[j].len <=
 c04af32:	4288      	cmp	r0, r1
 c04af34:	d206      	bcs.n	c04af44 <tfm_spm_client_psa_call+0x20c>
 c04af36:	9309      	str	r3, [sp, #36]	@ 0x24
                TFM_PROGRAMMER_ERROR(ns_caller, PSA_ERROR_PROGRAMMER_ERROR);
 c04af38:	2c00      	cmp	r4, #0
 c04af3a:	f47f af0f 	bne.w	c04ad5c <tfm_spm_client_psa_call+0x24>
 c04af3e:	f013 fbd3 	bl	c05e6e8 <tfm_core_panic>
 c04af42:	9b09      	ldr	r3, [sp, #36]	@ 0x24
        for (j = i+1; j < in_num; j++) {
 c04af44:	3301      	adds	r3, #1
 c04af46:	f10b 0b08 	add.w	fp, fp, #8
 c04af4a:	42bb      	cmp	r3, r7
 c04af4c:	d1e5      	bne.n	c04af1a <tfm_spm_client_psa_call+0x1e2>
 c04af4e:	f109 0908 	add.w	r9, r9, #8
 c04af52:	e787      	b.n	c04ae64 <tfm_spm_client_psa_call+0x12c>
 c04af54:	46cb      	mov	fp, r9
 c04af56:	4653      	mov	r3, sl
 c04af58:	e7f7      	b.n	c04af4a <tfm_spm_client_psa_call+0x212>
        if (tfm_memory_check(outvecs[i].base, outvecs[i].len,
 c04af5a:	9b27      	ldr	r3, [sp, #156]	@ 0x9c
 c04af5c:	4622      	mov	r2, r4
 c04af5e:	9300      	str	r3, [sp, #0]
 c04af60:	e9d9 0100 	ldrd	r0, r1, [r9]
 c04af64:	2302      	movs	r3, #2
 c04af66:	f011 fcbb 	bl	c05c8e0 <tfm_memory_check>
 c04af6a:	b120      	cbz	r0, c04af76 <tfm_spm_client_psa_call+0x23e>
            TFM_PROGRAMMER_ERROR(ns_caller, PSA_ERROR_PROGRAMMER_ERROR);
 c04af6c:	2c00      	cmp	r4, #0
 c04af6e:	f47f aef5 	bne.w	c04ad5c <tfm_spm_client_psa_call+0x24>
 c04af72:	f013 fbb9 	bl	c05e6e8 <tfm_core_panic>
    for (i = 0; i < out_num; i++) {
 c04af76:	f10a 0a01 	add.w	sl, sl, #1
 c04af7a:	f109 0908 	add.w	r9, r9, #8
 c04af7e:	e779      	b.n	c04ae74 <tfm_spm_client_psa_call+0x13c>
            TFM_PROGRAMMER_ERROR(ns_caller, PSA_ERROR_CONNECTION_REFUSED);
 c04af80:	f06f 0081 	mvn.w	r0, #129	@ 0x81
 c04af84:	e6ec      	b.n	c04ad60 <tfm_spm_client_psa_call+0x28>
            TFM_PROGRAMMER_ERROR(ns_caller, PSA_ERROR_CONNECTION_BUSY);
 c04af86:	f06f 0082 	mvn.w	r0, #130	@ 0x82
 c04af8a:	e6e9      	b.n	c04ad60 <tfm_spm_client_psa_call+0x28>
 c04af8c:	30030998 	.word	0x30030998

0c04af90 <tfm_spm_client_psa_close>:

void tfm_spm_client_psa_close(psa_handle_t handle, bool ns_caller)
{
 c04af90:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 c04af94:	460e      	mov	r6, r1
    struct tfm_msg_body_t *msg;
    struct tfm_conn_handle_t *conn_handle;
    int32_t client_id;

    /* It will have no effect if called with the NULL handle */
    if (handle == PSA_NULL_HANDLE) {
 c04af96:	4604      	mov	r4, r0
{
 c04af98:	b087      	sub	sp, #28
    if (handle == PSA_NULL_HANDLE) {
 c04af9a:	2800      	cmp	r0, #0
 c04af9c:	d046      	beq.n	c04b02c <tfm_spm_client_psa_close+0x9c>
        return;
    }

    /* It is a PROGRAMMER ERROR if called with a stateless handle. */
    if (IS_VALID_STATIC_HANDLE(handle)) {
 c04af9e:	0043      	lsls	r3, r0, #1
 c04afa0:	d50a      	bpl.n	c04afb8 <tfm_spm_client_psa_close+0x28>
 c04afa2:	b2c3      	uxtb	r3, r0
 c04afa4:	3b01      	subs	r3, #1
 c04afa6:	2b1f      	cmp	r3, #31
 c04afa8:	d806      	bhi.n	c04afb8 <tfm_spm_client_psa_close+0x28>
        TFM_PROGRAMMER_ERROR(ns_caller, PROGRAMMER_ERROR_NULL);
 c04afaa:	2900      	cmp	r1, #0
 c04afac:	d13e      	bne.n	c04b02c <tfm_spm_client_psa_close+0x9c>
 c04afae:	f013 fb9b 	bl	c05e6e8 <tfm_core_panic>
    }

    if (ns_caller) {
        client_id = tfm_nspm_get_current_client_id();
    } else {
        client_id = tfm_spm_partition_get_running_partition_id();
 c04afb2:	f011 fc6c 	bl	c05c88e <tfm_spm_partition_get_running_partition_id>
 c04afb6:	e003      	b.n	c04afc0 <tfm_spm_client_psa_close+0x30>
    if (ns_caller) {
 c04afb8:	2e00      	cmp	r6, #0
 c04afba:	d0fa      	beq.n	c04afb2 <tfm_spm_client_psa_close+0x22>
        client_id = tfm_nspm_get_current_client_id();
 c04afbc:	f013 fa12 	bl	c05e3e4 <tfm_nspm_get_current_client_id>
        client_id = tfm_spm_partition_get_running_partition_id();
 c04afc0:	4605      	mov	r5, r0
    }

    conn_handle = tfm_spm_to_handle_instance(handle);
 c04afc2:	4620      	mov	r0, r4
 c04afc4:	f011 fb28 	bl	c05c618 <tfm_spm_to_handle_instance>
    /*
     * It is a PROGRAMMER ERROR if an invalid handle was provided that is not
     * the null handle.
     */
    if (tfm_spm_validate_conn_handle(conn_handle, client_id) != SPM_SUCCESS) {
 c04afc8:	4629      	mov	r1, r5
    conn_handle = tfm_spm_to_handle_instance(handle);
 c04afca:	4680      	mov	r8, r0
    if (tfm_spm_validate_conn_handle(conn_handle, client_id) != SPM_SUCCESS) {
 c04afcc:	f011 fb46 	bl	c05c65c <tfm_spm_validate_conn_handle>
 c04afd0:	b110      	cbz	r0, c04afd8 <tfm_spm_client_psa_close+0x48>
        TFM_PROGRAMMER_ERROR(ns_caller, PROGRAMMER_ERROR_NULL);
 c04afd2:	bb5e      	cbnz	r6, c04b02c <tfm_spm_client_psa_close+0x9c>
 c04afd4:	f013 fb88 	bl	c05e6e8 <tfm_core_panic>
    }

    service = conn_handle->service;
 c04afd8:	f8d8 9098 	ldr.w	r9, [r8, #152]	@ 0x98
    if (!service) {
 c04afdc:	f1b9 0f00 	cmp.w	r9, #0
 c04afe0:	d101      	bne.n	c04afe6 <tfm_spm_client_psa_close+0x56>
        /* FixMe: Need to implement one mechanism to resolve this failure. */
        tfm_core_panic();
 c04afe2:	f013 fb81 	bl	c05e6e8 <tfm_core_panic>
    }

    msg = tfm_spm_get_msg_buffer_from_conn_handle(conn_handle);
 c04afe6:	4640      	mov	r0, r8
 c04afe8:	f011 fbd0 	bl	c05c78c <tfm_spm_get_msg_buffer_from_conn_handle>
    if (!msg) {
 c04afec:	4607      	mov	r7, r0
 c04afee:	b908      	cbnz	r0, c04aff4 <tfm_spm_client_psa_close+0x64>
        /* FixMe: Need to implement one mechanism to resolve this failure. */
        tfm_core_panic();
 c04aff0:	f013 fb7a 	bl	c05e6e8 <tfm_core_panic>

    /*
     * It is a PROGRAMMER ERROR if the connection is currently handling a
     * request.
     */
    if (conn_handle->status == TFM_HANDLE_STATUS_ACTIVE) {
 c04aff4:	f8d8 3004 	ldr.w	r3, [r8, #4]
 c04aff8:	2b01      	cmp	r3, #1
 c04affa:	d102      	bne.n	c04b002 <tfm_spm_client_psa_close+0x72>
        TFM_PROGRAMMER_ERROR(ns_caller, PROGRAMMER_ERROR_NULL);
 c04affc:	b9b6      	cbnz	r6, c04b02c <tfm_spm_client_psa_close+0x9c>
 c04affe:	f013 fb73 	bl	c05e6e8 <tfm_core_panic>
    }

    /* No input or output needed for close message */
    tfm_spm_fill_msg(msg, service, handle, PSA_IPC_DISCONNECT, client_id,
 c04b002:	2300      	movs	r3, #0
 c04b004:	4649      	mov	r1, r9
 c04b006:	4638      	mov	r0, r7
 c04b008:	e9cd 3304 	strd	r3, r3, [sp, #16]
 c04b00c:	e9cd 3302 	strd	r3, r3, [sp, #8]
 c04b010:	e9cd 5300 	strd	r5, r3, [sp]
 c04b014:	4622      	mov	r2, r4
 c04b016:	f06f 0301 	mvn.w	r3, #1
 c04b01a:	f011 fbb9 	bl	c05c790 <tfm_spm_fill_msg>

    /*
     * Send message and wake up the SP who is waiting on message queue,
     * and scheduler triggered
     */
    tfm_spm_send_event(service, msg);
 c04b01e:	4639      	mov	r1, r7
 c04b020:	4648      	mov	r0, r9
}
 c04b022:	b007      	add	sp, #28
 c04b024:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
    tfm_spm_send_event(service, msg);
 c04b028:	f011 bc02 	b.w	c05c830 <tfm_spm_send_event>
}
 c04b02c:	b007      	add	sp, #28
 c04b02e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

0c04b032 <psa_status_to_t_cose_error_signing>:
 * \return The \ref t_cose_err_t.
 */
static enum t_cose_err_t psa_status_to_t_cose_error_signing(psa_status_t err)
{
    /* Intentionally keeping to fewer mapped errors to save object code */
    return err == PSA_SUCCESS                   ? T_COSE_SUCCESS :
 c04b032:	f110 0f8d 	cmn.w	r0, #141	@ 0x8d
 c04b036:	d013      	beq.n	c04b060 <psa_status_to_t_cose_error_signing+0x2e>
 c04b038:	f110 0f8c 	cmn.w	r0, #140	@ 0x8c
 c04b03c:	da09      	bge.n	c04b052 <psa_status_to_t_cose_error_signing+0x20>
 c04b03e:	f110 0f97 	cmn.w	r0, #151	@ 0x97
 c04b042:	d00f      	beq.n	c04b064 <psa_status_to_t_cose_error_signing+0x32>
 c04b044:	f110 0f95 	cmn.w	r0, #149	@ 0x95
 c04b048:	bf08      	it	eq
 c04b04a:	200d      	moveq	r0, #13
 c04b04c:	bf18      	it	ne
 c04b04e:	2017      	movne	r0, #23
 c04b050:	4770      	bx	lr
 c04b052:	f110 0f86 	cmn.w	r0, #134	@ 0x86
 c04b056:	d007      	beq.n	c04b068 <psa_status_to_t_cose_error_signing+0x36>
 c04b058:	2800      	cmp	r0, #0
 c04b05a:	bf08      	it	eq
 c04b05c:	2000      	moveq	r0, #0
 c04b05e:	e7f5      	b.n	c04b04c <psa_status_to_t_cose_error_signing+0x1a>
{
 c04b060:	2010      	movs	r0, #16
 c04b062:	4770      	bx	lr
    return err == PSA_SUCCESS                   ? T_COSE_SUCCESS :
 c04b064:	2012      	movs	r0, #18
 c04b066:	4770      	bx	lr
{
 c04b068:	2001      	movs	r0, #1
           err == PSA_ERROR_INVALID_SIGNATURE   ? T_COSE_ERR_SIG_VERIFY :
           err == PSA_ERROR_NOT_SUPPORTED       ? T_COSE_ERR_UNSUPPORTED_SIGNING_ALG:
           err == PSA_ERROR_INSUFFICIENT_MEMORY ? T_COSE_ERR_INSUFFICIENT_MEMORY :
           err == PSA_ERROR_TAMPERING_DETECTED  ? T_COSE_ERR_TAMPERING_DETECTED :
                                                  T_COSE_ERR_SIG_FAIL;
}
 c04b06a:	4770      	bx	lr

0c04b06c <t_cose_crypto_pub_key_sign>:
t_cose_crypto_pub_key_sign(int32_t                cose_algorithm_id,
                           struct t_cose_key      signing_key,
                           struct q_useful_buf_c  hash_to_sign,
                           struct q_useful_buf    signature_buffer,
                           struct q_useful_buf_c *signature)
{
 c04b06c:	b082      	sub	sp, #8
 c04b06e:	b530      	push	{r4, r5, lr}
 c04b070:	b087      	sub	sp, #28
 c04b072:	a90a      	add	r1, sp, #40	@ 0x28
 c04b074:	f110 0f23 	cmn.w	r0, #35	@ 0x23
 c04b078:	e881 000c 	stmia.w	r1, {r2, r3}
 c04b07c:	9c12      	ldr	r4, [sp, #72]	@ 0x48
 c04b07e:	d020      	beq.n	c04b0c2 <t_cose_crypto_pub_key_sign+0x56>
 c04b080:	1dc3      	adds	r3, r0, #7
 c04b082:	d020      	beq.n	c04b0c6 <t_cose_crypto_pub_key_sign+0x5a>
    return cose_alg_id == COSE_ALGORITHM_ES256 ? PSA_ALG_ECDSA(PSA_ALG_SHA_256) :
 c04b084:	3024      	adds	r0, #36	@ 0x24
 c04b086:	4912      	ldr	r1, [pc, #72]	@ (c04b0d0 <t_cose_crypto_pub_key_sign+0x64>)
 c04b088:	bf18      	it	ne
 c04b08a:	2100      	movne	r1, #0
     * looks for ECDSA signing as indicated by COSE and rejects what
     * is not. (Perhaps this check can be removed to save object code
     * if it is the case that psa_asymmetric_verify() does the right
     * checks).
     */
    if(!PSA_ALG_IS_ECDSA(psa_alg_id)) {
 c04b08c:	f001 2306 	and.w	r3, r1, #100664832	@ 0x6000600
 c04b090:	f1b3 2f06 	cmp.w	r3, #100664832	@ 0x6000600
 c04b094:	d119      	bne.n	c04b0ca <t_cose_crypto_pub_key_sign+0x5e>
    signing_key_psa = (psa_key_handle_t)signing_key.k.key_handle;

    /* It is assumed that this call is checking the signature_buffer
     * length and won't write off the end of it.
     */
    psa_result = psa_sign_hash(signing_key_psa,
 c04b096:	ab05      	add	r3, sp, #20
 c04b098:	9d10      	ldr	r5, [sp, #64]	@ 0x40
 c04b09a:	9302      	str	r3, [sp, #8]
 c04b09c:	9b11      	ldr	r3, [sp, #68]	@ 0x44
 c04b09e:	980c      	ldr	r0, [sp, #48]	@ 0x30
 c04b0a0:	e9cd 5300 	strd	r5, r3, [sp]
 c04b0a4:	e9dd 230e 	ldrd	r2, r3, [sp, #56]	@ 0x38
 c04b0a8:	f7f1 f9df 	bl	c03c46a <psa_sign_hash>
                               hash_to_sign.len,
                               signature_buffer.ptr, /* Sig buf */
                               signature_buffer.len, /* Sig buf size */
                               &signature_len);      /* Sig length */

    return_value = psa_status_to_t_cose_error_signing(psa_result);
 c04b0ac:	f7ff ffc1 	bl	c04b032 <psa_status_to_t_cose_error_signing>

    if(return_value == T_COSE_SUCCESS) {
 c04b0b0:	b910      	cbnz	r0, c04b0b8 <t_cose_crypto_pub_key_sign+0x4c>
        /* Success, fill in the return useful_buf */
        signature->ptr = signature_buffer.ptr;
        signature->len = signature_len;
 c04b0b2:	9b05      	ldr	r3, [sp, #20]
        signature->ptr = signature_buffer.ptr;
 c04b0b4:	6025      	str	r5, [r4, #0]
        signature->len = signature_len;
 c04b0b6:	6063      	str	r3, [r4, #4]
    }

  Done:
     return return_value;
}
 c04b0b8:	b007      	add	sp, #28
 c04b0ba:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
 c04b0be:	b002      	add	sp, #8
 c04b0c0:	4770      	bx	lr
    return cose_alg_id == COSE_ALGORITHM_ES256 ? PSA_ALG_ECDSA(PSA_ALG_SHA_256) :
 c04b0c2:	4904      	ldr	r1, [pc, #16]	@ (c04b0d4 <t_cose_crypto_pub_key_sign+0x68>)
 c04b0c4:	e7e2      	b.n	c04b08c <t_cose_crypto_pub_key_sign+0x20>
 c04b0c6:	4904      	ldr	r1, [pc, #16]	@ (c04b0d8 <t_cose_crypto_pub_key_sign+0x6c>)
 c04b0c8:	e7e0      	b.n	c04b08c <t_cose_crypto_pub_key_sign+0x20>
        return_value = T_COSE_ERR_UNSUPPORTED_SIGNING_ALG;
 c04b0ca:	2001      	movs	r0, #1
 c04b0cc:	e7f4      	b.n	c04b0b8 <t_cose_crypto_pub_key_sign+0x4c>
 c04b0ce:	bf00      	nop
 c04b0d0:	0600060b 	.word	0x0600060b
 c04b0d4:	0600060a 	.word	0x0600060a
 c04b0d8:	06000609 	.word	0x06000609

0c04b0dc <t_cose_crypto_sig_size>:
 * See documentation in t_cose_crypto.h
 */
enum t_cose_err_t t_cose_crypto_sig_size(int32_t           cose_algorithm_id,
                                         struct t_cose_key signing_key,
                                         size_t           *sig_size)
{
 c04b0dc:	b082      	sub	sp, #8
 c04b0de:	b510      	push	{r4, lr}
 c04b0e0:	b086      	sub	sp, #24
 c04b0e2:	a908      	add	r1, sp, #32
 c04b0e4:	e881 000c 	stmia.w	r1, {r2, r3}
 c04b0e8:	4a11      	ldr	r2, [pc, #68]	@ (c04b130 <t_cose_crypto_sig_size+0x54>)
 * new .c file just for this.
 */
static inline bool
t_cose_check_list(int32_t cose_algorithm_id, const int32_t *list)
{
    while(*list) {
 c04b0ea:	f852 3b04 	ldr.w	r3, [r2], #4
 c04b0ee:	b92b      	cbnz	r3, c04b0fc <t_cose_crypto_sig_size+0x20>
     * (except the tests that test for exact values will fail). This
     * will save 100 bytes or so of obejct code.
     */

    if(!t_cose_algorithm_is_ecdsa(cose_algorithm_id)) {
        return T_COSE_ERR_UNSUPPORTED_SIGNING_ALG;
 c04b0f0:	2001      	movs	r0, #1
        /* Double because signature is made of up r and s values */
        *sig_size = key_len_bytes * 2;
    }

    return return_value;
}
 c04b0f2:	b006      	add	sp, #24
 c04b0f4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 c04b0f8:	b002      	add	sp, #8
 c04b0fa:	4770      	bx	lr
        if(*list == cose_algorithm_id) {
 c04b0fc:	4298      	cmp	r0, r3
 c04b0fe:	d1f4      	bne.n	c04b0ea <t_cose_crypto_sig_size+0xe>
    signing_key_psa = (psa_key_handle_t)signing_key.k.key_handle;
 c04b100:	9c0a      	ldr	r4, [sp, #40]	@ 0x28
    return( v );
 c04b102:	2100      	movs	r1, #0
 c04b104:	2218      	movs	r2, #24
 c04b106:	4668      	mov	r0, sp
 c04b108:	f010 fb11 	bl	c05b72e <memset>
    psa_status_t status = psa_get_key_attributes(signing_key_psa, &key_attributes);
 c04b10c:	4669      	mov	r1, sp
 c04b10e:	4620      	mov	r0, r4
 c04b110:	f7f0 fff0 	bl	c03c0f4 <psa_get_key_attributes>
    return_value = psa_status_to_t_cose_error_signing(status);
 c04b114:	f7ff ff8d 	bl	c04b032 <psa_status_to_t_cose_error_signing>
    if(return_value == T_COSE_SUCCESS) {
 c04b118:	2800      	cmp	r0, #0
 c04b11a:	d1ea      	bne.n	c04b0f2 <t_cose_crypto_sig_size+0x16>
}

static inline size_t psa_get_key_bits(
    const psa_key_attributes_t *attributes)
{
    return( attributes->bits );
 c04b11c:	9a04      	ldr	r2, [sp, #16]
        key_len_bytes = key_len_bits / 8;
 c04b11e:	08d3      	lsrs	r3, r2, #3
        if(key_len_bits % 8) {
 c04b120:	0752      	lsls	r2, r2, #29
            key_len_bytes++;
 c04b122:	bf18      	it	ne
 c04b124:	3301      	addne	r3, #1
        *sig_size = key_len_bytes * 2;
 c04b126:	9a0c      	ldr	r2, [sp, #48]	@ 0x30
 c04b128:	005b      	lsls	r3, r3, #1
 c04b12a:	6013      	str	r3, [r2, #0]
 c04b12c:	e7e1      	b.n	c04b0f2 <t_cose_crypto_sig_size+0x16>
 c04b12e:	bf00      	nop
 c04b130:	0c061f24 	.word	0x0c061f24

0c04b134 <t_cose_crypto_hash_start>:
 *
 */
static inline psa_algorithm_t
cose_hash_alg_id_to_psa(int32_t cose_hash_alg_id)
{
    return cose_hash_alg_id == COSE_ALGORITHM_SHA_256 ? PSA_ALG_SHA_256 :
 c04b134:	f111 0f2b 	cmn.w	r1, #43	@ 0x2b
/*
 * See documentation in t_cose_crypto.h
 */
enum t_cose_err_t t_cose_crypto_hash_start(struct t_cose_crypto_hash *hash_ctx,
                                           int32_t cose_hash_alg_id)
{
 c04b138:	b510      	push	{r4, lr}
 c04b13a:	460b      	mov	r3, r1
 c04b13c:	4604      	mov	r4, r0
 c04b13e:	d019      	beq.n	c04b174 <t_cose_crypto_hash_start+0x40>
 c04b140:	f111 0f10 	cmn.w	r1, #16
 c04b144:	d018      	beq.n	c04b178 <t_cose_crypto_hash_start+0x44>
    return cose_hash_alg_id == COSE_ALGORITHM_SHA_256 ? PSA_ALG_SHA_256 :
 c04b146:	f64f 71ff 	movw	r1, #65535	@ 0xffff
 c04b14a:	4a0d      	ldr	r2, [pc, #52]	@ (c04b180 <t_cose_crypto_hash_start+0x4c>)
 c04b14c:	f113 0f2c 	cmn.w	r3, #44	@ 0x2c
 c04b150:	bf08      	it	eq
 c04b152:	4611      	moveq	r1, r2

    /* Map the algorithm ID */
    psa_alg = cose_hash_alg_id_to_psa(cose_hash_alg_id);

    /* initialize PSA hash context */
    hash_ctx->ctx = psa_hash_operation_init();
 c04b154:	2300      	movs	r3, #0

    /* Actually do the hash set up */
    hash_ctx->status = psa_hash_setup(&(hash_ctx->ctx), psa_alg);
 c04b156:	4620      	mov	r0, r4
    hash_ctx->ctx = psa_hash_operation_init();
 c04b158:	6023      	str	r3, [r4, #0]
    hash_ctx->status = psa_hash_setup(&(hash_ctx->ctx), psa_alg);
 c04b15a:	f7f1 f850 	bl	c03c1fe <psa_hash_setup>
 c04b15e:	6060      	str	r0, [r4, #4]
    return status == PSA_SUCCESS                ? T_COSE_SUCCESS :
 c04b160:	b138      	cbz	r0, c04b172 <t_cose_crypto_hash_start+0x3e>
 c04b162:	f110 0f86 	cmn.w	r0, #134	@ 0x86
 c04b166:	d009      	beq.n	c04b17c <t_cose_crypto_hash_start+0x48>
 c04b168:	f110 0f8a 	cmn.w	r0, #138	@ 0x8a
 c04b16c:	bf14      	ite	ne
 c04b16e:	2004      	movne	r0, #4
 c04b170:	2005      	moveq	r0, #5

    /* Map errors and return */
    return psa_status_to_t_cose_error_hash((psa_status_t)hash_ctx->status);
}
 c04b172:	bd10      	pop	{r4, pc}
    return cose_hash_alg_id == COSE_ALGORITHM_SHA_256 ? PSA_ALG_SHA_256 :
 c04b174:	4903      	ldr	r1, [pc, #12]	@ (c04b184 <t_cose_crypto_hash_start+0x50>)
 c04b176:	e7ed      	b.n	c04b154 <t_cose_crypto_hash_start+0x20>
 c04b178:	4903      	ldr	r1, [pc, #12]	@ (c04b188 <t_cose_crypto_hash_start+0x54>)
 c04b17a:	e7eb      	b.n	c04b154 <t_cose_crypto_hash_start+0x20>
    return status == PSA_SUCCESS                ? T_COSE_SUCCESS :
 c04b17c:	2003      	movs	r0, #3
 c04b17e:	e7f8      	b.n	c04b172 <t_cose_crypto_hash_start+0x3e>
 c04b180:	0200000b 	.word	0x0200000b
 c04b184:	0200000a 	.word	0x0200000a
 c04b188:	02000009 	.word	0x02000009

0c04b18c <t_cose_crypto_hash_update>:
/*
 * See documentation in t_cose_crypto.h
 */
void t_cose_crypto_hash_update(struct t_cose_crypto_hash *hash_ctx,
                               struct q_useful_buf_c      data_to_hash)
{
 c04b18c:	b513      	push	{r0, r1, r4, lr}
 c04b18e:	ab02      	add	r3, sp, #8
 c04b190:	e903 0006 	stmdb	r3, {r1, r2}
    if(hash_ctx->status != PSA_SUCCESS) {
 c04b194:	6843      	ldr	r3, [r0, #4]
{
 c04b196:	4604      	mov	r4, r0
    if(hash_ctx->status != PSA_SUCCESS) {
 c04b198:	b91b      	cbnz	r3, c04b1a2 <t_cose_crypto_hash_update+0x16>
        /* In error state. Nothing to do. */
        return;
    }

    if(data_to_hash.ptr == NULL) {
 c04b19a:	b111      	cbz	r1, c04b1a2 <t_cose_crypto_hash_update+0x16>
         */
        return;
    }

    /* Actually hash the data */
    hash_ctx->status = psa_hash_update(&(hash_ctx->ctx),
 c04b19c:	f7f1 f85c 	bl	c03c258 <psa_hash_update>
 c04b1a0:	6060      	str	r0, [r4, #4]
                                       data_to_hash.ptr,
                                       data_to_hash.len);
}
 c04b1a2:	b002      	add	sp, #8
 c04b1a4:	bd10      	pop	{r4, pc}

0c04b1a6 <t_cose_crypto_hash_finish>:
 */
enum t_cose_err_t
t_cose_crypto_hash_finish(struct t_cose_crypto_hash *hash_ctx,
                          struct q_useful_buf        buffer_to_hold_result,
                          struct q_useful_buf_c     *hash_result)
{
 c04b1a6:	b573      	push	{r0, r1, r4, r5, r6, lr}
 c04b1a8:	ad02      	add	r5, sp, #8
 c04b1aa:	e905 0006 	stmdb	r5, {r1, r2}
 c04b1ae:	461d      	mov	r5, r3
    if(hash_ctx->status != PSA_SUCCESS) {
 c04b1b0:	6843      	ldr	r3, [r0, #4]
{
 c04b1b2:	4604      	mov	r4, r0
    if(hash_ctx->status != PSA_SUCCESS) {
 c04b1b4:	b92b      	cbnz	r3, c04b1c2 <t_cose_crypto_hash_finish+0x1c>
        /* Error state. Nothing to do */
        goto Done;
    }

    /* Actually finish up the hash */
    hash_ctx->status = psa_hash_finish(&(hash_ctx->ctx),
 c04b1b6:	1d2b      	adds	r3, r5, #4
 c04b1b8:	460e      	mov	r6, r1
 c04b1ba:	f7f1 f87e 	bl	c03c2ba <psa_hash_finish>
 c04b1be:	6060      	str	r0, [r4, #4]
                                         buffer_to_hold_result.ptr,
                                         buffer_to_hold_result.len,
                                       &(hash_result->len));

    hash_result->ptr = buffer_to_hold_result.ptr;
 c04b1c0:	602e      	str	r6, [r5, #0]

Done:
    return psa_status_to_t_cose_error_hash(hash_ctx->status);
 c04b1c2:	6860      	ldr	r0, [r4, #4]
    return status == PSA_SUCCESS                ? T_COSE_SUCCESS :
 c04b1c4:	b138      	cbz	r0, c04b1d6 <t_cose_crypto_hash_finish+0x30>
 c04b1c6:	f110 0f86 	cmn.w	r0, #134	@ 0x86
 c04b1ca:	d006      	beq.n	c04b1da <t_cose_crypto_hash_finish+0x34>
 c04b1cc:	f110 0f8a 	cmn.w	r0, #138	@ 0x8a
 c04b1d0:	bf14      	ite	ne
 c04b1d2:	2004      	movne	r0, #4
 c04b1d4:	2005      	moveq	r0, #5
}
 c04b1d6:	b002      	add	sp, #8
 c04b1d8:	bd70      	pop	{r4, r5, r6, pc}
    return status == PSA_SUCCESS                ? T_COSE_SUCCESS :
 c04b1da:	2003      	movs	r0, #3
 c04b1dc:	e7fb      	b.n	c04b1d6 <t_cose_crypto_hash_finish+0x30>

0c04b1de <tfm_hal_ps_fs_info>:
#endif

__WEAK enum tfm_hal_status_t
tfm_hal_ps_fs_info(struct tfm_hal_ps_fs_info_t *fs_info)
{
    if (!fs_info) {
 c04b1de:	b148      	cbz	r0, c04b1f4 <tfm_hal_ps_fs_info+0x16>
        return TFM_HAL_ERROR_INVALID_INPUT;
    }

    fs_info->flash_area_addr = TFM_HAL_PS_FLASH_AREA_ADDR;
    fs_info->flash_area_size = TFM_HAL_PS_FLASH_AREA_SIZE;
 c04b1e0:	f44f 3238 	mov.w	r2, #188416	@ 0x2e000
 c04b1e4:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
 c04b1e8:	e9c0 2300 	strd	r2, r3, [r0]
    fs_info->sectors_per_block = TFM_HAL_PS_SECTORS_PER_BLOCK;
 c04b1ec:	2301      	movs	r3, #1
 c04b1ee:	7203      	strb	r3, [r0, #8]

    return TFM_HAL_SUCCESS;
 c04b1f0:	2000      	movs	r0, #0
 c04b1f2:	4770      	bx	lr
        return TFM_HAL_ERROR_INVALID_INPUT;
 c04b1f4:	f24c 20da 	movw	r0, #49882	@ 0xc2da
}
 c04b1f8:	4770      	bx	lr
	...

0c04b1fc <tfm_ps_get_support_ipc>:

    return tfm_ps_remove(msg.client_id, uid);
}

static psa_status_t tfm_ps_get_support_ipc(void)
{
 c04b1fc:	b537      	push	{r0, r1, r2, r4, r5, lr}
    size_t out_size;
    uint32_t support_flags;

    out_size = msg.out_size[0];
 c04b1fe:	4c09      	ldr	r4, [pc, #36]	@ (c04b224 <tfm_ps_get_support_ipc+0x28>)
    if (out_size != sizeof(support_flags)) {
 c04b200:	6a25      	ldr	r5, [r4, #32]
 c04b202:	2d04      	cmp	r5, #4
 c04b204:	d10b      	bne.n	c04b21e <tfm_ps_get_support_ipc+0x22>
        /* The output argument size is incorrect */
        return PSA_ERROR_PROGRAMMER_ERROR;
    }

    support_flags = tfm_ps_get_support();
 c04b206:	f000 f975 	bl	c04b4f4 <tfm_ps_get_support>
    psa_write(msg.handle, 0, &support_flags, out_size);
 c04b20a:	462b      	mov	r3, r5
    support_flags = tfm_ps_get_support();
 c04b20c:	9001      	str	r0, [sp, #4]
    psa_write(msg.handle, 0, &support_flags, out_size);
 c04b20e:	2100      	movs	r1, #0
 c04b210:	6860      	ldr	r0, [r4, #4]
 c04b212:	aa01      	add	r2, sp, #4
 c04b214:	f7f1 fafe 	bl	c03c814 <psa_write>
    return PSA_SUCCESS;
 c04b218:	2000      	movs	r0, #0
}
 c04b21a:	b003      	add	sp, #12
 c04b21c:	bd30      	pop	{r4, r5, pc}
        return PSA_ERROR_PROGRAMMER_ERROR;
 c04b21e:	f06f 0080 	mvn.w	r0, #128	@ 0x80
 c04b222:	e7fa      	b.n	c04b21a <tfm_ps_get_support_ipc+0x1e>
 c04b224:	30040408 	.word	0x30040408

0c04b228 <tfm_ps_remove_ipc>:
{
 c04b228:	b513      	push	{r0, r1, r4, lr}
    if (msg.in_size[0] != sizeof(psa_storage_uid_t)) {
 c04b22a:	4c0b      	ldr	r4, [pc, #44]	@ (c04b258 <tfm_ps_remove_ipc+0x30>)
 c04b22c:	6923      	ldr	r3, [r4, #16]
 c04b22e:	2b08      	cmp	r3, #8
 c04b230:	d003      	beq.n	c04b23a <tfm_ps_remove_ipc+0x12>
        return PSA_ERROR_PROGRAMMER_ERROR;
 c04b232:	f06f 0080 	mvn.w	r0, #128	@ 0x80
}
 c04b236:	b002      	add	sp, #8
 c04b238:	bd10      	pop	{r4, pc}
    num = psa_read(msg.handle, 0, &uid, msg.in_size[0]);
 c04b23a:	466a      	mov	r2, sp
 c04b23c:	2100      	movs	r1, #0
 c04b23e:	6860      	ldr	r0, [r4, #4]
 c04b240:	f7f1 fae6 	bl	c03c810 <psa_read>
    if (num != msg.in_size[0]) {
 c04b244:	6923      	ldr	r3, [r4, #16]
 c04b246:	4283      	cmp	r3, r0
 c04b248:	d1f3      	bne.n	c04b232 <tfm_ps_remove_ipc+0xa>
    return tfm_ps_remove(msg.client_id, uid);
 c04b24a:	e9dd 2300 	ldrd	r2, r3, [sp]
 c04b24e:	68a0      	ldr	r0, [r4, #8]
 c04b250:	f000 f93d 	bl	c04b4ce <tfm_ps_remove>
 c04b254:	e7ef      	b.n	c04b236 <tfm_ps_remove_ipc+0xe>
 c04b256:	bf00      	nop
 c04b258:	30040408 	.word	0x30040408

0c04b25c <tfm_ps_get_info_ipc>:
{
 c04b25c:	b570      	push	{r4, r5, r6, lr}
    if (msg.in_size[0] != sizeof(psa_storage_uid_t) ||
 c04b25e:	4c13      	ldr	r4, [pc, #76]	@ (c04b2ac <tfm_ps_get_info_ipc+0x50>)
{
 c04b260:	b088      	sub	sp, #32
    if (msg.in_size[0] != sizeof(psa_storage_uid_t) ||
 c04b262:	6923      	ldr	r3, [r4, #16]
 c04b264:	2b08      	cmp	r3, #8
 c04b266:	d004      	beq.n	c04b272 <tfm_ps_get_info_ipc+0x16>
        return PSA_ERROR_PROGRAMMER_ERROR;
 c04b268:	f06f 0580 	mvn.w	r5, #128	@ 0x80
}
 c04b26c:	4628      	mov	r0, r5
 c04b26e:	b008      	add	sp, #32
 c04b270:	bd70      	pop	{r4, r5, r6, pc}
    if (msg.in_size[0] != sizeof(psa_storage_uid_t) ||
 c04b272:	6a22      	ldr	r2, [r4, #32]
 c04b274:	2a0c      	cmp	r2, #12
 c04b276:	d1f7      	bne.n	c04b268 <tfm_ps_get_info_ipc+0xc>
    num = psa_read(msg.handle, 0, &uid, msg.in_size[0]);
 c04b278:	2100      	movs	r1, #0
 c04b27a:	6860      	ldr	r0, [r4, #4]
 c04b27c:	aa02      	add	r2, sp, #8
 c04b27e:	f7f1 fac7 	bl	c03c810 <psa_read>
    if (num != msg.in_size[0]) {
 c04b282:	6923      	ldr	r3, [r4, #16]
 c04b284:	4283      	cmp	r3, r0
 c04b286:	d1ef      	bne.n	c04b268 <tfm_ps_get_info_ipc+0xc>
    status = tfm_ps_get_info(msg.client_id, uid, &info);
 c04b288:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 c04b28c:	ae05      	add	r6, sp, #20
 c04b28e:	9600      	str	r6, [sp, #0]
 c04b290:	68a0      	ldr	r0, [r4, #8]
 c04b292:	f000 f90c 	bl	c04b4ae <tfm_ps_get_info>
    if (status == PSA_SUCCESS) {
 c04b296:	4605      	mov	r5, r0
 c04b298:	2800      	cmp	r0, #0
 c04b29a:	d1e7      	bne.n	c04b26c <tfm_ps_get_info_ipc+0x10>
        psa_write(msg.handle, 0, &info, msg.out_size[0]);
 c04b29c:	4601      	mov	r1, r0
 c04b29e:	4632      	mov	r2, r6
 c04b2a0:	6a23      	ldr	r3, [r4, #32]
 c04b2a2:	6860      	ldr	r0, [r4, #4]
 c04b2a4:	f7f1 fab6 	bl	c03c814 <psa_write>
 c04b2a8:	e7e0      	b.n	c04b26c <tfm_ps_get_info_ipc+0x10>
 c04b2aa:	bf00      	nop
 c04b2ac:	30040408 	.word	0x30040408

0c04b2b0 <tfm_ps_get_ipc>:
{
 c04b2b0:	b510      	push	{r4, lr}
    if (msg.in_size[0] != sizeof(psa_storage_uid_t) ||
 c04b2b2:	4c14      	ldr	r4, [pc, #80]	@ (c04b304 <tfm_ps_get_ipc+0x54>)
{
 c04b2b4:	b088      	sub	sp, #32
    if (msg.in_size[0] != sizeof(psa_storage_uid_t) ||
 c04b2b6:	6923      	ldr	r3, [r4, #16]
 c04b2b8:	2b08      	cmp	r3, #8
 c04b2ba:	d003      	beq.n	c04b2c4 <tfm_ps_get_ipc+0x14>
        return PSA_ERROR_PROGRAMMER_ERROR;
 c04b2bc:	f06f 0080 	mvn.w	r0, #128	@ 0x80
}
 c04b2c0:	b008      	add	sp, #32
 c04b2c2:	bd10      	pop	{r4, pc}
    if (msg.in_size[0] != sizeof(psa_storage_uid_t) ||
 c04b2c4:	6962      	ldr	r2, [r4, #20]
 c04b2c6:	2a04      	cmp	r2, #4
 c04b2c8:	d1f8      	bne.n	c04b2bc <tfm_ps_get_ipc+0xc>
    num = psa_read(msg.handle, 0, &uid,  msg.in_size[0]);
 c04b2ca:	2100      	movs	r1, #0
 c04b2cc:	6860      	ldr	r0, [r4, #4]
 c04b2ce:	aa06      	add	r2, sp, #24
 c04b2d0:	f7f1 fa9e 	bl	c03c810 <psa_read>
    if (num != msg.in_size[0]) {
 c04b2d4:	6923      	ldr	r3, [r4, #16]
 c04b2d6:	4283      	cmp	r3, r0
 c04b2d8:	d1f0      	bne.n	c04b2bc <tfm_ps_get_ipc+0xc>
    num = psa_read(msg.handle, 1, &data_offset, msg.in_size[1]);
 c04b2da:	6963      	ldr	r3, [r4, #20]
 c04b2dc:	2101      	movs	r1, #1
 c04b2de:	6860      	ldr	r0, [r4, #4]
 c04b2e0:	aa04      	add	r2, sp, #16
 c04b2e2:	f7f1 fa95 	bl	c03c810 <psa_read>
    if (num !=  msg.in_size[1]) {
 c04b2e6:	6963      	ldr	r3, [r4, #20]
 c04b2e8:	4283      	cmp	r3, r0
 c04b2ea:	d1e7      	bne.n	c04b2bc <tfm_ps_get_ipc+0xc>
    return tfm_ps_get(msg.client_id, uid, data_offset,  msg.out_size[0],
 c04b2ec:	ab05      	add	r3, sp, #20
 c04b2ee:	9302      	str	r3, [sp, #8]
 c04b2f0:	6a23      	ldr	r3, [r4, #32]
 c04b2f2:	9301      	str	r3, [sp, #4]
 c04b2f4:	9b04      	ldr	r3, [sp, #16]
 c04b2f6:	9300      	str	r3, [sp, #0]
 c04b2f8:	68a0      	ldr	r0, [r4, #8]
 c04b2fa:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
 c04b2fe:	f000 f8c2 	bl	c04b486 <tfm_ps_get>
 c04b302:	e7dd      	b.n	c04b2c0 <tfm_ps_get_ipc+0x10>
 c04b304:	30040408 	.word	0x30040408

0c04b308 <tfm_ps_set_ipc>:
{
 c04b308:	b530      	push	{r4, r5, lr}
    client_id = msg.client_id;
 c04b30a:	4c14      	ldr	r4, [pc, #80]	@ (c04b35c <tfm_ps_set_ipc+0x54>)
{
 c04b30c:	b087      	sub	sp, #28
    if (msg.in_size[0] != sizeof(psa_storage_uid_t) ||
 c04b30e:	6923      	ldr	r3, [r4, #16]
    client_id = msg.client_id;
 c04b310:	68a5      	ldr	r5, [r4, #8]
    if (msg.in_size[0] != sizeof(psa_storage_uid_t) ||
 c04b312:	2b08      	cmp	r3, #8
 c04b314:	d003      	beq.n	c04b31e <tfm_ps_set_ipc+0x16>
        return PSA_ERROR_PROGRAMMER_ERROR;
 c04b316:	f06f 0080 	mvn.w	r0, #128	@ 0x80
}
 c04b31a:	b007      	add	sp, #28
 c04b31c:	bd30      	pop	{r4, r5, pc}
    if (msg.in_size[0] != sizeof(psa_storage_uid_t) ||
 c04b31e:	69a2      	ldr	r2, [r4, #24]
 c04b320:	2a04      	cmp	r2, #4
 c04b322:	d1f8      	bne.n	c04b316 <tfm_ps_set_ipc+0xe>
    num = psa_read(msg.handle, 0, &uid, msg.in_size[0]);
 c04b324:	2100      	movs	r1, #0
 c04b326:	6860      	ldr	r0, [r4, #4]
 c04b328:	aa04      	add	r2, sp, #16
 c04b32a:	f7f1 fa71 	bl	c03c810 <psa_read>
    if (num != msg.in_size[0]) {
 c04b32e:	6923      	ldr	r3, [r4, #16]
 c04b330:	4283      	cmp	r3, r0
 c04b332:	d1f0      	bne.n	c04b316 <tfm_ps_set_ipc+0xe>
    num = psa_read(msg.handle, 2, &create_flags, msg.in_size[2]);
 c04b334:	69a3      	ldr	r3, [r4, #24]
 c04b336:	2102      	movs	r1, #2
 c04b338:	6860      	ldr	r0, [r4, #4]
 c04b33a:	aa03      	add	r2, sp, #12
 c04b33c:	f7f1 fa68 	bl	c03c810 <psa_read>
    if (num != msg.in_size[2]) {
 c04b340:	69a3      	ldr	r3, [r4, #24]
 c04b342:	4283      	cmp	r3, r0
 c04b344:	d1e7      	bne.n	c04b316 <tfm_ps_set_ipc+0xe>
    return tfm_ps_set(client_id, uid, msg.in_size[1], create_flags);
 c04b346:	9b03      	ldr	r3, [sp, #12]
 c04b348:	4628      	mov	r0, r5
 c04b34a:	9301      	str	r3, [sp, #4]
 c04b34c:	6963      	ldr	r3, [r4, #20]
 c04b34e:	9300      	str	r3, [sp, #0]
 c04b350:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 c04b354:	f000 f880 	bl	c04b458 <tfm_ps_set>
 c04b358:	e7df      	b.n	c04b31a <tfm_ps_set_ipc+0x12>
 c04b35a:	bf00      	nop
 c04b35c:	30040408 	.word	0x30040408

0c04b360 <ps_signal_handle>:

static void ps_signal_handle(psa_signal_t signal, ps_func_t pfn)
{
 c04b360:	b538      	push	{r3, r4, r5, lr}
    psa_status_t status;

    status = psa_get(signal, &msg);
 c04b362:	4c0c      	ldr	r4, [pc, #48]	@ (c04b394 <ps_signal_handle+0x34>)
{
 c04b364:	460d      	mov	r5, r1
    status = psa_get(signal, &msg);
 c04b366:	4621      	mov	r1, r4
 c04b368:	f7f1 fa50 	bl	c03c80c <psa_get>
    switch (msg.type) {
 c04b36c:	6823      	ldr	r3, [r4, #0]
 c04b36e:	2b00      	cmp	r3, #0
 c04b370:	da05      	bge.n	c04b37e <ps_signal_handle+0x1e>
 c04b372:	3302      	adds	r3, #2
 c04b374:	da07      	bge.n	c04b386 <ps_signal_handle+0x26>
        psa_reply(msg.handle, PSA_SUCCESS);
        break;
    default:
        psa_panic();
    }
}
 c04b376:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
        psa_panic();
 c04b37a:	f7f1 ba4f 	b.w	c03c81c <psa_panic>
    switch (msg.type) {
 c04b37e:	d1fa      	bne.n	c04b376 <ps_signal_handle+0x16>
        status = pfn();
 c04b380:	47a8      	blx	r5
 c04b382:	4601      	mov	r1, r0
 c04b384:	e000      	b.n	c04b388 <ps_signal_handle+0x28>
        psa_reply(msg.handle, PSA_SUCCESS);
 c04b386:	2100      	movs	r1, #0
        psa_reply(msg.handle, status);
 c04b388:	6860      	ldr	r0, [r4, #4]
}
 c04b38a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
        psa_reply(msg.handle, status);
 c04b38e:	f7f1 ba43 	b.w	c03c818 <psa_reply>
 c04b392:	bf00      	nop
 c04b394:	30040408 	.word	0x30040408

0c04b398 <tfm_ps_req_mngr_init>:
#endif /* !defined(TFM_PSA_API) */

psa_status_t tfm_ps_req_mngr_init(void)
{
 c04b398:	b570      	push	{r4, r5, r6, lr}
#ifdef TFM_PSA_API
    psa_signal_t signals = 0;

    if (tfm_ps_init() != PSA_SUCCESS) {
 c04b39a:	f000 f851 	bl	c04b440 <tfm_ps_init>
 c04b39e:	b108      	cbz	r0, c04b3a4 <tfm_ps_req_mngr_init+0xc>
        psa_panic();
 c04b3a0:	f7f1 fa3c 	bl	c03c81c <psa_panic>
        } else if (signals & TFM_PS_GET_INFO_SIGNAL) {
            ps_signal_handle(TFM_PS_GET_INFO_SIGNAL, tfm_ps_get_info_ipc);
        } else if (signals & TFM_PS_REMOVE_SIGNAL) {
            ps_signal_handle(TFM_PS_REMOVE_SIGNAL, tfm_ps_remove_ipc);
        } else if (signals & TFM_PS_GET_SUPPORT_SIGNAL) {
            ps_signal_handle(TFM_PS_GET_SUPPORT_SIGNAL,
 c04b3a4:	4c13      	ldr	r4, [pc, #76]	@ (c04b3f4 <tfm_ps_req_mngr_init+0x5c>)
            ps_signal_handle(TFM_PS_REMOVE_SIGNAL, tfm_ps_remove_ipc);
 c04b3a6:	4d14      	ldr	r5, [pc, #80]	@ (c04b3f8 <tfm_ps_req_mngr_init+0x60>)
            ps_signal_handle(TFM_PS_GET_INFO_SIGNAL, tfm_ps_get_info_ipc);
 c04b3a8:	4e14      	ldr	r6, [pc, #80]	@ (c04b3fc <tfm_ps_req_mngr_init+0x64>)
        signals = psa_wait(PSA_WAIT_ANY, PSA_BLOCK);
 c04b3aa:	f04f 4100 	mov.w	r1, #2147483648	@ 0x80000000
 c04b3ae:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 c04b3b2:	f7f1 fa29 	bl	c03c808 <psa_wait>
        if (signals & TFM_PS_SET_SIGNAL) {
 c04b3b6:	06c2      	lsls	r2, r0, #27
 c04b3b8:	d504      	bpl.n	c04b3c4 <tfm_ps_req_mngr_init+0x2c>
            ps_signal_handle(TFM_PS_SET_SIGNAL, tfm_ps_set_ipc);
 c04b3ba:	2010      	movs	r0, #16
 c04b3bc:	4910      	ldr	r1, [pc, #64]	@ (c04b400 <tfm_ps_req_mngr_init+0x68>)
            ps_signal_handle(TFM_PS_GET_SUPPORT_SIGNAL,
 c04b3be:	f7ff ffcf 	bl	c04b360 <ps_signal_handle>
 c04b3c2:	e7f2      	b.n	c04b3aa <tfm_ps_req_mngr_init+0x12>
        } else if (signals & TFM_PS_GET_SIGNAL) {
 c04b3c4:	0683      	lsls	r3, r0, #26
 c04b3c6:	d502      	bpl.n	c04b3ce <tfm_ps_req_mngr_init+0x36>
            ps_signal_handle(TFM_PS_GET_SIGNAL, tfm_ps_get_ipc);
 c04b3c8:	2020      	movs	r0, #32
 c04b3ca:	490e      	ldr	r1, [pc, #56]	@ (c04b404 <tfm_ps_req_mngr_init+0x6c>)
 c04b3cc:	e7f7      	b.n	c04b3be <tfm_ps_req_mngr_init+0x26>
        } else if (signals & TFM_PS_GET_INFO_SIGNAL) {
 c04b3ce:	0641      	lsls	r1, r0, #25
 c04b3d0:	d502      	bpl.n	c04b3d8 <tfm_ps_req_mngr_init+0x40>
            ps_signal_handle(TFM_PS_GET_INFO_SIGNAL, tfm_ps_get_info_ipc);
 c04b3d2:	4631      	mov	r1, r6
 c04b3d4:	2040      	movs	r0, #64	@ 0x40
 c04b3d6:	e7f2      	b.n	c04b3be <tfm_ps_req_mngr_init+0x26>
        } else if (signals & TFM_PS_REMOVE_SIGNAL) {
 c04b3d8:	0602      	lsls	r2, r0, #24
 c04b3da:	d502      	bpl.n	c04b3e2 <tfm_ps_req_mngr_init+0x4a>
            ps_signal_handle(TFM_PS_REMOVE_SIGNAL, tfm_ps_remove_ipc);
 c04b3dc:	4629      	mov	r1, r5
 c04b3de:	2080      	movs	r0, #128	@ 0x80
 c04b3e0:	e7ed      	b.n	c04b3be <tfm_ps_req_mngr_init+0x26>
        } else if (signals & TFM_PS_GET_SUPPORT_SIGNAL) {
 c04b3e2:	05c3      	lsls	r3, r0, #23
 c04b3e4:	d503      	bpl.n	c04b3ee <tfm_ps_req_mngr_init+0x56>
            ps_signal_handle(TFM_PS_GET_SUPPORT_SIGNAL,
 c04b3e6:	4621      	mov	r1, r4
 c04b3e8:	f44f 7080 	mov.w	r0, #256	@ 0x100
 c04b3ec:	e7e7      	b.n	c04b3be <tfm_ps_req_mngr_init+0x26>
                             tfm_ps_get_support_ipc);
        } else {
            psa_panic();
 c04b3ee:	f7f1 fa15 	bl	c03c81c <psa_panic>
 c04b3f2:	e7da      	b.n	c04b3aa <tfm_ps_req_mngr_init+0x12>
 c04b3f4:	0c04b1fd 	.word	0x0c04b1fd
 c04b3f8:	0c04b229 	.word	0x0c04b229
 c04b3fc:	0c04b25d 	.word	0x0c04b25d
 c04b400:	0c04b309 	.word	0x0c04b309
 c04b404:	0c04b2b1 	.word	0x0c04b2b1

0c04b408 <ps_req_mngr_read_asset_data>:
    return PSA_SUCCESS;
#endif
}

psa_status_t ps_req_mngr_read_asset_data(uint8_t *out_data, uint32_t size)
{
 c04b408:	4602      	mov	r2, r0
#ifdef TFM_PSA_API
    size_t num = 0;

    num = psa_read(msg.handle, 1, out_data, size);
 c04b40a:	4807      	ldr	r0, [pc, #28]	@ (c04b428 <ps_req_mngr_read_asset_data+0x20>)
 c04b40c:	460b      	mov	r3, r1
{
 c04b40e:	b510      	push	{r4, lr}
    num = psa_read(msg.handle, 1, out_data, size);
 c04b410:	6840      	ldr	r0, [r0, #4]
{
 c04b412:	460c      	mov	r4, r1
    num = psa_read(msg.handle, 1, out_data, size);
 c04b414:	2101      	movs	r1, #1
 c04b416:	f7f1 f9fb 	bl	c03c810 <psa_read>
        return PSA_ERROR_PROGRAMMER_ERROR;
    }
#else /* TFM_PSA_API */
    (void)tfm_memcpy(out_data, p_data, size);
#endif
    return PSA_SUCCESS;
 c04b41a:	4284      	cmp	r4, r0
}
 c04b41c:	bf14      	ite	ne
 c04b41e:	f06f 0080 	mvnne.w	r0, #128	@ 0x80
 c04b422:	2000      	moveq	r0, #0
 c04b424:	bd10      	pop	{r4, pc}
 c04b426:	bf00      	nop
 c04b428:	30040408 	.word	0x30040408

0c04b42c <ps_req_mngr_write_asset_data>:

void ps_req_mngr_write_asset_data(const uint8_t *in_data, uint32_t size)
{
 c04b42c:	4602      	mov	r2, r0
#ifdef TFM_PSA_API
    psa_write(msg.handle, 0, in_data, size);
 c04b42e:	4803      	ldr	r0, [pc, #12]	@ (c04b43c <ps_req_mngr_write_asset_data+0x10>)
{
 c04b430:	460b      	mov	r3, r1
    psa_write(msg.handle, 0, in_data, size);
 c04b432:	6840      	ldr	r0, [r0, #4]
 c04b434:	2100      	movs	r1, #0
 c04b436:	f7f1 b9ed 	b.w	c03c814 <psa_write>
 c04b43a:	bf00      	nop
 c04b43c:	30040408 	.word	0x30040408

0c04b440 <tfm_ps_init>:
#include "tfm_protected_storage.h"
#include "ps_object_system.h"
#include "tfm_ps_defs.h"

psa_status_t tfm_ps_init(void)
{
 c04b440:	b508      	push	{r3, lr}
    psa_status_t err;

    err = ps_system_prepare();
 c04b442:	f7fe f9f1 	bl	c049828 <ps_system_prepare>
     * This flag can be set if the PS memory area is located in persistent
     * memory without a previous valid PS flash layout in it. That is the case
     * when it is the first time in the device life that the PS service is
     * executed.
     */
    if (err != PSA_SUCCESS) {
 c04b446:	b130      	cbz	r0, c04b456 <tfm_ps_init+0x16>
        /* Remove all data in the PS memory area and create a valid PS flash
         * layout in that area.
         */
        err = ps_system_wipe_all();
 c04b448:	f7fe faf0 	bl	c049a2c <ps_system_wipe_all>
        if (err != PSA_SUCCESS) {
 c04b44c:	b918      	cbnz	r0, c04b456 <tfm_ps_init+0x16>
        err = ps_system_prepare();
    }
#endif /* PS_CREATE_FLASH_LAYOUT */

    return err;
}
 c04b44e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
        err = ps_system_prepare();
 c04b452:	f7fe b9e9 	b.w	c049828 <ps_system_prepare>
}
 c04b456:	bd08      	pop	{r3, pc}

0c04b458 <tfm_ps_set>:

psa_status_t tfm_ps_set(int32_t client_id,
                        psa_storage_uid_t uid,
                        uint32_t data_length,
                        psa_storage_create_flags_t create_flags)
{
 c04b458:	b430      	push	{r4, r5}
 c04b45a:	4619      	mov	r1, r3
 c04b45c:	4604      	mov	r4, r0
 c04b45e:	4610      	mov	r0, r2
 c04b460:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    /* Check that the UID is valid */
    if (uid == TFM_PS_INVALID_UID) {
 c04b464:	ea50 0501 	orrs.w	r5, r0, r1
 c04b468:	d006      	beq.n	c04b478 <tfm_ps_set+0x20>
        return PSA_ERROR_INVALID_ARGUMENT;
    }

    /* Check that the create_flags does not contain any unsupported flags */
    if (create_flags & ~(PSA_STORAGE_FLAG_WRITE_ONCE |
 c04b46a:	2b07      	cmp	r3, #7
 c04b46c:	d808      	bhi.n	c04b480 <tfm_ps_set+0x28>
                         PSA_STORAGE_FLAG_NO_REPLAY_PROTECTION)) {
        return PSA_ERROR_NOT_SUPPORTED;
    }

    /* Create the object in the object system */
    return ps_object_create(uid, client_id, create_flags, data_length);
 c04b46e:	9202      	str	r2, [sp, #8]
 c04b470:	4622      	mov	r2, r4
}
 c04b472:	bc30      	pop	{r4, r5}
    return ps_object_create(uid, client_id, create_flags, data_length);
 c04b474:	f7fe ba14 	b.w	c0498a0 <ps_object_create>
        return PSA_ERROR_INVALID_ARGUMENT;
 c04b478:	f06f 0086 	mvn.w	r0, #134	@ 0x86
}
 c04b47c:	bc30      	pop	{r4, r5}
 c04b47e:	4770      	bx	lr
        return PSA_ERROR_NOT_SUPPORTED;
 c04b480:	f06f 0085 	mvn.w	r0, #133	@ 0x85
 c04b484:	e7fa      	b.n	c04b47c <tfm_ps_set+0x24>

0c04b486 <tfm_ps_get>:
psa_status_t tfm_ps_get(int32_t client_id,
                        psa_storage_uid_t uid,
                        uint32_t data_offset,
                        uint32_t data_size,
                        size_t *p_data_length)
{
 c04b486:	b470      	push	{r4, r5, r6}
 c04b488:	4619      	mov	r1, r3
 c04b48a:	4604      	mov	r4, r0
 c04b48c:	4610      	mov	r0, r2
 c04b48e:	e9dd 3203 	ldrd	r3, r2, [sp, #12]
    /* Check that the UID is valid */
    if (uid == TFM_PS_INVALID_UID) {
 c04b492:	ea50 0601 	orrs.w	r6, r0, r1
{
 c04b496:	9d05      	ldr	r5, [sp, #20]
    if (uid == TFM_PS_INVALID_UID) {
 c04b498:	d005      	beq.n	c04b4a6 <tfm_ps_get+0x20>
        return PSA_ERROR_INVALID_ARGUMENT;
    }

    /* Read the object data from the object system */
    return ps_object_read(uid, client_id, data_offset, data_size,
 c04b49a:	e9cd 2503 	strd	r2, r5, [sp, #12]
 c04b49e:	4622      	mov	r2, r4
                          p_data_length);
}
 c04b4a0:	bc70      	pop	{r4, r5, r6}
    return ps_object_read(uid, client_id, data_offset, data_size,
 c04b4a2:	f7fe b9cf 	b.w	c049844 <ps_object_read>
}
 c04b4a6:	f06f 0086 	mvn.w	r0, #134	@ 0x86
 c04b4aa:	bc70      	pop	{r4, r5, r6}
 c04b4ac:	4770      	bx	lr

0c04b4ae <tfm_ps_get_info>:

psa_status_t tfm_ps_get_info(int32_t client_id, psa_storage_uid_t uid,
                             struct psa_storage_info_t *p_info)
{
 c04b4ae:	4619      	mov	r1, r3
 c04b4b0:	b410      	push	{r4}
 c04b4b2:	4604      	mov	r4, r0
 c04b4b4:	4610      	mov	r0, r2
    /* Check that the UID is valid */
    if (uid == TFM_PS_INVALID_UID) {
 c04b4b6:	ea50 0201 	orrs.w	r2, r0, r1
{
 c04b4ba:	9b01      	ldr	r3, [sp, #4]
    if (uid == TFM_PS_INVALID_UID) {
 c04b4bc:	d003      	beq.n	c04b4c6 <tfm_ps_get_info+0x18>
        return PSA_ERROR_INVALID_ARGUMENT;
    }

    /* Get the info struct data from the object system */
    return ps_object_get_info(uid, client_id, p_info);
 c04b4be:	4622      	mov	r2, r4
}
 c04b4c0:	bc10      	pop	{r4}
    return ps_object_get_info(uid, client_id, p_info);
 c04b4c2:	f7fe ba61 	b.w	c049988 <ps_object_get_info>
}
 c04b4c6:	f06f 0086 	mvn.w	r0, #134	@ 0x86
 c04b4ca:	bc10      	pop	{r4}
 c04b4cc:	4770      	bx	lr

0c04b4ce <tfm_ps_remove>:

psa_status_t tfm_ps_remove(int32_t client_id, psa_storage_uid_t uid)
{
 c04b4ce:	4619      	mov	r1, r3
    psa_status_t err;

    /* Check that the UID is valid */
    if (uid == TFM_PS_INVALID_UID) {
 c04b4d0:	ea52 0301 	orrs.w	r3, r2, r1
{
 c04b4d4:	b510      	push	{r4, lr}
 c04b4d6:	4604      	mov	r4, r0
 c04b4d8:	4610      	mov	r0, r2
    if (uid == TFM_PS_INVALID_UID) {
 c04b4da:	d008      	beq.n	c04b4ee <tfm_ps_remove+0x20>
        return PSA_ERROR_INVALID_ARGUMENT;
    }

    /* Delete the object from the object system */
    err = ps_object_delete(uid, client_id);
 c04b4dc:	4622      	mov	r2, r4
 c04b4de:	f7fe fa73 	bl	c0499c8 <ps_object_delete>
    /* PSA_ERROR_INVALID_SIGNATURE is not supported by psa_ps_remove
     * specification. So, this function returns TFM_PS_ERR_OPERATION_FAILED
     * instead.
     */
    if (err == PSA_ERROR_INVALID_SIGNATURE) {
        return PSA_ERROR_GENERIC_ERROR;
 c04b4e2:	f110 0f95 	cmn.w	r0, #149	@ 0x95
 c04b4e6:	bf08      	it	eq
 c04b4e8:	f06f 0083 	mvneq.w	r0, #131	@ 0x83
    }

    return err;
}
 c04b4ec:	bd10      	pop	{r4, pc}
        return PSA_ERROR_INVALID_ARGUMENT;
 c04b4ee:	f06f 0086 	mvn.w	r0, #134	@ 0x86
 c04b4f2:	e7fb      	b.n	c04b4ec <tfm_ps_remove+0x1e>

0c04b4f4 <tfm_ps_get_support>:
     *
     * PS service does not support the optional extended PSA PS API yet.
     */

    return 0;
}
 c04b4f4:	2000      	movs	r0, #0
 c04b4f6:	4770      	bx	lr
	...

Disassembly of section .TFM_APP_ROT_RO:

0c04b500 <Test_Execute>:
/*  function used to validate TEST_EXECUTE */
void Test_Execute(void);
void Test_Execute(void)
{
    static __IO int TestExec = 0;
    TestExec++;
 c04b500:	4a02      	ldr	r2, [pc, #8]	@ (c04b50c <Test_Execute+0xc>)
 c04b502:	6813      	ldr	r3, [r2, #0]
 c04b504:	3301      	adds	r3, #1
 c04b506:	6013      	str	r3, [r2, #0]
}
 c04b508:	4770      	bx	lr
 c04b50a:	bf00      	nop
 c04b50c:	30040c40 	.word	0x30040c40

0c04b510 <set_periph_clk>:
  * @brief  Enable periph clock require to perform test
  * @param  periph to test.
  * @retval enable 1 , disable 0.
  */
static TestStatus set_periph_clk(PeriphTest periph)
{
 c04b510:	b082      	sub	sp, #8
    TestStatus status = TEST_IN_PROGRESS;
    switch (periph)
 c04b512:	b120      	cbz	r0, c04b51e <set_periph_clk+0xe>
 c04b514:	2801      	cmp	r0, #1
 c04b516:	d022      	beq.n	c04b55e <set_periph_clk+0x4e>
 c04b518:	2000      	movs	r0, #0
            break;
        default:
            break;
    }
    return status;
}
 c04b51a:	b002      	add	sp, #8
 c04b51c:	4770      	bx	lr
            if (!__HAL_RCC_RNG_IS_CLK_ENABLED())
 c04b51e:	4b1f      	ldr	r3, [pc, #124]	@ (c04b59c <set_periph_clk+0x8c>)
 c04b520:	f8d3 208c 	ldr.w	r2, [r3, #140]	@ 0x8c
 c04b524:	0351      	lsls	r1, r2, #13
 c04b526:	d411      	bmi.n	c04b54c <set_periph_clk+0x3c>
                __HAL_RCC_RNG_CONFIG(RCC_RNGCLKSOURCE_HSI48);
 c04b528:	f8d3 20e4 	ldr.w	r2, [r3, #228]	@ 0xe4
 c04b52c:	f422 5240 	bic.w	r2, r2, #12288	@ 0x3000
 c04b530:	f8c3 20e4 	str.w	r2, [r3, #228]	@ 0xe4
                __HAL_RCC_RNG_CLK_ENABLE();
 c04b534:	f8d3 208c 	ldr.w	r2, [r3, #140]	@ 0x8c
 c04b538:	f442 2280 	orr.w	r2, r2, #262144	@ 0x40000
 c04b53c:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
 c04b540:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 c04b544:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
 c04b548:	9300      	str	r3, [sp, #0]
 c04b54a:	9b00      	ldr	r3, [sp, #0]
            if (!__HAL_RCC_RNG_IS_CLK_ENABLED())
 c04b54c:	4b13      	ldr	r3, [pc, #76]	@ (c04b59c <set_periph_clk+0x8c>)
 c04b54e:	f8d3 008c 	ldr.w	r0, [r3, #140]	@ 0x8c
 c04b552:	f480 2080 	eor.w	r0, r0, #262144	@ 0x40000
 c04b556:	f3c0 4080 	ubfx	r0, r0, #18, #1
            if (!__HAL_RCC_HASH_IS_CLK_ENABLED())
 c04b55a:	0040      	lsls	r0, r0, #1
 c04b55c:	e7dd      	b.n	c04b51a <set_periph_clk+0xa>
            if (!__HAL_RCC_HASH_IS_CLK_ENABLED())
 c04b55e:	4b0f      	ldr	r3, [pc, #60]	@ (c04b59c <set_periph_clk+0x8c>)
 c04b560:	f8d3 208c 	ldr.w	r2, [r3, #140]	@ 0x8c
 c04b564:	0392      	lsls	r2, r2, #14
 c04b566:	d411      	bmi.n	c04b58c <set_periph_clk+0x7c>
                __HAL_RCC_RNG_CONFIG(RCC_RNGCLKSOURCE_HSI48);
 c04b568:	f8d3 20e4 	ldr.w	r2, [r3, #228]	@ 0xe4
 c04b56c:	f422 5240 	bic.w	r2, r2, #12288	@ 0x3000
 c04b570:	f8c3 20e4 	str.w	r2, [r3, #228]	@ 0xe4
                __HAL_RCC_RNG_CLK_ENABLE();
 c04b574:	f8d3 208c 	ldr.w	r2, [r3, #140]	@ 0x8c
 c04b578:	f442 2280 	orr.w	r2, r2, #262144	@ 0x40000
 c04b57c:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
 c04b580:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 c04b584:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
 c04b588:	9301      	str	r3, [sp, #4]
 c04b58a:	9b01      	ldr	r3, [sp, #4]
            if (!__HAL_RCC_HASH_IS_CLK_ENABLED())
 c04b58c:	4b03      	ldr	r3, [pc, #12]	@ (c04b59c <set_periph_clk+0x8c>)
 c04b58e:	f8d3 008c 	ldr.w	r0, [r3, #140]	@ 0x8c
 c04b592:	f480 3000 	eor.w	r0, r0, #131072	@ 0x20000
 c04b596:	f3c0 4040 	ubfx	r0, r0, #17, #1
 c04b59a:	e7de      	b.n	c04b55a <set_periph_clk+0x4a>
 c04b59c:	56020c00 	.word	0x56020c00

0c04b5a0 <dma_m2m.constprop.0>:
static TestStatus dma_m2m(void *to, void *from, size_t n)
{

    DMA_HandleTypeDef DMAHandle;
    DMA_QListTypeDef  Queue;
    __HAL_RCC_GPDMA1_CLK_ENABLE();
 c04b5a0:	4b28      	ldr	r3, [pc, #160]	@ (c04b644 <dma_m2m.constprop.0+0xa4>)
static TestStatus dma_m2m(void *to, void *from, size_t n)
 c04b5a2:	b570      	push	{r4, r5, r6, lr}
    __HAL_RCC_GPDMA1_CLK_ENABLE();
 c04b5a4:	f8d3 2088 	ldr.w	r2, [r3, #136]	@ 0x88
static TestStatus dma_m2m(void *to, void *from, size_t n)
 c04b5a8:	b0a6      	sub	sp, #152	@ 0x98
    __HAL_RCC_GPDMA1_CLK_ENABLE();
 c04b5aa:	f042 0201 	orr.w	r2, r2, #1
 c04b5ae:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
    DMAHandle.Instance                    = GPDMA1_Channel0;
#else
    DMAHandle.Instance                    = GPDMA1_Channel1;
#endif /* defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U) */
    /* Set parameter to be configured */
    DMAHandle.Init.Request                = DMA_REQUEST_SW;
 c04b5b2:	f44f 7200 	mov.w	r2, #512	@ 0x200
    __HAL_RCC_GPDMA1_CLK_ENABLE();
 c04b5b6:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
    DMAHandle.Init.BlkHWRequest           = DMA_BREQ_SINGLE_BURST;
    DMAHandle.Init.Direction              = DMA_MEMORY_TO_MEMORY;
    DMAHandle.Init.SrcInc                 = DMA_SINC_INCREMENTED;
    DMAHandle.Init.DestInc                = DMA_DINC_INCREMENTED;
 c04b5ba:	2608      	movs	r6, #8
    __HAL_RCC_GPDMA1_CLK_ENABLE();
 c04b5bc:	f003 0301 	and.w	r3, r3, #1
 c04b5c0:	9301      	str	r3, [sp, #4]
 c04b5c2:	9b01      	ldr	r3, [sp, #4]
    DMAHandle.Init.Request                = DMA_REQUEST_SW;
 c04b5c4:	4b20      	ldr	r3, [pc, #128]	@ (c04b648 <dma_m2m.constprop.0+0xa8>)
static TestStatus dma_m2m(void *to, void *from, size_t n)
 c04b5c6:	460c      	mov	r4, r1
    DMAHandle.Init.Request                = DMA_REQUEST_SW;
 c04b5c8:	e9cd 3208 	strd	r3, r2, [sp, #32]
    DMAHandle.Init.BlkHWRequest           = DMA_BREQ_SINGLE_BURST;
 c04b5cc:	2300      	movs	r3, #0
    DMAHandle.Init.Direction              = DMA_MEMORY_TO_MEMORY;
 c04b5ce:	e9cd 320a 	strd	r3, r2, [sp, #40]	@ 0x28
    DMAHandle.Init.DestInc                = DMA_DINC_INCREMENTED;
 c04b5d2:	f44f 2200 	mov.w	r2, #524288	@ 0x80000
    DMAHandle.Init.SrcDataWidth           = DMA_SRC_DATAWIDTH_WORD;
    DMAHandle.Init.DestDataWidth          = DMA_DEST_DATAWIDTH_WORD;
 c04b5d6:	2102      	movs	r1, #2
    DMAHandle.Init.DestInc                = DMA_DINC_INCREMENTED;
 c04b5d8:	e9cd 620c 	strd	r6, r2, [sp, #48]	@ 0x30
    DMAHandle.Init.DestDataWidth          = DMA_DEST_DATAWIDTH_WORD;
 c04b5dc:	f44f 3200 	mov.w	r2, #131072	@ 0x20000
 c04b5e0:	e9cd 120e 	strd	r1, r2, [sp, #56]	@ 0x38
    DMAHandle.Init.SrcBurstLength         = 1;
 c04b5e4:	2201      	movs	r2, #1
    DMAHandle.Init.DestBurstLength        = 1;
 c04b5e6:	e9cd 2211 	strd	r2, r2, [sp, #68]	@ 0x44
    DMAHandle.Init.Priority               = DMA_LOW_PRIORITY_HIGH_WEIGHT;
 c04b5ea:	f44f 0200 	mov.w	r2, #8388608	@ 0x800000
 c04b5ee:	9210      	str	r2, [sp, #64]	@ 0x40
    DMAHandle.Init.TransferEventMode      = DMA_TCEM_BLOCK_TRANSFER;
    DMAHandle.Init.TransferAllocatedPort  = DMA_SRC_ALLOCATED_PORT0 | DMA_DEST_ALLOCATED_PORT1;
 c04b5f0:	f04f 4280 	mov.w	r2, #1073741824	@ 0x40000000
static TestStatus dma_m2m(void *to, void *from, size_t n)
 c04b5f4:	4605      	mov	r5, r0
    DMAHandle.Init.TransferEventMode      = DMA_TCEM_BLOCK_TRANSFER;
 c04b5f6:	9314      	str	r3, [sp, #80]	@ 0x50
    DMAHandle.Mode                        = DMA_NORMAL;
 c04b5f8:	931c      	str	r3, [sp, #112]	@ 0x70
    DMAHandle.LinkedListQueue             = &Queue;

    /* Initialize the DMA channel */
    if (HAL_DMA_Init(&DMAHandle) != HAL_OK)
 c04b5fa:	a808      	add	r0, sp, #32
    DMAHandle.LinkedListQueue             = &Queue;
 c04b5fc:	eb0d 0306 	add.w	r3, sp, r6
    DMAHandle.Init.TransferAllocatedPort  = DMA_SRC_ALLOCATED_PORT0 | DMA_DEST_ALLOCATED_PORT1;
 c04b600:	9213      	str	r2, [sp, #76]	@ 0x4c
    DMAHandle.LinkedListQueue             = &Queue;
 c04b602:	9325      	str	r3, [sp, #148]	@ 0x94
    if (HAL_DMA_Init(&DMAHandle) != HAL_OK)
 c04b604:	f7f2 f8e0 	bl	c03d7c8 <HAL_DMA_Init>
 c04b608:	b110      	cbz	r0, c04b610 <dma_m2m.constprop.0+0x70>
    {
        return TEST_ERROR;
 c04b60a:	2002      	movs	r0, #2
    if (HAL_DMA_PollForTransfer(&DMAHandle, HAL_DMA_FULL_TRANSFER, 3000UL) != HAL_OK)
    {
        return TEST_ERROR;
    }
    return TEST_IN_PROGRESS;
}
 c04b60c:	b026      	add	sp, #152	@ 0x98
 c04b60e:	bd70      	pop	{r4, r5, r6, pc}
    if (HAL_DMA_ConfigChannelAttributes(&DMAHandle,
 c04b610:	21fe      	movs	r1, #254	@ 0xfe
 c04b612:	a808      	add	r0, sp, #32
 c04b614:	f7f2 fb8f 	bl	c03dd36 <HAL_DMA_ConfigChannelAttributes>
 c04b618:	2800      	cmp	r0, #0
 c04b61a:	d1f6      	bne.n	c04b60a <dma_m2m.constprop.0+0x6a>
    if (HAL_DMA_Start(&DMAHandle, (uint32_t)from, (uint32_t)to, n) != HAL_OK)
 c04b61c:	4621      	mov	r1, r4
 c04b61e:	4633      	mov	r3, r6
 c04b620:	462a      	mov	r2, r5
 c04b622:	a808      	add	r0, sp, #32
 c04b624:	f7f2 fa86 	bl	c03db34 <HAL_DMA_Start>
 c04b628:	4601      	mov	r1, r0
 c04b62a:	2800      	cmp	r0, #0
 c04b62c:	d1ed      	bne.n	c04b60a <dma_m2m.constprop.0+0x6a>
    if (HAL_DMA_PollForTransfer(&DMAHandle, HAL_DMA_FULL_TRANSFER, 3000UL) != HAL_OK)
 c04b62e:	f640 32b8 	movw	r2, #3000	@ 0xbb8
 c04b632:	a808      	add	r0, sp, #32
 c04b634:	f7f2 faf5 	bl	c03dc22 <HAL_DMA_PollForTransfer>
 c04b638:	3800      	subs	r0, #0
 c04b63a:	bf18      	it	ne
 c04b63c:	2001      	movne	r0, #1
 c04b63e:	0040      	lsls	r0, r0, #1
 c04b640:	e7e4      	b.n	c04b60c <dma_m2m.constprop.0+0x6c>
 c04b642:	bf00      	nop
 c04b644:	56020c00 	.word	0x56020c00
 c04b648:	50020050 	.word	0x50020050

0c04b64c <app_rot_hal_ioctl>:
{
 c04b64c:	b5f0      	push	{r4, r5, r6, r7, lr}
 c04b64e:	b08d      	sub	sp, #52	@ 0x34
    if ((!in_vec) || (in_vec->len != 4))
 c04b650:	2900      	cmp	r1, #0
 c04b652:	f000 811e 	beq.w	c04b892 <app_rot_hal_ioctl+0x246>
 c04b656:	684b      	ldr	r3, [r1, #4]
 c04b658:	2b04      	cmp	r3, #4
 c04b65a:	f040 811a 	bne.w	c04b892 <app_rot_hal_ioctl+0x246>
    test_idx = *((uint32_t *)in_vec->base);
 c04b65e:	680b      	ldr	r3, [r1, #0]
 c04b660:	681e      	ldr	r6, [r3, #0]
    if (test_idx > (sizeof(aProtectTests) / sizeof(TestProtection_t) -1))
 c04b662:	2e1c      	cmp	r6, #28
 c04b664:	f200 8113 	bhi.w	c04b88e <app_rot_hal_ioctl+0x242>
    if (request == IOCTL_TEST_PROTECTION_DESC)
 c04b668:	b9d8      	cbnz	r0, c04b6a2 <app_rot_hal_ioctl+0x56>
        if ((out_vec) && (out_vec->base) && (out_vec->len == sizeof(TestProtection_t)))
 c04b66a:	2a00      	cmp	r2, #0
 c04b66c:	f000 8111 	beq.w	c04b892 <app_rot_hal_ioctl+0x246>
 c04b670:	6813      	ldr	r3, [r2, #0]
 c04b672:	2b00      	cmp	r3, #0
 c04b674:	f000 810d 	beq.w	c04b892 <app_rot_hal_ioctl+0x246>
 c04b678:	6851      	ldr	r1, [r2, #4]
 c04b67a:	2928      	cmp	r1, #40	@ 0x28
 c04b67c:	f040 8109 	bne.w	c04b892 <app_rot_hal_ioctl+0x246>
            memcpy(test_desc, &aProtectTests[test_idx], sizeof(TestProtection_t));
 c04b680:	4a85      	ldr	r2, [pc, #532]	@ (c04b898 <app_rot_hal_ioctl+0x24c>)
 c04b682:	fb01 2206 	mla	r2, r1, r6, r2
 c04b686:	f102 0528 	add.w	r5, r2, #40	@ 0x28
 c04b68a:	4614      	mov	r4, r2
 c04b68c:	cc03      	ldmia	r4!, {r0, r1}
 c04b68e:	42ac      	cmp	r4, r5
 c04b690:	6018      	str	r0, [r3, #0]
 c04b692:	6059      	str	r1, [r3, #4]
 c04b694:	4622      	mov	r2, r4
 c04b696:	f103 0308 	add.w	r3, r3, #8
 c04b69a:	d1f6      	bne.n	c04b68a <app_rot_hal_ioctl+0x3e>
            return TFM_APP_ROT_ERR_SUCCESS;
 c04b69c:	2000      	movs	r0, #0
}
 c04b69e:	b00d      	add	sp, #52	@ 0x34
 c04b6a0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if (request == IOCTL_TEST_PROTECTION_RUN_TEST)
 c04b6a2:	2801      	cmp	r0, #1
 c04b6a4:	f040 80f5 	bne.w	c04b892 <app_rot_hal_ioctl+0x246>
    uint64_t pattern[2] = {0U};
 c04b6a8:	2210      	movs	r2, #16
 c04b6aa:	2100      	movs	r1, #0
 c04b6ac:	eb0d 0002 	add.w	r0, sp, r2
 c04b6b0:	f010 f83d 	bl	c05b72e <memset>
    uint32_t page_error = 0U;
 c04b6b4:	2300      	movs	r3, #0
    switch (aProtectTests[test_idx].type)
 c04b6b6:	2428      	movs	r4, #40	@ 0x28
 c04b6b8:	4d77      	ldr	r5, [pc, #476]	@ (c04b898 <app_rot_hal_ioctl+0x24c>)
    uint32_t page_error = 0U;
 c04b6ba:	9301      	str	r3, [sp, #4]
    uint32_t dmabuff[] = {0xdeadbeef, 0xfadadead};
 c04b6bc:	4b77      	ldr	r3, [pc, #476]	@ (c04b89c <app_rot_hal_ioctl+0x250>)
 c04b6be:	af02      	add	r7, sp, #8
 c04b6c0:	e893 0003 	ldmia.w	r3, {r0, r1}
    switch (aProtectTests[test_idx].type)
 c04b6c4:	fb04 5306 	mla	r3, r4, r6, r5
 c04b6c8:	f893 3024 	ldrb.w	r3, [r3, #36]	@ 0x24
    uint32_t dmabuff[] = {0xdeadbeef, 0xfadadead};
 c04b6cc:	e887 0003 	stmia.w	r7, {r0, r1}
    switch (aProtectTests[test_idx].type)
 c04b6d0:	2b11      	cmp	r3, #17
 c04b6d2:	d822      	bhi.n	c04b71a <app_rot_hal_ioctl+0xce>
 c04b6d4:	e8df f013 	tbh	[pc, r3, lsl #1]
 c04b6d8:	001200a2 	.word	0x001200a2
 c04b6dc:	002700c1 	.word	0x002700c1
 c04b6e0:	00320012 	.word	0x00320012
 c04b6e4:	004c0039 	.word	0x004c0039
 c04b6e8:	008d0069 	.word	0x008d0069
 c04b6ec:	00210076 	.word	0x00210076
 c04b6f0:	00210021 	.word	0x00210021
 c04b6f4:	00210021 	.word	0x00210021
 c04b6f8:	00db0021 	.word	0x00db0021
            tmp = *(uint8_t *)(aProtectTests[test_idx].address);
 c04b6fc:	4374      	muls	r4, r6
 c04b6fe:	592a      	ldr	r2, [r5, r4]
 c04b700:	192b      	adds	r3, r5, r4
            if ((aProtectTests[test_idx].access == DENIED) ||
 c04b702:	f893 3026 	ldrb.w	r3, [r3, #38]	@ 0x26
            tmp = *(uint8_t *)(aProtectTests[test_idx].address);
 c04b706:	7812      	ldrb	r2, [r2, #0]
            if ((aProtectTests[test_idx].access == DENIED) ||
 c04b708:	2b01      	cmp	r3, #1
            tmp = *(uint8_t *)(aProtectTests[test_idx].address);
 c04b70a:	f88d 2003 	strb.w	r2, [sp, #3]
            if ((aProtectTests[test_idx].access == DENIED) ||
 c04b70e:	d013      	beq.n	c04b738 <app_rot_hal_ioctl+0xec>
 c04b710:	2b02      	cmp	r3, #2
 c04b712:	d102      	bne.n	c04b71a <app_rot_hal_ioctl+0xce>
                ((aProtectTests[test_idx].access == SILENT) && (tmp)))
 c04b714:	f89d 3003 	ldrb.w	r3, [sp, #3]
 c04b718:	b973      	cbnz	r3, c04b738 <app_rot_hal_ioctl+0xec>
    TestStatus status = TEST_IN_PROGRESS;
 c04b71a:	2000      	movs	r0, #0
        if (status == TEST_IN_PROGRESS)
 c04b71c:	3800      	subs	r0, #0
 c04b71e:	bf18      	it	ne
 c04b720:	2001      	movne	r0, #1
 c04b722:	0040      	lsls	r0, r0, #1
 c04b724:	e7bb      	b.n	c04b69e <app_rot_hal_ioctl+0x52>
            *(uint32_t *)aProtectTests[test_idx].address = 0x00000000;
 c04b726:	2100      	movs	r1, #0
 c04b728:	4374      	muls	r4, r6
 c04b72a:	592a      	ldr	r2, [r5, r4]
 c04b72c:	192b      	adds	r3, r5, r4
            if (aProtectTests[test_idx].access == DENIED)
 c04b72e:	f893 3026 	ldrb.w	r3, [r3, #38]	@ 0x26
            *(uint32_t *)aProtectTests[test_idx].address = 0x00000000;
 c04b732:	6011      	str	r1, [r2, #0]
                if (aProtectTests[test_idx].access == DENIED)
 c04b734:	2b01      	cmp	r3, #1
 c04b736:	d1f0      	bne.n	c04b71a <app_rot_hal_ioctl+0xce>
            return TFM_APP_ROT_ERROR;
 c04b738:	2001      	movs	r0, #1
 c04b73a:	e7b0      	b.n	c04b69e <app_rot_hal_ioctl+0x52>
            func = (void(*)(void))(aProtectTests[test_idx].address);
 c04b73c:	4374      	muls	r4, r6
            func();
 c04b73e:	592b      	ldr	r3, [r5, r4]
            func = (void(*)(void))(aProtectTests[test_idx].address);
 c04b740:	192e      	adds	r6, r5, r4
            func();
 c04b742:	4798      	blx	r3
            switch (aProtectTests[test_idx].access)
 c04b744:	f896 3026 	ldrb.w	r3, [r6, #38]	@ 0x26
 c04b748:	e7e6      	b.n	c04b718 <app_rot_hal_ioctl+0xcc>
            if (aProtectTests[test_idx].address & 1)
 c04b74a:	4374      	muls	r4, r6
 c04b74c:	192e      	adds	r6, r5, r4
 c04b74e:	592c      	ldr	r4, [r5, r4]
 c04b750:	07e2      	lsls	r2, r4, #31
 c04b752:	d4f1      	bmi.n	c04b738 <app_rot_hal_ioctl+0xec>
            *pData = BX_LR;
 c04b754:	4623      	mov	r3, r4
 c04b756:	f244 7270 	movw	r2, #18288	@ 0x4770
            DataVal = *pData;
 c04b75a:	8825      	ldrh	r5, [r4, #0]
            *pData = BX_LR;
 c04b75c:	f823 2b01 	strh.w	r2, [r3], #1
            DataVal = *pData;
 c04b760:	b2ad      	uxth	r5, r5
  __ASM volatile ("dsb 0xF":::"memory");
 c04b762:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 c04b766:	f3bf 8f6f 	isb	sy
            func();
 c04b76a:	4798      	blx	r3
            *pData = DataVal;
 c04b76c:	8025      	strh	r5, [r4, #0]
 c04b76e:	e7e9      	b.n	c04b744 <app_rot_hal_ioctl+0xf8>
            status = set_periph_clk(aProtectTests[test_idx].periph);
 c04b770:	4374      	muls	r4, r6
 c04b772:	192b      	adds	r3, r5, r4
 c04b774:	f893 0025 	ldrb.w	r0, [r3, #37]	@ 0x25
 c04b778:	f7ff feca 	bl	c04b510 <set_periph_clk>
            if (status == TEST_IN_PROGRESS)
 c04b77c:	2800      	cmp	r0, #0
 c04b77e:	f040 8084 	bne.w	c04b88a <app_rot_hal_ioctl+0x23e>
                    tmp_reg = *((__IO uint32_t *)aProtectTests[test_idx].address);
 c04b782:	230a      	movs	r3, #10
 c04b784:	5929      	ldr	r1, [r5, r4]
 c04b786:	680a      	ldr	r2, [r1, #0]
                } while (loop && tmp_reg);
 c04b788:	3b01      	subs	r3, #1
                    tmp_reg = *((__IO uint32_t *)aProtectTests[test_idx].address);
 c04b78a:	9208      	str	r2, [sp, #32]
                } while (loop && tmp_reg);
 c04b78c:	d002      	beq.n	c04b794 <app_rot_hal_ioctl+0x148>
 c04b78e:	9a08      	ldr	r2, [sp, #32]
 c04b790:	2a00      	cmp	r2, #0
 c04b792:	d1f8      	bne.n	c04b786 <app_rot_hal_ioctl+0x13a>
                if ((aProtectTests[test_idx].access == DENIED) ||
 c04b794:	2328      	movs	r3, #40	@ 0x28
 c04b796:	fb03 5306 	mla	r3, r3, r6, r5
 c04b79a:	f893 3026 	ldrb.w	r3, [r3, #38]	@ 0x26
 c04b79e:	2b01      	cmp	r3, #1
 c04b7a0:	d0ca      	beq.n	c04b738 <app_rot_hal_ioctl+0xec>
 c04b7a2:	2b02      	cmp	r3, #2
 c04b7a4:	d1b9      	bne.n	c04b71a <app_rot_hal_ioctl+0xce>
                    ((aProtectTests[test_idx].access == SILENT) && (tmp_reg)))
 c04b7a6:	9b08      	ldr	r3, [sp, #32]
 c04b7a8:	e7b6      	b.n	c04b718 <app_rot_hal_ioctl+0xcc>
            status = set_periph_clk(aProtectTests[test_idx].periph);
 c04b7aa:	4374      	muls	r4, r6
 c04b7ac:	192e      	adds	r6, r5, r4
 c04b7ae:	f896 0025 	ldrb.w	r0, [r6, #37]	@ 0x25
 c04b7b2:	f7ff fead 	bl	c04b510 <set_periph_clk>
            if (status == TEST_IN_PROGRESS)
 c04b7b6:	2800      	cmp	r0, #0
 c04b7b8:	d167      	bne.n	c04b88a <app_rot_hal_ioctl+0x23e>
                *((__IO uint32_t *)aProtectTests[test_idx].address) = 0x0;
 c04b7ba:	592a      	ldr	r2, [r5, r4]
                if (aProtectTests[test_idx].access == DENIED)
 c04b7bc:	f896 3026 	ldrb.w	r3, [r6, #38]	@ 0x26
                *((__IO uint32_t *)aProtectTests[test_idx].address) = 0x0;
 c04b7c0:	6010      	str	r0, [r2, #0]
                if (aProtectTests[test_idx].access == DENIED)
 c04b7c2:	e7b7      	b.n	c04b734 <app_rot_hal_ioctl+0xe8>
            dest = (void *)aProtectTests[test_idx].address;
 c04b7c4:	4374      	muls	r4, r6
 c04b7c6:	192e      	adds	r6, r5, r4
 c04b7c8:	592c      	ldr	r4, [r5, r4]
            status = dma_m2m((void *)dest, (void *)DMA_CONST_2, sizeof(DMA_CONST_2));
 c04b7ca:	4935      	ldr	r1, [pc, #212]	@ (c04b8a0 <app_rot_hal_ioctl+0x254>)
 c04b7cc:	4620      	mov	r0, r4
 c04b7ce:	f7ff fee7 	bl	c04b5a0 <dma_m2m.constprop.0>
            if (status == TEST_IN_PROGRESS)
 c04b7d2:	2800      	cmp	r0, #0
 c04b7d4:	d159      	bne.n	c04b88a <app_rot_hal_ioctl+0x23e>
                switch (aProtectTests[test_idx].access)
 c04b7d6:	f896 3026 	ldrb.w	r3, [r6, #38]	@ 0x26
 c04b7da:	b113      	cbz	r3, c04b7e2 <app_rot_hal_ioctl+0x196>
 c04b7dc:	2b02      	cmp	r3, #2
 c04b7de:	d1ab      	bne.n	c04b738 <app_rot_hal_ioctl+0xec>
 c04b7e0:	e79b      	b.n	c04b71a <app_rot_hal_ioctl+0xce>
                        if (memcmp(dest, DMA_CONST_2, sizeof(DMA_CONST_2)))
 c04b7e2:	2208      	movs	r2, #8
 c04b7e4:	492e      	ldr	r1, [pc, #184]	@ (c04b8a0 <app_rot_hal_ioctl+0x254>)
                        if (memcmp(from, dmabuff, sizeof(dmabuff)))
 c04b7e6:	4620      	mov	r0, r4
                        if (memcmp(DMA_NULL, dmabuff, sizeof(DMA_NULL)))
 c04b7e8:	f00f ff20 	bl	c05b62c <memcmp>
 c04b7ec:	2800      	cmp	r0, #0
 c04b7ee:	d094      	beq.n	c04b71a <app_rot_hal_ioctl+0xce>
 c04b7f0:	e7a2      	b.n	c04b738 <app_rot_hal_ioctl+0xec>
            from = (void *)aProtectTests[test_idx].address;
 c04b7f2:	4374      	muls	r4, r6
 c04b7f4:	192e      	adds	r6, r5, r4
 c04b7f6:	592c      	ldr	r4, [r5, r4]
            status = dma_m2m((void *)dmabuff, from, sizeof(dmabuff));
 c04b7f8:	4638      	mov	r0, r7
 c04b7fa:	4621      	mov	r1, r4
 c04b7fc:	f7ff fed0 	bl	c04b5a0 <dma_m2m.constprop.0>
            if (status == TEST_IN_PROGRESS)
 c04b800:	2800      	cmp	r0, #0
 c04b802:	d142      	bne.n	c04b88a <app_rot_hal_ioctl+0x23e>
                switch (aProtectTests[test_idx].access)
 c04b804:	f896 3026 	ldrb.w	r3, [r6, #38]	@ 0x26
 c04b808:	b12b      	cbz	r3, c04b816 <app_rot_hal_ioctl+0x1ca>
 c04b80a:	2b02      	cmp	r3, #2
 c04b80c:	d194      	bne.n	c04b738 <app_rot_hal_ioctl+0xec>
                        if (memcmp(DMA_NULL, dmabuff, sizeof(DMA_NULL)))
 c04b80e:	2208      	movs	r2, #8
 c04b810:	4639      	mov	r1, r7
 c04b812:	4824      	ldr	r0, [pc, #144]	@ (c04b8a4 <app_rot_hal_ioctl+0x258>)
 c04b814:	e7e8      	b.n	c04b7e8 <app_rot_hal_ioctl+0x19c>
                        if (memcmp(from, dmabuff, sizeof(dmabuff)))
 c04b816:	2208      	movs	r2, #8
 c04b818:	4639      	mov	r1, r7
 c04b81a:	e7e4      	b.n	c04b7e6 <app_rot_hal_ioctl+0x19a>
            HAL_FLASH_Program(FLASH_TYPEPROGRAM_QUADWORD, aProtectTests[test_idx].address, (uint32_t)&pattern);
 c04b81c:	4374      	muls	r4, r6
            HAL_FLASH_Unlock();
 c04b81e:	f7f2 fb0d 	bl	c03de3c <HAL_FLASH_Unlock>
            HAL_FLASH_Program(FLASH_TYPEPROGRAM_QUADWORD, aProtectTests[test_idx].address, (uint32_t)&pattern);
 c04b822:	5929      	ldr	r1, [r5, r4]
 c04b824:	aa04      	add	r2, sp, #16
 c04b826:	2001      	movs	r0, #1
 c04b828:	f7f2 fb80 	bl	c03df2c <HAL_FLASH_Program>
            HAL_FLASH_Lock();
 c04b82c:	f7f2 fb26 	bl	c03de7c <HAL_FLASH_Lock>
            flashErrCode = HAL_FLASH_GetError();
 c04b830:	f7f2 fb38 	bl	c03dea4 <HAL_FLASH_GetError>
            if (0 == strncmp("OBs @", (const char *)aProtectTests[test_idx].msg, 5))
 c04b834:	3404      	adds	r4, #4
            flashErrCode = HAL_FLASH_GetError();
 c04b836:	4606      	mov	r6, r0
            if (0 == strncmp("OBs @", (const char *)aProtectTests[test_idx].msg, 5))
 c04b838:	2205      	movs	r2, #5
 c04b83a:	481b      	ldr	r0, [pc, #108]	@ (c04b8a8 <app_rot_hal_ioctl+0x25c>)
 c04b83c:	1929      	adds	r1, r5, r4
 c04b83e:	f7f6 fe9f 	bl	c042580 <strncmp>
 c04b842:	2800      	cmp	r0, #0
 c04b844:	f43f af78 	beq.w	c04b738 <app_rot_hal_ioctl+0xec>
            if ((flashErrCode & HAL_FLASH_ERROR_WRP) == 0U)
 c04b848:	f086 0010 	eor.w	r0, r6, #16
 c04b84c:	f3c0 1000 	ubfx	r0, r0, #4, #1
 c04b850:	0040      	lsls	r0, r0, #1
        if (status == TEST_ERROR)
 c04b852:	2802      	cmp	r0, #2
 c04b854:	f47f af62 	bne.w	c04b71c <app_rot_hal_ioctl+0xd0>
 c04b858:	e76e      	b.n	c04b738 <app_rot_hal_ioctl+0xec>
            HAL_FLASH_Unlock();
 c04b85a:	f7f2 faef 	bl	c03de3c <HAL_FLASH_Unlock>
            p_erase_init.TypeErase   = FLASH_TYPEERASE_PAGES;
 c04b85e:	2201      	movs	r2, #1
 c04b860:	2302      	movs	r3, #2
 c04b862:	e9cd 3208 	strd	r3, r2, [sp, #32]
            p_erase_init.Page        = (aProtectTests[test_idx].address) / 0x800;
 c04b866:	2328      	movs	r3, #40	@ 0x28
 c04b868:	435e      	muls	r6, r3
 c04b86a:	59ab      	ldr	r3, [r5, r6]
            HAL_FLASHEx_Erase(&p_erase_init, &page_error);
 c04b86c:	a901      	add	r1, sp, #4
            p_erase_init.Page        = (aProtectTests[test_idx].address) / 0x800;
 c04b86e:	0adb      	lsrs	r3, r3, #11
            HAL_FLASHEx_Erase(&p_erase_init, &page_error);
 c04b870:	a808      	add	r0, sp, #32
            p_erase_init.NbPages     = 1;
 c04b872:	e9cd 320a 	strd	r3, r2, [sp, #40]	@ 0x28
            HAL_FLASHEx_Erase(&p_erase_init, &page_error);
 c04b876:	f7f2 fbd3 	bl	c03e020 <HAL_FLASHEx_Erase>
            HAL_FLASH_Lock();
 c04b87a:	f7f2 faff 	bl	c03de7c <HAL_FLASH_Lock>
            if ((HAL_FLASH_GetError() & HAL_FLASH_ERROR_WRP) == 0U)
 c04b87e:	f7f2 fb11 	bl	c03dea4 <HAL_FLASH_GetError>
 c04b882:	06c3      	lsls	r3, r0, #27
 c04b884:	f53f af49 	bmi.w	c04b71a <app_rot_hal_ioctl+0xce>
 c04b888:	e756      	b.n	c04b738 <app_rot_hal_ioctl+0xec>
        if (status == TEST_COMPLETED)
 c04b88a:	2801      	cmp	r0, #1
 c04b88c:	d1e1      	bne.n	c04b852 <app_rot_hal_ioctl+0x206>
        return TFM_APP_ROT_ERR_NOT_SUPPORTED;
 c04b88e:	2003      	movs	r0, #3
 c04b890:	e705      	b.n	c04b69e <app_rot_hal_ioctl+0x52>
        return TFM_APP_ROT_ERR_INVALID_PARAM;
 c04b892:	2002      	movs	r0, #2
 c04b894:	e703      	b.n	c04b69e <app_rot_hal_ioctl+0x52>
 c04b896:	bf00      	nop
 c04b898:	0c05e818 	.word	0x0c05e818
 c04b89c:	0c05ecac 	.word	0x0c05ecac
 c04b8a0:	0c05e810 	.word	0x0c05e810
 c04b8a4:	0c05e808 	.word	0x0c05e808
 c04b8a8:	0c05e800 	.word	0x0c05e800

0c04b8ac <app_rot_init>:
    }
}


enum tfm_app_rot_err_t app_rot_init(void)
{
 c04b8ac:	b570      	push	{r4, r5, r6, lr}
 c04b8ae:	b0b2      	sub	sp, #200	@ 0xc8
    psa_signal_t signals = 0;
    while (1) {
        signals = psa_wait(PSA_WAIT_ANY, PSA_BLOCK);
 c04b8b0:	f04f 4100 	mov.w	r1, #2147483648	@ 0x80000000
 c04b8b4:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 c04b8b8:	f7f0 ffa6 	bl	c03c808 <psa_wait>
        if (signals &  TFM_APP_ROT_IOCTL_SIGNAL) {
 c04b8bc:	06c3      	lsls	r3, r0, #27
 c04b8be:	d575      	bpl.n	c04b9ac <app_rot_init+0x100>
    status = psa_get(signal, &msg);
 c04b8c0:	2010      	movs	r0, #16
 c04b8c2:	a906      	add	r1, sp, #24
 c04b8c4:	f7f0 ffa2 	bl	c03c80c <psa_get>
    switch (msg.type) {
 c04b8c8:	9c06      	ldr	r4, [sp, #24]
 c04b8ca:	2c00      	cmp	r4, #0
 c04b8cc:	da04      	bge.n	c04b8d8 <app_rot_init+0x2c>
 c04b8ce:	3402      	adds	r4, #2
 c04b8d0:	da1d      	bge.n	c04b90e <app_rot_init+0x62>
        psa_reply(msg.handle, PSA_ERROR_NOT_SUPPORTED);
 c04b8d2:	f06f 0185 	mvn.w	r1, #133	@ 0x85
 c04b8d6:	e01b      	b.n	c04b910 <app_rot_init+0x64>
    switch (msg.type) {
 c04b8d8:	d1fb      	bne.n	c04b8d2 <app_rot_init+0x26>
    uint32_t in_len = PSA_MAX_IOVEC;
 c04b8da:	2504      	movs	r5, #4
    uint8_t input_buffer[INPUT_BUFFER_SIZE] = {0};
 c04b8dc:	223c      	movs	r2, #60	@ 0x3c
 c04b8de:	4621      	mov	r1, r4
 c04b8e0:	a813      	add	r0, sp, #76	@ 0x4c
    psa_invec invec = {0};
 c04b8e2:	e9cd 4402 	strd	r4, r4, [sp, #8]
    psa_outvec outvec = {0};
 c04b8e6:	e9cd 4404 	strd	r4, r4, [sp, #16]
    uint8_t input_buffer[INPUT_BUFFER_SIZE] = {0};
 c04b8ea:	9412      	str	r4, [sp, #72]	@ 0x48
 c04b8ec:	f00f ff1f 	bl	c05b72e <memset>
    uint8_t output_buffer[OUTPUT_BUFFER_SIZE] = {0};
 c04b8f0:	223c      	movs	r2, #60	@ 0x3c
 c04b8f2:	4621      	mov	r1, r4
 c04b8f4:	a823      	add	r0, sp, #140	@ 0x8c
 c04b8f6:	9422      	str	r4, [sp, #136]	@ 0x88
 c04b8f8:	f00f ff19 	bl	c05b72e <memset>
    tfm_app_rot_ioctl_req_t request = 0;
 c04b8fc:	9401      	str	r4, [sp, #4]
    while ((in_len > 0) && (msg->in_size[in_len - 1] == 0)) {
 c04b8fe:	ab0e      	add	r3, sp, #56	@ 0x38
 c04b900:	f853 1d04 	ldr.w	r1, [r3, #-4]!
 c04b904:	462a      	mov	r2, r5
 c04b906:	3d01      	subs	r5, #1
 c04b908:	b131      	cbz	r1, c04b918 <app_rot_init+0x6c>
 c04b90a:	4615      	mov	r5, r2
 c04b90c:	e006      	b.n	c04b91c <app_rot_init+0x70>
        psa_reply(msg.handle, PSA_SUCCESS);
 c04b90e:	2100      	movs	r1, #0
        psa_reply(msg.handle, PSA_ERROR_NOT_SUPPORTED);
 c04b910:	9807      	ldr	r0, [sp, #28]
 c04b912:	f7f0 ff81 	bl	c03c818 <psa_reply>
}
 c04b916:	e7cb      	b.n	c04b8b0 <app_rot_init+0x4>
    while ((in_len > 0) && (msg->in_size[in_len - 1] == 0)) {
 c04b918:	2d00      	cmp	r5, #0
 c04b91a:	d1f1      	bne.n	c04b900 <app_rot_init+0x54>
 c04b91c:	ab12      	add	r3, sp, #72	@ 0x48
    while ((out_len > 0) && (msg->out_size[out_len - 1] == 0)) {
 c04b91e:	2404      	movs	r4, #4
 c04b920:	461e      	mov	r6, r3
 c04b922:	f853 1d04 	ldr.w	r1, [r3, #-4]!
 c04b926:	4622      	mov	r2, r4
 c04b928:	3c01      	subs	r4, #1
 c04b92a:	b109      	cbz	r1, c04b930 <app_rot_init+0x84>
 c04b92c:	4614      	mov	r4, r2
 c04b92e:	e001      	b.n	c04b934 <app_rot_init+0x88>
 c04b930:	2c00      	cmp	r4, #0
 c04b932:	d1f6      	bne.n	c04b922 <app_rot_init+0x76>
    if ((in_len < 1) || (in_len > 2) ||
 c04b934:	1e6b      	subs	r3, r5, #1
 c04b936:	2b01      	cmp	r3, #1
 c04b938:	d836      	bhi.n	c04b9a8 <app_rot_init+0xfc>
 c04b93a:	2c01      	cmp	r4, #1
 c04b93c:	d834      	bhi.n	c04b9a8 <app_rot_init+0xfc>
    num = psa_read(msg->handle, 0, &request, sizeof(request));
 c04b93e:	2304      	movs	r3, #4
 c04b940:	2100      	movs	r1, #0
 c04b942:	9807      	ldr	r0, [sp, #28]
 c04b944:	eb0d 0203 	add.w	r2, sp, r3
 c04b948:	f7f0 ff62 	bl	c03c810 <psa_read>
    if (num != sizeof(request)) {
 c04b94c:	2804      	cmp	r0, #4
 c04b94e:	d003      	beq.n	c04b958 <app_rot_init+0xac>
        return (enum tfm_app_rot_err_t) PSA_ERROR_PROGRAMMER_ERROR;
 c04b950:	f06f 0580 	mvn.w	r5, #128	@ 0x80
        psa_reply(msg.handle, status);
 c04b954:	4629      	mov	r1, r5
 c04b956:	e7db      	b.n	c04b910 <app_rot_init+0x64>
    if (in_len > 1) {
 c04b958:	2d02      	cmp	r5, #2
 c04b95a:	d123      	bne.n	c04b9a4 <app_rot_init+0xf8>
        if (msg->in_size[1] > INPUT_BUFFER_SIZE) {
 c04b95c:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
        num = psa_read(msg->handle, 1, &input_buffer, msg->in_size[1]);
 c04b95e:	9807      	ldr	r0, [sp, #28]
        if (msg->in_size[1] > INPUT_BUFFER_SIZE) {
 c04b960:	2b40      	cmp	r3, #64	@ 0x40
 c04b962:	d8f5      	bhi.n	c04b950 <app_rot_init+0xa4>
        num = psa_read(msg->handle, 1, &input_buffer, msg->in_size[1]);
 c04b964:	4632      	mov	r2, r6
 c04b966:	2101      	movs	r1, #1
 c04b968:	f7f0 ff52 	bl	c03c810 <psa_read>
        if (num != msg->in_size[1]) {
 c04b96c:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 c04b96e:	4298      	cmp	r0, r3
 c04b970:	d1ee      	bne.n	c04b950 <app_rot_init+0xa4>
        invec.len = msg->in_size[1];
 c04b972:	e9cd 6002 	strd	r6, r0, [sp, #8]
        input = &invec;
 c04b976:	a902      	add	r1, sp, #8
    if (out_len > 0) {
 c04b978:	b134      	cbz	r4, c04b988 <app_rot_init+0xdc>
        if (msg->out_size[0] > OUTPUT_BUFFER_SIZE) {
 c04b97a:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
 c04b97c:	2b40      	cmp	r3, #64	@ 0x40
 c04b97e:	d8e7      	bhi.n	c04b950 <app_rot_init+0xa4>
        outvec.base = output_buffer;
 c04b980:	aa22      	add	r2, sp, #136	@ 0x88
        outvec.len = msg->out_size[0];
 c04b982:	e9cd 2304 	strd	r2, r3, [sp, #16]
        output = &outvec;
 c04b986:	ac04      	add	r4, sp, #16
    ret = app_rot_hal_ioctl(request, input, output);
 c04b988:	4622      	mov	r2, r4
 c04b98a:	9801      	ldr	r0, [sp, #4]
 c04b98c:	f7ff fe5e 	bl	c04b64c <app_rot_hal_ioctl>
 c04b990:	4605      	mov	r5, r0
    if (output != NULL) {
 c04b992:	2c00      	cmp	r4, #0
 c04b994:	d0de      	beq.n	c04b954 <app_rot_init+0xa8>
        psa_write(msg->handle, 0, outvec.base, outvec.len);
 c04b996:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 c04b99a:	2100      	movs	r1, #0
 c04b99c:	9807      	ldr	r0, [sp, #28]
 c04b99e:	f7f0 ff39 	bl	c03c814 <psa_write>
 c04b9a2:	e7d7      	b.n	c04b954 <app_rot_init+0xa8>
    void *input = NULL;
 c04b9a4:	2100      	movs	r1, #0
 c04b9a6:	e7e7      	b.n	c04b978 <app_rot_init+0xcc>
        return TFM_APP_ROT_ERROR;
 c04b9a8:	2501      	movs	r5, #1
 c04b9aa:	e7d3      	b.n	c04b954 <app_rot_init+0xa8>
            app_rot_signal_handle(TFM_APP_ROT_IOCTL_SIGNAL ,
                                   app_rot_ioctl_ipc);
        } else {
            Error_Handler();
 c04b9ac:	f006 ffdc 	bl	c052968 <Error_Handler>
 c04b9b0:	e77e      	b.n	c04b8b0 <app_rot_init+0x4>
	...

Disassembly of section .ER_TFM_CODE:

0c04b9c0 <__do_global_dtors_aux>:
 c04b9c0:	b510      	push	{r4, lr}
 c04b9c2:	4c05      	ldr	r4, [pc, #20]	@ (c04b9d8 <__do_global_dtors_aux+0x18>)
 c04b9c4:	7823      	ldrb	r3, [r4, #0]
 c04b9c6:	b933      	cbnz	r3, c04b9d6 <__do_global_dtors_aux+0x16>
 c04b9c8:	4b04      	ldr	r3, [pc, #16]	@ (c04b9dc <__do_global_dtors_aux+0x1c>)
 c04b9ca:	b113      	cbz	r3, c04b9d2 <__do_global_dtors_aux+0x12>
 c04b9cc:	4804      	ldr	r0, [pc, #16]	@ (c04b9e0 <__do_global_dtors_aux+0x20>)
 c04b9ce:	f3af 8000 	nop.w
 c04b9d2:	2301      	movs	r3, #1
 c04b9d4:	7023      	strb	r3, [r4, #0]
 c04b9d6:	bd10      	pop	{r4, pc}
 c04b9d8:	30030b30 	.word	0x30030b30
 c04b9dc:	00000000 	.word	0x00000000
 c04b9e0:	0c062078 	.word	0x0c062078

0c04b9e4 <frame_dummy>:
 c04b9e4:	b508      	push	{r3, lr}
 c04b9e6:	4b03      	ldr	r3, [pc, #12]	@ (c04b9f4 <frame_dummy+0x10>)
 c04b9e8:	b11b      	cbz	r3, c04b9f2 <frame_dummy+0xe>
 c04b9ea:	4903      	ldr	r1, [pc, #12]	@ (c04b9f8 <frame_dummy+0x14>)
 c04b9ec:	4803      	ldr	r0, [pc, #12]	@ (c04b9fc <frame_dummy+0x18>)
 c04b9ee:	f3af 8000 	nop.w
 c04b9f2:	bd08      	pop	{r3, pc}
 c04b9f4:	00000000 	.word	0x00000000
 c04b9f8:	30030b34 	.word	0x30030b34
 c04b9fc:	0c062078 	.word	0x0c062078

0c04ba00 <_stack_init>:
 c04ba00:	f5a3 3a80 	sub.w	sl, r3, #65536	@ 0x10000
 c04ba04:	4770      	bx	lr
 c04ba06:	bf00      	nop

0c04ba08 <_mainCRTStartup>:
 c04ba08:	4b17      	ldr	r3, [pc, #92]	@ (c04ba68 <_mainCRTStartup+0x60>)
 c04ba0a:	2b00      	cmp	r3, #0
 c04ba0c:	bf08      	it	eq
 c04ba0e:	4b13      	ldreq	r3, [pc, #76]	@ (c04ba5c <_mainCRTStartup+0x54>)
 c04ba10:	469d      	mov	sp, r3
 c04ba12:	f7ff fff5 	bl	c04ba00 <_stack_init>
 c04ba16:	2100      	movs	r1, #0
 c04ba18:	468b      	mov	fp, r1
 c04ba1a:	460f      	mov	r7, r1
 c04ba1c:	4813      	ldr	r0, [pc, #76]	@ (c04ba6c <_mainCRTStartup+0x64>)
 c04ba1e:	4a14      	ldr	r2, [pc, #80]	@ (c04ba70 <_mainCRTStartup+0x68>)
 c04ba20:	1a12      	subs	r2, r2, r0
 c04ba22:	f00f fe84 	bl	c05b72e <memset>
 c04ba26:	4b0e      	ldr	r3, [pc, #56]	@ (c04ba60 <_mainCRTStartup+0x58>)
 c04ba28:	2b00      	cmp	r3, #0
 c04ba2a:	d000      	beq.n	c04ba2e <_mainCRTStartup+0x26>
 c04ba2c:	4798      	blx	r3
 c04ba2e:	4b0d      	ldr	r3, [pc, #52]	@ (c04ba64 <_mainCRTStartup+0x5c>)
 c04ba30:	2b00      	cmp	r3, #0
 c04ba32:	d000      	beq.n	c04ba36 <_mainCRTStartup+0x2e>
 c04ba34:	4798      	blx	r3
 c04ba36:	2000      	movs	r0, #0
 c04ba38:	2100      	movs	r1, #0
 c04ba3a:	0004      	movs	r4, r0
 c04ba3c:	000d      	movs	r5, r1
 c04ba3e:	480d      	ldr	r0, [pc, #52]	@ (c04ba74 <_mainCRTStartup+0x6c>)
 c04ba40:	2800      	cmp	r0, #0
 c04ba42:	d002      	beq.n	c04ba4a <_mainCRTStartup+0x42>
 c04ba44:	480c      	ldr	r0, [pc, #48]	@ (c04ba78 <_mainCRTStartup+0x70>)
 c04ba46:	f3af 8000 	nop.w
 c04ba4a:	f7f6 fe01 	bl	c042650 <__libc_init_array>
 c04ba4e:	0020      	movs	r0, r4
 c04ba50:	0029      	movs	r1, r5
 c04ba52:	f010 f847 	bl	c05bae4 <main>
 c04ba56:	f7f6 fb3f 	bl	c0420d8 <exit>
 c04ba5a:	bf00      	nop
 c04ba5c:	00080000 	.word	0x00080000
	...
 c04ba68:	3003f200 	.word	0x3003f200
 c04ba6c:	30030b30 	.word	0x30030b30
 c04ba70:	3003e960 	.word	0x3003e960
	...

0c04ba7c <aes_set_key>:
{
    unsigned int i;

    AES_VALIDATE_RET( ctx != NULL );

    switch (keybits) {
 c04ba7c:	2ac0      	cmp	r2, #192	@ 0xc0
{
 c04ba7e:	b573      	push	{r0, r1, r4, r5, r6, lr}
 c04ba80:	4604      	mov	r4, r0
    switch (keybits) {
 c04ba82:	d055      	beq.n	c04bb30 <aes_set_key+0xb4>
 c04ba84:	d806      	bhi.n	c04ba94 <aes_set_key+0x18>
 c04ba86:	b16a      	cbz	r2, c04baa4 <aes_set_key+0x28>
 c04ba88:	2a80      	cmp	r2, #128	@ 0x80
 c04ba8a:	d009      	beq.n	c04baa0 <aes_set_key+0x24>
 c04ba8c:	f06f 001f 	mvn.w	r0, #31

    /* allow multi-instance of CRYP use: save context for CRYP HW module CR */
    ctx->ctx_save_cr = ctx->hcryp_aes.Instance->CR;

    return (0);
}
 c04ba90:	b002      	add	sp, #8
 c04ba92:	bd70      	pop	{r4, r5, r6, pc}
    switch (keybits) {
 c04ba94:	f5b2 7f80 	cmp.w	r2, #256	@ 0x100
 c04ba98:	d1f8      	bne.n	c04ba8c <aes_set_key+0x10>
            ctx->hcryp_aes.Init.KeySize = CRYP_KEYSIZE_256B;
 c04ba9a:	f44f 2380 	mov.w	r3, #262144	@ 0x40000
 c04ba9e:	e000      	b.n	c04baa2 <aes_set_key+0x26>
            ctx->hcryp_aes.Init.KeySize = CRYP_KEYSIZE_128B;;
 c04baa0:	2300      	movs	r3, #0
 c04baa2:	62e3      	str	r3, [r4, #44]	@ 0x2c
    for( i=0; i < (keybits/32); i++ )
 c04baa4:	2000      	movs	r0, #0
 c04baa6:	0955      	lsrs	r5, r2, #5
 c04baa8:	42a8      	cmp	r0, r5
 c04baaa:	f101 0104 	add.w	r1, r1, #4
 c04baae:	d116      	bne.n	c04bade <aes_set_key+0x62>
    ctx->hcryp_aes.Init.DataType = CRYP_BYTE_SWAP;
 c04bab0:	2304      	movs	r3, #4
 c04bab2:	4921      	ldr	r1, [pc, #132]	@ (c04bb38 <aes_set_key+0xbc>)
    if ( 0 == keybits )
 c04bab4:	fab2 f282 	clz	r2, r2
    ctx->hcryp_aes.Init.DataType = CRYP_BYTE_SWAP;
 c04bab8:	e9c4 1309 	strd	r1, r3, [r4, #36]	@ 0x24
    ctx->hcryp_aes.Init.DataWidthUnit = CRYP_DATAWIDTHUNIT_BYTE;
 c04babc:	2301      	movs	r3, #1
 c04babe:	64a3      	str	r3, [r4, #72]	@ 0x48
        ctx->hcryp_aes.Init.KeyMode = CRYP_KEYMODE_NORMAL;
 c04bac0:	2300      	movs	r3, #0
    if ( 0 == keybits )
 c04bac2:	0952      	lsrs	r2, r2, #5
 c04bac4:	0712      	lsls	r2, r2, #28
    if (HAL_CRYP_DeInit(&ctx->hcryp_aes) != HAL_OK) {
 c04bac6:	f104 0524 	add.w	r5, r4, #36	@ 0x24
 c04baca:	4628      	mov	r0, r5
    ctx->hcryp_aes.Init.pKey = ctx->aes_key;
 c04bacc:	6324      	str	r4, [r4, #48]	@ 0x30
        ctx->hcryp_aes.Init.KeyMode = CRYP_KEYMODE_NORMAL;
 c04bace:	6563      	str	r3, [r4, #84]	@ 0x54
        ctx->hcryp_aes.Init.KeySelect = CRYP_KEYSEL_HW;
 c04bad0:	65a2      	str	r2, [r4, #88]	@ 0x58
    if (HAL_CRYP_DeInit(&ctx->hcryp_aes) != HAL_OK) {
 c04bad2:	f7f1 f9fa 	bl	c03ceca <HAL_CRYP_DeInit>
 c04bad6:	b1a0      	cbz	r0, c04bb02 <aes_set_key+0x86>
        return (MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED);
 c04bad8:	f06f 006f 	mvn.w	r0, #111	@ 0x6f
 c04badc:	e7d8      	b.n	c04ba90 <aes_set_key+0x14>
        GET_UINT32_BE( ctx->aes_key[i], key, 4*i );
 c04bade:	f811 3c03 	ldrb.w	r3, [r1, #-3]
 c04bae2:	f811 6c04 	ldrb.w	r6, [r1, #-4]
 c04bae6:	041b      	lsls	r3, r3, #16
 c04bae8:	ea43 6306 	orr.w	r3, r3, r6, lsl #24
 c04baec:	f811 6c01 	ldrb.w	r6, [r1, #-1]
 c04baf0:	4333      	orrs	r3, r6
 c04baf2:	f811 6c02 	ldrb.w	r6, [r1, #-2]
 c04baf6:	ea43 2306 	orr.w	r3, r3, r6, lsl #8
 c04bafa:	f844 3020 	str.w	r3, [r4, r0, lsl #2]
    for( i=0; i < (keybits/32); i++ )
 c04bafe:	3001      	adds	r0, #1
 c04bb00:	e7d2      	b.n	c04baa8 <aes_set_key+0x2c>
    __HAL_RCC_SAES_CLK_ENABLE();
 c04bb02:	4b0e      	ldr	r3, [pc, #56]	@ (c04bb3c <aes_set_key+0xc0>)
    if (HAL_CRYP_Init(&ctx->hcryp_aes) != HAL_OK) {
 c04bb04:	4628      	mov	r0, r5
    __HAL_RCC_SAES_CLK_ENABLE();
 c04bb06:	f8d3 208c 	ldr.w	r2, [r3, #140]	@ 0x8c
 c04bb0a:	f442 1280 	orr.w	r2, r2, #1048576	@ 0x100000
 c04bb0e:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
 c04bb12:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 c04bb16:	f403 1380 	and.w	r3, r3, #1048576	@ 0x100000
 c04bb1a:	9301      	str	r3, [sp, #4]
 c04bb1c:	9b01      	ldr	r3, [sp, #4]
    if (HAL_CRYP_Init(&ctx->hcryp_aes) != HAL_OK) {
 c04bb1e:	f7f1 f97b 	bl	c03ce18 <HAL_CRYP_Init>
 c04bb22:	2800      	cmp	r0, #0
 c04bb24:	d1d8      	bne.n	c04bad8 <aes_set_key+0x5c>
    ctx->ctx_save_cr = ctx->hcryp_aes.Instance->CR;
 c04bb26:	6a63      	ldr	r3, [r4, #36]	@ 0x24
 c04bb28:	681b      	ldr	r3, [r3, #0]
 c04bb2a:	f8c4 308c 	str.w	r3, [r4, #140]	@ 0x8c
    return (0);
 c04bb2e:	e7af      	b.n	c04ba90 <aes_set_key+0x14>
            return (MBEDTLS_ERR_PLATFORM_FEATURE_UNSUPPORTED);
 c04bb30:	f06f 0071 	mvn.w	r0, #113	@ 0x71
 c04bb34:	e7ac      	b.n	c04ba90 <aes_set_key+0x14>
 c04bb36:	bf00      	nop
 c04bb38:	520c0c00 	.word	0x520c0c00
 c04bb3c:	56020c00 	.word	0x56020c00

0c04bb40 <mbedtls_aes_init>:
        *p++ = 0;
    }
}

void mbedtls_aes_init(mbedtls_aes_context *ctx)
{
 c04bb40:	b510      	push	{r4, lr}
    AES_VALIDATE( ctx != NULL );

    memset(ctx, 0, sizeof(mbedtls_aes_context));
 c04bb42:	2290      	movs	r2, #144	@ 0x90
 c04bb44:	2100      	movs	r1, #0
{
 c04bb46:	4604      	mov	r4, r0
    memset(ctx, 0, sizeof(mbedtls_aes_context));
 c04bb48:	f00f fdf1 	bl	c05b72e <memset>

    ctx->Algorithm = ST_AES_NO_ALGO;
 c04bb4c:	f64f 73ff 	movw	r3, #65535	@ 0xffff
 c04bb50:	6223      	str	r3, [r4, #32]
}
 c04bb52:	bd10      	pop	{r4, pc}

0c04bb54 <mbedtls_aes_free>:


void mbedtls_aes_free(mbedtls_aes_context *ctx)
{
    if (ctx == NULL) {
 c04bb54:	b138      	cbz	r0, c04bb66 <mbedtls_aes_free+0x12>
        *p++ = 0;
 c04bb56:	2100      	movs	r1, #0
 c04bb58:	f100 0390 	add.w	r3, r0, #144	@ 0x90
 c04bb5c:	4602      	mov	r2, r0
 c04bb5e:	3001      	adds	r0, #1
    while (n--) {
 c04bb60:	4283      	cmp	r3, r0
        *p++ = 0;
 c04bb62:	7011      	strb	r1, [r2, #0]
    while (n--) {
 c04bb64:	d1fa      	bne.n	c04bb5c <mbedtls_aes_free+0x8>
        return;
    }

    mbedtls_zeroize(ctx, sizeof(mbedtls_aes_context));
}
 c04bb66:	4770      	bx	lr

0c04bb68 <mbedtls_aes_setkey_enc>:
 * AES key schedule (encryption)
 */
int mbedtls_aes_setkey_enc(mbedtls_aes_context *ctx, const unsigned char *key,
                           unsigned int keybits)
{
    return (aes_set_key(ctx, key, keybits));
 c04bb68:	f7ff bf88 	b.w	c04ba7c <aes_set_key>

0c04bb6c <mbedtls_aes_setkey_dec>:
}

/*
 * AES key schedule (decryption)
 */
int mbedtls_aes_setkey_dec(mbedtls_aes_context *ctx, const unsigned char *key,
 c04bb6c:	f7ff bf86 	b.w	c04ba7c <aes_set_key>

0c04bb70 <mbedtls_aes_crypt_cbc>:
                          int mode,
                          size_t length,
                          unsigned char iv[16],
                          const unsigned char *input,
                          unsigned char *output)
{
 c04bb70:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
 c04bb74:	461d      	mov	r5, r3
 c04bb76:	e9dd a60a 	ldrd	sl, r6, [sp, #40]	@ 0x28
                      mode == MBEDTLS_AES_DECRYPT );
    AES_VALIDATE_RET( iv != NULL );
    AES_VALIDATE_RET( input != NULL );
    AES_VALIDATE_RET( output != NULL );

    if (length % 16) {
 c04bb7a:	0713      	lsls	r3, r2, #28
{
 c04bb7c:	4604      	mov	r4, r0
 c04bb7e:	4689      	mov	r9, r1
 c04bb80:	4617      	mov	r7, r2
    if (length % 16) {
 c04bb82:	f040 8091 	bne.w	c04bca8 <mbedtls_aes_crypt_cbc+0x138>
    ctx->hcryp_aes.Instance->CR = ctx->ctx_save_cr;
 c04bb86:	6a43      	ldr	r3, [r0, #36]	@ 0x24
 c04bb88:	f8d0 208c 	ldr.w	r2, [r0, #140]	@ 0x8c
    if (HAL_CRYP_DeInit(&ctx->hcryp_aes) != HAL_OK) {
 c04bb8c:	f100 0824 	add.w	r8, r0, #36	@ 0x24
 c04bb90:	4640      	mov	r0, r8
    ctx->hcryp_aes.Instance->CR = ctx->ctx_save_cr;
 c04bb92:	601a      	str	r2, [r3, #0]
    if (HAL_CRYP_DeInit(&ctx->hcryp_aes) != HAL_OK) {
 c04bb94:	f7f1 f999 	bl	c03ceca <HAL_CRYP_DeInit>
 c04bb98:	b120      	cbz	r0, c04bba4 <mbedtls_aes_crypt_cbc+0x34>
        return (MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED);
 c04bb9a:	f06f 006f 	mvn.w	r0, #111	@ 0x6f
    /* Save the internal IV vector for multi context purpose */
    ctx->ctx_save_cr = ctx->hcryp_aes.Instance->CR; // save here before overwritten
    ctx->hcryp_aes.Instance->CR &= ~AES_CR_EN;

    return (0);
}
 c04bb9e:	b002      	add	sp, #8
 c04bba0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if (HAL_CRYP_Init(&ctx->hcryp_aes) != HAL_OK) {
 c04bba4:	4640      	mov	r0, r8
 c04bba6:	f7f1 f937 	bl	c03ce18 <HAL_CRYP_Init>
 c04bbaa:	2800      	cmp	r0, #0
 c04bbac:	d1f5      	bne.n	c04bb9a <mbedtls_aes_crypt_cbc+0x2a>
    if (CRYP_AES_CBC != ctx->Algorithm)
 c04bbae:	6a23      	ldr	r3, [r4, #32]
    if (HAL_CRYP_SetConfig(&ctx->hcryp_aes, &ctx->hcryp_aes.Init) != HAL_OK) {
 c04bbb0:	4640      	mov	r0, r8
    if (CRYP_AES_CBC != ctx->Algorithm)
 c04bbb2:	2b20      	cmp	r3, #32
        ctx->hcryp_aes.Init.Algorithm = ctx->Algorithm = CRYP_AES_CBC;
 c04bbb4:	bf1e      	ittt	ne
 c04bbb6:	2320      	movne	r3, #32
 c04bbb8:	6223      	strne	r3, [r4, #32]
 c04bbba:	63a3      	strne	r3, [r4, #56]	@ 0x38
    GET_UINT32_BE(iv_32B[0],iv,0);
 c04bbbc:	682a      	ldr	r2, [r5, #0]
 c04bbbe:	4b3c      	ldr	r3, [pc, #240]	@ (c04bcb0 <mbedtls_aes_crypt_cbc+0x140>)
 c04bbc0:	ba12      	rev	r2, r2
 c04bbc2:	601a      	str	r2, [r3, #0]
    GET_UINT32_BE(iv_32B[1],iv,4);
 c04bbc4:	686a      	ldr	r2, [r5, #4]
    if (HAL_CRYP_SetConfig(&ctx->hcryp_aes, &ctx->hcryp_aes.Init) != HAL_OK) {
 c04bbc6:	f104 0128 	add.w	r1, r4, #40	@ 0x28
 c04bbca:	ba12      	rev	r2, r2
    GET_UINT32_BE(iv_32B[1],iv,4);
 c04bbcc:	605a      	str	r2, [r3, #4]
    GET_UINT32_BE(iv_32B[2],iv,8);
 c04bbce:	68aa      	ldr	r2, [r5, #8]
 c04bbd0:	ba12      	rev	r2, r2
 c04bbd2:	609a      	str	r2, [r3, #8]
    GET_UINT32_BE(iv_32B[3],iv,12);
 c04bbd4:	68ea      	ldr	r2, [r5, #12]
    ctx->hcryp_aes.Init.pInitVect = iv_32B;
 c04bbd6:	6363      	str	r3, [r4, #52]	@ 0x34
 c04bbd8:	ba12      	rev	r2, r2
    GET_UINT32_BE(iv_32B[3],iv,12);
 c04bbda:	60da      	str	r2, [r3, #12]
    if (HAL_CRYP_SetConfig(&ctx->hcryp_aes, &ctx->hcryp_aes.Init) != HAL_OK) {
 c04bbdc:	f7f1 f8b0 	bl	c03cd40 <HAL_CRYP_SetConfig>
 c04bbe0:	2800      	cmp	r0, #0
 c04bbe2:	d1da      	bne.n	c04bb9a <mbedtls_aes_crypt_cbc+0x2a>
    if (mode == MBEDTLS_AES_DECRYPT) {
 c04bbe4:	23ff      	movs	r3, #255	@ 0xff
        if (HAL_CRYP_Decrypt(&ctx->hcryp_aes, (uint32_t *)input, length, (uint32_t *)output, ST_AES_TIMEOUT) != HAL_OK) {
 c04bbe6:	4651      	mov	r1, sl
 c04bbe8:	9300      	str	r3, [sp, #0]
 c04bbea:	4640      	mov	r0, r8
 c04bbec:	4633      	mov	r3, r6
 c04bbee:	b2ba      	uxth	r2, r7
    if (mode == MBEDTLS_AES_DECRYPT) {
 c04bbf0:	f1b9 0f00 	cmp.w	r9, #0
 c04bbf4:	d149      	bne.n	c04bc8a <mbedtls_aes_crypt_cbc+0x11a>
        if (HAL_CRYP_Decrypt(&ctx->hcryp_aes, (uint32_t *)input, length, (uint32_t *)output, ST_AES_TIMEOUT) != HAL_OK) {
 c04bbf6:	f7f1 fc8d 	bl	c03d514 <HAL_CRYP_Decrypt>
 c04bbfa:	2800      	cmp	r0, #0
 c04bbfc:	d1cd      	bne.n	c04bb9a <mbedtls_aes_crypt_cbc+0x2a>
        PUT_UINT32_BE(ctx->hcryp_aes.Instance->IVR3,iv,0);
 c04bbfe:	6a63      	ldr	r3, [r4, #36]	@ 0x24
 c04bc00:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 c04bc02:	0e1b      	lsrs	r3, r3, #24
 c04bc04:	702b      	strb	r3, [r5, #0]
 c04bc06:	6a63      	ldr	r3, [r4, #36]	@ 0x24
 c04bc08:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 c04bc0a:	0c1b      	lsrs	r3, r3, #16
 c04bc0c:	706b      	strb	r3, [r5, #1]
 c04bc0e:	6a63      	ldr	r3, [r4, #36]	@ 0x24
 c04bc10:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 c04bc12:	0a1b      	lsrs	r3, r3, #8
 c04bc14:	70ab      	strb	r3, [r5, #2]
 c04bc16:	6a63      	ldr	r3, [r4, #36]	@ 0x24
 c04bc18:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 c04bc1a:	70eb      	strb	r3, [r5, #3]
        PUT_UINT32_BE(ctx->hcryp_aes.Instance->IVR2,iv,4);
 c04bc1c:	6a63      	ldr	r3, [r4, #36]	@ 0x24
 c04bc1e:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 c04bc20:	0e1b      	lsrs	r3, r3, #24
 c04bc22:	712b      	strb	r3, [r5, #4]
 c04bc24:	6a63      	ldr	r3, [r4, #36]	@ 0x24
 c04bc26:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 c04bc28:	0c1b      	lsrs	r3, r3, #16
 c04bc2a:	716b      	strb	r3, [r5, #5]
 c04bc2c:	6a63      	ldr	r3, [r4, #36]	@ 0x24
 c04bc2e:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 c04bc30:	0a1b      	lsrs	r3, r3, #8
 c04bc32:	71ab      	strb	r3, [r5, #6]
 c04bc34:	6a63      	ldr	r3, [r4, #36]	@ 0x24
 c04bc36:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 c04bc38:	71eb      	strb	r3, [r5, #7]
        PUT_UINT32_BE(ctx->hcryp_aes.Instance->IVR1,iv,8);
 c04bc3a:	6a63      	ldr	r3, [r4, #36]	@ 0x24
 c04bc3c:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 c04bc3e:	0e1b      	lsrs	r3, r3, #24
 c04bc40:	722b      	strb	r3, [r5, #8]
 c04bc42:	6a63      	ldr	r3, [r4, #36]	@ 0x24
 c04bc44:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 c04bc46:	0c1b      	lsrs	r3, r3, #16
 c04bc48:	726b      	strb	r3, [r5, #9]
 c04bc4a:	6a63      	ldr	r3, [r4, #36]	@ 0x24
 c04bc4c:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 c04bc4e:	0a1b      	lsrs	r3, r3, #8
 c04bc50:	72ab      	strb	r3, [r5, #10]
 c04bc52:	6a63      	ldr	r3, [r4, #36]	@ 0x24
 c04bc54:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 c04bc56:	72eb      	strb	r3, [r5, #11]
        PUT_UINT32_BE(ctx->hcryp_aes.Instance->IVR0,iv,12);
 c04bc58:	6a63      	ldr	r3, [r4, #36]	@ 0x24
 c04bc5a:	6a1b      	ldr	r3, [r3, #32]
 c04bc5c:	0e1b      	lsrs	r3, r3, #24
 c04bc5e:	732b      	strb	r3, [r5, #12]
 c04bc60:	6a63      	ldr	r3, [r4, #36]	@ 0x24
 c04bc62:	6a1b      	ldr	r3, [r3, #32]
 c04bc64:	0c1b      	lsrs	r3, r3, #16
 c04bc66:	736b      	strb	r3, [r5, #13]
 c04bc68:	6a63      	ldr	r3, [r4, #36]	@ 0x24
 c04bc6a:	6a1b      	ldr	r3, [r3, #32]
 c04bc6c:	0a1b      	lsrs	r3, r3, #8
 c04bc6e:	73ab      	strb	r3, [r5, #14]
 c04bc70:	6a63      	ldr	r3, [r4, #36]	@ 0x24
 c04bc72:	6a1b      	ldr	r3, [r3, #32]
 c04bc74:	73eb      	strb	r3, [r5, #15]
    ctx->ctx_save_cr = ctx->hcryp_aes.Instance->CR; // save here before overwritten
 c04bc76:	6a63      	ldr	r3, [r4, #36]	@ 0x24
    return (0);
 c04bc78:	2000      	movs	r0, #0
    ctx->ctx_save_cr = ctx->hcryp_aes.Instance->CR; // save here before overwritten
 c04bc7a:	681a      	ldr	r2, [r3, #0]
 c04bc7c:	f8c4 208c 	str.w	r2, [r4, #140]	@ 0x8c
    ctx->hcryp_aes.Instance->CR &= ~AES_CR_EN;
 c04bc80:	681a      	ldr	r2, [r3, #0]
 c04bc82:	f022 0201 	bic.w	r2, r2, #1
 c04bc86:	601a      	str	r2, [r3, #0]
    return (0);
 c04bc88:	e789      	b.n	c04bb9e <mbedtls_aes_crypt_cbc+0x2e>
        if (HAL_CRYP_Encrypt(&ctx->hcryp_aes, (uint32_t *)input, length, (uint32_t *)output, ST_AES_TIMEOUT) != HAL_OK) {
 c04bc8a:	f7f1 fb73 	bl	c03d374 <HAL_CRYP_Encrypt>
 c04bc8e:	2800      	cmp	r0, #0
 c04bc90:	d183      	bne.n	c04bb9a <mbedtls_aes_crypt_cbc+0x2a>
        memcpy(iv, &output[length - 16], 16);
 c04bc92:	3f10      	subs	r7, #16
 c04bc94:	19f3      	adds	r3, r6, r7
 c04bc96:	f103 0210 	add.w	r2, r3, #16
 c04bc9a:	f853 1b04 	ldr.w	r1, [r3], #4
 c04bc9e:	4293      	cmp	r3, r2
 c04bca0:	f845 1b04 	str.w	r1, [r5], #4
 c04bca4:	d1f9      	bne.n	c04bc9a <mbedtls_aes_crypt_cbc+0x12a>
 c04bca6:	e7e6      	b.n	c04bc76 <mbedtls_aes_crypt_cbc+0x106>
        return (MBEDTLS_ERR_AES_INVALID_INPUT_LENGTH);
 c04bca8:	f06f 0021 	mvn.w	r0, #33	@ 0x21
 c04bcac:	e777      	b.n	c04bb9e <mbedtls_aes_crypt_cbc+0x2e>
 c04bcae:	bf00      	nop
 c04bcb0:	30030b4c 	.word	0x30030b4c

0c04bcb4 <mbedtls_internal_aes_encrypt>:
#endif /* MBEDTLS_CIPHER_MODE_CTR */

int mbedtls_internal_aes_encrypt(mbedtls_aes_context *ctx,
                                 const unsigned char input[16],
                                 unsigned char output[16])
{
 c04bcb4:	b507      	push	{r0, r1, r2, lr}
 c04bcb6:	4613      	mov	r3, r2

    if (HAL_CRYP_Encrypt(&ctx->hcryp_aes, (uint32_t *)input, 16, (uint32_t *)output, ST_AES_TIMEOUT) != HAL_OK) {
 c04bcb8:	22ff      	movs	r2, #255	@ 0xff
 c04bcba:	3024      	adds	r0, #36	@ 0x24
 c04bcbc:	9200      	str	r2, [sp, #0]
 c04bcbe:	2210      	movs	r2, #16
 c04bcc0:	f7f1 fb58 	bl	c03d374 <HAL_CRYP_Encrypt>
        return (MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED);
    }
    return (0);
 c04bcc4:	2800      	cmp	r0, #0

}
 c04bcc6:	bf14      	ite	ne
 c04bcc8:	f06f 006f 	mvnne.w	r0, #111	@ 0x6f
 c04bccc:	2000      	moveq	r0, #0
 c04bcce:	b003      	add	sp, #12
 c04bcd0:	f85d fb04 	ldr.w	pc, [sp], #4

0c04bcd4 <mbedtls_internal_aes_decrypt>:

int mbedtls_internal_aes_decrypt(mbedtls_aes_context *ctx,
                                 const unsigned char input[16],
                                 unsigned char output[16])
{
 c04bcd4:	b507      	push	{r0, r1, r2, lr}
 c04bcd6:	4613      	mov	r3, r2
    if (HAL_CRYP_Decrypt(&ctx->hcryp_aes, (uint32_t *)input, 16, (uint32_t *)output, ST_AES_TIMEOUT) != HAL_OK) {
 c04bcd8:	22ff      	movs	r2, #255	@ 0xff
 c04bcda:	3024      	adds	r0, #36	@ 0x24
 c04bcdc:	9200      	str	r2, [sp, #0]
 c04bcde:	2210      	movs	r2, #16
 c04bce0:	f7f1 fc18 	bl	c03d514 <HAL_CRYP_Decrypt>
        return MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED;
    }
    return (0);
 c04bce4:	2800      	cmp	r0, #0
}
 c04bce6:	bf14      	ite	ne
 c04bce8:	f06f 006f 	mvnne.w	r0, #111	@ 0x6f
 c04bcec:	2000      	moveq	r0, #0
 c04bcee:	b003      	add	sp, #12
 c04bcf0:	f85d fb04 	ldr.w	pc, [sp], #4

0c04bcf4 <mbedtls_aes_crypt_ecb>:
{
 c04bcf4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 c04bcf6:	4615      	mov	r5, r2
 c04bcf8:	461e      	mov	r6, r3
    ctx->hcryp_aes.Instance->CR = ctx->ctx_save_cr;
 c04bcfa:	f8d0 208c 	ldr.w	r2, [r0, #140]	@ 0x8c
 c04bcfe:	6a43      	ldr	r3, [r0, #36]	@ 0x24
{
 c04bd00:	4604      	mov	r4, r0
    ctx->hcryp_aes.Instance->CR = ctx->ctx_save_cr;
 c04bd02:	601a      	str	r2, [r3, #0]
    if (CRYP_AES_ECB != ctx->Algorithm)
 c04bd04:	6a03      	ldr	r3, [r0, #32]
{
 c04bd06:	460f      	mov	r7, r1
    if (CRYP_AES_ECB != ctx->Algorithm)
 c04bd08:	b933      	cbnz	r3, c04bd18 <mbedtls_aes_crypt_ecb+0x24>
    if (mode == MBEDTLS_AES_DECRYPT) { /* AES decryption */
 c04bd0a:	b197      	cbz	r7, c04bd32 <mbedtls_aes_crypt_ecb+0x3e>
        ret = mbedtls_internal_aes_encrypt(ctx, input, output);
 c04bd0c:	4632      	mov	r2, r6
 c04bd0e:	4629      	mov	r1, r5
 c04bd10:	4620      	mov	r0, r4
 c04bd12:	f7ff ffcf 	bl	c04bcb4 <mbedtls_internal_aes_encrypt>
 c04bd16:	e011      	b.n	c04bd3c <mbedtls_aes_crypt_ecb+0x48>
        ctx->hcryp_aes.Init.Algorithm = ctx->Algorithm = CRYP_AES_ECB;
 c04bd18:	2300      	movs	r3, #0
        if (HAL_CRYP_SetConfig(&ctx->hcryp_aes, &ctx->hcryp_aes.Init) != HAL_OK)
 c04bd1a:	f100 0128 	add.w	r1, r0, #40	@ 0x28
        ctx->hcryp_aes.Init.Algorithm = ctx->Algorithm = CRYP_AES_ECB;
 c04bd1e:	6203      	str	r3, [r0, #32]
 c04bd20:	6383      	str	r3, [r0, #56]	@ 0x38
        if (HAL_CRYP_SetConfig(&ctx->hcryp_aes, &ctx->hcryp_aes.Init) != HAL_OK)
 c04bd22:	3024      	adds	r0, #36	@ 0x24
 c04bd24:	f7f1 f80c 	bl	c03cd40 <HAL_CRYP_SetConfig>
 c04bd28:	2800      	cmp	r0, #0
 c04bd2a:	d0ee      	beq.n	c04bd0a <mbedtls_aes_crypt_ecb+0x16>
            return MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED;
 c04bd2c:	f06f 006f 	mvn.w	r0, #111	@ 0x6f
 c04bd30:	e00a      	b.n	c04bd48 <mbedtls_aes_crypt_ecb+0x54>
        ret = mbedtls_internal_aes_decrypt(ctx, input, output);
 c04bd32:	4632      	mov	r2, r6
 c04bd34:	4629      	mov	r1, r5
 c04bd36:	4620      	mov	r0, r4
 c04bd38:	f7ff ffcc 	bl	c04bcd4 <mbedtls_internal_aes_decrypt>
        if( ret != 0 )
 c04bd3c:	b920      	cbnz	r0, c04bd48 <mbedtls_aes_crypt_ecb+0x54>
    return (0);
 c04bd3e:	2000      	movs	r0, #0
    ctx->ctx_save_cr = ctx->hcryp_aes.Instance->CR;
 c04bd40:	6a63      	ldr	r3, [r4, #36]	@ 0x24
 c04bd42:	681b      	ldr	r3, [r3, #0]
 c04bd44:	f8c4 308c 	str.w	r3, [r4, #140]	@ 0x8c
}
 c04bd48:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0c04bd4a <mbedtls_aes_crypt_cfb128>:
{
 c04bd4a:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 c04bd4e:	f8dd 9028 	ldr.w	r9, [sp, #40]	@ 0x28
 c04bd52:	e9dd a508 	ldrd	sl, r5, [sp, #32]
 c04bd56:	4680      	mov	r8, r0
 c04bd58:	461e      	mov	r6, r3
    n = *iv_off;
 c04bd5a:	681c      	ldr	r4, [r3, #0]
    if (mode == MBEDTLS_AES_DECRYPT) {
 c04bd5c:	18af      	adds	r7, r5, r2
 c04bd5e:	b1e1      	cbz	r1, c04bd9a <mbedtls_aes_crypt_cfb128+0x50>
        while (length--) {
 c04bd60:	42bd      	cmp	r5, r7
 c04bd62:	d01c      	beq.n	c04bd9e <mbedtls_aes_crypt_cfb128+0x54>
            if (n == 0) {
 c04bd64:	b344      	cbz	r4, c04bdb8 <mbedtls_aes_crypt_cfb128+0x6e>
            iv[n] = *output++ = (unsigned char)(iv[n] ^ *input++);
 c04bd66:	f81a 3004 	ldrb.w	r3, [sl, r4]
 c04bd6a:	f815 2b01 	ldrb.w	r2, [r5], #1
 c04bd6e:	4053      	eors	r3, r2
 c04bd70:	f809 3b01 	strb.w	r3, [r9], #1
 c04bd74:	f80a 3004 	strb.w	r3, [sl, r4]
            n = (n + 1) & 0x0F;
 c04bd78:	3401      	adds	r4, #1
 c04bd7a:	f004 040f 	and.w	r4, r4, #15
 c04bd7e:	e7ef      	b.n	c04bd60 <mbedtls_aes_crypt_cfb128+0x16>
            if (n == 0) {
 c04bd80:	b184      	cbz	r4, c04bda4 <mbedtls_aes_crypt_cfb128+0x5a>
            *output++ = (unsigned char)(c ^ iv[n]);
 c04bd82:	f81a 3004 	ldrb.w	r3, [sl, r4]
            c = *input++;
 c04bd86:	f815 2b01 	ldrb.w	r2, [r5], #1
            *output++ = (unsigned char)(c ^ iv[n]);
 c04bd8a:	4053      	eors	r3, r2
 c04bd8c:	f809 3b01 	strb.w	r3, [r9], #1
            iv[n] = (unsigned char) c;
 c04bd90:	f80a 2004 	strb.w	r2, [sl, r4]
            n = (n + 1) & 0x0F;
 c04bd94:	3401      	adds	r4, #1
 c04bd96:	f004 040f 	and.w	r4, r4, #15
        while (length--) {
 c04bd9a:	42bd      	cmp	r5, r7
 c04bd9c:	d1f0      	bne.n	c04bd80 <mbedtls_aes_crypt_cfb128+0x36>
    return (0);
 c04bd9e:	2000      	movs	r0, #0
    *iv_off = n;
 c04bda0:	6034      	str	r4, [r6, #0]
    return (0);
 c04bda2:	e007      	b.n	c04bdb4 <mbedtls_aes_crypt_cfb128+0x6a>
                ret = mbedtls_aes_crypt_ecb(ctx, MBEDTLS_AES_ENCRYPT, iv, iv);
 c04bda4:	4653      	mov	r3, sl
 c04bda6:	4652      	mov	r2, sl
 c04bda8:	2101      	movs	r1, #1
 c04bdaa:	4640      	mov	r0, r8
 c04bdac:	f7ff ffa2 	bl	c04bcf4 <mbedtls_aes_crypt_ecb>
                if (ret != 0)
 c04bdb0:	2800      	cmp	r0, #0
 c04bdb2:	d0e6      	beq.n	c04bd82 <mbedtls_aes_crypt_cfb128+0x38>
}
 c04bdb4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
                ret = mbedtls_aes_crypt_ecb(ctx, MBEDTLS_AES_ENCRYPT, iv, iv);
 c04bdb8:	4653      	mov	r3, sl
 c04bdba:	4652      	mov	r2, sl
 c04bdbc:	2101      	movs	r1, #1
 c04bdbe:	4640      	mov	r0, r8
 c04bdc0:	f7ff ff98 	bl	c04bcf4 <mbedtls_aes_crypt_ecb>
                if (ret != 0)
 c04bdc4:	2800      	cmp	r0, #0
 c04bdc6:	d0ce      	beq.n	c04bd66 <mbedtls_aes_crypt_cfb128+0x1c>
 c04bdc8:	e7f4      	b.n	c04bdb4 <mbedtls_aes_crypt_cfb128+0x6a>

0c04bdca <mbedtls_aes_crypt_ofb>:
{
 c04bdca:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    n = *iv_off;
 c04bdce:	6814      	ldr	r4, [r2, #0]
{
 c04bdd0:	4680      	mov	r8, r0
 c04bdd2:	e9dd 7908 	ldrd	r7, r9, [sp, #32]
    if( n > 15 )
 c04bdd6:	2c0f      	cmp	r4, #15
{
 c04bdd8:	4616      	mov	r6, r2
 c04bdda:	469a      	mov	sl, r3
    if( n > 15 )
 c04bddc:	d81b      	bhi.n	c04be16 <mbedtls_aes_crypt_ofb+0x4c>
 c04bdde:	187d      	adds	r5, r7, r1
    while( length-- )
 c04bde0:	42af      	cmp	r7, r5
 c04bde2:	d102      	bne.n	c04bdea <mbedtls_aes_crypt_ofb+0x20>
    *iv_off = n;
 c04bde4:	2000      	movs	r0, #0
 c04bde6:	6034      	str	r4, [r6, #0]
 c04bde8:	e013      	b.n	c04be12 <mbedtls_aes_crypt_ofb+0x48>
        if( n == 0 )
 c04bdea:	b154      	cbz	r4, c04be02 <mbedtls_aes_crypt_ofb+0x38>
        *output++ =  *input++ ^ iv[n];
 c04bdec:	f81a 3004 	ldrb.w	r3, [sl, r4]
 c04bdf0:	f817 2b01 	ldrb.w	r2, [r7], #1
        n = ( n + 1 ) & 0x0F;
 c04bdf4:	3401      	adds	r4, #1
        *output++ =  *input++ ^ iv[n];
 c04bdf6:	4053      	eors	r3, r2
 c04bdf8:	f809 3b01 	strb.w	r3, [r9], #1
        n = ( n + 1 ) & 0x0F;
 c04bdfc:	f004 040f 	and.w	r4, r4, #15
 c04be00:	e7ee      	b.n	c04bde0 <mbedtls_aes_crypt_ofb+0x16>
            ret = mbedtls_aes_crypt_ecb( ctx, MBEDTLS_AES_ENCRYPT, iv, iv );
 c04be02:	4653      	mov	r3, sl
 c04be04:	4652      	mov	r2, sl
 c04be06:	2101      	movs	r1, #1
 c04be08:	4640      	mov	r0, r8
 c04be0a:	f7ff ff73 	bl	c04bcf4 <mbedtls_aes_crypt_ecb>
            if( ret != 0 )
 c04be0e:	2800      	cmp	r0, #0
 c04be10:	d0ec      	beq.n	c04bdec <mbedtls_aes_crypt_ofb+0x22>
}
 c04be12:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        return( MBEDTLS_ERR_AES_BAD_INPUT_DATA );
 c04be16:	f06f 0020 	mvn.w	r0, #32
 c04be1a:	e7fa      	b.n	c04be12 <mbedtls_aes_crypt_ofb+0x48>

0c04be1c <mbedtls_aes_crypt_ctr>:
{
 c04be1c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c04be20:	4681      	mov	r9, r0
 c04be22:	e9dd 7b0b 	ldrd	r7, fp, [sp, #44]	@ 0x2c
 c04be26:	4616      	mov	r6, r2
 c04be28:	469a      	mov	sl, r3
    n = *nc_off;
 c04be2a:	6814      	ldr	r4, [r2, #0]
    while (length--) {
 c04be2c:	eb07 0801 	add.w	r8, r7, r1
 c04be30:	45b8      	cmp	r8, r7
 c04be32:	d103      	bne.n	c04be3c <mbedtls_aes_crypt_ctr+0x20>
    return (0);
 c04be34:	2000      	movs	r0, #0
    *nc_off = n;
 c04be36:	6034      	str	r4, [r6, #0]
}
 c04be38:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if (n == 0) {
 c04be3c:	b984      	cbnz	r4, c04be60 <mbedtls_aes_crypt_ctr+0x44>
            if (mbedtls_aes_crypt_ecb(ctx, MBEDTLS_AES_ENCRYPT, nonce_counter, stream_block) != 0) {
 c04be3e:	4652      	mov	r2, sl
 c04be40:	2101      	movs	r1, #1
 c04be42:	4648      	mov	r0, r9
 c04be44:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 c04be46:	f7ff ff55 	bl	c04bcf4 <mbedtls_aes_crypt_ecb>
 c04be4a:	b9a0      	cbnz	r0, c04be76 <mbedtls_aes_crypt_ctr+0x5a>
 c04be4c:	f10a 0310 	add.w	r3, sl, #16
                if (++nonce_counter[i - 1] != 0) {
 c04be50:	f813 5d01 	ldrb.w	r5, [r3, #-1]!
 c04be54:	3501      	adds	r5, #1
 c04be56:	b2ed      	uxtb	r5, r5
 c04be58:	701d      	strb	r5, [r3, #0]
 c04be5a:	b90d      	cbnz	r5, c04be60 <mbedtls_aes_crypt_ctr+0x44>
            for (i = 16; i > 0; i--)
 c04be5c:	459a      	cmp	sl, r3
 c04be5e:	d1f7      	bne.n	c04be50 <mbedtls_aes_crypt_ctr+0x34>
        *output++ = (unsigned char)(c ^ stream_block[n]);
 c04be60:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 c04be62:	f817 1b01 	ldrb.w	r1, [r7], #1
 c04be66:	5d1b      	ldrb	r3, [r3, r4]
        n = (n + 1) & 0x0F;
 c04be68:	3401      	adds	r4, #1
        *output++ = (unsigned char)(c ^ stream_block[n]);
 c04be6a:	404b      	eors	r3, r1
 c04be6c:	f80b 3b01 	strb.w	r3, [fp], #1
        n = (n + 1) & 0x0F;
 c04be70:	f004 040f 	and.w	r4, r4, #15
 c04be74:	e7dc      	b.n	c04be30 <mbedtls_aes_crypt_ctr+0x14>
                return (MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED);
 c04be76:	f06f 006f 	mvn.w	r0, #111	@ 0x6f
 c04be7a:	e7dd      	b.n	c04be38 <mbedtls_aes_crypt_ctr+0x1c>

0c04be7c <tfm_attest_hal_get_security_lifecycle>:
static const char attestation_profile_definition[] = "psa-tfm-profile-1.md";

enum tfm_security_lifecycle_t tfm_attest_hal_get_security_lifecycle(void)
{
    return TFM_SLC_UNKNOWN;
}
 c04be7c:	2000      	movs	r0, #0
 c04be7e:	4770      	bx	lr

0c04be80 <tfm_attest_hal_get_verification_service>:

const char *
tfm_attest_hal_get_verification_service(uint32_t *size)
{
    *size = sizeof(verification_service_url) - 1;
 c04be80:	2317      	movs	r3, #23
 c04be82:	6003      	str	r3, [r0, #0]

    return verification_service_url;
}
 c04be84:	4800      	ldr	r0, [pc, #0]	@ (c04be88 <tfm_attest_hal_get_verification_service+0x8>)
 c04be86:	4770      	bx	lr
 c04be88:	0c05ecc9 	.word	0x0c05ecc9

0c04be8c <tfm_attest_hal_get_profile_definition>:

const char *
tfm_attest_hal_get_profile_definition(uint32_t *size)
{
    *size = sizeof(attestation_profile_definition) - 1;
 c04be8c:	2314      	movs	r3, #20
 c04be8e:	6003      	str	r3, [r0, #0]

    return attestation_profile_definition;
}
 c04be90:	4800      	ldr	r0, [pc, #0]	@ (c04be94 <tfm_attest_hal_get_profile_definition+0x8>)
 c04be92:	4770      	bx	lr
 c04be94:	0c05ecb4 	.word	0x0c05ecb4

0c04be98 <ccm_auth_crypt>:
static int ccm_auth_crypt( mbedtls_ccm_context *ctx, int mode, size_t length,
                           const unsigned char *iv, size_t iv_len,
                           const unsigned char *add, size_t add_len,
                           const unsigned char *input, unsigned char *output,
                           unsigned char *tag, size_t tag_len )
{
 c04be98:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c04be9c:	b093      	sub	sp, #76	@ 0x4c
 c04be9e:	f8dd 9088 	ldr.w	r9, [sp, #136]	@ 0x88
 c04bea2:	461f      	mov	r7, r3
     *
     * Also, loosen the requirements to enable support for CCM* (IEEE 802.15.4).
     */

    /* tag_len, aka t, is an element of {4, 6, 8, 10, 12, 14, 16} */
    if( tag_len < 4 || tag_len > 16 || tag_len % 2 != 0 )
 c04bea4:	f1a9 0304 	sub.w	r3, r9, #4
 c04bea8:	2b0c      	cmp	r3, #12
{
 c04beaa:	4605      	mov	r5, r0
 c04beac:	4616      	mov	r6, r2
 c04beae:	f8dd a070 	ldr.w	sl, [sp, #112]	@ 0x70
 c04beb2:	9c1e      	ldr	r4, [sp, #120]	@ 0x78
 c04beb4:	9102      	str	r1, [sp, #8]
    if( tag_len < 4 || tag_len > 16 || tag_len % 2 != 0 )
 c04beb6:	d905      	bls.n	c04bec4 <ccm_auth_crypt+0x2c>
        return( MBEDTLS_ERR_CCM_BAD_INPUT );
 c04beb8:	f06f 060c 	mvn.w	r6, #12
        mbedtls_free( b1_padded_addr );

exit:

    return( ret );
}
 c04bebc:	4630      	mov	r0, r6
 c04bebe:	b013      	add	sp, #76	@ 0x4c
 c04bec0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if( tag_len < 4 || tag_len > 16 || tag_len % 2 != 0 )
 c04bec4:	f019 0101 	ands.w	r1, r9, #1
 c04bec8:	d1f6      	bne.n	c04beb8 <ccm_auth_crypt+0x20>
    if( iv_len < 7 || iv_len > 13 )
 c04beca:	f1aa 0307 	sub.w	r3, sl, #7
 c04bece:	2b06      	cmp	r3, #6
 c04bed0:	d8f2      	bhi.n	c04beb8 <ccm_auth_crypt+0x20>
    if( add_len > 0xFF00 )
 c04bed2:	f5b4 4f7f 	cmp.w	r4, #65280	@ 0xff00
 c04bed6:	d8ef      	bhi.n	c04beb8 <ccm_auth_crypt+0x20>
    q = 15 - (unsigned char) iv_len;
 c04bed8:	fa5f fb8a 	uxtb.w	fp, sl
 c04bedc:	f1cb 080f 	rsb	r8, fp, #15
    memset( b0, 0, 16 );
 c04bee0:	2210      	movs	r2, #16
 c04bee2:	a806      	add	r0, sp, #24
    q = 15 - (unsigned char) iv_len;
 c04bee4:	fa5f f888 	uxtb.w	r8, r8
    memset( b0, 0, 16 );
 c04bee8:	f00f fc21 	bl	c05b72e <memset>
    if( add_len > 0 ) b0[0] |= 0x40;
 c04beec:	b114      	cbz	r4, c04bef4 <ccm_auth_crypt+0x5c>
 c04beee:	2340      	movs	r3, #64	@ 0x40
 c04bef0:	f88d 3018 	strb.w	r3, [sp, #24]
    b0[0] |= q - 1;
 c04bef4:	f89d 3018 	ldrb.w	r3, [sp, #24]
    b0[0] |= ( ( tag_len - 2 ) / 2 ) << 3;
 c04bef8:	f1a9 0202 	sub.w	r2, r9, #2
    b0[0] |= q - 1;
 c04befc:	f1cb 0b0e 	rsb	fp, fp, #14
    b0[0] |= ( ( tag_len - 2 ) / 2 ) << 3;
 c04bf00:	0852      	lsrs	r2, r2, #1
    b0[0] |= q - 1;
 c04bf02:	ea43 030b 	orr.w	r3, r3, fp
 c04bf06:	ea43 03c2 	orr.w	r3, r3, r2, lsl #3
    memcpy( b0 + 1, iv, iv_len );
 c04bf0a:	4639      	mov	r1, r7
 c04bf0c:	4652      	mov	r2, sl
 c04bf0e:	f10d 0019 	add.w	r0, sp, #25
    b0[0] |= q - 1;
 c04bf12:	f88d 3018 	strb.w	r3, [sp, #24]
    for( i = 0, len_left = length; i < q; i++, len_left >>= 8 )
 c04bf16:	4637      	mov	r7, r6
    memcpy( b0 + 1, iv, iv_len );
 c04bf18:	f00f fb98 	bl	c05b64c <memcpy>
    for( i = 0, len_left = length; i < q; i++, len_left >>= 8 )
 c04bf1c:	2300      	movs	r3, #0
 c04bf1e:	aa0a      	add	r2, sp, #40	@ 0x28
 c04bf20:	3301      	adds	r3, #1
 c04bf22:	b2db      	uxtb	r3, r3
 c04bf24:	4598      	cmp	r8, r3
        b0[15-i] = (unsigned char)( len_left & 0xFF );
 c04bf26:	f802 7d01 	strb.w	r7, [r2, #-1]!
    for( i = 0, len_left = length; i < q; i++, len_left >>= 8 )
 c04bf2a:	ea4f 2717 	mov.w	r7, r7, lsr #8
 c04bf2e:	d1f7      	bne.n	c04bf20 <ccm_auth_crypt+0x88>
    if( len_left > 0 )
 c04bf30:	2f00      	cmp	r7, #0
 c04bf32:	d1c1      	bne.n	c04beb8 <ccm_auth_crypt+0x20>
    __HAL_RCC_AES_CLK_DISABLE();
 c04bf34:	4a4d      	ldr	r2, [pc, #308]	@ (c04c06c <ccm_auth_crypt+0x1d4>)
    HAL_CRYP_DeInit( &ctx->hcryp_ccm );
 c04bf36:	f105 0a20 	add.w	sl, r5, #32
    __HAL_RCC_AES_CLK_DISABLE();
 c04bf3a:	f8d2 308c 	ldr.w	r3, [r2, #140]	@ 0x8c
    HAL_CRYP_DeInit( &ctx->hcryp_ccm );
 c04bf3e:	4650      	mov	r0, sl
    __HAL_RCC_AES_CLK_DISABLE();
 c04bf40:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
 c04bf44:	f8c2 308c 	str.w	r3, [r2, #140]	@ 0x8c
    HAL_CRYP_DeInit( &ctx->hcryp_ccm );
 c04bf48:	f7f0 ffbf 	bl	c03ceca <HAL_CRYP_DeInit>
    ctx->hcryp_ccm.Instance->CR = ctx->ctx_save_cr;
 c04bf4c:	6a2b      	ldr	r3, [r5, #32]
 c04bf4e:	f8d5 2088 	ldr.w	r2, [r5, #136]	@ 0x88
 c04bf52:	601a      	str	r2, [r3, #0]
    if( add_len > 0 )
 c04bf54:	2c00      	cmp	r4, #0
 c04bf56:	d058      	beq.n	c04c00a <ccm_auth_crypt+0x172>
        b1_padding = ((add_len + H_LENGTH) % 4);
 c04bf58:	1ca1      	adds	r1, r4, #2
        b1_length = add_len + H_LENGTH + b1_padding;
 c04bf5a:	f001 0103 	and.w	r1, r1, #3
 c04bf5e:	4421      	add	r1, r4
            mbedtls_calloc( 1, b1_length + 3);
 c04bf60:	2001      	movs	r0, #1
        b1_length = add_len + H_LENGTH + b1_padding;
 c04bf62:	f101 0b02 	add.w	fp, r1, #2
            mbedtls_calloc( 1, b1_length + 3);
 c04bf66:	3105      	adds	r1, #5
 c04bf68:	f7ef fa1c 	bl	c03b3a4 <mbedtls_calloc>
        if( b1_padded_addr == NULL )
 c04bf6c:	4680      	mov	r8, r0
 c04bf6e:	2800      	cmp	r0, #0
 c04bf70:	d078      	beq.n	c04c064 <ccm_auth_crypt+0x1cc>
            (unsigned char*) ((uint32_t)(b1_padded_addr + 3) & 0xFFFFFFFC);
 c04bf72:	1cc3      	adds	r3, r0, #3
 c04bf74:	f023 0303 	bic.w	r3, r3, #3
        b1_aligned_addr[0] = (unsigned char)( ( add_len >> 8 ) & 0xFF );
 c04bf78:	4618      	mov	r0, r3
 c04bf7a:	ba62      	rev16	r2, r4
 c04bf7c:	f820 2b02 	strh.w	r2, [r0], #2
        memcpy( b1_aligned_addr + H_LENGTH, add, add_len );
 c04bf80:	991d      	ldr	r1, [sp, #116]	@ 0x74
 c04bf82:	4622      	mov	r2, r4
        b1_aligned_addr[0] = (unsigned char)( ( add_len >> 8 ) & 0xFF );
 c04bf84:	9303      	str	r3, [sp, #12]
        memcpy( b1_aligned_addr + H_LENGTH, add, add_len );
 c04bf86:	f00f fb61 	bl	c05b64c <memcpy>
        ctx->hcryp_ccm.Init.HeaderSize = b1_length/4;
 c04bf8a:	9b03      	ldr	r3, [sp, #12]
 c04bf8c:	ea4f 029b 	mov.w	r2, fp, lsr #2
 c04bf90:	a90a      	add	r1, sp, #40	@ 0x28
 c04bf92:	4608      	mov	r0, r1
 c04bf94:	e9c5 320e 	strd	r3, r2, [r5, #56]	@ 0x38
    for( j=0; j < 4; j++ )
 c04bf98:	aa06      	add	r2, sp, #24
        GET_UINT32_BE( b0_32B[j], b0, 4*j );
 c04bf9a:	7853      	ldrb	r3, [r2, #1]
 c04bf9c:	f892 c000 	ldrb.w	ip, [r2]
 c04bfa0:	041b      	lsls	r3, r3, #16
 c04bfa2:	ea43 630c 	orr.w	r3, r3, ip, lsl #24
 c04bfa6:	f892 c003 	ldrb.w	ip, [r2, #3]
    for( j=0; j < 4; j++ )
 c04bfaa:	3701      	adds	r7, #1
        GET_UINT32_BE( b0_32B[j], b0, 4*j );
 c04bfac:	ea43 030c 	orr.w	r3, r3, ip
 c04bfb0:	f892 c002 	ldrb.w	ip, [r2, #2]
    for( j=0; j < 4; j++ )
 c04bfb4:	2f04      	cmp	r7, #4
        GET_UINT32_BE( b0_32B[j], b0, 4*j );
 c04bfb6:	ea43 230c 	orr.w	r3, r3, ip, lsl #8
 c04bfba:	f841 3b04 	str.w	r3, [r1], #4
    for( j=0; j < 4; j++ )
 c04bfbe:	f102 0204 	add.w	r2, r2, #4
 c04bfc2:	d1ea      	bne.n	c04bf9a <ccm_auth_crypt+0x102>
    __HAL_RCC_AES_CLK_ENABLE();
 c04bfc4:	4b29      	ldr	r3, [pc, #164]	@ (c04c06c <ccm_auth_crypt+0x1d4>)
    ctx->hcryp_ccm.Init.B0         = b0_32B;
 c04bfc6:	6428      	str	r0, [r5, #64]	@ 0x40
    __HAL_RCC_AES_CLK_ENABLE();
 c04bfc8:	f8d3 208c 	ldr.w	r2, [r3, #140]	@ 0x8c
    if ( HAL_CRYP_Init( &ctx->hcryp_ccm ) != HAL_OK )
 c04bfcc:	4650      	mov	r0, sl
    __HAL_RCC_AES_CLK_ENABLE();
 c04bfce:	f442 3280 	orr.w	r2, r2, #65536	@ 0x10000
 c04bfd2:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
 c04bfd6:	f8d3 208c 	ldr.w	r2, [r3, #140]	@ 0x8c
 c04bfda:	f402 3280 	and.w	r2, r2, #65536	@ 0x10000
 c04bfde:	9205      	str	r2, [sp, #20]
 c04bfe0:	9a05      	ldr	r2, [sp, #20]
    __HAL_RCC_AES_FORCE_RESET();
 c04bfe2:	6e5a      	ldr	r2, [r3, #100]	@ 0x64
 c04bfe4:	f442 3280 	orr.w	r2, r2, #65536	@ 0x10000
 c04bfe8:	665a      	str	r2, [r3, #100]	@ 0x64
    __HAL_RCC_AES_RELEASE_RESET();
 c04bfea:	6e5a      	ldr	r2, [r3, #100]	@ 0x64
 c04bfec:	f422 3280 	bic.w	r2, r2, #65536	@ 0x10000
 c04bff0:	665a      	str	r2, [r3, #100]	@ 0x64
    if ( HAL_CRYP_Init( &ctx->hcryp_ccm ) != HAL_OK )
 c04bff2:	f7f0 ff11 	bl	c03ce18 <HAL_CRYP_Init>
 c04bff6:	b160      	cbz	r0, c04c012 <ccm_auth_crypt+0x17a>
        ret = MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED;
 c04bff8:	f06f 066f 	mvn.w	r6, #111	@ 0x6f
    if( add_len > 0 )
 c04bffc:	2c00      	cmp	r4, #0
 c04bffe:	f43f af5d 	beq.w	c04bebc <ccm_auth_crypt+0x24>
        mbedtls_free( b1_padded_addr );
 c04c002:	4640      	mov	r0, r8
 c04c004:	f7ef f9d4 	bl	c03b3b0 <mbedtls_free>
 c04c008:	e758      	b.n	c04bebc <ccm_auth_crypt+0x24>
 c04c00a:	4622      	mov	r2, r4
 c04c00c:	4623      	mov	r3, r4
    unsigned char *b1_padded_addr = NULL;            /* Formatting of B1   */
 c04c00e:	46a0      	mov	r8, r4
 c04c010:	e7be      	b.n	c04bf90 <ccm_auth_crypt+0xf8>
    if( mode == CCM_DECRYPT )
 c04c012:	9b02      	ldr	r3, [sp, #8]
         if ( HAL_CRYP_Decrypt( &ctx->hcryp_ccm,
 c04c014:	4650      	mov	r0, sl
    if( mode == CCM_DECRYPT )
 c04c016:	2b01      	cmp	r3, #1
 c04c018:	f44f 737a 	mov.w	r3, #1000	@ 0x3e8
         if ( HAL_CRYP_Decrypt( &ctx->hcryp_ccm,
 c04c01c:	b2b2      	uxth	r2, r6
 c04c01e:	9300      	str	r3, [sp, #0]
 c04c020:	e9dd 131f 	ldrd	r1, r3, [sp, #124]	@ 0x7c
    if( mode == CCM_DECRYPT )
 c04c024:	d11b      	bne.n	c04c05e <ccm_auth_crypt+0x1c6>
         if ( HAL_CRYP_Decrypt( &ctx->hcryp_ccm,
 c04c026:	f7f1 fa75 	bl	c03d514 <HAL_CRYP_Decrypt>
         if ( HAL_CRYP_Encrypt( &ctx->hcryp_ccm,
 c04c02a:	2800      	cmp	r0, #0
 c04c02c:	d1e4      	bne.n	c04bff8 <ccm_auth_crypt+0x160>
    memset(mac, 0, sizeof(mac));
 c04c02e:	2210      	movs	r2, #16
 c04c030:	2100      	movs	r1, #0
 c04c032:	a80e      	add	r0, sp, #56	@ 0x38
 c04c034:	f00f fb7b 	bl	c05b72e <memset>
    if ( HAL_CRYPEx_AESCCM_GenerateAuthTAG( &ctx->hcryp_ccm,
 c04c038:	f44f 727a 	mov.w	r2, #1000	@ 0x3e8
 c04c03c:	4650      	mov	r0, sl
 c04c03e:	a90e      	add	r1, sp, #56	@ 0x38
 c04c040:	f7f1 fb52 	bl	c03d6e8 <HAL_CRYPEx_AESCCM_GenerateAuthTAG>
 c04c044:	4606      	mov	r6, r0
 c04c046:	2800      	cmp	r0, #0
 c04c048:	d1d6      	bne.n	c04bff8 <ccm_auth_crypt+0x160>
    memcpy( tag, mac, tag_len );
 c04c04a:	464a      	mov	r2, r9
 c04c04c:	9821      	ldr	r0, [sp, #132]	@ 0x84
 c04c04e:	a90e      	add	r1, sp, #56	@ 0x38
 c04c050:	f00f fafc 	bl	c05b64c <memcpy>
    ctx->ctx_save_cr = ctx->hcryp_ccm.Instance->CR;
 c04c054:	6a2b      	ldr	r3, [r5, #32]
 c04c056:	681b      	ldr	r3, [r3, #0]
 c04c058:	f8c5 3088 	str.w	r3, [r5, #136]	@ 0x88
 c04c05c:	e7ce      	b.n	c04bffc <ccm_auth_crypt+0x164>
         if ( HAL_CRYP_Encrypt( &ctx->hcryp_ccm,
 c04c05e:	f7f1 f989 	bl	c03d374 <HAL_CRYP_Encrypt>
 c04c062:	e7e2      	b.n	c04c02a <ccm_auth_crypt+0x192>
            ret = MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED;
 c04c064:	f06f 066f 	mvn.w	r6, #111	@ 0x6f
 c04c068:	e728      	b.n	c04bebc <ccm_auth_crypt+0x24>
 c04c06a:	bf00      	nop
 c04c06c:	56020c00 	.word	0x56020c00

0c04c070 <mbedtls_ccm_init>:
    mbedtls_platform_zeroize( ctx, sizeof( mbedtls_ccm_context ) );
 c04c070:	218c      	movs	r1, #140	@ 0x8c
 c04c072:	f7ef b9ad 	b.w	c03b3d0 <mbedtls_platform_zeroize>
	...

0c04c078 <mbedtls_ccm_setkey>:
    switch (keybits)
 c04c078:	2bc0      	cmp	r3, #192	@ 0xc0
{
 c04c07a:	b537      	push	{r0, r1, r2, r4, r5, lr}
 c04c07c:	4604      	mov	r4, r0
    switch (keybits)
 c04c07e:	d045      	beq.n	c04c10c <mbedtls_ccm_setkey+0x94>
 c04c080:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 c04c084:	d03f      	beq.n	c04c106 <mbedtls_ccm_setkey+0x8e>
 c04c086:	2b80      	cmp	r3, #128	@ 0x80
 c04c088:	d143      	bne.n	c04c112 <mbedtls_ccm_setkey+0x9a>
 c04c08a:	2100      	movs	r1, #0
    for( i=0; i < (keybits/32) ; i++ )
 c04c08c:	095b      	lsrs	r3, r3, #5
            ctx->hcryp_ccm.Init.KeySize = CRYP_KEYSIZE_256B;
 c04c08e:	62a1      	str	r1, [r4, #40]	@ 0x28
    for( i=0; i < (keybits/32) ; i++ )
 c04c090:	d012      	beq.n	c04c0b8 <mbedtls_ccm_setkey+0x40>
 c04c092:	1f20      	subs	r0, r4, #4
 c04c094:	eb02 0383 	add.w	r3, r2, r3, lsl #2
        GET_UINT32_BE( ctx->ccm_key[i], key, 4*i );
 c04c098:	7851      	ldrb	r1, [r2, #1]
 c04c09a:	7815      	ldrb	r5, [r2, #0]
 c04c09c:	0409      	lsls	r1, r1, #16
 c04c09e:	ea41 6105 	orr.w	r1, r1, r5, lsl #24
 c04c0a2:	78d5      	ldrb	r5, [r2, #3]
    for( i=0; i < (keybits/32) ; i++ )
 c04c0a4:	3204      	adds	r2, #4
        GET_UINT32_BE( ctx->ccm_key[i], key, 4*i );
 c04c0a6:	4329      	orrs	r1, r5
 c04c0a8:	f812 5c02 	ldrb.w	r5, [r2, #-2]
    for( i=0; i < (keybits/32) ; i++ )
 c04c0ac:	429a      	cmp	r2, r3
        GET_UINT32_BE( ctx->ccm_key[i], key, 4*i );
 c04c0ae:	ea41 2105 	orr.w	r1, r1, r5, lsl #8
 c04c0b2:	f840 1f04 	str.w	r1, [r0, #4]!
    for( i=0; i < (keybits/32) ; i++ )
 c04c0b6:	d1ef      	bne.n	c04c098 <mbedtls_ccm_setkey+0x20>
    ctx->hcryp_ccm.Init.DataType = CRYP_BYTE_SWAP;
 c04c0b8:	2304      	movs	r3, #4
 c04c0ba:	4a19      	ldr	r2, [pc, #100]	@ (c04c120 <mbedtls_ccm_setkey+0xa8>)
    ctx->hcryp_ccm.Init.pKey = ctx->ccm_key;
 c04c0bc:	62e4      	str	r4, [r4, #44]	@ 0x2c
    ctx->hcryp_ccm.Init.DataType = CRYP_BYTE_SWAP;
 c04c0be:	e9c4 2308 	strd	r2, r3, [r4, #32]
    ctx->hcryp_ccm.Init.Algorithm  = CRYP_AES_CCM;
 c04c0c2:	2300      	movs	r3, #0
 c04c0c4:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
    ctx->hcryp_ccm.Init.HeaderSize = 0;
 c04c0c8:	e9c4 330e 	strd	r3, r3, [r4, #56]	@ 0x38
    ctx->hcryp_ccm.Init.Algorithm  = CRYP_AES_CCM;
 c04c0cc:	e9c4 320c 	strd	r3, r2, [r4, #48]	@ 0x30
    ctx->hcryp_ccm.Init.B0 = NULL;
 c04c0d0:	6423      	str	r3, [r4, #64]	@ 0x40
    ctx->hcryp_ccm.Init.DataWidthUnit = CRYP_DATAWIDTHUNIT_BYTE;
 c04c0d2:	2301      	movs	r3, #1
 c04c0d4:	6463      	str	r3, [r4, #68]	@ 0x44
    __HAL_RCC_AES_CLK_ENABLE();
 c04c0d6:	4b13      	ldr	r3, [pc, #76]	@ (c04c124 <mbedtls_ccm_setkey+0xac>)
    if (HAL_CRYP_Init(&ctx->hcryp_ccm) != HAL_OK)
 c04c0d8:	f104 0020 	add.w	r0, r4, #32
    __HAL_RCC_AES_CLK_ENABLE();
 c04c0dc:	f8d3 208c 	ldr.w	r2, [r3, #140]	@ 0x8c
 c04c0e0:	f442 3280 	orr.w	r2, r2, #65536	@ 0x10000
 c04c0e4:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
 c04c0e8:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 c04c0ec:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
 c04c0f0:	9301      	str	r3, [sp, #4]
 c04c0f2:	9b01      	ldr	r3, [sp, #4]
    if (HAL_CRYP_Init(&ctx->hcryp_ccm) != HAL_OK)
 c04c0f4:	f7f0 fe90 	bl	c03ce18 <HAL_CRYP_Init>
 c04c0f8:	b970      	cbnz	r0, c04c118 <mbedtls_ccm_setkey+0xa0>
    ctx->ctx_save_cr = ctx->hcryp_ccm.Instance->CR;
 c04c0fa:	6a23      	ldr	r3, [r4, #32]
 c04c0fc:	681b      	ldr	r3, [r3, #0]
 c04c0fe:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
}
 c04c102:	b003      	add	sp, #12
 c04c104:	bd30      	pop	{r4, r5, pc}
    switch (keybits)
 c04c106:	f44f 2180 	mov.w	r1, #262144	@ 0x40000
 c04c10a:	e7bf      	b.n	c04c08c <mbedtls_ccm_setkey+0x14>
            ret = MBEDTLS_ERR_PLATFORM_FEATURE_UNSUPPORTED;
 c04c10c:	f06f 0071 	mvn.w	r0, #113	@ 0x71
 c04c110:	e7f7      	b.n	c04c102 <mbedtls_ccm_setkey+0x8a>
    switch (keybits)
 c04c112:	f06f 000c 	mvn.w	r0, #12
 c04c116:	e7f4      	b.n	c04c102 <mbedtls_ccm_setkey+0x8a>
        ret = MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED;
 c04c118:	f06f 006f 	mvn.w	r0, #111	@ 0x6f
    return( ret );
 c04c11c:	e7f1      	b.n	c04c102 <mbedtls_ccm_setkey+0x8a>
 c04c11e:	bf00      	nop
 c04c120:	520c0000 	.word	0x520c0000
 c04c124:	56020c00 	.word	0x56020c00

0c04c128 <mbedtls_ccm_free>:
{
 c04c128:	b510      	push	{r4, lr}
    if( ctx == NULL )
 c04c12a:	4604      	mov	r4, r0
 c04c12c:	b140      	cbz	r0, c04c140 <mbedtls_ccm_free+0x18>
    HAL_CRYP_DeInit( &ctx->hcryp_ccm );
 c04c12e:	3020      	adds	r0, #32
 c04c130:	f7f0 fecb 	bl	c03ceca <HAL_CRYP_DeInit>
    mbedtls_platform_zeroize( ctx, sizeof( mbedtls_ccm_context ) );
 c04c134:	4620      	mov	r0, r4
}
 c04c136:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mbedtls_platform_zeroize( ctx, sizeof( mbedtls_ccm_context ) );
 c04c13a:	218c      	movs	r1, #140	@ 0x8c
 c04c13c:	f7ef b948 	b.w	c03b3d0 <mbedtls_platform_zeroize>
}
 c04c140:	bd10      	pop	{r4, pc}

0c04c142 <mbedtls_ccm_star_encrypt_and_tag>:
int mbedtls_ccm_star_encrypt_and_tag( mbedtls_ccm_context *ctx, size_t length,
                         const unsigned char *iv, size_t iv_len,
                         const unsigned char *add, size_t add_len,
                         const unsigned char *input, unsigned char *output,
                         unsigned char *tag, size_t tag_len )
{
 c04c142:	b510      	push	{r4, lr}
 c04c144:	b088      	sub	sp, #32
    CCM_VALIDATE_RET( iv != NULL );
    CCM_VALIDATE_RET( add_len == 0 || add != NULL );
    CCM_VALIDATE_RET( length == 0 || input != NULL );
    CCM_VALIDATE_RET( length == 0 || output != NULL );
    CCM_VALIDATE_RET( tag_len == 0 || tag != NULL );
    return( ccm_auth_crypt( ctx, CCM_ENCRYPT, length, iv, iv_len,
 c04c146:	9c0f      	ldr	r4, [sp, #60]	@ 0x3c
 c04c148:	9406      	str	r4, [sp, #24]
 c04c14a:	9c0e      	ldr	r4, [sp, #56]	@ 0x38
 c04c14c:	9405      	str	r4, [sp, #20]
 c04c14e:	9c0d      	ldr	r4, [sp, #52]	@ 0x34
 c04c150:	9404      	str	r4, [sp, #16]
 c04c152:	9c0c      	ldr	r4, [sp, #48]	@ 0x30
 c04c154:	9403      	str	r4, [sp, #12]
 c04c156:	9c0b      	ldr	r4, [sp, #44]	@ 0x2c
 c04c158:	9402      	str	r4, [sp, #8]
 c04c15a:	9c0a      	ldr	r4, [sp, #40]	@ 0x28
 c04c15c:	e9cd 3400 	strd	r3, r4, [sp]
 c04c160:	4613      	mov	r3, r2
 c04c162:	460a      	mov	r2, r1
 c04c164:	2100      	movs	r1, #0
 c04c166:	f7ff fe97 	bl	c04be98 <ccm_auth_crypt>
                            add, add_len, input, output, tag, tag_len ) );
}
 c04c16a:	b008      	add	sp, #32
 c04c16c:	bd10      	pop	{r4, pc}

0c04c16e <mbedtls_ccm_encrypt_and_tag>:
int mbedtls_ccm_encrypt_and_tag( mbedtls_ccm_context *ctx, size_t length,
                         const unsigned char *iv, size_t iv_len,
                         const unsigned char *add, size_t add_len,
                         const unsigned char *input, unsigned char *output,
                         unsigned char *tag, size_t tag_len )
{
 c04c16e:	b5f0      	push	{r4, r5, r6, r7, lr}
 c04c170:	e9dd 5605 	ldrd	r5, r6, [sp, #20]
 c04c174:	e9dd 7c07 	ldrd	r7, ip, [sp, #28]
 c04c178:	e9dd e409 	ldrd	lr, r4, [sp, #36]	@ 0x24
    CCM_VALIDATE_RET( iv != NULL );
    CCM_VALIDATE_RET( add_len == 0 || add != NULL );
    CCM_VALIDATE_RET( length == 0 || input != NULL );
    CCM_VALIDATE_RET( length == 0 || output != NULL );
    CCM_VALIDATE_RET( tag_len == 0 || tag != NULL );
    if( tag_len == 0 )
 c04c17c:	b14c      	cbz	r4, c04c192 <mbedtls_ccm_encrypt_and_tag+0x24>
        return( MBEDTLS_ERR_CCM_BAD_INPUT );

    return( mbedtls_ccm_star_encrypt_and_tag( ctx, length, iv, iv_len, add,
 c04c17e:	e9cd e409 	strd	lr, r4, [sp, #36]	@ 0x24
 c04c182:	e9cd 7c07 	strd	r7, ip, [sp, #28]
 c04c186:	e9cd 5605 	strd	r5, r6, [sp, #20]
                add_len, input, output, tag, tag_len ) );
}
 c04c18a:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
    return( mbedtls_ccm_star_encrypt_and_tag( ctx, length, iv, iv_len, add,
 c04c18e:	f7ff bfd8 	b.w	c04c142 <mbedtls_ccm_star_encrypt_and_tag>
}
 c04c192:	f06f 000c 	mvn.w	r0, #12
 c04c196:	bdf0      	pop	{r4, r5, r6, r7, pc}

0c04c198 <mbedtls_ccm_star_auth_decrypt>:
int mbedtls_ccm_star_auth_decrypt( mbedtls_ccm_context *ctx, size_t length,
                      const unsigned char *iv, size_t iv_len,
                      const unsigned char *add, size_t add_len,
                      const unsigned char *input, unsigned char *output,
                      const unsigned char *tag, size_t tag_len )
{
 c04c198:	b5f0      	push	{r4, r5, r6, r7, lr}
 c04c19a:	460c      	mov	r4, r1
 c04c19c:	b08d      	sub	sp, #52	@ 0x34
    CCM_VALIDATE_RET( add_len == 0 || add != NULL );
    CCM_VALIDATE_RET( length == 0 || input != NULL );
    CCM_VALIDATE_RET( length == 0 || output != NULL );
    CCM_VALIDATE_RET( tag_len == 0 || tag != NULL );

    if( ( ret = ccm_auth_crypt( ctx, CCM_DECRYPT, length,
 c04c19e:	a908      	add	r1, sp, #32
{
 c04c1a0:	e9dd 6515 	ldrd	r6, r5, [sp, #84]	@ 0x54
    if( ( ret = ccm_auth_crypt( ctx, CCM_DECRYPT, length,
 c04c1a4:	e9cd 6104 	strd	r6, r1, [sp, #16]
 c04c1a8:	9914      	ldr	r1, [sp, #80]	@ 0x50
{
 c04c1aa:	9f17      	ldr	r7, [sp, #92]	@ 0x5c
    if( ( ret = ccm_auth_crypt( ctx, CCM_DECRYPT, length,
 c04c1ac:	9103      	str	r1, [sp, #12]
 c04c1ae:	9913      	ldr	r1, [sp, #76]	@ 0x4c
 c04c1b0:	9706      	str	r7, [sp, #24]
 c04c1b2:	9102      	str	r1, [sp, #8]
 c04c1b4:	9912      	ldr	r1, [sp, #72]	@ 0x48
 c04c1b6:	e9cd 3100 	strd	r3, r1, [sp]
 c04c1ba:	4613      	mov	r3, r2
 c04c1bc:	2101      	movs	r1, #1
 c04c1be:	4622      	mov	r2, r4
 c04c1c0:	f7ff fe6a 	bl	c04be98 <ccm_auth_crypt>
 c04c1c4:	b960      	cbnz	r0, c04c1e0 <mbedtls_ccm_star_auth_decrypt+0x48>
 c04c1c6:	4602      	mov	r2, r0
    {
        return( ret );
    }

    /* Check tag in "constant-time" */
    for( diff = 0, i = 0; i < tag_len; i++ )
 c04c1c8:	b2d3      	uxtb	r3, r2
 c04c1ca:	42bb      	cmp	r3, r7
 c04c1cc:	f102 0201 	add.w	r2, r2, #1
 c04c1d0:	d308      	bcc.n	c04c1e4 <mbedtls_ccm_star_auth_decrypt+0x4c>
        diff |= tag[i] ^ check_tag[i];

    if( diff != 0 )
 c04c1d2:	b128      	cbz	r0, c04c1e0 <mbedtls_ccm_star_auth_decrypt+0x48>
    {
        mbedtls_platform_zeroize( output, length );
 c04c1d4:	4630      	mov	r0, r6
 c04c1d6:	4621      	mov	r1, r4
 c04c1d8:	f7ef f8fa 	bl	c03b3d0 <mbedtls_platform_zeroize>
        return( MBEDTLS_ERR_CCM_AUTH_FAILED );
 c04c1dc:	f06f 000e 	mvn.w	r0, #14
    }

    return( 0 );
}
 c04c1e0:	b00d      	add	sp, #52	@ 0x34
 c04c1e2:	bdf0      	pop	{r4, r5, r6, r7, pc}
        diff |= tag[i] ^ check_tag[i];
 c04c1e4:	f103 0130 	add.w	r1, r3, #48	@ 0x30
 c04c1e8:	4469      	add	r1, sp
 c04c1ea:	5ceb      	ldrb	r3, [r5, r3]
 c04c1ec:	f811 1c10 	ldrb.w	r1, [r1, #-16]
 c04c1f0:	404b      	eors	r3, r1
 c04c1f2:	4318      	orrs	r0, r3
    for( diff = 0, i = 0; i < tag_len; i++ )
 c04c1f4:	e7e8      	b.n	c04c1c8 <mbedtls_ccm_star_auth_decrypt+0x30>

0c04c1f6 <mbedtls_ccm_auth_decrypt>:
int mbedtls_ccm_auth_decrypt( mbedtls_ccm_context *ctx, size_t length,
                      const unsigned char *iv, size_t iv_len,
                      const unsigned char *add, size_t add_len,
                      const unsigned char *input, unsigned char *output,
                      const unsigned char *tag, size_t tag_len )
{
 c04c1f6:	b5f0      	push	{r4, r5, r6, r7, lr}
 c04c1f8:	e9dd 5605 	ldrd	r5, r6, [sp, #20]
 c04c1fc:	e9dd 7c07 	ldrd	r7, ip, [sp, #28]
 c04c200:	e9dd e409 	ldrd	lr, r4, [sp, #36]	@ 0x24
    CCM_VALIDATE_RET( add_len == 0 || add != NULL );
    CCM_VALIDATE_RET( length == 0 || input != NULL );
    CCM_VALIDATE_RET( length == 0 || output != NULL );
    CCM_VALIDATE_RET( tag_len == 0 || tag != NULL );

    if( tag_len == 0 )
 c04c204:	b14c      	cbz	r4, c04c21a <mbedtls_ccm_auth_decrypt+0x24>
        return( MBEDTLS_ERR_CCM_BAD_INPUT );

    return( mbedtls_ccm_star_auth_decrypt( ctx, length, iv, iv_len, add,
 c04c206:	e9cd e409 	strd	lr, r4, [sp, #36]	@ 0x24
 c04c20a:	e9cd 7c07 	strd	r7, ip, [sp, #28]
 c04c20e:	e9cd 5605 	strd	r5, r6, [sp, #20]
                add_len, input, output, tag, tag_len ) );
}
 c04c212:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
    return( mbedtls_ccm_star_auth_decrypt( ctx, length, iv, iv_len, add,
 c04c216:	f7ff bfbf 	b.w	c04c198 <mbedtls_ccm_star_auth_decrypt>
}
 c04c21a:	f06f 000c 	mvn.w	r0, #12
 c04c21e:	bdf0      	pop	{r4, r5, r6, r7, pc}

0c04c220 <tfm_plat_get_boot_seed>:
#include "tfm_secure_api.h"

enum tfm_plat_err_t tfm_plat_get_boot_seed(uint32_t size, uint8_t *buf)
{
    return  TFM_PLAT_ERR_SYSTEM_ERR;
}
 c04c220:	f643 205c 	movw	r0, #14940	@ 0x3a5c
 c04c224:	4770      	bx	lr

0c04c226 <tfm_plat_get_implementation_id>:
#include "se_psa_id.h"
#endif

enum tfm_plat_err_t tfm_plat_get_implementation_id(uint32_t *size,
                                                   uint8_t  *buf)
{
 c04c226:	b508      	push	{r3, lr}
  uint8_t *p_dst;
  int32_t tfm_res;;
  p_dst = &buf[0];
  if (*size < IMPLEMENTATION_ID_MAX_SIZE)
 c04c228:	6803      	ldr	r3, [r0, #0]
 c04c22a:	2b1f      	cmp	r3, #31
 c04c22c:	d802      	bhi.n	c04c234 <tfm_plat_get_implementation_id+0xe>
  {
    return TFM_PLAT_ERR_SYSTEM_ERR;
 c04c22e:	f643 205c 	movw	r0, #14940	@ 0x3a5c
  if (tfm_res != (int32_t)TFM_SUCCESS)
  {
    return  TFM_PLAT_ERR_SYSTEM_ERR;
  }
  return TFM_PLAT_ERR_SUCCESS;
}
 c04c232:	bd08      	pop	{r3, pc}
  *size = IMPLEMENTATION_ID_MAX_SIZE;
 c04c234:	2220      	movs	r2, #32
 c04c236:	6002      	str	r2, [r0, #0]
  tfm_res = tfm_core_get_boot_value(SET_TLV_TYPE(TLV_MAJOR_CORE, TLV_MINOR_CORE_IAS_IMPLEMENTATION_ID), p_dst, (*size));
 c04c238:	f640 10cd 	movw	r0, #2509	@ 0x9cd
 c04c23c:	f7f0 fab6 	bl	c03c7ac <tfm_core_get_boot_value>
  if (tfm_res != (int32_t)TFM_SUCCESS)
 c04c240:	2800      	cmp	r0, #0
 c04c242:	d0f6      	beq.n	c04c232 <tfm_plat_get_implementation_id+0xc>
 c04c244:	e7f3      	b.n	c04c22e <tfm_plat_get_implementation_id+0x8>
	...

0c04c248 <tfm_plat_get_hw_version>:

enum tfm_plat_err_t tfm_plat_get_hw_version(uint32_t *size, uint8_t *buf)
{
#ifdef PSA_USE_SE_ST
  size_t st_number_size = 19;
 c04c248:	2313      	movs	r3, #19
{
 c04c24a:	b570      	push	{r4, r5, r6, lr}
 c04c24c:	b088      	sub	sp, #32
 c04c24e:	4605      	mov	r5, r0
 c04c250:	460c      	mov	r4, r1
  uint8_t st_number[st_number_size];
  psa_status_t ret;
  psa_key_handle_t key_handle;

  ret = psa_open_key(SE_ST_ID_TO_PSA_ID(SE_ST_SERIAL_NUMBER), &key_handle);
 c04c252:	4813      	ldr	r0, [pc, #76]	@ (c04c2a0 <tfm_plat_get_hw_version+0x58>)
 c04c254:	a902      	add	r1, sp, #8
  size_t st_number_size = 19;
 c04c256:	9301      	str	r3, [sp, #4]
  ret = psa_open_key(SE_ST_ID_TO_PSA_ID(SE_ST_SERIAL_NUMBER), &key_handle);
 c04c258:	f7ef fed2 	bl	c03c000 <psa_open_key>
  if (ret != PSA_SUCCESS)
 c04c25c:	b118      	cbz	r0, c04c266 <tfm_plat_get_hw_version+0x1e>
  {
    return TFM_PLAT_ERR_SYSTEM_ERR;
 c04c25e:	f643 205c 	movw	r0, #14940	@ 0x3a5c
  buf[12] = '0' + (((revision >> 0) & 0xf) / 10);
  buf[13] = '0' + (((revision >> 0) & 0xf) % 10);
  *size = hw_version_size;
#endif /* PSA_USE_SE_ST */
  return TFM_PLAT_ERR_SUCCESS;
}
 c04c262:	b008      	add	sp, #32
 c04c264:	bd70      	pop	{r4, r5, r6, pc}
  ret = psa_export_key(key_handle, st_number, st_number_size, &st_number_size);
 c04c266:	9a01      	ldr	r2, [sp, #4]
 c04c268:	9802      	ldr	r0, [sp, #8]
 c04c26a:	ab01      	add	r3, sp, #4
 c04c26c:	a903      	add	r1, sp, #12
 c04c26e:	f7ef ff6a 	bl	c03c146 <psa_export_key>
  if (ret != PSA_SUCCESS)
 c04c272:	2800      	cmp	r0, #0
 c04c274:	d1f3      	bne.n	c04c25e <tfm_plat_get_hw_version+0x16>
  memcpy(buf, st_number, 14);
 c04c276:	4623      	mov	r3, r4
 c04c278:	aa03      	add	r2, sp, #12
 c04c27a:	ae05      	add	r6, sp, #20
 c04c27c:	4614      	mov	r4, r2
 c04c27e:	cc03      	ldmia	r4!, {r0, r1}
 c04c280:	42b4      	cmp	r4, r6
 c04c282:	6018      	str	r0, [r3, #0]
 c04c284:	6059      	str	r1, [r3, #4]
 c04c286:	4622      	mov	r2, r4
 c04c288:	f103 0308 	add.w	r3, r3, #8
 c04c28c:	d1f6      	bne.n	c04c27c <tfm_plat_get_hw_version+0x34>
 c04c28e:	6820      	ldr	r0, [r4, #0]
 c04c290:	6018      	str	r0, [r3, #0]
 c04c292:	88a2      	ldrh	r2, [r4, #4]
  return TFM_PLAT_ERR_SUCCESS;
 c04c294:	2000      	movs	r0, #0
  memcpy(buf, st_number, 14);
 c04c296:	809a      	strh	r2, [r3, #4]
  *size = 14;
 c04c298:	230e      	movs	r3, #14
 c04c29a:	602b      	str	r3, [r5, #0]
  return TFM_PLAT_ERR_SUCCESS;
 c04c29c:	e7e1      	b.n	c04c262 <tfm_plat_get_hw_version+0x1a>
 c04c29e:	bf00      	nop
 c04c2a0:	40000003 	.word	0x40000003

0c04c2a4 <mbedtls_ecdsa_can_do>:
    return ret;
}

int mbedtls_ecdsa_can_do( mbedtls_ecp_group_id gid )
{
    switch( gid )
 c04c2a4:	f000 00fb 	and.w	r0, r0, #251	@ 0xfb
#ifdef MBEDTLS_ECP_DP_CURVE448_ENABLED
        case MBEDTLS_ECP_DP_CURVE448: return 0;
#endif
    default: return 1;
    }
}
 c04c2a8:	3809      	subs	r0, #9
 c04c2aa:	bf18      	it	ne
 c04c2ac:	2001      	movne	r0, #1
 c04c2ae:	4770      	bx	lr

0c04c2b0 <mbedtls_ecdsa_sign>:
{
 c04c2b0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    PKA_HandleTypeDef hpka = {0};
 c04c2b4:	2600      	movs	r6, #0
{
 c04c2b6:	4604      	mov	r4, r0
 c04c2b8:	b097      	sub	sp, #92	@ 0x5c
 c04c2ba:	4689      	mov	r9, r1
 c04c2bc:	4690      	mov	r8, r2
    PKA_ECDSASignInTypeDef ECDSA_SignIn = {0};
 c04c2be:	4631      	mov	r1, r6
 c04c2c0:	2230      	movs	r2, #48	@ 0x30
 c04c2c2:	a80a      	add	r0, sp, #40	@ 0x28
{
 c04c2c4:	461d      	mov	r5, r3
    PKA_HandleTypeDef hpka = {0};
 c04c2c6:	e9cd 6607 	strd	r6, r6, [sp, #28]
 c04c2ca:	9609      	str	r6, [sp, #36]	@ 0x24
    PKA_ECDSASignInTypeDef ECDSA_SignIn = {0};
 c04c2cc:	f00f fa2f 	bl	c05b72e <memset>
    if( ! mbedtls_ecdsa_can_do( grp->id ) || grp->N.p == NULL )
 c04c2d0:	7820      	ldrb	r0, [r4, #0]
 c04c2d2:	f7ff ffe7 	bl	c04c2a4 <mbedtls_ecdsa_can_do>
 c04c2d6:	2800      	cmp	r0, #0
 c04c2d8:	f000 80dc 	beq.w	c04c494 <mbedtls_ecdsa_sign+0x1e4>
 c04c2dc:	6d63      	ldr	r3, [r4, #84]	@ 0x54
 c04c2de:	2b00      	cmp	r3, #0
 c04c2e0:	f000 80d8 	beq.w	c04c494 <mbedtls_ecdsa_sign+0x1e4>
    if( mbedtls_mpi_cmp_int( d, 1 ) < 0 || mbedtls_mpi_cmp_mpi( d, &grp->N ) >= 0 )
 c04c2e4:	2101      	movs	r1, #1
 c04c2e6:	4628      	mov	r0, r5
 c04c2e8:	f007 faeb 	bl	c0538c2 <mbedtls_mpi_cmp_int>
 c04c2ec:	42b0      	cmp	r0, r6
 c04c2ee:	da04      	bge.n	c04c2fa <mbedtls_ecdsa_sign+0x4a>
        return ( MBEDTLS_ERR_ECP_INVALID_KEY);
 c04c2f0:	4d69      	ldr	r5, [pc, #420]	@ (c04c498 <mbedtls_ecdsa_sign+0x1e8>)
}
 c04c2f2:	4628      	mov	r0, r5
 c04c2f4:	b017      	add	sp, #92	@ 0x5c
 c04c2f6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    if( mbedtls_mpi_cmp_int( d, 1 ) < 0 || mbedtls_mpi_cmp_mpi( d, &grp->N ) >= 0 )
 c04c2fa:	4628      	mov	r0, r5
 c04c2fc:	f104 014c 	add.w	r1, r4, #76	@ 0x4c
 c04c300:	f007 fa9c 	bl	c05383c <mbedtls_mpi_cmp_mpi>
 c04c304:	2800      	cmp	r0, #0
 c04c306:	daf3      	bge.n	c04c2f0 <mbedtls_ecdsa_sign+0x40>
    ECDSA_SignIn.modulusSize    = grp->st_modulus_size;
 c04c308:	6fe3      	ldr	r3, [r4, #124]	@ 0x7c
    ECDSA_SignIn.primeOrderSize = grp->st_order_size;
 c04c30a:	f8d4 0080 	ldr.w	r0, [r4, #128]	@ 0x80
    ECDSA_SignIn.modulusSize    = grp->st_modulus_size;
 c04c30e:	930b      	str	r3, [sp, #44]	@ 0x2c
    ECDSA_SignIn.modulus        = grp->st_p;
 c04c310:	f8d4 3084 	ldr.w	r3, [r4, #132]	@ 0x84
    d_binary = mbedtls_calloc(grp->st_order_size, sizeof( uint8_t ));
 c04c314:	2101      	movs	r1, #1
    ECDSA_SignIn.modulus        = grp->st_p;
 c04c316:	930f      	str	r3, [sp, #60]	@ 0x3c
    ECDSA_SignIn.coefSign       = grp->st_a_sign;
 c04c318:	f8d4 3088 	ldr.w	r3, [r4, #136]	@ 0x88
    ECDSA_SignIn.primeOrderSize = grp->st_order_size;
 c04c31c:	900a      	str	r0, [sp, #40]	@ 0x28
    ECDSA_SignIn.coefSign       = grp->st_a_sign;
 c04c31e:	930c      	str	r3, [sp, #48]	@ 0x30
    ECDSA_SignIn.coef           = grp->st_a_abs;
 c04c320:	f8d4 308c 	ldr.w	r3, [r4, #140]	@ 0x8c
 c04c324:	930d      	str	r3, [sp, #52]	@ 0x34
    ECDSA_SignIn.coefB          = grp->st_b;
 c04c326:	f8d4 3090 	ldr.w	r3, [r4, #144]	@ 0x90
 c04c32a:	930e      	str	r3, [sp, #56]	@ 0x38
    ECDSA_SignIn.basePointX     = grp->st_gx;
 c04c32c:	f8d4 3094 	ldr.w	r3, [r4, #148]	@ 0x94
 c04c330:	9311      	str	r3, [sp, #68]	@ 0x44
    ECDSA_SignIn.basePointY     = grp->st_gy;
 c04c332:	f8d4 3098 	ldr.w	r3, [r4, #152]	@ 0x98
 c04c336:	9312      	str	r3, [sp, #72]	@ 0x48
    ECDSA_SignIn.primeOrder     = grp->st_n;
 c04c338:	f8d4 309c 	ldr.w	r3, [r4, #156]	@ 0x9c
 c04c33c:	9315      	str	r3, [sp, #84]	@ 0x54
    ECDSA_SignIn.hash = buf;
 c04c33e:	9b1e      	ldr	r3, [sp, #120]	@ 0x78
 c04c340:	9313      	str	r3, [sp, #76]	@ 0x4c
    d_binary = mbedtls_calloc(grp->st_order_size, sizeof( uint8_t ));
 c04c342:	f7ef f82f 	bl	c03b3a4 <mbedtls_calloc>
    MBEDTLS_MPI_CHK((d_binary == NULL) ? MBEDTLS_ERR_ECP_ALLOC_FAILED : 0);
 c04c346:	4607      	mov	r7, r0
 c04c348:	b910      	cbnz	r0, c04c350 <mbedtls_ecdsa_sign+0xa0>
    uint8_t *k_binary = NULL;
 c04c34a:	2600      	movs	r6, #0
    MBEDTLS_MPI_CHK((ECDSA_SignOut.RSign == NULL) ? MBEDTLS_ERR_ECP_ALLOC_FAILED : 0);
 c04c34c:	4d53      	ldr	r5, [pc, #332]	@ (c04c49c <mbedtls_ecdsa_sign+0x1ec>)
 c04c34e:	e045      	b.n	c04c3dc <mbedtls_ecdsa_sign+0x12c>
    MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( d, d_binary, grp->st_order_size ) );
 c04c350:	4601      	mov	r1, r0
 c04c352:	f8d4 2080 	ldr.w	r2, [r4, #128]	@ 0x80
 c04c356:	4628      	mov	r0, r5
 c04c358:	f007 f97e 	bl	c053658 <mbedtls_mpi_write_binary>
 c04c35c:	4605      	mov	r5, r0
 c04c35e:	2800      	cmp	r0, #0
 c04c360:	d13c      	bne.n	c04c3dc <mbedtls_ecdsa_sign+0x12c>
    mbedtls_mpi_init( &k );
 c04c362:	a804      	add	r0, sp, #16
    ECDSA_SignIn.privateKey = d_binary;
 c04c364:	9714      	str	r7, [sp, #80]	@ 0x50
    mbedtls_mpi_init( &k );
 c04c366:	f006 ffc6 	bl	c0532f6 <mbedtls_mpi_init>
    MBEDTLS_MPI_CHK( mbedtls_ecp_gen_privkey( grp, &k, f_rng, p_rng ) );
 c04c36a:	e9dd 2320 	ldrd	r2, r3, [sp, #128]	@ 0x80
 c04c36e:	4620      	mov	r0, r4
 c04c370:	a904      	add	r1, sp, #16
 c04c372:	f000 ffa9 	bl	c04d2c8 <mbedtls_ecp_gen_privkey>
 c04c376:	4605      	mov	r5, r0
 c04c378:	bb80      	cbnz	r0, c04c3dc <mbedtls_ecdsa_sign+0x12c>
    k_binary = mbedtls_calloc(grp->st_order_size, sizeof( uint8_t ));
 c04c37a:	2101      	movs	r1, #1
 c04c37c:	f8d4 0080 	ldr.w	r0, [r4, #128]	@ 0x80
 c04c380:	f7ef f810 	bl	c03b3a4 <mbedtls_calloc>
    MBEDTLS_MPI_CHK((k_binary == NULL) ? MBEDTLS_ERR_ECP_ALLOC_FAILED : 0);
 c04c384:	4606      	mov	r6, r0
 c04c386:	2800      	cmp	r0, #0
 c04c388:	d0df      	beq.n	c04c34a <mbedtls_ecdsa_sign+0x9a>
    MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( &k, k_binary, grp->st_order_size ) );
 c04c38a:	4601      	mov	r1, r0
 c04c38c:	f8d4 2080 	ldr.w	r2, [r4, #128]	@ 0x80
 c04c390:	a804      	add	r0, sp, #16
 c04c392:	f007 f961 	bl	c053658 <mbedtls_mpi_write_binary>
 c04c396:	4605      	mov	r5, r0
 c04c398:	bb00      	cbnz	r0, c04c3dc <mbedtls_ecdsa_sign+0x12c>
    __HAL_RCC_PKA_CLK_ENABLE();
 c04c39a:	4b41      	ldr	r3, [pc, #260]	@ (c04c4a0 <mbedtls_ecdsa_sign+0x1f0>)
    ECDSA_SignIn.integer = k_binary;
 c04c39c:	9610      	str	r6, [sp, #64]	@ 0x40
    __HAL_RCC_PKA_CLK_ENABLE();
 c04c39e:	f8d3 208c 	ldr.w	r2, [r3, #140]	@ 0x8c
    MBEDTLS_MPI_CHK((HAL_PKA_Init(&hpka) != HAL_OK) ? MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED : 0);
 c04c3a2:	a807      	add	r0, sp, #28
    __HAL_RCC_PKA_CLK_ENABLE();
 c04c3a4:	f442 2200 	orr.w	r2, r2, #524288	@ 0x80000
 c04c3a8:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
 c04c3ac:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 c04c3b0:	f403 2300 	and.w	r3, r3, #524288	@ 0x80000
 c04c3b4:	9301      	str	r3, [sp, #4]
 c04c3b6:	9b01      	ldr	r3, [sp, #4]
    hpka.Instance = PKA;
 c04c3b8:	4b3a      	ldr	r3, [pc, #232]	@ (c04c4a4 <mbedtls_ecdsa_sign+0x1f4>)
 c04c3ba:	9307      	str	r3, [sp, #28]
    MBEDTLS_MPI_CHK((HAL_PKA_Init(&hpka) != HAL_OK) ? MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED : 0);
 c04c3bc:	f7f3 fe67 	bl	c04008e <HAL_PKA_Init>
 c04c3c0:	b950      	cbnz	r0, c04c3d8 <mbedtls_ecdsa_sign+0x128>
    HAL_PKA_RAMReset(&hpka);
 c04c3c2:	a807      	add	r0, sp, #28
 c04c3c4:	f7f3 f902 	bl	c03f5cc <HAL_PKA_RAMReset>
    MBEDTLS_MPI_CHK((HAL_PKA_ECDSASign(&hpka, &ECDSA_SignIn, ST_ECDSA_TIMEOUT) != HAL_OK) ? MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED : 0);
 c04c3c8:	f241 3288 	movw	r2, #5000	@ 0x1388
 c04c3cc:	a90a      	add	r1, sp, #40	@ 0x28
 c04c3ce:	a807      	add	r0, sp, #28
 c04c3d0:	f7f3 fba8 	bl	c03fb24 <HAL_PKA_ECDSASign>
 c04c3d4:	4605      	mov	r5, r0
 c04c3d6:	b3a8      	cbz	r0, c04c444 <mbedtls_ecdsa_sign+0x194>
    MBEDTLS_MPI_CHK((HAL_PKA_Init(&hpka) != HAL_OK) ? MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED : 0);
 c04c3d8:	f06f 056f 	mvn.w	r5, #111	@ 0x6f
    HAL_PKA_DeInit(&hpka);
 c04c3dc:	a807      	add	r0, sp, #28
 c04c3de:	f7f3 f8cf 	bl	c03f580 <HAL_PKA_DeInit>
    __HAL_RCC_PKA_CLK_DISABLE();
 c04c3e2:	4a2f      	ldr	r2, [pc, #188]	@ (c04c4a0 <mbedtls_ecdsa_sign+0x1f0>)
    mbedtls_mpi_free( &k );
 c04c3e4:	a804      	add	r0, sp, #16
    __HAL_RCC_PKA_CLK_DISABLE();
 c04c3e6:	f8d2 308c 	ldr.w	r3, [r2, #140]	@ 0x8c
 c04c3ea:	f423 2300 	bic.w	r3, r3, #524288	@ 0x80000
 c04c3ee:	f8c2 308c 	str.w	r3, [r2, #140]	@ 0x8c
    mbedtls_mpi_free( &k );
 c04c3f2:	f006 ff86 	bl	c053302 <mbedtls_mpi_free>
    if (d_binary != NULL)
 c04c3f6:	b13f      	cbz	r7, c04c408 <mbedtls_ecdsa_sign+0x158>
        mbedtls_platform_zeroize(d_binary, grp->st_order_size);
 c04c3f8:	4638      	mov	r0, r7
 c04c3fa:	f8d4 1080 	ldr.w	r1, [r4, #128]	@ 0x80
 c04c3fe:	f7ee ffe7 	bl	c03b3d0 <mbedtls_platform_zeroize>
        mbedtls_free(d_binary);
 c04c402:	4638      	mov	r0, r7
 c04c404:	f7ee ffd4 	bl	c03b3b0 <mbedtls_free>
    if (k_binary != NULL)
 c04c408:	b13e      	cbz	r6, c04c41a <mbedtls_ecdsa_sign+0x16a>
        mbedtls_platform_zeroize(k_binary, grp->st_order_size);
 c04c40a:	4630      	mov	r0, r6
 c04c40c:	f8d4 1080 	ldr.w	r1, [r4, #128]	@ 0x80
 c04c410:	f7ee ffde 	bl	c03b3d0 <mbedtls_platform_zeroize>
        mbedtls_free(k_binary);
 c04c414:	4630      	mov	r0, r6
 c04c416:	f7ee ffcb 	bl	c03b3b0 <mbedtls_free>
    if (ECDSA_SignOut.RSign != NULL)
 c04c41a:	9802      	ldr	r0, [sp, #8]
 c04c41c:	b130      	cbz	r0, c04c42c <mbedtls_ecdsa_sign+0x17c>
        mbedtls_platform_zeroize(ECDSA_SignOut.RSign, grp->st_order_size);
 c04c41e:	f8d4 1080 	ldr.w	r1, [r4, #128]	@ 0x80
 c04c422:	f7ee ffd5 	bl	c03b3d0 <mbedtls_platform_zeroize>
        mbedtls_free(ECDSA_SignOut.RSign);
 c04c426:	9802      	ldr	r0, [sp, #8]
 c04c428:	f7ee ffc2 	bl	c03b3b0 <mbedtls_free>
    if (ECDSA_SignOut.SSign != NULL)
 c04c42c:	9803      	ldr	r0, [sp, #12]
 c04c42e:	2800      	cmp	r0, #0
 c04c430:	f43f af5f 	beq.w	c04c2f2 <mbedtls_ecdsa_sign+0x42>
        mbedtls_platform_zeroize(ECDSA_SignOut.SSign, grp->st_order_size);
 c04c434:	f8d4 1080 	ldr.w	r1, [r4, #128]	@ 0x80
 c04c438:	f7ee ffca 	bl	c03b3d0 <mbedtls_platform_zeroize>
        mbedtls_free(ECDSA_SignOut.SSign);
 c04c43c:	9803      	ldr	r0, [sp, #12]
 c04c43e:	f7ee ffb7 	bl	c03b3b0 <mbedtls_free>
 c04c442:	e756      	b.n	c04c2f2 <mbedtls_ecdsa_sign+0x42>
    ECDSA_SignOut.RSign = mbedtls_calloc(grp->st_order_size, sizeof( uint8_t ));
 c04c444:	2101      	movs	r1, #1
 c04c446:	f8d4 0080 	ldr.w	r0, [r4, #128]	@ 0x80
 c04c44a:	f7ee ffab 	bl	c03b3a4 <mbedtls_calloc>
 c04c44e:	9002      	str	r0, [sp, #8]
    MBEDTLS_MPI_CHK((ECDSA_SignOut.RSign == NULL) ? MBEDTLS_ERR_ECP_ALLOC_FAILED : 0);
 c04c450:	2800      	cmp	r0, #0
 c04c452:	f43f af7b 	beq.w	c04c34c <mbedtls_ecdsa_sign+0x9c>
    ECDSA_SignOut.SSign = mbedtls_calloc(grp->st_order_size, sizeof( uint8_t ));
 c04c456:	2101      	movs	r1, #1
 c04c458:	f8d4 0080 	ldr.w	r0, [r4, #128]	@ 0x80
 c04c45c:	f7ee ffa2 	bl	c03b3a4 <mbedtls_calloc>
 c04c460:	9003      	str	r0, [sp, #12]
    MBEDTLS_MPI_CHK((ECDSA_SignOut.SSign == NULL) ? MBEDTLS_ERR_ECP_ALLOC_FAILED : 0);
 c04c462:	2800      	cmp	r0, #0
 c04c464:	f43f af72 	beq.w	c04c34c <mbedtls_ecdsa_sign+0x9c>
    HAL_PKA_ECDSASign_GetResult(&hpka, &ECDSA_SignOut, NULL);
 c04c468:	462a      	mov	r2, r5
 c04c46a:	a902      	add	r1, sp, #8
 c04c46c:	a807      	add	r0, sp, #28
 c04c46e:	f7f3 f94f 	bl	c03f710 <HAL_PKA_ECDSASign_GetResult>
    MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( r, ECDSA_SignOut.RSign, grp->st_order_size ) );
 c04c472:	4648      	mov	r0, r9
 c04c474:	f8d4 2080 	ldr.w	r2, [r4, #128]	@ 0x80
 c04c478:	9902      	ldr	r1, [sp, #8]
 c04c47a:	f007 f896 	bl	c0535aa <mbedtls_mpi_read_binary>
 c04c47e:	4605      	mov	r5, r0
 c04c480:	2800      	cmp	r0, #0
 c04c482:	d1ab      	bne.n	c04c3dc <mbedtls_ecdsa_sign+0x12c>
    MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( s, ECDSA_SignOut.SSign, grp->st_order_size ) );
 c04c484:	4640      	mov	r0, r8
 c04c486:	f8d4 2080 	ldr.w	r2, [r4, #128]	@ 0x80
 c04c48a:	9903      	ldr	r1, [sp, #12]
 c04c48c:	f007 f88d 	bl	c0535aa <mbedtls_mpi_read_binary>
 c04c490:	4605      	mov	r5, r0
cleanup:
 c04c492:	e7a3      	b.n	c04c3dc <mbedtls_ecdsa_sign+0x12c>
        return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );
 c04c494:	4d04      	ldr	r5, [pc, #16]	@ (c04c4a8 <mbedtls_ecdsa_sign+0x1f8>)
 c04c496:	e72c      	b.n	c04c2f2 <mbedtls_ecdsa_sign+0x42>
 c04c498:	ffffb380 	.word	0xffffb380
 c04c49c:	ffffb280 	.word	0xffffb280
 c04c4a0:	56020c00 	.word	0x56020c00
 c04c4a4:	520c2000 	.word	0x520c2000
 c04c4a8:	ffffb080 	.word	0xffffb080

0c04c4ac <mbedtls_ecdsa_verify>:
int mbedtls_ecdsa_verify( mbedtls_ecp_group *grp,
                          const unsigned char *buf, size_t blen,
                          const mbedtls_ecp_point *Q,
                          const mbedtls_mpi *r,
                          const mbedtls_mpi *s)
{
 c04c4ac:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    size_t olen;
    uint8_t *Q_binary;
    uint8_t *r_binary = NULL;
    uint8_t *s_binary = NULL;
    PKA_HandleTypeDef hpka = {0};
 c04c4b0:	2600      	movs	r6, #0
{
 c04c4b2:	461d      	mov	r5, r3
    ECDSA_VALIDATE_RET( r   != NULL );
    ECDSA_VALIDATE_RET( s   != NULL );
    ECDSA_VALIDATE_RET( buf != NULL || blen == 0 );

    /* Fail cleanly on curves such as Curve25519 that can't be used for ECDSA */
    if( grp->G.Y.p == NULL )
 c04c4b4:	6bc3      	ldr	r3, [r0, #60]	@ 0x3c
{
 c04c4b6:	b094      	sub	sp, #80	@ 0x50
 c04c4b8:	4604      	mov	r4, r0
 c04c4ba:	e9dd a91c 	ldrd	sl, r9, [sp, #112]	@ 0x70
 c04c4be:	460f      	mov	r7, r1
    PKA_HandleTypeDef hpka = {0};
 c04c4c0:	e9cd 6604 	strd	r6, r6, [sp, #16]
 c04c4c4:	9606      	str	r6, [sp, #24]
    if( grp->G.Y.p == NULL )
 c04c4c6:	2b00      	cmp	r3, #0
 c04c4c8:	f000 80cd 	beq.w	c04c666 <mbedtls_ecdsa_verify+0x1ba>
        return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );

    /* Make sure r and s are in range 1..n-1 */
    if( mbedtls_mpi_cmp_int( r, 1 ) < 0 || mbedtls_mpi_cmp_mpi( r, &grp->N ) >= 0 ||
 c04c4cc:	2101      	movs	r1, #1
 c04c4ce:	4650      	mov	r0, sl
 c04c4d0:	f007 f9f7 	bl	c0538c2 <mbedtls_mpi_cmp_int>
 c04c4d4:	42b0      	cmp	r0, r6
 c04c4d6:	da04      	bge.n	c04c4e2 <mbedtls_ecdsa_verify+0x36>
        mbedtls_mpi_cmp_int( s, 1 ) < 0 || mbedtls_mpi_cmp_mpi( s, &grp->N ) >= 0 )
        return( MBEDTLS_ERR_ECP_VERIFY_FAILED );
 c04c4d8:	4d64      	ldr	r5, [pc, #400]	@ (c04c66c <mbedtls_ecdsa_verify+0x1c0>)
        mbedtls_platform_zeroize(s_binary, grp->st_order_size);
        mbedtls_free(s_binary);
    }

    return ret;
}
 c04c4da:	4628      	mov	r0, r5
 c04c4dc:	b014      	add	sp, #80	@ 0x50
 c04c4de:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if( mbedtls_mpi_cmp_int( r, 1 ) < 0 || mbedtls_mpi_cmp_mpi( r, &grp->N ) >= 0 ||
 c04c4e2:	f104 084c 	add.w	r8, r4, #76	@ 0x4c
 c04c4e6:	4641      	mov	r1, r8
 c04c4e8:	4650      	mov	r0, sl
 c04c4ea:	f007 f9a7 	bl	c05383c <mbedtls_mpi_cmp_mpi>
 c04c4ee:	2800      	cmp	r0, #0
 c04c4f0:	daf2      	bge.n	c04c4d8 <mbedtls_ecdsa_verify+0x2c>
        mbedtls_mpi_cmp_int( s, 1 ) < 0 || mbedtls_mpi_cmp_mpi( s, &grp->N ) >= 0 )
 c04c4f2:	2101      	movs	r1, #1
 c04c4f4:	4648      	mov	r0, r9
 c04c4f6:	f007 f9e4 	bl	c0538c2 <mbedtls_mpi_cmp_int>
    if( mbedtls_mpi_cmp_int( r, 1 ) < 0 || mbedtls_mpi_cmp_mpi( r, &grp->N ) >= 0 ||
 c04c4fa:	2800      	cmp	r0, #0
 c04c4fc:	dbec      	blt.n	c04c4d8 <mbedtls_ecdsa_verify+0x2c>
        mbedtls_mpi_cmp_int( s, 1 ) < 0 || mbedtls_mpi_cmp_mpi( s, &grp->N ) >= 0 )
 c04c4fe:	4641      	mov	r1, r8
 c04c500:	4648      	mov	r0, r9
 c04c502:	f007 f99b 	bl	c05383c <mbedtls_mpi_cmp_mpi>
 c04c506:	2800      	cmp	r0, #0
 c04c508:	dae6      	bge.n	c04c4d8 <mbedtls_ecdsa_verify+0x2c>
    Q_binary = mbedtls_calloc( ( 2U * grp->st_modulus_size ) + 1U, sizeof( uint8_t ) );
 c04c50a:	2101      	movs	r1, #1
    ECDSA_VerifyIn.primeOrderSize = grp->st_order_size;
 c04c50c:	f8d4 3080 	ldr.w	r3, [r4, #128]	@ 0x80
    ECDSA_VerifyIn.modulusSize    = grp->st_modulus_size;
 c04c510:	6fe0      	ldr	r0, [r4, #124]	@ 0x7c
    ECDSA_VerifyIn.primeOrderSize = grp->st_order_size;
 c04c512:	9307      	str	r3, [sp, #28]
    ECDSA_VerifyIn.modulus        = grp->st_p;
 c04c514:	f8d4 3084 	ldr.w	r3, [r4, #132]	@ 0x84
    ECDSA_VerifyIn.modulusSize    = grp->st_modulus_size;
 c04c518:	9008      	str	r0, [sp, #32]
    ECDSA_VerifyIn.modulus        = grp->st_p;
 c04c51a:	930b      	str	r3, [sp, #44]	@ 0x2c
    ECDSA_VerifyIn.coefSign       = grp->st_a_sign;
 c04c51c:	f8d4 3088 	ldr.w	r3, [r4, #136]	@ 0x88
    Q_binary = mbedtls_calloc( ( 2U * grp->st_modulus_size ) + 1U, sizeof( uint8_t ) );
 c04c520:	0040      	lsls	r0, r0, #1
    ECDSA_VerifyIn.coefSign       = grp->st_a_sign;
 c04c522:	9309      	str	r3, [sp, #36]	@ 0x24
    ECDSA_VerifyIn.coef           = grp->st_a_abs;
 c04c524:	f8d4 308c 	ldr.w	r3, [r4, #140]	@ 0x8c
    Q_binary = mbedtls_calloc( ( 2U * grp->st_modulus_size ) + 1U, sizeof( uint8_t ) );
 c04c528:	4408      	add	r0, r1
    ECDSA_VerifyIn.coef           = grp->st_a_abs;
 c04c52a:	930a      	str	r3, [sp, #40]	@ 0x28
    ECDSA_VerifyIn.basePointX     = grp->st_gx;
 c04c52c:	f8d4 3094 	ldr.w	r3, [r4, #148]	@ 0x94
 c04c530:	930c      	str	r3, [sp, #48]	@ 0x30
    ECDSA_VerifyIn.basePointY     = grp->st_gy;
 c04c532:	f8d4 3098 	ldr.w	r3, [r4, #152]	@ 0x98
 c04c536:	930d      	str	r3, [sp, #52]	@ 0x34
    ECDSA_VerifyIn.primeOrder     = grp->st_n;
 c04c538:	f8d4 309c 	ldr.w	r3, [r4, #156]	@ 0x9c
    ECDSA_VerifyIn.hash = buf;
 c04c53c:	e9cd 7312 	strd	r7, r3, [sp, #72]	@ 0x48
    Q_binary = mbedtls_calloc( ( 2U * grp->st_modulus_size ) + 1U, sizeof( uint8_t ) );
 c04c540:	f7ee ff30 	bl	c03b3a4 <mbedtls_calloc>
    MBEDTLS_MPI_CHK((Q_binary == NULL) ? MBEDTLS_ERR_ECP_ALLOC_FAILED : 0);
 c04c544:	4680      	mov	r8, r0
 c04c546:	b918      	cbnz	r0, c04c550 <mbedtls_ecdsa_verify+0xa4>
    uint8_t *s_binary = NULL;
 c04c548:	2600      	movs	r6, #0
    uint8_t *r_binary = NULL;
 c04c54a:	4637      	mov	r7, r6
    MBEDTLS_MPI_CHK((s_binary == NULL) ? MBEDTLS_ERR_ECP_ALLOC_FAILED : 0);
 c04c54c:	4d48      	ldr	r5, [pc, #288]	@ (c04c670 <mbedtls_ecdsa_verify+0x1c4>)
 c04c54e:	e055      	b.n	c04c5fc <mbedtls_ecdsa_verify+0x150>
    MBEDTLS_MPI_CHK( mbedtls_ecp_point_write_binary( grp, Q, MBEDTLS_ECP_PF_UNCOMPRESSED, &olen, Q_binary, ( 2U * grp->st_modulus_size ) + 1U ) );
 c04c550:	6fe2      	ldr	r2, [r4, #124]	@ 0x7c
 c04c552:	4629      	mov	r1, r5
 c04c554:	0052      	lsls	r2, r2, #1
 c04c556:	3201      	adds	r2, #1
 c04c558:	e9cd 0200 	strd	r0, r2, [sp]
 c04c55c:	ab02      	add	r3, sp, #8
 c04c55e:	4632      	mov	r2, r6
 c04c560:	4620      	mov	r0, r4
 c04c562:	f000 fa43 	bl	c04c9ec <mbedtls_ecp_point_write_binary>
 c04c566:	4605      	mov	r5, r0
 c04c568:	2800      	cmp	r0, #0
 c04c56a:	d17a      	bne.n	c04c662 <mbedtls_ecdsa_verify+0x1b6>
    ECDSA_VerifyIn.pPubKeyCurvePtX = Q_binary + 1U;
 c04c56c:	f108 0301 	add.w	r3, r8, #1
 c04c570:	930e      	str	r3, [sp, #56]	@ 0x38
    ECDSA_VerifyIn.pPubKeyCurvePtY = Q_binary + grp->st_modulus_size + 1U;
 c04c572:	6fe3      	ldr	r3, [r4, #124]	@ 0x7c
    r_binary = mbedtls_calloc(grp->st_order_size, sizeof( uint8_t ));
 c04c574:	2101      	movs	r1, #1
    ECDSA_VerifyIn.pPubKeyCurvePtY = Q_binary + grp->st_modulus_size + 1U;
 c04c576:	3301      	adds	r3, #1
 c04c578:	4443      	add	r3, r8
    r_binary = mbedtls_calloc(grp->st_order_size, sizeof( uint8_t ));
 c04c57a:	f8d4 0080 	ldr.w	r0, [r4, #128]	@ 0x80
    ECDSA_VerifyIn.pPubKeyCurvePtY = Q_binary + grp->st_modulus_size + 1U;
 c04c57e:	930f      	str	r3, [sp, #60]	@ 0x3c
    r_binary = mbedtls_calloc(grp->st_order_size, sizeof( uint8_t ));
 c04c580:	f7ee ff10 	bl	c03b3a4 <mbedtls_calloc>
    MBEDTLS_MPI_CHK((r_binary == NULL) ? MBEDTLS_ERR_ECP_ALLOC_FAILED : 0);
 c04c584:	4607      	mov	r7, r0
 c04c586:	2800      	cmp	r0, #0
 c04c588:	d0de      	beq.n	c04c548 <mbedtls_ecdsa_verify+0x9c>
    s_binary = mbedtls_calloc(grp->st_order_size, sizeof( uint8_t ));
 c04c58a:	2101      	movs	r1, #1
 c04c58c:	f8d4 0080 	ldr.w	r0, [r4, #128]	@ 0x80
 c04c590:	f7ee ff08 	bl	c03b3a4 <mbedtls_calloc>
    MBEDTLS_MPI_CHK((s_binary == NULL) ? MBEDTLS_ERR_ECP_ALLOC_FAILED : 0);
 c04c594:	4606      	mov	r6, r0
 c04c596:	2800      	cmp	r0, #0
 c04c598:	d0d8      	beq.n	c04c54c <mbedtls_ecdsa_verify+0xa0>
    MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( r, r_binary, grp->st_order_size ) );
 c04c59a:	4639      	mov	r1, r7
 c04c59c:	4650      	mov	r0, sl
 c04c59e:	f8d4 2080 	ldr.w	r2, [r4, #128]	@ 0x80
 c04c5a2:	f007 f859 	bl	c053658 <mbedtls_mpi_write_binary>
 c04c5a6:	4605      	mov	r5, r0
 c04c5a8:	bb40      	cbnz	r0, c04c5fc <mbedtls_ecdsa_verify+0x150>
    MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( s, s_binary, grp->st_order_size ) );
 c04c5aa:	4631      	mov	r1, r6
 c04c5ac:	4648      	mov	r0, r9
 c04c5ae:	f8d4 2080 	ldr.w	r2, [r4, #128]	@ 0x80
    ECDSA_VerifyIn.RSign = r_binary;
 c04c5b2:	9710      	str	r7, [sp, #64]	@ 0x40
    MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( s, s_binary, grp->st_order_size ) );
 c04c5b4:	f007 f850 	bl	c053658 <mbedtls_mpi_write_binary>
 c04c5b8:	4605      	mov	r5, r0
 c04c5ba:	b9f8      	cbnz	r0, c04c5fc <mbedtls_ecdsa_verify+0x150>
    __HAL_RCC_PKA_CLK_ENABLE();
 c04c5bc:	4b2d      	ldr	r3, [pc, #180]	@ (c04c674 <mbedtls_ecdsa_verify+0x1c8>)
    ECDSA_VerifyIn.SSign = s_binary;
 c04c5be:	9611      	str	r6, [sp, #68]	@ 0x44
    __HAL_RCC_PKA_CLK_ENABLE();
 c04c5c0:	f8d3 208c 	ldr.w	r2, [r3, #140]	@ 0x8c
    MBEDTLS_MPI_CHK((HAL_PKA_Init(&hpka) != HAL_OK) ? MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED : 0);
 c04c5c4:	a804      	add	r0, sp, #16
    __HAL_RCC_PKA_CLK_ENABLE();
 c04c5c6:	f442 2200 	orr.w	r2, r2, #524288	@ 0x80000
 c04c5ca:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
 c04c5ce:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 c04c5d2:	f403 2300 	and.w	r3, r3, #524288	@ 0x80000
 c04c5d6:	9303      	str	r3, [sp, #12]
 c04c5d8:	9b03      	ldr	r3, [sp, #12]
    hpka.Instance = PKA;
 c04c5da:	4b27      	ldr	r3, [pc, #156]	@ (c04c678 <mbedtls_ecdsa_verify+0x1cc>)
 c04c5dc:	9304      	str	r3, [sp, #16]
    MBEDTLS_MPI_CHK((HAL_PKA_Init(&hpka) != HAL_OK) ? MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED : 0);
 c04c5de:	f7f3 fd56 	bl	c04008e <HAL_PKA_Init>
 c04c5e2:	b948      	cbnz	r0, c04c5f8 <mbedtls_ecdsa_verify+0x14c>
    HAL_PKA_RAMReset(&hpka);
 c04c5e4:	a804      	add	r0, sp, #16
 c04c5e6:	f7f2 fff1 	bl	c03f5cc <HAL_PKA_RAMReset>
    MBEDTLS_MPI_CHK((HAL_PKA_ECDSAVerif(&hpka, &ECDSA_VerifyIn, ST_ECDSA_TIMEOUT) != HAL_OK) ? MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED : 0);
 c04c5ea:	f241 3288 	movw	r2, #5000	@ 0x1388
 c04c5ee:	a907      	add	r1, sp, #28
 c04c5f0:	a804      	add	r0, sp, #16
 c04c5f2:	f7f3 fb5f 	bl	c03fcb4 <HAL_PKA_ECDSAVerif>
 c04c5f6:	b360      	cbz	r0, c04c652 <mbedtls_ecdsa_verify+0x1a6>
    MBEDTLS_MPI_CHK((HAL_PKA_Init(&hpka) != HAL_OK) ? MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED : 0);
 c04c5f8:	f06f 056f 	mvn.w	r5, #111	@ 0x6f
    HAL_PKA_DeInit(&hpka);
 c04c5fc:	a804      	add	r0, sp, #16
 c04c5fe:	f7f2 ffbf 	bl	c03f580 <HAL_PKA_DeInit>
    __HAL_RCC_PKA_CLK_DISABLE();
 c04c602:	4a1c      	ldr	r2, [pc, #112]	@ (c04c674 <mbedtls_ecdsa_verify+0x1c8>)
 c04c604:	f8d2 308c 	ldr.w	r3, [r2, #140]	@ 0x8c
 c04c608:	f423 2300 	bic.w	r3, r3, #524288	@ 0x80000
 c04c60c:	f8c2 308c 	str.w	r3, [r2, #140]	@ 0x8c
    if (Q_binary != NULL)
 c04c610:	f1b8 0f00 	cmp.w	r8, #0
 c04c614:	d008      	beq.n	c04c628 <mbedtls_ecdsa_verify+0x17c>
        mbedtls_platform_zeroize(Q_binary, ( 2U * grp->st_modulus_size ) + 1U );
 c04c616:	6fe1      	ldr	r1, [r4, #124]	@ 0x7c
 c04c618:	4640      	mov	r0, r8
 c04c61a:	0049      	lsls	r1, r1, #1
 c04c61c:	3101      	adds	r1, #1
 c04c61e:	f7ee fed7 	bl	c03b3d0 <mbedtls_platform_zeroize>
        mbedtls_free(Q_binary);
 c04c622:	4640      	mov	r0, r8
 c04c624:	f7ee fec4 	bl	c03b3b0 <mbedtls_free>
    if (r_binary != NULL)
 c04c628:	b13f      	cbz	r7, c04c63a <mbedtls_ecdsa_verify+0x18e>
        mbedtls_platform_zeroize(r_binary, grp->st_order_size);
 c04c62a:	4638      	mov	r0, r7
 c04c62c:	f8d4 1080 	ldr.w	r1, [r4, #128]	@ 0x80
 c04c630:	f7ee fece 	bl	c03b3d0 <mbedtls_platform_zeroize>
        mbedtls_free(r_binary);
 c04c634:	4638      	mov	r0, r7
 c04c636:	f7ee febb 	bl	c03b3b0 <mbedtls_free>
    if (s_binary != NULL)
 c04c63a:	2e00      	cmp	r6, #0
 c04c63c:	f43f af4d 	beq.w	c04c4da <mbedtls_ecdsa_verify+0x2e>
        mbedtls_platform_zeroize(s_binary, grp->st_order_size);
 c04c640:	4630      	mov	r0, r6
 c04c642:	f8d4 1080 	ldr.w	r1, [r4, #128]	@ 0x80
 c04c646:	f7ee fec3 	bl	c03b3d0 <mbedtls_platform_zeroize>
        mbedtls_free(s_binary);
 c04c64a:	4630      	mov	r0, r6
 c04c64c:	f7ee feb0 	bl	c03b3b0 <mbedtls_free>
 c04c650:	e743      	b.n	c04c4da <mbedtls_ecdsa_verify+0x2e>
    MBEDTLS_MPI_CHK((HAL_PKA_ECDSAVerif_IsValidSignature(&hpka) != 1U) ? MBEDTLS_ERR_ECP_VERIFY_FAILED : 0);
 c04c652:	a804      	add	r0, sp, #16
 c04c654:	f7f2 ffa8 	bl	c03f5a8 <HAL_PKA_ECDSAVerif_IsValidSignature>
 c04c658:	4b04      	ldr	r3, [pc, #16]	@ (c04c66c <mbedtls_ecdsa_verify+0x1c0>)
 c04c65a:	2801      	cmp	r0, #1
 c04c65c:	bf18      	it	ne
 c04c65e:	461d      	movne	r5, r3
 c04c660:	e7cc      	b.n	c04c5fc <mbedtls_ecdsa_verify+0x150>
    uint8_t *r_binary = NULL;
 c04c662:	4637      	mov	r7, r6
 c04c664:	e7ca      	b.n	c04c5fc <mbedtls_ecdsa_verify+0x150>
        return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );
 c04c666:	4d05      	ldr	r5, [pc, #20]	@ (c04c67c <mbedtls_ecdsa_verify+0x1d0>)
 c04c668:	e737      	b.n	c04c4da <mbedtls_ecdsa_verify+0x2e>
 c04c66a:	bf00      	nop
 c04c66c:	ffffb200 	.word	0xffffb200
 c04c670:	ffffb280 	.word	0xffffb280
 c04c674:	56020c00 	.word	0x56020c00
 c04c678:	520c2000 	.word	0x520c2000
 c04c67c:	ffffb080 	.word	0xffffb080

0c04c680 <mbedtls_mpi_mul_mod>:

static inline int mbedtls_mpi_mul_mod( const mbedtls_ecp_group *grp,
                                       mbedtls_mpi *X,
                                       const mbedtls_mpi *A,
                                       const mbedtls_mpi *B )
{
 c04c680:	b570      	push	{r4, r5, r6, lr}
 c04c682:	460c      	mov	r4, r1
 c04c684:	4606      	mov	r6, r0
 c04c686:	4611      	mov	r1, r2
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( X, A, B ) );
 c04c688:	4620      	mov	r0, r4
 c04c68a:	461a      	mov	r2, r3
 c04c68c:	f007 fa68 	bl	c053b60 <mbedtls_mpi_mul_mpi>
 c04c690:	4605      	mov	r5, r0
 c04c692:	b998      	cbnz	r0, c04c6bc <mbedtls_mpi_mul_mod+0x3c>
    if( grp->modp == NULL )
 c04c694:	6e73      	ldr	r3, [r6, #100]	@ 0x64
 c04c696:	b933      	cbnz	r3, c04c6a6 <mbedtls_mpi_mul_mod+0x26>
        return( mbedtls_mpi_mod_mpi( N, N, &grp->P ) );
 c04c698:	4621      	mov	r1, r4
 c04c69a:	4620      	mov	r0, r4
 c04c69c:	1d32      	adds	r2, r6, #4
    MOD_MUL( *X );
cleanup:
    return( ret );
}
 c04c69e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        return( mbedtls_mpi_mod_mpi( N, N, &grp->P ) );
 c04c6a2:	f007 bd1a 	b.w	c0540da <mbedtls_mpi_mod_mpi>
    if( ( N->s < 0 && mbedtls_mpi_cmp_int( N, 0 ) != 0 ) ||
 c04c6a6:	6823      	ldr	r3, [r4, #0]
 c04c6a8:	2b00      	cmp	r3, #0
 c04c6aa:	db09      	blt.n	c04c6c0 <mbedtls_mpi_mul_mod+0x40>
        mbedtls_mpi_bitlen( N ) > 2 * grp->pbits )
 c04c6ac:	4620      	mov	r0, r4
 c04c6ae:	f006 ff36 	bl	c05351e <mbedtls_mpi_bitlen>
 c04c6b2:	6db3      	ldr	r3, [r6, #88]	@ 0x58
    if( ( N->s < 0 && mbedtls_mpi_cmp_int( N, 0 ) != 0 ) ||
 c04c6b4:	ebb0 0f43 	cmp.w	r0, r3, lsl #1
 c04c6b8:	d909      	bls.n	c04c6ce <mbedtls_mpi_mul_mod+0x4e>
        return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );
 c04c6ba:	4d18      	ldr	r5, [pc, #96]	@ (c04c71c <mbedtls_mpi_mul_mod+0x9c>)
}
 c04c6bc:	4628      	mov	r0, r5
 c04c6be:	bd70      	pop	{r4, r5, r6, pc}
    if( ( N->s < 0 && mbedtls_mpi_cmp_int( N, 0 ) != 0 ) ||
 c04c6c0:	4601      	mov	r1, r0
 c04c6c2:	4620      	mov	r0, r4
 c04c6c4:	f007 f8fd 	bl	c0538c2 <mbedtls_mpi_cmp_int>
 c04c6c8:	2800      	cmp	r0, #0
 c04c6ca:	d0ef      	beq.n	c04c6ac <mbedtls_mpi_mul_mod+0x2c>
 c04c6cc:	e7f5      	b.n	c04c6ba <mbedtls_mpi_mul_mod+0x3a>
    MBEDTLS_MPI_CHK( grp->modp( N ) );
 c04c6ce:	4620      	mov	r0, r4
 c04c6d0:	6e73      	ldr	r3, [r6, #100]	@ 0x64
 c04c6d2:	4798      	blx	r3
 c04c6d4:	4605      	mov	r5, r0
 c04c6d6:	2800      	cmp	r0, #0
 c04c6d8:	d1f0      	bne.n	c04c6bc <mbedtls_mpi_mul_mod+0x3c>
        return( mbedtls_mpi_mod_mpi( N, N, &grp->P ) );
 c04c6da:	3604      	adds	r6, #4
    while( N->s < 0 && mbedtls_mpi_cmp_int( N, 0 ) != 0 )
 c04c6dc:	6823      	ldr	r3, [r4, #0]
 c04c6de:	2b00      	cmp	r3, #0
 c04c6e0:	da04      	bge.n	c04c6ec <mbedtls_mpi_mul_mod+0x6c>
 c04c6e2:	2100      	movs	r1, #0
 c04c6e4:	4620      	mov	r0, r4
 c04c6e6:	f007 f8ec 	bl	c0538c2 <mbedtls_mpi_cmp_int>
 c04c6ea:	b968      	cbnz	r0, c04c708 <mbedtls_mpi_mul_mod+0x88>
    while( mbedtls_mpi_cmp_mpi( N, &grp->P ) >= 0 )
 c04c6ec:	4631      	mov	r1, r6
 c04c6ee:	4620      	mov	r0, r4
 c04c6f0:	f007 f8a4 	bl	c05383c <mbedtls_mpi_cmp_mpi>
 c04c6f4:	2800      	cmp	r0, #0
 c04c6f6:	dbe1      	blt.n	c04c6bc <mbedtls_mpi_mul_mod+0x3c>
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_abs( N, N, &grp->P ) );
 c04c6f8:	4632      	mov	r2, r6
 c04c6fa:	4621      	mov	r1, r4
 c04c6fc:	4620      	mov	r0, r4
 c04c6fe:	f007 f94d 	bl	c05399c <mbedtls_mpi_sub_abs>
 c04c702:	2800      	cmp	r0, #0
 c04c704:	d0f2      	beq.n	c04c6ec <mbedtls_mpi_mul_mod+0x6c>
 c04c706:	e006      	b.n	c04c716 <mbedtls_mpi_mul_mod+0x96>
        MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( N, N, &grp->P ) );
 c04c708:	4632      	mov	r2, r6
 c04c70a:	4621      	mov	r1, r4
 c04c70c:	4620      	mov	r0, r4
 c04c70e:	f007 f9b4 	bl	c053a7a <mbedtls_mpi_add_mpi>
 c04c712:	2800      	cmp	r0, #0
 c04c714:	d0e2      	beq.n	c04c6dc <mbedtls_mpi_mul_mod+0x5c>
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_abs( N, N, &grp->P ) );
 c04c716:	4605      	mov	r5, r0
    return( ret );
 c04c718:	e7d0      	b.n	c04c6bc <mbedtls_mpi_mul_mod+0x3c>
 c04c71a:	bf00      	nop
 c04c71c:	ffffb080 	.word	0xffffb080

0c04c720 <mbedtls_mpi_add_mod.part.0>:
 */
#define MOD_ADD( N )                                                    \
    while( mbedtls_mpi_cmp_mpi( &(N), &grp->P ) >= 0 )                  \
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_abs( &(N), &(N), &grp->P ) )

static inline int mbedtls_mpi_add_mod( const mbedtls_ecp_group *grp,
 c04c720:	b538      	push	{r3, r4, r5, lr}
 c04c722:	460c      	mov	r4, r1
                                       const mbedtls_mpi *A,
                                       const mbedtls_mpi *B )
{
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( X, A, B ) );
    MOD_ADD( *X );
 c04c724:	1d05      	adds	r5, r0, #4
 c04c726:	4629      	mov	r1, r5
 c04c728:	4620      	mov	r0, r4
 c04c72a:	f007 f887 	bl	c05383c <mbedtls_mpi_cmp_mpi>
 c04c72e:	2800      	cmp	r0, #0
 c04c730:	da01      	bge.n	c04c736 <mbedtls_mpi_add_mod.part.0+0x16>
cleanup:
 c04c732:	2000      	movs	r0, #0
    return( ret );
 c04c734:	e006      	b.n	c04c744 <mbedtls_mpi_add_mod.part.0+0x24>
    MOD_ADD( *X );
 c04c736:	462a      	mov	r2, r5
 c04c738:	4621      	mov	r1, r4
 c04c73a:	4620      	mov	r0, r4
 c04c73c:	f007 f92e 	bl	c05399c <mbedtls_mpi_sub_abs>
 c04c740:	2800      	cmp	r0, #0
 c04c742:	d0f0      	beq.n	c04c726 <mbedtls_mpi_add_mod.part.0+0x6>
}
 c04c744:	bd38      	pop	{r3, r4, r5, pc}

0c04c746 <mbedtls_mpi_add_mod>:
{
 c04c746:	b538      	push	{r3, r4, r5, lr}
 c04c748:	460c      	mov	r4, r1
 c04c74a:	4605      	mov	r5, r0
 c04c74c:	4611      	mov	r1, r2
    MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( X, A, B ) );
 c04c74e:	4620      	mov	r0, r4
 c04c750:	461a      	mov	r2, r3
 c04c752:	f007 f992 	bl	c053a7a <mbedtls_mpi_add_mpi>
 c04c756:	b928      	cbnz	r0, c04c764 <mbedtls_mpi_add_mod+0x1e>
 c04c758:	4621      	mov	r1, r4
 c04c75a:	4628      	mov	r0, r5
}
 c04c75c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 c04c760:	f7ff bfde 	b.w	c04c720 <mbedtls_mpi_add_mod.part.0>
 c04c764:	bd38      	pop	{r3, r4, r5, pc}

0c04c766 <mbedtls_mpi_sub_mod>:
{
 c04c766:	b570      	push	{r4, r5, r6, lr}
 c04c768:	460c      	mov	r4, r1
 c04c76a:	4606      	mov	r6, r0
 c04c76c:	4611      	mov	r1, r2
    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( X, A, B ) );
 c04c76e:	4620      	mov	r0, r4
 c04c770:	461a      	mov	r2, r3
 c04c772:	f007 f9a5 	bl	c053ac0 <mbedtls_mpi_sub_mpi>
 c04c776:	4605      	mov	r5, r0
 c04c778:	b940      	cbnz	r0, c04c78c <mbedtls_mpi_sub_mod+0x26>
    MOD_SUB( *X );
 c04c77a:	3604      	adds	r6, #4
 c04c77c:	6823      	ldr	r3, [r4, #0]
 c04c77e:	2b00      	cmp	r3, #0
 c04c780:	da04      	bge.n	c04c78c <mbedtls_mpi_sub_mod+0x26>
 c04c782:	2100      	movs	r1, #0
 c04c784:	4620      	mov	r0, r4
 c04c786:	f007 f89c 	bl	c0538c2 <mbedtls_mpi_cmp_int>
 c04c78a:	b908      	cbnz	r0, c04c790 <mbedtls_mpi_sub_mod+0x2a>
}
 c04c78c:	4628      	mov	r0, r5
 c04c78e:	bd70      	pop	{r4, r5, r6, pc}
    MOD_SUB( *X );
 c04c790:	4632      	mov	r2, r6
 c04c792:	4621      	mov	r1, r4
 c04c794:	4620      	mov	r0, r4
 c04c796:	f007 f970 	bl	c053a7a <mbedtls_mpi_add_mpi>
 c04c79a:	2800      	cmp	r0, #0
 c04c79c:	d0ee      	beq.n	c04c77c <mbedtls_mpi_sub_mod+0x16>
 c04c79e:	4605      	mov	r5, r0
    return( ret );
 c04c7a0:	e7f4      	b.n	c04c78c <mbedtls_mpi_sub_mod+0x26>

0c04c7a2 <mbedtls_ecp_point_free.part.0>:
void mbedtls_ecp_point_free( mbedtls_ecp_point *pt )
 c04c7a2:	b510      	push	{r4, lr}
 c04c7a4:	4604      	mov	r4, r0
    mbedtls_mpi_free( &( pt->X ) );
 c04c7a6:	f006 fdac 	bl	c053302 <mbedtls_mpi_free>
    mbedtls_mpi_free( &( pt->Y ) );
 c04c7aa:	f104 000c 	add.w	r0, r4, #12
 c04c7ae:	f006 fda8 	bl	c053302 <mbedtls_mpi_free>
    mbedtls_mpi_free( &( pt->Z ) );
 c04c7b2:	f104 0018 	add.w	r0, r4, #24
}
 c04c7b6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mbedtls_mpi_free( &( pt->Z ) );
 c04c7ba:	f006 bda2 	b.w	c053302 <mbedtls_mpi_free>
	...

0c04c7c0 <mbedtls_ecp_curve_info_from_grp_id>:
{
 c04c7c0:	4602      	mov	r2, r0
    for( curve_info = mbedtls_ecp_curve_list();
 c04c7c2:	4804      	ldr	r0, [pc, #16]	@ (c04c7d4 <mbedtls_ecp_curve_info_from_grp_id+0x14>)
         curve_info->grp_id != MBEDTLS_ECP_DP_NONE;
 c04c7c4:	7803      	ldrb	r3, [r0, #0]
 c04c7c6:	b90b      	cbnz	r3, c04c7cc <mbedtls_ecp_curve_info_from_grp_id+0xc>
    return( NULL );
 c04c7c8:	4618      	mov	r0, r3
}
 c04c7ca:	4770      	bx	lr
        if( curve_info->grp_id == grp_id )
 c04c7cc:	4293      	cmp	r3, r2
 c04c7ce:	d0fc      	beq.n	c04c7ca <mbedtls_ecp_curve_info_from_grp_id+0xa>
         curve_info++ )
 c04c7d0:	300c      	adds	r0, #12
 c04c7d2:	e7f7      	b.n	c04c7c4 <mbedtls_ecp_curve_info_from_grp_id+0x4>
 c04c7d4:	0c05ed70 	.word	0x0c05ed70

0c04c7d8 <mbedtls_ecp_get_type>:
{
 c04c7d8:	4603      	mov	r3, r0
    if( grp->G.X.p == NULL )
 c04c7da:	6b00      	ldr	r0, [r0, #48]	@ 0x30
 c04c7dc:	b120      	cbz	r0, c04c7e8 <mbedtls_ecp_get_type+0x10>
    if( grp->G.Y.p == NULL )
 c04c7de:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
        return( MBEDTLS_ECP_TYPE_MONTGOMERY );
 c04c7e0:	2b00      	cmp	r3, #0
 c04c7e2:	bf14      	ite	ne
 c04c7e4:	2001      	movne	r0, #1
 c04c7e6:	2002      	moveq	r0, #2
}
 c04c7e8:	4770      	bx	lr

0c04c7ea <mbedtls_ecp_point_init>:
{
 c04c7ea:	b510      	push	{r4, lr}
 c04c7ec:	4604      	mov	r4, r0
    mbedtls_mpi_init( &pt->X );
 c04c7ee:	f006 fd82 	bl	c0532f6 <mbedtls_mpi_init>
    mbedtls_mpi_init( &pt->Y );
 c04c7f2:	f104 000c 	add.w	r0, r4, #12
 c04c7f6:	f006 fd7e 	bl	c0532f6 <mbedtls_mpi_init>
    mbedtls_mpi_init( &pt->Z );
 c04c7fa:	f104 0018 	add.w	r0, r4, #24
}
 c04c7fe:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mbedtls_mpi_init( &pt->Z );
 c04c802:	f006 bd78 	b.w	c0532f6 <mbedtls_mpi_init>

0c04c806 <mbedtls_ecp_group_init>:
{
 c04c806:	b538      	push	{r3, r4, r5, lr}
    grp->id = MBEDTLS_ECP_DP_NONE;
 c04c808:	2500      	movs	r5, #0
{
 c04c80a:	4604      	mov	r4, r0
    grp->id = MBEDTLS_ECP_DP_NONE;
 c04c80c:	f800 5b04 	strb.w	r5, [r0], #4
    mbedtls_mpi_init( &grp->P );
 c04c810:	f006 fd71 	bl	c0532f6 <mbedtls_mpi_init>
    mbedtls_mpi_init( &grp->A );
 c04c814:	f104 0010 	add.w	r0, r4, #16
 c04c818:	f006 fd6d 	bl	c0532f6 <mbedtls_mpi_init>
    mbedtls_mpi_init( &grp->B );
 c04c81c:	f104 001c 	add.w	r0, r4, #28
 c04c820:	f006 fd69 	bl	c0532f6 <mbedtls_mpi_init>
    mbedtls_ecp_point_init( &grp->G );
 c04c824:	f104 0028 	add.w	r0, r4, #40	@ 0x28
 c04c828:	f7ff ffdf 	bl	c04c7ea <mbedtls_ecp_point_init>
    mbedtls_mpi_init( &grp->N );
 c04c82c:	f104 004c 	add.w	r0, r4, #76	@ 0x4c
 c04c830:	f006 fd61 	bl	c0532f6 <mbedtls_mpi_init>
    grp->nbits = 0;
 c04c834:	e9c4 5516 	strd	r5, r5, [r4, #88]	@ 0x58
    grp->modp = NULL;
 c04c838:	e9c4 5518 	strd	r5, r5, [r4, #96]	@ 0x60
    grp->t_post = NULL;
 c04c83c:	e9c4 551a 	strd	r5, r5, [r4, #104]	@ 0x68
    grp->T = NULL;
 c04c840:	e9c4 551c 	strd	r5, r5, [r4, #112]	@ 0x70
    grp->st_modulus_size = 0;
 c04c844:	e9c4 551e 	strd	r5, r5, [r4, #120]	@ 0x78
    grp->st_p = NULL;
 c04c848:	e9c4 5520 	strd	r5, r5, [r4, #128]	@ 0x80
    grp->st_a_abs = NULL;
 c04c84c:	e9c4 5522 	strd	r5, r5, [r4, #136]	@ 0x88
    grp->st_gx = NULL;
 c04c850:	e9c4 5524 	strd	r5, r5, [r4, #144]	@ 0x90
    grp->st_n = NULL;
 c04c854:	e9c4 5526 	strd	r5, r5, [r4, #152]	@ 0x98
}
 c04c858:	bd38      	pop	{r3, r4, r5, pc}

0c04c85a <mbedtls_ecp_keypair_init>:
{
 c04c85a:	b510      	push	{r4, lr}
 c04c85c:	4604      	mov	r4, r0
    mbedtls_ecp_group_init( &key->grp );
 c04c85e:	f7ff ffd2 	bl	c04c806 <mbedtls_ecp_group_init>
    mbedtls_mpi_init( &key->d );
 c04c862:	f104 00a0 	add.w	r0, r4, #160	@ 0xa0
 c04c866:	f006 fd46 	bl	c0532f6 <mbedtls_mpi_init>
    mbedtls_ecp_point_init( &key->Q );
 c04c86a:	f104 00ac 	add.w	r0, r4, #172	@ 0xac
}
 c04c86e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mbedtls_ecp_point_init( &key->Q );
 c04c872:	f7ff bfba 	b.w	c04c7ea <mbedtls_ecp_point_init>

0c04c876 <mbedtls_ecp_point_free>:
    if( pt == NULL )
 c04c876:	b108      	cbz	r0, c04c87c <mbedtls_ecp_point_free+0x6>
 c04c878:	f7ff bf93 	b.w	c04c7a2 <mbedtls_ecp_point_free.part.0>
}
 c04c87c:	4770      	bx	lr

0c04c87e <mbedtls_ecp_group_free>:
{
 c04c87e:	b570      	push	{r4, r5, r6, lr}
    if( grp == NULL )
 c04c880:	4604      	mov	r4, r0
 c04c882:	2800      	cmp	r0, #0
 c04c884:	d06a      	beq.n	c04c95c <mbedtls_ecp_group_free+0xde>
    if( grp->h != 1 )
 c04c886:	6e03      	ldr	r3, [r0, #96]	@ 0x60
 c04c888:	2b01      	cmp	r3, #1
 c04c88a:	d012      	beq.n	c04c8b2 <mbedtls_ecp_group_free+0x34>
        mbedtls_mpi_free( &grp->P );
 c04c88c:	3004      	adds	r0, #4
 c04c88e:	f006 fd38 	bl	c053302 <mbedtls_mpi_free>
        mbedtls_mpi_free( &grp->A );
 c04c892:	f104 0010 	add.w	r0, r4, #16
 c04c896:	f006 fd34 	bl	c053302 <mbedtls_mpi_free>
        mbedtls_mpi_free( &grp->B );
 c04c89a:	f104 001c 	add.w	r0, r4, #28
 c04c89e:	f006 fd30 	bl	c053302 <mbedtls_mpi_free>
        mbedtls_ecp_point_free( &grp->G );
 c04c8a2:	f104 0028 	add.w	r0, r4, #40	@ 0x28
 c04c8a6:	f7ff ffe6 	bl	c04c876 <mbedtls_ecp_point_free>
        mbedtls_mpi_free( &grp->N );
 c04c8aa:	f104 004c 	add.w	r0, r4, #76	@ 0x4c
 c04c8ae:	f006 fd28 	bl	c053302 <mbedtls_mpi_free>
    if( grp->T != NULL )
 c04c8b2:	6f63      	ldr	r3, [r4, #116]	@ 0x74
 c04c8b4:	2b00      	cmp	r3, #0
 c04c8b6:	d14e      	bne.n	c04c956 <mbedtls_ecp_group_free+0xd8>
    if ( grp->st_p != NULL )
 c04c8b8:	f8d4 0084 	ldr.w	r0, [r4, #132]	@ 0x84
 c04c8bc:	b130      	cbz	r0, c04c8cc <mbedtls_ecp_group_free+0x4e>
        mbedtls_platform_zeroize( grp->st_p, grp->st_modulus_size );
 c04c8be:	6fe1      	ldr	r1, [r4, #124]	@ 0x7c
 c04c8c0:	f7ee fd86 	bl	c03b3d0 <mbedtls_platform_zeroize>
        mbedtls_free( grp->st_p );
 c04c8c4:	f8d4 0084 	ldr.w	r0, [r4, #132]	@ 0x84
 c04c8c8:	f7ee fd72 	bl	c03b3b0 <mbedtls_free>
    if ( grp->st_a_abs != NULL )
 c04c8cc:	f8d4 008c 	ldr.w	r0, [r4, #140]	@ 0x8c
 c04c8d0:	b130      	cbz	r0, c04c8e0 <mbedtls_ecp_group_free+0x62>
        mbedtls_platform_zeroize( grp->st_a_abs, grp->st_modulus_size );
 c04c8d2:	6fe1      	ldr	r1, [r4, #124]	@ 0x7c
 c04c8d4:	f7ee fd7c 	bl	c03b3d0 <mbedtls_platform_zeroize>
        mbedtls_free( grp->st_a_abs );
 c04c8d8:	f8d4 008c 	ldr.w	r0, [r4, #140]	@ 0x8c
 c04c8dc:	f7ee fd68 	bl	c03b3b0 <mbedtls_free>
    if ( grp->st_b != NULL )
 c04c8e0:	f8d4 0090 	ldr.w	r0, [r4, #144]	@ 0x90
 c04c8e4:	b130      	cbz	r0, c04c8f4 <mbedtls_ecp_group_free+0x76>
        mbedtls_platform_zeroize( grp->st_b, grp->st_modulus_size );
 c04c8e6:	6fe1      	ldr	r1, [r4, #124]	@ 0x7c
 c04c8e8:	f7ee fd72 	bl	c03b3d0 <mbedtls_platform_zeroize>
        mbedtls_free( grp->st_b );
 c04c8ec:	f8d4 0090 	ldr.w	r0, [r4, #144]	@ 0x90
 c04c8f0:	f7ee fd5e 	bl	c03b3b0 <mbedtls_free>
    if ( grp->st_gx != NULL )
 c04c8f4:	f8d4 0094 	ldr.w	r0, [r4, #148]	@ 0x94
 c04c8f8:	b130      	cbz	r0, c04c908 <mbedtls_ecp_group_free+0x8a>
        mbedtls_platform_zeroize( grp->st_gx, grp->st_modulus_size );
 c04c8fa:	6fe1      	ldr	r1, [r4, #124]	@ 0x7c
 c04c8fc:	f7ee fd68 	bl	c03b3d0 <mbedtls_platform_zeroize>
        mbedtls_free( grp->st_gx );
 c04c900:	f8d4 0094 	ldr.w	r0, [r4, #148]	@ 0x94
 c04c904:	f7ee fd54 	bl	c03b3b0 <mbedtls_free>
    if ( grp->st_gy != NULL )
 c04c908:	f8d4 0098 	ldr.w	r0, [r4, #152]	@ 0x98
 c04c90c:	b130      	cbz	r0, c04c91c <mbedtls_ecp_group_free+0x9e>
        mbedtls_platform_zeroize( grp->st_gy, grp->st_modulus_size );
 c04c90e:	6fe1      	ldr	r1, [r4, #124]	@ 0x7c
 c04c910:	f7ee fd5e 	bl	c03b3d0 <mbedtls_platform_zeroize>
        mbedtls_free( grp->st_gy );
 c04c914:	f8d4 0098 	ldr.w	r0, [r4, #152]	@ 0x98
 c04c918:	f7ee fd4a 	bl	c03b3b0 <mbedtls_free>
    if ( grp->st_n != NULL )
 c04c91c:	f8d4 009c 	ldr.w	r0, [r4, #156]	@ 0x9c
 c04c920:	b138      	cbz	r0, c04c932 <mbedtls_ecp_group_free+0xb4>
        mbedtls_platform_zeroize( grp->st_n, grp->st_order_size );
 c04c922:	f8d4 1080 	ldr.w	r1, [r4, #128]	@ 0x80
 c04c926:	f7ee fd53 	bl	c03b3d0 <mbedtls_platform_zeroize>
        mbedtls_free( grp->st_n );
 c04c92a:	f8d4 009c 	ldr.w	r0, [r4, #156]	@ 0x9c
 c04c92e:	f7ee fd3f 	bl	c03b3b0 <mbedtls_free>
    mbedtls_platform_zeroize( grp, sizeof( mbedtls_ecp_group ) );
 c04c932:	4620      	mov	r0, r4
}
 c04c934:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    mbedtls_platform_zeroize( grp, sizeof( mbedtls_ecp_group ) );
 c04c938:	21a0      	movs	r1, #160	@ 0xa0
 c04c93a:	f7ee bd49 	b.w	c03b3d0 <mbedtls_platform_zeroize>
            mbedtls_ecp_point_free( &grp->T[i] );
 c04c93e:	fb06 0005 	mla	r0, r6, r5, r0
 c04c942:	f7ff ff98 	bl	c04c876 <mbedtls_ecp_point_free>
        for( i = 0; i < grp->T_size; i++ )
 c04c946:	3501      	adds	r5, #1
 c04c948:	e9d4 031d 	ldrd	r0, r3, [r4, #116]	@ 0x74
 c04c94c:	42ab      	cmp	r3, r5
 c04c94e:	d8f6      	bhi.n	c04c93e <mbedtls_ecp_group_free+0xc0>
        mbedtls_free( grp->T );
 c04c950:	f7ee fd2e 	bl	c03b3b0 <mbedtls_free>
 c04c954:	e7b0      	b.n	c04c8b8 <mbedtls_ecp_group_free+0x3a>
        for( i = 0; i < grp->T_size; i++ )
 c04c956:	2500      	movs	r5, #0
            mbedtls_ecp_point_free( &grp->T[i] );
 c04c958:	2624      	movs	r6, #36	@ 0x24
 c04c95a:	e7f5      	b.n	c04c948 <mbedtls_ecp_group_free+0xca>
}
 c04c95c:	bd70      	pop	{r4, r5, r6, pc}

0c04c95e <mbedtls_ecp_keypair_free>:
{
 c04c95e:	b510      	push	{r4, lr}
    if( key == NULL )
 c04c960:	4604      	mov	r4, r0
 c04c962:	b158      	cbz	r0, c04c97c <mbedtls_ecp_keypair_free+0x1e>
    mbedtls_ecp_group_free( &key->grp );
 c04c964:	f7ff ff8b 	bl	c04c87e <mbedtls_ecp_group_free>
    mbedtls_mpi_free( &key->d );
 c04c968:	f104 00a0 	add.w	r0, r4, #160	@ 0xa0
 c04c96c:	f006 fcc9 	bl	c053302 <mbedtls_mpi_free>
    mbedtls_ecp_point_free( &key->Q );
 c04c970:	f104 00ac 	add.w	r0, r4, #172	@ 0xac
}
 c04c974:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mbedtls_ecp_point_free( &key->Q );
 c04c978:	f7ff bf7d 	b.w	c04c876 <mbedtls_ecp_point_free>
}
 c04c97c:	bd10      	pop	{r4, pc}

0c04c97e <mbedtls_ecp_copy>:
{
 c04c97e:	b538      	push	{r3, r4, r5, lr}
 c04c980:	4604      	mov	r4, r0
 c04c982:	460d      	mov	r5, r1
    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &P->X, &Q->X ) );
 c04c984:	f006 fd11 	bl	c0533aa <mbedtls_mpi_copy>
 c04c988:	b970      	cbnz	r0, c04c9a8 <mbedtls_ecp_copy+0x2a>
    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &P->Y, &Q->Y ) );
 c04c98a:	f105 010c 	add.w	r1, r5, #12
 c04c98e:	f104 000c 	add.w	r0, r4, #12
 c04c992:	f006 fd0a 	bl	c0533aa <mbedtls_mpi_copy>
 c04c996:	b938      	cbnz	r0, c04c9a8 <mbedtls_ecp_copy+0x2a>
    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &P->Z, &Q->Z ) );
 c04c998:	f105 0118 	add.w	r1, r5, #24
 c04c99c:	f104 0018 	add.w	r0, r4, #24
}
 c04c9a0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &P->Z, &Q->Z ) );
 c04c9a4:	f006 bd01 	b.w	c0533aa <mbedtls_mpi_copy>
}
 c04c9a8:	bd38      	pop	{r3, r4, r5, pc}

0c04c9aa <mbedtls_ecp_group_copy>:
    return( mbedtls_ecp_group_load( dst, src->id ) );
 c04c9aa:	7809      	ldrb	r1, [r1, #0]
 c04c9ac:	f001 b820 	b.w	c04d9f0 <mbedtls_ecp_group_load>

0c04c9b0 <mbedtls_ecp_set_zero>:
{
 c04c9b0:	b510      	push	{r4, lr}
    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &pt->X , 1 ) );
 c04c9b2:	2101      	movs	r1, #1
{
 c04c9b4:	4604      	mov	r4, r0
    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &pt->X , 1 ) );
 c04c9b6:	f006 fd42 	bl	c05343e <mbedtls_mpi_lset>
 c04c9ba:	b960      	cbnz	r0, c04c9d6 <mbedtls_ecp_set_zero+0x26>
    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &pt->Y , 1 ) );
 c04c9bc:	2101      	movs	r1, #1
 c04c9be:	f104 000c 	add.w	r0, r4, #12
 c04c9c2:	f006 fd3c 	bl	c05343e <mbedtls_mpi_lset>
 c04c9c6:	b930      	cbnz	r0, c04c9d6 <mbedtls_ecp_set_zero+0x26>
    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &pt->Z , 0 ) );
 c04c9c8:	4601      	mov	r1, r0
 c04c9ca:	f104 0018 	add.w	r0, r4, #24
}
 c04c9ce:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &pt->Z , 0 ) );
 c04c9d2:	f006 bd34 	b.w	c05343e <mbedtls_mpi_lset>
}
 c04c9d6:	bd10      	pop	{r4, pc}

0c04c9d8 <mbedtls_ecp_is_zero>:
    return( mbedtls_mpi_cmp_int( &pt->Z, 0 ) == 0 );
 c04c9d8:	2100      	movs	r1, #0
{
 c04c9da:	b508      	push	{r3, lr}
    return( mbedtls_mpi_cmp_int( &pt->Z, 0 ) == 0 );
 c04c9dc:	3018      	adds	r0, #24
 c04c9de:	f006 ff70 	bl	c0538c2 <mbedtls_mpi_cmp_int>
}
 c04c9e2:	fab0 f080 	clz	r0, r0
 c04c9e6:	0940      	lsrs	r0, r0, #5
 c04c9e8:	bd08      	pop	{r3, pc}
	...

0c04c9ec <mbedtls_ecp_point_write_binary>:
{
 c04c9ec:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c04c9f0:	4683      	mov	fp, r0
 c04c9f2:	e9dd 690a 	ldrd	r6, r9, [sp, #40]	@ 0x28
    plen = mbedtls_mpi_size( &grp->P );
 c04c9f6:	3004      	adds	r0, #4
{
 c04c9f8:	4698      	mov	r8, r3
 c04c9fa:	460f      	mov	r7, r1
 c04c9fc:	4692      	mov	sl, r2
    plen = mbedtls_mpi_size( &grp->P );
 c04c9fe:	f006 fdac 	bl	c05355a <mbedtls_mpi_size>
 c04ca02:	4605      	mov	r5, r0
    if( mbedtls_ecp_get_type( grp ) == MBEDTLS_ECP_TYPE_MONTGOMERY )
 c04ca04:	4658      	mov	r0, fp
 c04ca06:	f7ff fee7 	bl	c04c7d8 <mbedtls_ecp_get_type>
 c04ca0a:	2802      	cmp	r0, #2
 c04ca0c:	d123      	bne.n	c04ca56 <mbedtls_ecp_point_write_binary+0x6a>
        if( buflen < *olen )
 c04ca0e:	454d      	cmp	r5, r9
        *olen = plen;
 c04ca10:	f8c8 5000 	str.w	r5, [r8]
        if( buflen < *olen )
 c04ca14:	d903      	bls.n	c04ca1e <mbedtls_ecp_point_write_binary+0x32>
            return( MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL );
 c04ca16:	4c29      	ldr	r4, [pc, #164]	@ (c04cabc <mbedtls_ecp_point_write_binary+0xd0>)
}
 c04ca18:	4620      	mov	r0, r4
 c04ca1a:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
        MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary_le( &P->X, buf, plen ) );
 c04ca1e:	462a      	mov	r2, r5
 c04ca20:	4631      	mov	r1, r6
 c04ca22:	4638      	mov	r0, r7
 c04ca24:	f006 fde2 	bl	c0535ec <mbedtls_mpi_write_binary_le>
 c04ca28:	4604      	mov	r4, r0
 c04ca2a:	2800      	cmp	r0, #0
 c04ca2c:	d1f4      	bne.n	c04ca18 <mbedtls_ecp_point_write_binary+0x2c>
    if( mbedtls_ecp_get_type( grp ) == MBEDTLS_ECP_TYPE_SHORT_WEIERSTRASS )
 c04ca2e:	4658      	mov	r0, fp
 c04ca30:	f7ff fed2 	bl	c04c7d8 <mbedtls_ecp_get_type>
 c04ca34:	2801      	cmp	r0, #1
 c04ca36:	4683      	mov	fp, r0
 c04ca38:	d1ee      	bne.n	c04ca18 <mbedtls_ecp_point_write_binary+0x2c>
        if( mbedtls_mpi_cmp_int( &P->Z, 0 ) == 0 )
 c04ca3a:	2100      	movs	r1, #0
 c04ca3c:	f107 0018 	add.w	r0, r7, #24
 c04ca40:	f006 ff3f 	bl	c0538c2 <mbedtls_mpi_cmp_int>
 c04ca44:	b948      	cbnz	r0, c04ca5a <mbedtls_ecp_point_write_binary+0x6e>
            if( buflen < 1 )
 c04ca46:	f1b9 0f00 	cmp.w	r9, #0
 c04ca4a:	d0e4      	beq.n	c04ca16 <mbedtls_ecp_point_write_binary+0x2a>
            buf[0] = 0x00;
 c04ca4c:	7030      	strb	r0, [r6, #0]
            return( 0 );
 c04ca4e:	4604      	mov	r4, r0
            *olen = 1;
 c04ca50:	f8c8 b000 	str.w	fp, [r8]
            return( 0 );
 c04ca54:	e7e0      	b.n	c04ca18 <mbedtls_ecp_point_write_binary+0x2c>
    int ret = MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE;
 c04ca56:	4c1a      	ldr	r4, [pc, #104]	@ (c04cac0 <mbedtls_ecp_point_write_binary+0xd4>)
 c04ca58:	e7e9      	b.n	c04ca2e <mbedtls_ecp_point_write_binary+0x42>
        if( format == MBEDTLS_ECP_PF_UNCOMPRESSED )
 c04ca5a:	f1ba 0f00 	cmp.w	sl, #0
 c04ca5e:	d119      	bne.n	c04ca94 <mbedtls_ecp_point_write_binary+0xa8>
            *olen = 2 * plen + 1;
 c04ca60:	006b      	lsls	r3, r5, #1
 c04ca62:	3301      	adds	r3, #1
            if( buflen < *olen )
 c04ca64:	454b      	cmp	r3, r9
            *olen = 2 * plen + 1;
 c04ca66:	f8c8 3000 	str.w	r3, [r8]
            if( buflen < *olen )
 c04ca6a:	d8d4      	bhi.n	c04ca16 <mbedtls_ecp_point_write_binary+0x2a>
            buf[0] = 0x04;
 c04ca6c:	4631      	mov	r1, r6
 c04ca6e:	2304      	movs	r3, #4
            MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( &P->X, buf + 1, plen ) );
 c04ca70:	462a      	mov	r2, r5
 c04ca72:	4638      	mov	r0, r7
            buf[0] = 0x04;
 c04ca74:	f801 3b01 	strb.w	r3, [r1], #1
            MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( &P->X, buf + 1, plen ) );
 c04ca78:	f006 fdee 	bl	c053658 <mbedtls_mpi_write_binary>
 c04ca7c:	4604      	mov	r4, r0
 c04ca7e:	2800      	cmp	r0, #0
 c04ca80:	d1ca      	bne.n	c04ca18 <mbedtls_ecp_point_write_binary+0x2c>
            MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( &P->Y, buf + 1 + plen, plen ) );
 c04ca82:	462a      	mov	r2, r5
 c04ca84:	1c69      	adds	r1, r5, #1
 c04ca86:	4431      	add	r1, r6
 c04ca88:	f107 000c 	add.w	r0, r7, #12
}
 c04ca8c:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
            MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( &P->X, buf + 1, plen ) );
 c04ca90:	f006 bde2 	b.w	c053658 <mbedtls_mpi_write_binary>
        else if( format == MBEDTLS_ECP_PF_COMPRESSED )
 c04ca94:	f1ba 0f01 	cmp.w	sl, #1
 c04ca98:	d1be      	bne.n	c04ca18 <mbedtls_ecp_point_write_binary+0x2c>
            *olen = plen + 1;
 c04ca9a:	1c6b      	adds	r3, r5, #1
            if( buflen < *olen )
 c04ca9c:	454b      	cmp	r3, r9
            *olen = plen + 1;
 c04ca9e:	f8c8 3000 	str.w	r3, [r8]
            if( buflen < *olen )
 c04caa2:	d8b8      	bhi.n	c04ca16 <mbedtls_ecp_point_write_binary+0x2a>
            buf[0] = 0x02 + mbedtls_mpi_get_bit( &P->Y, 0 );
 c04caa4:	2100      	movs	r1, #0
 c04caa6:	f107 000c 	add.w	r0, r7, #12
 c04caaa:	f006 fce4 	bl	c053476 <mbedtls_mpi_get_bit>
 c04caae:	4631      	mov	r1, r6
 c04cab0:	3002      	adds	r0, #2
 c04cab2:	f801 0b01 	strb.w	r0, [r1], #1
            MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( &P->X, buf + 1, plen ) );
 c04cab6:	462a      	mov	r2, r5
 c04cab8:	4638      	mov	r0, r7
 c04caba:	e7e7      	b.n	c04ca8c <mbedtls_ecp_point_write_binary+0xa0>
 c04cabc:	ffffb100 	.word	0xffffb100
 c04cac0:	ffffb180 	.word	0xffffb180

0c04cac4 <mbedtls_ecp_point_read_binary>:
{
 c04cac4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 c04cac8:	4681      	mov	r9, r0
 c04caca:	460d      	mov	r5, r1
 c04cacc:	4690      	mov	r8, r2
    if( ilen < 1 )
 c04cace:	461e      	mov	r6, r3
 c04cad0:	b91b      	cbnz	r3, c04cada <mbedtls_ecp_point_read_binary+0x16>
        return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );
 c04cad2:	4c32      	ldr	r4, [pc, #200]	@ (c04cb9c <mbedtls_ecp_point_read_binary+0xd8>)
}
 c04cad4:	4620      	mov	r0, r4
 c04cad6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    plen = mbedtls_mpi_size( &grp->P );
 c04cada:	3004      	adds	r0, #4
 c04cadc:	f006 fd3d 	bl	c05355a <mbedtls_mpi_size>
 c04cae0:	4607      	mov	r7, r0
    if( mbedtls_ecp_get_type( grp ) == MBEDTLS_ECP_TYPE_MONTGOMERY )
 c04cae2:	4648      	mov	r0, r9
 c04cae4:	f7ff fe78 	bl	c04c7d8 <mbedtls_ecp_get_type>
 c04cae8:	2802      	cmp	r0, #2
 c04caea:	d133      	bne.n	c04cb54 <mbedtls_ecp_point_read_binary+0x90>
        if( plen != ilen )
 c04caec:	42be      	cmp	r6, r7
 c04caee:	d1f0      	bne.n	c04cad2 <mbedtls_ecp_point_read_binary+0xe>
        MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary_le( &pt->X, buf, plen ) );
 c04caf0:	4632      	mov	r2, r6
 c04caf2:	4641      	mov	r1, r8
 c04caf4:	4628      	mov	r0, r5
 c04caf6:	f006 fd36 	bl	c053566 <mbedtls_mpi_read_binary_le>
 c04cafa:	4604      	mov	r4, r0
 c04cafc:	2800      	cmp	r0, #0
 c04cafe:	d1e9      	bne.n	c04cad4 <mbedtls_ecp_point_read_binary+0x10>
        mbedtls_mpi_free( &pt->Y );
 c04cb00:	f105 000c 	add.w	r0, r5, #12
 c04cb04:	f006 fbfd 	bl	c053302 <mbedtls_mpi_free>
        if( grp->id == MBEDTLS_ECP_DP_CURVE25519 )
 c04cb08:	f899 3000 	ldrb.w	r3, [r9]
 c04cb0c:	2b09      	cmp	r3, #9
 c04cb0e:	d017      	beq.n	c04cb40 <mbedtls_ecp_point_read_binary+0x7c>
        MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &pt->Z, 1 ) );
 c04cb10:	2101      	movs	r1, #1
 c04cb12:	f105 0018 	add.w	r0, r5, #24
 c04cb16:	f006 fc92 	bl	c05343e <mbedtls_mpi_lset>
 c04cb1a:	4604      	mov	r4, r0
 c04cb1c:	2800      	cmp	r0, #0
 c04cb1e:	d1d9      	bne.n	c04cad4 <mbedtls_ecp_point_read_binary+0x10>
    if( mbedtls_ecp_get_type( grp ) == MBEDTLS_ECP_TYPE_SHORT_WEIERSTRASS )
 c04cb20:	4648      	mov	r0, r9
 c04cb22:	f7ff fe59 	bl	c04c7d8 <mbedtls_ecp_get_type>
 c04cb26:	2801      	cmp	r0, #1
 c04cb28:	4681      	mov	r9, r0
 c04cb2a:	d1d3      	bne.n	c04cad4 <mbedtls_ecp_point_read_binary+0x10>
        if( buf[0] == 0x00 )
 c04cb2c:	f898 3000 	ldrb.w	r3, [r8]
 c04cb30:	b993      	cbnz	r3, c04cb58 <mbedtls_ecp_point_read_binary+0x94>
            if( ilen == 1 )
 c04cb32:	2e01      	cmp	r6, #1
 c04cb34:	d1cd      	bne.n	c04cad2 <mbedtls_ecp_point_read_binary+0xe>
                return( mbedtls_ecp_set_zero( pt ) );
 c04cb36:	4628      	mov	r0, r5
}
 c04cb38:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
                return( mbedtls_ecp_set_zero( pt ) );
 c04cb3c:	f7ff bf38 	b.w	c04c9b0 <mbedtls_ecp_set_zero>
            MBEDTLS_MPI_CHK( mbedtls_mpi_set_bit( &pt->X, plen * 8 - 1, 0 ) );
 c04cb40:	00f1      	lsls	r1, r6, #3
 c04cb42:	4622      	mov	r2, r4
 c04cb44:	4628      	mov	r0, r5
 c04cb46:	3901      	subs	r1, #1
 c04cb48:	f006 fca5 	bl	c053496 <mbedtls_mpi_set_bit>
 c04cb4c:	4604      	mov	r4, r0
 c04cb4e:	2800      	cmp	r0, #0
 c04cb50:	d0de      	beq.n	c04cb10 <mbedtls_ecp_point_read_binary+0x4c>
 c04cb52:	e7bf      	b.n	c04cad4 <mbedtls_ecp_point_read_binary+0x10>
    int ret = MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE;
 c04cb54:	4c12      	ldr	r4, [pc, #72]	@ (c04cba0 <mbedtls_ecp_point_read_binary+0xdc>)
 c04cb56:	e7e3      	b.n	c04cb20 <mbedtls_ecp_point_read_binary+0x5c>
        if( buf[0] != 0x04 )
 c04cb58:	2b04      	cmp	r3, #4
 c04cb5a:	d11d      	bne.n	c04cb98 <mbedtls_ecp_point_read_binary+0xd4>
        if( ilen != 2 * plen + 1 )
 c04cb5c:	007b      	lsls	r3, r7, #1
 c04cb5e:	3301      	adds	r3, #1
 c04cb60:	42b3      	cmp	r3, r6
 c04cb62:	d1b6      	bne.n	c04cad2 <mbedtls_ecp_point_read_binary+0xe>
        MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( &pt->X, buf + 1, plen ) );
 c04cb64:	463a      	mov	r2, r7
 c04cb66:	4628      	mov	r0, r5
 c04cb68:	f108 0101 	add.w	r1, r8, #1
 c04cb6c:	f006 fd1d 	bl	c0535aa <mbedtls_mpi_read_binary>
 c04cb70:	4604      	mov	r4, r0
 c04cb72:	2800      	cmp	r0, #0
 c04cb74:	d1ae      	bne.n	c04cad4 <mbedtls_ecp_point_read_binary+0x10>
        MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( &pt->Y,
 c04cb76:	1c79      	adds	r1, r7, #1
 c04cb78:	463a      	mov	r2, r7
 c04cb7a:	4441      	add	r1, r8
 c04cb7c:	f105 000c 	add.w	r0, r5, #12
 c04cb80:	f006 fd13 	bl	c0535aa <mbedtls_mpi_read_binary>
 c04cb84:	4604      	mov	r4, r0
 c04cb86:	2800      	cmp	r0, #0
 c04cb88:	d1a4      	bne.n	c04cad4 <mbedtls_ecp_point_read_binary+0x10>
        MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &pt->Z, 1 ) );
 c04cb8a:	4649      	mov	r1, r9
 c04cb8c:	f105 0018 	add.w	r0, r5, #24
}
 c04cb90:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
        MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &pt->Z, 1 ) );
 c04cb94:	f006 bc53 	b.w	c05343e <mbedtls_mpi_lset>
            return( MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE );
 c04cb98:	4c01      	ldr	r4, [pc, #4]	@ (c04cba0 <mbedtls_ecp_point_read_binary+0xdc>)
 c04cb9a:	e79b      	b.n	c04cad4 <mbedtls_ecp_point_read_binary+0x10>
 c04cb9c:	ffffb080 	.word	0xffffb080
 c04cba0:	ffffb180 	.word	0xffffb180

0c04cba4 <mbedtls_ecp_check_pubkey>:
/*
 * Check that a point is valid as a public key
 */
int mbedtls_ecp_check_pubkey( const mbedtls_ecp_group *grp,
                              const mbedtls_ecp_point *pt )
{
 c04cba4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 c04cba8:	460f      	mov	r7, r1
 c04cbaa:	4605      	mov	r5, r0
    ECP_VALIDATE_RET( grp != NULL );
    ECP_VALIDATE_RET( pt  != NULL );

    /* Must use affine coordinates */
    if( mbedtls_mpi_cmp_int( &pt->Z, 1 ) != 0 )
 c04cbac:	2101      	movs	r1, #1
{
 c04cbae:	b091      	sub	sp, #68	@ 0x44
    if( mbedtls_mpi_cmp_int( &pt->Z, 1 ) != 0 )
 c04cbb0:	f107 0018 	add.w	r0, r7, #24
 c04cbb4:	f006 fe85 	bl	c0538c2 <mbedtls_mpi_cmp_int>
 c04cbb8:	4604      	mov	r4, r0
 c04cbba:	b968      	cbnz	r0, c04cbd8 <mbedtls_ecp_check_pubkey+0x34>
        return( MBEDTLS_ERR_ECP_INVALID_KEY );

#if defined(MBEDTLS_ECP_MONTGOMERY_ENABLED)
    if( mbedtls_ecp_get_type( grp ) == MBEDTLS_ECP_TYPE_MONTGOMERY )
 c04cbbc:	4628      	mov	r0, r5
 c04cbbe:	f7ff fe0b 	bl	c04c7d8 <mbedtls_ecp_get_type>
 c04cbc2:	2802      	cmp	r0, #2
 c04cbc4:	4606      	mov	r6, r0
 c04cbc6:	d10c      	bne.n	c04cbe2 <mbedtls_ecp_check_pubkey+0x3e>
    if( mbedtls_mpi_size( &pt->X ) > ( grp->nbits + 7 ) / 8 )
 c04cbc8:	4638      	mov	r0, r7
 c04cbca:	f006 fcc6 	bl	c05355a <mbedtls_mpi_size>
 c04cbce:	6deb      	ldr	r3, [r5, #92]	@ 0x5c
 c04cbd0:	3307      	adds	r3, #7
 c04cbd2:	ebb0 0fd3 	cmp.w	r0, r3, lsr #3
 c04cbd6:	d900      	bls.n	c04cbda <mbedtls_ecp_check_pubkey+0x36>
        return( MBEDTLS_ERR_ECP_INVALID_KEY );
 c04cbd8:	4c4c      	ldr	r4, [pc, #304]	@ (c04cd0c <mbedtls_ecp_check_pubkey+0x168>)
#if defined(MBEDTLS_ECP_SHORT_WEIERSTRASS_ENABLED)
    if( mbedtls_ecp_get_type( grp ) == MBEDTLS_ECP_TYPE_SHORT_WEIERSTRASS )
        return( ecp_check_pubkey_sw( grp, pt ) );
#endif
    return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );
}
 c04cbda:	4620      	mov	r0, r4
 c04cbdc:	b011      	add	sp, #68	@ 0x44
 c04cbde:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    if( mbedtls_ecp_get_type( grp ) == MBEDTLS_ECP_TYPE_SHORT_WEIERSTRASS )
 c04cbe2:	2801      	cmp	r0, #1
 c04cbe4:	f040 808f 	bne.w	c04cd06 <mbedtls_ecp_check_pubkey+0x162>
    PKA_PointCheckInTypeDef ECC_PointCheck = {0};
 c04cbe8:	2220      	movs	r2, #32
 c04cbea:	4621      	mov	r1, r4
 c04cbec:	eb0d 0002 	add.w	r0, sp, r2
    PKA_HandleTypeDef hpka = {0};
 c04cbf0:	e9cd 4405 	strd	r4, r4, [sp, #20]
 c04cbf4:	9407      	str	r4, [sp, #28]
    PKA_PointCheckInTypeDef ECC_PointCheck = {0};
 c04cbf6:	f00e fd9a 	bl	c05b72e <memset>
    if( mbedtls_mpi_cmp_int( &pt->X, 0 ) < 0 ||
 c04cbfa:	4621      	mov	r1, r4
 c04cbfc:	4638      	mov	r0, r7
 c04cbfe:	f006 fe60 	bl	c0538c2 <mbedtls_mpi_cmp_int>
 c04cc02:	2800      	cmp	r0, #0
 c04cc04:	dbe8      	blt.n	c04cbd8 <mbedtls_ecp_check_pubkey+0x34>
        mbedtls_mpi_cmp_int( &pt->Y, 0 ) < 0 ||
 c04cc06:	f107 080c 	add.w	r8, r7, #12
 c04cc0a:	4621      	mov	r1, r4
 c04cc0c:	4640      	mov	r0, r8
 c04cc0e:	f006 fe58 	bl	c0538c2 <mbedtls_mpi_cmp_int>
    if( mbedtls_mpi_cmp_int( &pt->X, 0 ) < 0 ||
 c04cc12:	2800      	cmp	r0, #0
 c04cc14:	dbe0      	blt.n	c04cbd8 <mbedtls_ecp_check_pubkey+0x34>
        mbedtls_mpi_cmp_mpi( &pt->X, &grp->P ) >= 0 ||
 c04cc16:	f105 0904 	add.w	r9, r5, #4
 c04cc1a:	4649      	mov	r1, r9
 c04cc1c:	4638      	mov	r0, r7
 c04cc1e:	f006 fe0d 	bl	c05383c <mbedtls_mpi_cmp_mpi>
        mbedtls_mpi_cmp_int( &pt->Y, 0 ) < 0 ||
 c04cc22:	2800      	cmp	r0, #0
 c04cc24:	dad8      	bge.n	c04cbd8 <mbedtls_ecp_check_pubkey+0x34>
        mbedtls_mpi_cmp_mpi( &pt->Y, &grp->P ) >= 0 )
 c04cc26:	4649      	mov	r1, r9
 c04cc28:	4640      	mov	r0, r8
 c04cc2a:	f006 fe07 	bl	c05383c <mbedtls_mpi_cmp_mpi>
        mbedtls_mpi_cmp_mpi( &pt->X, &grp->P ) >= 0 ||
 c04cc2e:	2800      	cmp	r0, #0
 c04cc30:	dad2      	bge.n	c04cbd8 <mbedtls_ecp_check_pubkey+0x34>
    ECC_PointCheck.modulus     = grp->st_p;
 c04cc32:	f8d5 3084 	ldr.w	r3, [r5, #132]	@ 0x84
    ECC_PointCheck.modulusSize = grp->st_modulus_size;
 c04cc36:	6fe8      	ldr	r0, [r5, #124]	@ 0x7c
    ECC_PointCheck.modulus     = grp->st_p;
 c04cc38:	930c      	str	r3, [sp, #48]	@ 0x30
    ECC_PointCheck.coefSign    = grp->st_a_sign;
 c04cc3a:	f8d5 3088 	ldr.w	r3, [r5, #136]	@ 0x88
    ECC_PointCheck.modulusSize = grp->st_modulus_size;
 c04cc3e:	9008      	str	r0, [sp, #32]
    ECC_PointCheck.coefSign    = grp->st_a_sign;
 c04cc40:	9309      	str	r3, [sp, #36]	@ 0x24
    ECC_PointCheck.coefA       = grp->st_a_abs;
 c04cc42:	f8d5 308c 	ldr.w	r3, [r5, #140]	@ 0x8c
    pt_binary = mbedtls_calloc(( 2U * grp->st_modulus_size ) + 1U, sizeof( uint8_t ));
 c04cc46:	0040      	lsls	r0, r0, #1
    ECC_PointCheck.coefA       = grp->st_a_abs;
 c04cc48:	930a      	str	r3, [sp, #40]	@ 0x28
    ECC_PointCheck.coefB       = grp->st_b;
 c04cc4a:	f8d5 3090 	ldr.w	r3, [r5, #144]	@ 0x90
    pt_binary = mbedtls_calloc(( 2U * grp->st_modulus_size ) + 1U, sizeof( uint8_t ));
 c04cc4e:	4631      	mov	r1, r6
 c04cc50:	3001      	adds	r0, #1
    ECC_PointCheck.coefB       = grp->st_b;
 c04cc52:	930b      	str	r3, [sp, #44]	@ 0x2c
    ECC_PointCheck.pMontgomeryParam = NULL;
 c04cc54:	940f      	str	r4, [sp, #60]	@ 0x3c
    pt_binary = mbedtls_calloc(( 2U * grp->st_modulus_size ) + 1U, sizeof( uint8_t ));
 c04cc56:	f7ee fba5 	bl	c03b3a4 <mbedtls_calloc>
    MBEDTLS_MPI_CHK((pt_binary == NULL) ? MBEDTLS_ERR_ECP_ALLOC_FAILED : 0);
 c04cc5a:	4606      	mov	r6, r0
 c04cc5c:	2800      	cmp	r0, #0
 c04cc5e:	d050      	beq.n	c04cd02 <mbedtls_ecp_check_pubkey+0x15e>
    MBEDTLS_MPI_CHK( mbedtls_ecp_point_write_binary( grp, pt, MBEDTLS_ECP_PF_UNCOMPRESSED, &olen, pt_binary, ( 2U * grp->st_modulus_size ) + 1U ) );
 c04cc60:	6feb      	ldr	r3, [r5, #124]	@ 0x7c
 c04cc62:	4622      	mov	r2, r4
 c04cc64:	005b      	lsls	r3, r3, #1
 c04cc66:	3301      	adds	r3, #1
 c04cc68:	e9cd 0300 	strd	r0, r3, [sp]
 c04cc6c:	4639      	mov	r1, r7
 c04cc6e:	4628      	mov	r0, r5
 c04cc70:	ab03      	add	r3, sp, #12
 c04cc72:	f7ff febb 	bl	c04c9ec <mbedtls_ecp_point_write_binary>
 c04cc76:	4604      	mov	r4, r0
 c04cc78:	b9d0      	cbnz	r0, c04ccb0 <mbedtls_ecp_check_pubkey+0x10c>
    ECC_PointCheck.pointX = pt_binary + 1U;
 c04cc7a:	1c73      	adds	r3, r6, #1
 c04cc7c:	930d      	str	r3, [sp, #52]	@ 0x34
    ECC_PointCheck.pointY = pt_binary + grp->st_modulus_size + 1U;
 c04cc7e:	6feb      	ldr	r3, [r5, #124]	@ 0x7c
    MBEDTLS_MPI_CHK((HAL_PKA_Init(&hpka) != HAL_OK) ? MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED : 0);
 c04cc80:	a805      	add	r0, sp, #20
    ECC_PointCheck.pointY = pt_binary + grp->st_modulus_size + 1U;
 c04cc82:	3301      	adds	r3, #1
 c04cc84:	4433      	add	r3, r6
 c04cc86:	930e      	str	r3, [sp, #56]	@ 0x38
    __HAL_RCC_PKA_CLK_ENABLE();
 c04cc88:	4b21      	ldr	r3, [pc, #132]	@ (c04cd10 <mbedtls_ecp_check_pubkey+0x16c>)
 c04cc8a:	f8d3 208c 	ldr.w	r2, [r3, #140]	@ 0x8c
 c04cc8e:	f442 2200 	orr.w	r2, r2, #524288	@ 0x80000
 c04cc92:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
 c04cc96:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 c04cc9a:	f403 2300 	and.w	r3, r3, #524288	@ 0x80000
 c04cc9e:	9304      	str	r3, [sp, #16]
 c04cca0:	9b04      	ldr	r3, [sp, #16]
    hpka.Instance = PKA;
 c04cca2:	4b1c      	ldr	r3, [pc, #112]	@ (c04cd14 <mbedtls_ecp_check_pubkey+0x170>)
 c04cca4:	9305      	str	r3, [sp, #20]
    MBEDTLS_MPI_CHK((HAL_PKA_Init(&hpka) != HAL_OK) ? MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED : 0);
 c04cca6:	f7f3 f9f2 	bl	c04008e <HAL_PKA_Init>
 c04ccaa:	b1b8      	cbz	r0, c04ccdc <mbedtls_ecp_check_pubkey+0x138>
 c04ccac:	f06f 046f 	mvn.w	r4, #111	@ 0x6f
    HAL_PKA_DeInit(&hpka);
 c04ccb0:	a805      	add	r0, sp, #20
 c04ccb2:	f7f2 fc65 	bl	c03f580 <HAL_PKA_DeInit>
    __HAL_RCC_PKA_CLK_DISABLE();
 c04ccb6:	4a16      	ldr	r2, [pc, #88]	@ (c04cd10 <mbedtls_ecp_check_pubkey+0x16c>)
 c04ccb8:	f8d2 308c 	ldr.w	r3, [r2, #140]	@ 0x8c
 c04ccbc:	f423 2300 	bic.w	r3, r3, #524288	@ 0x80000
 c04ccc0:	f8c2 308c 	str.w	r3, [r2, #140]	@ 0x8c
    if (pt_binary != NULL)
 c04ccc4:	2e00      	cmp	r6, #0
 c04ccc6:	d088      	beq.n	c04cbda <mbedtls_ecp_check_pubkey+0x36>
        mbedtls_platform_zeroize(pt_binary, ( 2U * grp->st_modulus_size ) + 1U );
 c04ccc8:	6fe9      	ldr	r1, [r5, #124]	@ 0x7c
 c04ccca:	4630      	mov	r0, r6
 c04cccc:	0049      	lsls	r1, r1, #1
 c04ccce:	3101      	adds	r1, #1
 c04ccd0:	f7ee fb7e 	bl	c03b3d0 <mbedtls_platform_zeroize>
        mbedtls_free(pt_binary);
 c04ccd4:	4630      	mov	r0, r6
 c04ccd6:	f7ee fb6b 	bl	c03b3b0 <mbedtls_free>
        return( ecp_check_pubkey_sw( grp, pt ) );
 c04ccda:	e77e      	b.n	c04cbda <mbedtls_ecp_check_pubkey+0x36>
    HAL_PKA_RAMReset(&hpka);
 c04ccdc:	a805      	add	r0, sp, #20
 c04ccde:	f7f2 fc75 	bl	c03f5cc <HAL_PKA_RAMReset>
    MBEDTLS_MPI_CHK((HAL_PKA_PointCheck(&hpka, &ECC_PointCheck, ST_ECP_TIMEOUT) != HAL_OK) ? MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED : 0);
 c04cce2:	f241 3288 	movw	r2, #5000	@ 0x1388
 c04cce6:	a908      	add	r1, sp, #32
 c04cce8:	a805      	add	r0, sp, #20
 c04ccea:	f7f3 f8c1 	bl	c03fe70 <HAL_PKA_PointCheck>
 c04ccee:	2800      	cmp	r0, #0
 c04ccf0:	d1dc      	bne.n	c04ccac <mbedtls_ecp_check_pubkey+0x108>
    if( HAL_PKA_PointCheck_IsOnCurve(&hpka) != 1U)
 c04ccf2:	a805      	add	r0, sp, #20
 c04ccf4:	f7f2 fc61 	bl	c03f5ba <HAL_PKA_PointCheck_IsOnCurve>
        ret = MBEDTLS_ERR_ECP_INVALID_KEY;
 c04ccf8:	4b04      	ldr	r3, [pc, #16]	@ (c04cd0c <mbedtls_ecp_check_pubkey+0x168>)
 c04ccfa:	2801      	cmp	r0, #1
 c04ccfc:	bf18      	it	ne
 c04ccfe:	461c      	movne	r4, r3
 c04cd00:	e7d6      	b.n	c04ccb0 <mbedtls_ecp_check_pubkey+0x10c>
    MBEDTLS_MPI_CHK((pt_binary == NULL) ? MBEDTLS_ERR_ECP_ALLOC_FAILED : 0);
 c04cd02:	4c05      	ldr	r4, [pc, #20]	@ (c04cd18 <mbedtls_ecp_check_pubkey+0x174>)
 c04cd04:	e7d4      	b.n	c04ccb0 <mbedtls_ecp_check_pubkey+0x10c>
    return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );
 c04cd06:	4c05      	ldr	r4, [pc, #20]	@ (c04cd1c <mbedtls_ecp_check_pubkey+0x178>)
 c04cd08:	e767      	b.n	c04cbda <mbedtls_ecp_check_pubkey+0x36>
 c04cd0a:	bf00      	nop
 c04cd0c:	ffffb380 	.word	0xffffb380
 c04cd10:	56020c00 	.word	0x56020c00
 c04cd14:	520c2000 	.word	0x520c2000
 c04cd18:	ffffb280 	.word	0xffffb280
 c04cd1c:	ffffb080 	.word	0xffffb080

0c04cd20 <mbedtls_ecp_check_privkey>:
/*
 * Check that an mbedtls_mpi is valid as a private key
 */
int mbedtls_ecp_check_privkey( const mbedtls_ecp_group *grp,
                               const mbedtls_mpi *d )
{
 c04cd20:	b570      	push	{r4, r5, r6, lr}
 c04cd22:	4606      	mov	r6, r0
    ECP_VALIDATE_RET( grp != NULL );
    ECP_VALIDATE_RET( d   != NULL );

#if defined(MBEDTLS_ECP_MONTGOMERY_ENABLED)
    if( mbedtls_ecp_get_type( grp ) == MBEDTLS_ECP_TYPE_MONTGOMERY )
 c04cd24:	f7ff fd58 	bl	c04c7d8 <mbedtls_ecp_get_type>
 c04cd28:	2802      	cmp	r0, #2
{
 c04cd2a:	460c      	mov	r4, r1
    if( mbedtls_ecp_get_type( grp ) == MBEDTLS_ECP_TYPE_MONTGOMERY )
 c04cd2c:	4605      	mov	r5, r0
 c04cd2e:	d11d      	bne.n	c04cd6c <mbedtls_ecp_check_privkey+0x4c>
    {
        /* see RFC 7748 sec. 5 para. 5 */
        if( mbedtls_mpi_get_bit( d, 0 ) != 0 ||
 c04cd30:	2100      	movs	r1, #0
 c04cd32:	4620      	mov	r0, r4
 c04cd34:	f006 fb9f 	bl	c053476 <mbedtls_mpi_get_bit>
 c04cd38:	b108      	cbz	r0, c04cd3e <mbedtls_ecp_check_privkey+0x1e>
            mbedtls_mpi_get_bit( d, 1 ) != 0 ||
            mbedtls_mpi_bitlen( d ) - 1 != grp->nbits ) /* mbedtls_mpi_bitlen is one-based! */
            return( MBEDTLS_ERR_ECP_INVALID_KEY );
 c04cd3a:	4815      	ldr	r0, [pc, #84]	@ (c04cd90 <mbedtls_ecp_check_privkey+0x70>)
            return( 0 );
    }
#endif /* MBEDTLS_ECP_SHORT_WEIERSTRASS_ENABLED */

    return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );
}
 c04cd3c:	bd70      	pop	{r4, r5, r6, pc}
            mbedtls_mpi_get_bit( d, 1 ) != 0 ||
 c04cd3e:	2101      	movs	r1, #1
 c04cd40:	4620      	mov	r0, r4
 c04cd42:	f006 fb98 	bl	c053476 <mbedtls_mpi_get_bit>
        if( mbedtls_mpi_get_bit( d, 0 ) != 0 ||
 c04cd46:	2800      	cmp	r0, #0
 c04cd48:	d1f7      	bne.n	c04cd3a <mbedtls_ecp_check_privkey+0x1a>
            mbedtls_mpi_bitlen( d ) - 1 != grp->nbits ) /* mbedtls_mpi_bitlen is one-based! */
 c04cd4a:	4620      	mov	r0, r4
 c04cd4c:	f006 fbe7 	bl	c05351e <mbedtls_mpi_bitlen>
 c04cd50:	6df3      	ldr	r3, [r6, #92]	@ 0x5c
 c04cd52:	3801      	subs	r0, #1
            mbedtls_mpi_get_bit( d, 1 ) != 0 ||
 c04cd54:	4298      	cmp	r0, r3
 c04cd56:	d1f0      	bne.n	c04cd3a <mbedtls_ecp_check_privkey+0x1a>
        if( grp->nbits == 254 && mbedtls_mpi_get_bit( d, 2 ) != 0 )
 c04cd58:	28fe      	cmp	r0, #254	@ 0xfe
 c04cd5a:	d105      	bne.n	c04cd68 <mbedtls_ecp_check_privkey+0x48>
 c04cd5c:	4629      	mov	r1, r5
 c04cd5e:	4620      	mov	r0, r4
 c04cd60:	f006 fb89 	bl	c053476 <mbedtls_mpi_get_bit>
 c04cd64:	2800      	cmp	r0, #0
 c04cd66:	d1e8      	bne.n	c04cd3a <mbedtls_ecp_check_privkey+0x1a>
        return( 0 );
 c04cd68:	2000      	movs	r0, #0
 c04cd6a:	e7e7      	b.n	c04cd3c <mbedtls_ecp_check_privkey+0x1c>
    if( mbedtls_ecp_get_type( grp ) == MBEDTLS_ECP_TYPE_SHORT_WEIERSTRASS )
 c04cd6c:	2801      	cmp	r0, #1
 c04cd6e:	d10d      	bne.n	c04cd8c <mbedtls_ecp_check_privkey+0x6c>
        if( mbedtls_mpi_cmp_int( d, 1 ) < 0 ||
 c04cd70:	4601      	mov	r1, r0
 c04cd72:	4620      	mov	r0, r4
 c04cd74:	f006 fda5 	bl	c0538c2 <mbedtls_mpi_cmp_int>
 c04cd78:	2800      	cmp	r0, #0
 c04cd7a:	dbde      	blt.n	c04cd3a <mbedtls_ecp_check_privkey+0x1a>
            mbedtls_mpi_cmp_mpi( d, &grp->N ) >= 0 )
 c04cd7c:	4620      	mov	r0, r4
 c04cd7e:	f106 014c 	add.w	r1, r6, #76	@ 0x4c
 c04cd82:	f006 fd5b 	bl	c05383c <mbedtls_mpi_cmp_mpi>
        if( mbedtls_mpi_cmp_int( d, 1 ) < 0 ||
 c04cd86:	2800      	cmp	r0, #0
 c04cd88:	dbee      	blt.n	c04cd68 <mbedtls_ecp_check_privkey+0x48>
 c04cd8a:	e7d6      	b.n	c04cd3a <mbedtls_ecp_check_privkey+0x1a>
    return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );
 c04cd8c:	4801      	ldr	r0, [pc, #4]	@ (c04cd94 <mbedtls_ecp_check_privkey+0x74>)
 c04cd8e:	e7d5      	b.n	c04cd3c <mbedtls_ecp_check_privkey+0x1c>
 c04cd90:	ffffb380 	.word	0xffffb380
 c04cd94:	ffffb080 	.word	0xffffb080

0c04cd98 <mbedtls_ecp_mul_restartable>:
{
 c04cd98:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c04cd9c:	460e      	mov	r6, r1
 c04cd9e:	b0ad      	sub	sp, #180	@ 0xb4
        MBEDTLS_MPI_CHK( mbedtls_ecp_check_privkey( grp, m ) );
 c04cda0:	4611      	mov	r1, r2
{
 c04cda2:	4604      	mov	r4, r0
 c04cda4:	4698      	mov	r8, r3
 c04cda6:	9203      	str	r2, [sp, #12]
        MBEDTLS_MPI_CHK( mbedtls_ecp_check_privkey( grp, m ) );
 c04cda8:	f7ff ffba 	bl	c04cd20 <mbedtls_ecp_check_privkey>
 c04cdac:	4607      	mov	r7, r0
 c04cdae:	2800      	cmp	r0, #0
 c04cdb0:	d16b      	bne.n	c04ce8a <mbedtls_ecp_mul_restartable+0xf2>
        MBEDTLS_MPI_CHK( mbedtls_ecp_check_pubkey( grp, P ) );
 c04cdb2:	4641      	mov	r1, r8
 c04cdb4:	4620      	mov	r0, r4
 c04cdb6:	f7ff fef5 	bl	c04cba4 <mbedtls_ecp_check_pubkey>
 c04cdba:	4607      	mov	r7, r0
 c04cdbc:	2800      	cmp	r0, #0
 c04cdbe:	d164      	bne.n	c04ce8a <mbedtls_ecp_mul_restartable+0xf2>
    if( mbedtls_ecp_get_type( grp ) == MBEDTLS_ECP_TYPE_MONTGOMERY )
 c04cdc0:	4620      	mov	r0, r4
 c04cdc2:	f7ff fd09 	bl	c04c7d8 <mbedtls_ecp_get_type>
 c04cdc6:	2802      	cmp	r0, #2
 c04cdc8:	f040 81a0 	bne.w	c04d10c <mbedtls_ecp_mul_restartable+0x374>
    mbedtls_ecp_point_init( &RP ); mbedtls_mpi_init( &PX );
 c04cdcc:	a822      	add	r0, sp, #136	@ 0x88
 c04cdce:	f7ff fd0c 	bl	c04c7ea <mbedtls_ecp_point_init>
 c04cdd2:	a804      	add	r0, sp, #16
 c04cdd4:	f006 fa8f 	bl	c0532f6 <mbedtls_mpi_init>
    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &PX, &P->X ) );
 c04cdd8:	4641      	mov	r1, r8
 c04cdda:	a804      	add	r0, sp, #16
 c04cddc:	f006 fae5 	bl	c0533aa <mbedtls_mpi_copy>
 c04cde0:	4607      	mov	r7, r0
 c04cde2:	2800      	cmp	r0, #0
 c04cde4:	d148      	bne.n	c04ce78 <mbedtls_ecp_mul_restartable+0xe0>
    MBEDTLS_MPI_CHK( mbedtls_ecp_copy( &RP, P ) );
 c04cde6:	4641      	mov	r1, r8
 c04cde8:	a822      	add	r0, sp, #136	@ 0x88
 c04cdea:	f7ff fdc8 	bl	c04c97e <mbedtls_ecp_copy>
 c04cdee:	4607      	mov	r7, r0
 c04cdf0:	2800      	cmp	r0, #0
 c04cdf2:	d141      	bne.n	c04ce78 <mbedtls_ecp_mul_restartable+0xe0>
    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &R->X, 1 ) );
 c04cdf4:	2101      	movs	r1, #1
 c04cdf6:	4630      	mov	r0, r6
 c04cdf8:	f006 fb21 	bl	c05343e <mbedtls_mpi_lset>
 c04cdfc:	4607      	mov	r7, r0
 c04cdfe:	2800      	cmp	r0, #0
 c04ce00:	d13a      	bne.n	c04ce78 <mbedtls_ecp_mul_restartable+0xe0>
    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &R->Z, 0 ) );
 c04ce02:	f106 0518 	add.w	r5, r6, #24
 c04ce06:	4601      	mov	r1, r0
 c04ce08:	4628      	mov	r0, r5
 c04ce0a:	f006 fb18 	bl	c05343e <mbedtls_mpi_lset>
 c04ce0e:	4607      	mov	r7, r0
 c04ce10:	bb90      	cbnz	r0, c04ce78 <mbedtls_ecp_mul_restartable+0xe0>
    mbedtls_mpi_free( &R->Y );
 c04ce12:	f106 000c 	add.w	r0, r6, #12
 c04ce16:	f006 fa74 	bl	c053302 <mbedtls_mpi_free>
    MOD_ADD( RP.X );
 c04ce1a:	f104 0a04 	add.w	sl, r4, #4
 c04ce1e:	4651      	mov	r1, sl
 c04ce20:	a822      	add	r0, sp, #136	@ 0x88
 c04ce22:	f006 fd0b 	bl	c05383c <mbedtls_mpi_cmp_mpi>
 c04ce26:	2800      	cmp	r0, #0
 c04ce28:	da1e      	bge.n	c04ce68 <mbedtls_ecp_mul_restartable+0xd0>
    if( f_rng != NULL )
 c04ce2a:	9b36      	ldr	r3, [sp, #216]	@ 0xd8
 c04ce2c:	bb8b      	cbnz	r3, c04ce92 <mbedtls_ecp_mul_restartable+0xfa>
    i = mbedtls_mpi_bitlen( m ); /* one past the (zero-based) most significant bit */
 c04ce2e:	9803      	ldr	r0, [sp, #12]
 c04ce30:	f006 fb75 	bl	c05351e <mbedtls_mpi_bitlen>
    while( i-- > 0 )
 c04ce34:	f100 39ff 	add.w	r9, r0, #4294967295	@ 0xffffffff
 c04ce38:	f1b9 3fff 	cmp.w	r9, #4294967295	@ 0xffffffff
 c04ce3c:	d165      	bne.n	c04cf0a <mbedtls_ecp_mul_restartable+0x172>
    MBEDTLS_MPI_CHK( mbedtls_mpi_inv_mod( &P->Z, &P->Z, &grp->P ) );
 c04ce3e:	4652      	mov	r2, sl
 c04ce40:	4629      	mov	r1, r5
 c04ce42:	4628      	mov	r0, r5
 c04ce44:	f007 fd5c 	bl	c054900 <mbedtls_mpi_inv_mod>
 c04ce48:	4607      	mov	r7, r0
 c04ce4a:	b9a8      	cbnz	r0, c04ce78 <mbedtls_ecp_mul_restartable+0xe0>
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mod( grp, &P->X, &P->X, &P->Z ) );
 c04ce4c:	462b      	mov	r3, r5
 c04ce4e:	4632      	mov	r2, r6
 c04ce50:	4631      	mov	r1, r6
 c04ce52:	4620      	mov	r0, r4
 c04ce54:	f7ff fc14 	bl	c04c680 <mbedtls_mpi_mul_mod>
 c04ce58:	4607      	mov	r7, r0
 c04ce5a:	b968      	cbnz	r0, c04ce78 <mbedtls_ecp_mul_restartable+0xe0>
    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &P->Z, 1 ) );
 c04ce5c:	2101      	movs	r1, #1
 c04ce5e:	4628      	mov	r0, r5
 c04ce60:	f006 faed 	bl	c05343e <mbedtls_mpi_lset>
 c04ce64:	4607      	mov	r7, r0
cleanup:
 c04ce66:	e007      	b.n	c04ce78 <mbedtls_ecp_mul_restartable+0xe0>
    MOD_ADD( RP.X );
 c04ce68:	a922      	add	r1, sp, #136	@ 0x88
 c04ce6a:	4652      	mov	r2, sl
 c04ce6c:	4608      	mov	r0, r1
 c04ce6e:	f006 fd95 	bl	c05399c <mbedtls_mpi_sub_abs>
 c04ce72:	4607      	mov	r7, r0
 c04ce74:	2800      	cmp	r0, #0
 c04ce76:	d0d2      	beq.n	c04ce1e <mbedtls_ecp_mul_restartable+0x86>
    if( pt == NULL )
 c04ce78:	a822      	add	r0, sp, #136	@ 0x88
 c04ce7a:	f7ff fc92 	bl	c04c7a2 <mbedtls_ecp_point_free.part.0>
    mbedtls_ecp_point_free( &RP ); mbedtls_mpi_free( &PX );
 c04ce7e:	a804      	add	r0, sp, #16
 c04ce80:	f006 fa3f 	bl	c053302 <mbedtls_mpi_free>
        MBEDTLS_MPI_CHK( ecp_mul_mxz( grp, R, m, P, f_rng, p_rng ) );
 c04ce84:	2f00      	cmp	r7, #0
 c04ce86:	f000 8142 	beq.w	c04d10e <mbedtls_ecp_mul_restartable+0x376>
}
 c04ce8a:	4638      	mov	r0, r7
 c04ce8c:	b02d      	add	sp, #180	@ 0xb4
 c04ce8e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    p_size = ( grp->pbits + 7 ) / 8;
 c04ce92:	6da3      	ldr	r3, [r4, #88]	@ 0x58
    mbedtls_mpi_init( &l );
 c04ce94:	a81f      	add	r0, sp, #124	@ 0x7c
    p_size = ( grp->pbits + 7 ) / 8;
 c04ce96:	3307      	adds	r3, #7
 c04ce98:	ea4f 09d3 	mov.w	r9, r3, lsr #3
    mbedtls_mpi_init( &l );
 c04ce9c:	f04f 0b0c 	mov.w	fp, #12
 c04cea0:	f006 fa29 	bl	c0532f6 <mbedtls_mpi_init>
        MBEDTLS_MPI_CHK( mbedtls_mpi_fill_random( &l, p_size, f_rng, p_rng ) );
 c04cea4:	e9dd 2336 	ldrd	r2, r3, [sp, #216]	@ 0xd8
 c04cea8:	4649      	mov	r1, r9
 c04ceaa:	a81f      	add	r0, sp, #124	@ 0x7c
 c04ceac:	f007 fc4a 	bl	c054744 <mbedtls_mpi_fill_random>
            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &l, 1 ) );
 c04ceb0:	4607      	mov	r7, r0
 c04ceb2:	b9e8      	cbnz	r0, c04cef0 <mbedtls_ecp_mul_restartable+0x158>
        while( mbedtls_mpi_cmp_mpi( &l, &grp->P ) >= 0 )
 c04ceb4:	4651      	mov	r1, sl
 c04ceb6:	a81f      	add	r0, sp, #124	@ 0x7c
 c04ceb8:	f006 fcc0 	bl	c05383c <mbedtls_mpi_cmp_mpi>
 c04cebc:	2800      	cmp	r0, #0
 c04cebe:	da1d      	bge.n	c04cefc <mbedtls_ecp_mul_restartable+0x164>
        if( count++ > 10 )
 c04cec0:	f1bb 0b01 	subs.w	fp, fp, #1
 c04cec4:	d01f      	beq.n	c04cf06 <mbedtls_ecp_mul_restartable+0x16e>
    while( mbedtls_mpi_cmp_int( &l, 1 ) <= 0 );
 c04cec6:	2101      	movs	r1, #1
 c04cec8:	a81f      	add	r0, sp, #124	@ 0x7c
 c04ceca:	f006 fcfa 	bl	c0538c2 <mbedtls_mpi_cmp_int>
 c04cece:	2800      	cmp	r0, #0
 c04ced0:	dde8      	ble.n	c04cea4 <mbedtls_ecp_mul_restartable+0x10c>
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mod( grp, &P->X, &P->X, &l ) );
 c04ced2:	aa22      	add	r2, sp, #136	@ 0x88
 c04ced4:	4611      	mov	r1, r2
 c04ced6:	4620      	mov	r0, r4
 c04ced8:	ab1f      	add	r3, sp, #124	@ 0x7c
 c04ceda:	f7ff fbd1 	bl	c04c680 <mbedtls_mpi_mul_mod>
 c04cede:	4607      	mov	r7, r0
 c04cee0:	b930      	cbnz	r0, c04cef0 <mbedtls_ecp_mul_restartable+0x158>
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mod( grp, &P->Z, &P->Z, &l ) );
 c04cee2:	aa28      	add	r2, sp, #160	@ 0xa0
 c04cee4:	4611      	mov	r1, r2
 c04cee6:	4620      	mov	r0, r4
 c04cee8:	ab1f      	add	r3, sp, #124	@ 0x7c
 c04ceea:	f7ff fbc9 	bl	c04c680 <mbedtls_mpi_mul_mod>
 c04ceee:	4607      	mov	r7, r0
    mbedtls_mpi_free( &l );
 c04cef0:	a81f      	add	r0, sp, #124	@ 0x7c
 c04cef2:	f006 fa06 	bl	c053302 <mbedtls_mpi_free>
        MBEDTLS_MPI_CHK( ecp_randomize_mxz( grp, &RP, f_rng, p_rng ) );
 c04cef6:	2f00      	cmp	r7, #0
 c04cef8:	d099      	beq.n	c04ce2e <mbedtls_ecp_mul_restartable+0x96>
 c04cefa:	e7bd      	b.n	c04ce78 <mbedtls_ecp_mul_restartable+0xe0>
            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &l, 1 ) );
 c04cefc:	2101      	movs	r1, #1
 c04cefe:	a81f      	add	r0, sp, #124	@ 0x7c
 c04cf00:	f006 fc2f 	bl	c053762 <mbedtls_mpi_shift_r>
 c04cf04:	e7d4      	b.n	c04ceb0 <mbedtls_ecp_mul_restartable+0x118>
            ret = MBEDTLS_ERR_ECP_RANDOM_FAILED;
 c04cf06:	4f9a      	ldr	r7, [pc, #616]	@ (c04d170 <mbedtls_ecp_mul_restartable+0x3d8>)
 c04cf08:	e7f2      	b.n	c04cef0 <mbedtls_ecp_mul_restartable+0x158>
        b = mbedtls_mpi_get_bit( m, i );
 c04cf0a:	4649      	mov	r1, r9
 c04cf0c:	9803      	ldr	r0, [sp, #12]
 c04cf0e:	f006 fab2 	bl	c053476 <mbedtls_mpi_get_bit>
 c04cf12:	fa5f fb80 	uxtb.w	fp, r0
        MBEDTLS_MPI_CHK( mbedtls_mpi_safe_cond_swap( &R->X, &RP.X, b ) );
 c04cf16:	465a      	mov	r2, fp
 c04cf18:	4630      	mov	r0, r6
 c04cf1a:	a922      	add	r1, sp, #136	@ 0x88
 c04cf1c:	f008 fc7e 	bl	c05581c <mbedtls_mpi_safe_cond_swap>
 c04cf20:	4607      	mov	r7, r0
 c04cf22:	2800      	cmp	r0, #0
 c04cf24:	d1a8      	bne.n	c04ce78 <mbedtls_ecp_mul_restartable+0xe0>
        MBEDTLS_MPI_CHK( mbedtls_mpi_safe_cond_swap( &R->Z, &RP.Z, b ) );
 c04cf26:	465a      	mov	r2, fp
 c04cf28:	4628      	mov	r0, r5
 c04cf2a:	a928      	add	r1, sp, #160	@ 0xa0
 c04cf2c:	f008 fc76 	bl	c05581c <mbedtls_mpi_safe_cond_swap>
 c04cf30:	4607      	mov	r7, r0
 c04cf32:	2800      	cmp	r0, #0
 c04cf34:	d1a0      	bne.n	c04ce78 <mbedtls_ecp_mul_restartable+0xe0>
    mbedtls_mpi_init( &A ); mbedtls_mpi_init( &AA ); mbedtls_mpi_init( &B );
 c04cf36:	a807      	add	r0, sp, #28
 c04cf38:	f006 f9dd 	bl	c0532f6 <mbedtls_mpi_init>
 c04cf3c:	a80a      	add	r0, sp, #40	@ 0x28
 c04cf3e:	f006 f9da 	bl	c0532f6 <mbedtls_mpi_init>
 c04cf42:	a80d      	add	r0, sp, #52	@ 0x34
 c04cf44:	f006 f9d7 	bl	c0532f6 <mbedtls_mpi_init>
    mbedtls_mpi_init( &BB ); mbedtls_mpi_init( &E ); mbedtls_mpi_init( &C );
 c04cf48:	a810      	add	r0, sp, #64	@ 0x40
 c04cf4a:	f006 f9d4 	bl	c0532f6 <mbedtls_mpi_init>
 c04cf4e:	a813      	add	r0, sp, #76	@ 0x4c
 c04cf50:	f006 f9d1 	bl	c0532f6 <mbedtls_mpi_init>
 c04cf54:	a816      	add	r0, sp, #88	@ 0x58
 c04cf56:	f006 f9ce 	bl	c0532f6 <mbedtls_mpi_init>
    mbedtls_mpi_init( &D ); mbedtls_mpi_init( &DA ); mbedtls_mpi_init( &CB );
 c04cf5a:	a819      	add	r0, sp, #100	@ 0x64
 c04cf5c:	f006 f9cb 	bl	c0532f6 <mbedtls_mpi_init>
 c04cf60:	a81c      	add	r0, sp, #112	@ 0x70
 c04cf62:	f006 f9c8 	bl	c0532f6 <mbedtls_mpi_init>
 c04cf66:	a81f      	add	r0, sp, #124	@ 0x7c
 c04cf68:	f006 f9c5 	bl	c0532f6 <mbedtls_mpi_init>
    MBEDTLS_MPI_CHK( mbedtls_mpi_add_mod( grp, &A,    &P->X,   &P->Z ) );
 c04cf6c:	462b      	mov	r3, r5
 c04cf6e:	4632      	mov	r2, r6
 c04cf70:	4620      	mov	r0, r4
 c04cf72:	a907      	add	r1, sp, #28
 c04cf74:	f7ff fbe7 	bl	c04c746 <mbedtls_mpi_add_mod>
 c04cf78:	4607      	mov	r7, r0
 c04cf7a:	2800      	cmp	r0, #0
 c04cf7c:	f040 8093 	bne.w	c04d0a6 <mbedtls_ecp_mul_restartable+0x30e>
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mod( grp, &AA,   &A,      &A    ) );
 c04cf80:	ab07      	add	r3, sp, #28
 c04cf82:	461a      	mov	r2, r3
 c04cf84:	4620      	mov	r0, r4
 c04cf86:	a90a      	add	r1, sp, #40	@ 0x28
 c04cf88:	f7ff fb7a 	bl	c04c680 <mbedtls_mpi_mul_mod>
 c04cf8c:	4607      	mov	r7, r0
 c04cf8e:	2800      	cmp	r0, #0
 c04cf90:	f040 8089 	bne.w	c04d0a6 <mbedtls_ecp_mul_restartable+0x30e>
    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mod( grp, &B,    &P->X,   &P->Z ) );
 c04cf94:	462b      	mov	r3, r5
 c04cf96:	4632      	mov	r2, r6
 c04cf98:	4620      	mov	r0, r4
 c04cf9a:	a90d      	add	r1, sp, #52	@ 0x34
 c04cf9c:	f7ff fbe3 	bl	c04c766 <mbedtls_mpi_sub_mod>
 c04cfa0:	4607      	mov	r7, r0
 c04cfa2:	2800      	cmp	r0, #0
 c04cfa4:	d17f      	bne.n	c04d0a6 <mbedtls_ecp_mul_restartable+0x30e>
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mod( grp, &BB,   &B,      &B    ) );
 c04cfa6:	ab0d      	add	r3, sp, #52	@ 0x34
 c04cfa8:	461a      	mov	r2, r3
 c04cfaa:	4620      	mov	r0, r4
 c04cfac:	a910      	add	r1, sp, #64	@ 0x40
 c04cfae:	f7ff fb67 	bl	c04c680 <mbedtls_mpi_mul_mod>
 c04cfb2:	4607      	mov	r7, r0
 c04cfb4:	2800      	cmp	r0, #0
 c04cfb6:	d176      	bne.n	c04d0a6 <mbedtls_ecp_mul_restartable+0x30e>
    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mod( grp, &E,    &AA,     &BB   ) );
 c04cfb8:	4620      	mov	r0, r4
 c04cfba:	ab10      	add	r3, sp, #64	@ 0x40
 c04cfbc:	aa0a      	add	r2, sp, #40	@ 0x28
 c04cfbe:	a913      	add	r1, sp, #76	@ 0x4c
 c04cfc0:	f7ff fbd1 	bl	c04c766 <mbedtls_mpi_sub_mod>
 c04cfc4:	4607      	mov	r7, r0
 c04cfc6:	2800      	cmp	r0, #0
 c04cfc8:	d16d      	bne.n	c04d0a6 <mbedtls_ecp_mul_restartable+0x30e>
    MBEDTLS_MPI_CHK( mbedtls_mpi_add_mod( grp, &C,    &Q->X,   &Q->Z ) );
 c04cfca:	4620      	mov	r0, r4
 c04cfcc:	ab28      	add	r3, sp, #160	@ 0xa0
 c04cfce:	aa22      	add	r2, sp, #136	@ 0x88
 c04cfd0:	a916      	add	r1, sp, #88	@ 0x58
 c04cfd2:	f7ff fbb8 	bl	c04c746 <mbedtls_mpi_add_mod>
 c04cfd6:	4607      	mov	r7, r0
 c04cfd8:	2800      	cmp	r0, #0
 c04cfda:	d164      	bne.n	c04d0a6 <mbedtls_ecp_mul_restartable+0x30e>
    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mod( grp, &D,    &Q->X,   &Q->Z ) );
 c04cfdc:	4620      	mov	r0, r4
 c04cfde:	ab28      	add	r3, sp, #160	@ 0xa0
 c04cfe0:	aa22      	add	r2, sp, #136	@ 0x88
 c04cfe2:	a919      	add	r1, sp, #100	@ 0x64
 c04cfe4:	f7ff fbbf 	bl	c04c766 <mbedtls_mpi_sub_mod>
 c04cfe8:	4607      	mov	r7, r0
 c04cfea:	2800      	cmp	r0, #0
 c04cfec:	d15b      	bne.n	c04d0a6 <mbedtls_ecp_mul_restartable+0x30e>
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mod( grp, &DA,   &D,      &A    ) );
 c04cfee:	4620      	mov	r0, r4
 c04cff0:	ab07      	add	r3, sp, #28
 c04cff2:	aa19      	add	r2, sp, #100	@ 0x64
 c04cff4:	a91c      	add	r1, sp, #112	@ 0x70
 c04cff6:	f7ff fb43 	bl	c04c680 <mbedtls_mpi_mul_mod>
 c04cffa:	4607      	mov	r7, r0
 c04cffc:	2800      	cmp	r0, #0
 c04cffe:	d152      	bne.n	c04d0a6 <mbedtls_ecp_mul_restartable+0x30e>
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mod( grp, &CB,   &C,      &B    ) );
 c04d000:	4620      	mov	r0, r4
 c04d002:	ab0d      	add	r3, sp, #52	@ 0x34
 c04d004:	aa16      	add	r2, sp, #88	@ 0x58
 c04d006:	a91f      	add	r1, sp, #124	@ 0x7c
 c04d008:	f7ff fb3a 	bl	c04c680 <mbedtls_mpi_mul_mod>
 c04d00c:	4607      	mov	r7, r0
 c04d00e:	2800      	cmp	r0, #0
 c04d010:	d149      	bne.n	c04d0a6 <mbedtls_ecp_mul_restartable+0x30e>
    MBEDTLS_MPI_CHK( mbedtls_mpi_add_mod( grp, &S->X, &DA,     &CB   ) );
 c04d012:	4620      	mov	r0, r4
 c04d014:	ab1f      	add	r3, sp, #124	@ 0x7c
 c04d016:	aa1c      	add	r2, sp, #112	@ 0x70
 c04d018:	a922      	add	r1, sp, #136	@ 0x88
 c04d01a:	f7ff fb94 	bl	c04c746 <mbedtls_mpi_add_mod>
 c04d01e:	4607      	mov	r7, r0
 c04d020:	2800      	cmp	r0, #0
 c04d022:	d140      	bne.n	c04d0a6 <mbedtls_ecp_mul_restartable+0x30e>
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mod( grp, &S->X, &S->X,   &S->X ) );
 c04d024:	ab22      	add	r3, sp, #136	@ 0x88
 c04d026:	461a      	mov	r2, r3
 c04d028:	4619      	mov	r1, r3
 c04d02a:	4620      	mov	r0, r4
 c04d02c:	f7ff fb28 	bl	c04c680 <mbedtls_mpi_mul_mod>
 c04d030:	4607      	mov	r7, r0
 c04d032:	2800      	cmp	r0, #0
 c04d034:	d137      	bne.n	c04d0a6 <mbedtls_ecp_mul_restartable+0x30e>
    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mod( grp, &S->Z, &DA,     &CB   ) );
 c04d036:	4620      	mov	r0, r4
 c04d038:	ab1f      	add	r3, sp, #124	@ 0x7c
 c04d03a:	aa1c      	add	r2, sp, #112	@ 0x70
 c04d03c:	a928      	add	r1, sp, #160	@ 0xa0
 c04d03e:	f7ff fb92 	bl	c04c766 <mbedtls_mpi_sub_mod>
 c04d042:	4607      	mov	r7, r0
 c04d044:	bb78      	cbnz	r0, c04d0a6 <mbedtls_ecp_mul_restartable+0x30e>
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mod( grp, &S->Z, &S->Z,   &S->Z ) );
 c04d046:	ab28      	add	r3, sp, #160	@ 0xa0
 c04d048:	461a      	mov	r2, r3
 c04d04a:	4619      	mov	r1, r3
 c04d04c:	4620      	mov	r0, r4
 c04d04e:	f7ff fb17 	bl	c04c680 <mbedtls_mpi_mul_mod>
 c04d052:	4607      	mov	r7, r0
 c04d054:	bb38      	cbnz	r0, c04d0a6 <mbedtls_ecp_mul_restartable+0x30e>
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mod( grp, &S->Z, d,       &S->Z ) );
 c04d056:	ab28      	add	r3, sp, #160	@ 0xa0
 c04d058:	4619      	mov	r1, r3
 c04d05a:	4620      	mov	r0, r4
 c04d05c:	aa04      	add	r2, sp, #16
 c04d05e:	f7ff fb0f 	bl	c04c680 <mbedtls_mpi_mul_mod>
 c04d062:	4607      	mov	r7, r0
 c04d064:	b9f8      	cbnz	r0, c04d0a6 <mbedtls_ecp_mul_restartable+0x30e>
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mod( grp, &R->X, &AA,     &BB   ) );
 c04d066:	4631      	mov	r1, r6
 c04d068:	4620      	mov	r0, r4
 c04d06a:	ab10      	add	r3, sp, #64	@ 0x40
 c04d06c:	aa0a      	add	r2, sp, #40	@ 0x28
 c04d06e:	f7ff fb07 	bl	c04c680 <mbedtls_mpi_mul_mod>
 c04d072:	4607      	mov	r7, r0
 c04d074:	b9b8      	cbnz	r0, c04d0a6 <mbedtls_ecp_mul_restartable+0x30e>
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mod( grp, &R->Z, &grp->A, &E    ) );
 c04d076:	4629      	mov	r1, r5
 c04d078:	4620      	mov	r0, r4
 c04d07a:	ab13      	add	r3, sp, #76	@ 0x4c
 c04d07c:	f104 0210 	add.w	r2, r4, #16
 c04d080:	f7ff fafe 	bl	c04c680 <mbedtls_mpi_mul_mod>
 c04d084:	4607      	mov	r7, r0
 c04d086:	b970      	cbnz	r0, c04d0a6 <mbedtls_ecp_mul_restartable+0x30e>
    MBEDTLS_MPI_CHK( mbedtls_mpi_add_mod( grp, &R->Z, &BB,     &R->Z ) );
 c04d088:	462b      	mov	r3, r5
 c04d08a:	4629      	mov	r1, r5
 c04d08c:	4620      	mov	r0, r4
 c04d08e:	aa10      	add	r2, sp, #64	@ 0x40
 c04d090:	f7ff fb59 	bl	c04c746 <mbedtls_mpi_add_mod>
 c04d094:	4607      	mov	r7, r0
 c04d096:	b930      	cbnz	r0, c04d0a6 <mbedtls_ecp_mul_restartable+0x30e>
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mod( grp, &R->Z, &E,      &R->Z ) );
 c04d098:	462b      	mov	r3, r5
 c04d09a:	4629      	mov	r1, r5
 c04d09c:	4620      	mov	r0, r4
 c04d09e:	aa13      	add	r2, sp, #76	@ 0x4c
 c04d0a0:	f7ff faee 	bl	c04c680 <mbedtls_mpi_mul_mod>
 c04d0a4:	4607      	mov	r7, r0
    mbedtls_mpi_free( &A ); mbedtls_mpi_free( &AA ); mbedtls_mpi_free( &B );
 c04d0a6:	a807      	add	r0, sp, #28
 c04d0a8:	f006 f92b 	bl	c053302 <mbedtls_mpi_free>
 c04d0ac:	a80a      	add	r0, sp, #40	@ 0x28
 c04d0ae:	f006 f928 	bl	c053302 <mbedtls_mpi_free>
 c04d0b2:	a80d      	add	r0, sp, #52	@ 0x34
 c04d0b4:	f006 f925 	bl	c053302 <mbedtls_mpi_free>
    mbedtls_mpi_free( &BB ); mbedtls_mpi_free( &E ); mbedtls_mpi_free( &C );
 c04d0b8:	a810      	add	r0, sp, #64	@ 0x40
 c04d0ba:	f006 f922 	bl	c053302 <mbedtls_mpi_free>
 c04d0be:	a813      	add	r0, sp, #76	@ 0x4c
 c04d0c0:	f006 f91f 	bl	c053302 <mbedtls_mpi_free>
 c04d0c4:	a816      	add	r0, sp, #88	@ 0x58
 c04d0c6:	f006 f91c 	bl	c053302 <mbedtls_mpi_free>
    mbedtls_mpi_free( &D ); mbedtls_mpi_free( &DA ); mbedtls_mpi_free( &CB );
 c04d0ca:	a819      	add	r0, sp, #100	@ 0x64
 c04d0cc:	f006 f919 	bl	c053302 <mbedtls_mpi_free>
 c04d0d0:	a81c      	add	r0, sp, #112	@ 0x70
 c04d0d2:	f006 f916 	bl	c053302 <mbedtls_mpi_free>
 c04d0d6:	a81f      	add	r0, sp, #124	@ 0x7c
 c04d0d8:	f006 f913 	bl	c053302 <mbedtls_mpi_free>
        MBEDTLS_MPI_CHK( ecp_double_add_mxz( grp, R, &RP, R, &RP, &PX ) );
 c04d0dc:	2f00      	cmp	r7, #0
 c04d0de:	f47f aecb 	bne.w	c04ce78 <mbedtls_ecp_mul_restartable+0xe0>
        MBEDTLS_MPI_CHK( mbedtls_mpi_safe_cond_swap( &R->X, &RP.X, b ) );
 c04d0e2:	465a      	mov	r2, fp
 c04d0e4:	4630      	mov	r0, r6
 c04d0e6:	a922      	add	r1, sp, #136	@ 0x88
 c04d0e8:	f008 fb98 	bl	c05581c <mbedtls_mpi_safe_cond_swap>
 c04d0ec:	4607      	mov	r7, r0
 c04d0ee:	2800      	cmp	r0, #0
 c04d0f0:	f47f aec2 	bne.w	c04ce78 <mbedtls_ecp_mul_restartable+0xe0>
        MBEDTLS_MPI_CHK( mbedtls_mpi_safe_cond_swap( &R->Z, &RP.Z, b ) );
 c04d0f4:	465a      	mov	r2, fp
 c04d0f6:	4628      	mov	r0, r5
 c04d0f8:	a928      	add	r1, sp, #160	@ 0xa0
 c04d0fa:	f008 fb8f 	bl	c05581c <mbedtls_mpi_safe_cond_swap>
 c04d0fe:	f109 39ff 	add.w	r9, r9, #4294967295	@ 0xffffffff
 c04d102:	4607      	mov	r7, r0
 c04d104:	2800      	cmp	r0, #0
 c04d106:	f43f ae97 	beq.w	c04ce38 <mbedtls_ecp_mul_restartable+0xa0>
 c04d10a:	e6b5      	b.n	c04ce78 <mbedtls_ecp_mul_restartable+0xe0>
    ret = MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
 c04d10c:	4f19      	ldr	r7, [pc, #100]	@ (c04d174 <mbedtls_ecp_mul_restartable+0x3dc>)
    if( mbedtls_ecp_get_type( grp ) == MBEDTLS_ECP_TYPE_SHORT_WEIERSTRASS )
 c04d10e:	4620      	mov	r0, r4
 c04d110:	f7ff fb62 	bl	c04c7d8 <mbedtls_ecp_get_type>
 c04d114:	2801      	cmp	r0, #1
 c04d116:	4683      	mov	fp, r0
 c04d118:	f47f aeb7 	bne.w	c04ce8a <mbedtls_ecp_mul_restartable+0xf2>
    PKA_HandleTypeDef hpka = {0};
 c04d11c:	2500      	movs	r5, #0
    PKA_ECCMulInTypeDef ECC_MulIn = {0};
 c04d11e:	2228      	movs	r2, #40	@ 0x28
 c04d120:	4629      	mov	r1, r5
 c04d122:	a822      	add	r0, sp, #136	@ 0x88
    PKA_HandleTypeDef hpka = {0};
 c04d124:	e9cd 551f 	strd	r5, r5, [sp, #124]	@ 0x7c
 c04d128:	9521      	str	r5, [sp, #132]	@ 0x84
    PKA_ECCMulInTypeDef ECC_MulIn = {0};
 c04d12a:	f00e fb00 	bl	c05b72e <memset>
    scalarMulSize = mbedtls_mpi_size(m);
 c04d12e:	9803      	ldr	r0, [sp, #12]
 c04d130:	f006 fa13 	bl	c05355a <mbedtls_mpi_size>
    ECC_MulIn.coefSign    = grp->st_a_sign;
 c04d134:	f8d4 3088 	ldr.w	r3, [r4, #136]	@ 0x88
    ECC_MulIn.scalarMulSize = scalarMulSize;
 c04d138:	9022      	str	r0, [sp, #136]	@ 0x88
    ECC_MulIn.coefSign    = grp->st_a_sign;
 c04d13a:	9324      	str	r3, [sp, #144]	@ 0x90
    ECC_MulIn.coefA       = grp->st_a_abs;
 c04d13c:	f8d4 308c 	ldr.w	r3, [r4, #140]	@ 0x8c
    scalarMulSize = mbedtls_mpi_size(m);
 c04d140:	4682      	mov	sl, r0
    ECC_MulIn.coefA       = grp->st_a_abs;
 c04d142:	9325      	str	r3, [sp, #148]	@ 0x94
    ECC_MulIn.modulus     = grp->st_p;
 c04d144:	f8d4 3084 	ldr.w	r3, [r4, #132]	@ 0x84
    ECC_MulIn.modulusSize = grp->st_modulus_size;
 c04d148:	6fe0      	ldr	r0, [r4, #124]	@ 0x7c
    ECC_MulIn.modulus     = grp->st_p;
 c04d14a:	9327      	str	r3, [sp, #156]	@ 0x9c
    ECC_MulIn.coefB       = grp->st_b;
 c04d14c:	f8d4 3090 	ldr.w	r3, [r4, #144]	@ 0x90
    ECC_MulIn.modulusSize = grp->st_modulus_size;
 c04d150:	9023      	str	r0, [sp, #140]	@ 0x8c
    ECC_MulIn.coefB       = grp->st_b;
 c04d152:	9326      	str	r3, [sp, #152]	@ 0x98
    P_binary = mbedtls_calloc(2U * grp->st_modulus_size + 1U, sizeof( uint8_t ));
 c04d154:	0040      	lsls	r0, r0, #1
    ECC_MulIn.primeOrder  = grp->st_n;
 c04d156:	f8d4 309c 	ldr.w	r3, [r4, #156]	@ 0x9c
    P_binary = mbedtls_calloc(2U * grp->st_modulus_size + 1U, sizeof( uint8_t ));
 c04d15a:	4659      	mov	r1, fp
 c04d15c:	3001      	adds	r0, #1
    ECC_MulIn.primeOrder  = grp->st_n;
 c04d15e:	932b      	str	r3, [sp, #172]	@ 0xac
    P_binary = mbedtls_calloc(2U * grp->st_modulus_size + 1U, sizeof( uint8_t ));
 c04d160:	f7ee f920 	bl	c03b3a4 <mbedtls_calloc>
    MBEDTLS_MPI_CHK((P_binary == NULL) ? MBEDTLS_ERR_ECP_ALLOC_FAILED : 0);
 c04d164:	4681      	mov	r9, r0
 c04d166:	b948      	cbnz	r0, c04d17c <mbedtls_ecp_mul_restartable+0x3e4>
    uint8_t *R_binary = NULL;
 c04d168:	2500      	movs	r5, #0
    uint8_t *m_binary = NULL;
 c04d16a:	46a8      	mov	r8, r5
    MBEDTLS_MPI_CHK((R_binary == NULL) ? MBEDTLS_ERR_ECP_ALLOC_FAILED : 0);
 c04d16c:	4f02      	ldr	r7, [pc, #8]	@ (c04d178 <mbedtls_ecp_mul_restartable+0x3e0>)
 c04d16e:	e04b      	b.n	c04d208 <mbedtls_ecp_mul_restartable+0x470>
 c04d170:	ffffb300 	.word	0xffffb300
 c04d174:	ffffb080 	.word	0xffffb080
 c04d178:	ffffb280 	.word	0xffffb280
    MBEDTLS_MPI_CHK( mbedtls_ecp_point_write_binary( grp, P, MBEDTLS_ECP_PF_UNCOMPRESSED, &olen, P_binary, 2U * grp->st_modulus_size + 1U) );
 c04d17c:	6fe3      	ldr	r3, [r4, #124]	@ 0x7c
 c04d17e:	462a      	mov	r2, r5
 c04d180:	005b      	lsls	r3, r3, #1
 c04d182:	3301      	adds	r3, #1
 c04d184:	e9cd 0300 	strd	r0, r3, [sp]
 c04d188:	4641      	mov	r1, r8
 c04d18a:	4620      	mov	r0, r4
 c04d18c:	ab16      	add	r3, sp, #88	@ 0x58
 c04d18e:	f7ff fc2d 	bl	c04c9ec <mbedtls_ecp_point_write_binary>
 c04d192:	4607      	mov	r7, r0
 c04d194:	2800      	cmp	r0, #0
 c04d196:	f040 8084 	bne.w	c04d2a2 <mbedtls_ecp_mul_restartable+0x50a>
    ECC_MulIn.pointX = P_binary + 1U;
 c04d19a:	f109 0301 	add.w	r3, r9, #1
 c04d19e:	9328      	str	r3, [sp, #160]	@ 0xa0
    ECC_MulIn.pointY = P_binary + grp->st_modulus_size + 1U;
 c04d1a0:	6fe3      	ldr	r3, [r4, #124]	@ 0x7c
    m_binary = mbedtls_calloc(scalarMulSize, sizeof( uint8_t ));
 c04d1a2:	4659      	mov	r1, fp
    ECC_MulIn.pointY = P_binary + grp->st_modulus_size + 1U;
 c04d1a4:	3301      	adds	r3, #1
 c04d1a6:	444b      	add	r3, r9
    m_binary = mbedtls_calloc(scalarMulSize, sizeof( uint8_t ));
 c04d1a8:	4650      	mov	r0, sl
    ECC_MulIn.pointY = P_binary + grp->st_modulus_size + 1U;
 c04d1aa:	9329      	str	r3, [sp, #164]	@ 0xa4
    m_binary = mbedtls_calloc(scalarMulSize, sizeof( uint8_t ));
 c04d1ac:	f7ee f8fa 	bl	c03b3a4 <mbedtls_calloc>
    MBEDTLS_MPI_CHK((m_binary == NULL) ? MBEDTLS_ERR_ECP_ALLOC_FAILED : 0);
 c04d1b0:	4680      	mov	r8, r0
 c04d1b2:	2800      	cmp	r0, #0
 c04d1b4:	d0d8      	beq.n	c04d168 <mbedtls_ecp_mul_restartable+0x3d0>
    MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( m, m_binary, scalarMulSize ) );
 c04d1b6:	4601      	mov	r1, r0
 c04d1b8:	4652      	mov	r2, sl
 c04d1ba:	9803      	ldr	r0, [sp, #12]
 c04d1bc:	f006 fa4c 	bl	c053658 <mbedtls_mpi_write_binary>
 c04d1c0:	4607      	mov	r7, r0
 c04d1c2:	bb08      	cbnz	r0, c04d208 <mbedtls_ecp_mul_restartable+0x470>
    __HAL_RCC_PKA_CLK_ENABLE();
 c04d1c4:	4b38      	ldr	r3, [pc, #224]	@ (c04d2a8 <mbedtls_ecp_mul_restartable+0x510>)
    ECC_MulIn.scalarMul = m_binary;
 c04d1c6:	f8cd 80a8 	str.w	r8, [sp, #168]	@ 0xa8
    __HAL_RCC_PKA_CLK_ENABLE();
 c04d1ca:	f8d3 208c 	ldr.w	r2, [r3, #140]	@ 0x8c
    MBEDTLS_MPI_CHK((HAL_PKA_Init(&hpka) != HAL_OK) ? MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED : 0);
 c04d1ce:	a81f      	add	r0, sp, #124	@ 0x7c
    __HAL_RCC_PKA_CLK_ENABLE();
 c04d1d0:	f442 2200 	orr.w	r2, r2, #524288	@ 0x80000
 c04d1d4:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
 c04d1d8:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 c04d1dc:	f403 2300 	and.w	r3, r3, #524288	@ 0x80000
 c04d1e0:	9319      	str	r3, [sp, #100]	@ 0x64
 c04d1e2:	9b19      	ldr	r3, [sp, #100]	@ 0x64
    hpka.Instance = PKA;
 c04d1e4:	4b31      	ldr	r3, [pc, #196]	@ (c04d2ac <mbedtls_ecp_mul_restartable+0x514>)
 c04d1e6:	931f      	str	r3, [sp, #124]	@ 0x7c
    MBEDTLS_MPI_CHK((HAL_PKA_Init(&hpka) != HAL_OK) ? MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED : 0);
 c04d1e8:	f7f2 ff51 	bl	c04008e <HAL_PKA_Init>
 c04d1ec:	b948      	cbnz	r0, c04d202 <mbedtls_ecp_mul_restartable+0x46a>
    HAL_PKA_RAMReset(&hpka);
 c04d1ee:	a81f      	add	r0, sp, #124	@ 0x7c
 c04d1f0:	f7f2 f9ec 	bl	c03f5cc <HAL_PKA_RAMReset>
    MBEDTLS_MPI_CHK((HAL_PKA_ECCMul(&hpka, &ECC_MulIn, ST_ECP_TIMEOUT) != HAL_OK) ? MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED : 0);
 c04d1f4:	f241 3288 	movw	r2, #5000	@ 0x1388
 c04d1f8:	a922      	add	r1, sp, #136	@ 0x88
 c04d1fa:	a81f      	add	r0, sp, #124	@ 0x7c
 c04d1fc:	f7f2 fec8 	bl	c03ff90 <HAL_PKA_ECCMul>
 c04d200:	b378      	cbz	r0, c04d262 <mbedtls_ecp_mul_restartable+0x4ca>
    uint8_t *R_binary = NULL;
 c04d202:	2500      	movs	r5, #0
    MBEDTLS_MPI_CHK((HAL_PKA_Init(&hpka) != HAL_OK) ? MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED : 0);
 c04d204:	f06f 076f 	mvn.w	r7, #111	@ 0x6f
    HAL_PKA_DeInit(&hpka);
 c04d208:	a81f      	add	r0, sp, #124	@ 0x7c
 c04d20a:	f7f2 f9b9 	bl	c03f580 <HAL_PKA_DeInit>
    __HAL_RCC_PKA_CLK_DISABLE();
 c04d20e:	4926      	ldr	r1, [pc, #152]	@ (c04d2a8 <mbedtls_ecp_mul_restartable+0x510>)
 c04d210:	f8d1 208c 	ldr.w	r2, [r1, #140]	@ 0x8c
 c04d214:	f422 2200 	bic.w	r2, r2, #524288	@ 0x80000
 c04d218:	f8c1 208c 	str.w	r2, [r1, #140]	@ 0x8c
    if (P_binary != NULL)
 c04d21c:	f1b9 0f00 	cmp.w	r9, #0
 c04d220:	d008      	beq.n	c04d234 <mbedtls_ecp_mul_restartable+0x49c>
        mbedtls_platform_zeroize(P_binary, 2U * grp->st_modulus_size + 1U);
 c04d222:	6fe1      	ldr	r1, [r4, #124]	@ 0x7c
 c04d224:	4648      	mov	r0, r9
 c04d226:	0049      	lsls	r1, r1, #1
 c04d228:	3101      	adds	r1, #1
 c04d22a:	f7ee f8d1 	bl	c03b3d0 <mbedtls_platform_zeroize>
        mbedtls_free(P_binary);
 c04d22e:	4648      	mov	r0, r9
 c04d230:	f7ee f8be 	bl	c03b3b0 <mbedtls_free>
    if (m_binary != NULL)
 c04d234:	f1b8 0f00 	cmp.w	r8, #0
 c04d238:	d006      	beq.n	c04d248 <mbedtls_ecp_mul_restartable+0x4b0>
        mbedtls_platform_zeroize(m_binary, scalarMulSize);
 c04d23a:	4640      	mov	r0, r8
 c04d23c:	4651      	mov	r1, sl
 c04d23e:	f7ee f8c7 	bl	c03b3d0 <mbedtls_platform_zeroize>
        mbedtls_free(m_binary);
 c04d242:	4640      	mov	r0, r8
 c04d244:	f7ee f8b4 	bl	c03b3b0 <mbedtls_free>
    if (R_binary != NULL)
 c04d248:	2d00      	cmp	r5, #0
 c04d24a:	f43f ae1e 	beq.w	c04ce8a <mbedtls_ecp_mul_restartable+0xf2>
        mbedtls_platform_zeroize(R_binary, 2U * grp->st_modulus_size + 1U);
 c04d24e:	6fe1      	ldr	r1, [r4, #124]	@ 0x7c
 c04d250:	4628      	mov	r0, r5
 c04d252:	0049      	lsls	r1, r1, #1
 c04d254:	3101      	adds	r1, #1
 c04d256:	f7ee f8bb 	bl	c03b3d0 <mbedtls_platform_zeroize>
        mbedtls_free(R_binary);
 c04d25a:	4628      	mov	r0, r5
 c04d25c:	f7ee f8a8 	bl	c03b3b0 <mbedtls_free>
    return( ret );
 c04d260:	e613      	b.n	c04ce8a <mbedtls_ecp_mul_restartable+0xf2>
    R_binary = mbedtls_calloc(2U * grp->st_modulus_size + 1U, sizeof( uint8_t ));
 c04d262:	6fe0      	ldr	r0, [r4, #124]	@ 0x7c
 c04d264:	4659      	mov	r1, fp
 c04d266:	0040      	lsls	r0, r0, #1
 c04d268:	3001      	adds	r0, #1
 c04d26a:	f7ee f89b 	bl	c03b3a4 <mbedtls_calloc>
    MBEDTLS_MPI_CHK((R_binary == NULL) ? MBEDTLS_ERR_ECP_ALLOC_FAILED : 0);
 c04d26e:	4605      	mov	r5, r0
 c04d270:	2800      	cmp	r0, #0
 c04d272:	f43f af7b 	beq.w	c04d16c <mbedtls_ecp_mul_restartable+0x3d4>
    ECC_MulOut.ptX = R_binary + 1U;
 c04d276:	1c43      	adds	r3, r0, #1
 c04d278:	931c      	str	r3, [sp, #112]	@ 0x70
    ECC_MulOut.ptY = R_binary + grp->st_modulus_size + 1U;
 c04d27a:	6fe3      	ldr	r3, [r4, #124]	@ 0x7c
    HAL_PKA_ECCMul_GetResult(&hpka, &ECC_MulOut);
 c04d27c:	a91c      	add	r1, sp, #112	@ 0x70
    ECC_MulOut.ptY = R_binary + grp->st_modulus_size + 1U;
 c04d27e:	3301      	adds	r3, #1
 c04d280:	4403      	add	r3, r0
    HAL_PKA_ECCMul_GetResult(&hpka, &ECC_MulOut);
 c04d282:	a81f      	add	r0, sp, #124	@ 0x7c
    ECC_MulOut.ptY = R_binary + grp->st_modulus_size + 1U;
 c04d284:	931d      	str	r3, [sp, #116]	@ 0x74
    HAL_PKA_ECCMul_GetResult(&hpka, &ECC_MulOut);
 c04d286:	f7f2 fa79 	bl	c03f77c <HAL_PKA_ECCMul_GetResult>
    R_binary[0] = 0x04U;
 c04d28a:	2304      	movs	r3, #4
 c04d28c:	702b      	strb	r3, [r5, #0]
    MBEDTLS_MPI_CHK( mbedtls_ecp_point_read_binary( grp, R, R_binary, 2U * grp->st_modulus_size + 1U) );
 c04d28e:	6fe3      	ldr	r3, [r4, #124]	@ 0x7c
 c04d290:	462a      	mov	r2, r5
 c04d292:	005b      	lsls	r3, r3, #1
 c04d294:	4631      	mov	r1, r6
 c04d296:	4620      	mov	r0, r4
 c04d298:	3301      	adds	r3, #1
 c04d29a:	f7ff fc13 	bl	c04cac4 <mbedtls_ecp_point_read_binary>
 c04d29e:	4607      	mov	r7, r0
cleanup:
 c04d2a0:	e7b2      	b.n	c04d208 <mbedtls_ecp_mul_restartable+0x470>
    uint8_t *m_binary = NULL;
 c04d2a2:	46a8      	mov	r8, r5
 c04d2a4:	e7b0      	b.n	c04d208 <mbedtls_ecp_mul_restartable+0x470>
 c04d2a6:	bf00      	nop
 c04d2a8:	56020c00 	.word	0x56020c00
 c04d2ac:	520c2000 	.word	0x520c2000

0c04d2b0 <mbedtls_ecp_mul>:
{
 c04d2b0:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    return( mbedtls_ecp_mul_restartable( grp, R, m, P, f_rng, p_rng, NULL ) );
 c04d2b2:	2400      	movs	r4, #0
 c04d2b4:	9402      	str	r4, [sp, #8]
 c04d2b6:	9c07      	ldr	r4, [sp, #28]
 c04d2b8:	9401      	str	r4, [sp, #4]
 c04d2ba:	9c06      	ldr	r4, [sp, #24]
 c04d2bc:	9400      	str	r4, [sp, #0]
 c04d2be:	f7ff fd6b 	bl	c04cd98 <mbedtls_ecp_mul_restartable>
}
 c04d2c2:	b004      	add	sp, #16
 c04d2c4:	bd10      	pop	{r4, pc}
	...

0c04d2c8 <mbedtls_ecp_gen_privkey>:
 */
int mbedtls_ecp_gen_privkey( const mbedtls_ecp_group *grp,
                     mbedtls_mpi *d,
                     int (*f_rng)(void *, unsigned char *, size_t),
                     void *p_rng )
{
 c04d2c8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c04d2cc:	b085      	sub	sp, #20

    ECP_VALIDATE_RET( grp   != NULL );
    ECP_VALIDATE_RET( d     != NULL );
    ECP_VALIDATE_RET( f_rng != NULL );

    n_size = ( grp->nbits + 7 ) / 8;
 c04d2ce:	6dc6      	ldr	r6, [r0, #92]	@ 0x5c
{
 c04d2d0:	4605      	mov	r5, r0
 c04d2d2:	4698      	mov	r8, r3

#if defined(MBEDTLS_ECP_MONTGOMERY_ENABLED)
    if( mbedtls_ecp_get_type( grp ) == MBEDTLS_ECP_TYPE_MONTGOMERY )
 c04d2d4:	f7ff fa80 	bl	c04c7d8 <mbedtls_ecp_get_type>
    n_size = ( grp->nbits + 7 ) / 8;
 c04d2d8:	3607      	adds	r6, #7
    if( mbedtls_ecp_get_type( grp ) == MBEDTLS_ECP_TYPE_MONTGOMERY )
 c04d2da:	2802      	cmp	r0, #2
{
 c04d2dc:	460c      	mov	r4, r1
 c04d2de:	4693      	mov	fp, r2
    n_size = ( grp->nbits + 7 ) / 8;
 c04d2e0:	ea4f 0ad6 	mov.w	sl, r6, lsr #3
    if( mbedtls_ecp_get_type( grp ) == MBEDTLS_ECP_TYPE_MONTGOMERY )
 c04d2e4:	d13b      	bne.n	c04d35e <mbedtls_ecp_gen_privkey+0x96>
    {
        /* [M225] page 5 */
        size_t b;

        do {
            MBEDTLS_MPI_CHK( mbedtls_mpi_fill_random( d, n_size, f_rng, p_rng ) );
 c04d2e6:	4643      	mov	r3, r8
 c04d2e8:	465a      	mov	r2, fp
 c04d2ea:	4651      	mov	r1, sl
 c04d2ec:	4620      	mov	r0, r4
 c04d2ee:	f007 fa29 	bl	c054744 <mbedtls_mpi_fill_random>
 c04d2f2:	4607      	mov	r7, r0
 c04d2f4:	2800      	cmp	r0, #0
 c04d2f6:	d163      	bne.n	c04d3c0 <mbedtls_ecp_gen_privkey+0xf8>
        } while( mbedtls_mpi_bitlen( d ) == 0);
 c04d2f8:	4620      	mov	r0, r4
 c04d2fa:	f006 f910 	bl	c05351e <mbedtls_mpi_bitlen>
 c04d2fe:	2800      	cmp	r0, #0
 c04d300:	d0f1      	beq.n	c04d2e6 <mbedtls_ecp_gen_privkey+0x1e>

        /* Make sure the most significant bit is nbits */
        b = mbedtls_mpi_bitlen( d ) - 1; /* mbedtls_mpi_bitlen is one-based */
 c04d302:	4620      	mov	r0, r4
 c04d304:	f006 f90b 	bl	c05351e <mbedtls_mpi_bitlen>
        if( b > grp->nbits )
 c04d308:	6de9      	ldr	r1, [r5, #92]	@ 0x5c
        b = mbedtls_mpi_bitlen( d ) - 1; /* mbedtls_mpi_bitlen is one-based */
 c04d30a:	3801      	subs	r0, #1
        if( b > grp->nbits )
 c04d30c:	4281      	cmp	r1, r0
 c04d30e:	d221      	bcs.n	c04d354 <mbedtls_ecp_gen_privkey+0x8c>
            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( d, b - grp->nbits ) );
 c04d310:	1a41      	subs	r1, r0, r1
 c04d312:	4620      	mov	r0, r4
 c04d314:	f006 fa25 	bl	c053762 <mbedtls_mpi_shift_r>
 c04d318:	4607      	mov	r7, r0
 c04d31a:	2800      	cmp	r0, #0
 c04d31c:	d150      	bne.n	c04d3c0 <mbedtls_ecp_gen_privkey+0xf8>
        else
            MBEDTLS_MPI_CHK( mbedtls_mpi_set_bit( d, grp->nbits, 1 ) );

        /* Make sure the last two bits are unset for Curve448, three bits for
           Curve25519 */
        MBEDTLS_MPI_CHK( mbedtls_mpi_set_bit( d, 0, 0 ) );
 c04d31e:	2200      	movs	r2, #0
 c04d320:	4620      	mov	r0, r4
 c04d322:	4611      	mov	r1, r2
 c04d324:	f006 f8b7 	bl	c053496 <mbedtls_mpi_set_bit>
 c04d328:	4607      	mov	r7, r0
 c04d32a:	2800      	cmp	r0, #0
 c04d32c:	d148      	bne.n	c04d3c0 <mbedtls_ecp_gen_privkey+0xf8>
        MBEDTLS_MPI_CHK( mbedtls_mpi_set_bit( d, 1, 0 ) );
 c04d32e:	4602      	mov	r2, r0
 c04d330:	2101      	movs	r1, #1
 c04d332:	4620      	mov	r0, r4
 c04d334:	f006 f8af 	bl	c053496 <mbedtls_mpi_set_bit>
 c04d338:	4607      	mov	r7, r0
 c04d33a:	2800      	cmp	r0, #0
 c04d33c:	d140      	bne.n	c04d3c0 <mbedtls_ecp_gen_privkey+0xf8>
        if( grp->nbits == 254 )
 c04d33e:	6deb      	ldr	r3, [r5, #92]	@ 0x5c
 c04d340:	2bfe      	cmp	r3, #254	@ 0xfe
 c04d342:	d10d      	bne.n	c04d360 <mbedtls_ecp_gen_privkey+0x98>
        {
            MBEDTLS_MPI_CHK( mbedtls_mpi_set_bit( d, 2, 0 ) );
 c04d344:	4602      	mov	r2, r0
 c04d346:	2102      	movs	r1, #2
 c04d348:	4620      	mov	r0, r4
 c04d34a:	f006 f8a4 	bl	c053496 <mbedtls_mpi_set_bit>
 c04d34e:	b138      	cbz	r0, c04d360 <mbedtls_ecp_gen_privkey+0x98>
        while( mbedtls_mpi_cmp_int( d, 1 ) < 0 || cmp != 1 );
    }
#endif /* MBEDTLS_ECP_SHORT_WEIERSTRASS_ENABLED */

cleanup:
    return( ret );
 c04d350:	4607      	mov	r7, r0
 c04d352:	e035      	b.n	c04d3c0 <mbedtls_ecp_gen_privkey+0xf8>
            MBEDTLS_MPI_CHK( mbedtls_mpi_set_bit( d, grp->nbits, 1 ) );
 c04d354:	2201      	movs	r2, #1
 c04d356:	4620      	mov	r0, r4
 c04d358:	f006 f89d 	bl	c053496 <mbedtls_mpi_set_bit>
 c04d35c:	e7dc      	b.n	c04d318 <mbedtls_ecp_gen_privkey+0x50>
    int ret = MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
 c04d35e:	4f1b      	ldr	r7, [pc, #108]	@ (c04d3cc <mbedtls_ecp_gen_privkey+0x104>)
    if( mbedtls_ecp_get_type( grp ) == MBEDTLS_ECP_TYPE_SHORT_WEIERSTRASS )
 c04d360:	4628      	mov	r0, r5
 c04d362:	f7ff fa39 	bl	c04c7d8 <mbedtls_ecp_get_type>
 c04d366:	2801      	cmp	r0, #1
 c04d368:	d12a      	bne.n	c04d3c0 <mbedtls_ecp_gen_privkey+0xf8>
        unsigned cmp = 0;
 c04d36a:	2300      	movs	r3, #0
 c04d36c:	f04f 091f 	mov.w	r9, #31
 c04d370:	9303      	str	r3, [sp, #12]
            ret = mbedtls_mpi_lt_mpi_ct( d, &grp->N, &cmp );
 c04d372:	f105 034c 	add.w	r3, r5, #76	@ 0x4c
            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( d, 8 * n_size - grp->nbits ) );
 c04d376:	f026 0607 	bic.w	r6, r6, #7
            ret = mbedtls_mpi_lt_mpi_ct( d, &grp->N, &cmp );
 c04d37a:	9301      	str	r3, [sp, #4]
            MBEDTLS_MPI_CHK( mbedtls_mpi_fill_random( d, n_size, f_rng, p_rng ) );
 c04d37c:	4643      	mov	r3, r8
 c04d37e:	465a      	mov	r2, fp
 c04d380:	4651      	mov	r1, sl
 c04d382:	4620      	mov	r0, r4
 c04d384:	f007 f9de 	bl	c054744 <mbedtls_mpi_fill_random>
 c04d388:	4607      	mov	r7, r0
 c04d38a:	b9c8      	cbnz	r0, c04d3c0 <mbedtls_ecp_gen_privkey+0xf8>
            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( d, 8 * n_size - grp->nbits ) );
 c04d38c:	6de9      	ldr	r1, [r5, #92]	@ 0x5c
 c04d38e:	4620      	mov	r0, r4
 c04d390:	1a71      	subs	r1, r6, r1
 c04d392:	f006 f9e6 	bl	c053762 <mbedtls_mpi_shift_r>
 c04d396:	4607      	mov	r7, r0
 c04d398:	b990      	cbnz	r0, c04d3c0 <mbedtls_ecp_gen_privkey+0xf8>
            if( ++count > 30 )
 c04d39a:	f1b9 0901 	subs.w	r9, r9, #1
 c04d39e:	d013      	beq.n	c04d3c8 <mbedtls_ecp_gen_privkey+0x100>
            ret = mbedtls_mpi_lt_mpi_ct( d, &grp->N, &cmp );
 c04d3a0:	4620      	mov	r0, r4
 c04d3a2:	9901      	ldr	r1, [sp, #4]
 c04d3a4:	aa03      	add	r2, sp, #12
 c04d3a6:	f008 fa79 	bl	c05589c <mbedtls_mpi_lt_mpi_ct>
            if( ret != 0 )
 c04d3aa:	4607      	mov	r7, r0
 c04d3ac:	b940      	cbnz	r0, c04d3c0 <mbedtls_ecp_gen_privkey+0xf8>
        while( mbedtls_mpi_cmp_int( d, 1 ) < 0 || cmp != 1 );
 c04d3ae:	2101      	movs	r1, #1
 c04d3b0:	4620      	mov	r0, r4
 c04d3b2:	f006 fa86 	bl	c0538c2 <mbedtls_mpi_cmp_int>
 c04d3b6:	2800      	cmp	r0, #0
 c04d3b8:	dbe0      	blt.n	c04d37c <mbedtls_ecp_gen_privkey+0xb4>
 c04d3ba:	9b03      	ldr	r3, [sp, #12]
 c04d3bc:	2b01      	cmp	r3, #1
 c04d3be:	d1dd      	bne.n	c04d37c <mbedtls_ecp_gen_privkey+0xb4>
}
 c04d3c0:	4638      	mov	r0, r7
 c04d3c2:	b005      	add	sp, #20
 c04d3c4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                ret = MBEDTLS_ERR_ECP_RANDOM_FAILED;
 c04d3c8:	4f01      	ldr	r7, [pc, #4]	@ (c04d3d0 <mbedtls_ecp_gen_privkey+0x108>)
 c04d3ca:	e7f9      	b.n	c04d3c0 <mbedtls_ecp_gen_privkey+0xf8>
 c04d3cc:	ffffb080 	.word	0xffffb080
 c04d3d0:	ffffb300 	.word	0xffffb300

0c04d3d4 <mbedtls_ecp_gen_keypair_base>:
int mbedtls_ecp_gen_keypair_base( mbedtls_ecp_group *grp,
                     const mbedtls_ecp_point *G,
                     mbedtls_mpi *d, mbedtls_ecp_point *Q,
                     int (*f_rng)(void *, unsigned char *, size_t),
                     void *p_rng )
{
 c04d3d4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 c04d3d8:	4614      	mov	r4, r2
 c04d3da:	e9dd 8908 	ldrd	r8, r9, [sp, #32]
 c04d3de:	460f      	mov	r7, r1
 c04d3e0:	461e      	mov	r6, r3
    ECP_VALIDATE_RET( d     != NULL );
    ECP_VALIDATE_RET( G     != NULL );
    ECP_VALIDATE_RET( Q     != NULL );
    ECP_VALIDATE_RET( f_rng != NULL );

    MBEDTLS_MPI_CHK( mbedtls_ecp_gen_privkey( grp, d, f_rng, p_rng ) );
 c04d3e2:	4642      	mov	r2, r8
 c04d3e4:	464b      	mov	r3, r9
 c04d3e6:	4621      	mov	r1, r4
{
 c04d3e8:	4605      	mov	r5, r0
    MBEDTLS_MPI_CHK( mbedtls_ecp_gen_privkey( grp, d, f_rng, p_rng ) );
 c04d3ea:	f7ff ff6d 	bl	c04d2c8 <mbedtls_ecp_gen_privkey>
 c04d3ee:	b948      	cbnz	r0, c04d404 <mbedtls_ecp_gen_keypair_base+0x30>
    MBEDTLS_MPI_CHK( mbedtls_ecp_mul( grp, Q, d, G, f_rng, p_rng ) );
 c04d3f0:	463b      	mov	r3, r7
 c04d3f2:	4622      	mov	r2, r4
 c04d3f4:	4631      	mov	r1, r6
 c04d3f6:	4628      	mov	r0, r5
 c04d3f8:	e9cd 8908 	strd	r8, r9, [sp, #32]

cleanup:
    return( ret );
}
 c04d3fc:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    MBEDTLS_MPI_CHK( mbedtls_ecp_mul( grp, Q, d, G, f_rng, p_rng ) );
 c04d400:	f7ff bf56 	b.w	c04d2b0 <mbedtls_ecp_mul>
}
 c04d404:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

0c04d408 <mbedtls_ecp_gen_keypair>:
 */
int mbedtls_ecp_gen_keypair( mbedtls_ecp_group *grp,
                             mbedtls_mpi *d, mbedtls_ecp_point *Q,
                             int (*f_rng)(void *, unsigned char *, size_t),
                             void *p_rng )
{
 c04d408:	b513      	push	{r0, r1, r4, lr}
    ECP_VALIDATE_RET( grp   != NULL );
    ECP_VALIDATE_RET( d     != NULL );
    ECP_VALIDATE_RET( Q     != NULL );
    ECP_VALIDATE_RET( f_rng != NULL );

    return( mbedtls_ecp_gen_keypair_base( grp, &grp->G, d, Q, f_rng, p_rng ) );
 c04d40a:	9c04      	ldr	r4, [sp, #16]
 c04d40c:	e9cd 3400 	strd	r3, r4, [sp]
 c04d410:	4613      	mov	r3, r2
 c04d412:	460a      	mov	r2, r1
 c04d414:	f100 0128 	add.w	r1, r0, #40	@ 0x28
 c04d418:	f7ff ffdc 	bl	c04d3d4 <mbedtls_ecp_gen_keypair_base>
}
 c04d41c:	b002      	add	sp, #8
 c04d41e:	bd10      	pop	{r4, pc}

0c04d420 <mbedtls_ecp_gen_key>:
/*
 * Generate a key pair, prettier wrapper
 */
int mbedtls_ecp_gen_key( mbedtls_ecp_group_id grp_id, mbedtls_ecp_keypair *key,
                int (*f_rng)(void *, unsigned char *, size_t), void *p_rng )
{
 c04d420:	b573      	push	{r0, r1, r4, r5, r6, lr}
 c04d422:	460c      	mov	r4, r1
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    ECP_VALIDATE_RET( key   != NULL );
    ECP_VALIDATE_RET( f_rng != NULL );

    if( ( ret = mbedtls_ecp_group_load( &key->grp, grp_id ) ) != 0 )
 c04d424:	4601      	mov	r1, r0
 c04d426:	4620      	mov	r0, r4
{
 c04d428:	4615      	mov	r5, r2
 c04d42a:	461e      	mov	r6, r3
    if( ( ret = mbedtls_ecp_group_load( &key->grp, grp_id ) ) != 0 )
 c04d42c:	f000 fae0 	bl	c04d9f0 <mbedtls_ecp_group_load>
 c04d430:	b940      	cbnz	r0, c04d444 <mbedtls_ecp_gen_key+0x24>
        return( ret );

    return( mbedtls_ecp_gen_keypair( &key->grp, &key->d, &key->Q, f_rng, p_rng ) );
 c04d432:	462b      	mov	r3, r5
 c04d434:	4620      	mov	r0, r4
 c04d436:	9600      	str	r6, [sp, #0]
 c04d438:	f104 02ac 	add.w	r2, r4, #172	@ 0xac
 c04d43c:	f104 01a0 	add.w	r1, r4, #160	@ 0xa0
 c04d440:	f7ff ffe2 	bl	c04d408 <mbedtls_ecp_gen_keypair>
}
 c04d444:	b002      	add	sp, #8
 c04d446:	bd70      	pop	{r4, r5, r6, pc}

0c04d448 <mbedtls_ecp_read_key>:
/*
 * Read a private key.
 */
int mbedtls_ecp_read_key( mbedtls_ecp_group_id grp_id, mbedtls_ecp_keypair *key,
                          const unsigned char *buf, size_t buflen )
{
 c04d448:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 c04d44c:	460d      	mov	r5, r1
 c04d44e:	4604      	mov	r4, r0
    int ret = 0;

    ECP_VALIDATE_RET( key  != NULL );
    ECP_VALIDATE_RET( buf  != NULL );

    if( ( ret = mbedtls_ecp_group_load( &key->grp, grp_id ) ) != 0 )
 c04d450:	4601      	mov	r1, r0
 c04d452:	4628      	mov	r0, r5
{
 c04d454:	4690      	mov	r8, r2
 c04d456:	461f      	mov	r7, r3
    if( ( ret = mbedtls_ecp_group_load( &key->grp, grp_id ) ) != 0 )
 c04d458:	f000 faca 	bl	c04d9f0 <mbedtls_ecp_group_load>
 c04d45c:	4606      	mov	r6, r0
 c04d45e:	2800      	cmp	r0, #0
 c04d460:	d152      	bne.n	c04d508 <mbedtls_ecp_read_key+0xc0>
        return( ret );

    ret = MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE;

#if defined(MBEDTLS_ECP_MONTGOMERY_ENABLED)
    if( mbedtls_ecp_get_type( &key->grp ) == MBEDTLS_ECP_TYPE_MONTGOMERY )
 c04d462:	4628      	mov	r0, r5
 c04d464:	f7ff f9b8 	bl	c04c7d8 <mbedtls_ecp_get_type>
 c04d468:	2802      	cmp	r0, #2
 c04d46a:	4682      	mov	sl, r0
 c04d46c:	d135      	bne.n	c04d4da <mbedtls_ecp_read_key+0x92>
    {
        /*
         * If it is Curve25519 curve then mask the key as mandated by RFC7748
         */
        if( grp_id == MBEDTLS_ECP_DP_CURVE25519 )
 c04d46e:	2c09      	cmp	r4, #9
 c04d470:	d133      	bne.n	c04d4da <mbedtls_ecp_read_key+0x92>
        {
            if( buflen != ECP_CURVE25519_KEY_SIZE )
 c04d472:	2f20      	cmp	r7, #32
 c04d474:	d14f      	bne.n	c04d516 <mbedtls_ecp_read_key+0xce>
                return MBEDTLS_ERR_ECP_INVALID_KEY;

            MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary_le( &key->d, buf, buflen ) );
 c04d476:	f105 09a0 	add.w	r9, r5, #160	@ 0xa0
 c04d47a:	463a      	mov	r2, r7
 c04d47c:	4641      	mov	r1, r8
 c04d47e:	4648      	mov	r0, r9
 c04d480:	f006 f871 	bl	c053566 <mbedtls_mpi_read_binary_le>
 c04d484:	4604      	mov	r4, r0
 c04d486:	bb10      	cbnz	r0, c04d4ce <mbedtls_ecp_read_key+0x86>

            /* Set the three least significant bits to 0 */
            MBEDTLS_MPI_CHK( mbedtls_mpi_set_bit( &key->d, 0, 0 ) );
 c04d488:	4602      	mov	r2, r0
 c04d48a:	4601      	mov	r1, r0
 c04d48c:	4648      	mov	r0, r9
 c04d48e:	f006 f802 	bl	c053496 <mbedtls_mpi_set_bit>
 c04d492:	4604      	mov	r4, r0
 c04d494:	b9d8      	cbnz	r0, c04d4ce <mbedtls_ecp_read_key+0x86>
            MBEDTLS_MPI_CHK( mbedtls_mpi_set_bit( &key->d, 1, 0 ) );
 c04d496:	4602      	mov	r2, r0
 c04d498:	2101      	movs	r1, #1
 c04d49a:	4648      	mov	r0, r9
 c04d49c:	f005 fffb 	bl	c053496 <mbedtls_mpi_set_bit>
 c04d4a0:	4604      	mov	r4, r0
 c04d4a2:	b9a0      	cbnz	r0, c04d4ce <mbedtls_ecp_read_key+0x86>
            MBEDTLS_MPI_CHK( mbedtls_mpi_set_bit( &key->d, 2, 0 ) );
 c04d4a4:	4602      	mov	r2, r0
 c04d4a6:	4651      	mov	r1, sl
 c04d4a8:	4648      	mov	r0, r9
 c04d4aa:	f005 fff4 	bl	c053496 <mbedtls_mpi_set_bit>
 c04d4ae:	4604      	mov	r4, r0
 c04d4b0:	b968      	cbnz	r0, c04d4ce <mbedtls_ecp_read_key+0x86>

            /* Set the most significant bit to 0 */
            MBEDTLS_MPI_CHK(
 c04d4b2:	4602      	mov	r2, r0
 c04d4b4:	21ff      	movs	r1, #255	@ 0xff
 c04d4b6:	4648      	mov	r0, r9
 c04d4b8:	f005 ffed 	bl	c053496 <mbedtls_mpi_set_bit>
 c04d4bc:	4604      	mov	r4, r0
 c04d4be:	b930      	cbnz	r0, c04d4ce <mbedtls_ecp_read_key+0x86>
                    mbedtls_mpi_set_bit( &key->d,
                                         ECP_CURVE25519_KEY_SIZE * 8 - 1, 0 )
                    );

            /* Set the second most significant bit to 1 */
            MBEDTLS_MPI_CHK(
 c04d4c0:	2201      	movs	r2, #1
 c04d4c2:	21fe      	movs	r1, #254	@ 0xfe
 c04d4c4:	4648      	mov	r0, r9
 c04d4c6:	f005 ffe6 	bl	c053496 <mbedtls_mpi_set_bit>
 c04d4ca:	4604      	mov	r4, r0
 c04d4cc:	b130      	cbz	r0, c04d4dc <mbedtls_ecp_read_key+0x94>

#endif
cleanup:

    if( ret != 0 )
        mbedtls_mpi_free( &key->d );
 c04d4ce:	f105 00a0 	add.w	r0, r5, #160	@ 0xa0
 c04d4d2:	f005 ff16 	bl	c053302 <mbedtls_mpi_free>
 c04d4d6:	4626      	mov	r6, r4
 c04d4d8:	e016      	b.n	c04d508 <mbedtls_ecp_read_key+0xc0>
    ret = MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE;
 c04d4da:	4c10      	ldr	r4, [pc, #64]	@ (c04d51c <mbedtls_ecp_read_key+0xd4>)
    if( mbedtls_ecp_get_type( &key->grp ) == MBEDTLS_ECP_TYPE_SHORT_WEIERSTRASS )
 c04d4dc:	4628      	mov	r0, r5
 c04d4de:	f7ff f97b 	bl	c04c7d8 <mbedtls_ecp_get_type>
 c04d4e2:	2801      	cmp	r0, #1
 c04d4e4:	d113      	bne.n	c04d50e <mbedtls_ecp_read_key+0xc6>
        MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( &key->d, buf, buflen ) );
 c04d4e6:	f105 09a0 	add.w	r9, r5, #160	@ 0xa0
 c04d4ea:	463a      	mov	r2, r7
 c04d4ec:	4641      	mov	r1, r8
 c04d4ee:	4648      	mov	r0, r9
 c04d4f0:	f006 f85b 	bl	c0535aa <mbedtls_mpi_read_binary>
 c04d4f4:	4604      	mov	r4, r0
 c04d4f6:	2800      	cmp	r0, #0
 c04d4f8:	d1e9      	bne.n	c04d4ce <mbedtls_ecp_read_key+0x86>
        MBEDTLS_MPI_CHK( mbedtls_ecp_check_privkey( &key->grp, &key->d ) );
 c04d4fa:	4649      	mov	r1, r9
 c04d4fc:	4628      	mov	r0, r5
 c04d4fe:	f7ff fc0f 	bl	c04cd20 <mbedtls_ecp_check_privkey>
 c04d502:	4604      	mov	r4, r0
 c04d504:	2800      	cmp	r0, #0
 c04d506:	d1e2      	bne.n	c04d4ce <mbedtls_ecp_read_key+0x86>

    return( ret );
}
 c04d508:	4630      	mov	r0, r6
 c04d50a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if( ret != 0 )
 c04d50e:	2c00      	cmp	r4, #0
 c04d510:	d0fa      	beq.n	c04d508 <mbedtls_ecp_read_key+0xc0>
 c04d512:	4c02      	ldr	r4, [pc, #8]	@ (c04d51c <mbedtls_ecp_read_key+0xd4>)
 c04d514:	e7db      	b.n	c04d4ce <mbedtls_ecp_read_key+0x86>
                return MBEDTLS_ERR_ECP_INVALID_KEY;
 c04d516:	4e02      	ldr	r6, [pc, #8]	@ (c04d520 <mbedtls_ecp_read_key+0xd8>)
 c04d518:	e7f6      	b.n	c04d508 <mbedtls_ecp_read_key+0xc0>
 c04d51a:	bf00      	nop
 c04d51c:	ffffb180 	.word	0xffffb180
 c04d520:	ffffb380 	.word	0xffffb380

0c04d524 <mbedtls_ecp_write_key>:
/*
 * Write a private key.
 */
int mbedtls_ecp_write_key( mbedtls_ecp_keypair *key,
                           unsigned char *buf, size_t buflen )
{
 c04d524:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 c04d526:	4605      	mov	r5, r0

    ECP_VALIDATE_RET( key != NULL );
    ECP_VALIDATE_RET( buf != NULL );

#if defined(MBEDTLS_ECP_MONTGOMERY_ENABLED)
    if( mbedtls_ecp_get_type( &key->grp ) == MBEDTLS_ECP_TYPE_MONTGOMERY )
 c04d528:	f7ff f956 	bl	c04c7d8 <mbedtls_ecp_get_type>
 c04d52c:	2802      	cmp	r0, #2
{
 c04d52e:	460f      	mov	r7, r1
 c04d530:	4616      	mov	r6, r2
    if( mbedtls_ecp_get_type( &key->grp ) == MBEDTLS_ECP_TYPE_MONTGOMERY )
 c04d532:	d10c      	bne.n	c04d54e <mbedtls_ecp_write_key+0x2a>
    {
        if( key->grp.id == MBEDTLS_ECP_DP_CURVE25519 )
 c04d534:	782b      	ldrb	r3, [r5, #0]
 c04d536:	2b09      	cmp	r3, #9
 c04d538:	d109      	bne.n	c04d54e <mbedtls_ecp_write_key+0x2a>
        {
            if( buflen < ECP_CURVE25519_KEY_SIZE )
 c04d53a:	2a1f      	cmp	r2, #31
 c04d53c:	d915      	bls.n	c04d56a <mbedtls_ecp_write_key+0x46>
                return MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL;

            MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary_le( &key->d, buf, buflen ) );
 c04d53e:	f105 00a0 	add.w	r0, r5, #160	@ 0xa0
 c04d542:	f006 f853 	bl	c0535ec <mbedtls_mpi_write_binary_le>
 c04d546:	4604      	mov	r4, r0
 c04d548:	b110      	cbz	r0, c04d550 <mbedtls_ecp_write_key+0x2c>

#endif
cleanup:

    return( ret );
}
 c04d54a:	4620      	mov	r0, r4
 c04d54c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    int ret = MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE;
 c04d54e:	4c08      	ldr	r4, [pc, #32]	@ (c04d570 <mbedtls_ecp_write_key+0x4c>)
    if( mbedtls_ecp_get_type( &key->grp ) == MBEDTLS_ECP_TYPE_SHORT_WEIERSTRASS )
 c04d550:	4628      	mov	r0, r5
 c04d552:	f7ff f941 	bl	c04c7d8 <mbedtls_ecp_get_type>
 c04d556:	2801      	cmp	r0, #1
 c04d558:	d1f7      	bne.n	c04d54a <mbedtls_ecp_write_key+0x26>
        MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( &key->d, buf, buflen ) );
 c04d55a:	4632      	mov	r2, r6
 c04d55c:	4639      	mov	r1, r7
 c04d55e:	f105 00a0 	add.w	r0, r5, #160	@ 0xa0
}
 c04d562:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
        MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( &key->d, buf, buflen ) );
 c04d566:	f006 b877 	b.w	c053658 <mbedtls_mpi_write_binary>
                return MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL;
 c04d56a:	4c02      	ldr	r4, [pc, #8]	@ (c04d574 <mbedtls_ecp_write_key+0x50>)
 c04d56c:	e7ed      	b.n	c04d54a <mbedtls_ecp_write_key+0x26>
 c04d56e:	bf00      	nop
 c04d570:	ffffb180 	.word	0xffffb180
 c04d574:	ffffb100 	.word	0xffffb100

0c04d578 <mbedtls_ecp_check_pub_priv>:

/*
 * Check a public-private key pair
 */
int mbedtls_ecp_check_pub_priv( const mbedtls_ecp_keypair *pub, const mbedtls_ecp_keypair *prv )
{
 c04d578:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    mbedtls_ecp_point Q;
    mbedtls_ecp_group grp;
    ECP_VALIDATE_RET( pub != NULL );
    ECP_VALIDATE_RET( prv != NULL );

    if( pub->grp.id == MBEDTLS_ECP_DP_NONE ||
 c04d57c:	7803      	ldrb	r3, [r0, #0]
{
 c04d57e:	4605      	mov	r5, r0
 c04d580:	460c      	mov	r4, r1
 c04d582:	b0b4      	sub	sp, #208	@ 0xd0
    if( pub->grp.id == MBEDTLS_ECP_DP_NONE ||
 c04d584:	b923      	cbnz	r3, c04d590 <mbedtls_ecp_check_pub_priv+0x18>
        pub->grp.id != prv->grp.id ||
        mbedtls_mpi_cmp_mpi( &pub->Q.X, &prv->Q.X ) ||
        mbedtls_mpi_cmp_mpi( &pub->Q.Y, &prv->Q.Y ) ||
        mbedtls_mpi_cmp_mpi( &pub->Q.Z, &prv->Q.Z ) )
    {
        return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );
 c04d586:	4c28      	ldr	r4, [pc, #160]	@ (c04d628 <mbedtls_ecp_check_pub_priv+0xb0>)
cleanup:
    mbedtls_ecp_point_free( &Q );
    mbedtls_ecp_group_free( &grp );

    return( ret );
}
 c04d588:	4620      	mov	r0, r4
 c04d58a:	b034      	add	sp, #208	@ 0xd0
 c04d58c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if( pub->grp.id == MBEDTLS_ECP_DP_NONE ||
 c04d590:	780a      	ldrb	r2, [r1, #0]
 c04d592:	429a      	cmp	r2, r3
 c04d594:	d1f7      	bne.n	c04d586 <mbedtls_ecp_check_pub_priv+0xe>
        mbedtls_mpi_cmp_mpi( &pub->Q.X, &prv->Q.X ) ||
 c04d596:	f101 08ac 	add.w	r8, r1, #172	@ 0xac
 c04d59a:	4641      	mov	r1, r8
 c04d59c:	30ac      	adds	r0, #172	@ 0xac
 c04d59e:	f006 f94d 	bl	c05383c <mbedtls_mpi_cmp_mpi>
        pub->grp.id != prv->grp.id ||
 c04d5a2:	2800      	cmp	r0, #0
 c04d5a4:	d1ef      	bne.n	c04d586 <mbedtls_ecp_check_pub_priv+0xe>
        mbedtls_mpi_cmp_mpi( &pub->Q.Y, &prv->Q.Y ) ||
 c04d5a6:	f104 07b8 	add.w	r7, r4, #184	@ 0xb8
 c04d5aa:	4639      	mov	r1, r7
 c04d5ac:	f105 00b8 	add.w	r0, r5, #184	@ 0xb8
 c04d5b0:	f006 f944 	bl	c05383c <mbedtls_mpi_cmp_mpi>
        mbedtls_mpi_cmp_mpi( &pub->Q.X, &prv->Q.X ) ||
 c04d5b4:	2800      	cmp	r0, #0
 c04d5b6:	d1e6      	bne.n	c04d586 <mbedtls_ecp_check_pub_priv+0xe>
        mbedtls_mpi_cmp_mpi( &pub->Q.Z, &prv->Q.Z ) )
 c04d5b8:	f104 06c4 	add.w	r6, r4, #196	@ 0xc4
 c04d5bc:	f105 00c4 	add.w	r0, r5, #196	@ 0xc4
 c04d5c0:	4631      	mov	r1, r6
 c04d5c2:	f006 f93b 	bl	c05383c <mbedtls_mpi_cmp_mpi>
        mbedtls_mpi_cmp_mpi( &pub->Q.Y, &prv->Q.Y ) ||
 c04d5c6:	4605      	mov	r5, r0
 c04d5c8:	2800      	cmp	r0, #0
 c04d5ca:	d1dc      	bne.n	c04d586 <mbedtls_ecp_check_pub_priv+0xe>
    mbedtls_ecp_point_init( &Q );
 c04d5cc:	a803      	add	r0, sp, #12
 c04d5ce:	f7ff f90c 	bl	c04c7ea <mbedtls_ecp_point_init>
    mbedtls_ecp_group_init( &grp );
 c04d5d2:	a80c      	add	r0, sp, #48	@ 0x30
 c04d5d4:	f7ff f917 	bl	c04c806 <mbedtls_ecp_group_init>
    mbedtls_ecp_group_copy( &grp, &prv->grp );
 c04d5d8:	4621      	mov	r1, r4
 c04d5da:	a80c      	add	r0, sp, #48	@ 0x30
 c04d5dc:	f7ff f9e5 	bl	c04c9aa <mbedtls_ecp_group_copy>
    MBEDTLS_MPI_CHK( mbedtls_ecp_mul( &grp, &Q, &prv->d, &prv->grp.G, NULL, NULL ) );
 c04d5e0:	f104 0328 	add.w	r3, r4, #40	@ 0x28
 c04d5e4:	f104 02a0 	add.w	r2, r4, #160	@ 0xa0
 c04d5e8:	e9cd 5500 	strd	r5, r5, [sp]
 c04d5ec:	a903      	add	r1, sp, #12
 c04d5ee:	a80c      	add	r0, sp, #48	@ 0x30
 c04d5f0:	f7ff fe5e 	bl	c04d2b0 <mbedtls_ecp_mul>
 c04d5f4:	4604      	mov	r4, r0
 c04d5f6:	b980      	cbnz	r0, c04d61a <mbedtls_ecp_check_pub_priv+0xa2>
    if( mbedtls_mpi_cmp_mpi( &Q.X, &prv->Q.X ) ||
 c04d5f8:	4641      	mov	r1, r8
 c04d5fa:	a803      	add	r0, sp, #12
 c04d5fc:	f006 f91e 	bl	c05383c <mbedtls_mpi_cmp_mpi>
 c04d600:	b950      	cbnz	r0, c04d618 <mbedtls_ecp_check_pub_priv+0xa0>
        mbedtls_mpi_cmp_mpi( &Q.Y, &prv->Q.Y ) ||
 c04d602:	4639      	mov	r1, r7
 c04d604:	a806      	add	r0, sp, #24
 c04d606:	f006 f919 	bl	c05383c <mbedtls_mpi_cmp_mpi>
    if( mbedtls_mpi_cmp_mpi( &Q.X, &prv->Q.X ) ||
 c04d60a:	b928      	cbnz	r0, c04d618 <mbedtls_ecp_check_pub_priv+0xa0>
        mbedtls_mpi_cmp_mpi( &Q.Z, &prv->Q.Z ) )
 c04d60c:	4631      	mov	r1, r6
 c04d60e:	a809      	add	r0, sp, #36	@ 0x24
 c04d610:	f006 f914 	bl	c05383c <mbedtls_mpi_cmp_mpi>
        mbedtls_mpi_cmp_mpi( &Q.Y, &prv->Q.Y ) ||
 c04d614:	4604      	mov	r4, r0
 c04d616:	b100      	cbz	r0, c04d61a <mbedtls_ecp_check_pub_priv+0xa2>
        ret = MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
 c04d618:	4c03      	ldr	r4, [pc, #12]	@ (c04d628 <mbedtls_ecp_check_pub_priv+0xb0>)
    if( pt == NULL )
 c04d61a:	a803      	add	r0, sp, #12
 c04d61c:	f7ff f8c1 	bl	c04c7a2 <mbedtls_ecp_point_free.part.0>
    mbedtls_ecp_group_free( &grp );
 c04d620:	a80c      	add	r0, sp, #48	@ 0x30
 c04d622:	f7ff f92c 	bl	c04c87e <mbedtls_ecp_group_free>
    return( ret );
 c04d626:	e7af      	b.n	c04d588 <mbedtls_ecp_check_pub_priv+0x10>
 c04d628:	ffffb080 	.word	0xffffb080

0c04d62c <ecp_mod_p448>:
 * arithmetic using the limbs directly as we do for the NIST primes above,
 * but for 64-bit targets it should use half the number of operations if we do
 * the reduction with 224-bit limbs, since mpi_add_mpi will then use 64-bit adds.
 */
static int ecp_mod_p448( mbedtls_mpi *N )
{
 c04d62c:	b5f0      	push	{r4, r5, r6, r7, lr}
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    size_t i;
    mbedtls_mpi M, Q;
    mbedtls_mpi_uint Mp[P448_WIDTH + 1], Qp[P448_WIDTH];

    if( N->n <= P448_WIDTH )
 c04d62e:	6845      	ldr	r5, [r0, #4]
{
 c04d630:	4604      	mov	r4, r0
    if( N->n <= P448_WIDTH )
 c04d632:	2d0e      	cmp	r5, #14
{
 c04d634:	b0a5      	sub	sp, #148	@ 0x94
    if( N->n <= P448_WIDTH )
 c04d636:	d95f      	bls.n	c04d6f8 <ecp_mod_p448+0xcc>
        return( 0 );

    /* M = A1 */
    M.s = 1;
 c04d638:	2301      	movs	r3, #1
    M.n = N->n - ( P448_WIDTH );
 c04d63a:	3d0e      	subs	r5, #14
    if( M.n > P448_WIDTH )
 c04d63c:	2d0e      	cmp	r5, #14
    M.s = 1;
 c04d63e:	9301      	str	r3, [sp, #4]
    M.n = N->n - ( P448_WIDTH );
 c04d640:	9502      	str	r5, [sp, #8]
    if( M.n > P448_WIDTH )
 c04d642:	d85b      	bhi.n	c04d6fc <ecp_mod_p448+0xd0>
        /* Shouldn't be called with N larger than 2^896! */
        return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );
    M.p = Mp;
 c04d644:	ae15      	add	r6, sp, #84	@ 0x54
    memset( Mp, 0, sizeof( Mp ) );
 c04d646:	223c      	movs	r2, #60	@ 0x3c
 c04d648:	2100      	movs	r1, #0
 c04d64a:	4630      	mov	r0, r6
    M.p = Mp;
 c04d64c:	9603      	str	r6, [sp, #12]
    memset( Mp, 0, sizeof( Mp ) );
 c04d64e:	f00e f86e 	bl	c05b72e <memset>
    memcpy( Mp, N->p + P448_WIDTH, M.n * sizeof( mbedtls_mpi_uint ) );
 c04d652:	68a7      	ldr	r7, [r4, #8]
 c04d654:	00ad      	lsls	r5, r5, #2
 c04d656:	3738      	adds	r7, #56	@ 0x38
 c04d658:	462a      	mov	r2, r5
 c04d65a:	4639      	mov	r1, r7
 c04d65c:	4630      	mov	r0, r6
 c04d65e:	f00d fff5 	bl	c05b64c <memcpy>

    /* N = A0 */
    for( i = P448_WIDTH; i < N->n; i++ )
        N->p[i] = 0;
 c04d662:	462a      	mov	r2, r5
 c04d664:	2100      	movs	r1, #0
 c04d666:	4638      	mov	r0, r7

    /* N += A1 */
    MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( N, N, &M ) );
 c04d668:	ad01      	add	r5, sp, #4
        N->p[i] = 0;
 c04d66a:	f00e f860 	bl	c05b72e <memset>
    MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( N, N, &M ) );
 c04d66e:	462a      	mov	r2, r5
 c04d670:	4621      	mov	r1, r4
 c04d672:	4620      	mov	r0, r4
 c04d674:	f006 fa01 	bl	c053a7a <mbedtls_mpi_add_mpi>
 c04d678:	2800      	cmp	r0, #0
 c04d67a:	d13b      	bne.n	c04d6f4 <ecp_mod_p448+0xc8>

    /* Q = B1, N += B1 */
    Q = M;
 c04d67c:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
    Q.p = Qp;
 c04d680:	ab07      	add	r3, sp, #28
    memcpy( Qp, Mp, sizeof( Qp ) );
 c04d682:	469c      	mov	ip, r3
    Q = M;
 c04d684:	af04      	add	r7, sp, #16
 c04d686:	e887 0007 	stmia.w	r7, {r0, r1, r2}
    Q.p = Qp;
 c04d68a:	9306      	str	r3, [sp, #24]
    memcpy( Qp, Mp, sizeof( Qp ) );
 c04d68c:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 c04d68e:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
 c04d692:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 c04d694:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
 c04d698:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 c04d69a:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
 c04d69e:	e896 0003 	ldmia.w	r6, {r0, r1}
 c04d6a2:	e88c 0003 	stmia.w	ip, {r0, r1}
    MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &Q, 224 ) );
 c04d6a6:	21e0      	movs	r1, #224	@ 0xe0
 c04d6a8:	4638      	mov	r0, r7
 c04d6aa:	f006 f85a 	bl	c053762 <mbedtls_mpi_shift_r>
 c04d6ae:	bb08      	cbnz	r0, c04d6f4 <ecp_mod_p448+0xc8>
    MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( N, N, &Q ) );
 c04d6b0:	463a      	mov	r2, r7
 c04d6b2:	4621      	mov	r1, r4
 c04d6b4:	4620      	mov	r0, r4
 c04d6b6:	f006 f9e0 	bl	c053a7a <mbedtls_mpi_add_mpi>
 c04d6ba:	b9d8      	cbnz	r0, c04d6f4 <ecp_mod_p448+0xc8>

    /* M = (B0 + B1) * 2^224, N += M */
    if( sizeof( mbedtls_mpi_uint ) > 4 )
        Mp[P224_WIDTH_MIN] &= ( (mbedtls_mpi_uint)-1 ) >> ( P224_UNUSED_BITS );
    for( i = P224_WIDTH_MAX; i < M.n; ++i )
        Mp[i] = 0;
 c04d6bc:	9a02      	ldr	r2, [sp, #8]
 c04d6be:	4601      	mov	r1, r0
 c04d6c0:	2a07      	cmp	r2, #7
 c04d6c2:	bf38      	it	cc
 c04d6c4:	2207      	movcc	r2, #7
 c04d6c6:	3a07      	subs	r2, #7
 c04d6c8:	0092      	lsls	r2, r2, #2
 c04d6ca:	a81c      	add	r0, sp, #112	@ 0x70
 c04d6cc:	f00e f82f 	bl	c05b72e <memset>
    MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &M, &M, &Q ) );
 c04d6d0:	463a      	mov	r2, r7
 c04d6d2:	4629      	mov	r1, r5
 c04d6d4:	4628      	mov	r0, r5
 c04d6d6:	f006 f9d0 	bl	c053a7a <mbedtls_mpi_add_mpi>
 c04d6da:	b958      	cbnz	r0, c04d6f4 <ecp_mod_p448+0xc8>
    M.n = P448_WIDTH + 1; /* Make room for shifted carry bit from the addition */
 c04d6dc:	230f      	movs	r3, #15
    MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &M, 224 ) );
 c04d6de:	21e0      	movs	r1, #224	@ 0xe0
 c04d6e0:	4628      	mov	r0, r5
    M.n = P448_WIDTH + 1; /* Make room for shifted carry bit from the addition */
 c04d6e2:	9302      	str	r3, [sp, #8]
    MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &M, 224 ) );
 c04d6e4:	f005 ffed 	bl	c0536c2 <mbedtls_mpi_shift_l>
 c04d6e8:	b920      	cbnz	r0, c04d6f4 <ecp_mod_p448+0xc8>
    MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( N, N, &M ) );
 c04d6ea:	462a      	mov	r2, r5
 c04d6ec:	4621      	mov	r1, r4
 c04d6ee:	4620      	mov	r0, r4
 c04d6f0:	f006 f9c3 	bl	c053a7a <mbedtls_mpi_add_mpi>

cleanup:
    return( ret );
}
 c04d6f4:	b025      	add	sp, #148	@ 0x94
 c04d6f6:	bdf0      	pop	{r4, r5, r6, r7, pc}
        return( 0 );
 c04d6f8:	2000      	movs	r0, #0
 c04d6fa:	e7fb      	b.n	c04d6f4 <ecp_mod_p448+0xc8>
        return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );
 c04d6fc:	4800      	ldr	r0, [pc, #0]	@ (c04d700 <ecp_mod_p448+0xd4>)
 c04d6fe:	e7f9      	b.n	c04d6f4 <ecp_mod_p448+0xc8>
 c04d700:	ffffb080 	.word	0xffffb080

0c04d704 <ecp_mod_p255>:
{
 c04d704:	b530      	push	{r4, r5, lr}
    if( N->n < P255_WIDTH )
 c04d706:	6845      	ldr	r5, [r0, #4]
{
 c04d708:	4604      	mov	r4, r0
    if( N->n < P255_WIDTH )
 c04d70a:	2d07      	cmp	r5, #7
{
 c04d70c:	b08f      	sub	sp, #60	@ 0x3c
    if( N->n < P255_WIDTH )
 c04d70e:	d935      	bls.n	c04d77c <ecp_mod_p255+0x78>
    M.s = 1;
 c04d710:	2301      	movs	r3, #1
    M.n = N->n - ( P255_WIDTH - 1 );
 c04d712:	3d07      	subs	r5, #7
    if( M.n > P255_WIDTH + 1 )
 c04d714:	2d09      	cmp	r5, #9
    M.s = 1;
 c04d716:	9301      	str	r3, [sp, #4]
    M.n = N->n - ( P255_WIDTH - 1 );
 c04d718:	9502      	str	r5, [sp, #8]
    if( M.n > P255_WIDTH + 1 )
 c04d71a:	d831      	bhi.n	c04d780 <ecp_mod_p255+0x7c>
    M.p = Mp;
 c04d71c:	ab04      	add	r3, sp, #16
    memset( Mp, 0, sizeof Mp );
 c04d71e:	2228      	movs	r2, #40	@ 0x28
 c04d720:	2100      	movs	r1, #0
 c04d722:	4618      	mov	r0, r3
    M.p = Mp;
 c04d724:	9303      	str	r3, [sp, #12]
    memset( Mp, 0, sizeof Mp );
 c04d726:	f00e f802 	bl	c05b72e <memset>
    memcpy( Mp, N->p + P255_WIDTH - 1, M.n * sizeof( mbedtls_mpi_uint ) );
 c04d72a:	68a1      	ldr	r1, [r4, #8]
 c04d72c:	00aa      	lsls	r2, r5, #2
 c04d72e:	311c      	adds	r1, #28
 c04d730:	f00d ff8c 	bl	c05b64c <memcpy>
    MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &M, 255 % ( 8 * sizeof( mbedtls_mpi_uint ) ) ) );
 c04d734:	211f      	movs	r1, #31
 c04d736:	a801      	add	r0, sp, #4
 c04d738:	f006 f813 	bl	c053762 <mbedtls_mpi_shift_r>
 c04d73c:	b9b8      	cbnz	r0, c04d76e <ecp_mod_p255+0x6a>
    M.n++; /* Make room for multiplication by 19 */
 c04d73e:	9b02      	ldr	r3, [sp, #8]
    MBEDTLS_MPI_CHK( mbedtls_mpi_set_bit( N, 255, 0 ) );
 c04d740:	4602      	mov	r2, r0
    M.n++; /* Make room for multiplication by 19 */
 c04d742:	3301      	adds	r3, #1
    MBEDTLS_MPI_CHK( mbedtls_mpi_set_bit( N, 255, 0 ) );
 c04d744:	21ff      	movs	r1, #255	@ 0xff
 c04d746:	4620      	mov	r0, r4
    M.n++; /* Make room for multiplication by 19 */
 c04d748:	9302      	str	r3, [sp, #8]
    MBEDTLS_MPI_CHK( mbedtls_mpi_set_bit( N, 255, 0 ) );
 c04d74a:	f005 fea4 	bl	c053496 <mbedtls_mpi_set_bit>
 c04d74e:	b970      	cbnz	r0, c04d76e <ecp_mod_p255+0x6a>
    for( i = P255_WIDTH; i < N->n; i++ )
 c04d750:	2308      	movs	r3, #8
 c04d752:	6862      	ldr	r2, [r4, #4]
 c04d754:	429a      	cmp	r2, r3
 c04d756:	d80c      	bhi.n	c04d772 <ecp_mod_p255+0x6e>
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_int( &M, &M, 19 ) );
 c04d758:	a901      	add	r1, sp, #4
 c04d75a:	2213      	movs	r2, #19
 c04d75c:	4608      	mov	r0, r1
 c04d75e:	f006 fa6c 	bl	c053c3a <mbedtls_mpi_mul_int>
 c04d762:	b920      	cbnz	r0, c04d76e <ecp_mod_p255+0x6a>
    MBEDTLS_MPI_CHK( mbedtls_mpi_add_abs( N, N, &M ) );
 c04d764:	4621      	mov	r1, r4
 c04d766:	4620      	mov	r0, r4
 c04d768:	aa01      	add	r2, sp, #4
 c04d76a:	f006 f8c0 	bl	c0538ee <mbedtls_mpi_add_abs>
}
 c04d76e:	b00f      	add	sp, #60	@ 0x3c
 c04d770:	bd30      	pop	{r4, r5, pc}
        N->p[i] = 0;
 c04d772:	68a1      	ldr	r1, [r4, #8]
 c04d774:	f841 0023 	str.w	r0, [r1, r3, lsl #2]
    for( i = P255_WIDTH; i < N->n; i++ )
 c04d778:	3301      	adds	r3, #1
 c04d77a:	e7eb      	b.n	c04d754 <ecp_mod_p255+0x50>
        return( 0 );
 c04d77c:	2000      	movs	r0, #0
 c04d77e:	e7f6      	b.n	c04d76e <ecp_mod_p255+0x6a>
        return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );
 c04d780:	4800      	ldr	r0, [pc, #0]	@ (c04d784 <ecp_mod_p255+0x80>)
 c04d782:	e7f4      	b.n	c04d76e <ecp_mod_p255+0x6a>
 c04d784:	ffffb080 	.word	0xffffb080

0c04d788 <ecp_group_load>:
{
 c04d788:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 c04d78a:	4604      	mov	r4, r0
    ecp_mpi_load( &grp->P, p, plen );
 c04d78c:	1d07      	adds	r7, r0, #4
    X->s = 1;
 c04d78e:	2001      	movs	r0, #1
    X->n = len / sizeof( mbedtls_mpi_uint );
 c04d790:	0892      	lsrs	r2, r2, #2
    X->p = (mbedtls_mpi_uint *) p;
 c04d792:	e9c4 2102 	strd	r2, r1, [r4, #8]
    X->s = 1;
 c04d796:	6060      	str	r0, [r4, #4]
    if( a != NULL )
 c04d798:	b123      	cbz	r3, c04d7a4 <ecp_group_load+0x1c>
    X->n = len / sizeof( mbedtls_mpi_uint );
 c04d79a:	9a06      	ldr	r2, [sp, #24]
    X->s = 1;
 c04d79c:	6120      	str	r0, [r4, #16]
    X->n = len / sizeof( mbedtls_mpi_uint );
 c04d79e:	0892      	lsrs	r2, r2, #2
    X->p = (mbedtls_mpi_uint *) p;
 c04d7a0:	e9c4 2305 	strd	r2, r3, [r4, #20]
    X->s = 1;
 c04d7a4:	2501      	movs	r5, #1
    X->n = len / sizeof( mbedtls_mpi_uint );
 c04d7a6:	9b08      	ldr	r3, [sp, #32]
    grp->pbits = mbedtls_mpi_bitlen( &grp->P );
 c04d7a8:	4638      	mov	r0, r7
    X->n = len / sizeof( mbedtls_mpi_uint );
 c04d7aa:	089b      	lsrs	r3, r3, #2
 c04d7ac:	6223      	str	r3, [r4, #32]
    X->p = (mbedtls_mpi_uint *) p;
 c04d7ae:	9b07      	ldr	r3, [sp, #28]
    X->s = 1;
 c04d7b0:	61e5      	str	r5, [r4, #28]
    X->p = (mbedtls_mpi_uint *) p;
 c04d7b2:	6263      	str	r3, [r4, #36]	@ 0x24
    X->n = len / sizeof( mbedtls_mpi_uint );
 c04d7b4:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
    X->s = 1;
 c04d7b6:	64e5      	str	r5, [r4, #76]	@ 0x4c
    X->n = len / sizeof( mbedtls_mpi_uint );
 c04d7b8:	089b      	lsrs	r3, r3, #2
 c04d7ba:	6523      	str	r3, [r4, #80]	@ 0x50
    X->p = (mbedtls_mpi_uint *) p;
 c04d7bc:	9b0d      	ldr	r3, [sp, #52]	@ 0x34
    X->s = 1;
 c04d7be:	62a5      	str	r5, [r4, #40]	@ 0x28
    X->p = (mbedtls_mpi_uint *) p;
 c04d7c0:	6563      	str	r3, [r4, #84]	@ 0x54
    X->n = len / sizeof( mbedtls_mpi_uint );
 c04d7c2:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
    X->n = 1;
 c04d7c4:	6465      	str	r5, [r4, #68]	@ 0x44
    X->n = len / sizeof( mbedtls_mpi_uint );
 c04d7c6:	089b      	lsrs	r3, r3, #2
 c04d7c8:	62e3      	str	r3, [r4, #44]	@ 0x2c
    X->p = (mbedtls_mpi_uint *) p;
 c04d7ca:	9b09      	ldr	r3, [sp, #36]	@ 0x24
    ecp_mpi_load( &grp->N, n, nlen );
 c04d7cc:	f104 064c 	add.w	r6, r4, #76	@ 0x4c
    X->s = 1;
 c04d7d0:	e9c4 350c 	strd	r3, r5, [r4, #48]	@ 0x30
    X->n = len / sizeof( mbedtls_mpi_uint );
 c04d7d4:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
 c04d7d6:	089b      	lsrs	r3, r3, #2
 c04d7d8:	63a3      	str	r3, [r4, #56]	@ 0x38
    X->p = (mbedtls_mpi_uint *) p;
 c04d7da:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
    X->s = 1;
 c04d7dc:	e9c4 350f 	strd	r3, r5, [r4, #60]	@ 0x3c
    X->p = one;
 c04d7e0:	4b3d      	ldr	r3, [pc, #244]	@ (c04d8d8 <ecp_group_load+0x150>)
 c04d7e2:	64a3      	str	r3, [r4, #72]	@ 0x48
    grp->pbits = mbedtls_mpi_bitlen( &grp->P );
 c04d7e4:	f005 fe9b 	bl	c05351e <mbedtls_mpi_bitlen>
 c04d7e8:	65a0      	str	r0, [r4, #88]	@ 0x58
    grp->nbits = mbedtls_mpi_bitlen( &grp->N );
 c04d7ea:	4630      	mov	r0, r6
 c04d7ec:	f005 fe97 	bl	c05351e <mbedtls_mpi_bitlen>
    grp->h = 1;
 c04d7f0:	e9c4 0517 	strd	r0, r5, [r4, #92]	@ 0x5c
    grp->st_modulus_size = mbedtls_mpi_size( &grp->P );
 c04d7f4:	4638      	mov	r0, r7
 c04d7f6:	f005 feb0 	bl	c05355a <mbedtls_mpi_size>
 c04d7fa:	67e0      	str	r0, [r4, #124]	@ 0x7c
    grp->st_order_size = mbedtls_mpi_size( &grp->N );
 c04d7fc:	4630      	mov	r0, r6
 c04d7fe:	f005 feac 	bl	c05355a <mbedtls_mpi_size>
    grp->st_p = mbedtls_calloc(grp->st_modulus_size, sizeof( uint8_t ));
 c04d802:	4629      	mov	r1, r5
    grp->st_order_size = mbedtls_mpi_size( &grp->N );
 c04d804:	f8c4 0080 	str.w	r0, [r4, #128]	@ 0x80
    grp->st_p = mbedtls_calloc(grp->st_modulus_size, sizeof( uint8_t ));
 c04d808:	6fe0      	ldr	r0, [r4, #124]	@ 0x7c
 c04d80a:	f7ed fdcb 	bl	c03b3a4 <mbedtls_calloc>
 c04d80e:	4601      	mov	r1, r0
 c04d810:	f8c4 0084 	str.w	r0, [r4, #132]	@ 0x84
    MBEDTLS_MPI_CHK((grp->st_p == NULL) ? MBEDTLS_ERR_ECP_ALLOC_FAILED : 0);
 c04d814:	2800      	cmp	r0, #0
 c04d816:	d059      	beq.n	c04d8cc <ecp_group_load+0x144>
    mbedtls_mpi_write_binary(&grp->P, grp->st_p, grp->st_modulus_size);
 c04d818:	6fe2      	ldr	r2, [r4, #124]	@ 0x7c
 c04d81a:	4638      	mov	r0, r7
 c04d81c:	f005 ff1c 	bl	c053658 <mbedtls_mpi_write_binary>
    grp->st_a_abs = mbedtls_calloc(grp->st_modulus_size, sizeof( uint8_t ));
 c04d820:	4629      	mov	r1, r5
 c04d822:	6fe0      	ldr	r0, [r4, #124]	@ 0x7c
 c04d824:	f7ed fdbe 	bl	c03b3a4 <mbedtls_calloc>
 c04d828:	4601      	mov	r1, r0
 c04d82a:	f8c4 008c 	str.w	r0, [r4, #140]	@ 0x8c
    MBEDTLS_MPI_CHK((grp->st_a_abs == NULL) ? MBEDTLS_ERR_ECP_ALLOC_FAILED : 0);
 c04d82e:	2800      	cmp	r0, #0
 c04d830:	d04c      	beq.n	c04d8cc <ecp_group_load+0x144>
    if (grp->A.p == NULL)
 c04d832:	69a3      	ldr	r3, [r4, #24]
        mbedtls_platform_zeroize(grp->st_a_abs, grp->st_modulus_size);
 c04d834:	6fe2      	ldr	r2, [r4, #124]	@ 0x7c
    if (grp->A.p == NULL)
 c04d836:	2b00      	cmp	r3, #0
 c04d838:	d142      	bne.n	c04d8c0 <ecp_group_load+0x138>
        mbedtls_platform_zeroize(grp->st_a_abs, grp->st_modulus_size);
 c04d83a:	4611      	mov	r1, r2
 c04d83c:	f7ed fdc8 	bl	c03b3d0 <mbedtls_platform_zeroize>
        grp->st_a_abs[grp->st_modulus_size - 1] = 3U;
 c04d840:	6fe2      	ldr	r2, [r4, #124]	@ 0x7c
 c04d842:	f8d4 308c 	ldr.w	r3, [r4, #140]	@ 0x8c
 c04d846:	4413      	add	r3, r2
 c04d848:	2203      	movs	r2, #3
 c04d84a:	f803 2c01 	strb.w	r2, [r3, #-1]
    grp->st_b = mbedtls_calloc(grp->st_modulus_size, sizeof( uint8_t ));
 c04d84e:	2101      	movs	r1, #1
 c04d850:	6fe0      	ldr	r0, [r4, #124]	@ 0x7c
        grp->st_a_sign = 1U;
 c04d852:	f8c4 5088 	str.w	r5, [r4, #136]	@ 0x88
    grp->st_b = mbedtls_calloc(grp->st_modulus_size, sizeof( uint8_t ));
 c04d856:	f7ed fda5 	bl	c03b3a4 <mbedtls_calloc>
 c04d85a:	4601      	mov	r1, r0
 c04d85c:	f8c4 0090 	str.w	r0, [r4, #144]	@ 0x90
    MBEDTLS_MPI_CHK((grp->st_b == NULL) ? MBEDTLS_ERR_ECP_ALLOC_FAILED : 0);
 c04d860:	b3a0      	cbz	r0, c04d8cc <ecp_group_load+0x144>
    mbedtls_mpi_write_binary(&grp->B, grp->st_b, grp->st_modulus_size);
 c04d862:	6fe2      	ldr	r2, [r4, #124]	@ 0x7c
 c04d864:	f104 001c 	add.w	r0, r4, #28
 c04d868:	f005 fef6 	bl	c053658 <mbedtls_mpi_write_binary>
    grp->st_gx = mbedtls_calloc(grp->st_modulus_size, sizeof( uint8_t ));
 c04d86c:	2101      	movs	r1, #1
 c04d86e:	6fe0      	ldr	r0, [r4, #124]	@ 0x7c
 c04d870:	f7ed fd98 	bl	c03b3a4 <mbedtls_calloc>
 c04d874:	4601      	mov	r1, r0
 c04d876:	f8c4 0094 	str.w	r0, [r4, #148]	@ 0x94
    MBEDTLS_MPI_CHK((grp->st_gx == NULL) ? MBEDTLS_ERR_ECP_ALLOC_FAILED : 0);
 c04d87a:	b338      	cbz	r0, c04d8cc <ecp_group_load+0x144>
    mbedtls_mpi_write_binary(&grp->G.X, grp->st_gx, grp->st_modulus_size);
 c04d87c:	6fe2      	ldr	r2, [r4, #124]	@ 0x7c
 c04d87e:	f104 0028 	add.w	r0, r4, #40	@ 0x28
 c04d882:	f005 fee9 	bl	c053658 <mbedtls_mpi_write_binary>
    grp->st_gy = mbedtls_calloc(grp->st_modulus_size, sizeof( uint8_t ));
 c04d886:	2101      	movs	r1, #1
 c04d888:	6fe0      	ldr	r0, [r4, #124]	@ 0x7c
 c04d88a:	f7ed fd8b 	bl	c03b3a4 <mbedtls_calloc>
 c04d88e:	4601      	mov	r1, r0
 c04d890:	f8c4 0098 	str.w	r0, [r4, #152]	@ 0x98
    MBEDTLS_MPI_CHK((grp->st_gy == NULL) ? MBEDTLS_ERR_ECP_ALLOC_FAILED : 0);
 c04d894:	b1d0      	cbz	r0, c04d8cc <ecp_group_load+0x144>
    mbedtls_mpi_write_binary(&grp->G.Y, grp->st_gy, grp->st_modulus_size);
 c04d896:	6fe2      	ldr	r2, [r4, #124]	@ 0x7c
 c04d898:	f104 0034 	add.w	r0, r4, #52	@ 0x34
 c04d89c:	f005 fedc 	bl	c053658 <mbedtls_mpi_write_binary>
    grp->st_n = mbedtls_calloc(grp->st_order_size, sizeof( uint8_t ));
 c04d8a0:	2101      	movs	r1, #1
 c04d8a2:	f8d4 0080 	ldr.w	r0, [r4, #128]	@ 0x80
 c04d8a6:	f7ed fd7d 	bl	c03b3a4 <mbedtls_calloc>
 c04d8aa:	4601      	mov	r1, r0
 c04d8ac:	f8c4 009c 	str.w	r0, [r4, #156]	@ 0x9c
    MBEDTLS_MPI_CHK((grp->st_n == NULL) ? MBEDTLS_ERR_ECP_ALLOC_FAILED : 0);
 c04d8b0:	b160      	cbz	r0, c04d8cc <ecp_group_load+0x144>
    mbedtls_mpi_write_binary(&grp->N, grp->st_n, grp->st_order_size);
 c04d8b2:	4630      	mov	r0, r6
 c04d8b4:	f8d4 2080 	ldr.w	r2, [r4, #128]	@ 0x80
 c04d8b8:	f005 fece 	bl	c053658 <mbedtls_mpi_write_binary>
 c04d8bc:	2000      	movs	r0, #0
}
 c04d8be:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        mbedtls_mpi_write_binary(&grp->A, grp->st_a_abs, grp->st_modulus_size);
 c04d8c0:	f104 0010 	add.w	r0, r4, #16
 c04d8c4:	f005 fec8 	bl	c053658 <mbedtls_mpi_write_binary>
 c04d8c8:	2500      	movs	r5, #0
 c04d8ca:	e7c0      	b.n	c04d84e <ecp_group_load+0xc6>
        mbedtls_ecp_group_free( grp );
 c04d8cc:	4620      	mov	r0, r4
 c04d8ce:	f7fe ffd6 	bl	c04c87e <mbedtls_ecp_group_free>
 c04d8d2:	4802      	ldr	r0, [pc, #8]	@ (c04d8dc <ecp_group_load+0x154>)
    return( ret );
 c04d8d4:	e7f3      	b.n	c04d8be <ecp_group_load+0x136>
 c04d8d6:	bf00      	nop
 c04d8d8:	30030800 	.word	0x30030800
 c04d8dc:	ffffb280 	.word	0xffffb280

0c04d8e0 <ecp_mod_koblitz.constprop.0>:
 * Write N as A0 + 2^224 A1, return A0 + R * A1.
 * Actually do two passes, since R is big.
 */
#define P_KOBLITZ_MAX   ( 256 / 8 / sizeof( mbedtls_mpi_uint ) )  // Max limbs in P
#define P_KOBLITZ_R     ( 8 / sizeof( mbedtls_mpi_uint ) )        // Limbs in R
static inline int ecp_mod_koblitz( mbedtls_mpi *N, mbedtls_mpi_uint *Rp, size_t p_limbs,
 c04d8e0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    size_t i;
    mbedtls_mpi M, R;
    mbedtls_mpi_uint Mp[P_KOBLITZ_MAX + P_KOBLITZ_R + 1];

    if( N->n < p_limbs )
 c04d8e4:	6844      	ldr	r4, [r0, #4]
static inline int ecp_mod_koblitz( mbedtls_mpi *N, mbedtls_mpi_uint *Rp, size_t p_limbs,
 c04d8e6:	4606      	mov	r6, r0
    if( N->n < p_limbs )
 c04d8e8:	4294      	cmp	r4, r2
static inline int ecp_mod_koblitz( mbedtls_mpi *N, mbedtls_mpi_uint *Rp, size_t p_limbs,
 c04d8ea:	4615      	mov	r5, r2
 c04d8ec:	b093      	sub	sp, #76	@ 0x4c
    if( N->n < p_limbs )
 c04d8ee:	d36a      	bcc.n	c04d9c6 <ecp_mod_koblitz.constprop.0+0xe6>
        return( 0 );

    /* Init R */
    R.s = 1;
 c04d8f0:	1b64      	subs	r4, r4, r5
 c04d8f2:	42a5      	cmp	r5, r4
    R.p = Rp;
    R.n = P_KOBLITZ_R;
 c04d8f4:	f04f 0202 	mov.w	r2, #2
    R.s = 1;
 c04d8f8:	f04f 0301 	mov.w	r3, #1
 c04d8fc:	46a8      	mov	r8, r5
 c04d8fe:	bf28      	it	cs
 c04d900:	46a0      	movcs	r8, r4

    /* Common setup for M */
    M.s = 1;
    M.p = Mp;
 c04d902:	af07      	add	r7, sp, #28
    R.p = Rp;
 c04d904:	9106      	str	r1, [sp, #24]
    R.n = P_KOBLITZ_R;
 c04d906:	9205      	str	r2, [sp, #20]

    /* M = A1 */
    M.n = N->n - ( p_limbs - adjust );
    if( M.n > p_limbs + adjust )
        M.n = p_limbs + adjust;
    memset( Mp, 0, sizeof Mp );
 c04d908:	2100      	movs	r1, #0
 c04d90a:	222c      	movs	r2, #44	@ 0x2c
 c04d90c:	4638      	mov	r0, r7
    R.s = 1;
 c04d90e:	9304      	str	r3, [sp, #16]
    M.s = 1;
 c04d910:	9301      	str	r3, [sp, #4]
    M.p = Mp;
 c04d912:	9703      	str	r7, [sp, #12]
    if( M.n > p_limbs + adjust )
 c04d914:	f8cd 8008 	str.w	r8, [sp, #8]
    memset( Mp, 0, sizeof Mp );
 c04d918:	f00d ff09 	bl	c05b72e <memset>
    memcpy( Mp, N->p + p_limbs - adjust, M.n * sizeof( mbedtls_mpi_uint ) );
 c04d91c:	68b3      	ldr	r3, [r6, #8]
 c04d91e:	ea4f 0288 	mov.w	r2, r8, lsl #2
 c04d922:	eb03 0a85 	add.w	sl, r3, r5, lsl #2
 c04d926:	4651      	mov	r1, sl
 c04d928:	4638      	mov	r0, r7
 c04d92a:	f00d fe8f 	bl	c05b64c <memcpy>
    if( shift != 0 )
        MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &M, shift ) );
    M.n += R.n; /* Make room for multiplication by R */
 c04d92e:	f108 0302 	add.w	r3, r8, #2

    /* N = A0 */
    if( mask != 0 )
        N->p[p_limbs - 1] &= mask;
    for( i = p_limbs; i < N->n; i++ )
        N->p[i] = 0;
 c04d932:	00a2      	lsls	r2, r4, #2
 c04d934:	2100      	movs	r1, #0
 c04d936:	4650      	mov	r0, sl
    M.n += R.n; /* Make room for multiplication by R */
 c04d938:	9302      	str	r3, [sp, #8]
        N->p[i] = 0;
 c04d93a:	f00d fef8 	bl	c05b72e <memset>

    /* N = A0 + R * A1 */
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &M, &M, &R ) );
 c04d93e:	a901      	add	r1, sp, #4
 c04d940:	4608      	mov	r0, r1
 c04d942:	aa04      	add	r2, sp, #16
 c04d944:	f006 f90c 	bl	c053b60 <mbedtls_mpi_mul_mpi>
    memcpy( Mp, N->p + p_limbs - adjust, M.n * sizeof( mbedtls_mpi_uint ) );
 c04d948:	ea4f 0985 	mov.w	r9, r5, lsl #2
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &M, &M, &R ) );
 c04d94c:	4604      	mov	r4, r0
 c04d94e:	bbb0      	cbnz	r0, c04d9be <ecp_mod_koblitz.constprop.0+0xde>
    MBEDTLS_MPI_CHK( mbedtls_mpi_add_abs( N, N, &M ) );
 c04d950:	4631      	mov	r1, r6
 c04d952:	4630      	mov	r0, r6
 c04d954:	aa01      	add	r2, sp, #4
 c04d956:	f005 ffca 	bl	c0538ee <mbedtls_mpi_add_abs>
 c04d95a:	4604      	mov	r4, r0
 c04d95c:	bb78      	cbnz	r0, c04d9be <ecp_mod_koblitz.constprop.0+0xde>

    /* Second pass */

    /* M = A1 */
    M.n = N->n - ( p_limbs - adjust );
 c04d95e:	f8d6 b004 	ldr.w	fp, [r6, #4]
 c04d962:	46a8      	mov	r8, r5
 c04d964:	ebab 0a05 	sub.w	sl, fp, r5
    if( M.n > p_limbs + adjust )
 c04d968:	4555      	cmp	r5, sl
 c04d96a:	bf28      	it	cs
 c04d96c:	46d0      	movcs	r8, sl
        M.n = p_limbs + adjust;
    memset( Mp, 0, sizeof Mp );
 c04d96e:	4601      	mov	r1, r0
 c04d970:	222c      	movs	r2, #44	@ 0x2c
 c04d972:	4638      	mov	r0, r7
 c04d974:	f8cd 8008 	str.w	r8, [sp, #8]
 c04d978:	f00d fed9 	bl	c05b72e <memset>
    memcpy( Mp, N->p + p_limbs - adjust, M.n * sizeof( mbedtls_mpi_uint ) );
 c04d97c:	68b2      	ldr	r2, [r6, #8]
 c04d97e:	4638      	mov	r0, r7
 c04d980:	4491      	add	r9, r2
 c04d982:	4649      	mov	r1, r9
 c04d984:	ea4f 0288 	mov.w	r2, r8, lsl #2
 c04d988:	f00d fe60 	bl	c05b64c <memcpy>
    if( shift != 0 )
        MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &M, shift ) );
    M.n += R.n; /* Make room for multiplication by R */
 c04d98c:	9a05      	ldr	r2, [sp, #20]

    /* N = A0 */
    if( mask != 0 )
        N->p[p_limbs - 1] &= mask;
    for( i = p_limbs; i < N->n; i++ )
        N->p[i] = 0;
 c04d98e:	4621      	mov	r1, r4
    M.n += R.n; /* Make room for multiplication by R */
 c04d990:	4442      	add	r2, r8
 c04d992:	9202      	str	r2, [sp, #8]
        N->p[i] = 0;
 c04d994:	ea4f 028a 	mov.w	r2, sl, lsl #2
 c04d998:	455d      	cmp	r5, fp
 c04d99a:	bf88      	it	hi
 c04d99c:	2200      	movhi	r2, #0
 c04d99e:	4648      	mov	r0, r9
 c04d9a0:	f00d fec5 	bl	c05b72e <memset>

    /* N = A0 + R * A1 */
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &M, &M, &R ) );
 c04d9a4:	a901      	add	r1, sp, #4
 c04d9a6:	4608      	mov	r0, r1
 c04d9a8:	aa04      	add	r2, sp, #16
 c04d9aa:	f006 f8d9 	bl	c053b60 <mbedtls_mpi_mul_mpi>
 c04d9ae:	4604      	mov	r4, r0
 c04d9b0:	b928      	cbnz	r0, c04d9be <ecp_mod_koblitz.constprop.0+0xde>
    MBEDTLS_MPI_CHK( mbedtls_mpi_add_abs( N, N, &M ) );
 c04d9b2:	4631      	mov	r1, r6
 c04d9b4:	4630      	mov	r0, r6
 c04d9b6:	aa01      	add	r2, sp, #4
 c04d9b8:	f005 ff99 	bl	c0538ee <mbedtls_mpi_add_abs>
 c04d9bc:	4604      	mov	r4, r0

cleanup:
    return( ret );
}
 c04d9be:	4620      	mov	r0, r4
 c04d9c0:	b013      	add	sp, #76	@ 0x4c
 c04d9c2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        return( 0 );
 c04d9c6:	2400      	movs	r4, #0
 c04d9c8:	e7f9      	b.n	c04d9be <ecp_mod_koblitz.constprop.0+0xde>
	...

0c04d9cc <ecp_mod_p192k1>:
static int ecp_mod_p192k1( mbedtls_mpi *N )
{
    static mbedtls_mpi_uint Rp[] = {
        BYTES_TO_T_UINT_8( 0xC9, 0x11, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00 ) };

    return( ecp_mod_koblitz( N, Rp, 192 / 8 / sizeof( mbedtls_mpi_uint ), 0, 0, 0 ) );
 c04d9cc:	2206      	movs	r2, #6
 c04d9ce:	4901      	ldr	r1, [pc, #4]	@ (c04d9d4 <ecp_mod_p192k1+0x8>)
 c04d9d0:	f7ff bf86 	b.w	c04d8e0 <ecp_mod_koblitz.constprop.0>
 c04d9d4:	30030804 	.word	0x30030804

0c04d9d8 <ecp_mod_p224k1>:
        BYTES_TO_T_UINT_8( 0x93, 0x1A, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00 ) };

#if defined(MBEDTLS_HAVE_INT64)
    return( ecp_mod_koblitz( N, Rp, 4, 1, 32, 0xFFFFFFFF ) );
#else
    return( ecp_mod_koblitz( N, Rp, 224 / 8 / sizeof( mbedtls_mpi_uint ), 0, 0, 0 ) );
 c04d9d8:	2207      	movs	r2, #7
 c04d9da:	4901      	ldr	r1, [pc, #4]	@ (c04d9e0 <ecp_mod_p224k1+0x8>)
 c04d9dc:	f7ff bf80 	b.w	c04d8e0 <ecp_mod_koblitz.constprop.0>
 c04d9e0:	3003080c 	.word	0x3003080c

0c04d9e4 <ecp_mod_p256k1>:
 */
static int ecp_mod_p256k1( mbedtls_mpi *N )
{
    static mbedtls_mpi_uint Rp[] = {
        BYTES_TO_T_UINT_8( 0xD1, 0x03, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00 ) };
    return( ecp_mod_koblitz( N, Rp, 256 / 8 / sizeof( mbedtls_mpi_uint ), 0, 0, 0 ) );
 c04d9e4:	2208      	movs	r2, #8
 c04d9e6:	4901      	ldr	r1, [pc, #4]	@ (c04d9ec <ecp_mod_p256k1+0x8>)
 c04d9e8:	f7ff bf7a 	b.w	c04d8e0 <ecp_mod_koblitz.constprop.0>
 c04d9ec:	30030814 	.word	0x30030814

0c04d9f0 <mbedtls_ecp_group_load>:
{
 c04d9f0:	b570      	push	{r4, r5, r6, lr}
 c04d9f2:	460c      	mov	r4, r1
 c04d9f4:	4605      	mov	r5, r0
 c04d9f6:	b08e      	sub	sp, #56	@ 0x38
    mbedtls_ecp_group_free( grp );
 c04d9f8:	f7fe ff41 	bl	c04c87e <mbedtls_ecp_group_free>
    grp->id = id;
 c04d9fc:	702c      	strb	r4, [r5, #0]
    switch( id )
 c04d9fe:	3c01      	subs	r4, #1
 c04da00:	2c0c      	cmp	r4, #12
 c04da02:	f200 8223 	bhi.w	c04de4c <mbedtls_ecp_group_load+0x45c>
 c04da06:	e8df f014 	tbh	[pc, r4, lsl #1]
 c04da0a:	000d      	.short	0x000d
 c04da0c:	00360024 	.word	0x00360024
 c04da10:	00580047 	.word	0x00580047
 c04da14:	00b700a6 	.word	0x00b700a6
 c04da18:	00d900c8 	.word	0x00d900c8
 c04da1c:	007d0069 	.word	0x007d0069
 c04da20:	01b50092 	.word	0x01b50092
            return( LOAD_GROUP( secp192r1 ) );
 c04da24:	2218      	movs	r2, #24
 c04da26:	4b90      	ldr	r3, [pc, #576]	@ (c04dc68 <mbedtls_ecp_group_load+0x278>)
 c04da28:	4990      	ldr	r1, [pc, #576]	@ (c04dc6c <mbedtls_ecp_group_load+0x27c>)
 c04da2a:	e9cd 2306 	strd	r2, r3, [sp, #24]
 c04da2e:	4b90      	ldr	r3, [pc, #576]	@ (c04dc70 <mbedtls_ecp_group_load+0x280>)
 c04da30:	9208      	str	r2, [sp, #32]
 c04da32:	e9cd 2304 	strd	r2, r3, [sp, #16]
 c04da36:	4b8f      	ldr	r3, [pc, #572]	@ (c04dc74 <mbedtls_ecp_group_load+0x284>)
 c04da38:	e9cd 2302 	strd	r2, r3, [sp, #8]
 c04da3c:	4b8e      	ldr	r3, [pc, #568]	@ (c04dc78 <mbedtls_ecp_group_load+0x288>)
 c04da3e:	9301      	str	r3, [sp, #4]
 c04da40:	2300      	movs	r3, #0
 c04da42:	9300      	str	r3, [sp, #0]
            return( LOAD_GROUP( secp224r1 ) );
 c04da44:	4628      	mov	r0, r5
 c04da46:	f7ff fe9f 	bl	c04d788 <ecp_group_load>
 c04da4a:	4604      	mov	r4, r0
}
 c04da4c:	4620      	mov	r0, r4
 c04da4e:	b00e      	add	sp, #56	@ 0x38
 c04da50:	bd70      	pop	{r4, r5, r6, pc}
            return( LOAD_GROUP( secp224r1 ) );
 c04da52:	231c      	movs	r3, #28
 c04da54:	4a89      	ldr	r2, [pc, #548]	@ (c04dc7c <mbedtls_ecp_group_load+0x28c>)
 c04da56:	9308      	str	r3, [sp, #32]
 c04da58:	e9cd 3206 	strd	r3, r2, [sp, #24]
 c04da5c:	4a88      	ldr	r2, [pc, #544]	@ (c04dc80 <mbedtls_ecp_group_load+0x290>)
 c04da5e:	4989      	ldr	r1, [pc, #548]	@ (c04dc84 <mbedtls_ecp_group_load+0x294>)
 c04da60:	e9cd 3204 	strd	r3, r2, [sp, #16]
 c04da64:	4a88      	ldr	r2, [pc, #544]	@ (c04dc88 <mbedtls_ecp_group_load+0x298>)
 c04da66:	e9cd 3202 	strd	r3, r2, [sp, #8]
 c04da6a:	4b88      	ldr	r3, [pc, #544]	@ (c04dc8c <mbedtls_ecp_group_load+0x29c>)
 c04da6c:	2220      	movs	r2, #32
 c04da6e:	9301      	str	r3, [sp, #4]
 c04da70:	2300      	movs	r3, #0
 c04da72:	9300      	str	r3, [sp, #0]
 c04da74:	e7e6      	b.n	c04da44 <mbedtls_ecp_group_load+0x54>
            return( LOAD_GROUP( secp256r1 ) );
 c04da76:	2220      	movs	r2, #32
 c04da78:	4b85      	ldr	r3, [pc, #532]	@ (c04dc90 <mbedtls_ecp_group_load+0x2a0>)
 c04da7a:	4986      	ldr	r1, [pc, #536]	@ (c04dc94 <mbedtls_ecp_group_load+0x2a4>)
 c04da7c:	e9cd 2306 	strd	r2, r3, [sp, #24]
 c04da80:	4b85      	ldr	r3, [pc, #532]	@ (c04dc98 <mbedtls_ecp_group_load+0x2a8>)
 c04da82:	9208      	str	r2, [sp, #32]
 c04da84:	e9cd 2304 	strd	r2, r3, [sp, #16]
 c04da88:	4b84      	ldr	r3, [pc, #528]	@ (c04dc9c <mbedtls_ecp_group_load+0x2ac>)
 c04da8a:	e9cd 2302 	strd	r2, r3, [sp, #8]
 c04da8e:	4b84      	ldr	r3, [pc, #528]	@ (c04dca0 <mbedtls_ecp_group_load+0x2b0>)
 c04da90:	9301      	str	r3, [sp, #4]
 c04da92:	2300      	movs	r3, #0
 c04da94:	9300      	str	r3, [sp, #0]
 c04da96:	e7d5      	b.n	c04da44 <mbedtls_ecp_group_load+0x54>
            return( LOAD_GROUP( secp384r1 ) );
 c04da98:	2230      	movs	r2, #48	@ 0x30
 c04da9a:	4b82      	ldr	r3, [pc, #520]	@ (c04dca4 <mbedtls_ecp_group_load+0x2b4>)
 c04da9c:	4982      	ldr	r1, [pc, #520]	@ (c04dca8 <mbedtls_ecp_group_load+0x2b8>)
 c04da9e:	e9cd 2306 	strd	r2, r3, [sp, #24]
 c04daa2:	4b82      	ldr	r3, [pc, #520]	@ (c04dcac <mbedtls_ecp_group_load+0x2bc>)
 c04daa4:	9208      	str	r2, [sp, #32]
 c04daa6:	e9cd 2304 	strd	r2, r3, [sp, #16]
 c04daaa:	4b81      	ldr	r3, [pc, #516]	@ (c04dcb0 <mbedtls_ecp_group_load+0x2c0>)
 c04daac:	e9cd 2302 	strd	r2, r3, [sp, #8]
 c04dab0:	4b80      	ldr	r3, [pc, #512]	@ (c04dcb4 <mbedtls_ecp_group_load+0x2c4>)
 c04dab2:	9301      	str	r3, [sp, #4]
 c04dab4:	2300      	movs	r3, #0
 c04dab6:	9300      	str	r3, [sp, #0]
 c04dab8:	e7c4      	b.n	c04da44 <mbedtls_ecp_group_load+0x54>
            return( LOAD_GROUP( secp521r1 ) );
 c04daba:	2244      	movs	r2, #68	@ 0x44
 c04dabc:	4b7e      	ldr	r3, [pc, #504]	@ (c04dcb8 <mbedtls_ecp_group_load+0x2c8>)
 c04dabe:	497f      	ldr	r1, [pc, #508]	@ (c04dcbc <mbedtls_ecp_group_load+0x2cc>)
 c04dac0:	e9cd 2306 	strd	r2, r3, [sp, #24]
 c04dac4:	4b7e      	ldr	r3, [pc, #504]	@ (c04dcc0 <mbedtls_ecp_group_load+0x2d0>)
 c04dac6:	9208      	str	r2, [sp, #32]
 c04dac8:	e9cd 2304 	strd	r2, r3, [sp, #16]
 c04dacc:	4b7d      	ldr	r3, [pc, #500]	@ (c04dcc4 <mbedtls_ecp_group_load+0x2d4>)
 c04dace:	e9cd 2302 	strd	r2, r3, [sp, #8]
 c04dad2:	4b7d      	ldr	r3, [pc, #500]	@ (c04dcc8 <mbedtls_ecp_group_load+0x2d8>)
 c04dad4:	9301      	str	r3, [sp, #4]
 c04dad6:	2300      	movs	r3, #0
 c04dad8:	9300      	str	r3, [sp, #0]
 c04dada:	e7b3      	b.n	c04da44 <mbedtls_ecp_group_load+0x54>
            return( LOAD_GROUP_A( secp192k1 ) );
 c04dadc:	2218      	movs	r2, #24
            grp->modp = ecp_mod_p192k1;
 c04dade:	4b7b      	ldr	r3, [pc, #492]	@ (c04dccc <mbedtls_ecp_group_load+0x2dc>)
            return( LOAD_GROUP_A( secp192k1 ) );
 c04dae0:	497b      	ldr	r1, [pc, #492]	@ (c04dcd0 <mbedtls_ecp_group_load+0x2e0>)
            grp->modp = ecp_mod_p192k1;
 c04dae2:	666b      	str	r3, [r5, #100]	@ 0x64
            return( LOAD_GROUP_A( secp192k1 ) );
 c04dae4:	4b7b      	ldr	r3, [pc, #492]	@ (c04dcd4 <mbedtls_ecp_group_load+0x2e4>)
 c04dae6:	9208      	str	r2, [sp, #32]
 c04dae8:	e9cd 2306 	strd	r2, r3, [sp, #24]
 c04daec:	4b7a      	ldr	r3, [pc, #488]	@ (c04dcd8 <mbedtls_ecp_group_load+0x2e8>)
 c04daee:	e9cd 2304 	strd	r2, r3, [sp, #16]
 c04daf2:	4b7a      	ldr	r3, [pc, #488]	@ (c04dcdc <mbedtls_ecp_group_load+0x2ec>)
 c04daf4:	9303      	str	r3, [sp, #12]
 c04daf6:	2304      	movs	r3, #4
 c04daf8:	e9cd 3100 	strd	r3, r1, [sp]
 c04dafc:	9302      	str	r3, [sp, #8]
 c04dafe:	4978      	ldr	r1, [pc, #480]	@ (c04dce0 <mbedtls_ecp_group_load+0x2f0>)
 c04db00:	4b78      	ldr	r3, [pc, #480]	@ (c04dce4 <mbedtls_ecp_group_load+0x2f4>)
 c04db02:	e79f      	b.n	c04da44 <mbedtls_ecp_group_load+0x54>
            grp->modp = ecp_mod_p224k1;
 c04db04:	4b78      	ldr	r3, [pc, #480]	@ (c04dce8 <mbedtls_ecp_group_load+0x2f8>)
            return( LOAD_GROUP_A( secp224k1 ) );
 c04db06:	221c      	movs	r2, #28
            grp->modp = ecp_mod_p224k1;
 c04db08:	666b      	str	r3, [r5, #100]	@ 0x64
            return( LOAD_GROUP_A( secp224k1 ) );
 c04db0a:	2320      	movs	r3, #32
 c04db0c:	9308      	str	r3, [sp, #32]
 c04db0e:	4b77      	ldr	r3, [pc, #476]	@ (c04dcec <mbedtls_ecp_group_load+0x2fc>)
 c04db10:	4977      	ldr	r1, [pc, #476]	@ (c04dcf0 <mbedtls_ecp_group_load+0x300>)
 c04db12:	9307      	str	r3, [sp, #28]
 c04db14:	4b77      	ldr	r3, [pc, #476]	@ (c04dcf4 <mbedtls_ecp_group_load+0x304>)
 c04db16:	9206      	str	r2, [sp, #24]
 c04db18:	e9cd 2304 	strd	r2, r3, [sp, #16]
 c04db1c:	4b76      	ldr	r3, [pc, #472]	@ (c04dcf8 <mbedtls_ecp_group_load+0x308>)
 c04db1e:	9303      	str	r3, [sp, #12]
 c04db20:	2304      	movs	r3, #4
 c04db22:	e9cd 3100 	strd	r3, r1, [sp]
 c04db26:	9302      	str	r3, [sp, #8]
 c04db28:	4974      	ldr	r1, [pc, #464]	@ (c04dcfc <mbedtls_ecp_group_load+0x30c>)
 c04db2a:	4b75      	ldr	r3, [pc, #468]	@ (c04dd00 <mbedtls_ecp_group_load+0x310>)
 c04db2c:	e78a      	b.n	c04da44 <mbedtls_ecp_group_load+0x54>
            return( LOAD_GROUP_A( secp256k1 ) );
 c04db2e:	2220      	movs	r2, #32
            grp->modp = ecp_mod_p256k1;
 c04db30:	4b74      	ldr	r3, [pc, #464]	@ (c04dd04 <mbedtls_ecp_group_load+0x314>)
            return( LOAD_GROUP_A( secp256k1 ) );
 c04db32:	4975      	ldr	r1, [pc, #468]	@ (c04dd08 <mbedtls_ecp_group_load+0x318>)
            grp->modp = ecp_mod_p256k1;
 c04db34:	666b      	str	r3, [r5, #100]	@ 0x64
            return( LOAD_GROUP_A( secp256k1 ) );
 c04db36:	4b75      	ldr	r3, [pc, #468]	@ (c04dd0c <mbedtls_ecp_group_load+0x31c>)
 c04db38:	9208      	str	r2, [sp, #32]
 c04db3a:	e9cd 2306 	strd	r2, r3, [sp, #24]
 c04db3e:	4b74      	ldr	r3, [pc, #464]	@ (c04dd10 <mbedtls_ecp_group_load+0x320>)
 c04db40:	e9cd 2304 	strd	r2, r3, [sp, #16]
 c04db44:	4b73      	ldr	r3, [pc, #460]	@ (c04dd14 <mbedtls_ecp_group_load+0x324>)
 c04db46:	9303      	str	r3, [sp, #12]
 c04db48:	2304      	movs	r3, #4
 c04db4a:	e9cd 3100 	strd	r3, r1, [sp]
 c04db4e:	9302      	str	r3, [sp, #8]
 c04db50:	4971      	ldr	r1, [pc, #452]	@ (c04dd18 <mbedtls_ecp_group_load+0x328>)
 c04db52:	4b72      	ldr	r3, [pc, #456]	@ (c04dd1c <mbedtls_ecp_group_load+0x32c>)
 c04db54:	e776      	b.n	c04da44 <mbedtls_ecp_group_load+0x54>
            return( LOAD_GROUP_A( brainpoolP256r1 ) );
 c04db56:	2220      	movs	r2, #32
 c04db58:	4b71      	ldr	r3, [pc, #452]	@ (c04dd20 <mbedtls_ecp_group_load+0x330>)
 c04db5a:	4972      	ldr	r1, [pc, #456]	@ (c04dd24 <mbedtls_ecp_group_load+0x334>)
 c04db5c:	e9cd 2306 	strd	r2, r3, [sp, #24]
 c04db60:	4b71      	ldr	r3, [pc, #452]	@ (c04dd28 <mbedtls_ecp_group_load+0x338>)
 c04db62:	9208      	str	r2, [sp, #32]
 c04db64:	e9cd 2304 	strd	r2, r3, [sp, #16]
 c04db68:	4b70      	ldr	r3, [pc, #448]	@ (c04dd2c <mbedtls_ecp_group_load+0x33c>)
 c04db6a:	e9cd 2302 	strd	r2, r3, [sp, #8]
 c04db6e:	4b70      	ldr	r3, [pc, #448]	@ (c04dd30 <mbedtls_ecp_group_load+0x340>)
 c04db70:	e9cd 2300 	strd	r2, r3, [sp]
 c04db74:	4b6f      	ldr	r3, [pc, #444]	@ (c04dd34 <mbedtls_ecp_group_load+0x344>)
 c04db76:	e765      	b.n	c04da44 <mbedtls_ecp_group_load+0x54>
            return( LOAD_GROUP_A( brainpoolP384r1 ) );
 c04db78:	2230      	movs	r2, #48	@ 0x30
 c04db7a:	4b6f      	ldr	r3, [pc, #444]	@ (c04dd38 <mbedtls_ecp_group_load+0x348>)
 c04db7c:	496f      	ldr	r1, [pc, #444]	@ (c04dd3c <mbedtls_ecp_group_load+0x34c>)
 c04db7e:	e9cd 2306 	strd	r2, r3, [sp, #24]
 c04db82:	4b6f      	ldr	r3, [pc, #444]	@ (c04dd40 <mbedtls_ecp_group_load+0x350>)
 c04db84:	9208      	str	r2, [sp, #32]
 c04db86:	e9cd 2304 	strd	r2, r3, [sp, #16]
 c04db8a:	4b6e      	ldr	r3, [pc, #440]	@ (c04dd44 <mbedtls_ecp_group_load+0x354>)
 c04db8c:	e9cd 2302 	strd	r2, r3, [sp, #8]
 c04db90:	4b6d      	ldr	r3, [pc, #436]	@ (c04dd48 <mbedtls_ecp_group_load+0x358>)
 c04db92:	e9cd 2300 	strd	r2, r3, [sp]
 c04db96:	4b6d      	ldr	r3, [pc, #436]	@ (c04dd4c <mbedtls_ecp_group_load+0x35c>)
 c04db98:	e754      	b.n	c04da44 <mbedtls_ecp_group_load+0x54>
            return( LOAD_GROUP_A( brainpoolP512r1 ) );
 c04db9a:	2240      	movs	r2, #64	@ 0x40
 c04db9c:	4b6c      	ldr	r3, [pc, #432]	@ (c04dd50 <mbedtls_ecp_group_load+0x360>)
 c04db9e:	496d      	ldr	r1, [pc, #436]	@ (c04dd54 <mbedtls_ecp_group_load+0x364>)
 c04dba0:	e9cd 2306 	strd	r2, r3, [sp, #24]
 c04dba4:	4b6c      	ldr	r3, [pc, #432]	@ (c04dd58 <mbedtls_ecp_group_load+0x368>)
 c04dba6:	9208      	str	r2, [sp, #32]
 c04dba8:	e9cd 2304 	strd	r2, r3, [sp, #16]
 c04dbac:	4b6b      	ldr	r3, [pc, #428]	@ (c04dd5c <mbedtls_ecp_group_load+0x36c>)
 c04dbae:	e9cd 2302 	strd	r2, r3, [sp, #8]
 c04dbb2:	4b6b      	ldr	r3, [pc, #428]	@ (c04dd60 <mbedtls_ecp_group_load+0x370>)
 c04dbb4:	e9cd 2300 	strd	r2, r3, [sp]
 c04dbb8:	4b6a      	ldr	r3, [pc, #424]	@ (c04dd64 <mbedtls_ecp_group_load+0x374>)
 c04dbba:	e743      	b.n	c04da44 <mbedtls_ecp_group_load+0x54>
    MBEDTLS_MPI_CHK( mbedtls_mpi_read_string( &grp->A, 16, "01DB42" ) );
 c04dbbc:	2110      	movs	r1, #16
            grp->modp = ecp_mod_p255;
 c04dbbe:	4b6a      	ldr	r3, [pc, #424]	@ (c04dd68 <mbedtls_ecp_group_load+0x378>)
    MBEDTLS_MPI_CHK( mbedtls_mpi_read_string( &grp->A, 16, "01DB42" ) );
 c04dbc0:	4a6a      	ldr	r2, [pc, #424]	@ (c04dd6c <mbedtls_ecp_group_load+0x37c>)
            grp->modp = ecp_mod_p255;
 c04dbc2:	666b      	str	r3, [r5, #100]	@ 0x64
    MBEDTLS_MPI_CHK( mbedtls_mpi_read_string( &grp->A, 16, "01DB42" ) );
 c04dbc4:	1868      	adds	r0, r5, r1
 c04dbc6:	f006 f866 	bl	c053c96 <mbedtls_mpi_read_string>
 c04dbca:	4604      	mov	r4, r0
 c04dbcc:	2800      	cmp	r0, #0
 c04dbce:	f040 8139 	bne.w	c04de44 <mbedtls_ecp_group_load+0x454>
    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &grp->P, 1 ) );
 c04dbd2:	1d2e      	adds	r6, r5, #4
 c04dbd4:	2101      	movs	r1, #1
 c04dbd6:	4630      	mov	r0, r6
 c04dbd8:	f005 fc31 	bl	c05343e <mbedtls_mpi_lset>
 c04dbdc:	4604      	mov	r4, r0
 c04dbde:	2800      	cmp	r0, #0
 c04dbe0:	f040 8130 	bne.w	c04de44 <mbedtls_ecp_group_load+0x454>
    MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &grp->P, 255 ) );
 c04dbe4:	21ff      	movs	r1, #255	@ 0xff
 c04dbe6:	4630      	mov	r0, r6
 c04dbe8:	f005 fd6b 	bl	c0536c2 <mbedtls_mpi_shift_l>
 c04dbec:	4604      	mov	r4, r0
 c04dbee:	2800      	cmp	r0, #0
 c04dbf0:	f040 8128 	bne.w	c04de44 <mbedtls_ecp_group_load+0x454>
    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( &grp->P, &grp->P, 19 ) );
 c04dbf4:	2213      	movs	r2, #19
 c04dbf6:	4631      	mov	r1, r6
 c04dbf8:	4630      	mov	r0, r6
 c04dbfa:	f005 ff9b 	bl	c053b34 <mbedtls_mpi_sub_int>
 c04dbfe:	4604      	mov	r4, r0
 c04dc00:	2800      	cmp	r0, #0
 c04dc02:	f040 811f 	bne.w	c04de44 <mbedtls_ecp_group_load+0x454>
    grp->pbits = mbedtls_mpi_bitlen( &grp->P );
 c04dc06:	4630      	mov	r0, r6
 c04dc08:	f005 fc89 	bl	c05351e <mbedtls_mpi_bitlen>
    MBEDTLS_MPI_CHK( mbedtls_mpi_read_string( &grp->N, 16,
 c04dc0c:	f105 064c 	add.w	r6, r5, #76	@ 0x4c
    grp->pbits = mbedtls_mpi_bitlen( &grp->P );
 c04dc10:	65a8      	str	r0, [r5, #88]	@ 0x58
    MBEDTLS_MPI_CHK( mbedtls_mpi_read_string( &grp->N, 16,
 c04dc12:	2110      	movs	r1, #16
 c04dc14:	4630      	mov	r0, r6
 c04dc16:	4a56      	ldr	r2, [pc, #344]	@ (c04dd70 <mbedtls_ecp_group_load+0x380>)
 c04dc18:	f006 f83d 	bl	c053c96 <mbedtls_mpi_read_string>
 c04dc1c:	4604      	mov	r4, r0
 c04dc1e:	2800      	cmp	r0, #0
 c04dc20:	f040 8110 	bne.w	c04de44 <mbedtls_ecp_group_load+0x454>
    MBEDTLS_MPI_CHK( mbedtls_mpi_set_bit( &grp->N, 252, 1 ) );
 c04dc24:	2201      	movs	r2, #1
 c04dc26:	21fc      	movs	r1, #252	@ 0xfc
 c04dc28:	4630      	mov	r0, r6
 c04dc2a:	f005 fc34 	bl	c053496 <mbedtls_mpi_set_bit>
 c04dc2e:	4604      	mov	r4, r0
 c04dc30:	2800      	cmp	r0, #0
 c04dc32:	f040 8107 	bne.w	c04de44 <mbedtls_ecp_group_load+0x454>
    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &grp->G.X, 9 ) );
 c04dc36:	2109      	movs	r1, #9
 c04dc38:	f105 0028 	add.w	r0, r5, #40	@ 0x28
 c04dc3c:	f005 fbff 	bl	c05343e <mbedtls_mpi_lset>
 c04dc40:	4604      	mov	r4, r0
 c04dc42:	2800      	cmp	r0, #0
 c04dc44:	f040 80fe 	bne.w	c04de44 <mbedtls_ecp_group_load+0x454>
    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &grp->G.Z, 1 ) );
 c04dc48:	2101      	movs	r1, #1
 c04dc4a:	f105 0040 	add.w	r0, r5, #64	@ 0x40
 c04dc4e:	f005 fbf6 	bl	c05343e <mbedtls_mpi_lset>
 c04dc52:	4604      	mov	r4, r0
 c04dc54:	2800      	cmp	r0, #0
 c04dc56:	f040 80f5 	bne.w	c04de44 <mbedtls_ecp_group_load+0x454>
    mbedtls_mpi_free( &grp->G.Y );
 c04dc5a:	f105 0034 	add.w	r0, r5, #52	@ 0x34
 c04dc5e:	f005 fb50 	bl	c053302 <mbedtls_mpi_free>
    grp->nbits = 254;
 c04dc62:	23fe      	movs	r3, #254	@ 0xfe
 c04dc64:	65eb      	str	r3, [r5, #92]	@ 0x5c
    if( ret != 0 )
 c04dc66:	e6f1      	b.n	c04da4c <mbedtls_ecp_group_load+0x5c>
 c04dc68:	0c05f6c0 	.word	0x0c05f6c0
 c04dc6c:	0c05f720 	.word	0x0c05f720
 c04dc70:	0c05f6d8 	.word	0x0c05f6d8
 c04dc74:	0c05f6f0 	.word	0x0c05f6f0
 c04dc78:	0c05f708 	.word	0x0c05f708
 c04dc7c:	0c05f630 	.word	0x0c05f630
 c04dc80:	0c05f64c 	.word	0x0c05f64c
 c04dc84:	0c05f6a0 	.word	0x0c05f6a0
 c04dc88:	0c05f668 	.word	0x0c05f668
 c04dc8c:	0c05f684 	.word	0x0c05f684
 c04dc90:	0c05f590 	.word	0x0c05f590
 c04dc94:	0c05f610 	.word	0x0c05f610
 c04dc98:	0c05f5b0 	.word	0x0c05f5b0
 c04dc9c:	0c05f5d0 	.word	0x0c05f5d0
 c04dca0:	0c05f5f0 	.word	0x0c05f5f0
 c04dca4:	0c05f4a0 	.word	0x0c05f4a0
 c04dca8:	0c05f560 	.word	0x0c05f560
 c04dcac:	0c05f4d0 	.word	0x0c05f4d0
 c04dcb0:	0c05f500 	.word	0x0c05f500
 c04dcb4:	0c05f530 	.word	0x0c05f530
 c04dcb8:	0c05f34c 	.word	0x0c05f34c
 c04dcbc:	0c05f45c 	.word	0x0c05f45c
 c04dcc0:	0c05f390 	.word	0x0c05f390
 c04dcc4:	0c05f3d4 	.word	0x0c05f3d4
 c04dcc8:	0c05f418 	.word	0x0c05f418
 c04dccc:	0c04d9cd 	.word	0x0c04d9cd
 c04dcd0:	0c05f32c 	.word	0x0c05f32c
 c04dcd4:	0c05f2e4 	.word	0x0c05f2e4
 c04dcd8:	0c05f2fc 	.word	0x0c05f2fc
 c04dcdc:	0c05f314 	.word	0x0c05f314
 c04dce0:	0c05f334 	.word	0x0c05f334
 c04dce4:	0c05f330 	.word	0x0c05f330
 c04dce8:	0c04d9d9 	.word	0x0c04d9d9
 c04dcec:	0c05f268 	.word	0x0c05f268
 c04dcf0:	0c05f2c0 	.word	0x0c05f2c0
 c04dcf4:	0c05f288 	.word	0x0c05f288
 c04dcf8:	0c05f2a4 	.word	0x0c05f2a4
 c04dcfc:	0c05f2c8 	.word	0x0c05f2c8
 c04dd00:	0c05f2c4 	.word	0x0c05f2c4
 c04dd04:	0c04d9e5 	.word	0x0c04d9e5
 c04dd08:	0c05f240 	.word	0x0c05f240
 c04dd0c:	0c05f1e0 	.word	0x0c05f1e0
 c04dd10:	0c05f200 	.word	0x0c05f200
 c04dd14:	0c05f220 	.word	0x0c05f220
 c04dd18:	0c05f248 	.word	0x0c05f248
 c04dd1c:	0c05f244 	.word	0x0c05f244
 c04dd20:	0c05f120 	.word	0x0c05f120
 c04dd24:	0c05f1c0 	.word	0x0c05f1c0
 c04dd28:	0c05f140 	.word	0x0c05f140
 c04dd2c:	0c05f160 	.word	0x0c05f160
 c04dd30:	0c05f180 	.word	0x0c05f180
 c04dd34:	0c05f1a0 	.word	0x0c05f1a0
 c04dd38:	0c05f000 	.word	0x0c05f000
 c04dd3c:	0c05f0f0 	.word	0x0c05f0f0
 c04dd40:	0c05f030 	.word	0x0c05f030
 c04dd44:	0c05f060 	.word	0x0c05f060
 c04dd48:	0c05f090 	.word	0x0c05f090
 c04dd4c:	0c05f0c0 	.word	0x0c05f0c0
 c04dd50:	0c05ee80 	.word	0x0c05ee80
 c04dd54:	0c05efc0 	.word	0x0c05efc0
 c04dd58:	0c05eec0 	.word	0x0c05eec0
 c04dd5c:	0c05ef00 	.word	0x0c05ef00
 c04dd60:	0c05ef40 	.word	0x0c05ef40
 c04dd64:	0c05ef80 	.word	0x0c05ef80
 c04dd68:	0c04d705 	.word	0x0c04d705
 c04dd6c:	0c05ee18 	.word	0x0c05ee18
 c04dd70:	0c05ee1f 	.word	0x0c05ee1f
            grp->modp = ecp_mod_p448;
 c04dd74:	4b37      	ldr	r3, [pc, #220]	@ (c04de54 <mbedtls_ecp_group_load+0x464>)
    mbedtls_mpi_init( &Ns );
 c04dd76:	a80b      	add	r0, sp, #44	@ 0x2c
            grp->modp = ecp_mod_p448;
 c04dd78:	666b      	str	r3, [r5, #100]	@ 0x64
    mbedtls_mpi_init( &Ns );
 c04dd7a:	f005 fabc 	bl	c0532f6 <mbedtls_mpi_init>
    MBEDTLS_MPI_CHK( mbedtls_mpi_read_string( &grp->A, 16, "98AA" ) );
 c04dd7e:	2110      	movs	r1, #16
 c04dd80:	4a35      	ldr	r2, [pc, #212]	@ (c04de58 <mbedtls_ecp_group_load+0x468>)
 c04dd82:	1868      	adds	r0, r5, r1
 c04dd84:	f005 ff87 	bl	c053c96 <mbedtls_mpi_read_string>
 c04dd88:	4604      	mov	r4, r0
 c04dd8a:	2800      	cmp	r0, #0
 c04dd8c:	d154      	bne.n	c04de38 <mbedtls_ecp_group_load+0x448>
    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &grp->P, 1 ) );
 c04dd8e:	1d2e      	adds	r6, r5, #4
 c04dd90:	2101      	movs	r1, #1
 c04dd92:	4630      	mov	r0, r6
 c04dd94:	f005 fb53 	bl	c05343e <mbedtls_mpi_lset>
 c04dd98:	4604      	mov	r4, r0
 c04dd9a:	2800      	cmp	r0, #0
 c04dd9c:	d14c      	bne.n	c04de38 <mbedtls_ecp_group_load+0x448>
    MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &grp->P, 224 ) );
 c04dd9e:	21e0      	movs	r1, #224	@ 0xe0
 c04dda0:	4630      	mov	r0, r6
 c04dda2:	f005 fc8e 	bl	c0536c2 <mbedtls_mpi_shift_l>
 c04dda6:	4604      	mov	r4, r0
 c04dda8:	2800      	cmp	r0, #0
 c04ddaa:	d145      	bne.n	c04de38 <mbedtls_ecp_group_load+0x448>
    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( &grp->P, &grp->P, 1 ) );
 c04ddac:	2201      	movs	r2, #1
 c04ddae:	4631      	mov	r1, r6
 c04ddb0:	4630      	mov	r0, r6
 c04ddb2:	f005 febf 	bl	c053b34 <mbedtls_mpi_sub_int>
 c04ddb6:	4604      	mov	r4, r0
 c04ddb8:	2800      	cmp	r0, #0
 c04ddba:	d13d      	bne.n	c04de38 <mbedtls_ecp_group_load+0x448>
    MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &grp->P, 224 ) );
 c04ddbc:	21e0      	movs	r1, #224	@ 0xe0
 c04ddbe:	4630      	mov	r0, r6
 c04ddc0:	f005 fc7f 	bl	c0536c2 <mbedtls_mpi_shift_l>
 c04ddc4:	4604      	mov	r4, r0
 c04ddc6:	bbb8      	cbnz	r0, c04de38 <mbedtls_ecp_group_load+0x448>
    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( &grp->P, &grp->P, 1 ) );
 c04ddc8:	2201      	movs	r2, #1
 c04ddca:	4631      	mov	r1, r6
 c04ddcc:	4630      	mov	r0, r6
 c04ddce:	f005 feb1 	bl	c053b34 <mbedtls_mpi_sub_int>
 c04ddd2:	4604      	mov	r4, r0
 c04ddd4:	bb80      	cbnz	r0, c04de38 <mbedtls_ecp_group_load+0x448>
    grp->pbits = mbedtls_mpi_bitlen( &grp->P );
 c04ddd6:	4630      	mov	r0, r6
 c04ddd8:	f005 fba1 	bl	c05351e <mbedtls_mpi_bitlen>
    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &grp->G.X, 5 ) );
 c04dddc:	2105      	movs	r1, #5
    grp->pbits = mbedtls_mpi_bitlen( &grp->P );
 c04ddde:	65a8      	str	r0, [r5, #88]	@ 0x58
    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &grp->G.X, 5 ) );
 c04dde0:	f105 0028 	add.w	r0, r5, #40	@ 0x28
 c04dde4:	f005 fb2b 	bl	c05343e <mbedtls_mpi_lset>
 c04dde8:	4604      	mov	r4, r0
 c04ddea:	bb28      	cbnz	r0, c04de38 <mbedtls_ecp_group_load+0x448>
    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &grp->G.Z, 1 ) );
 c04ddec:	2101      	movs	r1, #1
 c04ddee:	f105 0040 	add.w	r0, r5, #64	@ 0x40
 c04ddf2:	f005 fb24 	bl	c05343e <mbedtls_mpi_lset>
 c04ddf6:	4604      	mov	r4, r0
 c04ddf8:	b9f0      	cbnz	r0, c04de38 <mbedtls_ecp_group_load+0x448>
    mbedtls_mpi_free( &grp->G.Y );
 c04ddfa:	f105 0034 	add.w	r0, r5, #52	@ 0x34
    MBEDTLS_MPI_CHK( mbedtls_mpi_set_bit( &grp->N, 446, 1 ) );
 c04ddfe:	f105 064c 	add.w	r6, r5, #76	@ 0x4c
    mbedtls_mpi_free( &grp->G.Y );
 c04de02:	f005 fa7e 	bl	c053302 <mbedtls_mpi_free>
    MBEDTLS_MPI_CHK( mbedtls_mpi_set_bit( &grp->N, 446, 1 ) );
 c04de06:	2201      	movs	r2, #1
 c04de08:	f44f 71df 	mov.w	r1, #446	@ 0x1be
 c04de0c:	4630      	mov	r0, r6
 c04de0e:	f005 fb42 	bl	c053496 <mbedtls_mpi_set_bit>
 c04de12:	4604      	mov	r4, r0
 c04de14:	b980      	cbnz	r0, c04de38 <mbedtls_ecp_group_load+0x448>
    MBEDTLS_MPI_CHK( mbedtls_mpi_read_string( &Ns, 16,
 c04de16:	2110      	movs	r1, #16
 c04de18:	4a10      	ldr	r2, [pc, #64]	@ (c04de5c <mbedtls_ecp_group_load+0x46c>)
 c04de1a:	a80b      	add	r0, sp, #44	@ 0x2c
 c04de1c:	f005 ff3b 	bl	c053c96 <mbedtls_mpi_read_string>
 c04de20:	4604      	mov	r4, r0
 c04de22:	b948      	cbnz	r0, c04de38 <mbedtls_ecp_group_load+0x448>
    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &grp->N, &grp->N, &Ns ) );
 c04de24:	4631      	mov	r1, r6
 c04de26:	4630      	mov	r0, r6
 c04de28:	aa0b      	add	r2, sp, #44	@ 0x2c
 c04de2a:	f005 fe49 	bl	c053ac0 <mbedtls_mpi_sub_mpi>
 c04de2e:	4604      	mov	r4, r0
 c04de30:	b910      	cbnz	r0, c04de38 <mbedtls_ecp_group_load+0x448>
    grp->nbits = 447;
 c04de32:	f240 13bf 	movw	r3, #447	@ 0x1bf
 c04de36:	65eb      	str	r3, [r5, #92]	@ 0x5c
    mbedtls_mpi_free( &Ns );
 c04de38:	a80b      	add	r0, sp, #44	@ 0x2c
 c04de3a:	f005 fa62 	bl	c053302 <mbedtls_mpi_free>
    if( ret != 0 )
 c04de3e:	2c00      	cmp	r4, #0
 c04de40:	f43f ae04 	beq.w	c04da4c <mbedtls_ecp_group_load+0x5c>
        mbedtls_ecp_group_free( grp );
 c04de44:	4628      	mov	r0, r5
 c04de46:	f7fe fd1a 	bl	c04c87e <mbedtls_ecp_group_free>
            return( ecp_use_curve448( grp ) );
 c04de4a:	e5ff      	b.n	c04da4c <mbedtls_ecp_group_load+0x5c>
            grp->id = MBEDTLS_ECP_DP_NONE;
 c04de4c:	2300      	movs	r3, #0
            return( MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE );
 c04de4e:	4c04      	ldr	r4, [pc, #16]	@ (c04de60 <mbedtls_ecp_group_load+0x470>)
            grp->id = MBEDTLS_ECP_DP_NONE;
 c04de50:	702b      	strb	r3, [r5, #0]
            return( MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE );
 c04de52:	e5fb      	b.n	c04da4c <mbedtls_ecp_group_load+0x5c>
 c04de54:	0c04d62d 	.word	0x0c04d62d
 c04de58:	0c05ee40 	.word	0x0c05ee40
 c04de5c:	0c05ee45 	.word	0x0c05ee45
 c04de60:	ffffb180 	.word	0xffffb180

0c04de64 <gcm_mult>:
 * Sets output to x times H using the precomputed tables.
 * x and output are seen as elements of GF(2^128) as in [MGV].
 */
static void gcm_mult( mbedtls_gcm_context *ctx, const unsigned char x[16],
                      unsigned char output[16] )
{
 c04de64:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    lo = x[15] & 0xf;

    zh = ctx->HH[lo];
    zl = ctx->HL[lo];

    for( i = 15; i >= 0; i-- )
 c04de68:	260f      	movs	r6, #15
    lo = x[15] & 0xf;
 c04de6a:	7bcc      	ldrb	r4, [r1, #15]
        if( i != 15 )
        {
            rem = (unsigned char) zl & 0xf;
            zl = ( zh << 60 ) | ( zl >> 4 );
            zh = ( zh >> 4 );
            zh ^= (uint64_t) last4[rem] << 48;
 c04de6c:	f8df e0f8 	ldr.w	lr, [pc, #248]	@ c04df68 <gcm_mult+0x104>
 c04de70:	f004 040f 	and.w	r4, r4, #15
 c04de74:	eb00 04c4 	add.w	r4, r0, r4, lsl #3
    zh = ctx->HH[lo];
 c04de78:	e9d4 a546 	ldrd	sl, r5, [r4, #280]	@ 0x118
    zl = ctx->HL[lo];
 c04de7c:	e9d4 3426 	ldrd	r3, r4, [r4, #152]	@ 0x98
        lo = x[i] & 0xf;
 c04de80:	5d8f      	ldrb	r7, [r1, r6]
            zl = ( zh << 60 ) | ( zl >> 4 );
 c04de82:	ea4f 1814 	mov.w	r8, r4, lsr #4
        lo = x[i] & 0xf;
 c04de86:	f007 0b0f 	and.w	fp, r7, #15
        hi = ( x[i] >> 4 ) & 0xf;
 c04de8a:	093f      	lsrs	r7, r7, #4
 c04de8c:	9700      	str	r7, [sp, #0]
            zh ^= (uint64_t) last4[rem] << 48;
 c04de8e:	f003 070f 	and.w	r7, r3, #15
            zl = ( zh << 60 ) | ( zl >> 4 );
 c04de92:	ea48 780a 	orr.w	r8, r8, sl, lsl #28
            zh ^= (uint64_t) last4[rem] << 48;
 c04de96:	f85e 7037 	ldr.w	r7, [lr, r7, lsl #3]
            zl = ( zh << 60 ) | ( zl >> 4 );
 c04de9a:	ea4f 1c13 	mov.w	ip, r3, lsr #4
 c04de9e:	f8cd 8004 	str.w	r8, [sp, #4]
        if( i != 15 )
 c04dea2:	2e0f      	cmp	r6, #15
            zh = ( zh >> 4 );
 c04dea4:	ea4f 181a 	mov.w	r8, sl, lsr #4
            zh ^= (uint64_t) last4[rem] << 48;
 c04dea8:	ea4f 4707 	mov.w	r7, r7, lsl #16
            zl = ( zh << 60 ) | ( zl >> 4 );
 c04deac:	ea4c 7c04 	orr.w	ip, ip, r4, lsl #28
            zh = ( zh >> 4 );
 c04deb0:	ea48 7805 	orr.w	r8, r8, r5, lsl #28
 c04deb4:	ea4f 1915 	mov.w	r9, r5, lsr #4
        if( i != 15 )
 c04deb8:	d00f      	beq.n	c04deda <gcm_mult+0x76>
            zh ^= ctx->HH[lo];
 c04deba:	eb00 0bcb 	add.w	fp, r0, fp, lsl #3
 c04debe:	e9db 3446 	ldrd	r3, r4, [fp, #280]	@ 0x118
 c04dec2:	4067      	eors	r7, r4
 c04dec4:	ea87 0509 	eor.w	r5, r7, r9
            zl ^= ctx->HL[lo];
 c04dec8:	9f01      	ldr	r7, [sp, #4]
            zh ^= ctx->HH[lo];
 c04deca:	ea83 0a08 	eor.w	sl, r3, r8
            zl ^= ctx->HL[lo];
 c04dece:	e9db 3426 	ldrd	r3, r4, [fp, #152]	@ 0x98
 c04ded2:	4067      	eors	r7, r4
 c04ded4:	463c      	mov	r4, r7
 c04ded6:	ea8c 0303 	eor.w	r3, ip, r3

        }

        rem = (unsigned char) zl & 0xf;
        zl = ( zh << 60 ) | ( zl >> 4 );
 c04deda:	ea4f 1813 	mov.w	r8, r3, lsr #4
 c04dede:	ea4f 790a 	mov.w	r9, sl, lsl #28
 c04dee2:	ea48 7804 	orr.w	r8, r8, r4, lsl #28
 c04dee6:	ea49 1914 	orr.w	r9, r9, r4, lsr #4
        zh = ( zh >> 4 );
        zh ^= (uint64_t) last4[rem] << 48;
        zh ^= ctx->HH[hi];
 c04deea:	9c00      	ldr	r4, [sp, #0]
        zh ^= (uint64_t) last4[rem] << 48;
 c04deec:	f003 030f 	and.w	r3, r3, #15
 c04def0:	f85e 3033 	ldr.w	r3, [lr, r3, lsl #3]
 c04def4:	eb00 0cc4 	add.w	ip, r0, r4, lsl #3
        zh = ( zh >> 4 );
 c04def8:	ea4f 1a1a 	mov.w	sl, sl, lsr #4
 c04defc:	e9dc 4746 	ldrd	r4, r7, [ip, #280]	@ 0x118
 c04df00:	ea4a 7a05 	orr.w	sl, sl, r5, lsl #28
    for( i = 15; i >= 0; i-- )
 c04df04:	3e01      	subs	r6, #1
 c04df06:	ea87 1515 	eor.w	r5, r7, r5, lsr #4
        zh ^= ctx->HH[hi];
 c04df0a:	ea8a 0a04 	eor.w	sl, sl, r4
 c04df0e:	ea85 4503 	eor.w	r5, r5, r3, lsl #16
        zl ^= ctx->HL[hi];
 c04df12:	e9dc 3426 	ldrd	r3, r4, [ip, #152]	@ 0x98
 c04df16:	ea88 0303 	eor.w	r3, r8, r3
 c04df1a:	ea89 0404 	eor.w	r4, r9, r4
    for( i = 15; i >= 0; i-- )
 c04df1e:	d2af      	bcs.n	c04de80 <gcm_mult+0x1c>
    }

    PUT_UINT32_BE( zh >> 32, output, 0 );
 c04df20:	0e29      	lsrs	r1, r5, #24
 c04df22:	7011      	strb	r1, [r2, #0]
 c04df24:	0c29      	lsrs	r1, r5, #16
 c04df26:	7051      	strb	r1, [r2, #1]
 c04df28:	0a29      	lsrs	r1, r5, #8
 c04df2a:	7091      	strb	r1, [r2, #2]
    PUT_UINT32_BE( zh, output, 4 );
 c04df2c:	ea4f 611a 	mov.w	r1, sl, lsr #24
 c04df30:	7111      	strb	r1, [r2, #4]
 c04df32:	ea4f 411a 	mov.w	r1, sl, lsr #16
 c04df36:	7151      	strb	r1, [r2, #5]
 c04df38:	ea4f 211a 	mov.w	r1, sl, lsr #8
 c04df3c:	7191      	strb	r1, [r2, #6]
    PUT_UINT32_BE( zl >> 32, output, 8 );
 c04df3e:	0e21      	lsrs	r1, r4, #24
 c04df40:	7211      	strb	r1, [r2, #8]
 c04df42:	0c21      	lsrs	r1, r4, #16
 c04df44:	7251      	strb	r1, [r2, #9]
 c04df46:	0a21      	lsrs	r1, r4, #8
 c04df48:	7291      	strb	r1, [r2, #10]
    PUT_UINT32_BE( zl, output, 12 );
 c04df4a:	0e19      	lsrs	r1, r3, #24
 c04df4c:	7311      	strb	r1, [r2, #12]
 c04df4e:	0c19      	lsrs	r1, r3, #16
 c04df50:	7351      	strb	r1, [r2, #13]
 c04df52:	0a19      	lsrs	r1, r3, #8
    PUT_UINT32_BE( zh >> 32, output, 0 );
 c04df54:	70d5      	strb	r5, [r2, #3]
    PUT_UINT32_BE( zh, output, 4 );
 c04df56:	f882 a007 	strb.w	sl, [r2, #7]
    PUT_UINT32_BE( zl >> 32, output, 8 );
 c04df5a:	72d4      	strb	r4, [r2, #11]
    PUT_UINT32_BE( zl, output, 12 );
 c04df5c:	7391      	strb	r1, [r2, #14]
 c04df5e:	73d3      	strb	r3, [r2, #15]
}
 c04df60:	b003      	add	sp, #12
 c04df62:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 c04df66:	bf00      	nop
 c04df68:	0c05f738 	.word	0x0c05f738

0c04df6c <mbedtls_gcm_init>:
    __HAL_RCC_SAES_CLK_ENABLE();
 c04df6c:	4b09      	ldr	r3, [pc, #36]	@ (c04df94 <mbedtls_gcm_init+0x28>)
    memset( ctx, 0, sizeof( mbedtls_gcm_context ) );
 c04df6e:	2100      	movs	r1, #0
    __HAL_RCC_SAES_CLK_ENABLE();
 c04df70:	f8d3 208c 	ldr.w	r2, [r3, #140]	@ 0x8c
{
 c04df74:	b082      	sub	sp, #8
    __HAL_RCC_SAES_CLK_ENABLE();
 c04df76:	f442 1280 	orr.w	r2, r2, #1048576	@ 0x100000
 c04df7a:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
    memset( ctx, 0, sizeof( mbedtls_gcm_context ) );
 c04df7e:	f44f 72ec 	mov.w	r2, #472	@ 0x1d8
    __HAL_RCC_SAES_CLK_ENABLE();
 c04df82:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 c04df86:	f403 1380 	and.w	r3, r3, #1048576	@ 0x100000
 c04df8a:	9301      	str	r3, [sp, #4]
 c04df8c:	9b01      	ldr	r3, [sp, #4]
}
 c04df8e:	b002      	add	sp, #8
    memset( ctx, 0, sizeof( mbedtls_gcm_context ) );
 c04df90:	f00d bbcd 	b.w	c05b72e <memset>
 c04df94:	56020c00 	.word	0x56020c00

0c04df98 <mbedtls_gcm_setkey>:
{
 c04df98:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    switch (keybits) {
 c04df9c:	2bc0      	cmp	r3, #192	@ 0xc0
{
 c04df9e:	4604      	mov	r4, r0
 c04dfa0:	b08b      	sub	sp, #44	@ 0x2c
    switch (keybits) {
 c04dfa2:	f000 80cb 	beq.w	c04e13c <mbedtls_gcm_setkey+0x1a4>
 c04dfa6:	d807      	bhi.n	c04dfb8 <mbedtls_gcm_setkey+0x20>
 c04dfa8:	b173      	cbz	r3, c04dfc8 <mbedtls_gcm_setkey+0x30>
 c04dfaa:	2b80      	cmp	r3, #128	@ 0x80
 c04dfac:	d00a      	beq.n	c04dfc4 <mbedtls_gcm_setkey+0x2c>
 c04dfae:	f06f 0013 	mvn.w	r0, #19
}
 c04dfb2:	b00b      	add	sp, #44	@ 0x2c
 c04dfb4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    switch (keybits) {
 c04dfb8:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 c04dfbc:	d1f7      	bne.n	c04dfae <mbedtls_gcm_setkey+0x16>
            ctx->hcryp_gcm.Init.KeySize = CRYP_KEYSIZE_256B;
 c04dfbe:	f44f 2180 	mov.w	r1, #262144	@ 0x40000
 c04dfc2:	e000      	b.n	c04dfc6 <mbedtls_gcm_setkey+0x2e>
            ctx->hcryp_gcm.Init.KeySize = CRYP_KEYSIZE_128B;;
 c04dfc4:	2100      	movs	r1, #0
 c04dfc6:	62a1      	str	r1, [r4, #40]	@ 0x28
    for( i=0; i < (keybits/32); i++ )
 c04dfc8:	2000      	movs	r0, #0
 c04dfca:	095d      	lsrs	r5, r3, #5
 c04dfcc:	4285      	cmp	r5, r0
 c04dfce:	f102 0204 	add.w	r2, r2, #4
 c04dfd2:	d117      	bne.n	c04e004 <mbedtls_gcm_setkey+0x6c>
    ctx->hcryp_gcm.Init.DataWidthUnit = CRYP_DATAWIDTHUNIT_BYTE;
 c04dfd4:	2201      	movs	r2, #1
    ctx->hcryp_gcm.Instance = SAES;
 c04dfd6:	2504      	movs	r5, #4
    if ( 0 == keybits )
 c04dfd8:	fab3 f383 	clz	r3, r3
    ctx->hcryp_gcm.Init.DataWidthUnit = CRYP_DATAWIDTHUNIT_BYTE;
 c04dfdc:	6462      	str	r2, [r4, #68]	@ 0x44
    ctx->hcryp_gcm.Instance = SAES;
 c04dfde:	4a59      	ldr	r2, [pc, #356]	@ (c04e144 <mbedtls_gcm_setkey+0x1ac>)
    if ( 0 == keybits )
 c04dfe0:	095b      	lsrs	r3, r3, #5
    ctx->hcryp_gcm.Instance = SAES;
 c04dfe2:	e9c4 2508 	strd	r2, r5, [r4, #32]
    ctx->hcryp_gcm.Init.Algorithm  = CRYP_AES_ECB;
 c04dfe6:	2200      	movs	r2, #0
    if ( 0 == keybits )
 c04dfe8:	071b      	lsls	r3, r3, #28
    if (HAL_CRYP_DeInit(&ctx->hcryp_gcm) != HAL_OK)
 c04dfea:	f104 0620 	add.w	r6, r4, #32
 c04dfee:	4630      	mov	r0, r6
    ctx->hcryp_gcm.Init.pKey = ctx->gcm_key;
 c04dff0:	62e4      	str	r4, [r4, #44]	@ 0x2c
    ctx->hcryp_gcm.Init.Algorithm  = CRYP_AES_ECB;
 c04dff2:	6362      	str	r2, [r4, #52]	@ 0x34
        ctx->hcryp_gcm.Init.KeyMode = CRYP_KEYMODE_NORMAL;
 c04dff4:	6522      	str	r2, [r4, #80]	@ 0x50
        ctx->hcryp_gcm.Init.KeySelect = CRYP_KEYSEL_HW;
 c04dff6:	6563      	str	r3, [r4, #84]	@ 0x54
    if (HAL_CRYP_DeInit(&ctx->hcryp_gcm) != HAL_OK)
 c04dff8:	f7ee ff67 	bl	c03ceca <HAL_CRYP_DeInit>
 c04dffc:	b1a0      	cbz	r0, c04e028 <mbedtls_gcm_setkey+0x90>
        ret = MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED;
 c04dffe:	f06f 006f 	mvn.w	r0, #111	@ 0x6f
 c04e002:	e7d6      	b.n	c04dfb2 <mbedtls_gcm_setkey+0x1a>
        GET_UINT32_BE( ctx->gcm_key[i], key, 4*i );
 c04e004:	f812 1c03 	ldrb.w	r1, [r2, #-3]
 c04e008:	f812 6c04 	ldrb.w	r6, [r2, #-4]
 c04e00c:	0409      	lsls	r1, r1, #16
 c04e00e:	ea41 6106 	orr.w	r1, r1, r6, lsl #24
 c04e012:	f812 6c01 	ldrb.w	r6, [r2, #-1]
 c04e016:	4331      	orrs	r1, r6
 c04e018:	f812 6c02 	ldrb.w	r6, [r2, #-2]
 c04e01c:	ea41 2106 	orr.w	r1, r1, r6, lsl #8
 c04e020:	f844 1020 	str.w	r1, [r4, r0, lsl #2]
    for( i=0; i < (keybits/32); i++ )
 c04e024:	3001      	adds	r0, #1
 c04e026:	e7d1      	b.n	c04dfcc <mbedtls_gcm_setkey+0x34>
    __HAL_RCC_SAES_CLK_ENABLE();
 c04e028:	4b47      	ldr	r3, [pc, #284]	@ (c04e148 <mbedtls_gcm_setkey+0x1b0>)
    if (HAL_CRYP_Init(&ctx->hcryp_gcm) != HAL_OK)
 c04e02a:	4630      	mov	r0, r6
    __HAL_RCC_SAES_CLK_ENABLE();
 c04e02c:	f8d3 208c 	ldr.w	r2, [r3, #140]	@ 0x8c
 c04e030:	f442 1280 	orr.w	r2, r2, #1048576	@ 0x100000
 c04e034:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
 c04e038:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 c04e03c:	f403 1380 	and.w	r3, r3, #1048576	@ 0x100000
 c04e040:	9305      	str	r3, [sp, #20]
 c04e042:	9b05      	ldr	r3, [sp, #20]
    if (HAL_CRYP_Init(&ctx->hcryp_gcm) != HAL_OK)
 c04e044:	f7ee fee8 	bl	c03ce18 <HAL_CRYP_Init>
 c04e048:	4601      	mov	r1, r0
 c04e04a:	2800      	cmp	r0, #0
 c04e04c:	d1d7      	bne.n	c04dffe <mbedtls_gcm_setkey+0x66>
    memset( h, 0, 16 );
 c04e04e:	2210      	movs	r2, #16
 c04e050:	a806      	add	r0, sp, #24
 c04e052:	f00d fb6c 	bl	c05b72e <memset>
    if ( HAL_CRYP_Encrypt( &ctx->hcryp_gcm,
 c04e056:	23ff      	movs	r3, #255	@ 0xff
 c04e058:	9300      	str	r3, [sp, #0]
 c04e05a:	ab06      	add	r3, sp, #24
 c04e05c:	2210      	movs	r2, #16
 c04e05e:	4619      	mov	r1, r3
 c04e060:	4630      	mov	r0, r6
 c04e062:	f7ef f987 	bl	c03d374 <HAL_CRYP_Encrypt>
 c04e066:	2800      	cmp	r0, #0
 c04e068:	d1c9      	bne.n	c04dffe <mbedtls_gcm_setkey+0x66>
    ctx->HH[0] = 0;
 c04e06a:	2000      	movs	r0, #0
 c04e06c:	2100      	movs	r1, #0
 c04e06e:	9a08      	ldr	r2, [sp, #32]
 c04e070:	e9c4 0146 	strd	r0, r1, [r4, #280]	@ 0x118
 c04e074:	fa92 fc82 	rev.w	ip, r2
    ctx->HL[0] = 0;
 c04e078:	e9c4 0126 	strd	r0, r1, [r4, #152]	@ 0x98
    for( i = 4; i > 0; i >>= 1 )
 c04e07c:	462a      	mov	r2, r5
    ctx->HL[0] = 0;
 c04e07e:	2003      	movs	r0, #3
        uint32_t T = ( vl & 1 ) * 0xe1000000U;
 c04e080:	f04f 4e61 	mov.w	lr, #3774873600	@ 0xe1000000
 c04e084:	9b07      	ldr	r3, [sp, #28]
 c04e086:	9f06      	ldr	r7, [sp, #24]
 c04e088:	9e09      	ldr	r6, [sp, #36]	@ 0x24
 c04e08a:	ba1b      	rev	r3, r3
 c04e08c:	ba3f      	rev	r7, r7
    ctx->HL[8] = vl;
 c04e08e:	ba36      	rev	r6, r6
 c04e090:	e9c4 6c36 	strd	r6, ip, [r4, #216]	@ 0xd8
    ctx->HH[8] = vh;
 c04e094:	e9c4 3756 	strd	r3, r7, [r4, #344]	@ 0x158
        uint32_t T = ( vl & 1 ) * 0xe1000000U;
 c04e098:	f006 0101 	and.w	r1, r6, #1
 c04e09c:	fb0e f101 	mul.w	r1, lr, r1
        vl  = ( vh << 63 ) | ( vl >> 1 );
 c04e0a0:	07dd      	lsls	r5, r3, #31
 c04e0a2:	0876      	lsrs	r6, r6, #1
        vh  = ( vh >> 1 ) ^ ( (uint64_t) T << 32);
 c04e0a4:	085b      	lsrs	r3, r3, #1
        vl  = ( vh << 63 ) | ( vl >> 1 );
 c04e0a6:	ea46 76cc 	orr.w	r6, r6, ip, lsl #31
        vh  = ( vh >> 1 ) ^ ( (uint64_t) T << 32);
 c04e0aa:	ea43 73c7 	orr.w	r3, r3, r7, lsl #31
        vl  = ( vh << 63 ) | ( vl >> 1 );
 c04e0ae:	ea45 0c5c 	orr.w	ip, r5, ip, lsr #1
        vh  = ( vh >> 1 ) ^ ( (uint64_t) T << 32);
 c04e0b2:	ea81 0757 	eor.w	r7, r1, r7, lsr #1
    for( i = 4; i > 0; i >>= 1 )
 c04e0b6:	3801      	subs	r0, #1
 c04e0b8:	eb04 01c2 	add.w	r1, r4, r2, lsl #3
        ctx->HL[i] = vl;
 c04e0bc:	e9c1 6c26 	strd	r6, ip, [r1, #152]	@ 0x98
        ctx->HH[i] = vh;
 c04e0c0:	e9c1 3746 	strd	r3, r7, [r1, #280]	@ 0x118
    for( i = 4; i > 0; i >>= 1 )
 c04e0c4:	ea4f 0262 	mov.w	r2, r2, asr #1
 c04e0c8:	d1e6      	bne.n	c04e098 <mbedtls_gcm_setkey+0x100>
 c04e0ca:	2003      	movs	r0, #3
    for( i = 2; i <= 8; i *= 2 )
 c04e0cc:	2202      	movs	r2, #2
        uint64_t *HiL = ctx->HL + i, *HiH = ctx->HH + i;
 c04e0ce:	f104 0c98 	add.w	ip, r4, #152	@ 0x98
 c04e0d2:	f504 7e8c 	add.w	lr, r4, #280	@ 0x118
 c04e0d6:	4665      	mov	r5, ip
 c04e0d8:	eb0e 06c2 	add.w	r6, lr, r2, lsl #3
        vl = *HiL;
 c04e0dc:	f85c 1032 	ldr.w	r1, [ip, r2, lsl #3]
        uint64_t *HiL = ctx->HL + i, *HiH = ctx->HH + i;
 c04e0e0:	eb0c 03c2 	add.w	r3, ip, r2, lsl #3
        vh = *HiH;
 c04e0e4:	f85e a032 	ldr.w	sl, [lr, r2, lsl #3]
 c04e0e8:	f8d6 9004 	ldr.w	r9, [r6, #4]
        vl = *HiL;
 c04e0ec:	f8d3 b004 	ldr.w	fp, [r3, #4]
 c04e0f0:	9102      	str	r1, [sp, #8]
 c04e0f2:	eb06 08c2 	add.w	r8, r6, r2, lsl #3
 c04e0f6:	f106 0108 	add.w	r1, r6, #8
            HiH[j] = vh ^ ctx->HH[j];
 c04e0fa:	e9d5 7622 	ldrd	r7, r6, [r5, #136]	@ 0x88
 c04e0fe:	ea87 070a 	eor.w	r7, r7, sl
 c04e102:	ea86 0609 	eor.w	r6, r6, r9
 c04e106:	e9c1 7600 	strd	r7, r6, [r1]
            HiL[j] = vl ^ ctx->HL[j];
 c04e10a:	f855 7f08 	ldr.w	r7, [r5, #8]!
 c04e10e:	3108      	adds	r1, #8
 c04e110:	686e      	ldr	r6, [r5, #4]
        for( j = 1; j < i; j++ )
 c04e112:	4588      	cmp	r8, r1
            HiL[j] = vl ^ ctx->HL[j];
 c04e114:	9603      	str	r6, [sp, #12]
 c04e116:	9e02      	ldr	r6, [sp, #8]
 c04e118:	ea87 0706 	eor.w	r7, r7, r6
 c04e11c:	9e03      	ldr	r6, [sp, #12]
 c04e11e:	f843 7f08 	str.w	r7, [r3, #8]!
 c04e122:	ea86 060b 	eor.w	r6, r6, fp
 c04e126:	605e      	str	r6, [r3, #4]
        for( j = 1; j < i; j++ )
 c04e128:	d1e7      	bne.n	c04e0fa <mbedtls_gcm_setkey+0x162>
    for( i = 2; i <= 8; i *= 2 )
 c04e12a:	3801      	subs	r0, #1
 c04e12c:	ea4f 0242 	mov.w	r2, r2, lsl #1
 c04e130:	d1d1      	bne.n	c04e0d6 <mbedtls_gcm_setkey+0x13e>
    ctx->ctx_save_cr = ctx->hcryp_gcm.Instance->CR;
 c04e132:	6a23      	ldr	r3, [r4, #32]
 c04e134:	681b      	ldr	r3, [r3, #0]
 c04e136:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
 c04e13a:	e73a      	b.n	c04dfb2 <mbedtls_gcm_setkey+0x1a>
            ret = MBEDTLS_ERR_PLATFORM_FEATURE_UNSUPPORTED;
 c04e13c:	f06f 0071 	mvn.w	r0, #113	@ 0x71
    return( ret );
 c04e140:	e737      	b.n	c04dfb2 <mbedtls_gcm_setkey+0x1a>
 c04e142:	bf00      	nop
 c04e144:	520c0c00 	.word	0x520c0c00
 c04e148:	56020c00 	.word	0x56020c00

0c04e14c <mbedtls_gcm_starts>:
                int mode,
                const unsigned char *iv,
                size_t iv_len,
                const unsigned char *add,
                size_t add_len )
{
 c04e14c:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
 c04e150:	9d09      	ldr	r5, [sp, #36]	@ 0x24
 c04e152:	4604      	mov	r4, r0
 c04e154:	460f      	mov	r7, r1
 c04e156:	4616      	mov	r6, r2
    GCM_VALIDATE_RET( iv != NULL );
    GCM_VALIDATE_RET( add_len == 0 || add != NULL );

    /* IV and AD are limited to 2^64 bits, so 2^61 bytes */
    /* IV is not allowed to be zero length */
    if( iv_len == 0 ||
 c04e158:	2b00      	cmp	r3, #0
 c04e15a:	d053      	beq.n	c04e204 <mbedtls_gcm_starts+0xb8>
    {
        return( MBEDTLS_ERR_GCM_BAD_INPUT );
    }

    /* HW implementation restrict support to the length of 96 bits */
    if( IV_LENGTH != iv_len )
 c04e15c:	2b0c      	cmp	r3, #12
 c04e15e:	d154      	bne.n	c04e20a <mbedtls_gcm_starts+0xbe>
    {
        return( MBEDTLS_ERR_PLATFORM_FEATURE_UNSUPPORTED );
    }

    /* allow multi-context of CRYP use: restore context */
    ctx->hcryp_gcm.Instance->CR = ctx->ctx_save_cr;
 c04e160:	6a03      	ldr	r3, [r0, #32]
 c04e162:	f8d0 2088 	ldr.w	r2, [r0, #136]	@ 0x88

    if ( HAL_CRYP_Init( &ctx->hcryp_gcm ) != HAL_OK )
 c04e166:	f100 0820 	add.w	r8, r0, #32
 c04e16a:	4640      	mov	r0, r8
    ctx->hcryp_gcm.Instance->CR = ctx->ctx_save_cr;
 c04e16c:	601a      	str	r2, [r3, #0]
    if ( HAL_CRYP_Init( &ctx->hcryp_gcm ) != HAL_OK )
 c04e16e:	f7ee fe53 	bl	c03ce18 <HAL_CRYP_Init>
 c04e172:	b120      	cbz	r0, c04e17e <mbedtls_gcm_starts+0x32>
    {
        return( MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED );
 c04e174:	f06f 006f 	mvn.w	r0, #111	@ 0x6f

    /* allow multi-context of CRYP : save context */
    ctx->ctx_save_cr = ctx->hcryp_gcm.Instance->CR;

    return( 0 );
}
 c04e178:	b002      	add	sp, #8
 c04e17a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    ctx->len = 0;
 c04e17e:	2200      	movs	r2, #0
 c04e180:	2300      	movs	r3, #0
 c04e182:	e9c4 2324 	strd	r2, r3, [r4, #144]	@ 0x90
    ctx->add_len = 0;
 c04e186:	e9c4 2366 	strd	r2, r3, [r4, #408]	@ 0x198
    ctx->mode = mode;
 c04e18a:	f8c4 71d0 	str.w	r7, [r4, #464]	@ 0x1d0
    memcpy( ctx->y, iv, iv_len );
 c04e18e:	6833      	ldr	r3, [r6, #0]
    if ( HAL_CRYP_Encrypt( &ctx->hcryp_gcm,
 c04e190:	2210      	movs	r2, #16
    memcpy( ctx->y, iv, iv_len );
 c04e192:	f8c4 31b0 	str.w	r3, [r4, #432]	@ 0x1b0
 c04e196:	6873      	ldr	r3, [r6, #4]
    if ( HAL_CRYP_Encrypt( &ctx->hcryp_gcm,
 c04e198:	4640      	mov	r0, r8
    memcpy( ctx->y, iv, iv_len );
 c04e19a:	f8c4 31b4 	str.w	r3, [r4, #436]	@ 0x1b4
 c04e19e:	68b3      	ldr	r3, [r6, #8]
    if ( HAL_CRYP_Encrypt( &ctx->hcryp_gcm,
 c04e1a0:	f504 71d8 	add.w	r1, r4, #432	@ 0x1b0
    memcpy( ctx->y, iv, iv_len );
 c04e1a4:	f8c4 31b8 	str.w	r3, [r4, #440]	@ 0x1b8
    ctx->y[15] = 1;
 c04e1a8:	2301      	movs	r3, #1
 c04e1aa:	f884 31bf 	strb.w	r3, [r4, #447]	@ 0x1bf
    if ( HAL_CRYP_Encrypt( &ctx->hcryp_gcm,
 c04e1ae:	23ff      	movs	r3, #255	@ 0xff
 c04e1b0:	9300      	str	r3, [sp, #0]
 c04e1b2:	f504 73d0 	add.w	r3, r4, #416	@ 0x1a0
 c04e1b6:	f7ef f8dd 	bl	c03d374 <HAL_CRYP_Encrypt>
 c04e1ba:	2800      	cmp	r0, #0
 c04e1bc:	d1da      	bne.n	c04e174 <mbedtls_gcm_starts+0x28>
    ctx->add_len = add_len;
 c04e1be:	e9c4 5066 	strd	r5, r0, [r4, #408]	@ 0x198
        gcm_mult( ctx, ctx->buf, ctx->buf );
 c04e1c2:	f504 72e0 	add.w	r2, r4, #448	@ 0x1c0
    while( add_len > 0 )
 c04e1c6:	b92d      	cbnz	r5, c04e1d4 <mbedtls_gcm_starts+0x88>
    ctx->ctx_save_cr = ctx->hcryp_gcm.Instance->CR;
 c04e1c8:	6a23      	ldr	r3, [r4, #32]
    return( 0 );
 c04e1ca:	4628      	mov	r0, r5
    ctx->ctx_save_cr = ctx->hcryp_gcm.Instance->CR;
 c04e1cc:	681b      	ldr	r3, [r3, #0]
 c04e1ce:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
    return( 0 );
 c04e1d2:	e7d1      	b.n	c04e178 <mbedtls_gcm_starts+0x2c>
        use_len = ( add_len < 16 ) ? add_len : 16;
 c04e1d4:	2d10      	cmp	r5, #16
 c04e1d6:	462f      	mov	r7, r5
 c04e1d8:	bf28      	it	cs
 c04e1da:	2710      	movcs	r7, #16
        for( i = 0; i < use_len; i++ )
 c04e1dc:	9e08      	ldr	r6, [sp, #32]
 c04e1de:	f204 13bf 	addw	r3, r4, #447	@ 0x1bf
 c04e1e2:	19f1      	adds	r1, r6, r7
            ctx->buf[i] ^= p[i];
 c04e1e4:	f816 0b01 	ldrb.w	r0, [r6], #1
 c04e1e8:	f813 cf01 	ldrb.w	ip, [r3, #1]!
        for( i = 0; i < use_len; i++ )
 c04e1ec:	428e      	cmp	r6, r1
            ctx->buf[i] ^= p[i];
 c04e1ee:	ea80 000c 	eor.w	r0, r0, ip
 c04e1f2:	7018      	strb	r0, [r3, #0]
        for( i = 0; i < use_len; i++ )
 c04e1f4:	d1f6      	bne.n	c04e1e4 <mbedtls_gcm_starts+0x98>
        gcm_mult( ctx, ctx->buf, ctx->buf );
 c04e1f6:	4611      	mov	r1, r2
 c04e1f8:	4620      	mov	r0, r4
 c04e1fa:	f7ff fe33 	bl	c04de64 <gcm_mult>
        add_len -= use_len;
 c04e1fe:	1bed      	subs	r5, r5, r7
        p += use_len;
 c04e200:	9608      	str	r6, [sp, #32]
 c04e202:	e7e0      	b.n	c04e1c6 <mbedtls_gcm_starts+0x7a>
        return( MBEDTLS_ERR_GCM_BAD_INPUT );
 c04e204:	f06f 0013 	mvn.w	r0, #19
 c04e208:	e7b6      	b.n	c04e178 <mbedtls_gcm_starts+0x2c>
        return( MBEDTLS_ERR_PLATFORM_FEATURE_UNSUPPORTED );
 c04e20a:	f06f 0071 	mvn.w	r0, #113	@ 0x71
 c04e20e:	e7b3      	b.n	c04e178 <mbedtls_gcm_starts+0x2c>

0c04e210 <mbedtls_gcm_update>:

int mbedtls_gcm_update( mbedtls_gcm_context *ctx,
                size_t length,
                const unsigned char *input,
                unsigned char *output )
{
 c04e210:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

    GCM_VALIDATE_RET( ctx != NULL );
    GCM_VALIDATE_RET( length == 0 || input != NULL );
    GCM_VALIDATE_RET( length == 0 || output != NULL );

    if( output > input && (size_t) ( output - input ) < length )
 c04e214:	4293      	cmp	r3, r2
{
 c04e216:	4604      	mov	r4, r0
 c04e218:	460d      	mov	r5, r1
 c04e21a:	4616      	mov	r6, r2
 c04e21c:	4698      	mov	r8, r3
 c04e21e:	b089      	sub	sp, #36	@ 0x24
    if( output > input && (size_t) ( output - input ) < length )
 c04e220:	d902      	bls.n	c04e228 <mbedtls_gcm_update+0x18>
 c04e222:	1a9b      	subs	r3, r3, r2
 c04e224:	428b      	cmp	r3, r1
 c04e226:	d370      	bcc.n	c04e30a <mbedtls_gcm_update+0xfa>
        return( MBEDTLS_ERR_GCM_BAD_INPUT );

    /* Total length is restricted to 2^39 - 256 bits, ie 2^36 - 2^5 bytes
     * Also check for possible overflow */
    if( ctx->len + length < ctx->len ||
 c04e228:	e9d4 3224 	ldrd	r3, r2, [r4, #144]	@ 0x90
 c04e22c:	195b      	adds	r3, r3, r5
 c04e22e:	f152 0200 	adcs.w	r2, r2, #0
 c04e232:	f04f 0100 	mov.w	r1, #0
 c04e236:	bf28      	it	cs
 c04e238:	2101      	movcs	r1, #1
 c04e23a:	2900      	cmp	r1, #0
 c04e23c:	d165      	bne.n	c04e30a <mbedtls_gcm_update+0xfa>
 c04e23e:	f06f 011f 	mvn.w	r1, #31
 c04e242:	4299      	cmp	r1, r3
 c04e244:	f04f 010f 	mov.w	r1, #15
 c04e248:	4191      	sbcs	r1, r2
 c04e24a:	d35e      	bcc.n	c04e30a <mbedtls_gcm_update+0xfa>
    {
        return( MBEDTLS_ERR_GCM_BAD_INPUT );
    }

    /* allow multi-context of CRYP use: restore context */
    ctx->hcryp_gcm.Instance->CR = ctx->ctx_save_cr;
 c04e24c:	6a21      	ldr	r1, [r4, #32]
 c04e24e:	f8d4 0088 	ldr.w	r0, [r4, #136]	@ 0x88
 c04e252:	f504 7ade 	add.w	sl, r4, #444	@ 0x1bc
 c04e256:	6008      	str	r0, [r1, #0]

#if  defined(HW_CRYPTO_DPA_GCM)
    ctx->len += length;
 c04e258:	e9c4 3224 	strd	r3, r2, [r4, #144]	@ 0x90
            if( ctx->y[i - 1] != 0 )
                break;
        }

        if ( HAL_CRYP_Encrypt( &ctx->hcryp_gcm,
                           (uint32_t *)ctx->y,
 c04e25c:	f504 73d8 	add.w	r3, r4, #432	@ 0x1b0
 c04e260:	9303      	str	r3, [sp, #12]
    while( length > 0 )
 c04e262:	b93d      	cbnz	r5, c04e274 <mbedtls_gcm_update+0x64>
#endif /* HW_CRYPTO_DPA_GCM */

    /* allow multi-context of CRYP : save context */
    ctx->ctx_save_cr = ctx->hcryp_gcm.Instance->CR;

    return( 0 );
 c04e264:	4628      	mov	r0, r5
    ctx->ctx_save_cr = ctx->hcryp_gcm.Instance->CR;
 c04e266:	6a23      	ldr	r3, [r4, #32]
 c04e268:	681b      	ldr	r3, [r3, #0]
 c04e26a:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
}
 c04e26e:	b009      	add	sp, #36	@ 0x24
 c04e270:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        use_len = ( length < 16 ) ? length : 16;
 c04e274:	f504 77e0 	add.w	r7, r4, #448	@ 0x1c0
 c04e278:	2d10      	cmp	r5, #16
 c04e27a:	46a9      	mov	r9, r5
        for( i = 16; i > 12; i-- )
 c04e27c:	463a      	mov	r2, r7
        use_len = ( length < 16 ) ? length : 16;
 c04e27e:	bf28      	it	cs
 c04e280:	f04f 0910 	movcs.w	r9, #16
        for( i = 16; i > 12; i-- )
 c04e284:	46bb      	mov	fp, r7
 c04e286:	4552      	cmp	r2, sl
 c04e288:	d006      	beq.n	c04e298 <mbedtls_gcm_update+0x88>
            ++ctx->y[i - 1];
 c04e28a:	f812 3d01 	ldrb.w	r3, [r2, #-1]!
 c04e28e:	3301      	adds	r3, #1
 c04e290:	b2db      	uxtb	r3, r3
 c04e292:	7013      	strb	r3, [r2, #0]
            if( ctx->y[i - 1] != 0 )
 c04e294:	2b00      	cmp	r3, #0
 c04e296:	d0f6      	beq.n	c04e286 <mbedtls_gcm_update+0x76>
        if ( HAL_CRYP_Encrypt( &ctx->hcryp_gcm,
 c04e298:	23ff      	movs	r3, #255	@ 0xff
 c04e29a:	2210      	movs	r2, #16
 c04e29c:	9300      	str	r3, [sp, #0]
 c04e29e:	9903      	ldr	r1, [sp, #12]
 c04e2a0:	ab04      	add	r3, sp, #16
 c04e2a2:	f104 0020 	add.w	r0, r4, #32
 c04e2a6:	f7ef f865 	bl	c03d374 <HAL_CRYP_Encrypt>
 c04e2aa:	b110      	cbz	r0, c04e2b2 <mbedtls_gcm_update+0xa2>
            return( MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED );
 c04e2ac:	f06f 006f 	mvn.w	r0, #111	@ 0x6f
 c04e2b0:	e7dd      	b.n	c04e26e <mbedtls_gcm_update+0x5e>
 c04e2b2:	aa04      	add	r2, sp, #16
 c04e2b4:	f108 33ff 	add.w	r3, r8, #4294967295	@ 0xffffffff
 c04e2b8:	eb06 0009 	add.w	r0, r6, r9
            if( ctx->mode == MBEDTLS_GCM_DECRYPT )
 c04e2bc:	f8d4 11d0 	ldr.w	r1, [r4, #464]	@ 0x1d0
 c04e2c0:	b929      	cbnz	r1, c04e2ce <mbedtls_gcm_update+0xbe>
                ctx->buf[i] ^= p[i];
 c04e2c2:	7839      	ldrb	r1, [r7, #0]
 c04e2c4:	f896 c000 	ldrb.w	ip, [r6]
 c04e2c8:	ea81 010c 	eor.w	r1, r1, ip
 c04e2cc:	7039      	strb	r1, [r7, #0]
            out_p[i] = ectr[i] ^ p[i];
 c04e2ce:	f816 1b01 	ldrb.w	r1, [r6], #1
 c04e2d2:	f812 cb01 	ldrb.w	ip, [r2], #1
        for( i = 0; i < use_len; i++ )
 c04e2d6:	3701      	adds	r7, #1
            out_p[i] = ectr[i] ^ p[i];
 c04e2d8:	ea8c 0c01 	eor.w	ip, ip, r1
 c04e2dc:	f803 cf01 	strb.w	ip, [r3, #1]!
            if( ctx->mode == MBEDTLS_GCM_ENCRYPT )
 c04e2e0:	f8d4 11d0 	ldr.w	r1, [r4, #464]	@ 0x1d0
 c04e2e4:	2901      	cmp	r1, #1
                ctx->buf[i] ^= out_p[i];
 c04e2e6:	bf02      	ittt	eq
 c04e2e8:	f817 1c01 	ldrbeq.w	r1, [r7, #-1]
 c04e2ec:	ea8c 0c01 	eoreq.w	ip, ip, r1
 c04e2f0:	f807 cc01 	strbeq.w	ip, [r7, #-1]
        for( i = 0; i < use_len; i++ )
 c04e2f4:	4286      	cmp	r6, r0
 c04e2f6:	d1e1      	bne.n	c04e2bc <mbedtls_gcm_update+0xac>
        gcm_mult( ctx, ctx->buf, ctx->buf );
 c04e2f8:	465a      	mov	r2, fp
 c04e2fa:	4659      	mov	r1, fp
 c04e2fc:	4620      	mov	r0, r4
 c04e2fe:	f7ff fdb1 	bl	c04de64 <gcm_mult>
        length -= use_len;
 c04e302:	eba5 0509 	sub.w	r5, r5, r9
        out_p += use_len;
 c04e306:	44c8      	add	r8, r9
 c04e308:	e7ab      	b.n	c04e262 <mbedtls_gcm_update+0x52>
        return( MBEDTLS_ERR_GCM_BAD_INPUT );
 c04e30a:	f06f 0013 	mvn.w	r0, #19
 c04e30e:	e7ae      	b.n	c04e26e <mbedtls_gcm_update+0x5e>

0c04e310 <mbedtls_gcm_finish>:

int mbedtls_gcm_finish( mbedtls_gcm_context *ctx,
                unsigned char *tag,
                size_t tag_len )
{
 c04e310:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
#endif

    GCM_VALIDATE_RET( ctx != NULL );
    GCM_VALIDATE_RET( tag != NULL );

    if( tag_len > 16 || tag_len < 4 )
 c04e314:	1f13      	subs	r3, r2, #4
 c04e316:	2b0c      	cmp	r3, #12
{
 c04e318:	4604      	mov	r4, r0
 c04e31a:	460f      	mov	r7, r1
 c04e31c:	4692      	mov	sl, r2
    if( tag_len > 16 || tag_len < 4 )
 c04e31e:	d858      	bhi.n	c04e3d2 <mbedtls_gcm_finish+0xc2>
        return( MBEDTLS_ERR_GCM_BAD_INPUT );

#if  defined(HW_CRYPTO_DPA_GCM)
    orig_len = ctx->len * 8;
 c04e320:	e9d0 3524 	ldrd	r3, r5, [r0, #144]	@ 0x90
 c04e324:	00ed      	lsls	r5, r5, #3
 c04e326:	ea45 7553 	orr.w	r5, r5, r3, lsr #29
 c04e32a:	ea4f 08c3 	mov.w	r8, r3, lsl #3
    orig_add_len = ctx->add_len * 8;
 c04e32e:	e9d0 3666 	ldrd	r3, r6, [r0, #408]	@ 0x198
 c04e332:	00f6      	lsls	r6, r6, #3
 c04e334:	ea46 7653 	orr.w	r6, r6, r3, lsr #29
 c04e338:	ea4f 09c3 	mov.w	r9, r3, lsl #3

    memcpy( tag, ctx->base_ectr, tag_len );
 c04e33c:	f500 71d0 	add.w	r1, r0, #416	@ 0x1a0
 c04e340:	4638      	mov	r0, r7
 c04e342:	f00d f983 	bl	c05b64c <memcpy>

    if( orig_len || orig_add_len )
 c04e346:	ea48 0309 	orr.w	r3, r8, r9
 c04e34a:	ea45 0206 	orr.w	r2, r5, r6
 c04e34e:	4313      	orrs	r3, r2
 c04e350:	d103      	bne.n	c04e35a <mbedtls_gcm_finish+0x4a>

    /* allow multi-context of CRYP : save context */
    ctx->ctx_save_cr = ctx->hcryp_gcm.Instance->CR;
#endif /* HW_CRYPTO_DPA_GCM */

    return( 0 );
 c04e352:	2000      	movs	r0, #0
}
 c04e354:	b004      	add	sp, #16
 c04e356:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        PUT_UINT32_BE( ( orig_add_len >> 32 ), work_buf, 0  );
 c04e35a:	0e33      	lsrs	r3, r6, #24
 c04e35c:	f88d 3000 	strb.w	r3, [sp]
 c04e360:	0c33      	lsrs	r3, r6, #16
 c04e362:	f88d 3001 	strb.w	r3, [sp, #1]
 c04e366:	0a33      	lsrs	r3, r6, #8
 c04e368:	f88d 3002 	strb.w	r3, [sp, #2]
 c04e36c:	fa99 f389 	rev.w	r3, r9
        PUT_UINT32_BE( ( orig_add_len       ), work_buf, 4  );
 c04e370:	9301      	str	r3, [sp, #4]
        PUT_UINT32_BE( ( orig_len     >> 32 ), work_buf, 8  );
 c04e372:	0e2b      	lsrs	r3, r5, #24
 c04e374:	f88d 3008 	strb.w	r3, [sp, #8]
 c04e378:	0c2b      	lsrs	r3, r5, #16
 c04e37a:	f88d 3009 	strb.w	r3, [sp, #9]
 c04e37e:	0a2b      	lsrs	r3, r5, #8
 c04e380:	f88d 300a 	strb.w	r3, [sp, #10]
 c04e384:	f88d 500b 	strb.w	r5, [sp, #11]
 c04e388:	fa98 f388 	rev.w	r3, r8
 c04e38c:	f204 15bf 	addw	r5, r4, #447	@ 0x1bf
        PUT_UINT32_BE( ( orig_len           ), work_buf, 12 );
 c04e390:	9303      	str	r3, [sp, #12]
 c04e392:	4669      	mov	r1, sp
 c04e394:	462b      	mov	r3, r5
        PUT_UINT32_BE( ( orig_add_len >> 32 ), work_buf, 0  );
 c04e396:	f88d 6003 	strb.w	r6, [sp, #3]
        for( i = 0; i < 16; i++ )
 c04e39a:	f204 10cf 	addw	r0, r4, #463	@ 0x1cf
            ctx->buf[i] ^= work_buf[i];
 c04e39e:	f813 6f01 	ldrb.w	r6, [r3, #1]!
 c04e3a2:	f811 2b01 	ldrb.w	r2, [r1], #1
        for( i = 0; i < 16; i++ )
 c04e3a6:	4283      	cmp	r3, r0
            ctx->buf[i] ^= work_buf[i];
 c04e3a8:	ea82 0206 	eor.w	r2, r2, r6
 c04e3ac:	701a      	strb	r2, [r3, #0]
        for( i = 0; i < 16; i++ )
 c04e3ae:	d1f6      	bne.n	c04e39e <mbedtls_gcm_finish+0x8e>
        gcm_mult( ctx, ctx->buf, ctx->buf );
 c04e3b0:	f504 72e0 	add.w	r2, r4, #448	@ 0x1c0
 c04e3b4:	4620      	mov	r0, r4
 c04e3b6:	4611      	mov	r1, r2
 c04e3b8:	f7ff fd54 	bl	c04de64 <gcm_mult>
        for( i = 0; i < tag_len; i++ )
 c04e3bc:	4638      	mov	r0, r7
 c04e3be:	44ba      	add	sl, r7
            tag[i] ^= ctx->buf[i];
 c04e3c0:	7803      	ldrb	r3, [r0, #0]
 c04e3c2:	f815 2f01 	ldrb.w	r2, [r5, #1]!
 c04e3c6:	4053      	eors	r3, r2
 c04e3c8:	f800 3b01 	strb.w	r3, [r0], #1
        for( i = 0; i < tag_len; i++ )
 c04e3cc:	4550      	cmp	r0, sl
 c04e3ce:	d1f7      	bne.n	c04e3c0 <mbedtls_gcm_finish+0xb0>
 c04e3d0:	e7bf      	b.n	c04e352 <mbedtls_gcm_finish+0x42>
        return( MBEDTLS_ERR_GCM_BAD_INPUT );
 c04e3d2:	f06f 0013 	mvn.w	r0, #19
 c04e3d6:	e7bd      	b.n	c04e354 <mbedtls_gcm_finish+0x44>

0c04e3d8 <mbedtls_gcm_crypt_and_tag>:
                       size_t add_len,
                       const unsigned char *input,
                       unsigned char *output,
                       size_t tag_len,
                       unsigned char *tag )
{
 c04e3d8:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 c04e3dc:	4615      	mov	r5, r2
 c04e3de:	e9dd 890d 	ldrd	r8, r9, [sp, #52]	@ 0x34
 c04e3e2:	e9dd 760f 	ldrd	r7, r6, [sp, #60]	@ 0x3c
 c04e3e6:	461a      	mov	r2, r3
    GCM_VALIDATE_RET( add_len == 0 || add != NULL );
    GCM_VALIDATE_RET( length == 0 || input != NULL );
    GCM_VALIDATE_RET( length == 0 || output != NULL );
    GCM_VALIDATE_RET( tag != NULL );

    if( ( ret = mbedtls_gcm_starts( ctx, mode, iv, iv_len, add, add_len ) ) != 0 )
 c04e3e8:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
{
 c04e3ea:	4604      	mov	r4, r0
    if( ( ret = mbedtls_gcm_starts( ctx, mode, iv, iv_len, add, add_len ) ) != 0 )
 c04e3ec:	9301      	str	r3, [sp, #4]
 c04e3ee:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 c04e3f0:	9300      	str	r3, [sp, #0]
 c04e3f2:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 c04e3f4:	f7ff feaa 	bl	c04e14c <mbedtls_gcm_starts>
 c04e3f8:	b970      	cbnz	r0, c04e418 <mbedtls_gcm_crypt_and_tag+0x40>
        return( ret );

    if( ( ret = mbedtls_gcm_update( ctx, length, input, output ) ) != 0 )
 c04e3fa:	464b      	mov	r3, r9
 c04e3fc:	4642      	mov	r2, r8
 c04e3fe:	4629      	mov	r1, r5
 c04e400:	4620      	mov	r0, r4
 c04e402:	f7ff ff05 	bl	c04e210 <mbedtls_gcm_update>
 c04e406:	b938      	cbnz	r0, c04e418 <mbedtls_gcm_crypt_and_tag+0x40>
        return( ret );

    if( ( ret = mbedtls_gcm_finish( ctx, tag, tag_len ) ) != 0 )
 c04e408:	463a      	mov	r2, r7
 c04e40a:	4631      	mov	r1, r6
 c04e40c:	4620      	mov	r0, r4
        return( ret );

    return( 0 );
}
 c04e40e:	b003      	add	sp, #12
 c04e410:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
    if( ( ret = mbedtls_gcm_finish( ctx, tag, tag_len ) ) != 0 )
 c04e414:	f7ff bf7c 	b.w	c04e310 <mbedtls_gcm_finish>
}
 c04e418:	b003      	add	sp, #12
 c04e41a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

0c04e41e <mbedtls_gcm_auth_decrypt>:
                      size_t add_len,
                      const unsigned char *tag,
                      size_t tag_len,
                      const unsigned char *input,
                      unsigned char *output )
{
 c04e41e:	b5f0      	push	{r4, r5, r6, r7, lr}
 c04e420:	460c      	mov	r4, r1
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    unsigned char check_tag[16];
    size_t i, j;
    unsigned char diff = 0;
    volatile unsigned char inv_diff = 0xFF;
 c04e422:	21ff      	movs	r1, #255	@ 0xff
{
 c04e424:	b08f      	sub	sp, #60	@ 0x3c
    volatile unsigned char inv_diff = 0xFF;
 c04e426:	f88d 1027 	strb.w	r1, [sp, #39]	@ 0x27
    GCM_VALIDATE_RET( add_len == 0 || add != NULL );
    GCM_VALIDATE_RET( tag != NULL );
    GCM_VALIDATE_RET( length == 0 || input != NULL );
    GCM_VALIDATE_RET( length == 0 || output != NULL );

    if( ( ret = mbedtls_gcm_crypt_and_tag( ctx, MBEDTLS_GCM_DECRYPT, length,
 c04e42a:	9918      	ldr	r1, [sp, #96]	@ 0x60
{
 c04e42c:	9d17      	ldr	r5, [sp, #92]	@ 0x5c
    if( ( ret = mbedtls_gcm_crypt_and_tag( ctx, MBEDTLS_GCM_DECRYPT, length,
 c04e42e:	9103      	str	r1, [sp, #12]
 c04e430:	9915      	ldr	r1, [sp, #84]	@ 0x54
{
 c04e432:	9e19      	ldr	r6, [sp, #100]	@ 0x64
    if( ( ret = mbedtls_gcm_crypt_and_tag( ctx, MBEDTLS_GCM_DECRYPT, length,
 c04e434:	9102      	str	r1, [sp, #8]
 c04e436:	9914      	ldr	r1, [sp, #80]	@ 0x50
 c04e438:	af0a      	add	r7, sp, #40	@ 0x28
 c04e43a:	e9cd 3100 	strd	r3, r1, [sp]
 c04e43e:	e9cd 5705 	strd	r5, r7, [sp, #20]
 c04e442:	4613      	mov	r3, r2
 c04e444:	2100      	movs	r1, #0
 c04e446:	4622      	mov	r2, r4
 c04e448:	9604      	str	r6, [sp, #16]
 c04e44a:	f7ff ffc5 	bl	c04e3d8 <mbedtls_gcm_crypt_and_tag>
 c04e44e:	b950      	cbnz	r0, c04e466 <mbedtls_gcm_auth_decrypt+0x48>
 c04e450:	9a16      	ldr	r2, [sp, #88]	@ 0x58
 c04e452:	1951      	adds	r1, r2, r5
    }

    j = tag_len;

    /* Check tag in "constant-time" */
    for( i = 0; i < tag_len; i++ )
 c04e454:	428a      	cmp	r2, r1
 c04e456:	d108      	bne.n	c04e46a <mbedtls_gcm_auth_decrypt+0x4c>
        inv_diff &= tag[i] ^ SEC_SUCCESS_CONSTANT ^ check_tag[i];
        j--;
    }

    /* Check loop is executed ("not skipped" due to attacks) */
    if( ( i != tag_len ) || ( j != 0 ) || ( 0 == tag_len) )
 c04e458:	b9bd      	cbnz	r5, c04e48a <mbedtls_gcm_auth_decrypt+0x6c>
    {
        mbedtls_platform_zeroize( output, length );
 c04e45a:	4630      	mov	r0, r6
 c04e45c:	4621      	mov	r1, r4
 c04e45e:	f7ec ffb7 	bl	c03b3d0 <mbedtls_platform_zeroize>
        return( MBEDTLS_ERR_GCM_AUTH_FAILED );
 c04e462:	f06f 0011 	mvn.w	r0, #17
        mbedtls_platform_zeroize( output, length );
        return( MBEDTLS_ERR_GCM_AUTH_FAILED );
    }

    return( (diff ^ inv_diff) + j );
}
 c04e466:	b00f      	add	sp, #60	@ 0x3c
 c04e468:	bdf0      	pop	{r4, r5, r6, r7, pc}
        diff |= tag[i] ^ SEC_SUCCESS_CONSTANT ^ check_tag[i];
 c04e46a:	f817 cb01 	ldrb.w	ip, [r7], #1
 c04e46e:	f812 3b01 	ldrb.w	r3, [r2], #1
 c04e472:	ea83 030c 	eor.w	r3, r3, ip
        inv_diff &= tag[i] ^ SEC_SUCCESS_CONSTANT ^ check_tag[i];
 c04e476:	f89d c027 	ldrb.w	ip, [sp, #39]	@ 0x27
        diff |= tag[i] ^ SEC_SUCCESS_CONSTANT ^ check_tag[i];
 c04e47a:	f083 033a 	eor.w	r3, r3, #58	@ 0x3a
 c04e47e:	4318      	orrs	r0, r3
        inv_diff &= tag[i] ^ SEC_SUCCESS_CONSTANT ^ check_tag[i];
 c04e480:	ea03 030c 	and.w	r3, r3, ip
 c04e484:	f88d 3027 	strb.w	r3, [sp, #39]	@ 0x27
    for( i = 0; i < tag_len; i++ )
 c04e488:	e7e4      	b.n	c04e454 <mbedtls_gcm_auth_decrypt+0x36>
    if( ( diff != SEC_SUCCESS_CONSTANT ) || ( inv_diff != SEC_SUCCESS_CONSTANT ) )
 c04e48a:	283a      	cmp	r0, #58	@ 0x3a
 c04e48c:	d1e5      	bne.n	c04e45a <mbedtls_gcm_auth_decrypt+0x3c>
 c04e48e:	f89d 3027 	ldrb.w	r3, [sp, #39]	@ 0x27
 c04e492:	2b3a      	cmp	r3, #58	@ 0x3a
 c04e494:	d1e1      	bne.n	c04e45a <mbedtls_gcm_auth_decrypt+0x3c>
    return( (diff ^ inv_diff) + j );
 c04e496:	f89d 0027 	ldrb.w	r0, [sp, #39]	@ 0x27
 c04e49a:	f080 003a 	eor.w	r0, r0, #58	@ 0x3a
 c04e49e:	e7e2      	b.n	c04e466 <mbedtls_gcm_auth_decrypt+0x48>

0c04e4a0 <mbedtls_gcm_free>:

void mbedtls_gcm_free( mbedtls_gcm_context *ctx )
{
    if( ctx == NULL )
 c04e4a0:	b118      	cbz	r0, c04e4aa <mbedtls_gcm_free+0xa>
        return;

    mbedtls_platform_zeroize( ctx, sizeof( mbedtls_gcm_context ) );
 c04e4a2:	f44f 71ec 	mov.w	r1, #472	@ 0x1d8
 c04e4a6:	f7ec bf93 	b.w	c03b3d0 <mbedtls_platform_zeroize>
}
 c04e4aa:	4770      	bx	lr

0c04e4ac <USART_GetVersion>:
  0  /* Reserved */
};

static ARM_DRIVER_VERSION USART_GetVersion(void)
{
  return DriverVersion;
 c04e4ac:	4b06      	ldr	r3, [pc, #24]	@ (c04e4c8 <USART_GetVersion+0x1c>)
{
 c04e4ae:	b082      	sub	sp, #8
  return DriverVersion;
 c04e4b0:	6818      	ldr	r0, [r3, #0]
 c04e4b2:	2300      	movs	r3, #0
 c04e4b4:	b282      	uxth	r2, r0
 c04e4b6:	f362 030f 	bfi	r3, r2, #0, #16
 c04e4ba:	0c00      	lsrs	r0, r0, #16
 c04e4bc:	f360 431f 	bfi	r3, r0, #16, #16
}
 c04e4c0:	4618      	mov	r0, r3
 c04e4c2:	b002      	add	sp, #8
 c04e4c4:	4770      	bx	lr
 c04e4c6:	bf00      	nop
 c04e4c8:	0c05f7f0 	.word	0x0c05f7f0

0c04e4cc <USART_GetCapabilities>:

static ARM_USART_CAPABILITIES USART_GetCapabilities(void)
{
  return DriverCapabilities;
}
 c04e4cc:	2001      	movs	r0, #1
 c04e4ce:	4770      	bx	lr

0c04e4d0 <USART0_Uninitialize>:

static int32_t USART0_Uninitialize(void)
{
  /* Nothing to be done */
  return ARM_DRIVER_OK;
}
 c04e4d0:	2000      	movs	r0, #0
 c04e4d2:	4770      	bx	lr

0c04e4d4 <USART0_PowerControl>:

static int32_t USART0_PowerControl(ARM_POWER_STATE state)
{
  return ARM_DRIVER_OK;
}
 c04e4d4:	2000      	movs	r0, #0
 c04e4d6:	4770      	bx	lr

0c04e4d8 <USART0_Transfer>:
  ARG_UNUSED(data_out);
  ARG_UNUSED(data_in);
  ARG_UNUSED(num);

  return ARM_DRIVER_ERROR_UNSUPPORTED;
}
 c04e4d8:	f06f 0003 	mvn.w	r0, #3
 c04e4dc:	4770      	bx	lr

0c04e4de <USART0_GetTxCount>:

static uint32_t USART0_GetTxCount(void)
{
  return 0;
}
 c04e4de:	2000      	movs	r0, #0
 c04e4e0:	4770      	bx	lr

0c04e4e2 <USART0_Control>:
  return 0;
}
static int32_t USART0_Control(uint32_t control, uint32_t arg)
{
  return ARM_DRIVER_OK;
}
 c04e4e2:	2000      	movs	r0, #0
 c04e4e4:	4770      	bx	lr

0c04e4e6 <USART0_GetStatus>:

static ARM_USART_STATUS USART0_GetStatus(void)
{
  ARM_USART_STATUS status = {0, 0, 0, 0, 0, 0, 0, 0};
 c04e4e6:	2300      	movs	r3, #0
{
 c04e4e8:	b082      	sub	sp, #8
  ARM_USART_STATUS status = {0, 0, 0, 0, 0, 0, 0, 0};
 c04e4ea:	9301      	str	r3, [sp, #4]
  return status;
 c04e4ec:	9801      	ldr	r0, [sp, #4]
}
 c04e4ee:	b002      	add	sp, #8
 c04e4f0:	4770      	bx	lr

0c04e4f2 <USART0_SetModemControl>:

static int32_t USART0_SetModemControl(ARM_USART_MODEM_CONTROL control)
{
  ARG_UNUSED(control);
  return ARM_DRIVER_ERROR_UNSUPPORTED;
}
 c04e4f2:	f06f 0003 	mvn.w	r0, #3
 c04e4f6:	4770      	bx	lr

0c04e4f8 <USART0_GetModemStatus>:

static ARM_USART_MODEM_STATUS USART0_GetModemStatus(void)
{
  ARM_USART_MODEM_STATUS modem_status = {0, 0, 0, 0, 0};
 c04e4f8:	2300      	movs	r3, #0
{
 c04e4fa:	b082      	sub	sp, #8
  ARM_USART_MODEM_STATUS modem_status = {0, 0, 0, 0, 0};
 c04e4fc:	9301      	str	r3, [sp, #4]
  return modem_status;
 c04e4fe:	9801      	ldr	r0, [sp, #4]
}
 c04e500:	b002      	add	sp, #8
 c04e502:	4770      	bx	lr

0c04e504 <USART0_Receive>:
{
 c04e504:	b510      	push	{r4, lr}
 c04e506:	460c      	mov	r4, r1
  if ((data == NULL) || (num == 0U))
 c04e508:	4601      	mov	r1, r0
 c04e50a:	b130      	cbz	r0, c04e51a <USART0_Receive+0x16>
 c04e50c:	b12c      	cbz	r4, c04e51a <USART0_Receive+0x16>
  HAL_UART_Receive_IT(&uart_device, data, num);
 c04e50e:	4804      	ldr	r0, [pc, #16]	@ (c04e520 <USART0_Receive+0x1c>)
 c04e510:	b2a2      	uxth	r2, r4
 c04e512:	f7f3 fd97 	bl	c042044 <HAL_UART_Receive_IT>
  return num;
 c04e516:	4620      	mov	r0, r4
}
 c04e518:	bd10      	pop	{r4, pc}
    return ARM_DRIVER_ERROR_PARAMETER;
 c04e51a:	f06f 0004 	mvn.w	r0, #4
 c04e51e:	e7fb      	b.n	c04e518 <USART0_Receive+0x14>
 c04e520:	30030b5c 	.word	0x30030b5c

0c04e524 <USART0_Send>:
{
 c04e524:	460a      	mov	r2, r1
 c04e526:	b508      	push	{r3, lr}
  if ((data == NULL) || (num == 0U))
 c04e528:	4601      	mov	r1, r0
 c04e52a:	b140      	cbz	r0, c04e53e <USART0_Send+0x1a>
 c04e52c:	b13a      	cbz	r2, c04e53e <USART0_Send+0x1a>
  HAL_UART_Transmit(&uart_device, (uint8_t *) data, num,  1000);
 c04e52e:	f44f 737a 	mov.w	r3, #1000	@ 0x3e8
 c04e532:	4804      	ldr	r0, [pc, #16]	@ (c04e544 <USART0_Send+0x20>)
 c04e534:	b292      	uxth	r2, r2
 c04e536:	f7f3 fc18 	bl	c041d6a <HAL_UART_Transmit>
  return ARM_DRIVER_OK;
 c04e53a:	2000      	movs	r0, #0
}
 c04e53c:	bd08      	pop	{r3, pc}
    return ARM_DRIVER_ERROR_PARAMETER;
 c04e53e:	f06f 0004 	mvn.w	r0, #4
 c04e542:	e7fb      	b.n	c04e53c <USART0_Send+0x18>
 c04e544:	30030b5c 	.word	0x30030b5c

0c04e548 <USART0_Initialize>:
  COM_TX_GPIO_CLK_ENABLE();
 c04e548:	4b2b      	ldr	r3, [pc, #172]	@ (c04e5f8 <USART0_Initialize+0xb0>)
{
 c04e54a:	b570      	push	{r4, r5, r6, lr}
  COM_TX_GPIO_CLK_ENABLE();
 c04e54c:	f8d3 208c 	ldr.w	r2, [r3, #140]	@ 0x8c
{
 c04e550:	b088      	sub	sp, #32
  COM_TX_GPIO_CLK_ENABLE();
 c04e552:	f042 0201 	orr.w	r2, r2, #1
 c04e556:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
 c04e55a:	f8d3 208c 	ldr.w	r2, [r3, #140]	@ 0x8c
  GPIO_Init.Pull      = GPIO_NOPULL;
 c04e55e:	2400      	movs	r4, #0
  COM_TX_GPIO_CLK_ENABLE();
 c04e560:	f002 0201 	and.w	r2, r2, #1
 c04e564:	9200      	str	r2, [sp, #0]
 c04e566:	9a00      	ldr	r2, [sp, #0]
  COM_RX_GPIO_CLK_ENABLE();
 c04e568:	f8d3 208c 	ldr.w	r2, [r3, #140]	@ 0x8c
  GPIO_Init.Alternate = COM_TX_AF;
 c04e56c:	2607      	movs	r6, #7
  COM_RX_GPIO_CLK_ENABLE();
 c04e56e:	f042 0201 	orr.w	r2, r2, #1
 c04e572:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
 c04e576:	f8d3 208c 	ldr.w	r2, [r3, #140]	@ 0x8c
  HAL_GPIO_Init(COM_TX_GPIO_PORT, &GPIO_Init);
 c04e57a:	4d20      	ldr	r5, [pc, #128]	@ (c04e5fc <USART0_Initialize+0xb4>)
  COM_RX_GPIO_CLK_ENABLE();
 c04e57c:	f002 0201 	and.w	r2, r2, #1
 c04e580:	9201      	str	r2, [sp, #4]
 c04e582:	9a01      	ldr	r2, [sp, #4]
  COM_CLK_ENABLE();
 c04e584:	f8d3 20a4 	ldr.w	r2, [r3, #164]	@ 0xa4
  HAL_GPIO_Init(COM_TX_GPIO_PORT, &GPIO_Init);
 c04e588:	4628      	mov	r0, r5
  COM_CLK_ENABLE();
 c04e58a:	f442 4280 	orr.w	r2, r2, #16384	@ 0x4000
 c04e58e:	f8c3 20a4 	str.w	r2, [r3, #164]	@ 0xa4
 c04e592:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
  GPIO_Init.Mode      = GPIO_MODE_AF_PP;
 c04e596:	f44f 7200 	mov.w	r2, #512	@ 0x200
  COM_CLK_ENABLE();
 c04e59a:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
 c04e59e:	9302      	str	r3, [sp, #8]
 c04e5a0:	9b02      	ldr	r3, [sp, #8]
  GPIO_Init.Mode      = GPIO_MODE_AF_PP;
 c04e5a2:	2302      	movs	r3, #2
  HAL_GPIO_Init(COM_TX_GPIO_PORT, &GPIO_Init);
 c04e5a4:	a903      	add	r1, sp, #12
  GPIO_Init.Mode      = GPIO_MODE_AF_PP;
 c04e5a6:	e9cd 2303 	strd	r2, r3, [sp, #12]
  GPIO_Init.Speed     = GPIO_SPEED_FREQ_HIGH;
 c04e5aa:	9306      	str	r3, [sp, #24]
  GPIO_Init.Pull      = GPIO_NOPULL;
 c04e5ac:	9405      	str	r4, [sp, #20]
  GPIO_Init.Alternate = COM_TX_AF;
 c04e5ae:	9607      	str	r6, [sp, #28]
  HAL_GPIO_Init(COM_TX_GPIO_PORT, &GPIO_Init);
 c04e5b0:	f7ef fd8c 	bl	c03e0cc <HAL_GPIO_Init>
  GPIO_Init.Pin       = COM_RX_PIN;
 c04e5b4:	f44f 6380 	mov.w	r3, #1024	@ 0x400
  HAL_GPIO_Init(COM_RX_GPIO_PORT, &GPIO_Init);
 c04e5b8:	4628      	mov	r0, r5
 c04e5ba:	a903      	add	r1, sp, #12
  GPIO_Init.Pin       = COM_RX_PIN;
 c04e5bc:	9303      	str	r3, [sp, #12]
  GPIO_Init.Alternate = COM_RX_AF;
 c04e5be:	9607      	str	r6, [sp, #28]
  HAL_GPIO_Init(COM_RX_GPIO_PORT, &GPIO_Init);
 c04e5c0:	f7ef fd84 	bl	c03e0cc <HAL_GPIO_Init>
  uart_device.Init.BaudRate       = 115200;
 c04e5c4:	f44f 33e1 	mov.w	r3, #115200	@ 0x1c200
  uart_device.Instance = COM_INSTANCE;
 c04e5c8:	480d      	ldr	r0, [pc, #52]	@ (c04e600 <USART0_Initialize+0xb8>)
  uart_device.Init.BaudRate       = 115200;
 c04e5ca:	490e      	ldr	r1, [pc, #56]	@ (c04e604 <USART0_Initialize+0xbc>)
  uart_device.Init.StopBits       = UART_STOPBITS_1;
 c04e5cc:	e9c0 4402 	strd	r4, r4, [r0, #8]
  uart_device.Init.BaudRate       = 115200;
 c04e5d0:	e9c0 1300 	strd	r1, r3, [r0]
  uart_device.Init.Mode           = UART_MODE_TX_RX;
 c04e5d4:	230c      	movs	r3, #12
  uart_device.Init.HwFlowCtl      = UART_HWCONTROL_NONE;
 c04e5d6:	e9c0 3405 	strd	r3, r4, [r0, #20]
  uart_device.Init.OverSampling   = UART_OVERSAMPLING_8;
 c04e5da:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
  uart_device.Init.Parity         = UART_PARITY_NONE;
 c04e5de:	6104      	str	r4, [r0, #16]
  uart_device.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
 c04e5e0:	e9c0 3407 	strd	r3, r4, [r0, #28]
  uart_device.Init.ClockPrescaler = UART_PRESCALER_DIV1;
 c04e5e4:	6244      	str	r4, [r0, #36]	@ 0x24
  if (HAL_UART_Init(&uart_device) != HAL_OK)
 c04e5e6:	f7f3 fc78 	bl	c041eda <HAL_UART_Init>
 c04e5ea:	1b00      	subs	r0, r0, r4
 c04e5ec:	bf18      	it	ne
 c04e5ee:	2001      	movne	r0, #1
}
 c04e5f0:	4240      	negs	r0, r0
 c04e5f2:	b008      	add	sp, #32
 c04e5f4:	bd70      	pop	{r4, r5, r6, pc}
 c04e5f6:	bf00      	nop
 c04e5f8:	56020c00 	.word	0x56020c00
 c04e5fc:	52020000 	.word	0x52020000
 c04e600:	30030b5c 	.word	0x30030b5c
 c04e604:	50013800 	.word	0x50013800

0c04e608 <USART0_GetRxCount>:
static uint32_t USART0_GetRxCount(void)
 c04e608:	2000      	movs	r0, #0
 c04e60a:	4770      	bx	lr

0c04e60c <memcpy_flash>:
};

#if !defined(LOCAL_LOADER_CONFIG)
__attribute__((naked)) static void memcpy_flash(void *dest, const void *src, size_t n)
{
    __ASM volatile(
 c04e60c:	2a04      	cmp	r2, #4
 c04e60e:	db09      	blt.n	c04e624 <testbyte>

0c04e610 <loopwords>:
 c04e610:	680b      	ldr	r3, [r1, #0]
 c04e612:	6003      	str	r3, [r0, #0]
 c04e614:	f100 0004 	add.w	r0, r0, #4
 c04e618:	f101 0104 	add.w	r1, r1, #4
 c04e61c:	f1a2 0204 	sub.w	r2, r2, #4
 c04e620:	2a04      	cmp	r2, #4
 c04e622:	daf5      	bge.n	c04e610 <loopwords>

0c04e624 <testbyte>:
 c04e624:	2a00      	cmp	r2, #0
 c04e626:	d009      	beq.n	c04e63c <finish>

0c04e628 <loopbytes>:
 c04e628:	780b      	ldrb	r3, [r1, #0]
 c04e62a:	7003      	strb	r3, [r0, #0]
 c04e62c:	f100 0001 	add.w	r0, r0, #1
 c04e630:	f101 0101 	add.w	r1, r1, #1
 c04e634:	f1a2 0201 	sub.w	r2, r2, #1
 c04e638:	2a01      	cmp	r2, #1
 c04e63a:	daf5      	bge.n	c04e628 <loopbytes>

0c04e63c <finish>:
 c04e63c:	4770      	bx	lr
	...

0c04e640 <Flash_GetVersion>:
static ARM_FLASH_STATUS ARM_FLASH0_STATUS = {0, 0, 0};

#if !defined(LOCAL_LOADER_CONFIG)
static ARM_DRIVER_VERSION Flash_GetVersion(void)
{
  return DriverVersion;
 c04e640:	4b06      	ldr	r3, [pc, #24]	@ (c04e65c <Flash_GetVersion+0x1c>)
{
 c04e642:	b082      	sub	sp, #8
  return DriverVersion;
 c04e644:	6818      	ldr	r0, [r3, #0]
 c04e646:	2300      	movs	r3, #0
 c04e648:	b282      	uxth	r2, r0
 c04e64a:	f362 030f 	bfi	r3, r2, #0, #16
 c04e64e:	0c00      	lsrs	r0, r0, #16
 c04e650:	f360 431f 	bfi	r3, r0, #16, #16
}
 c04e654:	4618      	mov	r0, r3
 c04e656:	b002      	add	sp, #8
 c04e658:	4770      	bx	lr
 c04e65a:	bf00      	nop
 c04e65c:	0c05f838 	.word	0x0c05f838

0c04e660 <Flash_GetCapabilities>:

static ARM_FLASH_CAPABILITIES Flash_GetCapabilities(void)
{
  return DriverCapabilities;
}
 c04e660:	200c      	movs	r0, #12
 c04e662:	4770      	bx	lr

0c04e664 <Flash_Uninitialize>:
}
#if !defined(LOCAL_LOADER_CONFIG)
static int32_t Flash_Uninitialize(void)
{
  return ARM_DRIVER_OK;
}
 c04e664:	2000      	movs	r0, #0
 c04e666:	4770      	bx	lr

0c04e668 <Flash_PowerControl>:

static int32_t Flash_PowerControl(ARM_POWER_STATE state)
{
  switch (state)
 c04e668:	2801      	cmp	r0, #1
 c04e66a:	d905      	bls.n	c04e678 <Flash_PowerControl+0x10>
      return ARM_DRIVER_OK;
    case ARM_POWER_OFF:
    case ARM_POWER_LOW:
      return ARM_DRIVER_ERROR_UNSUPPORTED;
    default:
      return ARM_DRIVER_ERROR_PARAMETER;
 c04e66c:	2802      	cmp	r0, #2
 c04e66e:	bf0c      	ite	eq
 c04e670:	2000      	moveq	r0, #0
 c04e672:	f06f 0004 	mvnne.w	r0, #4
 c04e676:	4770      	bx	lr
  switch (state)
 c04e678:	f06f 0003 	mvn.w	r0, #3
  }
}
 c04e67c:	4770      	bx	lr

0c04e67e <Flash_EraseChip>:
}
#if !defined(LOCAL_LOADER_CONFIG)
static int32_t Flash_EraseChip(void)
{
  return ARM_DRIVER_ERROR_UNSUPPORTED;
}
 c04e67e:	f06f 0003 	mvn.w	r0, #3
 c04e682:	4770      	bx	lr

0c04e684 <Flash_GetStatus>:

static ARM_FLASH_STATUS Flash_GetStatus(void)
{
  return ARM_FLASH0_STATUS;
 c04e684:	4b01      	ldr	r3, [pc, #4]	@ (c04e68c <Flash_GetStatus+0x8>)
 c04e686:	6818      	ldr	r0, [r3, #0]
}
 c04e688:	4770      	bx	lr
 c04e68a:	bf00      	nop
 c04e68c:	30030bf0 	.word	0x30030bf0

0c04e690 <Flash_GetInfo>:
#endif
static ARM_FLASH_INFO *Flash_GetInfo(void)
{
  return ARM_FLASH0_DEV.data;
}
 c04e690:	4800      	ldr	r0, [pc, #0]	@ (c04e694 <Flash_GetInfo+0x4>)
 c04e692:	4770      	bx	lr
 c04e694:	0c05f820 	.word	0x0c05f820

0c04e698 <Flash_Initialize>:
{
 c04e698:	b508      	push	{r3, lr}
  FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 c04e69a:	f44f 707a 	mov.w	r0, #1000	@ 0x3e8
 c04e69e:	f7ef fc07 	bl	c03deb0 <FLASH_WaitForLastOperation>
}
 c04e6a2:	2000      	movs	r0, #0
 c04e6a4:	bd08      	pop	{r3, pc}
	...

0c04e6a8 <is_range_secure.constprop.0>:
  if (!vect->range)
 c04e6a8:	4b0c      	ldr	r3, [pc, #48]	@ (c04e6dc <is_range_secure.constprop.0+0x34>)
static bool is_range_secure(struct arm_flash_dev_t *flash_dev,
 c04e6aa:	b570      	push	{r4, r5, r6, lr}
  if (!vect->range)
 c04e6ac:	695a      	ldr	r2, [r3, #20]
 c04e6ae:	b192      	cbz	r2, c04e6d6 <is_range_secure.constprop.0+0x2e>
  for (nb = 0; nb < vect->nb; nb++)
 c04e6b0:	691c      	ldr	r4, [r3, #16]
 c04e6b2:	2300      	movs	r3, #0
    if ((start >= vect->range[nb].base) && ((start + len - 1) <= vect->range[nb].limit))
 c04e6b4:	3901      	subs	r1, #1
 c04e6b6:	4401      	add	r1, r0
 c04e6b8:	1d15      	adds	r5, r2, #4
  for (nb = 0; nb < vect->nb; nb++)
 c04e6ba:	42a3      	cmp	r3, r4
 c04e6bc:	d101      	bne.n	c04e6c2 <is_range_secure.constprop.0+0x1a>
  return false;
 c04e6be:	2000      	movs	r0, #0
}
 c04e6c0:	bd70      	pop	{r4, r5, r6, pc}
    if ((start >= vect->range[nb].base) && ((start + len - 1) <= vect->range[nb].limit))
 c04e6c2:	f852 6033 	ldr.w	r6, [r2, r3, lsl #3]
 c04e6c6:	4286      	cmp	r6, r0
 c04e6c8:	d803      	bhi.n	c04e6d2 <is_range_secure.constprop.0+0x2a>
 c04e6ca:	f855 6033 	ldr.w	r6, [r5, r3, lsl #3]
 c04e6ce:	42b1      	cmp	r1, r6
 c04e6d0:	d901      	bls.n	c04e6d6 <is_range_secure.constprop.0+0x2e>
  for (nb = 0; nb < vect->nb; nb++)
 c04e6d2:	3301      	adds	r3, #1
 c04e6d4:	e7f1      	b.n	c04e6ba <is_range_secure.constprop.0+0x12>
    return true;
 c04e6d6:	2001      	movs	r0, #1
 c04e6d8:	e7f2      	b.n	c04e6c0 <is_range_secure.constprop.0+0x18>
 c04e6da:	bf00      	nop
 c04e6dc:	3003081c 	.word	0x3003081c

0c04e6e0 <Flash_ReadData>:
{
 c04e6e0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  ARM_FLASH0_STATUS.error = DRIVER_STATUS_NO_ERROR;
 c04e6e2:	4b1b      	ldr	r3, [pc, #108]	@ (c04e750 <Flash_ReadData+0x70>)
{
 c04e6e4:	460d      	mov	r5, r1
  ARM_FLASH0_STATUS.error = DRIVER_STATUS_NO_ERROR;
 c04e6e6:	6819      	ldr	r1, [r3, #0]
{
 c04e6e8:	4606      	mov	r6, r0
  ARM_FLASH0_STATUS.error = DRIVER_STATUS_NO_ERROR;
 c04e6ea:	f36f 0141 	bfc	r1, #1, #1
 c04e6ee:	6019      	str	r1, [r3, #0]
  is_valid = is_range_valid(&ARM_FLASH0_DEV, addr + cnt - 1);
 c04e6f0:	1e51      	subs	r1, r2, #1
 c04e6f2:	4401      	add	r1, r0
  if (is_valid != true)
 c04e6f4:	f5b1 1f00 	cmp.w	r1, #2097152	@ 0x200000
{
 c04e6f8:	4614      	mov	r4, r2
  if (is_valid != true)
 c04e6fa:	d30f      	bcc.n	c04e71c <Flash_ReadData+0x3c>
    if (ARM_FLASH0_DEV.dev->read_error)
 c04e6fc:	4915      	ldr	r1, [pc, #84]	@ (c04e754 <Flash_ReadData+0x74>)
 c04e6fe:	698c      	ldr	r4, [r1, #24]
 c04e700:	b134      	cbz	r4, c04e710 <Flash_ReadData+0x30>
      return ARM_DRIVER_ERROR_PARAMETER;
 c04e702:	f06f 0004 	mvn.w	r0, #4
      ARM_FLASH0_STATUS.error = DRIVER_STATUS_ERROR;
 c04e706:	681a      	ldr	r2, [r3, #0]
 c04e708:	f042 0202 	orr.w	r2, r2, #2
 c04e70c:	601a      	str	r2, [r3, #0]
}
 c04e70e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    memset(data, 0xff, cnt);
 c04e710:	21ff      	movs	r1, #255	@ 0xff
 c04e712:	4628      	mov	r0, r5
 c04e714:	f00d f80b 	bl	c05b72e <memset>
    return ARM_DRIVER_OK;
 c04e718:	4620      	mov	r0, r4
 c04e71a:	e7f8      	b.n	c04e70e <Flash_ReadData+0x2e>
  DoubleECC_Error_Counter = 0U;
 c04e71c:	2300      	movs	r3, #0
 c04e71e:	4f0e      	ldr	r7, [pc, #56]	@ (c04e758 <Flash_ReadData+0x78>)
  if (is_range_secure(&ARM_FLASH0_DEV, addr, cnt))
 c04e720:	4611      	mov	r1, r2
  DoubleECC_Error_Counter = 0U;
 c04e722:	603b      	str	r3, [r7, #0]
  if (is_range_secure(&ARM_FLASH0_DEV, addr, cnt))
 c04e724:	f7ff ffc0 	bl	c04e6a8 <is_range_secure.constprop.0>
    memcpy_flash(data, (void *)((uint32_t)addr + FLASH_BASE), cnt);
 c04e728:	4622      	mov	r2, r4
  if (is_range_secure(&ARM_FLASH0_DEV, addr, cnt))
 c04e72a:	b170      	cbz	r0, c04e74a <Flash_ReadData+0x6a>
    memcpy_flash(data, (void *)((uint32_t)addr + FLASH_BASE), cnt);
 c04e72c:	f106 6140 	add.w	r1, r6, #201326592	@ 0xc000000
    memcpy_flash(data, (void *)((uint32_t)addr + FLASH_BASE_NS), cnt);
 c04e730:	4628      	mov	r0, r5
 c04e732:	f7ff ff6b 	bl	c04e60c <memcpy_flash>
  if (DoubleECC_Error_Counter == 0U)
 c04e736:	683b      	ldr	r3, [r7, #0]
  int32_t ret = ARM_DRIVER_ERROR_SPECIFIC;
 c04e738:	2b00      	cmp	r3, #0
  DoubleECC_Error_Counter = 0U;
 c04e73a:	f04f 0300 	mov.w	r3, #0
  int32_t ret = ARM_DRIVER_ERROR_SPECIFIC;
 c04e73e:	bf0c      	ite	eq
 c04e740:	2000      	moveq	r0, #0
 c04e742:	f06f 0005 	mvnne.w	r0, #5
  DoubleECC_Error_Counter = 0U;
 c04e746:	603b      	str	r3, [r7, #0]
  return ret;
 c04e748:	e7e1      	b.n	c04e70e <Flash_ReadData+0x2e>
    memcpy_flash(data, (void *)((uint32_t)addr + FLASH_BASE_NS), cnt);
 c04e74a:	f106 6100 	add.w	r1, r6, #134217728	@ 0x8000000
 c04e74e:	e7ef      	b.n	c04e730 <Flash_ReadData+0x50>
 c04e750:	30030bf0 	.word	0x30030bf0
 c04e754:	3003081c 	.word	0x3003081c
 c04e758:	30030bf4 	.word	0x30030bf4

0c04e75c <Flash_ProgramData>:
{
 c04e75c:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
  ARM_FLASH0_STATUS.error = DRIVER_STATUS_NO_ERROR;
 c04e760:	4e39      	ldr	r6, [pc, #228]	@ (c04e848 <Flash_ProgramData+0xec>)
{
 c04e762:	4617      	mov	r7, r2
  ARM_FLASH0_STATUS.error = DRIVER_STATUS_NO_ERROR;
 c04e764:	6833      	ldr	r3, [r6, #0]
{
 c04e766:	4689      	mov	r9, r1
  ARM_FLASH0_STATUS.error = DRIVER_STATUS_NO_ERROR;
 c04e768:	f36f 0341 	bfc	r3, #1, #1
  if (is_range_secure(&ARM_FLASH0_DEV, addr, cnt))
 c04e76c:	4611      	mov	r1, r2
  ARM_FLASH0_STATUS.error = DRIVER_STATUS_NO_ERROR;
 c04e76e:	6033      	str	r3, [r6, #0]
{
 c04e770:	4604      	mov	r4, r0
  if (is_range_secure(&ARM_FLASH0_DEV, addr, cnt))
 c04e772:	f7ff ff99 	bl	c04e6a8 <is_range_secure.constprop.0>
    write_type = FLASH_TYPEPROGRAM_QUADWORD;
 c04e776:	4b35      	ldr	r3, [pc, #212]	@ (c04e84c <Flash_ProgramData+0xf0>)
  if ((!is_range_valid(&ARM_FLASH0_DEV, addr + cnt - 1)) ||
 c04e778:	1e7a      	subs	r2, r7, #1
    write_type = FLASH_TYPEPROGRAM_QUADWORD;
 c04e77a:	2800      	cmp	r0, #0
  if ((!is_range_valid(&ARM_FLASH0_DEV, addr + cnt - 1)) ||
 c04e77c:	4422      	add	r2, r4
    write_type = FLASH_TYPEPROGRAM_QUADWORD;
 c04e77e:	bf0b      	itete	eq
 c04e780:	4698      	moveq	r8, r3
 c04e782:	f04f 0801 	movne.w	r8, #1
 c04e786:	f04f 6a00 	moveq.w	sl, #134217728	@ 0x8000000
 c04e78a:	f04f 6a40 	movne.w	sl, #201326592	@ 0xc000000
  if ((!is_range_valid(&ARM_FLASH0_DEV, addr + cnt - 1)) ||
 c04e78e:	f5b2 1f00 	cmp.w	r2, #2097152	@ 0x200000
 c04e792:	d20c      	bcs.n	c04e7ae <Flash_ProgramData+0x52>
 c04e794:	ea44 0507 	orr.w	r5, r4, r7
      (!is_write_aligned(&ARM_FLASH0_DEV, addr))     ||
 c04e798:	f015 050f 	ands.w	r5, r5, #15
 c04e79c:	d107      	bne.n	c04e7ae <Flash_ProgramData+0x52>
  for (nb = 0; nb < vect->nb; nb++)
 c04e79e:	4b2c      	ldr	r3, [pc, #176]	@ (c04e850 <Flash_ProgramData+0xf4>)
    if ((start >= vect->range[nb].base) && ((start + len - 1) <= vect->range[nb].limit))
 c04e7a0:	e9d3 1002 	ldrd	r1, r0, [r3, #8]
  for (nb = 0; nb < vect->nb; nb++)
 c04e7a4:	462b      	mov	r3, r5
    if ((start >= vect->range[nb].base) && ((start + len - 1) <= vect->range[nb].limit))
 c04e7a6:	f100 0e04 	add.w	lr, r0, #4
  for (nb = 0; nb < vect->nb; nb++)
 c04e7aa:	428b      	cmp	r3, r1
 c04e7ac:	d108      	bne.n	c04e7c0 <Flash_ProgramData+0x64>
    return ARM_DRIVER_ERROR_PARAMETER;
 c04e7ae:	f06f 0004 	mvn.w	r0, #4
    ARM_FLASH0_STATUS.error = DRIVER_STATUS_ERROR;
 c04e7b2:	6833      	ldr	r3, [r6, #0]
 c04e7b4:	f043 0302 	orr.w	r3, r3, #2
 c04e7b8:	6033      	str	r3, [r6, #0]
}
 c04e7ba:	b004      	add	sp, #16
 c04e7bc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if ((start >= vect->range[nb].base) && ((start + len - 1) <= vect->range[nb].limit))
 c04e7c0:	f850 c033 	ldr.w	ip, [r0, r3, lsl #3]
 c04e7c4:	4564      	cmp	r4, ip
 c04e7c6:	d303      	bcc.n	c04e7d0 <Flash_ProgramData+0x74>
 c04e7c8:	f85e c033 	ldr.w	ip, [lr, r3, lsl #3]
 c04e7cc:	4562      	cmp	r2, ip
 c04e7ce:	d903      	bls.n	c04e7d8 <Flash_ProgramData+0x7c>
  for (nb = 0; nb < vect->nb; nb++)
 c04e7d0:	3301      	adds	r3, #1
 c04e7d2:	e7ea      	b.n	c04e7aa <Flash_ProgramData+0x4e>
        err = HAL_OK;
 c04e7d4:	2400      	movs	r4, #0
 c04e7d6:	e026      	b.n	c04e826 <Flash_ProgramData+0xca>
  HAL_FLASH_Unlock();
 c04e7d8:	f7ef fb30 	bl	c03de3c <HAL_FLASH_Unlock>
  ARM_FLASH0_STATUS.busy = DRIVER_STATUS_BUSY;
 c04e7dc:	6833      	ldr	r3, [r6, #0]
        err = HAL_FLASH_Program(write_type, (flash_base + addr), (uint32_t)&dword[0]);
 c04e7de:	44a2      	add	sl, r4
  ARM_FLASH0_STATUS.busy = DRIVER_STATUS_BUSY;
 c04e7e0:	f043 0301 	orr.w	r3, r3, #1
 c04e7e4:	6033      	str	r3, [r6, #0]
    memcpy(dword, (void *)((uint32_t)data + loop), sizeof(dword));
 c04e7e6:	466c      	mov	r4, sp
 c04e7e8:	eb09 0305 	add.w	r3, r9, r5
 c04e7ec:	f103 0c10 	add.w	ip, r3, #16
 c04e7f0:	4622      	mov	r2, r4
 c04e7f2:	6818      	ldr	r0, [r3, #0]
 c04e7f4:	6859      	ldr	r1, [r3, #4]
 c04e7f6:	3308      	adds	r3, #8
 c04e7f8:	c203      	stmia	r2!, {r0, r1}
 c04e7fa:	4563      	cmp	r3, ip
 c04e7fc:	4614      	mov	r4, r2
 c04e7fe:	d1f7      	bne.n	c04e7f0 <Flash_ProgramData+0x94>
    if ((dword[0] != -1) || (dword[1] != -1))
 c04e800:	9b00      	ldr	r3, [sp, #0]
 c04e802:	9a02      	ldr	r2, [sp, #8]
 c04e804:	9903      	ldr	r1, [sp, #12]
 c04e806:	401a      	ands	r2, r3
 c04e808:	9b01      	ldr	r3, [sp, #4]
 c04e80a:	400b      	ands	r3, r1
 c04e80c:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 c04e810:	bf08      	it	eq
 c04e812:	f1b2 3fff 	cmpeq.w	r2, #4294967295	@ 0xffffffff
 c04e816:	d0dd      	beq.n	c04e7d4 <Flash_ProgramData+0x78>
        err = HAL_FLASH_Program(write_type, (flash_base + addr), (uint32_t)&dword[0]);
 c04e818:	466a      	mov	r2, sp
 c04e81a:	4640      	mov	r0, r8
 c04e81c:	eb0a 0105 	add.w	r1, sl, r5
 c04e820:	f7ef fb84 	bl	c03df2c <HAL_FLASH_Program>
 c04e824:	4604      	mov	r4, r0
    loop += sizeof(dword);
 c04e826:	3510      	adds	r5, #16
  } while ((loop != cnt) && (err == HAL_OK));
 c04e828:	42af      	cmp	r7, r5
 c04e82a:	d001      	beq.n	c04e830 <Flash_ProgramData+0xd4>
 c04e82c:	2c00      	cmp	r4, #0
 c04e82e:	d0da      	beq.n	c04e7e6 <Flash_ProgramData+0x8a>
  ARM_FLASH0_STATUS.busy = DRIVER_STATUS_IDLE;
 c04e830:	6833      	ldr	r3, [r6, #0]
 c04e832:	f36f 0300 	bfc	r3, #0, #1
 c04e836:	6033      	str	r3, [r6, #0]
  HAL_FLASH_Lock();
 c04e838:	f7ef fb20 	bl	c03de7c <HAL_FLASH_Lock>
  return (err == HAL_OK) ? ARM_DRIVER_OK : ARM_DRIVER_ERROR;
 c04e83c:	1e20      	subs	r0, r4, #0
 c04e83e:	bf18      	it	ne
 c04e840:	2001      	movne	r0, #1
 c04e842:	4240      	negs	r0, r0
 c04e844:	e7b9      	b.n	c04e7ba <Flash_ProgramData+0x5e>
 c04e846:	bf00      	nop
 c04e848:	30030bf0 	.word	0x30030bf0
 c04e84c:	80000001 	.word	0x80000001
 c04e850:	3003081c 	.word	0x3003081c

0c04e854 <Flash_EraseSector>:
{
 c04e854:	b530      	push	{r4, r5, lr}
  if (!(is_range_valid(&ARM_FLASH0_DEV, addr)) ||
 c04e856:	f5b0 1f00 	cmp.w	r0, #2097152	@ 0x200000
{
 c04e85a:	4604      	mov	r4, r0
 c04e85c:	b087      	sub	sp, #28
  if (!(is_range_valid(&ARM_FLASH0_DEV, addr)) ||
 c04e85e:	d208      	bcs.n	c04e872 <Flash_EraseSector+0x1e>
  return ((param % (flash_dev->data->sector_size)) != 0) ? (false) : (true);
 c04e860:	f3c0 030c 	ubfx	r3, r0, #0, #13
  if (!(is_range_valid(&ARM_FLASH0_DEV, addr)) ||
 c04e864:	b92b      	cbnz	r3, c04e872 <Flash_EraseSector+0x1e>
  for (nb = 0; nb < vect->nb; nb++)
 c04e866:	4a23      	ldr	r2, [pc, #140]	@ (c04e8f4 <Flash_EraseSector+0xa0>)
    if ((param >= vect->range[nb].base) && (param <= vect->range[nb].limit))
 c04e868:	e9d2 1200 	ldrd	r1, r2, [r2]
 c04e86c:	1d10      	adds	r0, r2, #4
  for (nb = 0; nb < vect->nb; nb++)
 c04e86e:	428b      	cmp	r3, r1
 c04e870:	d108      	bne.n	c04e884 <Flash_EraseSector+0x30>
    return ARM_DRIVER_ERROR_PARAMETER;
 c04e872:	f06f 0004 	mvn.w	r0, #4
    ARM_FLASH0_STATUS.error = DRIVER_STATUS_ERROR;
 c04e876:	4a20      	ldr	r2, [pc, #128]	@ (c04e8f8 <Flash_EraseSector+0xa4>)
 c04e878:	6813      	ldr	r3, [r2, #0]
 c04e87a:	f043 0302 	orr.w	r3, r3, #2
 c04e87e:	6013      	str	r3, [r2, #0]
}
 c04e880:	b007      	add	sp, #28
 c04e882:	bd30      	pop	{r4, r5, pc}
    if ((param >= vect->range[nb].base) && (param <= vect->range[nb].limit))
 c04e884:	f852 5033 	ldr.w	r5, [r2, r3, lsl #3]
 c04e888:	42ac      	cmp	r4, r5
 c04e88a:	d303      	bcc.n	c04e894 <Flash_EraseSector+0x40>
 c04e88c:	f850 5033 	ldr.w	r5, [r0, r3, lsl #3]
 c04e890:	42ac      	cmp	r4, r5
 c04e892:	d901      	bls.n	c04e898 <Flash_EraseSector+0x44>
  for (nb = 0; nb < vect->nb; nb++)
 c04e894:	3301      	adds	r3, #1
 c04e896:	e7ea      	b.n	c04e86e <Flash_EraseSector+0x1a>
  if (is_range_secure(&ARM_FLASH0_DEV, addr, 4))
 c04e898:	2104      	movs	r1, #4
 c04e89a:	4620      	mov	r0, r4
 c04e89c:	f7ff ff04 	bl	c04e6a8 <is_range_secure.constprop.0>
    EraseInit.TypeErase = FLASH_TYPEERASE_PAGES_NS;
 c04e8a0:	2800      	cmp	r0, #0
 c04e8a2:	4b16      	ldr	r3, [pc, #88]	@ (c04e8fc <Flash_EraseSector+0xa8>)
 c04e8a4:	bf18      	it	ne
 c04e8a6:	2302      	movne	r3, #2
  return ((param >= (FLASH_TOTAL_SIZE / 2)) ? 2 : 1);
 c04e8a8:	f5b4 1f80 	cmp.w	r4, #1048576	@ 0x100000
 c04e8ac:	9302      	str	r3, [sp, #8]
 c04e8ae:	bf2c      	ite	cs
 c04e8b0:	2302      	movcs	r3, #2
 c04e8b2:	2301      	movcc	r3, #1
  EraseInit.Banks = bank_number(&ARM_FLASH0_DEV, addr);
 c04e8b4:	9303      	str	r3, [sp, #12]
  EraseInit.NbPages = 1;
 c04e8b6:	2301      	movs	r3, #1
  ARM_FLASH0_STATUS.error = DRIVER_STATUS_NO_ERROR;
 c04e8b8:	4d0f      	ldr	r5, [pc, #60]	@ (c04e8f8 <Flash_EraseSector+0xa4>)
  uint32_t page = param / flash_dev->data->page_size ;
 c04e8ba:	0b64      	lsrs	r4, r4, #13
  EraseInit.Page = page_number(&ARM_FLASH0_DEV, addr);
 c04e8bc:	9404      	str	r4, [sp, #16]
  EraseInit.NbPages = 1;
 c04e8be:	9305      	str	r3, [sp, #20]
  ARM_FLASH0_STATUS.error = DRIVER_STATUS_NO_ERROR;
 c04e8c0:	682b      	ldr	r3, [r5, #0]
 c04e8c2:	f36f 0341 	bfc	r3, #1, #1
 c04e8c6:	602b      	str	r3, [r5, #0]
  HAL_FLASH_Unlock();
 c04e8c8:	f7ef fab8 	bl	c03de3c <HAL_FLASH_Unlock>
  ARM_FLASH0_STATUS.busy = DRIVER_STATUS_BUSY;
 c04e8cc:	682b      	ldr	r3, [r5, #0]
  err = HAL_FLASHEx_Erase(&EraseInit, &pageError);
 c04e8ce:	a901      	add	r1, sp, #4
  ARM_FLASH0_STATUS.busy = DRIVER_STATUS_BUSY;
 c04e8d0:	f043 0301 	orr.w	r3, r3, #1
 c04e8d4:	602b      	str	r3, [r5, #0]
  err = HAL_FLASHEx_Erase(&EraseInit, &pageError);
 c04e8d6:	a802      	add	r0, sp, #8
 c04e8d8:	f7ef fba2 	bl	c03e020 <HAL_FLASHEx_Erase>
 c04e8dc:	4604      	mov	r4, r0
  ARM_FLASH0_STATUS.busy = DRIVER_STATUS_IDLE;
 c04e8de:	682b      	ldr	r3, [r5, #0]
 c04e8e0:	f36f 0300 	bfc	r3, #0, #1
 c04e8e4:	602b      	str	r3, [r5, #0]
  HAL_FLASH_Lock();
 c04e8e6:	f7ef fac9 	bl	c03de7c <HAL_FLASH_Lock>
  return (err == HAL_OK) ? ARM_DRIVER_OK : ARM_DRIVER_ERROR;
 c04e8ea:	1e20      	subs	r0, r4, #0
 c04e8ec:	bf18      	it	ne
 c04e8ee:	2001      	movne	r0, #1
 c04e8f0:	4240      	negs	r0, r0
 c04e8f2:	e7c5      	b.n	c04e880 <Flash_EraseSector+0x2c>
 c04e8f4:	3003081c 	.word	0x3003081c
 c04e8f8:	30030bf0 	.word	0x30030bf0
 c04e8fc:	80000002 	.word	0x80000002

0c04e900 <NMI_Handler>:
void NMI_Handler(void)
{
  uint32_t *p_sp;
  uint32_t lr;
  uint16_t opcode_msb;
  if (__HAL_FLASH_GET_FLAG(FLASH_FLAG_ECCD))
 c04e900:	4b16      	ldr	r3, [pc, #88]	@ (c04e95c <NMI_Handler+0x5c>)
 c04e902:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 c04e904:	2a00      	cmp	r2, #0
 c04e906:	da27      	bge.n	c04e958 <NMI_Handler+0x58>
  {
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_ECCD);
 c04e908:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 c04e90a:	f042 4200 	orr.w	r2, r2, #2147483648	@ 0x80000000
 c04e90e:	631a      	str	r2, [r3, #48]	@ 0x30
    /* Memorize error to ignore the read value */
    DoubleECC_Error_Counter++;
 c04e910:	4a13      	ldr	r2, [pc, #76]	@ (c04e960 <NMI_Handler+0x60>)
 c04e912:	6813      	ldr	r3, [r2, #0]
 c04e914:	3301      	adds	r3, #1
 c04e916:	6013      	str	r3, [r2, #0]
  __ASM volatile("MOV %0, LR" : "=r"(result));
 c04e918:	4673      	mov	r3, lr

    lr = get_LR();

    /* Check EXC_RETURN value in LR to know which SP was used prior entering exception */
    if (((lr) & (0xFU)) == 0xDU)
 c04e91a:	f003 030f 	and.w	r3, r3, #15
 c04e91e:	2b0d      	cmp	r3, #13
 c04e920:	d114      	bne.n	c04e94c <NMI_Handler+0x4c>
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 c04e922:	f3ef 8209 	mrs	r2, PSP
      /* interrupted code was using Main Stack Pointer */
      p_sp = (uint32_t *)__get_MSP();
    }

    /* Test caller mode T bit from CPSR in stack */
    if ((*(p_sp + 7U) & (1U << xPSR_T_Pos)) != 0U)
 c04e926:	e9d2 3106 	ldrd	r3, r1, [r2, #24]
 c04e92a:	01c9      	lsls	r1, r1, #7
 c04e92c:	d50c      	bpl.n	c04e948 <NMI_Handler+0x48>
         Test PC in stack.
         If bits [15:11] of the halfword being decoded take any of the following values,
         the halfword is the first halfword of a 32-bit instruction: 0b11101, 0b11110, 0b11111.
         Otherwise, the halfword is a 16-bit instruction.
      */
      opcode_msb = (*(uint16_t *)(*(p_sp + 6) & 0xFFFFFFFEU) & 0xF800U);
 c04e92e:	f023 0101 	bic.w	r1, r3, #1
 c04e932:	8809      	ldrh	r1, [r1, #0]
      if ((opcode_msb == 0xE800U) || (opcode_msb == 0xF000U) || (opcode_msb == 0xF800U))
 c04e934:	f401 4068 	and.w	r0, r1, #59392	@ 0xe800
 c04e938:	f5b0 4f68 	cmp.w	r0, #59392	@ 0xe800
 c04e93c:	d004      	beq.n	c04e948 <NMI_Handler+0x48>
 c04e93e:	f401 4178 	and.w	r1, r1, #63488	@ 0xf800
 c04e942:	f5b1 4f70 	cmp.w	r1, #61440	@ 0xf000
 c04e946:	d104      	bne.n	c04e952 <NMI_Handler+0x52>
      }
    }
    else
    {
      /* ARM mode execute next instruction PC +4 */
      *(p_sp + 6U) += 4U;
 c04e948:	3304      	adds	r3, #4
 c04e94a:	e003      	b.n	c04e954 <NMI_Handler+0x54>
  __ASM volatile ("MRS %0, msp" : "=r" (result) );
 c04e94c:	f3ef 8208 	mrs	r2, MSP
  return(result);
 c04e950:	e7e9      	b.n	c04e926 <NMI_Handler+0x26>
        *(p_sp + 6U) += 2U;
 c04e952:	3302      	adds	r3, #2
      *(p_sp + 6U) += 4U;
 c04e954:	6193      	str	r3, [r2, #24]
  else
  {
    /* This exception occurs for another reason than flash double ECC errors */
    while (1U);
  }
}
 c04e956:	4770      	bx	lr
    while (1U);
 c04e958:	e7fe      	b.n	c04e958 <NMI_Handler+0x58>
 c04e95a:	bf00      	nop
 c04e95c:	50022000 	.word	0x50022000
 c04e960:	30030bf4 	.word	0x30030bf4

0c04e964 <RNG_Init>:
  COMPILER_BARRIER();
  return newValue;
}

void RNG_Init(void)
{
 c04e964:	b507      	push	{r0, r1, r2, lr}
   __ASM volatile ("ldrexb %0, %1" : "=r" (result) : "Q" (*addr) );
 c04e966:	4a19      	ldr	r2, [pc, #100]	@ (c04e9cc <RNG_Init+0x68>)
 c04e968:	e8d2 3f4f 	ldrexb	r3, [r2]
    newValue = __LDREXB(valuePtr) + delta;
 c04e96c:	3301      	adds	r3, #1
 c04e96e:	b2db      	uxtb	r3, r3
   __ASM volatile ("strexb %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" ((uint32_t)value) );
 c04e970:	e8c2 3f41 	strexb	r1, r3, [r2]
  } while (__STREXB(newValue, valuePtr));
 c04e974:	2900      	cmp	r1, #0
 c04e976:	d1f7      	bne.n	c04e968 <RNG_Init+0x4>
  uint32_t dummy;
  /*  We're only supporting a single user of RNG */
  if (atomic_incr_u8(&users, 1) > 1)
 c04e978:	2b01      	cmp	r3, #1
 c04e97a:	d901      	bls.n	c04e980 <RNG_Init+0x1c>
  {
    Error_Handler();
 c04e97c:	f003 fff4 	bl	c052968 <Error_Handler>
  }

  /* Select RNG clock source */
  __HAL_RCC_RNG_CONFIG(RCC_RNGCLKSOURCE_HSI48);
 c04e980:	4b13      	ldr	r3, [pc, #76]	@ (c04e9d0 <RNG_Init+0x6c>)

  /* RNG Peripheral clock enable */
  __HAL_RCC_RNG_CLK_ENABLE();

  /* Initialize RNG instance */
  handle.Instance = RNG;
 c04e982:	4814      	ldr	r0, [pc, #80]	@ (c04e9d4 <RNG_Init+0x70>)
  __HAL_RCC_RNG_CONFIG(RCC_RNGCLKSOURCE_HSI48);
 c04e984:	f8d3 20e4 	ldr.w	r2, [r3, #228]	@ 0xe4
 c04e988:	f422 5240 	bic.w	r2, r2, #12288	@ 0x3000
 c04e98c:	f8c3 20e4 	str.w	r2, [r3, #228]	@ 0xe4
  __HAL_RCC_RNG_CLK_ENABLE();
 c04e990:	f8d3 208c 	ldr.w	r2, [r3, #140]	@ 0x8c
 c04e994:	f442 2280 	orr.w	r2, r2, #262144	@ 0x40000
 c04e998:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
 c04e99c:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 c04e9a0:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
 c04e9a4:	9301      	str	r3, [sp, #4]
 c04e9a6:	9b01      	ldr	r3, [sp, #4]
  handle.Instance = RNG;
 c04e9a8:	4b0b      	ldr	r3, [pc, #44]	@ (c04e9d8 <RNG_Init+0x74>)
 c04e9aa:	6003      	str	r3, [r0, #0]
  handle.State = HAL_RNG_STATE_RESET;
 c04e9ac:	2300      	movs	r3, #0
 c04e9ae:	7243      	strb	r3, [r0, #9]
  handle.Lock = HAL_UNLOCKED;
 c04e9b0:	7203      	strb	r3, [r0, #8]

  if (HAL_RNG_Init(&handle) != HAL_OK)
 c04e9b2:	f7f2 fcd4 	bl	c04135e <HAL_RNG_Init>
 c04e9b6:	b108      	cbz	r0, c04e9bc <RNG_Init+0x58>
  {
    Error_Handler();
 c04e9b8:	f003 ffd6 	bl	c052968 <Error_Handler>
  }

  /* first random number generated after setting the RNGEN bit should not be used */
  HAL_RNG_GenerateRandomNumber(&handle, &dummy);
 c04e9bc:	4669      	mov	r1, sp
 c04e9be:	4805      	ldr	r0, [pc, #20]	@ (c04e9d4 <RNG_Init+0x70>)
 c04e9c0:	f7f2 fd68 	bl	c041494 <HAL_RNG_GenerateRandomNumber>
}
 c04e9c4:	b003      	add	sp, #12
 c04e9c6:	f85d fb04 	ldr.w	pc, [sp], #4
 c04e9ca:	bf00      	nop
 c04e9cc:	30030bf8 	.word	0x30030bf8
 c04e9d0:	56020c00 	.word	0x56020c00
 c04e9d4:	30030bfc 	.word	0x30030bfc
 c04e9d8:	520c0800 	.word	0x520c0800

0c04e9dc <RNG_GetBytes>:

void RNG_GetBytes(uint8_t *output, size_t length, size_t *output_length)
{
 c04e9dc:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
  int32_t ret = 0;
  uint8_t try = 0;
  __IO uint8_t random[4];
  *output_length = 0;
 c04e9e0:	2400      	movs	r4, #0
{
 c04e9e2:	4606      	mov	r6, r0
 c04e9e4:	460f      	mov	r7, r1
 c04e9e6:	4615      	mov	r5, r2
  int32_t ret = 0;
 c04e9e8:	46a0      	mov	r8, r4
    {
      for (uint8_t i = 0; (i < 4) && (*output_length < length) ; i++)
      {
        *output++ = random[i];
        *output_length += 1;
        random[i] = 0;
 c04e9ea:	46a2      	mov	sl, r4
    if (HAL_RNG_GenerateRandomNumber(&handle, (uint32_t *)random) != HAL_OK)
 c04e9ec:	f8df 9070 	ldr.w	r9, [pc, #112]	@ c04ea60 <RNG_GetBytes+0x84>
  *output_length = 0;
 c04e9f0:	6014      	str	r4, [r2, #0]
  while ((*output_length < length) && (ret == 0))
 c04e9f2:	682b      	ldr	r3, [r5, #0]
 c04e9f4:	42bb      	cmp	r3, r7
 c04e9f6:	d202      	bcs.n	c04e9fe <RNG_GetBytes+0x22>
 c04e9f8:	f1b8 0f00 	cmp.w	r8, #0
 c04e9fc:	d00b      	beq.n	c04ea16 <RNG_GetBytes+0x3a>
      }
    }
  }
  /* Just be extra sure that we didn't do it wrong */
  if ((__HAL_RNG_GET_FLAG(&handle, (RNG_FLAG_CECS | RNG_FLAG_SECS))) != 0)
 c04e9fe:	4b18      	ldr	r3, [pc, #96]	@ (c04ea60 <RNG_GetBytes+0x84>)
 c04ea00:	681b      	ldr	r3, [r3, #0]
 c04ea02:	685b      	ldr	r3, [r3, #4]
 c04ea04:	f003 0306 	and.w	r3, r3, #6
 c04ea08:	2b06      	cmp	r3, #6
  {
    *output_length = 0;
 c04ea0a:	bf04      	itt	eq
 c04ea0c:	2300      	moveq	r3, #0
 c04ea0e:	602b      	streq	r3, [r5, #0]
  }
}
 c04ea10:	b002      	add	sp, #8
 c04ea12:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if (HAL_RNG_GenerateRandomNumber(&handle, (uint32_t *)random) != HAL_OK)
 c04ea16:	4648      	mov	r0, r9
 c04ea18:	a901      	add	r1, sp, #4
 c04ea1a:	f7f2 fd3b 	bl	c041494 <HAL_RNG_GenerateRandomNumber>
 c04ea1e:	b1c8      	cbz	r0, c04ea54 <RNG_GetBytes+0x78>
      if (try < 3)
 c04ea20:	2c02      	cmp	r4, #2
 c04ea22:	d819      	bhi.n	c04ea58 <RNG_GetBytes+0x7c>
        try++;
 c04ea24:	3401      	adds	r4, #1
 c04ea26:	b2e4      	uxtb	r4, r4
 c04ea28:	e7e3      	b.n	c04e9f2 <RNG_GetBytes+0x16>
        *output++ = random[i];
 c04ea2a:	f103 0208 	add.w	r2, r3, #8
 c04ea2e:	eb0d 0102 	add.w	r1, sp, r2
 c04ea32:	f811 2c04 	ldrb.w	r2, [r1, #-4]
      for (uint8_t i = 0; (i < 4) && (*output_length < length) ; i++)
 c04ea36:	3301      	adds	r3, #1
        *output++ = random[i];
 c04ea38:	f806 2b01 	strb.w	r2, [r6], #1
        *output_length += 1;
 c04ea3c:	682a      	ldr	r2, [r5, #0]
      for (uint8_t i = 0; (i < 4) && (*output_length < length) ; i++)
 c04ea3e:	2b04      	cmp	r3, #4
        *output_length += 1;
 c04ea40:	f102 0201 	add.w	r2, r2, #1
 c04ea44:	602a      	str	r2, [r5, #0]
        random[i] = 0;
 c04ea46:	f801 ac04 	strb.w	sl, [r1, #-4]
      for (uint8_t i = 0; (i < 4) && (*output_length < length) ; i++)
 c04ea4a:	d0d2      	beq.n	c04e9f2 <RNG_GetBytes+0x16>
 c04ea4c:	682a      	ldr	r2, [r5, #0]
 c04ea4e:	42ba      	cmp	r2, r7
 c04ea50:	d3eb      	bcc.n	c04ea2a <RNG_GetBytes+0x4e>
 c04ea52:	e7ce      	b.n	c04e9f2 <RNG_GetBytes+0x16>
 c04ea54:	4643      	mov	r3, r8
 c04ea56:	e7f9      	b.n	c04ea4c <RNG_GetBytes+0x70>
        ret = -1;
 c04ea58:	f04f 38ff 	mov.w	r8, #4294967295	@ 0xffffffff
 c04ea5c:	e7c9      	b.n	c04e9f2 <RNG_GetBytes+0x16>
 c04ea5e:	bf00      	nop
 c04ea60:	30030bfc 	.word	0x30030bfc

0c04ea64 <mbedtls_hardware_poll>:
}


/*  interface for mbed-crypto */
int mbedtls_hardware_poll(void *data, unsigned char *output, size_t len, size_t *olen)
{
 c04ea64:	b538      	push	{r3, r4, r5, lr}
 c04ea66:	4614      	mov	r4, r2
 c04ea68:	461d      	mov	r5, r3
 c04ea6a:	4608      	mov	r0, r1
  RNG_GetBytes(output, len, olen);
 c04ea6c:	461a      	mov	r2, r3
 c04ea6e:	4621      	mov	r1, r4
 c04ea70:	f7ff ffb4 	bl	c04e9dc <RNG_GetBytes>
  if (*olen != len)
 c04ea74:	682b      	ldr	r3, [r5, #0]
  {
    return MBEDTLS_ERR_ENTROPY_SOURCE_FAILED;
  }
  return 0;
 c04ea76:	42a3      	cmp	r3, r4
}
 c04ea78:	bf14      	ite	ne
 c04ea7a:	f06f 003b 	mvnne.w	r0, #59	@ 0x3b
 c04ea7e:	2000      	moveq	r0, #0
 c04ea80:	bd38      	pop	{r3, r4, r5, pc}
	...

0c04ea84 <mpu_armv8m_enable>:
               (MPU_ARMV8M_MAIR_ATTR_DATA_VAL << MPU_MAIR0_Attr2_Pos) |
               (MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_VAL << MPU_MAIR0_Attr3_Pos);

  mpu->CTRL =
    (privdef_en ? MPU_CTRL_PRIVDEFENA_Msk : 0) |
    (hfnmi_en   ? MPU_CTRL_HFNMIENA_Msk   : 0);
 c04ea84:	3a00      	subs	r2, #0
 c04ea86:	bf18      	it	ne
 c04ea88:	2201      	movne	r2, #1
    (privdef_en ? MPU_CTRL_PRIVDEFENA_Msk : 0) |
 c04ea8a:	3900      	subs	r1, #0
 c04ea8c:	bf18      	it	ne
 c04ea8e:	2101      	movne	r1, #1
  MPU_Type *mpu = (MPU_Type *)dev->base;
 c04ea90:	6803      	ldr	r3, [r0, #0]
    (privdef_en ? MPU_CTRL_PRIVDEFENA_Msk : 0) |
 c04ea92:	0089      	lsls	r1, r1, #2
  mpu->MAIR0 = (MPU_ARMV8M_MAIR_ATTR_DEVICE_VAL << MPU_MAIR0_Attr0_Pos) |
 c04ea94:	4807      	ldr	r0, [pc, #28]	@ (c04eab4 <mpu_armv8m_enable+0x30>)
    (privdef_en ? MPU_CTRL_PRIVDEFENA_Msk : 0) |
 c04ea96:	ea41 0142 	orr.w	r1, r1, r2, lsl #1
  mpu->MAIR0 = (MPU_ARMV8M_MAIR_ATTR_DEVICE_VAL << MPU_MAIR0_Attr0_Pos) |
 c04ea9a:	6318      	str	r0, [r3, #48]	@ 0x30
  mpu->CTRL =
 c04ea9c:	6059      	str	r1, [r3, #4]

  /*Ensure all configuration is written before enable*/

  mpu->CTRL |= MPU_CTRL_ENABLE_Msk;
 c04ea9e:	685a      	ldr	r2, [r3, #4]
 c04eaa0:	f042 0201 	orr.w	r2, r2, #1
 c04eaa4:	605a      	str	r2, [r3, #4]
  __ASM volatile ("dsb 0xF":::"memory");
 c04eaa6:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 c04eaaa:	f3bf 8f6f 	isb	sy

  /* Enable MPU before next instruction */
  __DSB();
  __ISB();
  return MPU_ARMV8M_OK;
}
 c04eaae:	2000      	movs	r0, #0
 c04eab0:	4770      	bx	lr
 c04eab2:	bf00      	nop
 c04eab4:	44ffaa04 	.word	0x44ffaa04

0c04eab8 <mpu_armv8m_check>:
  uint32_t mair0;
  uint32_t ctrl;

  /*No error checking*/

  MPU_Type *mpu = (MPU_Type *)dev->base;
 c04eab8:	6803      	ldr	r3, [r0, #0]
{
 c04eaba:	b510      	push	{r4, lr}
  /*Ensure all configuration is written before enable*/

  ctrl |= MPU_CTRL_ENABLE_Msk;


  if ((mpu->MAIR0 == mair0) && (mpu->CTRL == ctrl))
 c04eabc:	480a      	ldr	r0, [pc, #40]	@ (c04eae8 <mpu_armv8m_check+0x30>)
 c04eabe:	6b1c      	ldr	r4, [r3, #48]	@ 0x30
 c04eac0:	4284      	cmp	r4, r0
 c04eac2:	d10f      	bne.n	c04eae4 <mpu_armv8m_check+0x2c>
    (hfnmi_en   ? MPU_CTRL_HFNMIENA_Msk   : 0);
 c04eac4:	3a00      	subs	r2, #0
 c04eac6:	bf18      	it	ne
 c04eac8:	2201      	movne	r2, #1
    (privdef_en ? MPU_CTRL_PRIVDEFENA_Msk : 0) |
 c04eaca:	1e08      	subs	r0, r1, #0
 c04eacc:	bf18      	it	ne
 c04eace:	2001      	movne	r0, #1
 c04ead0:	0080      	lsls	r0, r0, #2
  if ((mpu->MAIR0 == mair0) && (mpu->CTRL == ctrl))
 c04ead2:	685b      	ldr	r3, [r3, #4]
  ctrl =
 c04ead4:	ea40 0042 	orr.w	r0, r0, r2, lsl #1
  ctrl |= MPU_CTRL_ENABLE_Msk;
 c04ead8:	f040 0001 	orr.w	r0, r0, #1
  if ((mpu->MAIR0 == mair0) && (mpu->CTRL == ctrl))
 c04eadc:	1ac0      	subs	r0, r0, r3
 c04eade:	bf18      	it	ne
 c04eae0:	2001      	movne	r0, #1
  {
    ret_val = MPU_ARMV8M_OK;
  }

  return ret_val;
}
 c04eae2:	bd10      	pop	{r4, pc}
  enum mpu_armv8m_error_t ret_val = MPU_ARMV8M_ERROR;
 c04eae4:	2001      	movs	r0, #1
 c04eae6:	e7fc      	b.n	c04eae2 <mpu_armv8m_check+0x2a>
 c04eae8:	44ffaa04 	.word	0x44ffaa04

0c04eaec <mpu_armv8m_disable>:

enum mpu_armv8m_error_t mpu_armv8m_disable(struct mpu_armv8m_dev_t *dev)
{
  MPU_Type *mpu = (MPU_Type *)dev->base;
 c04eaec:	6803      	ldr	r3, [r0, #0]

  /* Reset all fields as enable does full setup */
  mpu->CTRL = 0;
 c04eaee:	2000      	movs	r0, #0
 c04eaf0:	6058      	str	r0, [r3, #4]

  return MPU_ARMV8M_OK;
}
 c04eaf2:	4770      	bx	lr

0c04eaf4 <mpu_armv8m_region_enable>:
  enum mpu_armv8m_error_t ret_val = MPU_ARMV8M_OK;
  uint32_t base_cfg;
  uint32_t limit_cfg;

  /*FIXME : Add complete error checking*/
  if ((region_cfg->region_base & ~MPU_RBAR_BASE_Msk) != 0)
 c04eaf4:	684b      	ldr	r3, [r1, #4]
{
 c04eaf6:	b530      	push	{r4, r5, lr}
  if ((region_cfg->region_base & ~MPU_RBAR_BASE_Msk) != 0)
 c04eaf8:	06da      	lsls	r2, r3, #27
 c04eafa:	d128      	bne.n	c04eb4e <mpu_armv8m_region_enable+0x5a>
  {
    return MPU_ARMV8M_ERROR;
  }
  if (((region_cfg->region_limit+1) & ~MPU_RLAR_LIMIT_Msk) !=0)
 c04eafc:	688d      	ldr	r5, [r1, #8]
 c04eafe:	1c6a      	adds	r2, r5, #1
 c04eb00:	f012 021f 	ands.w	r2, r2, #31
 c04eb04:	d123      	bne.n	c04eb4e <mpu_armv8m_region_enable+0x5a>
  MPU_Type *mpu = (MPU_Type *)dev->base;
 c04eb06:	6804      	ldr	r4, [r0, #0]
  }
  /* region_limit needs to be setup to ensure that partitions do not overlap.
   */
  /* don't disable MPU */

  mpu->RNR  = region_cfg->region_nr & MPU_RNR_REGION_Msk;
 c04eb08:	7808      	ldrb	r0, [r1, #0]

  /* This 0s the lower bits of the base address */
  base_cfg = region_cfg->region_base & MPU_RBAR_BASE_Msk;
 c04eb0a:	f023 031f 	bic.w	r3, r3, #31
  mpu->RNR  = region_cfg->region_nr & MPU_RNR_REGION_Msk;
 c04eb0e:	60a0      	str	r0, [r4, #8]
  base_cfg |= (region_cfg->attr_sh << MPU_RBAR_SH_Pos) & MPU_RBAR_SH_Msk;
  base_cfg |= (region_cfg->attr_access << MPU_RBAR_AP_Pos) & MPU_RBAR_AP_Msk;
  base_cfg |= (region_cfg->attr_exec << MPU_RBAR_XN_Pos) & MPU_RBAR_XN_Msk;
 c04eb10:	7c08      	ldrb	r0, [r1, #16]

  mpu->RBAR = base_cfg;

  /*This 0s the lower bits of base address but they are treated as 1 */
  limit_cfg = (region_cfg->region_limit) & MPU_RLAR_LIMIT_Msk;
 c04eb12:	f025 051f 	bic.w	r5, r5, #31
  base_cfg |= (region_cfg->attr_exec << MPU_RBAR_XN_Pos) & MPU_RBAR_XN_Msk;
 c04eb16:	f000 0001 	and.w	r0, r0, #1
 c04eb1a:	4318      	orrs	r0, r3
  base_cfg |= (region_cfg->attr_sh << MPU_RBAR_SH_Pos) & MPU_RBAR_SH_Msk;
 c04eb1c:	7c8b      	ldrb	r3, [r1, #18]
 c04eb1e:	00db      	lsls	r3, r3, #3
 c04eb20:	f003 0318 	and.w	r3, r3, #24
 c04eb24:	4318      	orrs	r0, r3
  base_cfg |= (region_cfg->attr_access << MPU_RBAR_AP_Pos) & MPU_RBAR_AP_Msk;
 c04eb26:	7c4b      	ldrb	r3, [r1, #17]
 c04eb28:	005b      	lsls	r3, r3, #1
 c04eb2a:	f003 0306 	and.w	r3, r3, #6
  base_cfg |= (region_cfg->attr_exec << MPU_RBAR_XN_Pos) & MPU_RBAR_XN_Msk;
 c04eb2e:	4303      	orrs	r3, r0
  mpu->RBAR = base_cfg;
 c04eb30:	60e3      	str	r3, [r4, #12]

  limit_cfg |= (region_cfg->region_attridx << MPU_RLAR_AttrIndx_Pos) &
 c04eb32:	68cb      	ldr	r3, [r1, #12]
 c04eb34:	005b      	lsls	r3, r3, #1
 c04eb36:	f003 030e 	and.w	r3, r3, #14
 c04eb3a:	432b      	orrs	r3, r5
               MPU_RLAR_AttrIndx_Msk;

  limit_cfg |= MPU_RLAR_EN_Msk;
 c04eb3c:	f043 0301 	orr.w	r3, r3, #1

  mpu->RLAR = limit_cfg;
 c04eb40:	6123      	str	r3, [r4, #16]
  __ASM volatile ("dsb 0xF":::"memory");
 c04eb42:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 c04eb46:	f3bf 8f6f 	isb	sy

  /* Enable MPU before the next instruction */
  __DSB();
  __ISB();

  return ret_val;
 c04eb4a:	4610      	mov	r0, r2
}
 c04eb4c:	bd30      	pop	{r4, r5, pc}
    return MPU_ARMV8M_ERROR;
 c04eb4e:	2001      	movs	r0, #1
 c04eb50:	e7fc      	b.n	c04eb4c <mpu_armv8m_region_enable+0x58>

0c04eb52 <mpu_armv8m_region_enable_check>:
  enum mpu_armv8m_error_t ret_val = MPU_ARMV8M_ERROR;
  uint32_t base_cfg;
  uint32_t limit_cfg;

  /*FIXME : Add complete error checking*/
  if ((region_cfg->region_base & ~MPU_RBAR_BASE_Msk) != 0)
 c04eb52:	684b      	ldr	r3, [r1, #4]
{
 c04eb54:	b570      	push	{r4, r5, r6, lr}
  if ((region_cfg->region_base & ~MPU_RBAR_BASE_Msk) != 0)
 c04eb56:	06da      	lsls	r2, r3, #27
  MPU_Type *mpu = (MPU_Type *)dev->base;
 c04eb58:	6804      	ldr	r4, [r0, #0]
  if ((region_cfg->region_base & ~MPU_RBAR_BASE_Msk) != 0)
 c04eb5a:	d001      	beq.n	c04eb60 <mpu_armv8m_region_enable_check+0xe>
  {
    return MPU_ARMV8M_ERROR;
 c04eb5c:	2001      	movs	r0, #1
  {
    ret_val = MPU_ARMV8M_OK;
  }

  return ret_val;
}
 c04eb5e:	bd70      	pop	{r4, r5, r6, pc}
  mpu->RNR  = region_cfg->region_nr & MPU_RNR_REGION_Msk;
 c04eb60:	780a      	ldrb	r2, [r1, #0]
  base_cfg = region_cfg->region_base & MPU_RBAR_BASE_Msk;
 c04eb62:	f023 031f 	bic.w	r3, r3, #31
  mpu->RNR  = region_cfg->region_nr & MPU_RNR_REGION_Msk;
 c04eb66:	60a2      	str	r2, [r4, #8]
  base_cfg |= (region_cfg->attr_exec << MPU_RBAR_XN_Pos) & MPU_RBAR_XN_Msk;
 c04eb68:	7c0a      	ldrb	r2, [r1, #16]
  if ((mpu->RBAR == base_cfg) && (mpu->RLAR == limit_cfg))
 c04eb6a:	68e6      	ldr	r6, [r4, #12]
  base_cfg |= (region_cfg->attr_exec << MPU_RBAR_XN_Pos) & MPU_RBAR_XN_Msk;
 c04eb6c:	f002 0201 	and.w	r2, r2, #1
 c04eb70:	431a      	orrs	r2, r3
  base_cfg |= (region_cfg->attr_sh << MPU_RBAR_SH_Pos) & MPU_RBAR_SH_Msk;
 c04eb72:	7c8b      	ldrb	r3, [r1, #18]
  limit_cfg |= (region_cfg->region_attridx << MPU_RLAR_AttrIndx_Pos) &
 c04eb74:	e9d1 5002 	ldrd	r5, r0, [r1, #8]
  base_cfg |= (region_cfg->attr_sh << MPU_RBAR_SH_Pos) & MPU_RBAR_SH_Msk;
 c04eb78:	00db      	lsls	r3, r3, #3
 c04eb7a:	f003 0318 	and.w	r3, r3, #24
 c04eb7e:	431a      	orrs	r2, r3
  base_cfg |= (region_cfg->attr_access << MPU_RBAR_AP_Pos) & MPU_RBAR_AP_Msk;
 c04eb80:	7c4b      	ldrb	r3, [r1, #17]
 c04eb82:	005b      	lsls	r3, r3, #1
 c04eb84:	f003 0306 	and.w	r3, r3, #6
  base_cfg |= (region_cfg->attr_exec << MPU_RBAR_XN_Pos) & MPU_RBAR_XN_Msk;
 c04eb88:	4313      	orrs	r3, r2
  if ((mpu->RBAR == base_cfg) && (mpu->RLAR == limit_cfg))
 c04eb8a:	429e      	cmp	r6, r3
 c04eb8c:	d1e6      	bne.n	c04eb5c <mpu_armv8m_region_enable_check+0xa>
  limit_cfg |= (region_cfg->region_attridx << MPU_RLAR_AttrIndx_Pos) &
 c04eb8e:	0040      	lsls	r0, r0, #1
  limit_cfg = (region_cfg->region_limit) & MPU_RLAR_LIMIT_Msk;
 c04eb90:	f025 031f 	bic.w	r3, r5, #31
  limit_cfg |= (region_cfg->region_attridx << MPU_RLAR_AttrIndx_Pos) &
 c04eb94:	f000 000e 	and.w	r0, r0, #14
  if ((mpu->RBAR == base_cfg) && (mpu->RLAR == limit_cfg))
 c04eb98:	6922      	ldr	r2, [r4, #16]
  limit_cfg |= (region_cfg->region_attridx << MPU_RLAR_AttrIndx_Pos) &
 c04eb9a:	4318      	orrs	r0, r3
  limit_cfg |= MPU_RLAR_EN_Msk;
 c04eb9c:	f040 0001 	orr.w	r0, r0, #1
  if ((mpu->RBAR == base_cfg) && (mpu->RLAR == limit_cfg))
 c04eba0:	1a80      	subs	r0, r0, r2
 c04eba2:	bf18      	it	ne
 c04eba4:	2001      	movne	r0, #1
 c04eba6:	e7da      	b.n	c04eb5e <mpu_armv8m_region_enable_check+0xc>

0c04eba8 <mpu_armv8m_region_disable>:
enum mpu_armv8m_error_t mpu_armv8m_region_disable(
  struct mpu_armv8m_dev_t *dev,
  uint32_t region_nr)
{

  MPU_Type *mpu = (MPU_Type *)dev->base;
 c04eba8:	6803      	ldr	r3, [r0, #0]
  uint32_t ctrl_before;

  /*FIXME : Add complete error checking*/

  ctrl_before = mpu->CTRL;
  mpu->CTRL = 0;
 c04ebaa:	2000      	movs	r0, #0
  ctrl_before = mpu->CTRL;
 c04ebac:	685a      	ldr	r2, [r3, #4]

  mpu->RNR  = region_nr & MPU_RNR_REGION_Msk;
 c04ebae:	b2c9      	uxtb	r1, r1
  mpu->CTRL = 0;
 c04ebb0:	6058      	str	r0, [r3, #4]
  mpu->RNR  = region_nr & MPU_RNR_REGION_Msk;
 c04ebb2:	6099      	str	r1, [r3, #8]

  mpu->RBAR = 0;
 c04ebb4:	60d8      	str	r0, [r3, #12]
  mpu->RLAR = 0;
 c04ebb6:	6118      	str	r0, [r3, #16]

  /*Restore main MPU control*/
  mpu->CTRL = ctrl_before;
 c04ebb8:	605a      	str	r2, [r3, #4]

  return ret_val;
}
 c04ebba:	4770      	bx	lr

0c04ebbc <mpu_armv8m_clean>:

  return ret_val;
}

enum mpu_armv8m_error_t mpu_armv8m_clean(struct mpu_armv8m_dev_t *dev)
{
 c04ebbc:	b538      	push	{r3, r4, r5, lr}
 c04ebbe:	4605      	mov	r5, r0
  MPU_Type *mpu = (MPU_Type *)dev->base;
 c04ebc0:	6803      	ldr	r3, [r0, #0]
  uint32_t i = (mpu->TYPE & MPU_TYPE_DREGION_Msk) >> MPU_TYPE_DREGION_Pos;
 c04ebc2:	681c      	ldr	r4, [r3, #0]
 c04ebc4:	f3c4 2407 	ubfx	r4, r4, #8, #8

  while (i > 0)
 c04ebc8:	b90c      	cbnz	r4, c04ebce <mpu_armv8m_clean+0x12>
    i--;
  }

  return MPU_ARMV8M_OK;

}
 c04ebca:	4620      	mov	r0, r4
 c04ebcc:	bd38      	pop	{r3, r4, r5, pc}
    mpu_armv8m_region_disable(dev, i - 1);
 c04ebce:	3c01      	subs	r4, #1
 c04ebd0:	4621      	mov	r1, r4
 c04ebd2:	4628      	mov	r0, r5
 c04ebd4:	f7ff ffe8 	bl	c04eba8 <mpu_armv8m_region_disable>
    i--;
 c04ebd8:	e7f6      	b.n	c04ebc8 <mpu_armv8m_clean+0xc>

0c04ebda <crc16>:
  * @param  pdata: pointer to data buffer.
  * @param  size: buffer length in bytes.
  * @retval uint16_t CRC
  */
static uint16_t crc16(const uint8_t *pdata, uint16_t size)
{
 c04ebda:	b5f0      	push	{r4, r5, r6, r7, lr}
 c04ebdc:	1e43      	subs	r3, r0, #1
    out ^= 0x1021;
 c04ebde:	f241 0621 	movw	r6, #4129	@ 0x1021
  uint16_t crc;
  uint8_t i;

  for (crc = 0; size > 0; size--, pdata++)
 c04ebe2:	2000      	movs	r0, #0
  {
    for (i = 0x80; i; i >>= 1)
    {
      crc = crc_update(crc, *pdata & i);
 c04ebe4:	2408      	movs	r4, #8
    for (i = 0x80; i; i >>= 1)
 c04ebe6:	2280      	movs	r2, #128	@ 0x80
      crc = crc_update(crc, *pdata & i);
 c04ebe8:	f813 5f01 	ldrb.w	r5, [r3, #1]!
  uint16_t xor = crc_in >> 15;
 c04ebec:	0bc7      	lsrs	r7, r0, #15
  uint16_t out = crc_in << 1;
 c04ebee:	0040      	lsls	r0, r0, #1
 c04ebf0:	b280      	uxth	r0, r0
  if (incr)
 c04ebf2:	4215      	tst	r5, r2
    out++;
 c04ebf4:	bf1c      	itt	ne
 c04ebf6:	3001      	addne	r0, #1
 c04ebf8:	b280      	uxthne	r0, r0
  if (xor)
 c04ebfa:	b107      	cbz	r7, c04ebfe <crc16+0x24>
    out ^= 0x1021;
 c04ebfc:	4070      	eors	r0, r6
    for (i = 0x80; i; i >>= 1)
 c04ebfe:	3c01      	subs	r4, #1
 c04ec00:	ea4f 0252 	mov.w	r2, r2, lsr #1
 c04ec04:	d1f2      	bne.n	c04ebec <crc16+0x12>
  for (crc = 0; size > 0; size--, pdata++)
 c04ec06:	3901      	subs	r1, #1
 c04ec08:	b289      	uxth	r1, r1
 c04ec0a:	2900      	cmp	r1, #0
 c04ec0c:	d1ea      	bne.n	c04ebe4 <crc16+0xa>
 c04ec0e:	2310      	movs	r3, #16
    out ^= 0x1021;
 c04ec10:	f241 0221 	movw	r2, #4129	@ 0x1021
  uint16_t xor = crc_in >> 15;
 c04ec14:	0bc1      	lsrs	r1, r0, #15
  uint16_t out = crc_in << 1;
 c04ec16:	0040      	lsls	r0, r0, #1
 c04ec18:	b280      	uxth	r0, r0
  if (xor)
 c04ec1a:	b101      	cbz	r1, c04ec1e <crc16+0x44>
    out ^= 0x1021;
 c04ec1c:	4050      	eors	r0, r2
    }
  }
  for (i = 0; i < 16; i++)
 c04ec1e:	3b01      	subs	r3, #1
 c04ec20:	f013 03ff 	ands.w	r3, r3, #255	@ 0xff
 c04ec24:	d1f6      	bne.n	c04ec14 <crc16+0x3a>
  {
    crc = crc_update(crc, 0);
  }
  return crc;
}
 c04ec26:	bdf0      	pop	{r4, r5, r6, r7, pc}

0c04ec28 <tfm_plat_init_nv_counter>:

    nv_counters->crc = (uint32_t)crc;
}

enum tfm_plat_err_t tfm_plat_init_nv_counter(void)
{
 c04ec28:	b570      	push	{r4, r5, r6, lr}
    int32_t  err;
    uint32_t i;
    struct nv_counters_t nv_counters;

    err = DEVICE_NV_COUNTERS_FLASH_NAME.Initialize(NULL);
 c04ec2a:	4c23      	ldr	r4, [pc, #140]	@ (c04ecb8 <tfm_plat_init_nv_counter+0x90>)
{
 c04ec2c:	b088      	sub	sp, #32
    err = DEVICE_NV_COUNTERS_FLASH_NAME.Initialize(NULL);
 c04ec2e:	2000      	movs	r0, #0
 c04ec30:	68a3      	ldr	r3, [r4, #8]
 c04ec32:	4798      	blx	r3
    if (err != ARM_DRIVER_OK) {
 c04ec34:	b118      	cbz	r0, c04ec3e <tfm_plat_init_nv_counter+0x16>
        return TFM_PLAT_ERR_SYSTEM_ERR;
 c04ec36:	f643 205c 	movw	r0, #14940	@ 0x3a5c
    if (err != ARM_DRIVER_OK) {
        return TFM_PLAT_ERR_SYSTEM_ERR;
    }

    return TFM_PLAT_ERR_SUCCESS;
}
 c04ec3a:	b008      	add	sp, #32
 c04ec3c:	bd70      	pop	{r4, r5, r6, pc}
    err = DEVICE_NV_COUNTERS_FLASH_NAME.ReadData(VALID_ADDRESS,
 c04ec3e:	2220      	movs	r2, #32
 c04ec40:	4669      	mov	r1, sp
 c04ec42:	f44f 3028 	mov.w	r0, #172032	@ 0x2a000
 c04ec46:	6966      	ldr	r6, [r4, #20]
 c04ec48:	47b0      	blx	r6
    if (err != ARM_DRIVER_OK) {
 c04ec4a:	2800      	cmp	r0, #0
 c04ec4c:	d1f3      	bne.n	c04ec36 <tfm_plat_init_nv_counter+0xe>
    return ((nv_counters->init_value == NV_COUNTERS_INITIALIZED) &&
 c04ec4e:	4d1b      	ldr	r5, [pc, #108]	@ (c04ecbc <tfm_plat_init_nv_counter+0x94>)
 c04ec50:	9b01      	ldr	r3, [sp, #4]
 c04ec52:	42ab      	cmp	r3, r5
 c04ec54:	d104      	bne.n	c04ec60 <tfm_plat_init_nv_counter+0x38>
    return crc16((uint8_t *)data, len);
 c04ec56:	2120      	movs	r1, #32
 c04ec58:	4668      	mov	r0, sp
 c04ec5a:	f7ff ffbe 	bl	c04ebda <crc16>
    return ((nv_counters->init_value == NV_COUNTERS_INITIALIZED) &&
 c04ec5e:	b348      	cbz	r0, c04ecb4 <tfm_plat_init_nv_counter+0x8c>
    err = DEVICE_NV_COUNTERS_FLASH_NAME.ReadData(BACKUP_ADDRESS,
 c04ec60:	2220      	movs	r2, #32
 c04ec62:	4669      	mov	r1, sp
 c04ec64:	f44f 3030 	mov.w	r0, #180224	@ 0x2c000
 c04ec68:	47b0      	blx	r6
    if (err != ARM_DRIVER_OK) {
 c04ec6a:	2800      	cmp	r0, #0
 c04ec6c:	d1e3      	bne.n	c04ec36 <tfm_plat_init_nv_counter+0xe>
    err = DEVICE_NV_COUNTERS_FLASH_NAME.EraseSector(VALID_ADDRESS);
 c04ec6e:	f44f 3028 	mov.w	r0, #172032	@ 0x2a000
 c04ec72:	69e3      	ldr	r3, [r4, #28]
 c04ec74:	4798      	blx	r3
    if (err != ARM_DRIVER_OK) {
 c04ec76:	2800      	cmp	r0, #0
 c04ec78:	d1dd      	bne.n	c04ec36 <tfm_plat_init_nv_counter+0xe>
    return ((nv_counters->init_value == NV_COUNTERS_INITIALIZED) &&
 c04ec7a:	9b01      	ldr	r3, [sp, #4]
        err = DEVICE_NV_COUNTERS_FLASH_NAME.ProgramData(VALID_ADDRESS,
 c04ec7c:	69a4      	ldr	r4, [r4, #24]
    return ((nv_counters->init_value == NV_COUNTERS_INITIALIZED) &&
 c04ec7e:	42ab      	cmp	r3, r5
 c04ec80:	d104      	bne.n	c04ec8c <tfm_plat_init_nv_counter+0x64>
    return crc16((uint8_t *)data, len);
 c04ec82:	2120      	movs	r1, #32
 c04ec84:	4668      	mov	r0, sp
 c04ec86:	f7ff ffa8 	bl	c04ebda <crc16>
    return ((nv_counters->init_value == NV_COUNTERS_INITIALIZED) &&
 c04ec8a:	b160      	cbz	r0, c04eca6 <tfm_plat_init_nv_counter+0x7e>
        nv_counters.counters[i] = 0;
 c04ec8c:	2300      	movs	r3, #0
    return crc16((uint8_t *)data, len);
 c04ec8e:	211c      	movs	r1, #28
 c04ec90:	a801      	add	r0, sp, #4
        nv_counters.counters[i] = 0;
 c04ec92:	e9cd 3302 	strd	r3, r3, [sp, #8]
 c04ec96:	e9cd 3304 	strd	r3, r3, [sp, #16]
 c04ec9a:	e9cd 3306 	strd	r3, r3, [sp, #24]
    nv_counters.init_value = NV_COUNTERS_INITIALIZED;
 c04ec9e:	9501      	str	r5, [sp, #4]
    return crc16((uint8_t *)data, len);
 c04eca0:	f7ff ff9b 	bl	c04ebda <crc16>
    nv_counters->crc = (uint32_t)crc;
 c04eca4:	9000      	str	r0, [sp, #0]
        err = DEVICE_NV_COUNTERS_FLASH_NAME.ProgramData(VALID_ADDRESS,
 c04eca6:	2220      	movs	r2, #32
 c04eca8:	4669      	mov	r1, sp
 c04ecaa:	f44f 3028 	mov.w	r0, #172032	@ 0x2a000
 c04ecae:	47a0      	blx	r4
        if (err != ARM_DRIVER_OK) {
 c04ecb0:	2800      	cmp	r0, #0
 c04ecb2:	d1c0      	bne.n	c04ec36 <tfm_plat_init_nv_counter+0xe>
        return TFM_PLAT_ERR_SUCCESS;
 c04ecb4:	2000      	movs	r0, #0
 c04ecb6:	e7c0      	b.n	c04ec3a <tfm_plat_init_nv_counter+0x12>
 c04ecb8:	0c05f7f4 	.word	0x0c05f7f4
 c04ecbc:	c0de0042 	.word	0xc0de0042

0c04ecc0 <tfm_plat_read_nv_counter>:

enum tfm_plat_err_t tfm_plat_read_nv_counter(enum tfm_nv_counter_t counter_id,
                                             uint32_t size, uint8_t *val)
{
 c04ecc0:	460b      	mov	r3, r1
    int32_t  err;
    uint32_t flash_addr = VALID_ADDRESS
                           + offsetof(struct nv_counters_t, counters)
                           + (counter_id * NV_COUNTER_SIZE);

    if (size != NV_COUNTER_SIZE) {
 c04ecc2:	2b04      	cmp	r3, #4
{
 c04ecc4:	4611      	mov	r1, r2
 c04ecc6:	b510      	push	{r4, lr}
    if (size != NV_COUNTER_SIZE) {
 c04ecc8:	d002      	beq.n	c04ecd0 <tfm_plat_read_nv_counter+0x10>
        return TFM_PLAT_ERR_SYSTEM_ERR;
 c04ecca:	f643 205c 	movw	r0, #14940	@ 0x3a5c
    if (err != ARM_DRIVER_OK) {
        return TFM_PLAT_ERR_SYSTEM_ERR;
    }

    return TFM_PLAT_ERR_SUCCESS;
}
 c04ecce:	bd10      	pop	{r4, pc}
    err = DEVICE_NV_COUNTERS_FLASH_NAME.ReadData(flash_addr, val, NV_COUNTER_SIZE);
 c04ecd0:	4c05      	ldr	r4, [pc, #20]	@ (c04ece8 <tfm_plat_read_nv_counter+0x28>)
                           + (counter_id * NV_COUNTER_SIZE);
 c04ecd2:	f500 4028 	add.w	r0, r0, #43008	@ 0xa800
 c04ecd6:	3002      	adds	r0, #2
    err = DEVICE_NV_COUNTERS_FLASH_NAME.ReadData(flash_addr, val, NV_COUNTER_SIZE);
 c04ecd8:	461a      	mov	r2, r3
 c04ecda:	0080      	lsls	r0, r0, #2
 c04ecdc:	6963      	ldr	r3, [r4, #20]
 c04ecde:	4798      	blx	r3
    if (err != ARM_DRIVER_OK) {
 c04ece0:	2800      	cmp	r0, #0
 c04ece2:	d0f4      	beq.n	c04ecce <tfm_plat_read_nv_counter+0xe>
 c04ece4:	e7f1      	b.n	c04ecca <tfm_plat_read_nv_counter+0xa>
 c04ece6:	bf00      	nop
 c04ece8:	0c05f7f4 	.word	0x0c05f7f4

0c04ecec <tfm_plat_set_nv_counter>:

enum tfm_plat_err_t tfm_plat_set_nv_counter(enum tfm_nv_counter_t counter_id,
                                            uint32_t value)
{
 c04ecec:	b5f0      	push	{r4, r5, r6, r7, lr}
    int32_t  err;
    struct nv_counters_t nv_counters;

    /* Read the whole sector so we can write it back to flash later */
    err = DEVICE_NV_COUNTERS_FLASH_NAME.ReadData(VALID_ADDRESS,
 c04ecee:	4e1f      	ldr	r6, [pc, #124]	@ (c04ed6c <tfm_plat_set_nv_counter+0x80>)
{
 c04ecf0:	b089      	sub	sp, #36	@ 0x24
 c04ecf2:	4604      	mov	r4, r0
 c04ecf4:	460d      	mov	r5, r1
    err = DEVICE_NV_COUNTERS_FLASH_NAME.ReadData(VALID_ADDRESS,
 c04ecf6:	2220      	movs	r2, #32
 c04ecf8:	4669      	mov	r1, sp
 c04ecfa:	f44f 3028 	mov.w	r0, #172032	@ 0x2a000
 c04ecfe:	6973      	ldr	r3, [r6, #20]
 c04ed00:	4798      	blx	r3
                                             &nv_counters,
                                             sizeof(struct nv_counters_t));
    if (err != ARM_DRIVER_OK) {
 c04ed02:	b118      	cbz	r0, c04ed0c <tfm_plat_set_nv_counter+0x20>
        return TFM_PLAT_ERR_SYSTEM_ERR;
 c04ed04:	f643 205c 	movw	r0, #14940	@ 0x3a5c
            return TFM_PLAT_ERR_SYSTEM_ERR;
        }
    }

    return TFM_PLAT_ERR_SUCCESS;
}
 c04ed08:	b009      	add	sp, #36	@ 0x24
 c04ed0a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if (value != nv_counters.counters[counter_id]) {
 c04ed0c:	ab08      	add	r3, sp, #32
 c04ed0e:	3402      	adds	r4, #2
 c04ed10:	eb03 0484 	add.w	r4, r3, r4, lsl #2
 c04ed14:	f854 3c20 	ldr.w	r3, [r4, #-32]
 c04ed18:	42ab      	cmp	r3, r5
 c04ed1a:	d101      	bne.n	c04ed20 <tfm_plat_set_nv_counter+0x34>
    return TFM_PLAT_ERR_SUCCESS;
 c04ed1c:	2000      	movs	r0, #0
 c04ed1e:	e7f3      	b.n	c04ed08 <tfm_plat_set_nv_counter+0x1c>
        if (value < nv_counters.counters[counter_id]) {
 c04ed20:	d821      	bhi.n	c04ed66 <tfm_plat_set_nv_counter+0x7a>
        err = DEVICE_NV_COUNTERS_FLASH_NAME.EraseSector(BACKUP_ADDRESS);
 c04ed22:	f44f 3030 	mov.w	r0, #180224	@ 0x2c000
 c04ed26:	69f7      	ldr	r7, [r6, #28]
 c04ed28:	47b8      	blx	r7
        if (err != ARM_DRIVER_OK) {
 c04ed2a:	2800      	cmp	r0, #0
 c04ed2c:	d1ea      	bne.n	c04ed04 <tfm_plat_set_nv_counter+0x18>
    return crc16((uint8_t *)data, len);
 c04ed2e:	211c      	movs	r1, #28
 c04ed30:	a801      	add	r0, sp, #4
        nv_counters.counters[counter_id] = value;
 c04ed32:	f844 5c20 	str.w	r5, [r4, #-32]
    return crc16((uint8_t *)data, len);
 c04ed36:	f7ff ff50 	bl	c04ebda <crc16>
        err = DEVICE_NV_COUNTERS_FLASH_NAME.ProgramData(BACKUP_ADDRESS,
 c04ed3a:	2220      	movs	r2, #32
    nv_counters->crc = (uint32_t)crc;
 c04ed3c:	9000      	str	r0, [sp, #0]
        err = DEVICE_NV_COUNTERS_FLASH_NAME.ProgramData(BACKUP_ADDRESS,
 c04ed3e:	4669      	mov	r1, sp
 c04ed40:	f44f 3030 	mov.w	r0, #180224	@ 0x2c000
 c04ed44:	69b4      	ldr	r4, [r6, #24]
 c04ed46:	47a0      	blx	r4
        if (err != ARM_DRIVER_OK) {
 c04ed48:	2800      	cmp	r0, #0
 c04ed4a:	d1db      	bne.n	c04ed04 <tfm_plat_set_nv_counter+0x18>
        err = DEVICE_NV_COUNTERS_FLASH_NAME.EraseSector(VALID_ADDRESS);
 c04ed4c:	f44f 3028 	mov.w	r0, #172032	@ 0x2a000
 c04ed50:	47b8      	blx	r7
        if (err != ARM_DRIVER_OK) {
 c04ed52:	2800      	cmp	r0, #0
 c04ed54:	d1d6      	bne.n	c04ed04 <tfm_plat_set_nv_counter+0x18>
        err = DEVICE_NV_COUNTERS_FLASH_NAME.ProgramData(VALID_ADDRESS,
 c04ed56:	2220      	movs	r2, #32
 c04ed58:	4669      	mov	r1, sp
 c04ed5a:	f44f 3028 	mov.w	r0, #172032	@ 0x2a000
 c04ed5e:	47a0      	blx	r4
        if (err != ARM_DRIVER_OK) {
 c04ed60:	2800      	cmp	r0, #0
 c04ed62:	d0db      	beq.n	c04ed1c <tfm_plat_set_nv_counter+0x30>
 c04ed64:	e7ce      	b.n	c04ed04 <tfm_plat_set_nv_counter+0x18>
            return TFM_PLAT_ERR_INVALID_INPUT;
 c04ed66:	f24a 30c5 	movw	r0, #41925	@ 0xa3c5
 c04ed6a:	e7cd      	b.n	c04ed08 <tfm_plat_set_nv_counter+0x1c>
 c04ed6c:	0c05f7f4 	.word	0x0c05f7f4

0c04ed70 <tfm_plat_increment_nv_counter>:

enum tfm_plat_err_t tfm_plat_increment_nv_counter(
                                           enum tfm_nv_counter_t counter_id)
{
 c04ed70:	b513      	push	{r0, r1, r4, lr}
    uint32_t security_cnt;
    enum tfm_plat_err_t err;

    err = tfm_plat_read_nv_counter(counter_id,
 c04ed72:	2104      	movs	r1, #4
 c04ed74:	aa01      	add	r2, sp, #4
{
 c04ed76:	4604      	mov	r4, r0
    err = tfm_plat_read_nv_counter(counter_id,
 c04ed78:	f7ff ffa2 	bl	c04ecc0 <tfm_plat_read_nv_counter>
                                   sizeof(security_cnt),
                                   (uint8_t *)&security_cnt);
    if (err != TFM_PLAT_ERR_SUCCESS) {
 c04ed7c:	b930      	cbnz	r0, c04ed8c <tfm_plat_increment_nv_counter+0x1c>
        return err;
    }

    if (security_cnt == UINT32_MAX) {
 c04ed7e:	9901      	ldr	r1, [sp, #4]
 c04ed80:	1c4b      	adds	r3, r1, #1
 c04ed82:	d005      	beq.n	c04ed90 <tfm_plat_increment_nv_counter+0x20>
        return TFM_PLAT_ERR_MAX_VALUE;
    }

    return tfm_plat_set_nv_counter(counter_id, security_cnt + 1u);
 c04ed84:	4620      	mov	r0, r4
 c04ed86:	3101      	adds	r1, #1
 c04ed88:	f7ff ffb0 	bl	c04ecec <tfm_plat_set_nv_counter>
 c04ed8c:	b002      	add	sp, #8
 c04ed8e:	bd10      	pop	{r4, pc}
        return TFM_PLAT_ERR_MAX_VALUE;
 c04ed90:	f245 50a3 	movw	r0, #21923	@ 0x55a3
 c04ed94:	e7fa      	b.n	c04ed8c <tfm_plat_increment_nv_counter+0x1c>
	...

0c04ed98 <rsa_mpi2pka_mul>:
 * @retval      MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED    Error in the HW
 */
static int rsa_mpi2pka_mul( mbedtls_mpi *AxB,
                            const mbedtls_mpi *A,
                            const mbedtls_mpi *B )
{
 c04ed98:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c04ed9c:	b08d      	sub	sp, #52	@ 0x34
 c04ed9e:	9001      	str	r0, [sp, #4]
           AxB_len;
    uint8_t *A_binary = NULL;
    uint8_t *B_binary = NULL;
    uint8_t *AxB_binary = NULL;

    A_len = mbedtls_mpi_size( A );
 c04eda0:	4608      	mov	r0, r1
{
 c04eda2:	460c      	mov	r4, r1
 c04eda4:	4616      	mov	r6, r2
    A_len = mbedtls_mpi_size( A );
 c04eda6:	f004 fbd8 	bl	c05355a <mbedtls_mpi_size>
    A_binary = mbedtls_calloc( 1, A_len );
 c04edaa:	4601      	mov	r1, r0
    A_len = mbedtls_mpi_size( A );
 c04edac:	4605      	mov	r5, r0
    A_binary = mbedtls_calloc( 1, A_len );
 c04edae:	2001      	movs	r0, #1
 c04edb0:	f7ec faf8 	bl	c03b3a4 <mbedtls_calloc>
    MBEDTLS_MPI_CHK( ( A_binary == NULL ) ? MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED : 0 );
 c04edb4:	4681      	mov	r9, r0
 c04edb6:	2800      	cmp	r0, #0
 c04edb8:	f000 80e8 	beq.w	c04ef8c <rsa_mpi2pka_mul+0x1f4>
    MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( A, A_binary, A_len ) );
 c04edbc:	4601      	mov	r1, r0
 c04edbe:	462a      	mov	r2, r5
 c04edc0:	4620      	mov	r0, r4
 c04edc2:	f004 fc49 	bl	c053658 <mbedtls_mpi_write_binary>
 c04edc6:	4604      	mov	r4, r0
 c04edc8:	2800      	cmp	r0, #0
 c04edca:	f040 80e5 	bne.w	c04ef98 <rsa_mpi2pka_mul+0x200>

    B_len = mbedtls_mpi_size( B );
 c04edce:	4630      	mov	r0, r6
 c04edd0:	f004 fbc3 	bl	c05355a <mbedtls_mpi_size>
    B_binary = mbedtls_calloc( 1, B_len );
 c04edd4:	4601      	mov	r1, r0
    B_len = mbedtls_mpi_size( B );
 c04edd6:	4683      	mov	fp, r0
    B_binary = mbedtls_calloc( 1, B_len );
 c04edd8:	2001      	movs	r0, #1
 c04edda:	f7ec fae3 	bl	c03b3a4 <mbedtls_calloc>
    MBEDTLS_MPI_CHK( ( B_binary == NULL ) ? MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED : 0 );
 c04edde:	4607      	mov	r7, r0
 c04ede0:	2800      	cmp	r0, #0
 c04ede2:	f000 80dc 	beq.w	c04ef9e <rsa_mpi2pka_mul+0x206>
    MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( B, B_binary, B_len ) );
 c04ede6:	4601      	mov	r1, r0
 c04ede8:	465a      	mov	r2, fp
 c04edea:	4630      	mov	r0, r6
 c04edec:	f004 fc34 	bl	c053658 <mbedtls_mpi_write_binary>
 c04edf0:	4604      	mov	r4, r0
 c04edf2:	2800      	cmp	r0, #0
 c04edf4:	f040 80d7 	bne.w	c04efa6 <rsa_mpi2pka_mul+0x20e>

    AxB_len = A_len + B_len;
 c04edf8:	eb05 030b 	add.w	r3, r5, fp
    AxB_binary = mbedtls_calloc( 1, AxB_len );
 c04edfc:	4619      	mov	r1, r3
 c04edfe:	2001      	movs	r0, #1
    AxB_len = A_len + B_len;
 c04ee00:	9300      	str	r3, [sp, #0]
    AxB_binary = mbedtls_calloc( 1, AxB_len );
 c04ee02:	f7ec facf 	bl	c03b3a4 <mbedtls_calloc>
    MBEDTLS_MPI_CHK( ( AxB_binary == NULL ) ? MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED : 0 );
 c04ee06:	4606      	mov	r6, r0
 c04ee08:	2800      	cmp	r0, #0
 c04ee0a:	f000 80c9 	beq.w	c04efa0 <rsa_mpi2pka_mul+0x208>
    if ( A_len != B_len )
 c04ee0e:	455d      	cmp	r5, fp
    PKA_HandleTypeDef hpka = {0};
 c04ee10:	e9cd 4406 	strd	r4, r4, [sp, #24]
    PKA_MulInTypeDef in = {0};
 c04ee14:	e9cd 4408 	strd	r4, r4, [sp, #32]
 c04ee18:	e9cd 440a 	strd	r4, r4, [sp, #40]	@ 0x28
    if ( A_len != B_len )
 c04ee1c:	d01b      	beq.n	c04ee56 <rsa_mpi2pka_mul+0xbe>
        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
 c04ee1e:	f5a4 4481 	sub.w	r4, r4, #16512	@ 0x4080
    MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary_le( AxB, AxB_binary, AxB_len ) );

cleanup:
    if (A_binary != NULL)
    {
        mbedtls_platform_zeroize( A_binary, A_len );
 c04ee22:	4648      	mov	r0, r9
 c04ee24:	4629      	mov	r1, r5
 c04ee26:	f7ec fad3 	bl	c03b3d0 <mbedtls_platform_zeroize>
        mbedtls_free( A_binary );
 c04ee2a:	4648      	mov	r0, r9
 c04ee2c:	f7ec fac0 	bl	c03b3b0 <mbedtls_free>
    }

    if (B_binary != NULL)
 c04ee30:	b137      	cbz	r7, c04ee40 <rsa_mpi2pka_mul+0xa8>
    {
        mbedtls_platform_zeroize( B_binary, B_len );
 c04ee32:	4638      	mov	r0, r7
 c04ee34:	4659      	mov	r1, fp
 c04ee36:	f7ec facb 	bl	c03b3d0 <mbedtls_platform_zeroize>
        mbedtls_free( B_binary );
 c04ee3a:	4638      	mov	r0, r7
 c04ee3c:	f7ec fab8 	bl	c03b3b0 <mbedtls_free>
    }

    if (AxB_binary != NULL)
 c04ee40:	2e00      	cmp	r6, #0
 c04ee42:	f000 80a5 	beq.w	c04ef90 <rsa_mpi2pka_mul+0x1f8>
    {
        mbedtls_platform_zeroize( AxB_binary, AxB_len );
 c04ee46:	4630      	mov	r0, r6
 c04ee48:	9900      	ldr	r1, [sp, #0]
 c04ee4a:	f7ec fac1 	bl	c03b3d0 <mbedtls_platform_zeroize>
        mbedtls_free( AxB_binary );
 c04ee4e:	4630      	mov	r0, r6
 c04ee50:	f7ec faae 	bl	c03b3b0 <mbedtls_free>
    }

     return ret;
 c04ee54:	e09c      	b.n	c04ef90 <rsa_mpi2pka_mul+0x1f8>
    input_A = mbedtls_calloc( 1, op_len );
 c04ee56:	4629      	mov	r1, r5
 c04ee58:	2001      	movs	r0, #1
 c04ee5a:	f7ec faa3 	bl	c03b3a4 <mbedtls_calloc>
    MBEDTLS_MPI_CHK( ( input_A == NULL ) ? MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED : 0 );
 c04ee5e:	4682      	mov	sl, r0
 c04ee60:	bb70      	cbnz	r0, c04eec0 <rsa_mpi2pka_mul+0x128>
    uint32_t *input_B = NULL;
 c04ee62:	f04f 0800 	mov.w	r8, #0
    MBEDTLS_MPI_CHK( ( HAL_PKA_Init( &hpka ) != HAL_OK ) ? MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED : 0 );
 c04ee66:	f06f 046f 	mvn.w	r4, #111	@ 0x6f
    if (HAL_PKA_GetState(&hpka) != HAL_PKA_STATE_RESET)
 c04ee6a:	a806      	add	r0, sp, #24
 c04ee6c:	f7f0 fbbc 	bl	c03f5e8 <HAL_PKA_GetState>
 c04ee70:	b110      	cbz	r0, c04ee78 <rsa_mpi2pka_mul+0xe0>
        HAL_PKA_DeInit( &hpka );
 c04ee72:	a806      	add	r0, sp, #24
 c04ee74:	f7f0 fb84 	bl	c03f580 <HAL_PKA_DeInit>
    __HAL_RCC_PKA_CLK_DISABLE();
 c04ee78:	4a4c      	ldr	r2, [pc, #304]	@ (c04efac <rsa_mpi2pka_mul+0x214>)
 c04ee7a:	f8d2 308c 	ldr.w	r3, [r2, #140]	@ 0x8c
 c04ee7e:	f423 2300 	bic.w	r3, r3, #524288	@ 0x80000
 c04ee82:	f8c2 308c 	str.w	r3, [r2, #140]	@ 0x8c
    if (input_A != NULL)
 c04ee86:	f1ba 0f00 	cmp.w	sl, #0
 c04ee8a:	d006      	beq.n	c04ee9a <rsa_mpi2pka_mul+0x102>
        mbedtls_platform_zeroize( input_A, op_len );
 c04ee8c:	4650      	mov	r0, sl
 c04ee8e:	4629      	mov	r1, r5
 c04ee90:	f7ec fa9e 	bl	c03b3d0 <mbedtls_platform_zeroize>
        mbedtls_free( input_A );
 c04ee94:	4650      	mov	r0, sl
 c04ee96:	f7ec fa8b 	bl	c03b3b0 <mbedtls_free>
    if (input_B != NULL)
 c04ee9a:	f1b8 0f00 	cmp.w	r8, #0
 c04ee9e:	d006      	beq.n	c04eeae <rsa_mpi2pka_mul+0x116>
        mbedtls_platform_zeroize( input_B, op_len );
 c04eea0:	4640      	mov	r0, r8
 c04eea2:	4629      	mov	r1, r5
 c04eea4:	f7ec fa94 	bl	c03b3d0 <mbedtls_platform_zeroize>
        mbedtls_free( input_B );
 c04eea8:	4640      	mov	r0, r8
 c04eeaa:	f7ec fa81 	bl	c03b3b0 <mbedtls_free>
    MBEDTLS_MPI_CHK( rsa_pka_arithmetic_mul( A_binary,
 c04eeae:	2c00      	cmp	r4, #0
 c04eeb0:	d176      	bne.n	c04efa0 <rsa_mpi2pka_mul+0x208>
    MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary_le( AxB, AxB_binary, AxB_len ) );
 c04eeb2:	4631      	mov	r1, r6
 c04eeb4:	9a00      	ldr	r2, [sp, #0]
 c04eeb6:	9801      	ldr	r0, [sp, #4]
 c04eeb8:	f004 fb55 	bl	c053566 <mbedtls_mpi_read_binary_le>
 c04eebc:	4604      	mov	r4, r0
cleanup:
 c04eebe:	e7b0      	b.n	c04ee22 <rsa_mpi2pka_mul+0x8a>
    for( i = op_len/4 ; i > 0; i-- )
 c04eec0:	f025 0303 	bic.w	r3, r5, #3
 c04eec4:	08aa      	lsrs	r2, r5, #2
 c04eec6:	eb09 0003 	add.w	r0, r9, r3
 c04eeca:	f1aa 0c04 	sub.w	ip, sl, #4
 c04eece:	4548      	cmp	r0, r9
 c04eed0:	d136      	bne.n	c04ef40 <rsa_mpi2pka_mul+0x1a8>
    input_B = mbedtls_calloc( 1, op_len );
 c04eed2:	4629      	mov	r1, r5
 c04eed4:	2001      	movs	r0, #1
 c04eed6:	e9cd 2302 	strd	r2, r3, [sp, #8]
 c04eeda:	f7ec fa63 	bl	c03b3a4 <mbedtls_calloc>
    MBEDTLS_MPI_CHK( ( input_B == NULL ) ? MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED : 0 );
 c04eede:	4680      	mov	r8, r0
 c04eee0:	2800      	cmp	r0, #0
 c04eee2:	d0be      	beq.n	c04ee62 <rsa_mpi2pka_mul+0xca>
 c04eee4:	9b03      	ldr	r3, [sp, #12]
 c04eee6:	9a02      	ldr	r2, [sp, #8]
 c04eee8:	443b      	add	r3, r7
 c04eeea:	3804      	subs	r0, #4
    for( i = op_len/4 ; i > 0; i-- )
 c04eeec:	429f      	cmp	r7, r3
 c04eeee:	d13a      	bne.n	c04ef66 <rsa_mpi2pka_mul+0x1ce>
    in.pOp1 = input_A;
 c04eef0:	e9cd 2a09 	strd	r2, sl, [sp, #36]	@ 0x24
    __HAL_RCC_PKA_CLK_ENABLE();
 c04eef4:	4b2d      	ldr	r3, [pc, #180]	@ (c04efac <rsa_mpi2pka_mul+0x214>)
    in.pOp2 = input_B;
 c04eef6:	f8cd 802c 	str.w	r8, [sp, #44]	@ 0x2c
    __HAL_RCC_PKA_CLK_ENABLE();
 c04eefa:	f8d3 208c 	ldr.w	r2, [r3, #140]	@ 0x8c
    MBEDTLS_MPI_CHK( ( HAL_PKA_Init( &hpka ) != HAL_OK ) ? MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED : 0 );
 c04eefe:	a806      	add	r0, sp, #24
    __HAL_RCC_PKA_CLK_ENABLE();
 c04ef00:	f442 2200 	orr.w	r2, r2, #524288	@ 0x80000
 c04ef04:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
 c04ef08:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 c04ef0c:	f403 2300 	and.w	r3, r3, #524288	@ 0x80000
 c04ef10:	9305      	str	r3, [sp, #20]
 c04ef12:	9b05      	ldr	r3, [sp, #20]
    hpka.Instance = PKA;
 c04ef14:	4b26      	ldr	r3, [pc, #152]	@ (c04efb0 <rsa_mpi2pka_mul+0x218>)
 c04ef16:	9306      	str	r3, [sp, #24]
    MBEDTLS_MPI_CHK( ( HAL_PKA_Init( &hpka ) != HAL_OK ) ? MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED : 0 );
 c04ef18:	f7f1 f8b9 	bl	c04008e <HAL_PKA_Init>
 c04ef1c:	2800      	cmp	r0, #0
 c04ef1e:	d1a2      	bne.n	c04ee66 <rsa_mpi2pka_mul+0xce>
    HAL_PKA_RAMReset(&hpka);
 c04ef20:	a806      	add	r0, sp, #24
 c04ef22:	f7f0 fb53 	bl	c03f5cc <HAL_PKA_RAMReset>
    MBEDTLS_MPI_CHK( ( HAL_PKA_Mul(&hpka, &in, ST_PKA_TIMEOUT) != HAL_OK ) ? MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED : 0 );
 c04ef26:	f241 3288 	movw	r2, #5000	@ 0x1388
 c04ef2a:	a909      	add	r1, sp, #36	@ 0x24
 c04ef2c:	a806      	add	r0, sp, #24
 c04ef2e:	f7f1 f877 	bl	c040020 <HAL_PKA_Mul>
 c04ef32:	2800      	cmp	r0, #0
 c04ef34:	d197      	bne.n	c04ee66 <rsa_mpi2pka_mul+0xce>
    HAL_PKA_Arithmetic_GetResult( &hpka, (uint32_t *)AxB );
 c04ef36:	4631      	mov	r1, r6
 c04ef38:	a806      	add	r0, sp, #24
 c04ef3a:	f7f0 fc87 	bl	c03f84c <HAL_PKA_Arithmetic_GetResult>
 c04ef3e:	e794      	b.n	c04ee6a <rsa_mpi2pka_mul+0xd2>
        GET_UINT32_BE( input_A[( op_len/4 ) - i], A, 4*(i-1) );
 c04ef40:	f810 1c03 	ldrb.w	r1, [r0, #-3]
 c04ef44:	f810 ec04 	ldrb.w	lr, [r0, #-4]
 c04ef48:	0409      	lsls	r1, r1, #16
 c04ef4a:	ea41 610e 	orr.w	r1, r1, lr, lsl #24
 c04ef4e:	f810 ec01 	ldrb.w	lr, [r0, #-1]
 c04ef52:	3804      	subs	r0, #4
 c04ef54:	ea41 010e 	orr.w	r1, r1, lr
 c04ef58:	f890 e002 	ldrb.w	lr, [r0, #2]
 c04ef5c:	ea41 210e 	orr.w	r1, r1, lr, lsl #8
 c04ef60:	f84c 1f04 	str.w	r1, [ip, #4]!
    for( i = op_len/4 ; i > 0; i-- )
 c04ef64:	e7b3      	b.n	c04eece <rsa_mpi2pka_mul+0x136>
        GET_UINT32_BE( input_B[( op_len/4 ) - i], B, 4*(i-1) );
 c04ef66:	f813 1c03 	ldrb.w	r1, [r3, #-3]
 c04ef6a:	f813 cc04 	ldrb.w	ip, [r3, #-4]
 c04ef6e:	0409      	lsls	r1, r1, #16
 c04ef70:	ea41 610c 	orr.w	r1, r1, ip, lsl #24
 c04ef74:	f813 cc01 	ldrb.w	ip, [r3, #-1]
 c04ef78:	3b04      	subs	r3, #4
 c04ef7a:	ea41 010c 	orr.w	r1, r1, ip
 c04ef7e:	f893 c002 	ldrb.w	ip, [r3, #2]
 c04ef82:	ea41 210c 	orr.w	r1, r1, ip, lsl #8
 c04ef86:	f840 1f04 	str.w	r1, [r0, #4]!
    for( i = op_len/4 ; i > 0; i-- )
 c04ef8a:	e7af      	b.n	c04eeec <rsa_mpi2pka_mul+0x154>
    MBEDTLS_MPI_CHK( ( A_binary == NULL ) ? MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED : 0 );
 c04ef8c:	f06f 046f 	mvn.w	r4, #111	@ 0x6f
}
 c04ef90:	4620      	mov	r0, r4
 c04ef92:	b00d      	add	sp, #52	@ 0x34
 c04ef94:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    uint8_t *AxB_binary = NULL;
 c04ef98:	2600      	movs	r6, #0
    uint8_t *B_binary = NULL;
 c04ef9a:	4637      	mov	r7, r6
 c04ef9c:	e741      	b.n	c04ee22 <rsa_mpi2pka_mul+0x8a>
    uint8_t *AxB_binary = NULL;
 c04ef9e:	4606      	mov	r6, r0
 c04efa0:	f06f 046f 	mvn.w	r4, #111	@ 0x6f
 c04efa4:	e73d      	b.n	c04ee22 <rsa_mpi2pka_mul+0x8a>
 c04efa6:	2600      	movs	r6, #0
 c04efa8:	e73b      	b.n	c04ee22 <rsa_mpi2pka_mul+0x8a>
 c04efaa:	bf00      	nop
 c04efac:	56020c00 	.word	0x56020c00
 c04efb0:	520c2000 	.word	0x520c2000

0c04efb4 <mgf_mask>:
 * \param slen      length of the source buffer
 * \param md_ctx    message digest context to use
 */
static int mgf_mask( unsigned char *dst, size_t dlen, unsigned char *src,
                      size_t slen, mbedtls_md_context_t *md_ctx )
{
 c04efb4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c04efb8:	b093      	sub	sp, #76	@ 0x4c
 c04efba:	4606      	mov	r6, r0
 c04efbc:	460d      	mov	r5, r1
 c04efbe:	4690      	mov	r8, r2
    unsigned char *p;
    unsigned int hlen;
    size_t i, use_len;
    int ret = 0;

    memset( mask, 0, MBEDTLS_MD_MAX_SIZE );
 c04efc0:	2100      	movs	r1, #0
 c04efc2:	2240      	movs	r2, #64	@ 0x40
 c04efc4:	a802      	add	r0, sp, #8
{
 c04efc6:	4699      	mov	r9, r3
 c04efc8:	9f1c      	ldr	r7, [sp, #112]	@ 0x70
    memset( mask, 0, MBEDTLS_MD_MAX_SIZE );
 c04efca:	f00c fbb0 	bl	c05b72e <memset>
    memset( counter, 0, 4 );
 c04efce:	2300      	movs	r3, #0

    hlen = mbedtls_md_get_size( md_ctx->md_info );
 c04efd0:	6838      	ldr	r0, [r7, #0]
    memset( counter, 0, 4 );
 c04efd2:	9301      	str	r3, [sp, #4]
    hlen = mbedtls_md_get_size( md_ctx->md_info );
 c04efd4:	f007 fd48 	bl	c056a68 <mbedtls_md_get_size>
 c04efd8:	4682      	mov	sl, r0

    /* Generate and apply dbMask */
    p = dst;

    while( dlen > 0 )
 c04efda:	b945      	cbnz	r5, c04efee <mgf_mask+0x3a>
        counter[3]++;

        dlen -= use_len;
    }

exit:
 c04efdc:	462c      	mov	r4, r5
    mbedtls_platform_zeroize( mask, sizeof( mask ) );
 c04efde:	a802      	add	r0, sp, #8
 c04efe0:	2140      	movs	r1, #64	@ 0x40
 c04efe2:	f7ec f9f5 	bl	c03b3d0 <mbedtls_platform_zeroize>

    return( ret );
}
 c04efe6:	4620      	mov	r0, r4
 c04efe8:	b013      	add	sp, #76	@ 0x4c
 c04efea:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if( dlen < hlen )
 c04efee:	4555      	cmp	r5, sl
        if( ( ret = mbedtls_md_starts( md_ctx ) ) != 0 )
 c04eff0:	4638      	mov	r0, r7
 c04eff2:	46ab      	mov	fp, r5
 c04eff4:	bf28      	it	cs
 c04eff6:	46d3      	movcs	fp, sl
 c04eff8:	f007 fc20 	bl	c05683c <mbedtls_md_starts>
 c04effc:	4604      	mov	r4, r0
 c04effe:	2800      	cmp	r0, #0
 c04f000:	d1ed      	bne.n	c04efde <mgf_mask+0x2a>
        if( ( ret = mbedtls_md_update( md_ctx, src, slen ) ) != 0 )
 c04f002:	464a      	mov	r2, r9
 c04f004:	4641      	mov	r1, r8
 c04f006:	4638      	mov	r0, r7
 c04f008:	f007 fc34 	bl	c056874 <mbedtls_md_update>
 c04f00c:	4604      	mov	r4, r0
 c04f00e:	2800      	cmp	r0, #0
 c04f010:	d1e5      	bne.n	c04efde <mgf_mask+0x2a>
        if( ( ret = mbedtls_md_update( md_ctx, counter, 4 ) ) != 0 )
 c04f012:	2204      	movs	r2, #4
 c04f014:	4638      	mov	r0, r7
 c04f016:	eb0d 0102 	add.w	r1, sp, r2
 c04f01a:	f007 fc2b 	bl	c056874 <mbedtls_md_update>
 c04f01e:	4604      	mov	r4, r0
 c04f020:	2800      	cmp	r0, #0
 c04f022:	d1dc      	bne.n	c04efde <mgf_mask+0x2a>
        if( ( ret = mbedtls_md_finish( md_ctx, mask ) ) != 0 )
 c04f024:	4638      	mov	r0, r7
 c04f026:	a902      	add	r1, sp, #8
 c04f028:	f007 fc3a 	bl	c0568a0 <mbedtls_md_finish>
 c04f02c:	4604      	mov	r4, r0
 c04f02e:	2800      	cmp	r0, #0
 c04f030:	d1d5      	bne.n	c04efde <mgf_mask+0x2a>
 c04f032:	aa02      	add	r2, sp, #8
 c04f034:	eb06 010b 	add.w	r1, r6, fp
        for( i = 0; i < use_len; ++i )
 c04f038:	428e      	cmp	r6, r1
 c04f03a:	d107      	bne.n	c04f04c <mgf_mask+0x98>
        counter[3]++;
 c04f03c:	f89d 3007 	ldrb.w	r3, [sp, #7]
        dlen -= use_len;
 c04f040:	eba5 050b 	sub.w	r5, r5, fp
        counter[3]++;
 c04f044:	3301      	adds	r3, #1
 c04f046:	f88d 3007 	strb.w	r3, [sp, #7]
        dlen -= use_len;
 c04f04a:	e7c6      	b.n	c04efda <mgf_mask+0x26>
            *p++ ^= mask[i];
 c04f04c:	f816 0b01 	ldrb.w	r0, [r6], #1
 c04f050:	f812 3b01 	ldrb.w	r3, [r2], #1
 c04f054:	4043      	eors	r3, r0
 c04f056:	f806 3c01 	strb.w	r3, [r6, #-1]
        for( i = 0; i < use_len; ++i )
 c04f05a:	e7ed      	b.n	c04f038 <mgf_mask+0x84>

0c04f05c <rsa_rsassa_pkcs1_v15_encode>:
static int rsa_rsassa_pkcs1_v15_encode( mbedtls_md_type_t md_alg,
                                        unsigned int hashlen,
                                        const unsigned char *hash,
                                        size_t dst_len,
                                        unsigned char *dst )
{
 c04f05c:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
 c04f060:	461e      	mov	r6, r3
    size_t oid_size  = 0;
 c04f062:	2300      	movs	r3, #0
{
 c04f064:	460c      	mov	r4, r1
 c04f066:	4691      	mov	r9, r2
    size_t nb_pad    = dst_len;
    unsigned char *p = dst;
    const char *oid  = NULL;

    /* Are we signing hashed or raw data? */
    if( md_alg != MBEDTLS_MD_NONE )
 c04f068:	4607      	mov	r7, r0
    const char *oid  = NULL;
 c04f06a:	e9cd 3300 	strd	r3, r3, [sp]
{
 c04f06e:	f8dd 8028 	ldr.w	r8, [sp, #40]	@ 0x28
    if( md_alg != MBEDTLS_MD_NONE )
 c04f072:	2800      	cmp	r0, #0
 c04f074:	d03e      	beq.n	c04f0f4 <rsa_rsassa_pkcs1_v15_encode+0x98>
    {
        const mbedtls_md_info_t *md_info = mbedtls_md_info_from_type( md_alg );
 c04f076:	f007 fb6b 	bl	c056750 <mbedtls_md_info_from_type>
        if( md_info == NULL )
 c04f07a:	4604      	mov	r4, r0
 c04f07c:	2800      	cmp	r0, #0
 c04f07e:	d06b      	beq.n	c04f158 <rsa_rsassa_pkcs1_v15_encode+0xfc>
            return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );

        if( mbedtls_oid_get_oid_by_md( md_alg, &oid, &oid_size ) != 0 )
 c04f080:	466a      	mov	r2, sp
 c04f082:	4638      	mov	r0, r7
 c04f084:	a901      	add	r1, sp, #4
 c04f086:	f007 fe9f 	bl	c056dc8 <mbedtls_oid_get_oid_by_md>
 c04f08a:	2800      	cmp	r0, #0
 c04f08c:	d164      	bne.n	c04f158 <rsa_rsassa_pkcs1_v15_encode+0xfc>
            return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );

        hashlen = mbedtls_md_get_size( md_info );
 c04f08e:	4620      	mov	r0, r4
 c04f090:	f007 fcea 	bl	c056a68 <mbedtls_md_get_size>

        /* Double-check that 8 + hashlen + oid_size can be used as a
         * 1-byte ASN.1 length encoding and that there's no overflow. */
        if( 8 + hashlen + oid_size  >= 0x80         ||
 c04f094:	9b00      	ldr	r3, [sp, #0]
        hashlen = mbedtls_md_get_size( md_info );
 c04f096:	4604      	mov	r4, r0
        if( 8 + hashlen + oid_size  >= 0x80         ||
 c04f098:	4403      	add	r3, r0
 c04f09a:	f103 0208 	add.w	r2, r3, #8
 c04f09e:	2a7f      	cmp	r2, #127	@ 0x7f
 c04f0a0:	d85a      	bhi.n	c04f158 <rsa_rsassa_pkcs1_v15_encode+0xfc>
            10 + hashlen            <  hashlen      ||
            10 + hashlen + oid_size <  10 + hashlen )
 c04f0a2:	f103 020a 	add.w	r2, r3, #10
 c04f0a6:	f100 010a 	add.w	r1, r0, #10
            10 + hashlen            <  hashlen      ||
 c04f0aa:	428a      	cmp	r2, r1
 c04f0ac:	d354      	bcc.n	c04f158 <rsa_rsassa_pkcs1_v15_encode+0xfc>
         *   (Insist on 1-byte length encodings to protect against variants of
         *    Bleichenbacher's forgery attack against lax PKCS#1v1.5 verification)
         * - Need hashlen bytes for hash
         * - Need oid_size bytes for hash alg OID.
         */
        if( nb_pad < 10 + hashlen + oid_size )
 c04f0ae:	42b2      	cmp	r2, r6
 c04f0b0:	d852      	bhi.n	c04f158 <rsa_rsassa_pkcs1_v15_encode+0xfc>
            return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
        nb_pad -= 10 + hashlen + oid_size;
 c04f0b2:	f1a6 050a 	sub.w	r5, r6, #10
 c04f0b6:	1aed      	subs	r5, r5, r3
        nb_pad -= hashlen;
    }

    /* Need space for signature header and padding delimiter (3 bytes),
     * and 8 bytes for the minimal padding */
    if( nb_pad < 3 + 8 )
 c04f0b8:	2d0a      	cmp	r5, #10
 c04f0ba:	d94d      	bls.n	c04f158 <rsa_rsassa_pkcs1_v15_encode+0xfc>

    /* Now nb_pad is the amount of memory to be filled
     * with padding, and at least 8 bytes long. */

    /* Write signature header and padding */
    *p++ = 0;
 c04f0bc:	4643      	mov	r3, r8
 c04f0be:	f04f 0a00 	mov.w	sl, #0
    *p++ = MBEDTLS_RSA_SIGN;
 c04f0c2:	2201      	movs	r2, #1
    *p++ = 0;
 c04f0c4:	f803 ab02 	strb.w	sl, [r3], #2
    nb_pad -= 3;
 c04f0c8:	3d03      	subs	r5, #3
    memset( p, 0xFF, nb_pad );
 c04f0ca:	4618      	mov	r0, r3
    *p++ = MBEDTLS_RSA_SIGN;
 c04f0cc:	f888 2001 	strb.w	r2, [r8, #1]
    memset( p, 0xFF, nb_pad );
 c04f0d0:	21ff      	movs	r1, #255	@ 0xff
 c04f0d2:	462a      	mov	r2, r5
 c04f0d4:	f00c fb2b 	bl	c05b72e <memset>
 c04f0d8:	4603      	mov	r3, r0
    p += nb_pad;
 c04f0da:	4428      	add	r0, r5
    *p++ = 0;
 c04f0dc:	f803 a005 	strb.w	sl, [r3, r5]

    /* Are we signing raw data? */
    if( md_alg == MBEDTLS_MD_NONE )
 c04f0e0:	b967      	cbnz	r7, c04f0fc <rsa_rsassa_pkcs1_v15_encode+0xa0>
    {
        memcpy( p, hash, hashlen );
 c04f0e2:	4622      	mov	r2, r4
 c04f0e4:	4649      	mov	r1, r9
 c04f0e6:	3001      	adds	r0, #1
 c04f0e8:	f00c fab0 	bl	c05b64c <memcpy>
        return( 0 );
 c04f0ec:	2000      	movs	r0, #0
        mbedtls_platform_zeroize( dst, dst_len );
        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
    }

    return( 0 );
}
 c04f0ee:	b002      	add	sp, #8
 c04f0f0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        if( nb_pad < hashlen )
 c04f0f4:	428e      	cmp	r6, r1
 c04f0f6:	d32f      	bcc.n	c04f158 <rsa_rsassa_pkcs1_v15_encode+0xfc>
        nb_pad -= hashlen;
 c04f0f8:	1a75      	subs	r5, r6, r1
 c04f0fa:	e7dd      	b.n	c04f0b8 <rsa_rsassa_pkcs1_v15_encode+0x5c>
    *p++ = MBEDTLS_ASN1_SEQUENCE | MBEDTLS_ASN1_CONSTRUCTED;
 c04f0fc:	2230      	movs	r2, #48	@ 0x30
 c04f0fe:	7042      	strb	r2, [r0, #1]
    *p++ = (unsigned char)( 0x08 + oid_size + hashlen );
 c04f100:	9d00      	ldr	r5, [sp, #0]
    *p++ = MBEDTLS_ASN1_SEQUENCE | MBEDTLS_ASN1_CONSTRUCTED;
 c04f102:	70c2      	strb	r2, [r0, #3]
    *p++ = (unsigned char)( 0x08 + oid_size + hashlen );
 c04f104:	f105 0308 	add.w	r3, r5, #8
    *p++ = (unsigned char)( 0x04 + oid_size );
 c04f108:	b2ea      	uxtb	r2, r5
    *p++ = (unsigned char)( 0x08 + oid_size + hashlen );
 c04f10a:	fa53 f384 	uxtab	r3, r3, r4
 c04f10e:	7083      	strb	r3, [r0, #2]
    *p++ = (unsigned char)( 0x04 + oid_size );
 c04f110:	1d13      	adds	r3, r2, #4
 c04f112:	7103      	strb	r3, [r0, #4]
    *p++ = MBEDTLS_ASN1_OID;
 c04f114:	2306      	movs	r3, #6
 c04f116:	7143      	strb	r3, [r0, #5]
    *p++ = (unsigned char) oid_size;
 c04f118:	1dc3      	adds	r3, r0, #7
 c04f11a:	7182      	strb	r2, [r0, #6]
    memcpy( p, oid, oid_size );
 c04f11c:	9901      	ldr	r1, [sp, #4]
 c04f11e:	462a      	mov	r2, r5
 c04f120:	4618      	mov	r0, r3
 c04f122:	f00c fa93 	bl	c05b64c <memcpy>
    *p++ = MBEDTLS_ASN1_NULL;
 c04f126:	2105      	movs	r1, #5
    *p++ = MBEDTLS_ASN1_OCTET_STRING;
 c04f128:	2304      	movs	r3, #4
    p += oid_size;
 c04f12a:	1942      	adds	r2, r0, r5
    *p++ = MBEDTLS_ASN1_NULL;
 c04f12c:	5541      	strb	r1, [r0, r5]
    *p++ = (unsigned char)( 0x08 + oid_size + hashlen );
 c04f12e:	b2e7      	uxtb	r7, r4
    *p++ = MBEDTLS_ASN1_OCTET_STRING;
 c04f130:	7093      	strb	r3, [r2, #2]
    *p++ = (unsigned char) hashlen;
 c04f132:	18d3      	adds	r3, r2, r3
    memcpy( p, hash, hashlen );
 c04f134:	4618      	mov	r0, r3
    *p++ = 0x00;
 c04f136:	f882 a001 	strb.w	sl, [r2, #1]
    *p++ = (unsigned char) hashlen;
 c04f13a:	70d7      	strb	r7, [r2, #3]
    memcpy( p, hash, hashlen );
 c04f13c:	4649      	mov	r1, r9
 c04f13e:	4622      	mov	r2, r4
 c04f140:	f00c fa84 	bl	c05b64c <memcpy>
 c04f144:	4603      	mov	r3, r0
    if( p != dst + dst_len )
 c04f146:	eb08 0206 	add.w	r2, r8, r6
    p += hashlen;
 c04f14a:	4423      	add	r3, r4
    if( p != dst + dst_len )
 c04f14c:	429a      	cmp	r2, r3
 c04f14e:	d0cd      	beq.n	c04f0ec <rsa_rsassa_pkcs1_v15_encode+0x90>
        mbedtls_platform_zeroize( dst, dst_len );
 c04f150:	4631      	mov	r1, r6
 c04f152:	4640      	mov	r0, r8
 c04f154:	f7ec f93c 	bl	c03b3d0 <mbedtls_platform_zeroize>
            return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
 c04f158:	4800      	ldr	r0, [pc, #0]	@ (c04f15c <rsa_rsassa_pkcs1_v15_encode+0x100>)
 c04f15a:	e7c8      	b.n	c04f0ee <rsa_rsassa_pkcs1_v15_encode+0x92>
 c04f15c:	ffffbf80 	.word	0xffffbf80

0c04f160 <rsa_check_context.constprop.0>:
static int rsa_check_context( mbedtls_rsa_context const *ctx, int is_priv,
 c04f160:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    if( ctx->len != mbedtls_mpi_size( &ctx->N ) ||
 c04f162:	f100 0608 	add.w	r6, r0, #8
 c04f166:	6847      	ldr	r7, [r0, #4]
static int rsa_check_context( mbedtls_rsa_context const *ctx, int is_priv,
 c04f168:	4604      	mov	r4, r0
    if( ctx->len != mbedtls_mpi_size( &ctx->N ) ||
 c04f16a:	4630      	mov	r0, r6
static int rsa_check_context( mbedtls_rsa_context const *ctx, int is_priv,
 c04f16c:	460d      	mov	r5, r1
    if( ctx->len != mbedtls_mpi_size( &ctx->N ) ||
 c04f16e:	f004 f9f4 	bl	c05355a <mbedtls_mpi_size>
 c04f172:	4287      	cmp	r7, r0
 c04f174:	d116      	bne.n	c04f1a4 <rsa_check_context.constprop.0+0x44>
 c04f176:	6863      	ldr	r3, [r4, #4]
 c04f178:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 c04f17c:	d812      	bhi.n	c04f1a4 <rsa_check_context.constprop.0+0x44>
    if( mbedtls_mpi_cmp_int( &ctx->N, 0 ) <= 0 ||
 c04f17e:	2100      	movs	r1, #0
 c04f180:	4630      	mov	r0, r6
 c04f182:	f004 fb9e 	bl	c0538c2 <mbedtls_mpi_cmp_int>
 c04f186:	2800      	cmp	r0, #0
 c04f188:	dd0c      	ble.n	c04f1a4 <rsa_check_context.constprop.0+0x44>
        mbedtls_mpi_get_bit( &ctx->N, 0 ) == 0  )
 c04f18a:	2100      	movs	r1, #0
 c04f18c:	4630      	mov	r0, r6
 c04f18e:	f004 f972 	bl	c053476 <mbedtls_mpi_get_bit>
    if( mbedtls_mpi_cmp_int( &ctx->N, 0 ) <= 0 ||
 c04f192:	b138      	cbz	r0, c04f1a4 <rsa_check_context.constprop.0+0x44>
    if( is_priv &&
 c04f194:	b945      	cbnz	r5, c04f1a8 <rsa_check_context.constprop.0+0x48>
    if( mbedtls_mpi_cmp_int( &ctx->E, 0 ) <= 0 )
 c04f196:	2100      	movs	r1, #0
 c04f198:	f104 0014 	add.w	r0, r4, #20
 c04f19c:	f004 fb91 	bl	c0538c2 <mbedtls_mpi_cmp_int>
 c04f1a0:	2800      	cmp	r0, #0
 c04f1a2:	dc1e      	bgt.n	c04f1e2 <rsa_check_context.constprop.0+0x82>
        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
 c04f1a4:	481b      	ldr	r0, [pc, #108]	@ (c04f214 <rsa_check_context.constprop.0+0xb4>)
 c04f1a6:	e01e      	b.n	c04f1e6 <rsa_check_context.constprop.0+0x86>
        ( mbedtls_mpi_cmp_int( &ctx->P, 0 ) <= 0 ||
 c04f1a8:	f104 062c 	add.w	r6, r4, #44	@ 0x2c
 c04f1ac:	2100      	movs	r1, #0
 c04f1ae:	4630      	mov	r0, r6
 c04f1b0:	f004 fb87 	bl	c0538c2 <mbedtls_mpi_cmp_int>
    if( is_priv &&
 c04f1b4:	2800      	cmp	r0, #0
 c04f1b6:	ddf5      	ble.n	c04f1a4 <rsa_check_context.constprop.0+0x44>
          mbedtls_mpi_get_bit( &ctx->P, 0 ) == 0 ||
 c04f1b8:	2100      	movs	r1, #0
 c04f1ba:	4630      	mov	r0, r6
 c04f1bc:	f004 f95b 	bl	c053476 <mbedtls_mpi_get_bit>
        ( mbedtls_mpi_cmp_int( &ctx->P, 0 ) <= 0 ||
 c04f1c0:	2800      	cmp	r0, #0
 c04f1c2:	d0ef      	beq.n	c04f1a4 <rsa_check_context.constprop.0+0x44>
          mbedtls_mpi_cmp_int( &ctx->Q, 0 ) <= 0 ||
 c04f1c4:	f104 0638 	add.w	r6, r4, #56	@ 0x38
 c04f1c8:	2100      	movs	r1, #0
 c04f1ca:	4630      	mov	r0, r6
 c04f1cc:	f004 fb79 	bl	c0538c2 <mbedtls_mpi_cmp_int>
          mbedtls_mpi_get_bit( &ctx->P, 0 ) == 0 ||
 c04f1d0:	2800      	cmp	r0, #0
 c04f1d2:	dde7      	ble.n	c04f1a4 <rsa_check_context.constprop.0+0x44>
          mbedtls_mpi_get_bit( &ctx->Q, 0 ) == 0  ) )
 c04f1d4:	2100      	movs	r1, #0
 c04f1d6:	4630      	mov	r0, r6
 c04f1d8:	f004 f94d 	bl	c053476 <mbedtls_mpi_get_bit>
          mbedtls_mpi_cmp_int( &ctx->Q, 0 ) <= 0 ||
 c04f1dc:	2800      	cmp	r0, #0
 c04f1de:	d1da      	bne.n	c04f196 <rsa_check_context.constprop.0+0x36>
 c04f1e0:	e7e0      	b.n	c04f1a4 <rsa_check_context.constprop.0+0x44>
    if( is_priv &&
 c04f1e2:	b90d      	cbnz	r5, c04f1e8 <rsa_check_context.constprop.0+0x88>
    return( 0 );
 c04f1e4:	2000      	movs	r0, #0
}
 c04f1e6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        ( mbedtls_mpi_cmp_int( &ctx->DP, 0 ) <= 0 ||
 c04f1e8:	2100      	movs	r1, #0
 c04f1ea:	f104 0050 	add.w	r0, r4, #80	@ 0x50
 c04f1ee:	f004 fb68 	bl	c0538c2 <mbedtls_mpi_cmp_int>
    if( is_priv &&
 c04f1f2:	2800      	cmp	r0, #0
 c04f1f4:	ddd6      	ble.n	c04f1a4 <rsa_check_context.constprop.0+0x44>
          mbedtls_mpi_cmp_int( &ctx->DQ, 0 ) <= 0  ) )
 c04f1f6:	2100      	movs	r1, #0
 c04f1f8:	f104 005c 	add.w	r0, r4, #92	@ 0x5c
 c04f1fc:	f004 fb61 	bl	c0538c2 <mbedtls_mpi_cmp_int>
        ( mbedtls_mpi_cmp_int( &ctx->DP, 0 ) <= 0 ||
 c04f200:	2800      	cmp	r0, #0
 c04f202:	ddcf      	ble.n	c04f1a4 <rsa_check_context.constprop.0+0x44>
        mbedtls_mpi_cmp_int( &ctx->QP, 0 ) <= 0 )
 c04f204:	2100      	movs	r1, #0
 c04f206:	f104 0068 	add.w	r0, r4, #104	@ 0x68
 c04f20a:	f004 fb5a 	bl	c0538c2 <mbedtls_mpi_cmp_int>
    if( is_priv &&
 c04f20e:	2800      	cmp	r0, #0
 c04f210:	dce8      	bgt.n	c04f1e4 <rsa_check_context.constprop.0+0x84>
 c04f212:	e7c7      	b.n	c04f1a4 <rsa_check_context.constprop.0+0x44>
 c04f214:	ffffbf80 	.word	0xffffbf80

0c04f218 <mbedtls_rsa_import>:
{
 c04f218:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 c04f21c:	4604      	mov	r4, r0
 c04f21e:	e9dd 7608 	ldrd	r7, r6, [sp, #32]
 c04f222:	4691      	mov	r9, r2
 c04f224:	4698      	mov	r8, r3
    if( ( N != NULL && ( ret = mbedtls_mpi_copy( &ctx->N, N ) ) != 0 ) ||
 c04f226:	460d      	mov	r5, r1
 c04f228:	b951      	cbnz	r1, c04f240 <mbedtls_rsa_import+0x28>
 c04f22a:	f1b9 0f00 	cmp.w	r9, #0
 c04f22e:	d110      	bne.n	c04f252 <mbedtls_rsa_import+0x3a>
        ( P != NULL && ( ret = mbedtls_mpi_copy( &ctx->P, P ) ) != 0 ) ||
 c04f230:	f1b8 0f00 	cmp.w	r8, #0
 c04f234:	d115      	bne.n	c04f262 <mbedtls_rsa_import+0x4a>
        ( Q != NULL && ( ret = mbedtls_mpi_copy( &ctx->Q, Q ) ) != 0 ) ||
 c04f236:	b9e7      	cbnz	r7, c04f272 <mbedtls_rsa_import+0x5a>
        ( D != NULL && ( ret = mbedtls_mpi_copy( &ctx->D, D ) ) != 0 ) ||
 c04f238:	bb1e      	cbnz	r6, c04f282 <mbedtls_rsa_import+0x6a>
    if( N != NULL )
 c04f23a:	bb55      	cbnz	r5, c04f292 <mbedtls_rsa_import+0x7a>
    return( 0 );
 c04f23c:	2000      	movs	r0, #0
 c04f23e:	e006      	b.n	c04f24e <mbedtls_rsa_import+0x36>
    if( ( N != NULL && ( ret = mbedtls_mpi_copy( &ctx->N, N ) ) != 0 ) ||
 c04f240:	3008      	adds	r0, #8
 c04f242:	f004 f8b2 	bl	c0533aa <mbedtls_mpi_copy>
 c04f246:	2800      	cmp	r0, #0
 c04f248:	d0ef      	beq.n	c04f22a <mbedtls_rsa_import+0x12>
        ( *mbedtls_test_hook_error_add )( high, low, file, line );
#endif
    (void)file;
    (void)line;

    return( high + low );
 c04f24a:	f5a0 4081 	sub.w	r0, r0, #16512	@ 0x4080
}
 c04f24e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        ( P != NULL && ( ret = mbedtls_mpi_copy( &ctx->P, P ) ) != 0 ) ||
 c04f252:	4649      	mov	r1, r9
 c04f254:	f104 002c 	add.w	r0, r4, #44	@ 0x2c
 c04f258:	f004 f8a7 	bl	c0533aa <mbedtls_mpi_copy>
 c04f25c:	2800      	cmp	r0, #0
 c04f25e:	d0e7      	beq.n	c04f230 <mbedtls_rsa_import+0x18>
 c04f260:	e7f3      	b.n	c04f24a <mbedtls_rsa_import+0x32>
        ( Q != NULL && ( ret = mbedtls_mpi_copy( &ctx->Q, Q ) ) != 0 ) ||
 c04f262:	4641      	mov	r1, r8
 c04f264:	f104 0038 	add.w	r0, r4, #56	@ 0x38
 c04f268:	f004 f89f 	bl	c0533aa <mbedtls_mpi_copy>
 c04f26c:	2800      	cmp	r0, #0
 c04f26e:	d0e2      	beq.n	c04f236 <mbedtls_rsa_import+0x1e>
 c04f270:	e7eb      	b.n	c04f24a <mbedtls_rsa_import+0x32>
        ( D != NULL && ( ret = mbedtls_mpi_copy( &ctx->D, D ) ) != 0 ) ||
 c04f272:	4639      	mov	r1, r7
 c04f274:	f104 0020 	add.w	r0, r4, #32
 c04f278:	f004 f897 	bl	c0533aa <mbedtls_mpi_copy>
 c04f27c:	2800      	cmp	r0, #0
 c04f27e:	d0db      	beq.n	c04f238 <mbedtls_rsa_import+0x20>
 c04f280:	e7e3      	b.n	c04f24a <mbedtls_rsa_import+0x32>
        ( E != NULL && ( ret = mbedtls_mpi_copy( &ctx->E, E ) ) != 0 ) )
 c04f282:	4631      	mov	r1, r6
 c04f284:	f104 0014 	add.w	r0, r4, #20
 c04f288:	f004 f88f 	bl	c0533aa <mbedtls_mpi_copy>
 c04f28c:	2800      	cmp	r0, #0
 c04f28e:	d0d4      	beq.n	c04f23a <mbedtls_rsa_import+0x22>
 c04f290:	e7db      	b.n	c04f24a <mbedtls_rsa_import+0x32>
        ctx->len = mbedtls_mpi_size( &ctx->N );
 c04f292:	f104 0008 	add.w	r0, r4, #8
 c04f296:	f004 f960 	bl	c05355a <mbedtls_mpi_size>
 c04f29a:	6060      	str	r0, [r4, #4]
 c04f29c:	e7ce      	b.n	c04f23c <mbedtls_rsa_import+0x24>

0c04f29e <mbedtls_rsa_import_raw>:
{
 c04f29e:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 c04f2a2:	f8dd 8024 	ldr.w	r8, [sp, #36]	@ 0x24
 c04f2a6:	4604      	mov	r4, r0
 c04f2a8:	461d      	mov	r5, r3
 c04f2aa:	9f0b      	ldr	r7, [sp, #44]	@ 0x2c
 c04f2ac:	9e0d      	ldr	r6, [sp, #52]	@ 0x34
    if( N != NULL )
 c04f2ae:	b149      	cbz	r1, c04f2c4 <mbedtls_rsa_import_raw+0x26>
        MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( &ctx->N, N, N_len ) );
 c04f2b0:	f100 0908 	add.w	r9, r0, #8
 c04f2b4:	4648      	mov	r0, r9
 c04f2b6:	f004 f978 	bl	c0535aa <mbedtls_mpi_read_binary>
 c04f2ba:	b9a0      	cbnz	r0, c04f2e6 <mbedtls_rsa_import_raw+0x48>
        ctx->len = mbedtls_mpi_size( &ctx->N );
 c04f2bc:	4648      	mov	r0, r9
 c04f2be:	f004 f94c 	bl	c05355a <mbedtls_mpi_size>
 c04f2c2:	6060      	str	r0, [r4, #4]
    if( P != NULL )
 c04f2c4:	b93d      	cbnz	r5, c04f2d6 <mbedtls_rsa_import_raw+0x38>
    if( Q != NULL )
 c04f2c6:	f1b8 0f00 	cmp.w	r8, #0
 c04f2ca:	d10f      	bne.n	c04f2ec <mbedtls_rsa_import_raw+0x4e>
    if( D != NULL )
 c04f2cc:	b9bf      	cbnz	r7, c04f2fe <mbedtls_rsa_import_raw+0x60>
    if( E != NULL )
 c04f2ce:	b9fe      	cbnz	r6, c04f310 <mbedtls_rsa_import_raw+0x72>
    return( 0 );
 c04f2d0:	2000      	movs	r0, #0
}
 c04f2d2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( &ctx->P, P, P_len ) );
 c04f2d6:	4629      	mov	r1, r5
 c04f2d8:	9a08      	ldr	r2, [sp, #32]
 c04f2da:	f104 002c 	add.w	r0, r4, #44	@ 0x2c
 c04f2de:	f004 f964 	bl	c0535aa <mbedtls_mpi_read_binary>
 c04f2e2:	2800      	cmp	r0, #0
 c04f2e4:	d0ef      	beq.n	c04f2c6 <mbedtls_rsa_import_raw+0x28>
 c04f2e6:	f5a0 4081 	sub.w	r0, r0, #16512	@ 0x4080
        return( MBEDTLS_ERROR_ADD( MBEDTLS_ERR_RSA_BAD_INPUT_DATA, ret ) );
 c04f2ea:	e7f2      	b.n	c04f2d2 <mbedtls_rsa_import_raw+0x34>
        MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( &ctx->Q, Q, Q_len ) );
 c04f2ec:	4641      	mov	r1, r8
 c04f2ee:	9a0a      	ldr	r2, [sp, #40]	@ 0x28
 c04f2f0:	f104 0038 	add.w	r0, r4, #56	@ 0x38
 c04f2f4:	f004 f959 	bl	c0535aa <mbedtls_mpi_read_binary>
 c04f2f8:	2800      	cmp	r0, #0
 c04f2fa:	d0e7      	beq.n	c04f2cc <mbedtls_rsa_import_raw+0x2e>
 c04f2fc:	e7f3      	b.n	c04f2e6 <mbedtls_rsa_import_raw+0x48>
        MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( &ctx->D, D, D_len ) );
 c04f2fe:	4639      	mov	r1, r7
 c04f300:	9a0c      	ldr	r2, [sp, #48]	@ 0x30
 c04f302:	f104 0020 	add.w	r0, r4, #32
 c04f306:	f004 f950 	bl	c0535aa <mbedtls_mpi_read_binary>
 c04f30a:	2800      	cmp	r0, #0
 c04f30c:	d0df      	beq.n	c04f2ce <mbedtls_rsa_import_raw+0x30>
 c04f30e:	e7ea      	b.n	c04f2e6 <mbedtls_rsa_import_raw+0x48>
        MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( &ctx->E, E, E_len ) );
 c04f310:	4631      	mov	r1, r6
 c04f312:	9a0e      	ldr	r2, [sp, #56]	@ 0x38
 c04f314:	f104 0014 	add.w	r0, r4, #20
 c04f318:	f004 f947 	bl	c0535aa <mbedtls_mpi_read_binary>
 c04f31c:	2800      	cmp	r0, #0
 c04f31e:	d0d7      	beq.n	c04f2d0 <mbedtls_rsa_import_raw+0x32>
 c04f320:	e7e1      	b.n	c04f2e6 <mbedtls_rsa_import_raw+0x48>
	...

0c04f324 <mbedtls_rsa_complete>:
{
 c04f324:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    have_N = ( mbedtls_mpi_cmp_int( &ctx->N, 0 ) != 0 );
 c04f328:	f100 0b08 	add.w	fp, r0, #8
{
 c04f32c:	b087      	sub	sp, #28
 c04f32e:	4680      	mov	r8, r0
    have_N = ( mbedtls_mpi_cmp_int( &ctx->N, 0 ) != 0 );
 c04f330:	2100      	movs	r1, #0
 c04f332:	4658      	mov	r0, fp
 c04f334:	f004 fac5 	bl	c0538c2 <mbedtls_mpi_cmp_int>
    have_P = ( mbedtls_mpi_cmp_int( &ctx->P, 0 ) != 0 );
 c04f338:	f108 092c 	add.w	r9, r8, #44	@ 0x2c
 c04f33c:	2100      	movs	r1, #0
    have_N = ( mbedtls_mpi_cmp_int( &ctx->N, 0 ) != 0 );
 c04f33e:	4607      	mov	r7, r0
    have_P = ( mbedtls_mpi_cmp_int( &ctx->P, 0 ) != 0 );
 c04f340:	4648      	mov	r0, r9
 c04f342:	f004 fabe 	bl	c0538c2 <mbedtls_mpi_cmp_int>
    have_Q = ( mbedtls_mpi_cmp_int( &ctx->Q, 0 ) != 0 );
 c04f346:	f108 0a38 	add.w	sl, r8, #56	@ 0x38
 c04f34a:	2100      	movs	r1, #0
    have_P = ( mbedtls_mpi_cmp_int( &ctx->P, 0 ) != 0 );
 c04f34c:	9004      	str	r0, [sp, #16]
    have_Q = ( mbedtls_mpi_cmp_int( &ctx->Q, 0 ) != 0 );
 c04f34e:	4650      	mov	r0, sl
 c04f350:	f004 fab7 	bl	c0538c2 <mbedtls_mpi_cmp_int>
    have_D = ( mbedtls_mpi_cmp_int( &ctx->D, 0 ) != 0 );
 c04f354:	f108 0320 	add.w	r3, r8, #32
 c04f358:	2100      	movs	r1, #0
    have_Q = ( mbedtls_mpi_cmp_int( &ctx->Q, 0 ) != 0 );
 c04f35a:	4606      	mov	r6, r0
    have_D = ( mbedtls_mpi_cmp_int( &ctx->D, 0 ) != 0 );
 c04f35c:	4618      	mov	r0, r3
 c04f35e:	9303      	str	r3, [sp, #12]
 c04f360:	f004 faaf 	bl	c0538c2 <mbedtls_mpi_cmp_int>
    have_E = ( mbedtls_mpi_cmp_int( &ctx->E, 0 ) != 0 );
 c04f364:	f108 0314 	add.w	r3, r8, #20
    have_D = ( mbedtls_mpi_cmp_int( &ctx->D, 0 ) != 0 );
 c04f368:	9003      	str	r0, [sp, #12]
    have_E = ( mbedtls_mpi_cmp_int( &ctx->E, 0 ) != 0 );
 c04f36a:	2100      	movs	r1, #0
 c04f36c:	4618      	mov	r0, r3
 c04f36e:	9305      	str	r3, [sp, #20]
 c04f370:	f004 faa7 	bl	c0538c2 <mbedtls_mpi_cmp_int>
    n_missing  =              have_P &&  have_Q &&  have_D && have_E;
 c04f374:	e9dd 2303 	ldrd	r2, r3, [sp, #12]
 c04f378:	b1e3      	cbz	r3, c04f3b4 <mbedtls_rsa_complete+0x90>
 c04f37a:	b1ee      	cbz	r6, c04f3b8 <mbedtls_rsa_complete+0x94>
 c04f37c:	b1f2      	cbz	r2, c04f3bc <mbedtls_rsa_complete+0x98>
 c04f37e:	1e05      	subs	r5, r0, #0
 c04f380:	bf18      	it	ne
 c04f382:	2501      	movne	r5, #1
    pq_missing =   have_N && !have_P && !have_Q &&  have_D && have_E;
 c04f384:	b1e7      	cbz	r7, c04f3c0 <mbedtls_rsa_complete+0x9c>
 c04f386:	2b00      	cmp	r3, #0
 c04f388:	f040 80a6 	bne.w	c04f4d8 <mbedtls_rsa_complete+0x1b4>
 c04f38c:	2e00      	cmp	r6, #0
 c04f38e:	f040 809a 	bne.w	c04f4c6 <mbedtls_rsa_complete+0x1a2>
 c04f392:	2a00      	cmp	r2, #0
 c04f394:	d031      	beq.n	c04f3fa <mbedtls_rsa_complete+0xd6>
    n_missing  =              have_P &&  have_Q &&  have_D && have_E;
 c04f396:	1e04      	subs	r4, r0, #0
 c04f398:	bf18      	it	ne
 c04f39a:	2401      	movne	r4, #1
    is_priv = n_missing || pq_missing || d_missing;
 c04f39c:	2d00      	cmp	r5, #0
 c04f39e:	d166      	bne.n	c04f46e <mbedtls_rsa_complete+0x14a>
    is_pub     =   have_N && !have_P && !have_Q && !have_D && have_E;
 c04f3a0:	4628      	mov	r0, r5
    is_priv = n_missing || pq_missing || d_missing;
 c04f3a2:	2c00      	cmp	r4, #0
 c04f3a4:	d17c      	bne.n	c04f4a0 <mbedtls_rsa_complete+0x17c>
 c04f3a6:	462c      	mov	r4, r5
 c04f3a8:	2c00      	cmp	r4, #0
 c04f3aa:	d17f      	bne.n	c04f4ac <mbedtls_rsa_complete+0x188>
    if( !is_priv && !is_pub )
 c04f3ac:	2800      	cmp	r0, #0
 c04f3ae:	d16f      	bne.n	c04f490 <mbedtls_rsa_complete+0x16c>
        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
 c04f3b0:	484c      	ldr	r0, [pc, #304]	@ (c04f4e4 <mbedtls_rsa_complete+0x1c0>)
 c04f3b2:	e033      	b.n	c04f41c <mbedtls_rsa_complete+0xf8>
    n_missing  =              have_P &&  have_Q &&  have_D && have_E;
 c04f3b4:	461d      	mov	r5, r3
 c04f3b6:	e7e5      	b.n	c04f384 <mbedtls_rsa_complete+0x60>
 c04f3b8:	4635      	mov	r5, r6
 c04f3ba:	e7e3      	b.n	c04f384 <mbedtls_rsa_complete+0x60>
 c04f3bc:	4615      	mov	r5, r2
 c04f3be:	e7e1      	b.n	c04f384 <mbedtls_rsa_complete+0x60>
    d_missing  =              have_P &&  have_Q && !have_D && have_E;
 c04f3c0:	2b00      	cmp	r3, #0
 c04f3c2:	f040 8084 	bne.w	c04f4ce <mbedtls_rsa_complete+0x1aa>
 c04f3c6:	461c      	mov	r4, r3
    is_priv = n_missing || pq_missing || d_missing;
 c04f3c8:	b1cd      	cbz	r5, c04f3fe <mbedtls_rsa_complete+0xda>
    if( !have_N && have_P && have_Q )
 c04f3ca:	b9d3      	cbnz	r3, c04f402 <mbedtls_rsa_complete+0xde>
 c04f3cc:	4622      	mov	r2, r4
 c04f3ce:	e053      	b.n	c04f478 <mbedtls_rsa_complete+0x154>
    d_missing  =              have_P &&  have_Q && !have_D && have_E;
 c04f3d0:	b98a      	cbnz	r2, c04f3f6 <mbedtls_rsa_complete+0xd2>
 c04f3d2:	1e04      	subs	r4, r0, #0
 c04f3d4:	bf18      	it	ne
 c04f3d6:	2401      	movne	r4, #1
    is_pub     =   have_N && !have_P && !have_Q && !have_D && have_E;
 c04f3d8:	2f00      	cmp	r7, #0
 c04f3da:	d0f5      	beq.n	c04f3c8 <mbedtls_rsa_complete+0xa4>
 c04f3dc:	ea43 0106 	orr.w	r1, r3, r6
 c04f3e0:	4311      	orrs	r1, r2
 c04f3e2:	d16d      	bne.n	c04f4c0 <mbedtls_rsa_complete+0x19c>
 c04f3e4:	3800      	subs	r0, #0
 c04f3e6:	bf18      	it	ne
 c04f3e8:	2001      	movne	r0, #1
 c04f3ea:	4622      	mov	r2, r4
    is_priv = n_missing || pq_missing || d_missing;
 c04f3ec:	2d00      	cmp	r5, #0
 c04f3ee:	d143      	bne.n	c04f478 <mbedtls_rsa_complete+0x154>
 c04f3f0:	462c      	mov	r4, r5
 c04f3f2:	4615      	mov	r5, r2
 c04f3f4:	e7d5      	b.n	c04f3a2 <mbedtls_rsa_complete+0x7e>
    d_missing  =              have_P &&  have_Q && !have_D && have_E;
 c04f3f6:	2400      	movs	r4, #0
 c04f3f8:	e7ee      	b.n	c04f3d8 <mbedtls_rsa_complete+0xb4>
 c04f3fa:	4634      	mov	r4, r6
 c04f3fc:	e7f2      	b.n	c04f3e4 <mbedtls_rsa_complete+0xc0>
    is_priv = n_missing || pq_missing || d_missing;
 c04f3fe:	4628      	mov	r0, r5
 c04f400:	e7d2      	b.n	c04f3a8 <mbedtls_rsa_complete+0x84>
    if( !have_N && have_P && have_Q )
 c04f402:	4623      	mov	r3, r4
 c04f404:	2700      	movs	r7, #0
    is_priv = n_missing || pq_missing || d_missing;
 c04f406:	462c      	mov	r4, r5
    if( !have_N && have_P && have_Q )
 c04f408:	461d      	mov	r5, r3
 c04f40a:	b17e      	cbz	r6, c04f42c <mbedtls_rsa_complete+0x108>
        if( ( ret = rsa_mpi2pka_mul( &ctx->N, &ctx->P,
 c04f40c:	4652      	mov	r2, sl
 c04f40e:	4649      	mov	r1, r9
 c04f410:	4658      	mov	r0, fp
 c04f412:	f7ff fcc1 	bl	c04ed98 <rsa_mpi2pka_mul>
 c04f416:	b120      	cbz	r0, c04f422 <mbedtls_rsa_complete+0xfe>
 c04f418:	f5a0 4081 	sub.w	r0, r0, #16512	@ 0x4080
}
 c04f41c:	b007      	add	sp, #28
 c04f41e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        ctx->len = mbedtls_mpi_size( &ctx->N );
 c04f422:	4658      	mov	r0, fp
 c04f424:	f004 f899 	bl	c05355a <mbedtls_mpi_size>
 c04f428:	f8c8 0004 	str.w	r0, [r8, #4]
    d_missing  =              have_P &&  have_Q && !have_D && have_E;
 c04f42c:	462a      	mov	r2, r5
    if( pq_missing )
 c04f42e:	b317      	cbz	r7, c04f476 <mbedtls_rsa_complete+0x152>
        ret = mbedtls_rsa_deduce_primes( &ctx->N, &ctx->E, &ctx->D,
 c04f430:	464b      	mov	r3, r9
 c04f432:	4658      	mov	r0, fp
 c04f434:	f8cd a000 	str.w	sl, [sp]
 c04f438:	f108 0220 	add.w	r2, r8, #32
 c04f43c:	f108 0114 	add.w	r1, r8, #20
 c04f440:	f008 fc00 	bl	c057c44 <mbedtls_rsa_deduce_primes>
        if( ( ret = mbedtls_rsa_deduce_private_exponent( &ctx->P,
 c04f444:	2800      	cmp	r0, #0
 c04f446:	d1e7      	bne.n	c04f418 <mbedtls_rsa_complete+0xf4>
    if( is_priv )
 c04f448:	b31c      	cbz	r4, c04f492 <mbedtls_rsa_complete+0x16e>
        ret = mbedtls_rsa_deduce_crt( &ctx->P,  &ctx->Q,  &ctx->D,
 c04f44a:	f108 0368 	add.w	r3, r8, #104	@ 0x68
 c04f44e:	9301      	str	r3, [sp, #4]
 c04f450:	f108 035c 	add.w	r3, r8, #92	@ 0x5c
 c04f454:	9300      	str	r3, [sp, #0]
 c04f456:	4651      	mov	r1, sl
 c04f458:	4648      	mov	r0, r9
 c04f45a:	f108 0350 	add.w	r3, r8, #80	@ 0x50
 c04f45e:	f108 0220 	add.w	r2, r8, #32
 c04f462:	f008 feab 	bl	c0581bc <mbedtls_rsa_deduce_crt>
        if( ret != 0 )
 c04f466:	2800      	cmp	r0, #0
 c04f468:	d1d6      	bne.n	c04f418 <mbedtls_rsa_complete+0xf4>
 c04f46a:	2101      	movs	r1, #1
 c04f46c:	e012      	b.n	c04f494 <mbedtls_rsa_complete+0x170>
    pq_missing =   have_N && !have_P && !have_Q &&  have_D && have_E;
 c04f46e:	4627      	mov	r7, r4
    d_missing  =              have_P &&  have_Q && !have_D && have_E;
 c04f470:	4632      	mov	r2, r6
    is_priv = n_missing || pq_missing || d_missing;
 c04f472:	462c      	mov	r4, r5
 c04f474:	e7db      	b.n	c04f42e <mbedtls_rsa_complete+0x10a>
 c04f476:	4625      	mov	r5, r4
    else if( d_missing )
 c04f478:	462c      	mov	r4, r5
 c04f47a:	2a00      	cmp	r2, #0
 c04f47c:	d0e4      	beq.n	c04f448 <mbedtls_rsa_complete+0x124>
        if( ( ret = mbedtls_rsa_deduce_private_exponent( &ctx->P,
 c04f47e:	4651      	mov	r1, sl
 c04f480:	4648      	mov	r0, r9
 c04f482:	f108 0320 	add.w	r3, r8, #32
 c04f486:	f108 0214 	add.w	r2, r8, #20
 c04f48a:	f008 fccb 	bl	c057e24 <mbedtls_rsa_deduce_private_exponent>
 c04f48e:	e7d9      	b.n	c04f444 <mbedtls_rsa_complete+0x120>
    if( !have_N && have_P && have_Q )
 c04f490:	b197      	cbz	r7, c04f4b8 <mbedtls_rsa_complete+0x194>
 c04f492:	2100      	movs	r1, #0
    return( rsa_check_context( ctx, is_priv, 1 ) );
 c04f494:	4640      	mov	r0, r8
}
 c04f496:	b007      	add	sp, #28
 c04f498:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    return( rsa_check_context( ctx, is_priv, 1 ) );
 c04f49c:	f7ff be60 	b.w	c04f160 <rsa_check_context.constprop.0>
    if( !have_N && have_P && have_Q )
 c04f4a0:	2f00      	cmp	r7, #0
 c04f4a2:	d1c5      	bne.n	c04f430 <mbedtls_rsa_complete+0x10c>
 c04f4a4:	2b00      	cmp	r3, #0
 c04f4a6:	d0c3      	beq.n	c04f430 <mbedtls_rsa_complete+0x10c>
 c04f4a8:	4627      	mov	r7, r4
 c04f4aa:	e7ae      	b.n	c04f40a <mbedtls_rsa_complete+0xe6>
 c04f4ac:	2f00      	cmp	r7, #0
 c04f4ae:	d1e6      	bne.n	c04f47e <mbedtls_rsa_complete+0x15a>
 c04f4b0:	2b00      	cmp	r3, #0
 c04f4b2:	d0e4      	beq.n	c04f47e <mbedtls_rsa_complete+0x15a>
 c04f4b4:	4625      	mov	r5, r4
 c04f4b6:	e7a8      	b.n	c04f40a <mbedtls_rsa_complete+0xe6>
 c04f4b8:	2b00      	cmp	r3, #0
 c04f4ba:	d0ea      	beq.n	c04f492 <mbedtls_rsa_complete+0x16e>
 c04f4bc:	463d      	mov	r5, r7
 c04f4be:	e7a4      	b.n	c04f40a <mbedtls_rsa_complete+0xe6>
 c04f4c0:	4622      	mov	r2, r4
    is_pub     =   have_N && !have_P && !have_Q && !have_D && have_E;
 c04f4c2:	2000      	movs	r0, #0
 c04f4c4:	e792      	b.n	c04f3ec <mbedtls_rsa_complete+0xc8>
    is_priv = n_missing || pq_missing || d_missing;
 c04f4c6:	2d00      	cmp	r5, #0
 c04f4c8:	d1bf      	bne.n	c04f44a <mbedtls_rsa_complete+0x126>
    is_pub     =   have_N && !have_P && !have_Q && !have_D && have_E;
 c04f4ca:	4628      	mov	r0, r5
 c04f4cc:	e76b      	b.n	c04f3a6 <mbedtls_rsa_complete+0x82>
    d_missing  =              have_P &&  have_Q && !have_D && have_E;
 c04f4ce:	2e00      	cmp	r6, #0
 c04f4d0:	f47f af7e 	bne.w	c04f3d0 <mbedtls_rsa_complete+0xac>
 c04f4d4:	4634      	mov	r4, r6
 c04f4d6:	e777      	b.n	c04f3c8 <mbedtls_rsa_complete+0xa4>
 c04f4d8:	2e00      	cmp	r6, #0
 c04f4da:	f47f af79 	bne.w	c04f3d0 <mbedtls_rsa_complete+0xac>
 c04f4de:	4634      	mov	r4, r6
 c04f4e0:	e77c      	b.n	c04f3dc <mbedtls_rsa_complete+0xb8>
 c04f4e2:	bf00      	nop
 c04f4e4:	ffffbf80 	.word	0xffffbf80

0c04f4e8 <mbedtls_rsa_export>:
{
 c04f4e8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
        mbedtls_mpi_cmp_int( &ctx->N, 0 ) != 0 &&
 c04f4ec:	f100 0a08 	add.w	sl, r0, #8
{
 c04f4f0:	4604      	mov	r4, r0
 c04f4f2:	e9dd 7608 	ldrd	r7, r6, [sp, #32]
 c04f4f6:	460d      	mov	r5, r1
        mbedtls_mpi_cmp_int( &ctx->N, 0 ) != 0 &&
 c04f4f8:	4650      	mov	r0, sl
 c04f4fa:	2100      	movs	r1, #0
{
 c04f4fc:	4691      	mov	r9, r2
 c04f4fe:	4698      	mov	r8, r3
        mbedtls_mpi_cmp_int( &ctx->N, 0 ) != 0 &&
 c04f500:	f004 f9df 	bl	c0538c2 <mbedtls_mpi_cmp_int>
        mbedtls_mpi_cmp_int( &ctx->D, 0 ) != 0 &&
 c04f504:	b920      	cbnz	r0, c04f510 <mbedtls_rsa_export+0x28>
        if( P != NULL || Q != NULL || D != NULL )
 c04f506:	f1b9 0f00 	cmp.w	r9, #0
 c04f50a:	d028      	beq.n	c04f55e <mbedtls_rsa_export+0x76>
            return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
 c04f50c:	482b      	ldr	r0, [pc, #172]	@ (c04f5bc <mbedtls_rsa_export+0xd4>)
 c04f50e:	e033      	b.n	c04f578 <mbedtls_rsa_export+0x90>
        mbedtls_mpi_cmp_int( &ctx->P, 0 ) != 0 &&
 c04f510:	2100      	movs	r1, #0
 c04f512:	f104 002c 	add.w	r0, r4, #44	@ 0x2c
 c04f516:	f004 f9d4 	bl	c0538c2 <mbedtls_mpi_cmp_int>
        mbedtls_mpi_cmp_int( &ctx->N, 0 ) != 0 &&
 c04f51a:	2800      	cmp	r0, #0
 c04f51c:	d0f3      	beq.n	c04f506 <mbedtls_rsa_export+0x1e>
        mbedtls_mpi_cmp_int( &ctx->Q, 0 ) != 0 &&
 c04f51e:	2100      	movs	r1, #0
 c04f520:	f104 0038 	add.w	r0, r4, #56	@ 0x38
 c04f524:	f004 f9cd 	bl	c0538c2 <mbedtls_mpi_cmp_int>
        mbedtls_mpi_cmp_int( &ctx->P, 0 ) != 0 &&
 c04f528:	2800      	cmp	r0, #0
 c04f52a:	d0ec      	beq.n	c04f506 <mbedtls_rsa_export+0x1e>
        mbedtls_mpi_cmp_int( &ctx->D, 0 ) != 0 &&
 c04f52c:	2100      	movs	r1, #0
 c04f52e:	f104 0020 	add.w	r0, r4, #32
 c04f532:	f004 f9c6 	bl	c0538c2 <mbedtls_mpi_cmp_int>
        mbedtls_mpi_cmp_int( &ctx->Q, 0 ) != 0 &&
 c04f536:	2800      	cmp	r0, #0
 c04f538:	d0e5      	beq.n	c04f506 <mbedtls_rsa_export+0x1e>
        mbedtls_mpi_cmp_int( &ctx->E, 0 ) != 0;
 c04f53a:	2100      	movs	r1, #0
 c04f53c:	f104 0014 	add.w	r0, r4, #20
 c04f540:	f004 f9bf 	bl	c0538c2 <mbedtls_mpi_cmp_int>
        mbedtls_mpi_cmp_int( &ctx->D, 0 ) != 0 &&
 c04f544:	2800      	cmp	r0, #0
 c04f546:	d0de      	beq.n	c04f506 <mbedtls_rsa_export+0x1e>
    if( ( N != NULL && ( ret = mbedtls_mpi_copy( N, &ctx->N ) ) != 0 ) ||
 c04f548:	b985      	cbnz	r5, c04f56c <mbedtls_rsa_export+0x84>
 c04f54a:	f1b9 0f00 	cmp.w	r9, #0
 c04f54e:	d115      	bne.n	c04f57c <mbedtls_rsa_export+0x94>
        ( P != NULL && ( ret = mbedtls_mpi_copy( P, &ctx->P ) ) != 0 ) ||
 c04f550:	f1b8 0f00 	cmp.w	r8, #0
 c04f554:	d11a      	bne.n	c04f58c <mbedtls_rsa_export+0xa4>
        ( Q != NULL && ( ret = mbedtls_mpi_copy( Q, &ctx->Q ) ) != 0 ) ||
 c04f556:	bb0f      	cbnz	r7, c04f59c <mbedtls_rsa_export+0xb4>
        ( D != NULL && ( ret = mbedtls_mpi_copy( D, &ctx->D ) ) != 0 ) ||
 c04f558:	bb46      	cbnz	r6, c04f5ac <mbedtls_rsa_export+0xc4>
    return( 0 );
 c04f55a:	4630      	mov	r0, r6
 c04f55c:	e00c      	b.n	c04f578 <mbedtls_rsa_export+0x90>
        if( P != NULL || Q != NULL || D != NULL )
 c04f55e:	f1b8 0f00 	cmp.w	r8, #0
 c04f562:	d1d3      	bne.n	c04f50c <mbedtls_rsa_export+0x24>
 c04f564:	2f00      	cmp	r7, #0
 c04f566:	d1d1      	bne.n	c04f50c <mbedtls_rsa_export+0x24>
    if( ( N != NULL && ( ret = mbedtls_mpi_copy( N, &ctx->N ) ) != 0 ) ||
 c04f568:	2d00      	cmp	r5, #0
 c04f56a:	d0f5      	beq.n	c04f558 <mbedtls_rsa_export+0x70>
 c04f56c:	4651      	mov	r1, sl
 c04f56e:	4628      	mov	r0, r5
 c04f570:	f003 ff1b 	bl	c0533aa <mbedtls_mpi_copy>
 c04f574:	2800      	cmp	r0, #0
 c04f576:	d0e8      	beq.n	c04f54a <mbedtls_rsa_export+0x62>
}
 c04f578:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        ( P != NULL && ( ret = mbedtls_mpi_copy( P, &ctx->P ) ) != 0 ) ||
 c04f57c:	4648      	mov	r0, r9
 c04f57e:	f104 012c 	add.w	r1, r4, #44	@ 0x2c
 c04f582:	f003 ff12 	bl	c0533aa <mbedtls_mpi_copy>
 c04f586:	2800      	cmp	r0, #0
 c04f588:	d0e2      	beq.n	c04f550 <mbedtls_rsa_export+0x68>
 c04f58a:	e7f5      	b.n	c04f578 <mbedtls_rsa_export+0x90>
        ( Q != NULL && ( ret = mbedtls_mpi_copy( Q, &ctx->Q ) ) != 0 ) ||
 c04f58c:	4640      	mov	r0, r8
 c04f58e:	f104 0138 	add.w	r1, r4, #56	@ 0x38
 c04f592:	f003 ff0a 	bl	c0533aa <mbedtls_mpi_copy>
 c04f596:	2800      	cmp	r0, #0
 c04f598:	d0dd      	beq.n	c04f556 <mbedtls_rsa_export+0x6e>
 c04f59a:	e7ed      	b.n	c04f578 <mbedtls_rsa_export+0x90>
        ( D != NULL && ( ret = mbedtls_mpi_copy( D, &ctx->D ) ) != 0 ) ||
 c04f59c:	4638      	mov	r0, r7
 c04f59e:	f104 0120 	add.w	r1, r4, #32
 c04f5a2:	f003 ff02 	bl	c0533aa <mbedtls_mpi_copy>
 c04f5a6:	2800      	cmp	r0, #0
 c04f5a8:	d0d6      	beq.n	c04f558 <mbedtls_rsa_export+0x70>
 c04f5aa:	e7e5      	b.n	c04f578 <mbedtls_rsa_export+0x90>
        ( E != NULL && ( ret = mbedtls_mpi_copy( E, &ctx->E ) ) != 0 ) )
 c04f5ac:	4630      	mov	r0, r6
 c04f5ae:	f104 0114 	add.w	r1, r4, #20
}
 c04f5b2:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
        ( E != NULL && ( ret = mbedtls_mpi_copy( E, &ctx->E ) ) != 0 ) )
 c04f5b6:	f003 bef8 	b.w	c0533aa <mbedtls_mpi_copy>
 c04f5ba:	bf00      	nop
 c04f5bc:	ffffbf80 	.word	0xffffbf80

0c04f5c0 <mbedtls_rsa_export_crt>:
{
 c04f5c0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 c04f5c2:	4604      	mov	r4, r0
 c04f5c4:	460f      	mov	r7, r1
        mbedtls_mpi_cmp_int( &ctx->N, 0 ) != 0 &&
 c04f5c6:	3008      	adds	r0, #8
 c04f5c8:	2100      	movs	r1, #0
{
 c04f5ca:	4616      	mov	r6, r2
 c04f5cc:	461d      	mov	r5, r3
        mbedtls_mpi_cmp_int( &ctx->N, 0 ) != 0 &&
 c04f5ce:	f004 f978 	bl	c0538c2 <mbedtls_mpi_cmp_int>
        mbedtls_mpi_cmp_int( &ctx->D, 0 ) != 0 &&
 c04f5d2:	b908      	cbnz	r0, c04f5d8 <mbedtls_rsa_export_crt+0x18>
        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
 c04f5d4:	481e      	ldr	r0, [pc, #120]	@ (c04f650 <mbedtls_rsa_export_crt+0x90>)
}
 c04f5d6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        mbedtls_mpi_cmp_int( &ctx->P, 0 ) != 0 &&
 c04f5d8:	2100      	movs	r1, #0
 c04f5da:	f104 002c 	add.w	r0, r4, #44	@ 0x2c
 c04f5de:	f004 f970 	bl	c0538c2 <mbedtls_mpi_cmp_int>
        mbedtls_mpi_cmp_int( &ctx->N, 0 ) != 0 &&
 c04f5e2:	2800      	cmp	r0, #0
 c04f5e4:	d0f6      	beq.n	c04f5d4 <mbedtls_rsa_export_crt+0x14>
        mbedtls_mpi_cmp_int( &ctx->Q, 0 ) != 0 &&
 c04f5e6:	2100      	movs	r1, #0
 c04f5e8:	f104 0038 	add.w	r0, r4, #56	@ 0x38
 c04f5ec:	f004 f969 	bl	c0538c2 <mbedtls_mpi_cmp_int>
        mbedtls_mpi_cmp_int( &ctx->P, 0 ) != 0 &&
 c04f5f0:	2800      	cmp	r0, #0
 c04f5f2:	d0ef      	beq.n	c04f5d4 <mbedtls_rsa_export_crt+0x14>
        mbedtls_mpi_cmp_int( &ctx->D, 0 ) != 0 &&
 c04f5f4:	2100      	movs	r1, #0
 c04f5f6:	f104 0020 	add.w	r0, r4, #32
 c04f5fa:	f004 f962 	bl	c0538c2 <mbedtls_mpi_cmp_int>
        mbedtls_mpi_cmp_int( &ctx->Q, 0 ) != 0 &&
 c04f5fe:	2800      	cmp	r0, #0
 c04f600:	d0e8      	beq.n	c04f5d4 <mbedtls_rsa_export_crt+0x14>
        mbedtls_mpi_cmp_int( &ctx->E, 0 ) != 0;
 c04f602:	2100      	movs	r1, #0
 c04f604:	f104 0014 	add.w	r0, r4, #20
 c04f608:	f004 f95b 	bl	c0538c2 <mbedtls_mpi_cmp_int>
        mbedtls_mpi_cmp_int( &ctx->D, 0 ) != 0 &&
 c04f60c:	2800      	cmp	r0, #0
 c04f60e:	d0e1      	beq.n	c04f5d4 <mbedtls_rsa_export_crt+0x14>
    if( ( DP != NULL && ( ret = mbedtls_mpi_copy( DP, &ctx->DP ) ) != 0 ) ||
 c04f610:	b91f      	cbnz	r7, c04f61a <mbedtls_rsa_export_crt+0x5a>
 c04f612:	b966      	cbnz	r6, c04f62e <mbedtls_rsa_export_crt+0x6e>
        ( DQ != NULL && ( ret = mbedtls_mpi_copy( DQ, &ctx->DQ ) ) != 0 ) ||
 c04f614:	b99d      	cbnz	r5, c04f63e <mbedtls_rsa_export_crt+0x7e>
    return( 0 );
 c04f616:	2000      	movs	r0, #0
 c04f618:	e7dd      	b.n	c04f5d6 <mbedtls_rsa_export_crt+0x16>
    if( ( DP != NULL && ( ret = mbedtls_mpi_copy( DP, &ctx->DP ) ) != 0 ) ||
 c04f61a:	4638      	mov	r0, r7
 c04f61c:	f104 0150 	add.w	r1, r4, #80	@ 0x50
 c04f620:	f003 fec3 	bl	c0533aa <mbedtls_mpi_copy>
 c04f624:	2800      	cmp	r0, #0
 c04f626:	d0f4      	beq.n	c04f612 <mbedtls_rsa_export_crt+0x52>
 c04f628:	f5a0 4081 	sub.w	r0, r0, #16512	@ 0x4080
        return( MBEDTLS_ERROR_ADD( MBEDTLS_ERR_RSA_BAD_INPUT_DATA, ret ) );
 c04f62c:	e7d3      	b.n	c04f5d6 <mbedtls_rsa_export_crt+0x16>
        ( DQ != NULL && ( ret = mbedtls_mpi_copy( DQ, &ctx->DQ ) ) != 0 ) ||
 c04f62e:	4630      	mov	r0, r6
 c04f630:	f104 015c 	add.w	r1, r4, #92	@ 0x5c
 c04f634:	f003 feb9 	bl	c0533aa <mbedtls_mpi_copy>
 c04f638:	2800      	cmp	r0, #0
 c04f63a:	d0eb      	beq.n	c04f614 <mbedtls_rsa_export_crt+0x54>
 c04f63c:	e7f4      	b.n	c04f628 <mbedtls_rsa_export_crt+0x68>
        ( QP != NULL && ( ret = mbedtls_mpi_copy( QP, &ctx->QP ) ) != 0 ) )
 c04f63e:	4628      	mov	r0, r5
 c04f640:	f104 0168 	add.w	r1, r4, #104	@ 0x68
 c04f644:	f003 feb1 	bl	c0533aa <mbedtls_mpi_copy>
 c04f648:	2800      	cmp	r0, #0
 c04f64a:	d0e4      	beq.n	c04f616 <mbedtls_rsa_export_crt+0x56>
 c04f64c:	e7ec      	b.n	c04f628 <mbedtls_rsa_export_crt+0x68>
 c04f64e:	bf00      	nop
 c04f650:	ffffbf80 	.word	0xffffbf80

0c04f654 <mbedtls_rsa_init>:
{
 c04f654:	b570      	push	{r4, r5, r6, lr}
 c04f656:	4604      	mov	r4, r0
 c04f658:	460e      	mov	r6, r1
 c04f65a:	4615      	mov	r5, r2
    memset( ctx, 0, sizeof( mbedtls_rsa_context ) );
 c04f65c:	2100      	movs	r1, #0
 c04f65e:	22b8      	movs	r2, #184	@ 0xb8
 c04f660:	f00c f865 	bl	c05b72e <memset>
    ctx->hash_id = hash_id;
 c04f664:	e9c4 652c 	strd	r6, r5, [r4, #176]	@ 0xb0
}
 c04f668:	bd70      	pop	{r4, r5, r6, pc}

0c04f66a <mbedtls_rsa_set_padding>:
    ctx->hash_id = hash_id;
 c04f66a:	e9c0 122c 	strd	r1, r2, [r0, #176]	@ 0xb0
}
 c04f66e:	4770      	bx	lr

0c04f670 <mbedtls_rsa_get_len>:
}
 c04f670:	6840      	ldr	r0, [r0, #4]
 c04f672:	4770      	bx	lr

0c04f674 <mbedtls_rsa_check_pubkey>:
{
 c04f674:	b570      	push	{r4, r5, r6, lr}
    if( rsa_check_context( ctx, 0 /* public */, 0 /* no blinding */ ) != 0 )
 c04f676:	2100      	movs	r1, #0
{
 c04f678:	4604      	mov	r4, r0
    if( rsa_check_context( ctx, 0 /* public */, 0 /* no blinding */ ) != 0 )
 c04f67a:	f7ff fd71 	bl	c04f160 <rsa_check_context.constprop.0>
 c04f67e:	4605      	mov	r5, r0
 c04f680:	b110      	cbz	r0, c04f688 <mbedtls_rsa_check_pubkey+0x14>
        return( MBEDTLS_ERR_RSA_KEY_CHECK_FAILED );
 c04f682:	4d0e      	ldr	r5, [pc, #56]	@ (c04f6bc <mbedtls_rsa_check_pubkey+0x48>)
}
 c04f684:	4628      	mov	r0, r5
 c04f686:	bd70      	pop	{r4, r5, r6, pc}
    if( mbedtls_mpi_bitlen( &ctx->N ) < 128 )
 c04f688:	f104 0608 	add.w	r6, r4, #8
 c04f68c:	4630      	mov	r0, r6
 c04f68e:	f003 ff46 	bl	c05351e <mbedtls_mpi_bitlen>
 c04f692:	287f      	cmp	r0, #127	@ 0x7f
 c04f694:	d9f5      	bls.n	c04f682 <mbedtls_rsa_check_pubkey+0xe>
    if( mbedtls_mpi_get_bit( &ctx->E, 0 ) == 0 ||
 c04f696:	3414      	adds	r4, #20
 c04f698:	4629      	mov	r1, r5
 c04f69a:	4620      	mov	r0, r4
 c04f69c:	f003 feeb 	bl	c053476 <mbedtls_mpi_get_bit>
 c04f6a0:	2800      	cmp	r0, #0
 c04f6a2:	d0ee      	beq.n	c04f682 <mbedtls_rsa_check_pubkey+0xe>
        mbedtls_mpi_bitlen( &ctx->E )     < 2  ||
 c04f6a4:	4620      	mov	r0, r4
 c04f6a6:	f003 ff3a 	bl	c05351e <mbedtls_mpi_bitlen>
    if( mbedtls_mpi_get_bit( &ctx->E, 0 ) == 0 ||
 c04f6aa:	2801      	cmp	r0, #1
 c04f6ac:	d9e9      	bls.n	c04f682 <mbedtls_rsa_check_pubkey+0xe>
        mbedtls_mpi_cmp_mpi( &ctx->E, &ctx->N ) >= 0 )
 c04f6ae:	4631      	mov	r1, r6
 c04f6b0:	4620      	mov	r0, r4
 c04f6b2:	f004 f8c3 	bl	c05383c <mbedtls_mpi_cmp_mpi>
        mbedtls_mpi_bitlen( &ctx->E )     < 2  ||
 c04f6b6:	2800      	cmp	r0, #0
 c04f6b8:	dbe4      	blt.n	c04f684 <mbedtls_rsa_check_pubkey+0x10>
 c04f6ba:	e7e2      	b.n	c04f682 <mbedtls_rsa_check_pubkey+0xe>
 c04f6bc:	ffffbe00 	.word	0xffffbe00

0c04f6c0 <mbedtls_rsa_check_privkey>:
{
 c04f6c0:	b5f0      	push	{r4, r5, r6, r7, lr}
 c04f6c2:	b085      	sub	sp, #20
 c04f6c4:	4604      	mov	r4, r0
    if( mbedtls_rsa_check_pubkey( ctx ) != 0 ||
 c04f6c6:	f7ff ffd5 	bl	c04f674 <mbedtls_rsa_check_pubkey>
 c04f6ca:	b920      	cbnz	r0, c04f6d6 <mbedtls_rsa_check_privkey+0x16>
        rsa_check_context( ctx, 1 /* private */, 1 /* blinding */ ) != 0 )
 c04f6cc:	2101      	movs	r1, #1
 c04f6ce:	4620      	mov	r0, r4
 c04f6d0:	f7ff fd46 	bl	c04f160 <rsa_check_context.constprop.0>
    if( mbedtls_rsa_check_pubkey( ctx ) != 0 ||
 c04f6d4:	b110      	cbz	r0, c04f6dc <mbedtls_rsa_check_privkey+0x1c>
        return( MBEDTLS_ERR_RSA_KEY_CHECK_FAILED );
 c04f6d6:	4813      	ldr	r0, [pc, #76]	@ (c04f724 <mbedtls_rsa_check_privkey+0x64>)
}
 c04f6d8:	b005      	add	sp, #20
 c04f6da:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if( mbedtls_rsa_validate_params( &ctx->N, &ctx->P, &ctx->Q,
 c04f6dc:	f104 0314 	add.w	r3, r4, #20
 c04f6e0:	f104 052c 	add.w	r5, r4, #44	@ 0x2c
 c04f6e4:	f104 0638 	add.w	r6, r4, #56	@ 0x38
 c04f6e8:	f104 0720 	add.w	r7, r4, #32
 c04f6ec:	e9cd 0001 	strd	r0, r0, [sp, #4]
 c04f6f0:	9300      	str	r3, [sp, #0]
 c04f6f2:	4632      	mov	r2, r6
 c04f6f4:	463b      	mov	r3, r7
 c04f6f6:	4629      	mov	r1, r5
 c04f6f8:	f104 0008 	add.w	r0, r4, #8
 c04f6fc:	f008 fc78 	bl	c057ff0 <mbedtls_rsa_validate_params>
 c04f700:	2800      	cmp	r0, #0
 c04f702:	d1e8      	bne.n	c04f6d6 <mbedtls_rsa_check_privkey+0x16>
    else if( mbedtls_rsa_validate_crt( &ctx->P, &ctx->Q, &ctx->D,
 c04f704:	f104 0368 	add.w	r3, r4, #104	@ 0x68
 c04f708:	9301      	str	r3, [sp, #4]
 c04f70a:	f104 035c 	add.w	r3, r4, #92	@ 0x5c
 c04f70e:	9300      	str	r3, [sp, #0]
 c04f710:	463a      	mov	r2, r7
 c04f712:	4631      	mov	r1, r6
 c04f714:	4628      	mov	r0, r5
 c04f716:	f104 0350 	add.w	r3, r4, #80	@ 0x50
 c04f71a:	f008 fbe1 	bl	c057ee0 <mbedtls_rsa_validate_crt>
 c04f71e:	2800      	cmp	r0, #0
 c04f720:	d0da      	beq.n	c04f6d8 <mbedtls_rsa_check_privkey+0x18>
 c04f722:	e7d8      	b.n	c04f6d6 <mbedtls_rsa_check_privkey+0x16>
 c04f724:	ffffbe00 	.word	0xffffbe00

0c04f728 <mbedtls_rsa_check_pub_priv>:
{
 c04f728:	b538      	push	{r3, r4, r5, lr}
 c04f72a:	4605      	mov	r5, r0
 c04f72c:	460c      	mov	r4, r1
    if( mbedtls_rsa_check_pubkey( pub )  != 0 ||
 c04f72e:	f7ff ffa1 	bl	c04f674 <mbedtls_rsa_check_pubkey>
 c04f732:	b918      	cbnz	r0, c04f73c <mbedtls_rsa_check_pub_priv+0x14>
        mbedtls_rsa_check_privkey( prv ) != 0 )
 c04f734:	4620      	mov	r0, r4
 c04f736:	f7ff ffc3 	bl	c04f6c0 <mbedtls_rsa_check_privkey>
    if( mbedtls_rsa_check_pubkey( pub )  != 0 ||
 c04f73a:	b108      	cbz	r0, c04f740 <mbedtls_rsa_check_pub_priv+0x18>
        return( MBEDTLS_ERR_RSA_KEY_CHECK_FAILED );
 c04f73c:	4809      	ldr	r0, [pc, #36]	@ (c04f764 <mbedtls_rsa_check_pub_priv+0x3c>)
}
 c04f73e:	bd38      	pop	{r3, r4, r5, pc}
    if( mbedtls_mpi_cmp_mpi( &pub->N, &prv->N ) != 0 ||
 c04f740:	f104 0108 	add.w	r1, r4, #8
 c04f744:	f105 0008 	add.w	r0, r5, #8
 c04f748:	f004 f878 	bl	c05383c <mbedtls_mpi_cmp_mpi>
 c04f74c:	2800      	cmp	r0, #0
 c04f74e:	d1f5      	bne.n	c04f73c <mbedtls_rsa_check_pub_priv+0x14>
        mbedtls_mpi_cmp_mpi( &pub->E, &prv->E ) != 0 )
 c04f750:	f104 0114 	add.w	r1, r4, #20
 c04f754:	f105 0014 	add.w	r0, r5, #20
 c04f758:	f004 f870 	bl	c05383c <mbedtls_mpi_cmp_mpi>
    if( mbedtls_mpi_cmp_mpi( &pub->N, &prv->N ) != 0 ||
 c04f75c:	2800      	cmp	r0, #0
 c04f75e:	d0ee      	beq.n	c04f73e <mbedtls_rsa_check_pub_priv+0x16>
 c04f760:	e7ec      	b.n	c04f73c <mbedtls_rsa_check_pub_priv+0x14>
 c04f762:	bf00      	nop
 c04f764:	ffffbe00 	.word	0xffffbe00

0c04f768 <mbedtls_rsa_public>:
{
 c04f768:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c04f76c:	4689      	mov	r9, r1
 c04f76e:	b08f      	sub	sp, #60	@ 0x3c
    if( rsa_check_context( ctx, 0 /* public */, 0 /* no blinding */ ) )
 c04f770:	2100      	movs	r1, #0
{
 c04f772:	4607      	mov	r7, r0
 c04f774:	9201      	str	r2, [sp, #4]
    if( rsa_check_context( ctx, 0 /* public */, 0 /* no blinding */ ) )
 c04f776:	f7ff fcf3 	bl	c04f160 <rsa_check_context.constprop.0>
 c04f77a:	4604      	mov	r4, r0
 c04f77c:	2800      	cmp	r0, #0
 c04f77e:	f040 809b 	bne.w	c04f8b8 <mbedtls_rsa_public+0x150>
    mbedtls_mpi_init( &T );
 c04f782:	a803      	add	r0, sp, #12
 c04f784:	f003 fdb7 	bl	c0532f6 <mbedtls_mpi_init>
    MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( &T, input, ctx->len ) );
 c04f788:	4649      	mov	r1, r9
 c04f78a:	687a      	ldr	r2, [r7, #4]
 c04f78c:	a803      	add	r0, sp, #12
 c04f78e:	f003 ff0c 	bl	c0535aa <mbedtls_mpi_read_binary>
 c04f792:	4682      	mov	sl, r0
 c04f794:	2800      	cmp	r0, #0
 c04f796:	d17e      	bne.n	c04f896 <mbedtls_rsa_public+0x12e>
    if( mbedtls_mpi_cmp_mpi( &T, &ctx->N ) >= 0 )
 c04f798:	f107 0b08 	add.w	fp, r7, #8
 c04f79c:	4659      	mov	r1, fp
 c04f79e:	a803      	add	r0, sp, #12
 c04f7a0:	f004 f84c 	bl	c05383c <mbedtls_mpi_cmp_mpi>
 c04f7a4:	2800      	cmp	r0, #0
 c04f7a6:	f280 8084 	bge.w	c04f8b2 <mbedtls_rsa_public+0x14a>
    PKA_ModExpInTypeDef in = {0};
 c04f7aa:	4651      	mov	r1, sl
 c04f7ac:	2214      	movs	r2, #20
    PKA_HandleTypeDef hpka = {0};
 c04f7ae:	e9cd aa06 	strd	sl, sl, [sp, #24]
 c04f7b2:	f8cd a020 	str.w	sl, [sp, #32]
    PKA_ModExpInTypeDef in = {0};
 c04f7b6:	a809      	add	r0, sp, #36	@ 0x24
        elen = mbedtls_mpi_size( &ctx->E );
 c04f7b8:	f107 0a14 	add.w	sl, r7, #20
    PKA_ModExpInTypeDef in = {0};
 c04f7bc:	f00b ffb7 	bl	c05b72e <memset>
        elen = mbedtls_mpi_size( &ctx->E );
 c04f7c0:	4650      	mov	r0, sl
 c04f7c2:	f003 feca 	bl	c05355a <mbedtls_mpi_size>
    elen = ((elen + 3)/4)*4;
 c04f7c6:	1cc6      	adds	r6, r0, #3
 c04f7c8:	f026 0603 	bic.w	r6, r6, #3
    e_binary = mbedtls_calloc( 1, elen );
 c04f7cc:	4631      	mov	r1, r6
 c04f7ce:	2001      	movs	r0, #1
 c04f7d0:	f7eb fde8 	bl	c03b3a4 <mbedtls_calloc>
    MBEDTLS_MPI_CHK( ( e_binary == NULL ) ? MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED : 0 );
 c04f7d4:	4605      	mov	r5, r0
 c04f7d6:	2800      	cmp	r0, #0
 c04f7d8:	d069      	beq.n	c04f8ae <mbedtls_rsa_public+0x146>
        MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( &ctx->E, e_binary, elen ) );
 c04f7da:	4601      	mov	r1, r0
 c04f7dc:	4632      	mov	r2, r6
 c04f7de:	4650      	mov	r0, sl
 c04f7e0:	f003 ff3a 	bl	c053658 <mbedtls_mpi_write_binary>
 c04f7e4:	4682      	mov	sl, r0
 c04f7e6:	2800      	cmp	r0, #0
 c04f7e8:	d137      	bne.n	c04f85a <mbedtls_rsa_public+0xf2>
    nlen = ctx->len;
 c04f7ea:	f8d7 8004 	ldr.w	r8, [r7, #4]
    n_binary = mbedtls_calloc( 1, nlen );
 c04f7ee:	2001      	movs	r0, #1
 c04f7f0:	4641      	mov	r1, r8
 c04f7f2:	f7eb fdd7 	bl	c03b3a4 <mbedtls_calloc>
    MBEDTLS_MPI_CHK( ( n_binary == NULL ) ? MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED : 0 );
 c04f7f6:	4604      	mov	r4, r0
 c04f7f8:	b340      	cbz	r0, c04f84c <mbedtls_rsa_public+0xe4>
    MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( &ctx->N, n_binary, nlen ) );
 c04f7fa:	4601      	mov	r1, r0
 c04f7fc:	4642      	mov	r2, r8
 c04f7fe:	4658      	mov	r0, fp
 c04f800:	f003 ff2a 	bl	c053658 <mbedtls_mpi_write_binary>
 c04f804:	4682      	mov	sl, r0
 c04f806:	bb40      	cbnz	r0, c04f85a <mbedtls_rsa_public+0xf2>
        in.OpSize  = nlen;           /* modulus length */
 c04f808:	e9cd 6809 	strd	r6, r8, [sp, #36]	@ 0x24
    __HAL_RCC_PKA_CLK_ENABLE();
 c04f80c:	4a2c      	ldr	r2, [pc, #176]	@ (c04f8c0 <mbedtls_rsa_public+0x158>)
        in.pExp    = e_binary;       /* Exponent */
 c04f80e:	e9cd 590b 	strd	r5, r9, [sp, #44]	@ 0x2c
    __HAL_RCC_PKA_CLK_ENABLE();
 c04f812:	f8d2 108c 	ldr.w	r1, [r2, #140]	@ 0x8c
        in.pMod    = n_binary;       /* modulus */
 c04f816:	940d      	str	r4, [sp, #52]	@ 0x34
    __HAL_RCC_PKA_CLK_ENABLE();
 c04f818:	f441 2100 	orr.w	r1, r1, #524288	@ 0x80000
 c04f81c:	f8c2 108c 	str.w	r1, [r2, #140]	@ 0x8c
 c04f820:	f8d2 208c 	ldr.w	r2, [r2, #140]	@ 0x8c
    MBEDTLS_MPI_CHK( ( HAL_PKA_Init( &hpka ) != HAL_OK ) ? MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED : 0 );
 c04f824:	a806      	add	r0, sp, #24
    __HAL_RCC_PKA_CLK_ENABLE();
 c04f826:	f402 2200 	and.w	r2, r2, #524288	@ 0x80000
 c04f82a:	9202      	str	r2, [sp, #8]
 c04f82c:	9a02      	ldr	r2, [sp, #8]
    hpka.Instance = PKA;
 c04f82e:	4a25      	ldr	r2, [pc, #148]	@ (c04f8c4 <mbedtls_rsa_public+0x15c>)
 c04f830:	9206      	str	r2, [sp, #24]
    MBEDTLS_MPI_CHK( ( HAL_PKA_Init( &hpka ) != HAL_OK ) ? MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED : 0 );
 c04f832:	f7f0 fc2c 	bl	c04008e <HAL_PKA_Init>
 c04f836:	b948      	cbnz	r0, c04f84c <mbedtls_rsa_public+0xe4>
    HAL_PKA_RAMReset(&hpka);
 c04f838:	a806      	add	r0, sp, #24
 c04f83a:	f7ef fec7 	bl	c03f5cc <HAL_PKA_RAMReset>
        MBEDTLS_MPI_CHK( ( HAL_PKA_ModExp( &hpka, &in, ST_PKA_TIMEOUT ) != HAL_OK ) ? MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED : 0 );
 c04f83e:	f241 3288 	movw	r2, #5000	@ 0x1388
 c04f842:	a909      	add	r1, sp, #36	@ 0x24
 c04f844:	a806      	add	r0, sp, #24
 c04f846:	f7f0 f8b9 	bl	c03f9bc <HAL_PKA_ModExp>
 c04f84a:	b110      	cbz	r0, c04f852 <mbedtls_rsa_public+0xea>
    MBEDTLS_MPI_CHK( ( n_binary == NULL ) ? MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED : 0 );
 c04f84c:	f06f 0a6f 	mvn.w	sl, #111	@ 0x6f
 c04f850:	e003      	b.n	c04f85a <mbedtls_rsa_public+0xf2>
    HAL_PKA_ModExp_GetResult( &hpka, (uint8_t *)output );
 c04f852:	9901      	ldr	r1, [sp, #4]
 c04f854:	a806      	add	r0, sp, #24
 c04f856:	f7ef ff4f 	bl	c03f6f8 <HAL_PKA_ModExp_GetResult>
    if (HAL_PKA_GetState(&hpka) != HAL_PKA_STATE_RESET)
 c04f85a:	a806      	add	r0, sp, #24
 c04f85c:	f7ef fec4 	bl	c03f5e8 <HAL_PKA_GetState>
 c04f860:	b110      	cbz	r0, c04f868 <mbedtls_rsa_public+0x100>
        HAL_PKA_DeInit( &hpka );
 c04f862:	a806      	add	r0, sp, #24
 c04f864:	f7ef fe8c 	bl	c03f580 <HAL_PKA_DeInit>
    __HAL_RCC_PKA_CLK_DISABLE();
 c04f868:	4915      	ldr	r1, [pc, #84]	@ (c04f8c0 <mbedtls_rsa_public+0x158>)
 c04f86a:	f8d1 208c 	ldr.w	r2, [r1, #140]	@ 0x8c
 c04f86e:	f422 2200 	bic.w	r2, r2, #524288	@ 0x80000
 c04f872:	f8c1 208c 	str.w	r2, [r1, #140]	@ 0x8c
    if (e_binary != NULL)
 c04f876:	b135      	cbz	r5, c04f886 <mbedtls_rsa_public+0x11e>
        mbedtls_platform_zeroize( e_binary, elen );
 c04f878:	4628      	mov	r0, r5
 c04f87a:	4631      	mov	r1, r6
 c04f87c:	f7eb fda8 	bl	c03b3d0 <mbedtls_platform_zeroize>
        mbedtls_free( e_binary );
 c04f880:	4628      	mov	r0, r5
 c04f882:	f7eb fd95 	bl	c03b3b0 <mbedtls_free>
    if (n_binary != NULL)
 c04f886:	b134      	cbz	r4, c04f896 <mbedtls_rsa_public+0x12e>
        mbedtls_platform_zeroize( n_binary, nlen );
 c04f888:	4620      	mov	r0, r4
 c04f88a:	4641      	mov	r1, r8
 c04f88c:	f7eb fda0 	bl	c03b3d0 <mbedtls_platform_zeroize>
        mbedtls_free( n_binary );
 c04f890:	4620      	mov	r0, r4
 c04f892:	f7eb fd8d 	bl	c03b3b0 <mbedtls_free>
    mbedtls_mpi_free( &T );
 c04f896:	a803      	add	r0, sp, #12
 c04f898:	f003 fd33 	bl	c053302 <mbedtls_mpi_free>
    if( ret != 0 )
 c04f89c:	f1ba 0f00 	cmp.w	sl, #0
 c04f8a0:	d001      	beq.n	c04f8a6 <mbedtls_rsa_public+0x13e>
 c04f8a2:	f5aa 4a85 	sub.w	sl, sl, #17024	@ 0x4280
}
 c04f8a6:	4650      	mov	r0, sl
 c04f8a8:	b00f      	add	sp, #60	@ 0x3c
 c04f8aa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    uint8_t *n_binary = NULL;
 c04f8ae:	4604      	mov	r4, r0
 c04f8b0:	e7cc      	b.n	c04f84c <mbedtls_rsa_public+0xe4>
        ret = MBEDTLS_ERR_MPI_BAD_INPUT_DATA;
 c04f8b2:	f06f 0a03 	mvn.w	sl, #3
 c04f8b6:	e7ee      	b.n	c04f896 <mbedtls_rsa_public+0x12e>
        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
 c04f8b8:	f8df a00c 	ldr.w	sl, [pc, #12]	@ c04f8c8 <mbedtls_rsa_public+0x160>
 c04f8bc:	e7f3      	b.n	c04f8a6 <mbedtls_rsa_public+0x13e>
 c04f8be:	bf00      	nop
 c04f8c0:	56020c00 	.word	0x56020c00
 c04f8c4:	520c2000 	.word	0x520c2000
 c04f8c8:	ffffbf80 	.word	0xffffbf80

0c04f8cc <mbedtls_rsa_private>:
{
 c04f8cc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    if( rsa_check_context( ctx, 1             /* private key checks */,
 c04f8d0:	2101      	movs	r1, #1
{
 c04f8d2:	b09b      	sub	sp, #108	@ 0x6c
 c04f8d4:	4604      	mov	r4, r0
 c04f8d6:	9304      	str	r3, [sp, #16]
    if( rsa_check_context( ctx, 1             /* private key checks */,
 c04f8d8:	f7ff fc42 	bl	c04f160 <rsa_check_context.constprop.0>
 c04f8dc:	4605      	mov	r5, r0
 c04f8de:	2800      	cmp	r0, #0
 c04f8e0:	f040 8132 	bne.w	c04fb48 <mbedtls_rsa_private+0x27c>
    mbedtls_mpi_init( &T );
 c04f8e4:	a807      	add	r0, sp, #28
 c04f8e6:	f003 fd06 	bl	c0532f6 <mbedtls_mpi_init>
    mbedtls_mpi_init( &I );
 c04f8ea:	a80a      	add	r0, sp, #40	@ 0x28
 c04f8ec:	f003 fd03 	bl	c0532f6 <mbedtls_mpi_init>
    mbedtls_mpi_init( &C );
 c04f8f0:	a80d      	add	r0, sp, #52	@ 0x34
 c04f8f2:	f003 fd00 	bl	c0532f6 <mbedtls_mpi_init>
    MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( &T, input, ctx->len ) );
 c04f8f6:	6862      	ldr	r2, [r4, #4]
 c04f8f8:	9904      	ldr	r1, [sp, #16]
 c04f8fa:	a807      	add	r0, sp, #28
 c04f8fc:	f003 fe55 	bl	c0535aa <mbedtls_mpi_read_binary>
 c04f900:	4681      	mov	r9, r0
 c04f902:	2800      	cmp	r0, #0
 c04f904:	f040 80ee 	bne.w	c04fae4 <mbedtls_rsa_private+0x218>
    if( mbedtls_mpi_cmp_mpi( &T, &ctx->N ) >= 0 )
 c04f908:	f104 0108 	add.w	r1, r4, #8
 c04f90c:	a807      	add	r0, sp, #28
 c04f90e:	f003 ff95 	bl	c05383c <mbedtls_mpi_cmp_mpi>
 c04f912:	2800      	cmp	r0, #0
 c04f914:	f280 8115 	bge.w	c04fb42 <mbedtls_rsa_private+0x276>
    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &I, &T ) );
 c04f918:	a907      	add	r1, sp, #28
 c04f91a:	a80a      	add	r0, sp, #40	@ 0x28
 c04f91c:	f003 fd45 	bl	c0533aa <mbedtls_mpi_copy>
 c04f920:	4681      	mov	r9, r0
 c04f922:	2800      	cmp	r0, #0
 c04f924:	f040 80de 	bne.w	c04fae4 <mbedtls_rsa_private+0x218>
    MBEDTLS_MPI_CHK( rsa_crt_pka_modexp( DP, DQ, &ctx->P, &ctx->Q, &ctx->QP, input, ctx->len, output) );
 c04f928:	6863      	ldr	r3, [r4, #4]
    PKA_RSACRTExpInTypeDef in = {0};
 c04f92a:	4601      	mov	r1, r0
 c04f92c:	221c      	movs	r2, #28
    PKA_HandleTypeDef hpka = {0};
 c04f92e:	e9cd 0010 	strd	r0, r0, [sp, #64]	@ 0x40
 c04f932:	9012      	str	r0, [sp, #72]	@ 0x48
    mbedtls_mpi *DP = &ctx->DP;
 c04f934:	f104 0650 	add.w	r6, r4, #80	@ 0x50
    PKA_RSACRTExpInTypeDef in = {0};
 c04f938:	a813      	add	r0, sp, #76	@ 0x4c
    MBEDTLS_MPI_CHK( rsa_crt_pka_modexp( DP, DQ, &ctx->P, &ctx->Q, &ctx->QP, input, ctx->len, output) );
 c04f93a:	9305      	str	r3, [sp, #20]
    PKA_RSACRTExpInTypeDef in = {0};
 c04f93c:	f00b fef7 	bl	c05b72e <memset>
    dplen = mbedtls_mpi_size( dp );
 c04f940:	4630      	mov	r0, r6
 c04f942:	f003 fe0a 	bl	c05355a <mbedtls_mpi_size>
    dp_binary = mbedtls_calloc( 1, dplen );
 c04f946:	4601      	mov	r1, r0
    dplen = mbedtls_mpi_size( dp );
 c04f948:	4683      	mov	fp, r0
    dp_binary = mbedtls_calloc( 1, dplen );
 c04f94a:	2001      	movs	r0, #1
 c04f94c:	f7eb fd2a 	bl	c03b3a4 <mbedtls_calloc>
    MBEDTLS_MPI_CHK( ( dp_binary == NULL ) ? MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED : 0 );
 c04f950:	4680      	mov	r8, r0
 c04f952:	2800      	cmp	r0, #0
 c04f954:	f000 80db 	beq.w	c04fb0e <mbedtls_rsa_private+0x242>
    MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( dp, dp_binary, dplen ) );
 c04f958:	4601      	mov	r1, r0
 c04f95a:	465a      	mov	r2, fp
 c04f95c:	4630      	mov	r0, r6
 c04f95e:	f003 fe7b 	bl	c053658 <mbedtls_mpi_write_binary>
 c04f962:	4681      	mov	r9, r0
 c04f964:	2800      	cmp	r0, #0
 c04f966:	f040 80d7 	bne.w	c04fb18 <mbedtls_rsa_private+0x24c>
    mbedtls_mpi *DQ = &ctx->DQ;
 c04f96a:	f104 065c 	add.w	r6, r4, #92	@ 0x5c
    dqlen = mbedtls_mpi_size( dq );
 c04f96e:	4630      	mov	r0, r6
 c04f970:	f003 fdf3 	bl	c05355a <mbedtls_mpi_size>
    dq_binary = mbedtls_calloc( 1, dqlen );
 c04f974:	4601      	mov	r1, r0
    dqlen = mbedtls_mpi_size( dq );
 c04f976:	4682      	mov	sl, r0
    dq_binary = mbedtls_calloc( 1, dqlen );
 c04f978:	2001      	movs	r0, #1
 c04f97a:	f7eb fd13 	bl	c03b3a4 <mbedtls_calloc>
    MBEDTLS_MPI_CHK( ( dq_binary == NULL ) ? MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED : 0 );
 c04f97e:	4607      	mov	r7, r0
 c04f980:	2800      	cmp	r0, #0
 c04f982:	f000 80cd 	beq.w	c04fb20 <mbedtls_rsa_private+0x254>
    MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( dq, dq_binary, dqlen ) );
 c04f986:	4601      	mov	r1, r0
 c04f988:	4652      	mov	r2, sl
 c04f98a:	4630      	mov	r0, r6
 c04f98c:	f003 fe64 	bl	c053658 <mbedtls_mpi_write_binary>
 c04f990:	4681      	mov	r9, r0
 c04f992:	2800      	cmp	r0, #0
 c04f994:	f040 80c8 	bne.w	c04fb28 <mbedtls_rsa_private+0x25c>
    MBEDTLS_MPI_CHK( rsa_crt_pka_modexp( DP, DQ, &ctx->P, &ctx->Q, &ctx->QP, input, ctx->len, output) );
 c04f998:	f104 052c 	add.w	r5, r4, #44	@ 0x2c
    plen = mbedtls_mpi_size( p );
 c04f99c:	4628      	mov	r0, r5
 c04f99e:	f003 fddc 	bl	c05355a <mbedtls_mpi_size>
    p_binary = mbedtls_calloc( 1, plen );
 c04f9a2:	4601      	mov	r1, r0
    plen = mbedtls_mpi_size( p );
 c04f9a4:	9001      	str	r0, [sp, #4]
    p_binary = mbedtls_calloc( 1, plen );
 c04f9a6:	2001      	movs	r0, #1
 c04f9a8:	f7eb fcfc 	bl	c03b3a4 <mbedtls_calloc>
    MBEDTLS_MPI_CHK( ( p_binary == NULL ) ? MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED : 0 );
 c04f9ac:	4606      	mov	r6, r0
 c04f9ae:	2800      	cmp	r0, #0
 c04f9b0:	f000 80bd 	beq.w	c04fb2e <mbedtls_rsa_private+0x262>
    MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( p, p_binary, plen ) );
 c04f9b4:	4601      	mov	r1, r0
 c04f9b6:	9a01      	ldr	r2, [sp, #4]
 c04f9b8:	4628      	mov	r0, r5
 c04f9ba:	f003 fe4d 	bl	c053658 <mbedtls_mpi_write_binary>
 c04f9be:	4681      	mov	r9, r0
 c04f9c0:	2800      	cmp	r0, #0
 c04f9c2:	f040 80b7 	bne.w	c04fb34 <mbedtls_rsa_private+0x268>
    MBEDTLS_MPI_CHK( rsa_crt_pka_modexp( DP, DQ, &ctx->P, &ctx->Q, &ctx->QP, input, ctx->len, output) );
 c04f9c6:	f104 0938 	add.w	r9, r4, #56	@ 0x38
    qlen = mbedtls_mpi_size( q );
 c04f9ca:	4648      	mov	r0, r9
 c04f9cc:	f003 fdc5 	bl	c05355a <mbedtls_mpi_size>
    q_binary = mbedtls_calloc( 1, qlen );
 c04f9d0:	4601      	mov	r1, r0
    qlen = mbedtls_mpi_size( q );
 c04f9d2:	9002      	str	r0, [sp, #8]
    q_binary = mbedtls_calloc( 1, qlen );
 c04f9d4:	2001      	movs	r0, #1
 c04f9d6:	f7eb fce5 	bl	c03b3a4 <mbedtls_calloc>
    MBEDTLS_MPI_CHK( ( q_binary == NULL ) ? MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED : 0 );
 c04f9da:	4605      	mov	r5, r0
 c04f9dc:	2800      	cmp	r0, #0
 c04f9de:	f000 80ac 	beq.w	c04fb3a <mbedtls_rsa_private+0x26e>
    MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( q, q_binary, qlen ) );
 c04f9e2:	4601      	mov	r1, r0
 c04f9e4:	9a02      	ldr	r2, [sp, #8]
 c04f9e6:	4648      	mov	r0, r9
 c04f9e8:	f003 fe36 	bl	c053658 <mbedtls_mpi_write_binary>
 c04f9ec:	4681      	mov	r9, r0
 c04f9ee:	2800      	cmp	r0, #0
 c04f9f0:	f040 80a5 	bne.w	c04fb3e <mbedtls_rsa_private+0x272>
    MBEDTLS_MPI_CHK( rsa_crt_pka_modexp( DP, DQ, &ctx->P, &ctx->Q, &ctx->QP, input, ctx->len, output) );
 c04f9f4:	f104 0968 	add.w	r9, r4, #104	@ 0x68
    qplen = mbedtls_mpi_size( qp );
 c04f9f8:	4648      	mov	r0, r9
 c04f9fa:	f003 fdae 	bl	c05355a <mbedtls_mpi_size>
    qp_binary = mbedtls_calloc( 1, qplen );
 c04f9fe:	4601      	mov	r1, r0
    qplen = mbedtls_mpi_size( qp );
 c04fa00:	9003      	str	r0, [sp, #12]
    qp_binary = mbedtls_calloc( 1, qplen );
 c04fa02:	2001      	movs	r0, #1
 c04fa04:	f7eb fcce 	bl	c03b3a4 <mbedtls_calloc>
    MBEDTLS_MPI_CHK( ( qp_binary == NULL ) ? MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED : 0 );
 c04fa08:	4604      	mov	r4, r0
 c04fa0a:	b360      	cbz	r0, c04fa66 <mbedtls_rsa_private+0x19a>
    MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( qp, qp_binary, qplen ) );
 c04fa0c:	4601      	mov	r1, r0
 c04fa0e:	9a03      	ldr	r2, [sp, #12]
 c04fa10:	4648      	mov	r0, r9
 c04fa12:	f003 fe21 	bl	c053658 <mbedtls_mpi_write_binary>
 c04fa16:	4681      	mov	r9, r0
 c04fa18:	bb60      	cbnz	r0, c04fa74 <mbedtls_rsa_private+0x1a8>
    in.size    = input_len;
 c04fa1a:	9b05      	ldr	r3, [sp, #20]
    __HAL_RCC_PKA_CLK_ENABLE();
 c04fa1c:	4a4c      	ldr	r2, [pc, #304]	@ (c04fb50 <mbedtls_rsa_private+0x284>)
    in.pOpDp   = dp_binary;
 c04fa1e:	e9cd 3813 	strd	r3, r8, [sp, #76]	@ 0x4c
    __HAL_RCC_PKA_CLK_ENABLE();
 c04fa22:	f8d2 108c 	ldr.w	r1, [r2, #140]	@ 0x8c
    in.popA    = input;
 c04fa26:	9b04      	ldr	r3, [sp, #16]
    __HAL_RCC_PKA_CLK_ENABLE();
 c04fa28:	f441 2100 	orr.w	r1, r1, #524288	@ 0x80000
    in.pOpQinv = qp_binary;
 c04fa2c:	e9cd 7415 	strd	r7, r4, [sp, #84]	@ 0x54
    in.pPrimeQ = q_binary;
 c04fa30:	e9cd 6517 	strd	r6, r5, [sp, #92]	@ 0x5c
    in.popA    = input;
 c04fa34:	9319      	str	r3, [sp, #100]	@ 0x64
    __HAL_RCC_PKA_CLK_ENABLE();
 c04fa36:	f8c2 108c 	str.w	r1, [r2, #140]	@ 0x8c
 c04fa3a:	f8d2 208c 	ldr.w	r2, [r2, #140]	@ 0x8c
    MBEDTLS_MPI_CHK( ( HAL_PKA_Init( &hpka ) != HAL_OK ) ? MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED : 0 );
 c04fa3e:	a810      	add	r0, sp, #64	@ 0x40
    __HAL_RCC_PKA_CLK_ENABLE();
 c04fa40:	f402 2200 	and.w	r2, r2, #524288	@ 0x80000
 c04fa44:	9206      	str	r2, [sp, #24]
 c04fa46:	9a06      	ldr	r2, [sp, #24]
    hpka.Instance = PKA;
 c04fa48:	4a42      	ldr	r2, [pc, #264]	@ (c04fb54 <mbedtls_rsa_private+0x288>)
 c04fa4a:	9210      	str	r2, [sp, #64]	@ 0x40
    MBEDTLS_MPI_CHK( ( HAL_PKA_Init( &hpka ) != HAL_OK ) ? MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED : 0 );
 c04fa4c:	f7f0 fb1f 	bl	c04008e <HAL_PKA_Init>
 c04fa50:	b948      	cbnz	r0, c04fa66 <mbedtls_rsa_private+0x19a>
    HAL_PKA_RAMReset(&hpka);
 c04fa52:	a810      	add	r0, sp, #64	@ 0x40
 c04fa54:	f7ef fdba 	bl	c03f5cc <HAL_PKA_RAMReset>
    MBEDTLS_MPI_CHK( ( HAL_PKA_RSACRTExp( &hpka, &in, ST_PKA_TIMEOUT ) != HAL_OK ) ? MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED : 0 );
 c04fa58:	f241 3288 	movw	r2, #5000	@ 0x1388
 c04fa5c:	a913      	add	r1, sp, #76	@ 0x4c
 c04fa5e:	a810      	add	r0, sp, #64	@ 0x40
 c04fa60:	f7f0 f995 	bl	c03fd8e <HAL_PKA_RSACRTExp>
 c04fa64:	b110      	cbz	r0, c04fa6c <mbedtls_rsa_private+0x1a0>
    MBEDTLS_MPI_CHK( ( qp_binary == NULL ) ? MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED : 0 );
 c04fa66:	f06f 096f 	mvn.w	r9, #111	@ 0x6f
 c04fa6a:	e003      	b.n	c04fa74 <mbedtls_rsa_private+0x1a8>
    HAL_PKA_RSACRTExp_GetResult( &hpka, (uint8_t *)output );
 c04fa6c:	9924      	ldr	r1, [sp, #144]	@ 0x90
 c04fa6e:	a810      	add	r0, sp, #64	@ 0x40
 c04fa70:	f7ef fe78 	bl	c03f764 <HAL_PKA_RSACRTExp_GetResult>
    if (HAL_PKA_GetState(&hpka) != HAL_PKA_STATE_RESET)
 c04fa74:	a810      	add	r0, sp, #64	@ 0x40
 c04fa76:	f7ef fdb7 	bl	c03f5e8 <HAL_PKA_GetState>
 c04fa7a:	b110      	cbz	r0, c04fa82 <mbedtls_rsa_private+0x1b6>
        HAL_PKA_DeInit( &hpka );
 c04fa7c:	a810      	add	r0, sp, #64	@ 0x40
 c04fa7e:	f7ef fd7f 	bl	c03f580 <HAL_PKA_DeInit>
    __HAL_RCC_PKA_CLK_DISABLE();
 c04fa82:	4933      	ldr	r1, [pc, #204]	@ (c04fb50 <mbedtls_rsa_private+0x284>)
 c04fa84:	f8d1 208c 	ldr.w	r2, [r1, #140]	@ 0x8c
 c04fa88:	f422 2200 	bic.w	r2, r2, #524288	@ 0x80000
 c04fa8c:	f8c1 208c 	str.w	r2, [r1, #140]	@ 0x8c
    if (dp_binary != NULL)
 c04fa90:	f1b8 0f00 	cmp.w	r8, #0
 c04fa94:	d006      	beq.n	c04faa4 <mbedtls_rsa_private+0x1d8>
        mbedtls_platform_zeroize( dp_binary, dplen );
 c04fa96:	4640      	mov	r0, r8
 c04fa98:	4659      	mov	r1, fp
 c04fa9a:	f7eb fc99 	bl	c03b3d0 <mbedtls_platform_zeroize>
        mbedtls_free( dp_binary );
 c04fa9e:	4640      	mov	r0, r8
 c04faa0:	f7eb fc86 	bl	c03b3b0 <mbedtls_free>
    if (dq_binary != NULL)
 c04faa4:	b137      	cbz	r7, c04fab4 <mbedtls_rsa_private+0x1e8>
        mbedtls_platform_zeroize( dq_binary, dqlen );
 c04faa6:	4638      	mov	r0, r7
 c04faa8:	4651      	mov	r1, sl
 c04faaa:	f7eb fc91 	bl	c03b3d0 <mbedtls_platform_zeroize>
        mbedtls_free( dq_binary );
 c04faae:	4638      	mov	r0, r7
 c04fab0:	f7eb fc7e 	bl	c03b3b0 <mbedtls_free>
    if (p_binary != NULL)
 c04fab4:	b136      	cbz	r6, c04fac4 <mbedtls_rsa_private+0x1f8>
        mbedtls_platform_zeroize( p_binary, plen );
 c04fab6:	4630      	mov	r0, r6
 c04fab8:	9901      	ldr	r1, [sp, #4]
 c04faba:	f7eb fc89 	bl	c03b3d0 <mbedtls_platform_zeroize>
        mbedtls_free( p_binary );
 c04fabe:	4630      	mov	r0, r6
 c04fac0:	f7eb fc76 	bl	c03b3b0 <mbedtls_free>
    if (q_binary != NULL)
 c04fac4:	b135      	cbz	r5, c04fad4 <mbedtls_rsa_private+0x208>
        mbedtls_platform_zeroize( q_binary, qlen );
 c04fac6:	4628      	mov	r0, r5
 c04fac8:	9902      	ldr	r1, [sp, #8]
 c04faca:	f7eb fc81 	bl	c03b3d0 <mbedtls_platform_zeroize>
        mbedtls_free( q_binary );
 c04face:	4628      	mov	r0, r5
 c04fad0:	f7eb fc6e 	bl	c03b3b0 <mbedtls_free>
    if (qp_binary != NULL)
 c04fad4:	b134      	cbz	r4, c04fae4 <mbedtls_rsa_private+0x218>
        mbedtls_platform_zeroize( qp_binary, qplen );
 c04fad6:	4620      	mov	r0, r4
 c04fad8:	9903      	ldr	r1, [sp, #12]
 c04fada:	f7eb fc79 	bl	c03b3d0 <mbedtls_platform_zeroize>
        mbedtls_free( qp_binary );
 c04fade:	4620      	mov	r0, r4
 c04fae0:	f7eb fc66 	bl	c03b3b0 <mbedtls_free>
    mbedtls_mpi_free( &T );
 c04fae4:	a807      	add	r0, sp, #28
 c04fae6:	f003 fc0c 	bl	c053302 <mbedtls_mpi_free>
    mbedtls_mpi_free( &C );
 c04faea:	a80d      	add	r0, sp, #52	@ 0x34
 c04faec:	f003 fc09 	bl	c053302 <mbedtls_mpi_free>
    mbedtls_mpi_free( &I );
 c04faf0:	a80a      	add	r0, sp, #40	@ 0x28
 c04faf2:	f003 fc06 	bl	c053302 <mbedtls_mpi_free>
    if( ret != 0 && ret >= -0x007f )
 c04faf6:	f1b9 0f00 	cmp.w	r9, #0
 c04fafa:	d004      	beq.n	c04fb06 <mbedtls_rsa_private+0x23a>
 c04fafc:	f119 0f7f 	cmn.w	r9, #127	@ 0x7f
 c04fb00:	db01      	blt.n	c04fb06 <mbedtls_rsa_private+0x23a>
 c04fb02:	f5a9 4986 	sub.w	r9, r9, #17152	@ 0x4300
}
 c04fb06:	4648      	mov	r0, r9
 c04fb08:	b01b      	add	sp, #108	@ 0x6c
 c04fb0a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    uint8_t *qp_binary = NULL;
 c04fb0e:	4604      	mov	r4, r0
    uint8_t *q_binary = NULL;
 c04fb10:	4605      	mov	r5, r0
    uint8_t *p_binary = NULL;
 c04fb12:	4606      	mov	r6, r0
    uint8_t *dq_binary = NULL;
 c04fb14:	4607      	mov	r7, r0
 c04fb16:	e7a6      	b.n	c04fa66 <mbedtls_rsa_private+0x19a>
    uint8_t *qp_binary = NULL;
 c04fb18:	462c      	mov	r4, r5
    uint8_t *p_binary = NULL;
 c04fb1a:	462e      	mov	r6, r5
    uint8_t *dq_binary = NULL;
 c04fb1c:	462f      	mov	r7, r5
 c04fb1e:	e7a9      	b.n	c04fa74 <mbedtls_rsa_private+0x1a8>
    uint8_t *qp_binary = NULL;
 c04fb20:	4604      	mov	r4, r0
    uint8_t *q_binary = NULL;
 c04fb22:	4605      	mov	r5, r0
    uint8_t *p_binary = NULL;
 c04fb24:	4606      	mov	r6, r0
 c04fb26:	e79e      	b.n	c04fa66 <mbedtls_rsa_private+0x19a>
    uint8_t *qp_binary = NULL;
 c04fb28:	462c      	mov	r4, r5
    uint8_t *p_binary = NULL;
 c04fb2a:	462e      	mov	r6, r5
 c04fb2c:	e7a2      	b.n	c04fa74 <mbedtls_rsa_private+0x1a8>
    uint8_t *qp_binary = NULL;
 c04fb2e:	4604      	mov	r4, r0
    uint8_t *q_binary = NULL;
 c04fb30:	4605      	mov	r5, r0
 c04fb32:	e798      	b.n	c04fa66 <mbedtls_rsa_private+0x19a>
    uint8_t *qp_binary = NULL;
 c04fb34:	2400      	movs	r4, #0
    uint8_t *q_binary = NULL;
 c04fb36:	4625      	mov	r5, r4
 c04fb38:	e79c      	b.n	c04fa74 <mbedtls_rsa_private+0x1a8>
    uint8_t *qp_binary = NULL;
 c04fb3a:	4604      	mov	r4, r0
 c04fb3c:	e793      	b.n	c04fa66 <mbedtls_rsa_private+0x19a>
 c04fb3e:	2400      	movs	r4, #0
 c04fb40:	e798      	b.n	c04fa74 <mbedtls_rsa_private+0x1a8>
        ret = MBEDTLS_ERR_MPI_BAD_INPUT_DATA;
 c04fb42:	f06f 0903 	mvn.w	r9, #3
 c04fb46:	e7cd      	b.n	c04fae4 <mbedtls_rsa_private+0x218>
        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
 c04fb48:	f8df 900c 	ldr.w	r9, [pc, #12]	@ c04fb58 <mbedtls_rsa_private+0x28c>
 c04fb4c:	e7db      	b.n	c04fb06 <mbedtls_rsa_private+0x23a>
 c04fb4e:	bf00      	nop
 c04fb50:	56020c00 	.word	0x56020c00
 c04fb54:	520c2000 	.word	0x520c2000
 c04fb58:	ffffbf80 	.word	0xffffbf80

0c04fb5c <rsa_rsassa_pss_sign>:
{
 c04fb5c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    if( mode == MBEDTLS_RSA_PRIVATE && ctx->padding != MBEDTLS_RSA_PKCS_V21 )
 c04fb60:	2b01      	cmp	r3, #1
{
 c04fb62:	b08d      	sub	sp, #52	@ 0x34
 c04fb64:	4680      	mov	r8, r0
 c04fb66:	e9dd 4519 	ldrd	r4, r5, [sp, #100]	@ 0x64
 c04fb6a:	e9cd 1203 	strd	r1, r2, [sp, #12]
 c04fb6e:	f89d 0058 	ldrb.w	r0, [sp, #88]	@ 0x58
 c04fb72:	9305      	str	r3, [sp, #20]
    if( mode == MBEDTLS_RSA_PRIVATE && ctx->padding != MBEDTLS_RSA_PKCS_V21 )
 c04fb74:	d108      	bne.n	c04fb88 <rsa_rsassa_pss_sign+0x2c>
 c04fb76:	f8d8 30b0 	ldr.w	r3, [r8, #176]	@ 0xb0
 c04fb7a:	2b01      	cmp	r3, #1
 c04fb7c:	d004      	beq.n	c04fb88 <rsa_rsassa_pss_sign+0x2c>
        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
 c04fb7e:	4a60      	ldr	r2, [pc, #384]	@ (c04fd00 <rsa_rsassa_pss_sign+0x1a4>)
}
 c04fb80:	4610      	mov	r0, r2
 c04fb82:	b00d      	add	sp, #52	@ 0x34
 c04fb84:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if( f_rng == NULL )
 c04fb88:	9b03      	ldr	r3, [sp, #12]
 c04fb8a:	2b00      	cmp	r3, #0
 c04fb8c:	d0f7      	beq.n	c04fb7e <rsa_rsassa_pss_sign+0x22>
    olen = ctx->len;
 c04fb8e:	f8d8 9004 	ldr.w	r9, [r8, #4]
    if( md_alg != MBEDTLS_MD_NONE )
 c04fb92:	b130      	cbz	r0, c04fba2 <rsa_rsassa_pss_sign+0x46>
        md_info = mbedtls_md_info_from_type( md_alg );
 c04fb94:	f006 fddc 	bl	c056750 <mbedtls_md_info_from_type>
        if( md_info == NULL )
 c04fb98:	2800      	cmp	r0, #0
 c04fb9a:	d0f0      	beq.n	c04fb7e <rsa_rsassa_pss_sign+0x22>
        hashlen = mbedtls_md_get_size( md_info );
 c04fb9c:	f006 ff64 	bl	c056a68 <mbedtls_md_get_size>
 c04fba0:	9017      	str	r0, [sp, #92]	@ 0x5c
    md_info = mbedtls_md_info_from_type( (mbedtls_md_type_t) ctx->hash_id );
 c04fba2:	f898 00b4 	ldrb.w	r0, [r8, #180]	@ 0xb4
 c04fba6:	f006 fdd3 	bl	c056750 <mbedtls_md_info_from_type>
    if( md_info == NULL )
 c04fbaa:	4683      	mov	fp, r0
 c04fbac:	2800      	cmp	r0, #0
 c04fbae:	d0e6      	beq.n	c04fb7e <rsa_rsassa_pss_sign+0x22>
    hlen = mbedtls_md_get_size( md_info );
 c04fbb0:	f006 ff5a 	bl	c056a68 <mbedtls_md_get_size>
    if (saltlen == MBEDTLS_RSA_SALT_LEN_ANY)
 c04fbb4:	1c63      	adds	r3, r4, #1
    hlen = mbedtls_md_get_size( md_info );
 c04fbb6:	4607      	mov	r7, r0
    if (saltlen == MBEDTLS_RSA_SALT_LEN_ANY)
 c04fbb8:	d12b      	bne.n	c04fc12 <rsa_rsassa_pss_sign+0xb6>
        if( olen < hlen + min_slen + 2 )
 c04fbba:	b202      	sxth	r2, r0
 c04fbbc:	ebb9 0f42 	cmp.w	r9, r2, lsl #1
 c04fbc0:	ea4f 0342 	mov.w	r3, r2, lsl #1
 c04fbc4:	d3db      	bcc.n	c04fb7e <rsa_rsassa_pss_sign+0x22>
        else if( olen >= hlen + hlen + 2 )
 c04fbc6:	3302      	adds	r3, #2
 c04fbc8:	454b      	cmp	r3, r9
 c04fbca:	d929      	bls.n	c04fc20 <rsa_rsassa_pss_sign+0xc4>
            slen = olen - hlen - 2;
 c04fbcc:	f1a9 0402 	sub.w	r4, r9, #2
 c04fbd0:	1a24      	subs	r4, r4, r0
    memset( sig, 0, olen );
 c04fbd2:	464a      	mov	r2, r9
 c04fbd4:	2100      	movs	r1, #0
 c04fbd6:	4628      	mov	r0, r5
 c04fbd8:	f00b fda9 	bl	c05b72e <memset>
    msb = mbedtls_mpi_bitlen( &ctx->N ) - 1;
 c04fbdc:	f108 0308 	add.w	r3, r8, #8
 c04fbe0:	4618      	mov	r0, r3
 c04fbe2:	9306      	str	r3, [sp, #24]
 c04fbe4:	f003 fc9b 	bl	c05351e <mbedtls_mpi_bitlen>
    *p++ = 0x01;
 c04fbe8:	2201      	movs	r2, #1
    p += olen - hlen - slen - 2;
 c04fbea:	eba9 0307 	sub.w	r3, r9, r7
 c04fbee:	9307      	str	r3, [sp, #28]
 c04fbf0:	3b02      	subs	r3, #2
 c04fbf2:	1b1b      	subs	r3, r3, r4
 c04fbf4:	eb05 0a03 	add.w	sl, r5, r3
    *p++ = 0x01;
 c04fbf8:	f10a 0a01 	add.w	sl, sl, #1
 c04fbfc:	54ea      	strb	r2, [r5, r3]
    msb = mbedtls_mpi_bitlen( &ctx->N ) - 1;
 c04fbfe:	9006      	str	r0, [sp, #24]
    if( ( ret = f_rng( p_rng, salt, slen ) ) != 0 )
 c04fc00:	4622      	mov	r2, r4
 c04fc02:	e9dd 3003 	ldrd	r3, r0, [sp, #12]
 c04fc06:	4651      	mov	r1, sl
 c04fc08:	4798      	blx	r3
 c04fc0a:	b158      	cbz	r0, c04fc24 <rsa_rsassa_pss_sign+0xc8>
 c04fc0c:	f5a0 4289 	sub.w	r2, r0, #17536	@ 0x4480
        return( MBEDTLS_ERROR_ADD( MBEDTLS_ERR_RSA_RNG_FAILED, ret ) );
 c04fc10:	e7b6      	b.n	c04fb80 <rsa_rsassa_pss_sign+0x24>
    else if ( (saltlen < 0) || (saltlen + hlen + 2 > olen) )
 c04fc12:	2c00      	cmp	r4, #0
 c04fc14:	dbb3      	blt.n	c04fb7e <rsa_rsassa_pss_sign+0x22>
 c04fc16:	1ca3      	adds	r3, r4, #2
 c04fc18:	4403      	add	r3, r0
 c04fc1a:	454b      	cmp	r3, r9
 c04fc1c:	d9d9      	bls.n	c04fbd2 <rsa_rsassa_pss_sign+0x76>
 c04fc1e:	e7ae      	b.n	c04fb7e <rsa_rsassa_pss_sign+0x22>
            slen = hlen;
 c04fc20:	4604      	mov	r4, r0
 c04fc22:	e7d6      	b.n	c04fbd2 <rsa_rsassa_pss_sign+0x76>
    mbedtls_md_init( &md_ctx );
 c04fc24:	ae09      	add	r6, sp, #36	@ 0x24
 c04fc26:	9007      	str	r0, [sp, #28]
 c04fc28:	4630      	mov	r0, r6
 c04fc2a:	f006 fd9d 	bl	c056768 <mbedtls_md_init>
    if( ( ret = mbedtls_md_setup( &md_ctx, md_info, 0 ) ) != 0 )
 c04fc2e:	9a07      	ldr	r2, [sp, #28]
 c04fc30:	4659      	mov	r1, fp
 c04fc32:	4630      	mov	r0, r6
 c04fc34:	f006 fdc6 	bl	c0567c4 <mbedtls_md_setup>
 c04fc38:	4602      	mov	r2, r0
 c04fc3a:	2800      	cmp	r0, #0
 c04fc3c:	d146      	bne.n	c04fccc <rsa_rsassa_pss_sign+0x170>
    if( ( ret = mbedtls_md_starts( &md_ctx ) ) != 0 )
 c04fc3e:	4630      	mov	r0, r6
 c04fc40:	f006 fdfc 	bl	c05683c <mbedtls_md_starts>
 c04fc44:	4602      	mov	r2, r0
 c04fc46:	2800      	cmp	r0, #0
 c04fc48:	d140      	bne.n	c04fccc <rsa_rsassa_pss_sign+0x170>
    p += slen;
 c04fc4a:	eb0a 0b04 	add.w	fp, sl, r4
    if( ( ret = mbedtls_md_update( &md_ctx, p, 8 ) ) != 0 )
 c04fc4e:	2208      	movs	r2, #8
 c04fc50:	4659      	mov	r1, fp
 c04fc52:	4630      	mov	r0, r6
 c04fc54:	f006 fe0e 	bl	c056874 <mbedtls_md_update>
 c04fc58:	4602      	mov	r2, r0
 c04fc5a:	bbb8      	cbnz	r0, c04fccc <rsa_rsassa_pss_sign+0x170>
    if( ( ret = mbedtls_md_update( &md_ctx, hash, hashlen ) ) != 0 )
 c04fc5c:	e9dd 2117 	ldrd	r2, r1, [sp, #92]	@ 0x5c
 c04fc60:	4630      	mov	r0, r6
 c04fc62:	f006 fe07 	bl	c056874 <mbedtls_md_update>
 c04fc66:	4602      	mov	r2, r0
 c04fc68:	bb80      	cbnz	r0, c04fccc <rsa_rsassa_pss_sign+0x170>
    if( ( ret = mbedtls_md_update( &md_ctx, salt, slen ) ) != 0 )
 c04fc6a:	4622      	mov	r2, r4
 c04fc6c:	4651      	mov	r1, sl
 c04fc6e:	4630      	mov	r0, r6
 c04fc70:	f006 fe00 	bl	c056874 <mbedtls_md_update>
 c04fc74:	4602      	mov	r2, r0
 c04fc76:	bb48      	cbnz	r0, c04fccc <rsa_rsassa_pss_sign+0x170>
    if( ( ret = mbedtls_md_finish( &md_ctx, p ) ) != 0 )
 c04fc78:	4659      	mov	r1, fp
 c04fc7a:	4630      	mov	r0, r6
 c04fc7c:	f006 fe10 	bl	c0568a0 <mbedtls_md_finish>
 c04fc80:	4602      	mov	r2, r0
 c04fc82:	bb18      	cbnz	r0, c04fccc <rsa_rsassa_pss_sign+0x170>
    msb = mbedtls_mpi_bitlen( &ctx->N ) - 1;
 c04fc84:	9b06      	ldr	r3, [sp, #24]
    if( ( ret = mgf_mask( sig + offset, olen - hlen - 1 - offset, p, hlen,
 c04fc86:	465a      	mov	r2, fp
    msb = mbedtls_mpi_bitlen( &ctx->N ) - 1;
 c04fc88:	3b01      	subs	r3, #1
    if( msb % 8 == 0 )
 c04fc8a:	f013 0f07 	tst.w	r3, #7
 c04fc8e:	bf0c      	ite	eq
 c04fc90:	2001      	moveq	r0, #1
 c04fc92:	2000      	movne	r0, #0
    if( ( ret = mgf_mask( sig + offset, olen - hlen - 1 - offset, p, hlen,
 c04fc94:	eba9 0307 	sub.w	r3, r9, r7
 c04fc98:	1e59      	subs	r1, r3, #1
 c04fc9a:	1a09      	subs	r1, r1, r0
 c04fc9c:	463b      	mov	r3, r7
 c04fc9e:	9600      	str	r6, [sp, #0]
 c04fca0:	4428      	add	r0, r5
 c04fca2:	f7ff f987 	bl	c04efb4 <mgf_mask>
 c04fca6:	4602      	mov	r2, r0
 c04fca8:	b980      	cbnz	r0, c04fccc <rsa_rsassa_pss_sign+0x170>
 c04fcaa:	9006      	str	r0, [sp, #24]
    msb = mbedtls_mpi_bitlen( &ctx->N ) - 1;
 c04fcac:	f108 0008 	add.w	r0, r8, #8
 c04fcb0:	f003 fc35 	bl	c05351e <mbedtls_mpi_bitlen>
    sig[0] &= 0xFF >> ( olen * 8 - msb );
 c04fcb4:	23ff      	movs	r3, #255	@ 0xff
 c04fcb6:	ebc0 00c9 	rsb	r0, r0, r9, lsl #3
 c04fcba:	7829      	ldrb	r1, [r5, #0]
 c04fcbc:	3001      	adds	r0, #1
 c04fcbe:	4103      	asrs	r3, r0
 c04fcc0:	400b      	ands	r3, r1
 c04fcc2:	702b      	strb	r3, [r5, #0]
    *p++ = 0xBC;
 c04fcc4:	23bc      	movs	r3, #188	@ 0xbc
 c04fcc6:	9a06      	ldr	r2, [sp, #24]
 c04fcc8:	f80b 3007 	strb.w	r3, [fp, r7]
    mbedtls_md_free( &md_ctx );
 c04fccc:	4630      	mov	r0, r6
 c04fcce:	9206      	str	r2, [sp, #24]
 c04fcd0:	f006 fd4f 	bl	c056772 <mbedtls_md_free>
    if( ret != 0 )
 c04fcd4:	9a06      	ldr	r2, [sp, #24]
 c04fcd6:	2a00      	cmp	r2, #0
 c04fcd8:	f47f af52 	bne.w	c04fb80 <rsa_rsassa_pss_sign+0x24>
            : mbedtls_rsa_private( ctx, f_rng, p_rng, sig, sig ) );
 c04fcdc:	9b05      	ldr	r3, [sp, #20]
 c04fcde:	b933      	cbnz	r3, c04fcee <rsa_rsassa_pss_sign+0x192>
            ? mbedtls_rsa_public(  ctx, sig, sig )
 c04fce0:	462a      	mov	r2, r5
 c04fce2:	4629      	mov	r1, r5
 c04fce4:	4640      	mov	r0, r8
 c04fce6:	f7ff fd3f 	bl	c04f768 <mbedtls_rsa_public>
            : mbedtls_rsa_private( ctx, f_rng, p_rng, sig, sig ) );
 c04fcea:	4602      	mov	r2, r0
 c04fcec:	e748      	b.n	c04fb80 <rsa_rsassa_pss_sign+0x24>
 c04fcee:	462b      	mov	r3, r5
 c04fcf0:	e9dd 1203 	ldrd	r1, r2, [sp, #12]
 c04fcf4:	4640      	mov	r0, r8
 c04fcf6:	9500      	str	r5, [sp, #0]
 c04fcf8:	f7ff fde8 	bl	c04f8cc <mbedtls_rsa_private>
 c04fcfc:	e7f5      	b.n	c04fcea <rsa_rsassa_pss_sign+0x18e>
 c04fcfe:	bf00      	nop
 c04fd00:	ffffbf80 	.word	0xffffbf80

0c04fd04 <mbedtls_rsa_rsaes_oaep_encrypt>:
{
 c04fd04:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    if( mode == MBEDTLS_RSA_PRIVATE && ctx->padding != MBEDTLS_RSA_PKCS_V21 )
 c04fd08:	2b01      	cmp	r3, #1
{
 c04fd0a:	b08b      	sub	sp, #44	@ 0x2c
 c04fd0c:	4606      	mov	r6, r0
 c04fd0e:	4689      	mov	r9, r1
 c04fd10:	e9cd 2302 	strd	r2, r3, [sp, #8]
 c04fd14:	f8dd b058 	ldr.w	fp, [sp, #88]	@ 0x58
 c04fd18:	9f18      	ldr	r7, [sp, #96]	@ 0x60
    if( mode == MBEDTLS_RSA_PRIVATE && ctx->padding != MBEDTLS_RSA_PKCS_V21 )
 c04fd1a:	d108      	bne.n	c04fd2e <mbedtls_rsa_rsaes_oaep_encrypt+0x2a>
 c04fd1c:	f8d0 30b0 	ldr.w	r3, [r0, #176]	@ 0xb0
 c04fd20:	2b01      	cmp	r3, #1
 c04fd22:	d004      	beq.n	c04fd2e <mbedtls_rsa_rsaes_oaep_encrypt+0x2a>
        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
 c04fd24:	4a42      	ldr	r2, [pc, #264]	@ (c04fe30 <mbedtls_rsa_rsaes_oaep_encrypt+0x12c>)
}
 c04fd26:	4610      	mov	r0, r2
 c04fd28:	b00b      	add	sp, #44	@ 0x2c
 c04fd2a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if( f_rng == NULL )
 c04fd2e:	f1b9 0f00 	cmp.w	r9, #0
 c04fd32:	d0f7      	beq.n	c04fd24 <mbedtls_rsa_rsaes_oaep_encrypt+0x20>
    md_info = mbedtls_md_info_from_type( (mbedtls_md_type_t) ctx->hash_id );
 c04fd34:	f896 00b4 	ldrb.w	r0, [r6, #180]	@ 0xb4
 c04fd38:	f006 fd0a 	bl	c056750 <mbedtls_md_info_from_type>
    if( md_info == NULL )
 c04fd3c:	4682      	mov	sl, r0
 c04fd3e:	2800      	cmp	r0, #0
 c04fd40:	d0f0      	beq.n	c04fd24 <mbedtls_rsa_rsaes_oaep_encrypt+0x20>
    olen = ctx->len;
 c04fd42:	6875      	ldr	r5, [r6, #4]
    hlen = mbedtls_md_get_size( md_info );
 c04fd44:	f006 fe90 	bl	c056a68 <mbedtls_md_get_size>
    if( ilen + 2 * hlen + 2 < ilen || olen < ilen + 2 * hlen + 2 )
 c04fd48:	b202      	sxth	r2, r0
 c04fd4a:	0053      	lsls	r3, r2, #1
 c04fd4c:	9304      	str	r3, [sp, #16]
 c04fd4e:	f10b 0302 	add.w	r3, fp, #2
 c04fd52:	eb03 0342 	add.w	r3, r3, r2, lsl #1
 c04fd56:	455b      	cmp	r3, fp
    hlen = mbedtls_md_get_size( md_info );
 c04fd58:	4604      	mov	r4, r0
    if( ilen + 2 * hlen + 2 < ilen || olen < ilen + 2 * hlen + 2 )
 c04fd5a:	d3e3      	bcc.n	c04fd24 <mbedtls_rsa_rsaes_oaep_encrypt+0x20>
 c04fd5c:	42ab      	cmp	r3, r5
 c04fd5e:	d8e1      	bhi.n	c04fd24 <mbedtls_rsa_rsaes_oaep_encrypt+0x20>
    memset( output, 0, olen );
 c04fd60:	462a      	mov	r2, r5
 c04fd62:	2100      	movs	r1, #0
 c04fd64:	4638      	mov	r0, r7
 c04fd66:	f00b fce2 	bl	c05b72e <memset>
    *p++ = 0;
 c04fd6a:	46b8      	mov	r8, r7
 c04fd6c:	2300      	movs	r3, #0
 c04fd6e:	f808 3b01 	strb.w	r3, [r8], #1
    if( ( ret = f_rng( p_rng, p, hlen ) ) != 0 )
 c04fd72:	4622      	mov	r2, r4
 c04fd74:	4641      	mov	r1, r8
 c04fd76:	9802      	ldr	r0, [sp, #8]
 c04fd78:	47c8      	blx	r9
 c04fd7a:	b110      	cbz	r0, c04fd82 <mbedtls_rsa_rsaes_oaep_encrypt+0x7e>
 c04fd7c:	f5a0 4289 	sub.w	r2, r0, #17536	@ 0x4480
        return( MBEDTLS_ERROR_ADD( MBEDTLS_ERR_RSA_RNG_FAILED, ret ) );
 c04fd80:	e7d1      	b.n	c04fd26 <mbedtls_rsa_rsaes_oaep_encrypt+0x22>
    p += hlen;
 c04fd82:	eb08 0304 	add.w	r3, r8, r4
    if( ( ret = mbedtls_md( md_info, label, label_len, p ) ) != 0 )
 c04fd86:	e9dd 1214 	ldrd	r1, r2, [sp, #80]	@ 0x50
 c04fd8a:	4650      	mov	r0, sl
 c04fd8c:	9305      	str	r3, [sp, #20]
 c04fd8e:	f006 fd9d 	bl	c0568cc <mbedtls_md>
 c04fd92:	4602      	mov	r2, r0
 c04fd94:	2800      	cmp	r0, #0
 c04fd96:	d1c6      	bne.n	c04fd26 <mbedtls_rsa_rsaes_oaep_encrypt+0x22>
    *p++ = 1;
 c04fd98:	2101      	movs	r1, #1
    p += olen - 2 * hlen - 2 - ilen;
 c04fd9a:	eba5 020b 	sub.w	r2, r5, fp
 c04fd9e:	9b04      	ldr	r3, [sp, #16]
 c04fda0:	3a02      	subs	r2, #2
 c04fda2:	4422      	add	r2, r4
 c04fda4:	1ad2      	subs	r2, r2, r3
 c04fda6:	9b05      	ldr	r3, [sp, #20]
 c04fda8:	1898      	adds	r0, r3, r2
    *p++ = 1;
 c04fdaa:	5499      	strb	r1, [r3, r2]
    if( ilen != 0 )
 c04fdac:	f1bb 0f00 	cmp.w	fp, #0
 c04fdb0:	d004      	beq.n	c04fdbc <mbedtls_rsa_rsaes_oaep_encrypt+0xb8>
        memcpy( p, input, ilen );
 c04fdb2:	465a      	mov	r2, fp
 c04fdb4:	9917      	ldr	r1, [sp, #92]	@ 0x5c
 c04fdb6:	3001      	adds	r0, #1
 c04fdb8:	f00b fc48 	bl	c05b64c <memcpy>
    mbedtls_md_init( &md_ctx );
 c04fdbc:	a807      	add	r0, sp, #28
 c04fdbe:	f006 fcd3 	bl	c056768 <mbedtls_md_init>
    if( ( ret = mbedtls_md_setup( &md_ctx, md_info, 0 ) ) != 0 )
 c04fdc2:	2200      	movs	r2, #0
 c04fdc4:	4651      	mov	r1, sl
 c04fdc6:	a807      	add	r0, sp, #28
 c04fdc8:	f006 fcfc 	bl	c0567c4 <mbedtls_md_setup>
 c04fdcc:	4602      	mov	r2, r0
 c04fdce:	b9b8      	cbnz	r0, c04fe00 <mbedtls_rsa_rsaes_oaep_encrypt+0xfc>
    if( ( ret = mgf_mask( output + hlen + 1, olen - hlen - 1, output + 1, hlen,
 c04fdd0:	f104 0a01 	add.w	sl, r4, #1
 c04fdd4:	3d01      	subs	r5, #1
 c04fdd6:	ab07      	add	r3, sp, #28
 c04fdd8:	44ba      	add	sl, r7
 c04fdda:	1b2d      	subs	r5, r5, r4
 c04fddc:	4642      	mov	r2, r8
 c04fdde:	9300      	str	r3, [sp, #0]
 c04fde0:	4629      	mov	r1, r5
 c04fde2:	4623      	mov	r3, r4
 c04fde4:	4650      	mov	r0, sl
 c04fde6:	f7ff f8e5 	bl	c04efb4 <mgf_mask>
 c04fdea:	4602      	mov	r2, r0
 c04fdec:	b940      	cbnz	r0, c04fe00 <mbedtls_rsa_rsaes_oaep_encrypt+0xfc>
    if( ( ret = mgf_mask( output + 1, hlen, output + hlen + 1, olen - hlen - 1,
 c04fdee:	ab07      	add	r3, sp, #28
 c04fdf0:	4652      	mov	r2, sl
 c04fdf2:	9300      	str	r3, [sp, #0]
 c04fdf4:	4621      	mov	r1, r4
 c04fdf6:	462b      	mov	r3, r5
 c04fdf8:	4640      	mov	r0, r8
 c04fdfa:	f7ff f8db 	bl	c04efb4 <mgf_mask>
 c04fdfe:	4602      	mov	r2, r0
    mbedtls_md_free( &md_ctx );
 c04fe00:	a807      	add	r0, sp, #28
 c04fe02:	9204      	str	r2, [sp, #16]
 c04fe04:	f006 fcb5 	bl	c056772 <mbedtls_md_free>
    if( ret != 0 )
 c04fe08:	9a04      	ldr	r2, [sp, #16]
 c04fe0a:	2a00      	cmp	r2, #0
 c04fe0c:	d18b      	bne.n	c04fd26 <mbedtls_rsa_rsaes_oaep_encrypt+0x22>
            : mbedtls_rsa_private( ctx, f_rng, p_rng, output, output ) );
 c04fe0e:	9b03      	ldr	r3, [sp, #12]
 c04fe10:	b933      	cbnz	r3, c04fe20 <mbedtls_rsa_rsaes_oaep_encrypt+0x11c>
            ? mbedtls_rsa_public(  ctx, output, output )
 c04fe12:	463a      	mov	r2, r7
 c04fe14:	4639      	mov	r1, r7
 c04fe16:	4630      	mov	r0, r6
 c04fe18:	f7ff fca6 	bl	c04f768 <mbedtls_rsa_public>
            : mbedtls_rsa_private( ctx, f_rng, p_rng, output, output ) );
 c04fe1c:	4602      	mov	r2, r0
 c04fe1e:	e782      	b.n	c04fd26 <mbedtls_rsa_rsaes_oaep_encrypt+0x22>
 c04fe20:	463b      	mov	r3, r7
 c04fe22:	4649      	mov	r1, r9
 c04fe24:	4630      	mov	r0, r6
 c04fe26:	9a02      	ldr	r2, [sp, #8]
 c04fe28:	9700      	str	r7, [sp, #0]
 c04fe2a:	f7ff fd4f 	bl	c04f8cc <mbedtls_rsa_private>
 c04fe2e:	e7f5      	b.n	c04fe1c <mbedtls_rsa_rsaes_oaep_encrypt+0x118>
 c04fe30:	ffffbf80 	.word	0xffffbf80

0c04fe34 <mbedtls_rsa_rsaes_pkcs1_v15_encrypt>:
{
 c04fe34:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c04fe38:	4698      	mov	r8, r3
 c04fe3a:	e9dd 930c 	ldrd	r9, r3, [sp, #48]	@ 0x30
    if( mode == MBEDTLS_RSA_PRIVATE && ctx->padding != MBEDTLS_RSA_PKCS_V15 )
 c04fe3e:	f1b8 0f01 	cmp.w	r8, #1
{
 c04fe42:	4606      	mov	r6, r0
 c04fe44:	460f      	mov	r7, r1
 c04fe46:	4692      	mov	sl, r2
 c04fe48:	9c0e      	ldr	r4, [sp, #56]	@ 0x38
 c04fe4a:	9300      	str	r3, [sp, #0]
    if( mode == MBEDTLS_RSA_PRIVATE && ctx->padding != MBEDTLS_RSA_PKCS_V15 )
 c04fe4c:	d106      	bne.n	c04fe5c <mbedtls_rsa_rsaes_pkcs1_v15_encrypt+0x28>
 c04fe4e:	f8d0 30b0 	ldr.w	r3, [r0, #176]	@ 0xb0
 c04fe52:	b11b      	cbz	r3, c04fe5c <mbedtls_rsa_rsaes_pkcs1_v15_encrypt+0x28>
        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
 c04fe54:	482e      	ldr	r0, [pc, #184]	@ (c04ff10 <mbedtls_rsa_rsaes_pkcs1_v15_encrypt+0xdc>)
}
 c04fe56:	b003      	add	sp, #12
 c04fe58:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if( ilen + 11 < ilen || olen < ilen + 11 )
 c04fe5c:	f119 0f0c 	cmn.w	r9, #12
    olen = ctx->len;
 c04fe60:	6875      	ldr	r5, [r6, #4]
    if( ilen + 11 < ilen || olen < ilen + 11 )
 c04fe62:	d8f7      	bhi.n	c04fe54 <mbedtls_rsa_rsaes_pkcs1_v15_encrypt+0x20>
 c04fe64:	f109 030b 	add.w	r3, r9, #11
 c04fe68:	42ab      	cmp	r3, r5
 c04fe6a:	d8f3      	bhi.n	c04fe54 <mbedtls_rsa_rsaes_pkcs1_v15_encrypt+0x20>
    *p++ = 0;
 c04fe6c:	2300      	movs	r3, #0
    nb_pad = olen - 3 - ilen;
 c04fe6e:	eba5 0509 	sub.w	r5, r5, r9
 c04fe72:	3d03      	subs	r5, #3
    *p++ = 0;
 c04fe74:	7023      	strb	r3, [r4, #0]
    if( mode == MBEDTLS_RSA_PUBLIC )
 c04fe76:	f1b8 0f00 	cmp.w	r8, #0
 c04fe7a:	d134      	bne.n	c04fee6 <mbedtls_rsa_rsaes_pkcs1_v15_encrypt+0xb2>
        if( f_rng == NULL )
 c04fe7c:	2f00      	cmp	r7, #0
 c04fe7e:	d0e9      	beq.n	c04fe54 <mbedtls_rsa_rsaes_pkcs1_v15_encrypt+0x20>
        *p++ = MBEDTLS_RSA_CRYPT;
 c04fe80:	2302      	movs	r3, #2
 c04fe82:	441d      	add	r5, r3
 c04fe84:	f104 0b02 	add.w	fp, r4, #2
 c04fe88:	7063      	strb	r3, [r4, #1]
        while( nb_pad-- > 0 )
 c04fe8a:	4425      	add	r5, r4
 c04fe8c:	45ab      	cmp	fp, r5
 c04fe8e:	d114      	bne.n	c04feba <mbedtls_rsa_rsaes_pkcs1_v15_encrypt+0x86>
    *p++ = 0;
 c04fe90:	2300      	movs	r3, #0
 c04fe92:	702b      	strb	r3, [r5, #0]
    if( ilen != 0 )
 c04fe94:	f1b9 0f00 	cmp.w	r9, #0
 c04fe98:	d004      	beq.n	c04fea4 <mbedtls_rsa_rsaes_pkcs1_v15_encrypt+0x70>
        memcpy( p, input, ilen );
 c04fe9a:	464a      	mov	r2, r9
 c04fe9c:	9900      	ldr	r1, [sp, #0]
 c04fe9e:	1c68      	adds	r0, r5, #1
 c04fea0:	f00b fbd4 	bl	c05b64c <memcpy>
            : mbedtls_rsa_private( ctx, f_rng, p_rng, output, output ) );
 c04fea4:	f1b8 0f00 	cmp.w	r8, #0
 c04fea8:	d127      	bne.n	c04fefa <mbedtls_rsa_rsaes_pkcs1_v15_encrypt+0xc6>
            ? mbedtls_rsa_public(  ctx, output, output )
 c04feaa:	4622      	mov	r2, r4
 c04feac:	4621      	mov	r1, r4
 c04feae:	4630      	mov	r0, r6
}
 c04feb0:	b003      	add	sp, #12
 c04feb2:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
            ? mbedtls_rsa_public(  ctx, output, output )
 c04feb6:	f7ff bc57 	b.w	c04f768 <mbedtls_rsa_public>
 c04feba:	2364      	movs	r3, #100	@ 0x64
                ret = f_rng( p_rng, p, 1 );
 c04febc:	2201      	movs	r2, #1
 c04febe:	4659      	mov	r1, fp
 c04fec0:	4650      	mov	r0, sl
 c04fec2:	9301      	str	r3, [sp, #4]
 c04fec4:	47b8      	blx	r7
            } while( *p == 0 && --rng_dl && ret == 0 );
 c04fec6:	f89b 2000 	ldrb.w	r2, [fp]
 c04feca:	b93a      	cbnz	r2, c04fedc <mbedtls_rsa_rsaes_pkcs1_v15_encrypt+0xa8>
 c04fecc:	9b01      	ldr	r3, [sp, #4]
 c04fece:	3b01      	subs	r3, #1
 c04fed0:	d001      	beq.n	c04fed6 <mbedtls_rsa_rsaes_pkcs1_v15_encrypt+0xa2>
 c04fed2:	2800      	cmp	r0, #0
 c04fed4:	d0f2      	beq.n	c04febc <mbedtls_rsa_rsaes_pkcs1_v15_encrypt+0x88>
 c04fed6:	f5a0 4089 	sub.w	r0, r0, #17536	@ 0x4480
                return( MBEDTLS_ERROR_ADD( MBEDTLS_ERR_RSA_RNG_FAILED, ret ) );
 c04feda:	e7bc      	b.n	c04fe56 <mbedtls_rsa_rsaes_pkcs1_v15_encrypt+0x22>
            if( rng_dl == 0 || ret != 0 )
 c04fedc:	2800      	cmp	r0, #0
 c04fede:	d1fa      	bne.n	c04fed6 <mbedtls_rsa_rsaes_pkcs1_v15_encrypt+0xa2>
            p++;
 c04fee0:	f10b 0b01 	add.w	fp, fp, #1
 c04fee4:	e7d2      	b.n	c04fe8c <mbedtls_rsa_rsaes_pkcs1_v15_encrypt+0x58>
        *p++ = MBEDTLS_RSA_SIGN;
 c04fee6:	2201      	movs	r2, #1
 c04fee8:	1ca3      	adds	r3, r4, #2
 c04feea:	7062      	strb	r2, [r4, #1]
            *p++ = 0xFF;
 c04feec:	21ff      	movs	r1, #255	@ 0xff
 c04feee:	462a      	mov	r2, r5
 c04fef0:	4618      	mov	r0, r3
 c04fef2:	f00b fc1c 	bl	c05b72e <memset>
 c04fef6:	4405      	add	r5, r0
 c04fef8:	e7ca      	b.n	c04fe90 <mbedtls_rsa_rsaes_pkcs1_v15_encrypt+0x5c>
            : mbedtls_rsa_private( ctx, f_rng, p_rng, output, output ) );
 c04fefa:	4623      	mov	r3, r4
 c04fefc:	4652      	mov	r2, sl
 c04fefe:	4639      	mov	r1, r7
 c04ff00:	4630      	mov	r0, r6
 c04ff02:	940c      	str	r4, [sp, #48]	@ 0x30
}
 c04ff04:	b003      	add	sp, #12
 c04ff06:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
            : mbedtls_rsa_private( ctx, f_rng, p_rng, output, output ) );
 c04ff0a:	f7ff bcdf 	b.w	c04f8cc <mbedtls_rsa_private>
 c04ff0e:	bf00      	nop
 c04ff10:	ffffbf80 	.word	0xffffbf80

0c04ff14 <mbedtls_rsa_pkcs1_encrypt>:
{
 c04ff14:	b5f0      	push	{r4, r5, r6, r7, lr}
    switch( ctx->padding )
 c04ff16:	f8d0 70b0 	ldr.w	r7, [r0, #176]	@ 0xb0
{
 c04ff1a:	b087      	sub	sp, #28
 c04ff1c:	9e0e      	ldr	r6, [sp, #56]	@ 0x38
 c04ff1e:	e9dd 450c 	ldrd	r4, r5, [sp, #48]	@ 0x30
    switch( ctx->padding )
 c04ff22:	b127      	cbz	r7, c04ff2e <mbedtls_rsa_pkcs1_encrypt+0x1a>
 c04ff24:	2f01      	cmp	r7, #1
 c04ff26:	d00a      	beq.n	c04ff3e <mbedtls_rsa_pkcs1_encrypt+0x2a>
 c04ff28:	4809      	ldr	r0, [pc, #36]	@ (c04ff50 <mbedtls_rsa_pkcs1_encrypt+0x3c>)
}
 c04ff2a:	b007      	add	sp, #28
 c04ff2c:	bdf0      	pop	{r4, r5, r6, r7, pc}
            return mbedtls_rsa_rsaes_pkcs1_v15_encrypt( ctx, f_rng, p_rng, mode, ilen,
 c04ff2e:	e9cd 560d 	strd	r5, r6, [sp, #52]	@ 0x34
 c04ff32:	940c      	str	r4, [sp, #48]	@ 0x30
}
 c04ff34:	b007      	add	sp, #28
 c04ff36:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
            return mbedtls_rsa_rsaes_pkcs1_v15_encrypt( ctx, f_rng, p_rng, mode, ilen,
 c04ff3a:	f7ff bf7b 	b.w	c04fe34 <mbedtls_rsa_rsaes_pkcs1_v15_encrypt>
            return mbedtls_rsa_rsaes_oaep_encrypt( ctx, f_rng, p_rng, mode, NULL, 0,
 c04ff3e:	9402      	str	r4, [sp, #8]
 c04ff40:	2400      	movs	r4, #0
 c04ff42:	e9cd 5603 	strd	r5, r6, [sp, #12]
 c04ff46:	e9cd 4400 	strd	r4, r4, [sp]
 c04ff4a:	f7ff fedb 	bl	c04fd04 <mbedtls_rsa_rsaes_oaep_encrypt>
 c04ff4e:	e7ec      	b.n	c04ff2a <mbedtls_rsa_pkcs1_encrypt+0x16>
 c04ff50:	ffffbf00 	.word	0xffffbf00

0c04ff54 <mbedtls_rsa_rsaes_oaep_decrypt>:
{
 c04ff54:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    if( mode == MBEDTLS_RSA_PRIVATE && ctx->padding != MBEDTLS_RSA_PKCS_V21 )
 c04ff58:	2b01      	cmp	r3, #1
{
 c04ff5a:	f2ad 4d64 	subw	sp, sp, #1124	@ 0x464
 c04ff5e:	4606      	mov	r6, r0
 c04ff60:	469b      	mov	fp, r3
 c04ff62:	e9cd 1202 	strd	r1, r2, [sp, #8]
    if( mode == MBEDTLS_RSA_PRIVATE && ctx->padding != MBEDTLS_RSA_PKCS_V21 )
 c04ff66:	d109      	bne.n	c04ff7c <mbedtls_rsa_rsaes_oaep_decrypt+0x28>
 c04ff68:	f8d0 30b0 	ldr.w	r3, [r0, #176]	@ 0xb0
 c04ff6c:	2b01      	cmp	r3, #1
 c04ff6e:	d005      	beq.n	c04ff7c <mbedtls_rsa_rsaes_oaep_decrypt+0x28>
        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
 c04ff70:	4e5a      	ldr	r6, [pc, #360]	@ (c0500dc <mbedtls_rsa_rsaes_oaep_decrypt+0x188>)
}
 c04ff72:	4630      	mov	r0, r6
 c04ff74:	f20d 4d64 	addw	sp, sp, #1124	@ 0x464
 c04ff78:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    ilen = ctx->len;
 c04ff7c:	6874      	ldr	r4, [r6, #4]
    if( ilen < 16 || ilen > sizeof( buf ) )
 c04ff7e:	f1a4 0310 	sub.w	r3, r4, #16
 c04ff82:	f5b3 7f7c 	cmp.w	r3, #1008	@ 0x3f0
 c04ff86:	d8f3      	bhi.n	c04ff70 <mbedtls_rsa_rsaes_oaep_decrypt+0x1c>
    md_info = mbedtls_md_info_from_type( (mbedtls_md_type_t) ctx->hash_id );
 c04ff88:	f896 00b4 	ldrb.w	r0, [r6, #180]	@ 0xb4
 c04ff8c:	f006 fbe0 	bl	c056750 <mbedtls_md_info_from_type>
    if( md_info == NULL )
 c04ff90:	4681      	mov	r9, r0
 c04ff92:	2800      	cmp	r0, #0
 c04ff94:	d0ec      	beq.n	c04ff70 <mbedtls_rsa_rsaes_oaep_decrypt+0x1c>
    hlen = mbedtls_md_get_size( md_info );
 c04ff96:	f006 fd67 	bl	c056a68 <mbedtls_md_get_size>
    if( 2 * hlen + 2 > ilen )
 c04ff9a:	1c47      	adds	r7, r0, #1
 c04ff9c:	ebb4 0f47 	cmp.w	r4, r7, lsl #1
    hlen = mbedtls_md_get_size( md_info );
 c04ffa0:	4605      	mov	r5, r0
    if( 2 * hlen + 2 > ilen )
 c04ffa2:	ea4f 0847 	mov.w	r8, r7, lsl #1
 c04ffa6:	d3e3      	bcc.n	c04ff70 <mbedtls_rsa_rsaes_oaep_decrypt+0x1c>
    ret = ( mode == MBEDTLS_RSA_PUBLIC )
 c04ffa8:	f10d 0a60 	add.w	sl, sp, #96	@ 0x60
          : mbedtls_rsa_private( ctx, f_rng, p_rng, input, buf );
 c04ffac:	f1bb 0f00 	cmp.w	fp, #0
 c04ffb0:	d11e      	bne.n	c04fff0 <mbedtls_rsa_rsaes_oaep_decrypt+0x9c>
          ? mbedtls_rsa_public(  ctx, input, buf )
 c04ffb2:	4652      	mov	r2, sl
 c04ffb4:	4630      	mov	r0, r6
 c04ffb6:	f8dd 1494 	ldr.w	r1, [sp, #1172]	@ 0x494
 c04ffba:	f7ff fbd5 	bl	c04f768 <mbedtls_rsa_public>
          : mbedtls_rsa_private( ctx, f_rng, p_rng, input, buf );
 c04ffbe:	4606      	mov	r6, r0
    if( ret != 0 )
 c04ffc0:	b960      	cbnz	r0, c04ffdc <mbedtls_rsa_rsaes_oaep_decrypt+0x88>
    mbedtls_md_init( &md_ctx );
 c04ffc2:	a805      	add	r0, sp, #20
 c04ffc4:	f006 fbd0 	bl	c056768 <mbedtls_md_init>
    if( ( ret = mbedtls_md_setup( &md_ctx, md_info, 0 ) ) != 0 )
 c04ffc8:	4632      	mov	r2, r6
 c04ffca:	4649      	mov	r1, r9
 c04ffcc:	a805      	add	r0, sp, #20
 c04ffce:	f006 fbf9 	bl	c0567c4 <mbedtls_md_setup>
 c04ffd2:	4606      	mov	r6, r0
 c04ffd4:	b1b0      	cbz	r0, c050004 <mbedtls_rsa_rsaes_oaep_decrypt+0xb0>
        mbedtls_md_free( &md_ctx );
 c04ffd6:	a805      	add	r0, sp, #20
 c04ffd8:	f006 fbcb 	bl	c056772 <mbedtls_md_free>
    mbedtls_platform_zeroize( buf, sizeof( buf ) );
 c04ffdc:	a818      	add	r0, sp, #96	@ 0x60
 c04ffde:	f44f 6180 	mov.w	r1, #1024	@ 0x400
 c04ffe2:	f7eb f9f5 	bl	c03b3d0 <mbedtls_platform_zeroize>
    mbedtls_platform_zeroize( lhash, sizeof( lhash ) );
 c04ffe6:	2140      	movs	r1, #64	@ 0x40
 c04ffe8:	a808      	add	r0, sp, #32
 c04ffea:	f7eb f9f1 	bl	c03b3d0 <mbedtls_platform_zeroize>
    return( ret );
 c04ffee:	e7c0      	b.n	c04ff72 <mbedtls_rsa_rsaes_oaep_decrypt+0x1e>
          : mbedtls_rsa_private( ctx, f_rng, p_rng, input, buf );
 c04fff0:	4630      	mov	r0, r6
 c04fff2:	e9dd 1202 	ldrd	r1, r2, [sp, #8]
 c04fff6:	f8dd 3494 	ldr.w	r3, [sp, #1172]	@ 0x494
 c04fffa:	f8cd a000 	str.w	sl, [sp]
 c04fffe:	f7ff fc65 	bl	c04f8cc <mbedtls_rsa_private>
 c050002:	e7dc      	b.n	c04ffbe <mbedtls_rsa_rsaes_oaep_decrypt+0x6a>
    if( ( ret = mgf_mask( buf + 1, hlen, buf + hlen + 1, ilen - hlen - 1,
 c050004:	f104 3bff 	add.w	fp, r4, #4294967295	@ 0xffffffff
 c050008:	ab05      	add	r3, sp, #20
 c05000a:	4457      	add	r7, sl
 c05000c:	ebab 0b05 	sub.w	fp, fp, r5
 c050010:	9300      	str	r3, [sp, #0]
 c050012:	463a      	mov	r2, r7
 c050014:	465b      	mov	r3, fp
 c050016:	4629      	mov	r1, r5
 c050018:	f10d 0061 	add.w	r0, sp, #97	@ 0x61
 c05001c:	f7fe ffca 	bl	c04efb4 <mgf_mask>
 c050020:	4606      	mov	r6, r0
 c050022:	2800      	cmp	r0, #0
 c050024:	d1d7      	bne.n	c04ffd6 <mbedtls_rsa_rsaes_oaep_decrypt+0x82>
        ( ret = mgf_mask( buf + hlen + 1, ilen - hlen - 1, buf + 1, hlen,
 c050026:	ab05      	add	r3, sp, #20
 c050028:	9300      	str	r3, [sp, #0]
 c05002a:	4659      	mov	r1, fp
 c05002c:	462b      	mov	r3, r5
 c05002e:	4638      	mov	r0, r7
 c050030:	f10d 0261 	add.w	r2, sp, #97	@ 0x61
 c050034:	f7fe ffbe 	bl	c04efb4 <mgf_mask>
                          &md_ctx ) ) != 0 ||
 c050038:	4606      	mov	r6, r0
 c05003a:	2800      	cmp	r0, #0
 c05003c:	d1cb      	bne.n	c04ffd6 <mbedtls_rsa_rsaes_oaep_decrypt+0x82>
    mbedtls_md_free( &md_ctx );
 c05003e:	a805      	add	r0, sp, #20
 c050040:	f006 fb97 	bl	c056772 <mbedtls_md_free>
    if( ( ret = mbedtls_md( md_info, label, label_len, lhash ) ) != 0 )
 c050044:	4648      	mov	r0, r9
 c050046:	f8dd 248c 	ldr.w	r2, [sp, #1164]	@ 0x48c
 c05004a:	f8dd 1488 	ldr.w	r1, [sp, #1160]	@ 0x488
 c05004e:	ab08      	add	r3, sp, #32
 c050050:	f006 fc3c 	bl	c0568cc <mbedtls_md>
 c050054:	4606      	mov	r6, r0
 c050056:	2800      	cmp	r0, #0
 c050058:	d1c0      	bne.n	c04ffdc <mbedtls_rsa_rsaes_oaep_decrypt+0x88>
    p += hlen; /* Skip seed */
 c05005a:	f10d 0361 	add.w	r3, sp, #97	@ 0x61
    bad |= *p++; /* First byte must be 0 */
 c05005e:	f89a 0000 	ldrb.w	r0, [sl]
    p += hlen; /* Skip seed */
 c050062:	1959      	adds	r1, r3, r5
    for( i = 0; i < hlen; i++ )
 c050064:	aa08      	add	r2, sp, #32
 c050066:	eb03 0345 	add.w	r3, r3, r5, lsl #1
 c05006a:	4299      	cmp	r1, r3
 c05006c:	d11f      	bne.n	c0500ae <mbedtls_rsa_rsaes_oaep_decrypt+0x15a>
    pad_done = 0;
 c05006e:	2100      	movs	r1, #0
 c050070:	461f      	mov	r7, r3
    pad_len = 0;
 c050072:	460d      	mov	r5, r1
    for( i = 0; i < ilen - 2 * hlen - 2; i++ )
 c050074:	eba4 0808 	sub.w	r8, r4, r8
 c050078:	4498      	add	r8, r3
 c05007a:	4547      	cmp	r7, r8
 c05007c:	d11e      	bne.n	c0500bc <mbedtls_rsa_rsaes_oaep_decrypt+0x168>
    p += pad_len;
 c05007e:	1959      	adds	r1, r3, r5
    bad |= *p++ ^ 0x01;
 c050080:	5d5b      	ldrb	r3, [r3, r5]
 c050082:	f083 0301 	eor.w	r3, r3, #1
    if( bad != 0 )
 c050086:	4303      	orrs	r3, r0
 c050088:	d123      	bne.n	c0500d2 <mbedtls_rsa_rsaes_oaep_decrypt+0x17e>
    bad |= *p++ ^ 0x01;
 c05008a:	3101      	adds	r1, #1
    if( ilen - ( p - buf ) > output_max_len )
 c05008c:	ab18      	add	r3, sp, #96	@ 0x60
 c05008e:	1acb      	subs	r3, r1, r3
 c050090:	1ae2      	subs	r2, r4, r3
 c050092:	f8dd 349c 	ldr.w	r3, [sp, #1180]	@ 0x49c
 c050096:	429a      	cmp	r2, r3
 c050098:	d81d      	bhi.n	c0500d6 <mbedtls_rsa_rsaes_oaep_decrypt+0x182>
    *olen = ilen - (p - buf);
 c05009a:	f8dd 3490 	ldr.w	r3, [sp, #1168]	@ 0x490
 c05009e:	601a      	str	r2, [r3, #0]
    if( *olen != 0 )
 c0500a0:	2a00      	cmp	r2, #0
 c0500a2:	d09b      	beq.n	c04ffdc <mbedtls_rsa_rsaes_oaep_decrypt+0x88>
        memcpy( output, p, *olen );
 c0500a4:	f8dd 0498 	ldr.w	r0, [sp, #1176]	@ 0x498
 c0500a8:	f00b fad0 	bl	c05b64c <memcpy>
 c0500ac:	e796      	b.n	c04ffdc <mbedtls_rsa_rsaes_oaep_decrypt+0x88>
        bad |= lhash[i] ^ *p++;
 c0500ae:	f812 5b01 	ldrb.w	r5, [r2], #1
 c0500b2:	f811 7b01 	ldrb.w	r7, [r1], #1
 c0500b6:	407d      	eors	r5, r7
 c0500b8:	4328      	orrs	r0, r5
    for( i = 0; i < hlen; i++ )
 c0500ba:	e7d6      	b.n	c05006a <mbedtls_rsa_rsaes_oaep_decrypt+0x116>
        pad_done |= p[i];
 c0500bc:	f817 2b01 	ldrb.w	r2, [r7], #1
 c0500c0:	4311      	orrs	r1, r2
        pad_len += ((pad_done | (unsigned char)-pad_done) >> 7) ^ 1;
 c0500c2:	424a      	negs	r2, r1
 c0500c4:	430a      	orrs	r2, r1
 c0500c6:	f3c2 12c0 	ubfx	r2, r2, #7, #1
 c0500ca:	f082 0201 	eor.w	r2, r2, #1
 c0500ce:	4415      	add	r5, r2
    for( i = 0; i < ilen - 2 * hlen - 2; i++ )
 c0500d0:	e7d3      	b.n	c05007a <mbedtls_rsa_rsaes_oaep_decrypt+0x126>
        ret = MBEDTLS_ERR_RSA_INVALID_PADDING;
 c0500d2:	4e03      	ldr	r6, [pc, #12]	@ (c0500e0 <mbedtls_rsa_rsaes_oaep_decrypt+0x18c>)
 c0500d4:	e782      	b.n	c04ffdc <mbedtls_rsa_rsaes_oaep_decrypt+0x88>
        ret = MBEDTLS_ERR_RSA_OUTPUT_TOO_LARGE;
 c0500d6:	4e03      	ldr	r6, [pc, #12]	@ (c0500e4 <mbedtls_rsa_rsaes_oaep_decrypt+0x190>)
 c0500d8:	e780      	b.n	c04ffdc <mbedtls_rsa_rsaes_oaep_decrypt+0x88>
 c0500da:	bf00      	nop
 c0500dc:	ffffbf80 	.word	0xffffbf80
 c0500e0:	ffffbf00 	.word	0xffffbf00
 c0500e4:	ffffbc00 	.word	0xffffbc00

0c0500e8 <mbedtls_rsa_rsaes_pkcs1_v15_decrypt>:
{
 c0500e8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c0500ec:	461e      	mov	r6, r3
 c0500ee:	f2ad 4d0c 	subw	sp, sp, #1036	@ 0x40c
    if( mode == MBEDTLS_RSA_PRIVATE && ctx->padding != MBEDTLS_RSA_PKCS_V15 )
 c0500f2:	2e01      	cmp	r6, #1
{
 c0500f4:	f8dd 3434 	ldr.w	r3, [sp, #1076]	@ 0x434
    ilen = ctx->len;
 c0500f8:	6847      	ldr	r7, [r0, #4]
    if( mode == MBEDTLS_RSA_PRIVATE && ctx->padding != MBEDTLS_RSA_PKCS_V15 )
 c0500fa:	d104      	bne.n	c050106 <mbedtls_rsa_rsaes_pkcs1_v15_decrypt+0x1e>
 c0500fc:	f8d0 40b0 	ldr.w	r4, [r0, #176]	@ 0xb0
 c050100:	2c00      	cmp	r4, #0
 c050102:	f040 80c3 	bne.w	c05028c <mbedtls_rsa_rsaes_pkcs1_v15_decrypt+0x1a4>
    if( ilen < 16 || ilen > sizeof( buf ) )
 c050106:	f1a7 0410 	sub.w	r4, r7, #16
 c05010a:	f5b4 7f7c 	cmp.w	r4, #1008	@ 0x3f0
 c05010e:	f200 80bd 	bhi.w	c05028c <mbedtls_rsa_rsaes_pkcs1_v15_decrypt+0x1a4>
    ret = ( mode == MBEDTLS_RSA_PUBLIC )
 c050112:	ad02      	add	r5, sp, #8
          : mbedtls_rsa_private( ctx, f_rng, p_rng, input, buf );
 c050114:	2e00      	cmp	r6, #0
 c050116:	d173      	bne.n	c050200 <mbedtls_rsa_rsaes_pkcs1_v15_decrypt+0x118>
          ? mbedtls_rsa_public(  ctx, input, buf )
 c050118:	462a      	mov	r2, r5
 c05011a:	4619      	mov	r1, r3
 c05011c:	f7ff fb24 	bl	c04f768 <mbedtls_rsa_public>
          : mbedtls_rsa_private( ctx, f_rng, p_rng, input, buf );
 c050120:	4604      	mov	r4, r0
    if( ret != 0 )
 c050122:	2800      	cmp	r0, #0
 c050124:	d162      	bne.n	c0501ec <mbedtls_rsa_rsaes_pkcs1_v15_decrypt+0x104>
    if( mode == MBEDTLS_RSA_PRIVATE )
 c050126:	2e01      	cmp	r6, #1
    bad |= buf[0];
 c050128:	782b      	ldrb	r3, [r5, #0]
        bad |= buf[1] ^ MBEDTLS_RSA_CRYPT;
 c05012a:	786a      	ldrb	r2, [r5, #1]
    if( mode == MBEDTLS_RSA_PRIVATE )
 c05012c:	d16c      	bne.n	c050208 <mbedtls_rsa_rsaes_pkcs1_v15_decrypt+0x120>
    size_t pad_count = 0;
 c05012e:	4601      	mov	r1, r0
        for( i = 2; i < ilen; i++ )
 c050130:	2002      	movs	r0, #2
        bad |= buf[1] ^ MBEDTLS_RSA_CRYPT;
 c050132:	f082 0202 	eor.w	r2, r2, #2
 c050136:	4313      	orrs	r3, r2
            pad_done  |= ((buf[i] | (unsigned char)-buf[i]) >> 7) ^ 1;
 c050138:	5c2a      	ldrb	r2, [r5, r0]
        for( i = 2; i < ilen; i++ )
 c05013a:	3001      	adds	r0, #1
            pad_done  |= ((buf[i] | (unsigned char)-buf[i]) >> 7) ^ 1;
 c05013c:	4256      	negs	r6, r2
 c05013e:	4332      	orrs	r2, r6
 c050140:	f3c2 12c0 	ubfx	r2, r2, #7, #1
 c050144:	f082 0201 	eor.w	r2, r2, #1
 c050148:	4314      	orrs	r4, r2
            pad_count += ((pad_done | (unsigned char)-pad_done) >> 7) ^ 1;
 c05014a:	4262      	negs	r2, r4
 c05014c:	4322      	orrs	r2, r4
 c05014e:	f3c2 12c0 	ubfx	r2, r2, #7, #1
 c050152:	f082 0201 	eor.w	r2, r2, #1
        for( i = 2; i < ilen; i++ )
 c050156:	4287      	cmp	r7, r0
            pad_count += ((pad_done | (unsigned char)-pad_done) >> 7) ^ 1;
 c050158:	4411      	add	r1, r2
        for( i = 2; i < ilen; i++ )
 c05015a:	d1ed      	bne.n	c050138 <mbedtls_rsa_rsaes_pkcs1_v15_decrypt+0x50>
    plaintext_max_size = ( output_max_len > ilen - 11 ?
 c05015c:	f8dd 043c 	ldr.w	r0, [sp, #1084]	@ 0x43c
 c050160:	f1a7 020b 	sub.w	r2, r7, #11
 c050164:	4282      	cmp	r2, r0
 c050166:	bf28      	it	cs
 c050168:	4602      	movcs	r2, r0
    return( ( max - size ) >> ( sizeof( size_t ) * 8 - 1 ) );
 c05016a:	f1a1 0008 	sub.w	r0, r1, #8
 c05016e:	ea43 73d0 	orr.w	r3, r3, r0, lsr #31
    bad |= size_greater_than( 8, pad_count );
 c050172:	2c00      	cmp	r4, #0
 c050174:	bf08      	it	eq
 c050176:	f043 0301 	orreq.w	r3, r3, #1
                             (unsigned) ( ilen - pad_count - 3 ) );
 c05017a:	1efc      	subs	r4, r7, #3
 c05017c:	1a64      	subs	r4, r4, r1
    return( - ( ( value | - value ) >> ( sizeof( value ) * 8 - 1 ) ) );
 c05017e:	4259      	negs	r1, r3
 c050180:	4319      	orrs	r1, r3
    return( ( mask & if1 ) | (~mask & if0 ) );
 c050182:	ea84 0002 	eor.w	r0, r4, r2
 c050186:	ea00 70e1 	and.w	r0, r0, r1, asr #31
 c05018a:	4060      	eors	r0, r4
    return( ( max - size ) >> ( sizeof( size_t ) * 8 - 1 ) );
 c05018c:	1a16      	subs	r6, r2, r0
    return( - ( ( value | - value ) >> ( sizeof( value ) * 8 - 1 ) ) );
 c05018e:	ea4f 7ce6 	mov.w	ip, r6, asr #31
    return( ( mask & if1 ) | (~mask & if0 ) );
 c050192:	f40c 4e88 	and.w	lr, ip, #17408	@ 0x4400
    ret = - (int) if_int( bad, - MBEDTLS_ERR_RSA_INVALID_PADDING,
 c050196:	f48e 4482 	eor.w	r4, lr, #16640	@ 0x4100
 c05019a:	ea04 74e1 	and.w	r4, r4, r1, asr #31
    bad = all_or_nothing_int( bad | output_too_large );
 c05019e:	ea43 71d6 	orr.w	r1, r3, r6, lsr #31
    return( - ( ( value | - value ) >> ( sizeof( value ) * 8 - 1 ) ) );
 c0501a2:	424b      	negs	r3, r1
 c0501a4:	430b      	orrs	r3, r1
 c0501a6:	17db      	asrs	r3, r3, #31
    for( i = 11; i < ilen; i++ )
 c0501a8:	210b      	movs	r1, #11
        buf[i] &= ~bad;
 c0501aa:	43db      	mvns	r3, r3
    ret = - (int) if_int( bad, - MBEDTLS_ERR_RSA_INVALID_PADDING,
 c0501ac:	ea84 040e 	eor.w	r4, r4, lr
 c0501b0:	4264      	negs	r4, r4
    for( i = 11; i < ilen; i++ )
 c0501b2:	f10d 0612 	add.w	r6, sp, #18
        buf[i] &= ~bad;
 c0501b6:	f816 ef01 	ldrb.w	lr, [r6, #1]!
    for( i = 11; i < ilen; i++ )
 c0501ba:	3101      	adds	r1, #1
        buf[i] &= ~bad;
 c0501bc:	ea0e 0e03 	and.w	lr, lr, r3
    for( i = 11; i < ilen; i++ )
 c0501c0:	428f      	cmp	r7, r1
        buf[i] &= ~bad;
 c0501c2:	f886 e000 	strb.w	lr, [r6]
    for( i = 11; i < ilen; i++ )
 c0501c6:	d1f6      	bne.n	c0501b6 <mbedtls_rsa_rsaes_pkcs1_v15_decrypt+0xce>
    return( ( mask & if1 ) | (~mask & if0 ) );
 c0501c8:	ea82 0600 	eor.w	r6, r2, r0
 c0501cc:	ea06 060c 	and.w	r6, r6, ip
    mem_move_to_left( buf + ilen - plaintext_max_size,
 c0501d0:	1ab9      	subs	r1, r7, r2
    return( ( mask & if1 ) | (~mask & if0 ) );
 c0501d2:	4046      	eors	r6, r0
    mem_move_to_left( buf + ilen - plaintext_max_size,
 c0501d4:	4429      	add	r1, r5
    if( total == 0 )
 c0501d6:	bb8a      	cbnz	r2, c05023c <mbedtls_rsa_rsaes_pkcs1_v15_decrypt+0x154>
    if( output_max_len != 0 )
 c0501d8:	f8dd 343c 	ldr.w	r3, [sp, #1084]	@ 0x43c
 c0501dc:	b11b      	cbz	r3, c0501e6 <mbedtls_rsa_rsaes_pkcs1_v15_decrypt+0xfe>
        memcpy( output, buf + ilen - plaintext_max_size, plaintext_max_size );
 c0501de:	f8dd 0438 	ldr.w	r0, [sp, #1080]	@ 0x438
 c0501e2:	f00b fa33 	bl	c05b64c <memcpy>
    *olen = plaintext_size;
 c0501e6:	f8dd 3430 	ldr.w	r3, [sp, #1072]	@ 0x430
 c0501ea:	601e      	str	r6, [r3, #0]
    mbedtls_platform_zeroize( buf, sizeof( buf ) );
 c0501ec:	f44f 6180 	mov.w	r1, #1024	@ 0x400
 c0501f0:	4628      	mov	r0, r5
 c0501f2:	f7eb f8ed 	bl	c03b3d0 <mbedtls_platform_zeroize>
}
 c0501f6:	4620      	mov	r0, r4
 c0501f8:	f20d 4d0c 	addw	sp, sp, #1036	@ 0x40c
 c0501fc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
          : mbedtls_rsa_private( ctx, f_rng, p_rng, input, buf );
 c050200:	9500      	str	r5, [sp, #0]
 c050202:	f7ff fb63 	bl	c04f8cc <mbedtls_rsa_private>
 c050206:	e78b      	b.n	c050120 <mbedtls_rsa_rsaes_pkcs1_v15_decrypt+0x38>
    size_t pad_count = 0;
 c050208:	4601      	mov	r1, r0
        for( i = 2; i < ilen; i++ )
 c05020a:	2602      	movs	r6, #2
        bad |= buf[1] ^ MBEDTLS_RSA_SIGN;
 c05020c:	f082 0201 	eor.w	r2, r2, #1
 c050210:	4313      	orrs	r3, r2
            pad_done |= if_int( buf[i], 0, 1 );
 c050212:	5daa      	ldrb	r2, [r5, r6]
        for( i = 2; i < ilen; i++ )
 c050214:	3601      	adds	r6, #1
            pad_done |= if_int( buf[i], 0, 1 );
 c050216:	2a00      	cmp	r2, #0
 c050218:	bf08      	it	eq
 c05021a:	f044 0401 	orreq.w	r4, r4, #1
            bad |= if_int( pad_done, 0, buf[i] ^ 0xFF );
 c05021e:	43d2      	mvns	r2, r2
    return( - ( ( value | - value ) >> ( sizeof( value ) * 8 - 1 ) ) );
 c050220:	4260      	negs	r0, r4
 c050222:	4320      	orrs	r0, r4
            pad_count += if_int( pad_done, 0, 1 );
 c050224:	2800      	cmp	r0, #0
 c050226:	bfa8      	it	ge
 c050228:	3101      	addge	r1, #1
            bad |= if_int( pad_done, 0, buf[i] ^ 0xFF );
 c05022a:	b2d2      	uxtb	r2, r2
    return( - ( ( value | - value ) >> ( sizeof( value ) * 8 - 1 ) ) );
 c05022c:	17c0      	asrs	r0, r0, #31
    return( ( mask & if1 ) | (~mask & if0 ) );
 c05022e:	ea22 0200 	bic.w	r2, r2, r0
        for( i = 2; i < ilen; i++ )
 c050232:	42b7      	cmp	r7, r6
            bad |= if_int( pad_done, 0, buf[i] ^ 0xFF );
 c050234:	ea43 0302 	orr.w	r3, r3, r2
        for( i = 2; i < ilen; i++ )
 c050238:	d1eb      	bne.n	c050212 <mbedtls_rsa_rsaes_pkcs1_v15_decrypt+0x12a>
 c05023a:	e78f      	b.n	c05015c <mbedtls_rsa_rsaes_pkcs1_v15_decrypt+0x74>
        for( n = 0; n < total - 1; n++ )
 c05023c:	f102 38ff 	add.w	r8, r2, #4294967295	@ 0xffffffff
 c050240:	f1c6 0c00 	rsb	ip, r6, #0
 c050244:	eba2 0a06 	sub.w	sl, r2, r6
        buf[total-1] = if_int( no_op, buf[total-1], 0 );
 c050248:	eb01 0e08 	add.w	lr, r1, r8
        for( n = 0; n < total - 1; n++ )
 c05024c:	2700      	movs	r7, #0
    return( ( max - size ) >> ( sizeof( size_t ) * 8 - 1 ) );
 c05024e:	ea4f 70dc 	mov.w	r0, ip, lsr #31
    return( - ( ( value | - value ) >> ( sizeof( value ) * 8 - 1 ) ) );
 c050252:	ea40 70ec 	orr.w	r0, r0, ip, asr #31
 c050256:	17c0      	asrs	r0, r0, #31
        for( n = 0; n < total - 1; n++ )
 c050258:	4547      	cmp	r7, r8
 c05025a:	d309      	bcc.n	c050270 <mbedtls_rsa_rsaes_pkcs1_v15_decrypt+0x188>
        buf[total-1] = if_int( no_op, buf[total-1], 0 );
 c05025c:	f89e 3000 	ldrb.w	r3, [lr]
    for( i = 0; i < total; i++ )
 c050260:	f10c 0c01 	add.w	ip, ip, #1
        buf[total-1] = if_int( no_op, buf[total-1], 0 );
 c050264:	4003      	ands	r3, r0
    for( i = 0; i < total; i++ )
 c050266:	45e2      	cmp	sl, ip
        buf[total-1] = if_int( no_op, buf[total-1], 0 );
 c050268:	f88e 3000 	strb.w	r3, [lr]
    for( i = 0; i < total; i++ )
 c05026c:	d1ee      	bne.n	c05024c <mbedtls_rsa_rsaes_pkcs1_v15_decrypt+0x164>
 c05026e:	e7b3      	b.n	c0501d8 <mbedtls_rsa_rsaes_pkcs1_v15_decrypt+0xf0>
            unsigned char current = buf[n];
 c050270:	5dcb      	ldrb	r3, [r1, r7]
 c050272:	eb07 0b01 	add.w	fp, r7, r1
            unsigned char next = buf[n+1];
 c050276:	3701      	adds	r7, #1
 c050278:	f811 9007 	ldrb.w	r9, [r1, r7]
    return( ( mask & if1 ) | (~mask & if0 ) );
 c05027c:	ea83 0309 	eor.w	r3, r3, r9
 c050280:	4003      	ands	r3, r0
            buf[n] = if_int( no_op, current, next );
 c050282:	ea83 0309 	eor.w	r3, r3, r9
 c050286:	f88b 3000 	strb.w	r3, [fp]
        for( n = 0; n < total - 1; n++ )
 c05028a:	e7e5      	b.n	c050258 <mbedtls_rsa_rsaes_pkcs1_v15_decrypt+0x170>
        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
 c05028c:	4c00      	ldr	r4, [pc, #0]	@ (c050290 <mbedtls_rsa_rsaes_pkcs1_v15_decrypt+0x1a8>)
 c05028e:	e7b2      	b.n	c0501f6 <mbedtls_rsa_rsaes_pkcs1_v15_decrypt+0x10e>
 c050290:	ffffbf80 	.word	0xffffbf80

0c050294 <mbedtls_rsa_pkcs1_decrypt>:
{
 c050294:	b5f0      	push	{r4, r5, r6, r7, lr}
    switch( ctx->padding )
 c050296:	f8d0 c0b0 	ldr.w	ip, [r0, #176]	@ 0xb0
{
 c05029a:	b087      	sub	sp, #28
 c05029c:	e9dd 450c 	ldrd	r4, r5, [sp, #48]	@ 0x30
 c0502a0:	e9dd 670e 	ldrd	r6, r7, [sp, #56]	@ 0x38
    switch( ctx->padding )
 c0502a4:	f1bc 0f00 	cmp.w	ip, #0
 c0502a8:	d005      	beq.n	c0502b6 <mbedtls_rsa_pkcs1_decrypt+0x22>
 c0502aa:	f1bc 0f01 	cmp.w	ip, #1
 c0502ae:	d00b      	beq.n	c0502c8 <mbedtls_rsa_pkcs1_decrypt+0x34>
 c0502b0:	480a      	ldr	r0, [pc, #40]	@ (c0502dc <mbedtls_rsa_pkcs1_decrypt+0x48>)
}
 c0502b2:	b007      	add	sp, #28
 c0502b4:	bdf0      	pop	{r4, r5, r6, r7, pc}
            return mbedtls_rsa_rsaes_pkcs1_v15_decrypt( ctx, f_rng, p_rng, mode, olen,
 c0502b6:	e9cd 670e 	strd	r6, r7, [sp, #56]	@ 0x38
 c0502ba:	e9cd 450c 	strd	r4, r5, [sp, #48]	@ 0x30
}
 c0502be:	b007      	add	sp, #28
 c0502c0:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
            return mbedtls_rsa_rsaes_pkcs1_v15_decrypt( ctx, f_rng, p_rng, mode, olen,
 c0502c4:	f7ff bf10 	b.w	c0500e8 <mbedtls_rsa_rsaes_pkcs1_v15_decrypt>
            return mbedtls_rsa_rsaes_oaep_decrypt( ctx, f_rng, p_rng, mode, NULL, 0,
 c0502c8:	e9cd 4502 	strd	r4, r5, [sp, #8]
 c0502cc:	2400      	movs	r4, #0
 c0502ce:	e9cd 6704 	strd	r6, r7, [sp, #16]
 c0502d2:	e9cd 4400 	strd	r4, r4, [sp]
 c0502d6:	f7ff fe3d 	bl	c04ff54 <mbedtls_rsa_rsaes_oaep_decrypt>
 c0502da:	e7ea      	b.n	c0502b2 <mbedtls_rsa_pkcs1_decrypt+0x1e>
 c0502dc:	ffffbf00 	.word	0xffffbf00

0c0502e0 <mbedtls_rsa_rsassa_pss_sign>:
{
 c0502e0:	b510      	push	{r4, lr}
 c0502e2:	b086      	sub	sp, #24
    return rsa_rsassa_pss_sign( ctx, f_rng, p_rng, mode, md_alg,
 c0502e4:	9c0b      	ldr	r4, [sp, #44]	@ 0x2c
 c0502e6:	9404      	str	r4, [sp, #16]
 c0502e8:	f04f 34ff 	mov.w	r4, #4294967295	@ 0xffffffff
 c0502ec:	9403      	str	r4, [sp, #12]
 c0502ee:	9c0a      	ldr	r4, [sp, #40]	@ 0x28
 c0502f0:	9402      	str	r4, [sp, #8]
 c0502f2:	9c09      	ldr	r4, [sp, #36]	@ 0x24
 c0502f4:	9401      	str	r4, [sp, #4]
 c0502f6:	f89d 4020 	ldrb.w	r4, [sp, #32]
 c0502fa:	9400      	str	r4, [sp, #0]
 c0502fc:	f7ff fc2e 	bl	c04fb5c <rsa_rsassa_pss_sign>
}
 c050300:	b006      	add	sp, #24
 c050302:	bd10      	pop	{r4, pc}

0c050304 <mbedtls_rsa_rsassa_pkcs1_v15_sign>:
                               int mode,
                               mbedtls_md_type_t md_alg,
                               unsigned int hashlen,
                               const unsigned char *hash,
                               unsigned char *sig )
{
 c050304:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
    RSA_VALIDATE_RET( ( md_alg  == MBEDTLS_MD_NONE &&
                        hashlen == 0 ) ||
                      hash != NULL );
    RSA_VALIDATE_RET( sig != NULL );

    if( mode == MBEDTLS_RSA_PRIVATE && ctx->padding != MBEDTLS_RSA_PKCS_V15 )
 c050308:	2b01      	cmp	r3, #1
{
 c05030a:	4605      	mov	r5, r0
 c05030c:	4689      	mov	r9, r1
 c05030e:	4692      	mov	sl, r2
 c050310:	e9dd 120b 	ldrd	r1, r2, [sp, #44]	@ 0x2c
 c050314:	461e      	mov	r6, r3
 c050316:	f89d 0028 	ldrb.w	r0, [sp, #40]	@ 0x28
 c05031a:	9f0d      	ldr	r7, [sp, #52]	@ 0x34
    if( mode == MBEDTLS_RSA_PRIVATE && ctx->padding != MBEDTLS_RSA_PKCS_V15 )
 c05031c:	d103      	bne.n	c050326 <mbedtls_rsa_rsassa_pkcs1_v15_sign+0x22>
 c05031e:	f8d5 30b0 	ldr.w	r3, [r5, #176]	@ 0xb0
 c050322:	2b00      	cmp	r3, #0
 c050324:	d157      	bne.n	c0503d6 <mbedtls_rsa_rsassa_pkcs1_v15_sign+0xd2>

    /*
     * Prepare PKCS1-v1.5 encoding (padding and hash identifier)
     */

    if( ( ret = rsa_rsassa_pkcs1_v15_encode( md_alg, hashlen, hash,
 c050326:	9700      	str	r7, [sp, #0]
 c050328:	686b      	ldr	r3, [r5, #4]
 c05032a:	f7fe fe97 	bl	c04f05c <rsa_rsassa_pkcs1_v15_encode>
 c05032e:	4604      	mov	r4, r0
 c050330:	b9c8      	cbnz	r0, c050366 <mbedtls_rsa_rsassa_pkcs1_v15_sign+0x62>

    /*
     * Call respective RSA primitive
     */

    if( mode == MBEDTLS_RSA_PUBLIC )
 c050332:	b93e      	cbnz	r6, c050344 <mbedtls_rsa_rsassa_pkcs1_v15_sign+0x40>
    {
        /* Skip verification on a public key operation */
        return( mbedtls_rsa_public( ctx, sig, sig ) );
 c050334:	463a      	mov	r2, r7
 c050336:	4639      	mov	r1, r7
 c050338:	4628      	mov	r0, r5
    mbedtls_free( verif );

    if( ret != 0 )
        memset( sig, '!', ctx->len );
    return( ret );
}
 c05033a:	b002      	add	sp, #8
 c05033c:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
        return( mbedtls_rsa_public( ctx, sig, sig ) );
 c050340:	f7ff ba12 	b.w	c04f768 <mbedtls_rsa_public>
    sig_try = mbedtls_calloc( 1, ctx->len );
 c050344:	2001      	movs	r0, #1
 c050346:	6869      	ldr	r1, [r5, #4]
 c050348:	f7eb f82c 	bl	c03b3a4 <mbedtls_calloc>
    if( sig_try == NULL )
 c05034c:	4606      	mov	r6, r0
 c05034e:	b140      	cbz	r0, c050362 <mbedtls_rsa_rsassa_pkcs1_v15_sign+0x5e>
    verif = mbedtls_calloc( 1, ctx->len );
 c050350:	2001      	movs	r0, #1
 c050352:	6869      	ldr	r1, [r5, #4]
 c050354:	f7eb f826 	bl	c03b3a4 <mbedtls_calloc>
    if( verif == NULL )
 c050358:	4680      	mov	r8, r0
 c05035a:	b940      	cbnz	r0, c05036e <mbedtls_rsa_rsassa_pkcs1_v15_sign+0x6a>
        mbedtls_free( sig_try );
 c05035c:	4630      	mov	r0, r6
 c05035e:	f7eb f827 	bl	c03b3b0 <mbedtls_free>
        return( MBEDTLS_ERR_MPI_ALLOC_FAILED );
 c050362:	f06f 040f 	mvn.w	r4, #15
}
 c050366:	4620      	mov	r0, r4
 c050368:	b002      	add	sp, #8
 c05036a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    MBEDTLS_MPI_CHK( mbedtls_rsa_private( ctx, f_rng, p_rng, sig, sig_try ) );
 c05036e:	463b      	mov	r3, r7
 c050370:	4652      	mov	r2, sl
 c050372:	4649      	mov	r1, r9
 c050374:	4628      	mov	r0, r5
 c050376:	9600      	str	r6, [sp, #0]
 c050378:	f7ff faa8 	bl	c04f8cc <mbedtls_rsa_private>
 c05037c:	4604      	mov	r4, r0
 c05037e:	b990      	cbnz	r0, c0503a6 <mbedtls_rsa_rsassa_pkcs1_v15_sign+0xa2>
    MBEDTLS_MPI_CHK( mbedtls_rsa_public( ctx, sig_try, verif ) );
 c050380:	4642      	mov	r2, r8
 c050382:	4631      	mov	r1, r6
 c050384:	4628      	mov	r0, r5
 c050386:	f7ff f9ef 	bl	c04f768 <mbedtls_rsa_public>
 c05038a:	4604      	mov	r4, r0
 c05038c:	b958      	cbnz	r0, c0503a6 <mbedtls_rsa_rsassa_pkcs1_v15_sign+0xa2>
    if( mbedtls_ct_memcmp( verif, sig, ctx->len ) != 0 )
 c05038e:	4639      	mov	r1, r7
 c050390:	4640      	mov	r0, r8
 c050392:	686a      	ldr	r2, [r5, #4]
 c050394:	f005 f9e0 	bl	c055758 <mbedtls_ct_memcmp>
 c050398:	4604      	mov	r4, r0
 c05039a:	b9d0      	cbnz	r0, c0503d2 <mbedtls_rsa_rsassa_pkcs1_v15_sign+0xce>
    memcpy( sig, sig_try, ctx->len );
 c05039c:	4631      	mov	r1, r6
 c05039e:	4638      	mov	r0, r7
 c0503a0:	686a      	ldr	r2, [r5, #4]
 c0503a2:	f00b f953 	bl	c05b64c <memcpy>
    mbedtls_platform_zeroize( sig_try, ctx->len );
 c0503a6:	4630      	mov	r0, r6
 c0503a8:	6869      	ldr	r1, [r5, #4]
 c0503aa:	f7eb f811 	bl	c03b3d0 <mbedtls_platform_zeroize>
    mbedtls_platform_zeroize( verif, ctx->len );
 c0503ae:	4640      	mov	r0, r8
 c0503b0:	6869      	ldr	r1, [r5, #4]
 c0503b2:	f7eb f80d 	bl	c03b3d0 <mbedtls_platform_zeroize>
    mbedtls_free( sig_try );
 c0503b6:	4630      	mov	r0, r6
 c0503b8:	f7ea fffa 	bl	c03b3b0 <mbedtls_free>
    mbedtls_free( verif );
 c0503bc:	4640      	mov	r0, r8
 c0503be:	f7ea fff7 	bl	c03b3b0 <mbedtls_free>
    if( ret != 0 )
 c0503c2:	2c00      	cmp	r4, #0
 c0503c4:	d0cf      	beq.n	c050366 <mbedtls_rsa_rsassa_pkcs1_v15_sign+0x62>
        memset( sig, '!', ctx->len );
 c0503c6:	2121      	movs	r1, #33	@ 0x21
 c0503c8:	4638      	mov	r0, r7
 c0503ca:	686a      	ldr	r2, [r5, #4]
 c0503cc:	f00b f9af 	bl	c05b72e <memset>
 c0503d0:	e7c9      	b.n	c050366 <mbedtls_rsa_rsassa_pkcs1_v15_sign+0x62>
        ret = MBEDTLS_ERR_RSA_PRIVATE_FAILED;
 c0503d2:	4c02      	ldr	r4, [pc, #8]	@ (c0503dc <mbedtls_rsa_rsassa_pkcs1_v15_sign+0xd8>)
 c0503d4:	e7e7      	b.n	c0503a6 <mbedtls_rsa_rsassa_pkcs1_v15_sign+0xa2>
        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
 c0503d6:	4c02      	ldr	r4, [pc, #8]	@ (c0503e0 <mbedtls_rsa_rsassa_pkcs1_v15_sign+0xdc>)
 c0503d8:	e7c5      	b.n	c050366 <mbedtls_rsa_rsassa_pkcs1_v15_sign+0x62>
 c0503da:	bf00      	nop
 c0503dc:	ffffbd00 	.word	0xffffbd00
 c0503e0:	ffffbf80 	.word	0xffffbf80

0c0503e4 <mbedtls_rsa_pkcs1_sign>:
                    int mode,
                    mbedtls_md_type_t md_alg,
                    unsigned int hashlen,
                    const unsigned char *hash,
                    unsigned char *sig )
{
 c0503e4:	b4f0      	push	{r4, r5, r6, r7}
    RSA_VALIDATE_RET( ( md_alg  == MBEDTLS_MD_NONE &&
                        hashlen == 0 ) ||
                      hash != NULL );
    RSA_VALIDATE_RET( sig != NULL );

    switch( ctx->padding )
 c0503e6:	f8d0 c0b0 	ldr.w	ip, [r0, #176]	@ 0xb0
{
 c0503ea:	f89d 4010 	ldrb.w	r4, [sp, #16]
 c0503ee:	9f07      	ldr	r7, [sp, #28]
 c0503f0:	e9dd 5605 	ldrd	r5, r6, [sp, #20]
    switch( ctx->padding )
 c0503f4:	f1bc 0f00 	cmp.w	ip, #0
 c0503f8:	d005      	beq.n	c050406 <mbedtls_rsa_pkcs1_sign+0x22>
 c0503fa:	f1bc 0f01 	cmp.w	ip, #1
 c0503fe:	d009      	beq.n	c050414 <mbedtls_rsa_pkcs1_sign+0x30>
#endif

        default:
            return( MBEDTLS_ERR_RSA_INVALID_PADDING );
    }
}
 c050400:	bcf0      	pop	{r4, r5, r6, r7}
 c050402:	4808      	ldr	r0, [pc, #32]	@ (c050424 <mbedtls_rsa_pkcs1_sign+0x40>)
 c050404:	4770      	bx	lr
            return mbedtls_rsa_rsassa_pkcs1_v15_sign( ctx, f_rng, p_rng, mode, md_alg,
 c050406:	e9cd 6706 	strd	r6, r7, [sp, #24]
 c05040a:	e9cd 4504 	strd	r4, r5, [sp, #16]
}
 c05040e:	bcf0      	pop	{r4, r5, r6, r7}
            return mbedtls_rsa_rsassa_pkcs1_v15_sign( ctx, f_rng, p_rng, mode, md_alg,
 c050410:	f7ff bf78 	b.w	c050304 <mbedtls_rsa_rsassa_pkcs1_v15_sign>
            return mbedtls_rsa_rsassa_pss_sign( ctx, f_rng, p_rng, mode, md_alg,
 c050414:	e9cd 6706 	strd	r6, r7, [sp, #24]
 c050418:	e9cd 4504 	strd	r4, r5, [sp, #16]
}
 c05041c:	bcf0      	pop	{r4, r5, r6, r7}
            return mbedtls_rsa_rsassa_pss_sign( ctx, f_rng, p_rng, mode, md_alg,
 c05041e:	f7ff bf5f 	b.w	c0502e0 <mbedtls_rsa_rsassa_pss_sign>
 c050422:	bf00      	nop
 c050424:	ffffbf00 	.word	0xffffbf00

0c050428 <mbedtls_rsa_rsassa_pss_verify_ext>:
                               unsigned int hashlen,
                               const unsigned char *hash,
                               mbedtls_md_type_t mgf1_hash_id,
                               int expected_salt_len,
                               const unsigned char *sig )
{
 c050428:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c05042c:	4604      	mov	r4, r0
 c05042e:	4618      	mov	r0, r3
 c050430:	f2ad 4d6c 	subw	sp, sp, #1132	@ 0x46c
    RSA_VALIDATE_RET( sig != NULL );
    RSA_VALIDATE_RET( ( md_alg  == MBEDTLS_MD_NONE &&
                        hashlen == 0 ) ||
                      hash != NULL );

    if( mode == MBEDTLS_RSA_PRIVATE && ctx->padding != MBEDTLS_RSA_PKCS_V21 )
 c050434:	2801      	cmp	r0, #1
{
 c050436:	f89d 7490 	ldrb.w	r7, [sp, #1168]	@ 0x490
 c05043a:	f8dd b4a0 	ldr.w	fp, [sp, #1184]	@ 0x4a0
 c05043e:	f8dd 34a4 	ldr.w	r3, [sp, #1188]	@ 0x4a4
    if( mode == MBEDTLS_RSA_PRIVATE && ctx->padding != MBEDTLS_RSA_PKCS_V21 )
 c050442:	d109      	bne.n	c050458 <mbedtls_rsa_rsassa_pss_verify_ext+0x30>
 c050444:	f8d4 50b0 	ldr.w	r5, [r4, #176]	@ 0xb0
 c050448:	2d01      	cmp	r5, #1
 c05044a:	d005      	beq.n	c050458 <mbedtls_rsa_rsassa_pss_verify_ext+0x30>
        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
 c05044c:	4b5c      	ldr	r3, [pc, #368]	@ (c0505c0 <mbedtls_rsa_rsassa_pss_verify_ext+0x198>)

exit:
    mbedtls_md_free( &md_ctx );

    return( ret );
}
 c05044e:	4618      	mov	r0, r3
 c050450:	f20d 4d6c 	addw	sp, sp, #1132	@ 0x46c
 c050454:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    siglen = ctx->len;
 c050458:	f8d4 8004 	ldr.w	r8, [r4, #4]
    if( siglen < 16 || siglen > sizeof( buf ) )
 c05045c:	f1a8 0510 	sub.w	r5, r8, #16
 c050460:	f5b5 7f7c 	cmp.w	r5, #1008	@ 0x3f0
 c050464:	d8f2      	bhi.n	c05044c <mbedtls_rsa_rsassa_pss_verify_ext+0x24>
    ret = ( mode == MBEDTLS_RSA_PUBLIC )
 c050466:	ae1a      	add	r6, sp, #104	@ 0x68
          : mbedtls_rsa_private( ctx, f_rng, p_rng, sig, buf );
 c050468:	2800      	cmp	r0, #0
 c05046a:	f040 80a0 	bne.w	c0505ae <mbedtls_rsa_rsassa_pss_verify_ext+0x186>
          ? mbedtls_rsa_public(  ctx, sig, buf )
 c05046e:	4632      	mov	r2, r6
 c050470:	4619      	mov	r1, r3
 c050472:	4620      	mov	r0, r4
 c050474:	f7ff f978 	bl	c04f768 <mbedtls_rsa_public>
          : mbedtls_rsa_private( ctx, f_rng, p_rng, sig, buf );
 c050478:	4603      	mov	r3, r0
    if( ret != 0 )
 c05047a:	2800      	cmp	r0, #0
 c05047c:	d1e7      	bne.n	c05044e <mbedtls_rsa_rsassa_pss_verify_ext+0x26>
    if( buf[siglen - 1] != 0xBC )
 c05047e:	f108 35ff 	add.w	r5, r8, #4294967295	@ 0xffffffff
 c050482:	5d73      	ldrb	r3, [r6, r5]
 c050484:	2bbc      	cmp	r3, #188	@ 0xbc
 c050486:	f040 8099 	bne.w	c0505bc <mbedtls_rsa_rsassa_pss_verify_ext+0x194>
    if( md_alg != MBEDTLS_MD_NONE )
 c05048a:	b147      	cbz	r7, c05049e <mbedtls_rsa_rsassa_pss_verify_ext+0x76>
        md_info = mbedtls_md_info_from_type( md_alg );
 c05048c:	4638      	mov	r0, r7
 c05048e:	f006 f95f 	bl	c056750 <mbedtls_md_info_from_type>
        if( md_info == NULL )
 c050492:	2800      	cmp	r0, #0
 c050494:	d0da      	beq.n	c05044c <mbedtls_rsa_rsassa_pss_verify_ext+0x24>
        hashlen = mbedtls_md_get_size( md_info );
 c050496:	f006 fae7 	bl	c056a68 <mbedtls_md_get_size>
 c05049a:	f8cd 0494 	str.w	r0, [sp, #1172]	@ 0x494
    md_info = mbedtls_md_info_from_type( mgf1_hash_id );
 c05049e:	f89d 049c 	ldrb.w	r0, [sp, #1180]	@ 0x49c
 c0504a2:	f006 f955 	bl	c056750 <mbedtls_md_info_from_type>
    if( md_info == NULL )
 c0504a6:	4682      	mov	sl, r0
 c0504a8:	2800      	cmp	r0, #0
 c0504aa:	d0cf      	beq.n	c05044c <mbedtls_rsa_rsassa_pss_verify_ext+0x24>
    hlen = mbedtls_md_get_size( md_info );
 c0504ac:	f006 fadc 	bl	c056a68 <mbedtls_md_get_size>
    memset( zeros, 0, 8 );
 c0504b0:	2300      	movs	r3, #0
    hlen = mbedtls_md_get_size( md_info );
 c0504b2:	4681      	mov	r9, r0
    msb = mbedtls_mpi_bitlen( &ctx->N ) - 1;
 c0504b4:	f104 0008 	add.w	r0, r4, #8
    memset( zeros, 0, 8 );
 c0504b8:	e9cd 3305 	strd	r3, r3, [sp, #20]
    msb = mbedtls_mpi_bitlen( &ctx->N ) - 1;
 c0504bc:	f003 f82f 	bl	c05351e <mbedtls_mpi_bitlen>
    if( buf[0] >> ( 8 - siglen * 8 + msb ) )
 c0504c0:	7832      	ldrb	r2, [r6, #0]
    msb = mbedtls_mpi_bitlen( &ctx->N ) - 1;
 c0504c2:	1e47      	subs	r7, r0, #1
    if( buf[0] >> ( 8 - siglen * 8 + msb ) )
 c0504c4:	f1c8 0301 	rsb	r3, r8, #1
 c0504c8:	eb07 03c3 	add.w	r3, r7, r3, lsl #3
 c0504cc:	411a      	asrs	r2, r3
 c0504ce:	d1bd      	bne.n	c05044c <mbedtls_rsa_rsassa_pss_verify_ext+0x24>
    if( msb % 8 == 0 )
 c0504d0:	077b      	lsls	r3, r7, #29
        siglen -= 1;
 c0504d2:	bf08      	it	eq
 c0504d4:	46a8      	moveq	r8, r5
    if( siglen < hlen + 2 )
 c0504d6:	f109 0302 	add.w	r3, r9, #2
    p = buf;
 c0504da:	bf14      	ite	ne
 c0504dc:	4635      	movne	r5, r6
        p++;
 c0504de:	f10d 0569 	addeq.w	r5, sp, #105	@ 0x69
    if( siglen < hlen + 2 )
 c0504e2:	4543      	cmp	r3, r8
 c0504e4:	d8b2      	bhi.n	c05044c <mbedtls_rsa_rsassa_pss_verify_ext+0x24>
    mbedtls_md_init( &md_ctx );
 c0504e6:	ac07      	add	r4, sp, #28
 c0504e8:	4620      	mov	r0, r4
 c0504ea:	f006 f93d 	bl	c056768 <mbedtls_md_init>
    if( ( ret = mbedtls_md_setup( &md_ctx, md_info, 0 ) ) != 0 )
 c0504ee:	2200      	movs	r2, #0
 c0504f0:	4651      	mov	r1, sl
 c0504f2:	4620      	mov	r0, r4
 c0504f4:	f006 f966 	bl	c0567c4 <mbedtls_md_setup>
 c0504f8:	4603      	mov	r3, r0
 c0504fa:	2800      	cmp	r0, #0
 c0504fc:	d151      	bne.n	c0505a2 <mbedtls_rsa_rsassa_pss_verify_ext+0x17a>
    hash_start = p + siglen - hlen - 1;
 c0504fe:	eba8 0109 	sub.w	r1, r8, r9
 c050502:	3901      	subs	r1, #1
 c050504:	eb05 0a01 	add.w	sl, r5, r1
    ret = mgf_mask( p, siglen - hlen - 1, hash_start, hlen, &md_ctx );
 c050508:	464b      	mov	r3, r9
 c05050a:	4652      	mov	r2, sl
 c05050c:	4628      	mov	r0, r5
 c05050e:	9400      	str	r4, [sp, #0]
 c050510:	f7fe fd50 	bl	c04efb4 <mgf_mask>
    if( ret != 0 )
 c050514:	4603      	mov	r3, r0
 c050516:	2800      	cmp	r0, #0
 c050518:	d143      	bne.n	c0505a2 <mbedtls_rsa_rsassa_pss_verify_ext+0x17a>
    buf[0] &= 0xFF >> ( siglen * 8 - msb );
 c05051a:	23ff      	movs	r3, #255	@ 0xff
 c05051c:	7832      	ldrb	r2, [r6, #0]
 c05051e:	ebc7 07c8 	rsb	r7, r7, r8, lsl #3
 c050522:	413b      	asrs	r3, r7
 c050524:	4013      	ands	r3, r2
 c050526:	7033      	strb	r3, [r6, #0]
    while( p < hash_start - 1 && *p == 0 )
 c050528:	f10a 32ff 	add.w	r2, sl, #4294967295	@ 0xffffffff
 c05052c:	f815 3b01 	ldrb.w	r3, [r5], #1
 c050530:	1e69      	subs	r1, r5, #1
 c050532:	428a      	cmp	r2, r1
 c050534:	d901      	bls.n	c05053a <mbedtls_rsa_rsassa_pss_verify_ext+0x112>
 c050536:	2b00      	cmp	r3, #0
 c050538:	d0f8      	beq.n	c05052c <mbedtls_rsa_rsassa_pss_verify_ext+0x104>
    if( *p++ != 0x01 )
 c05053a:	2b01      	cmp	r3, #1
 c05053c:	d13c      	bne.n	c0505b8 <mbedtls_rsa_rsassa_pss_verify_ext+0x190>
    if( expected_salt_len != MBEDTLS_RSA_SALT_LEN_ANY &&
 c05053e:	f1bb 3fff 	cmp.w	fp, #4294967295	@ 0xffffffff
    observed_salt_len = hash_start - p;
 c050542:	ebaa 0605 	sub.w	r6, sl, r5
    if( expected_salt_len != MBEDTLS_RSA_SALT_LEN_ANY &&
 c050546:	d001      	beq.n	c05054c <mbedtls_rsa_rsassa_pss_verify_ext+0x124>
 c050548:	455e      	cmp	r6, fp
 c05054a:	d135      	bne.n	c0505b8 <mbedtls_rsa_rsassa_pss_verify_ext+0x190>
    ret = mbedtls_md_starts( &md_ctx );
 c05054c:	4620      	mov	r0, r4
 c05054e:	f006 f975 	bl	c05683c <mbedtls_md_starts>
    if ( ret != 0 )
 c050552:	4603      	mov	r3, r0
 c050554:	bb28      	cbnz	r0, c0505a2 <mbedtls_rsa_rsassa_pss_verify_ext+0x17a>
    ret = mbedtls_md_update( &md_ctx, zeros, 8 );
 c050556:	2208      	movs	r2, #8
 c050558:	4620      	mov	r0, r4
 c05055a:	a905      	add	r1, sp, #20
 c05055c:	f006 f98a 	bl	c056874 <mbedtls_md_update>
    if ( ret != 0 )
 c050560:	4603      	mov	r3, r0
 c050562:	b9f0      	cbnz	r0, c0505a2 <mbedtls_rsa_rsassa_pss_verify_ext+0x17a>
    ret = mbedtls_md_update( &md_ctx, hash, hashlen );
 c050564:	4620      	mov	r0, r4
 c050566:	f8dd 2494 	ldr.w	r2, [sp, #1172]	@ 0x494
 c05056a:	f8dd 1498 	ldr.w	r1, [sp, #1176]	@ 0x498
 c05056e:	f006 f981 	bl	c056874 <mbedtls_md_update>
    if ( ret != 0 )
 c050572:	4603      	mov	r3, r0
 c050574:	b9a8      	cbnz	r0, c0505a2 <mbedtls_rsa_rsassa_pss_verify_ext+0x17a>
    ret = mbedtls_md_update( &md_ctx, p, observed_salt_len );
 c050576:	4632      	mov	r2, r6
 c050578:	4629      	mov	r1, r5
 c05057a:	4620      	mov	r0, r4
 c05057c:	f006 f97a 	bl	c056874 <mbedtls_md_update>
    if ( ret != 0 )
 c050580:	4603      	mov	r3, r0
 c050582:	b970      	cbnz	r0, c0505a2 <mbedtls_rsa_rsassa_pss_verify_ext+0x17a>
    ret = mbedtls_md_finish( &md_ctx, result );
 c050584:	4620      	mov	r0, r4
 c050586:	a90a      	add	r1, sp, #40	@ 0x28
 c050588:	f006 f98a 	bl	c0568a0 <mbedtls_md_finish>
    if ( ret != 0 )
 c05058c:	4603      	mov	r3, r0
 c05058e:	b940      	cbnz	r0, c0505a2 <mbedtls_rsa_rsassa_pss_verify_ext+0x17a>
    if( memcmp( hash_start, result, hlen ) != 0 )
 c050590:	464a      	mov	r2, r9
 c050592:	4650      	mov	r0, sl
 c050594:	a90a      	add	r1, sp, #40	@ 0x28
 c050596:	f00b f849 	bl	c05b62c <memcmp>
        ret = MBEDTLS_ERR_RSA_VERIFY_FAILED;
 c05059a:	4a0a      	ldr	r2, [pc, #40]	@ (c0505c4 <mbedtls_rsa_rsassa_pss_verify_ext+0x19c>)
 c05059c:	1e03      	subs	r3, r0, #0
 c05059e:	bf18      	it	ne
 c0505a0:	4613      	movne	r3, r2
    mbedtls_md_free( &md_ctx );
 c0505a2:	4620      	mov	r0, r4
 c0505a4:	9303      	str	r3, [sp, #12]
 c0505a6:	f006 f8e4 	bl	c056772 <mbedtls_md_free>
    return( ret );
 c0505aa:	9b03      	ldr	r3, [sp, #12]
 c0505ac:	e74f      	b.n	c05044e <mbedtls_rsa_rsassa_pss_verify_ext+0x26>
          : mbedtls_rsa_private( ctx, f_rng, p_rng, sig, buf );
 c0505ae:	4620      	mov	r0, r4
 c0505b0:	9600      	str	r6, [sp, #0]
 c0505b2:	f7ff f98b 	bl	c04f8cc <mbedtls_rsa_private>
 c0505b6:	e75f      	b.n	c050478 <mbedtls_rsa_rsassa_pss_verify_ext+0x50>
        ret = MBEDTLS_ERR_RSA_INVALID_PADDING;
 c0505b8:	4b03      	ldr	r3, [pc, #12]	@ (c0505c8 <mbedtls_rsa_rsassa_pss_verify_ext+0x1a0>)
 c0505ba:	e7f2      	b.n	c0505a2 <mbedtls_rsa_rsassa_pss_verify_ext+0x17a>
        return( MBEDTLS_ERR_RSA_INVALID_PADDING );
 c0505bc:	4b02      	ldr	r3, [pc, #8]	@ (c0505c8 <mbedtls_rsa_rsassa_pss_verify_ext+0x1a0>)
 c0505be:	e746      	b.n	c05044e <mbedtls_rsa_rsassa_pss_verify_ext+0x26>
 c0505c0:	ffffbf80 	.word	0xffffbf80
 c0505c4:	ffffbc80 	.word	0xffffbc80
 c0505c8:	ffffbf00 	.word	0xffffbf00

0c0505cc <mbedtls_rsa_rsassa_pss_verify>:
                           int mode,
                           mbedtls_md_type_t md_alg,
                           unsigned int hashlen,
                           const unsigned char *hash,
                           const unsigned char *sig )
{
 c0505cc:	b570      	push	{r4, r5, r6, lr}
    RSA_VALIDATE_RET( sig != NULL );
    RSA_VALIDATE_RET( ( md_alg  == MBEDTLS_MD_NONE &&
                        hashlen == 0 ) ||
                      hash != NULL );

    mgf1_hash_id = ( ctx->hash_id != MBEDTLS_MD_NONE )
 c0505ce:	f8d0 40b4 	ldr.w	r4, [r0, #180]	@ 0xb4
{
 c0505d2:	b086      	sub	sp, #24
 c0505d4:	f89d 5028 	ldrb.w	r5, [sp, #40]	@ 0x28
                             ? (mbedtls_md_type_t) ctx->hash_id
                             : md_alg;
 c0505d8:	b17c      	cbz	r4, c0505fa <mbedtls_rsa_rsassa_pss_verify+0x2e>
 c0505da:	b2e4      	uxtb	r4, r4

    return( mbedtls_rsa_rsassa_pss_verify_ext( ctx, f_rng, p_rng, mode,
 c0505dc:	9e0d      	ldr	r6, [sp, #52]	@ 0x34
 c0505de:	9605      	str	r6, [sp, #20]
 c0505e0:	f04f 36ff 	mov.w	r6, #4294967295	@ 0xffffffff
 c0505e4:	e9cd 4603 	strd	r4, r6, [sp, #12]
 c0505e8:	9c0c      	ldr	r4, [sp, #48]	@ 0x30
 c0505ea:	9402      	str	r4, [sp, #8]
 c0505ec:	9c0b      	ldr	r4, [sp, #44]	@ 0x2c
 c0505ee:	e9cd 5400 	strd	r5, r4, [sp]
 c0505f2:	f7ff ff19 	bl	c050428 <mbedtls_rsa_rsassa_pss_verify_ext>
                                       md_alg, hashlen, hash,
                                       mgf1_hash_id, MBEDTLS_RSA_SALT_LEN_ANY,
                                       sig ) );

}
 c0505f6:	b006      	add	sp, #24
 c0505f8:	bd70      	pop	{r4, r5, r6, pc}
                             : md_alg;
 c0505fa:	462c      	mov	r4, r5
 c0505fc:	e7ee      	b.n	c0505dc <mbedtls_rsa_rsassa_pss_verify+0x10>
	...

0c050600 <mbedtls_rsa_rsassa_pkcs1_v15_verify>:
                        hashlen == 0 ) ||
                      hash != NULL );

    sig_len = ctx->len;

    if( mode == MBEDTLS_RSA_PRIVATE && ctx->padding != MBEDTLS_RSA_PKCS_V15 )
 c050600:	2b01      	cmp	r3, #1
{
 c050602:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c050606:	4607      	mov	r7, r0
 c050608:	4689      	mov	r9, r1
 c05060a:	4692      	mov	sl, r2
 c05060c:	4698      	mov	r8, r3
    sig_len = ctx->len;
 c05060e:	6846      	ldr	r6, [r0, #4]
    if( mode == MBEDTLS_RSA_PRIVATE && ctx->padding != MBEDTLS_RSA_PKCS_V15 )
 c050610:	d103      	bne.n	c05061a <mbedtls_rsa_rsassa_pkcs1_v15_verify+0x1a>
 c050612:	f8d0 30b0 	ldr.w	r3, [r0, #176]	@ 0xb0
 c050616:	2b00      	cmp	r3, #0
 c050618:	d146      	bne.n	c0506a8 <mbedtls_rsa_rsassa_pkcs1_v15_verify+0xa8>

    /*
     * Prepare expected PKCS1 v1.5 encoding of hash.
     */

    if( ( encoded          = mbedtls_calloc( 1, sig_len ) ) == NULL ||
 c05061a:	4631      	mov	r1, r6
 c05061c:	2001      	movs	r0, #1
 c05061e:	f7ea fec1 	bl	c03b3a4 <mbedtls_calloc>
 c050622:	4605      	mov	r5, r0
 c050624:	2800      	cmp	r0, #0
 c050626:	d042      	beq.n	c0506ae <mbedtls_rsa_rsassa_pkcs1_v15_verify+0xae>
        ( encoded_expected = mbedtls_calloc( 1, sig_len ) ) == NULL )
 c050628:	4631      	mov	r1, r6
 c05062a:	2001      	movs	r0, #1
 c05062c:	f7ea feba 	bl	c03b3a4 <mbedtls_calloc>
    if( ( encoded          = mbedtls_calloc( 1, sig_len ) ) == NULL ||
 c050630:	4604      	mov	r4, r0
 c050632:	2800      	cmp	r0, #0
 c050634:	d03e      	beq.n	c0506b4 <mbedtls_rsa_rsassa_pkcs1_v15_verify+0xb4>
    {
        ret = MBEDTLS_ERR_MPI_ALLOC_FAILED;
        goto cleanup;
    }

    if( ( ret = rsa_rsassa_pkcs1_v15_encode( md_alg, hashlen, hash, sig_len,
 c050636:	e9dd 120d 	ldrd	r1, r2, [sp, #52]	@ 0x34
 c05063a:	9000      	str	r0, [sp, #0]
 c05063c:	4633      	mov	r3, r6
 c05063e:	f89d 0030 	ldrb.w	r0, [sp, #48]	@ 0x30
 c050642:	f7fe fd0b 	bl	c04f05c <rsa_rsassa_pkcs1_v15_encode>
 c050646:	4683      	mov	fp, r0
 c050648:	b998      	cbnz	r0, c050672 <mbedtls_rsa_rsassa_pkcs1_v15_verify+0x72>
     * Apply RSA primitive to get what should be PKCS1 encoded hash.
     */

    ret = ( mode == MBEDTLS_RSA_PUBLIC )
          ? mbedtls_rsa_public(  ctx, sig, encoded )
          : mbedtls_rsa_private( ctx, f_rng, p_rng, sig, encoded );
 c05064a:	f1b8 0f00 	cmp.w	r8, #0
 c05064e:	d123      	bne.n	c050698 <mbedtls_rsa_rsassa_pkcs1_v15_verify+0x98>
          ? mbedtls_rsa_public(  ctx, sig, encoded )
 c050650:	462a      	mov	r2, r5
 c050652:	4638      	mov	r0, r7
 c050654:	990f      	ldr	r1, [sp, #60]	@ 0x3c
 c050656:	f7ff f887 	bl	c04f768 <mbedtls_rsa_public>
          : mbedtls_rsa_private( ctx, f_rng, p_rng, sig, encoded );
 c05065a:	4683      	mov	fp, r0
    if( ret != 0 )
 c05065c:	b948      	cbnz	r0, c050672 <mbedtls_rsa_rsassa_pkcs1_v15_verify+0x72>

    /*
     * Compare
     */

    if( ( ret = mbedtls_ct_memcmp( encoded, encoded_expected,
 c05065e:	4632      	mov	r2, r6
 c050660:	4621      	mov	r1, r4
 c050662:	4628      	mov	r0, r5
 c050664:	f005 f878 	bl	c055758 <mbedtls_ct_memcmp>
                                              sig_len ) ) != 0 )
    {
        ret = MBEDTLS_ERR_RSA_VERIFY_FAILED;
 c050668:	4a14      	ldr	r2, [pc, #80]	@ (c0506bc <mbedtls_rsa_rsassa_pkcs1_v15_verify+0xbc>)
 c05066a:	f1b0 0b00 	subs.w	fp, r0, #0
 c05066e:	bf18      	it	ne
 c050670:	4693      	movne	fp, r2

cleanup:

    if( encoded != NULL )
    {
        mbedtls_platform_zeroize( encoded, sig_len );
 c050672:	4628      	mov	r0, r5
 c050674:	4631      	mov	r1, r6
 c050676:	f7ea feab 	bl	c03b3d0 <mbedtls_platform_zeroize>
        mbedtls_free( encoded );
 c05067a:	4628      	mov	r0, r5
 c05067c:	f7ea fe98 	bl	c03b3b0 <mbedtls_free>
    }

    if( encoded_expected != NULL )
 c050680:	b134      	cbz	r4, c050690 <mbedtls_rsa_rsassa_pkcs1_v15_verify+0x90>
    {
        mbedtls_platform_zeroize( encoded_expected, sig_len );
 c050682:	4620      	mov	r0, r4
 c050684:	4631      	mov	r1, r6
 c050686:	f7ea fea3 	bl	c03b3d0 <mbedtls_platform_zeroize>
        mbedtls_free( encoded_expected );
 c05068a:	4620      	mov	r0, r4
 c05068c:	f7ea fe90 	bl	c03b3b0 <mbedtls_free>
    }

    return( ret );
}
 c050690:	4658      	mov	r0, fp
 c050692:	b003      	add	sp, #12
 c050694:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
          : mbedtls_rsa_private( ctx, f_rng, p_rng, sig, encoded );
 c050698:	4652      	mov	r2, sl
 c05069a:	4649      	mov	r1, r9
 c05069c:	4638      	mov	r0, r7
 c05069e:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
 c0506a0:	9500      	str	r5, [sp, #0]
 c0506a2:	f7ff f913 	bl	c04f8cc <mbedtls_rsa_private>
 c0506a6:	e7d8      	b.n	c05065a <mbedtls_rsa_rsassa_pkcs1_v15_verify+0x5a>
        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
 c0506a8:	f8df b014 	ldr.w	fp, [pc, #20]	@ c0506c0 <mbedtls_rsa_rsassa_pkcs1_v15_verify+0xc0>
 c0506ac:	e7f0      	b.n	c050690 <mbedtls_rsa_rsassa_pkcs1_v15_verify+0x90>
        ret = MBEDTLS_ERR_MPI_ALLOC_FAILED;
 c0506ae:	f06f 0b0f 	mvn.w	fp, #15
 c0506b2:	e7ed      	b.n	c050690 <mbedtls_rsa_rsassa_pkcs1_v15_verify+0x90>
 c0506b4:	f06f 0b0f 	mvn.w	fp, #15
 c0506b8:	e7db      	b.n	c050672 <mbedtls_rsa_rsassa_pkcs1_v15_verify+0x72>
 c0506ba:	bf00      	nop
 c0506bc:	ffffbc80 	.word	0xffffbc80
 c0506c0:	ffffbf80 	.word	0xffffbf80

0c0506c4 <mbedtls_rsa_pkcs1_verify>:
                      int mode,
                      mbedtls_md_type_t md_alg,
                      unsigned int hashlen,
                      const unsigned char *hash,
                      const unsigned char *sig )
{
 c0506c4:	b4f0      	push	{r4, r5, r6, r7}
    RSA_VALIDATE_RET( sig != NULL );
    RSA_VALIDATE_RET( ( md_alg  == MBEDTLS_MD_NONE &&
                        hashlen == 0 ) ||
                      hash != NULL );

    switch( ctx->padding )
 c0506c6:	f8d0 c0b0 	ldr.w	ip, [r0, #176]	@ 0xb0
{
 c0506ca:	f89d 4010 	ldrb.w	r4, [sp, #16]
 c0506ce:	9f07      	ldr	r7, [sp, #28]
 c0506d0:	e9dd 5605 	ldrd	r5, r6, [sp, #20]
    switch( ctx->padding )
 c0506d4:	f1bc 0f00 	cmp.w	ip, #0
 c0506d8:	d005      	beq.n	c0506e6 <mbedtls_rsa_pkcs1_verify+0x22>
 c0506da:	f1bc 0f01 	cmp.w	ip, #1
 c0506de:	d009      	beq.n	c0506f4 <mbedtls_rsa_pkcs1_verify+0x30>
#endif

        default:
            return( MBEDTLS_ERR_RSA_INVALID_PADDING );
    }
}
 c0506e0:	bcf0      	pop	{r4, r5, r6, r7}
 c0506e2:	4808      	ldr	r0, [pc, #32]	@ (c050704 <mbedtls_rsa_pkcs1_verify+0x40>)
 c0506e4:	4770      	bx	lr
            return mbedtls_rsa_rsassa_pkcs1_v15_verify( ctx, f_rng, p_rng, mode, md_alg,
 c0506e6:	e9cd 6706 	strd	r6, r7, [sp, #24]
 c0506ea:	e9cd 4504 	strd	r4, r5, [sp, #16]
}
 c0506ee:	bcf0      	pop	{r4, r5, r6, r7}
            return mbedtls_rsa_rsassa_pkcs1_v15_verify( ctx, f_rng, p_rng, mode, md_alg,
 c0506f0:	f7ff bf86 	b.w	c050600 <mbedtls_rsa_rsassa_pkcs1_v15_verify>
            return mbedtls_rsa_rsassa_pss_verify( ctx, f_rng, p_rng, mode, md_alg,
 c0506f4:	e9cd 6706 	strd	r6, r7, [sp, #24]
 c0506f8:	e9cd 4504 	strd	r4, r5, [sp, #16]
}
 c0506fc:	bcf0      	pop	{r4, r5, r6, r7}
            return mbedtls_rsa_rsassa_pss_verify( ctx, f_rng, p_rng, mode, md_alg,
 c0506fe:	f7ff bf65 	b.w	c0505cc <mbedtls_rsa_rsassa_pss_verify>
 c050702:	bf00      	nop
 c050704:	ffffbf00 	.word	0xffffbf00

0c050708 <mbedtls_rsa_free>:

/*
 * Free the components of an RSA key
 */
void mbedtls_rsa_free( mbedtls_rsa_context *ctx )
{
 c050708:	b510      	push	{r4, lr}
    if( ctx == NULL )
 c05070a:	4604      	mov	r4, r0
 c05070c:	b3c0      	cbz	r0, c050780 <mbedtls_rsa_free+0x78>
        return;

    mbedtls_mpi_free( &ctx->Vi );
 c05070e:	3098      	adds	r0, #152	@ 0x98
 c050710:	f002 fdf7 	bl	c053302 <mbedtls_mpi_free>
    mbedtls_mpi_free( &ctx->Vf );
 c050714:	f104 00a4 	add.w	r0, r4, #164	@ 0xa4
 c050718:	f002 fdf3 	bl	c053302 <mbedtls_mpi_free>
    mbedtls_mpi_free( &ctx->RN );
 c05071c:	f104 0074 	add.w	r0, r4, #116	@ 0x74
 c050720:	f002 fdef 	bl	c053302 <mbedtls_mpi_free>
    mbedtls_mpi_free( &ctx->D  );
 c050724:	f104 0020 	add.w	r0, r4, #32
 c050728:	f002 fdeb 	bl	c053302 <mbedtls_mpi_free>
    mbedtls_mpi_free( &ctx->Q  );
 c05072c:	f104 0038 	add.w	r0, r4, #56	@ 0x38
 c050730:	f002 fde7 	bl	c053302 <mbedtls_mpi_free>
    mbedtls_mpi_free( &ctx->P  );
 c050734:	f104 002c 	add.w	r0, r4, #44	@ 0x2c
 c050738:	f002 fde3 	bl	c053302 <mbedtls_mpi_free>
    mbedtls_mpi_free( &ctx->Phi );
 c05073c:	f104 0044 	add.w	r0, r4, #68	@ 0x44
 c050740:	f002 fddf 	bl	c053302 <mbedtls_mpi_free>
    mbedtls_mpi_free( &ctx->E  );
 c050744:	f104 0014 	add.w	r0, r4, #20
 c050748:	f002 fddb 	bl	c053302 <mbedtls_mpi_free>
    mbedtls_mpi_free( &ctx->N  );
 c05074c:	f104 0008 	add.w	r0, r4, #8
 c050750:	f002 fdd7 	bl	c053302 <mbedtls_mpi_free>

#if !defined(MBEDTLS_RSA_NO_CRT)
    mbedtls_mpi_free( &ctx->RQ );
 c050754:	f104 008c 	add.w	r0, r4, #140	@ 0x8c
 c050758:	f002 fdd3 	bl	c053302 <mbedtls_mpi_free>
    mbedtls_mpi_free( &ctx->RP );
 c05075c:	f104 0080 	add.w	r0, r4, #128	@ 0x80
 c050760:	f002 fdcf 	bl	c053302 <mbedtls_mpi_free>
    mbedtls_mpi_free( &ctx->QP );
 c050764:	f104 0068 	add.w	r0, r4, #104	@ 0x68
 c050768:	f002 fdcb 	bl	c053302 <mbedtls_mpi_free>
    mbedtls_mpi_free( &ctx->DQ );
 c05076c:	f104 005c 	add.w	r0, r4, #92	@ 0x5c
 c050770:	f002 fdc7 	bl	c053302 <mbedtls_mpi_free>
    mbedtls_mpi_free( &ctx->DP );
 c050774:	f104 0050 	add.w	r0, r4, #80	@ 0x50
    {
        mbedtls_mutex_free( &ctx->mutex );
        ctx->ver = 0;
    }
#endif
}
 c050778:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mbedtls_mpi_free( &ctx->DP );
 c05077c:	f002 bdc1 	b.w	c053302 <mbedtls_mpi_free>
}
 c050780:	bd10      	pop	{r4, pc}
	...

0c050784 <mbedtls_rsa_gen_key>:
{
 c050784:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c050788:	461f      	mov	r7, r3
 c05078a:	b091      	sub	sp, #68	@ 0x44
 c05078c:	4604      	mov	r4, r0
    mbedtls_mpi_init( &H );
 c05078e:	a807      	add	r0, sp, #28
{
 c050790:	4690      	mov	r8, r2
 c050792:	9103      	str	r1, [sp, #12]
 c050794:	9d1a      	ldr	r5, [sp, #104]	@ 0x68
    mbedtls_mpi_init( &H );
 c050796:	f002 fdae 	bl	c0532f6 <mbedtls_mpi_init>
    mbedtls_mpi_init( &G );
 c05079a:	a80a      	add	r0, sp, #40	@ 0x28
 c05079c:	f002 fdab 	bl	c0532f6 <mbedtls_mpi_init>
    mbedtls_mpi_init( &L );
 c0507a0:	a80d      	add	r0, sp, #52	@ 0x34
 c0507a2:	f002 fda8 	bl	c0532f6 <mbedtls_mpi_init>
    if( nbits < 128 || exponent < 3 || nbits % 2 != 0 )
 c0507a6:	2f7f      	cmp	r7, #127	@ 0x7f
 c0507a8:	f240 80df 	bls.w	c05096a <mbedtls_rsa_gen_key+0x1e6>
 c0507ac:	2d02      	cmp	r5, #2
 c0507ae:	f340 80dc 	ble.w	c05096a <mbedtls_rsa_gen_key+0x1e6>
 c0507b2:	07fb      	lsls	r3, r7, #31
 c0507b4:	f100 80d9 	bmi.w	c05096a <mbedtls_rsa_gen_key+0x1e6>
    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &ctx->E, exponent ) );
 c0507b8:	f104 0a14 	add.w	sl, r4, #20
 c0507bc:	4629      	mov	r1, r5
 c0507be:	4650      	mov	r0, sl
 c0507c0:	f002 fe3d 	bl	c05343e <mbedtls_mpi_lset>
 c0507c4:	4601      	mov	r1, r0
 c0507c6:	2800      	cmp	r0, #0
 c0507c8:	f040 80b6 	bne.w	c050938 <mbedtls_rsa_gen_key+0x1b4>
    if( nbits > 1024 )
 c0507cc:	f5b7 6f80 	cmp.w	r7, #1024	@ 0x400
 c0507d0:	bf94      	ite	ls
 c0507d2:	2300      	movls	r3, #0
 c0507d4:	2301      	movhi	r3, #1
 c0507d6:	005b      	lsls	r3, r3, #1
 c0507d8:	9302      	str	r3, [sp, #8]
        if( mbedtls_mpi_bitlen( &ctx->D ) <= ( ( nbits + 1 ) / 2 ) ) // (FIPS 186-4 par. B.3.1 criterion 3(a))
 c0507da:	1c7b      	adds	r3, r7, #1
 c0507dc:	085b      	lsrs	r3, r3, #1
        MBEDTLS_MPI_CHK( mbedtls_mpi_gen_prime( &ctx->P, nbits >> 1,
 c0507de:	ea4f 0b57 	mov.w	fp, r7, lsr #1
        if( mbedtls_mpi_bitlen( &ctx->D ) <= ( ( nbits + 1 ) / 2 ) ) // (FIPS 186-4 par. B.3.1 criterion 3(a))
 c0507e2:	9304      	str	r3, [sp, #16]
        MBEDTLS_MPI_CHK( mbedtls_mpi_gen_prime( &ctx->P, nbits >> 1,
 c0507e4:	f104 052c 	add.w	r5, r4, #44	@ 0x2c
        MBEDTLS_MPI_CHK( mbedtls_mpi_gen_prime( &ctx->Q, nbits >> 1,
 c0507e8:	f104 0638 	add.w	r6, r4, #56	@ 0x38
        MBEDTLS_MPI_CHK( mbedtls_mpi_gen_prime( &ctx->P, nbits >> 1,
 c0507ec:	4659      	mov	r1, fp
 c0507ee:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 c0507f2:	4628      	mov	r0, r5
 c0507f4:	f8cd 8000 	str.w	r8, [sp]
 c0507f8:	f004 fa0c 	bl	c054c14 <mbedtls_mpi_gen_prime>
 c0507fc:	4601      	mov	r1, r0
 c0507fe:	2800      	cmp	r0, #0
 c050800:	f040 809a 	bne.w	c050938 <mbedtls_rsa_gen_key+0x1b4>
        MBEDTLS_MPI_CHK( mbedtls_mpi_gen_prime( &ctx->Q, nbits >> 1,
 c050804:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 c050808:	4659      	mov	r1, fp
 c05080a:	4630      	mov	r0, r6
 c05080c:	f8cd 8000 	str.w	r8, [sp]
 c050810:	f004 fa00 	bl	c054c14 <mbedtls_mpi_gen_prime>
 c050814:	4601      	mov	r1, r0
 c050816:	2800      	cmp	r0, #0
 c050818:	f040 808e 	bne.w	c050938 <mbedtls_rsa_gen_key+0x1b4>
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &H, &ctx->P, &ctx->Q ) );
 c05081c:	4629      	mov	r1, r5
 c05081e:	4632      	mov	r2, r6
 c050820:	a807      	add	r0, sp, #28
 c050822:	f003 f94d 	bl	c053ac0 <mbedtls_mpi_sub_mpi>
 c050826:	4601      	mov	r1, r0
 c050828:	2800      	cmp	r0, #0
 c05082a:	f040 8085 	bne.w	c050938 <mbedtls_rsa_gen_key+0x1b4>
 c05082e:	9005      	str	r0, [sp, #20]
        if( mbedtls_mpi_bitlen( &H ) <= ( ( nbits >= 200 ) ? ( ( nbits >> 1 ) - 99 ) : 0 ) )
 c050830:	a807      	add	r0, sp, #28
 c050832:	f002 fe74 	bl	c05351e <mbedtls_mpi_bitlen>
 c050836:	9905      	ldr	r1, [sp, #20]
 c050838:	2fc7      	cmp	r7, #199	@ 0xc7
 c05083a:	bf88      	it	hi
 c05083c:	f1ab 0163 	subhi.w	r1, fp, #99	@ 0x63
 c050840:	4288      	cmp	r0, r1
 c050842:	d9d3      	bls.n	c0507ec <mbedtls_rsa_gen_key+0x68>
        if( H.s < 0 )
 c050844:	9b07      	ldr	r3, [sp, #28]
 c050846:	2b00      	cmp	r3, #0
 c050848:	da03      	bge.n	c050852 <mbedtls_rsa_gen_key+0xce>
            mbedtls_mpi_swap( &ctx->P, &ctx->Q );
 c05084a:	4631      	mov	r1, r6
 c05084c:	4628      	mov	r0, r5
 c05084e:	f002 fde0 	bl	c053412 <mbedtls_mpi_swap>
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( &ctx->P, &ctx->P, 1 ) );
 c050852:	4629      	mov	r1, r5
 c050854:	2201      	movs	r2, #1
 c050856:	4628      	mov	r0, r5
 c050858:	f003 f96c 	bl	c053b34 <mbedtls_mpi_sub_int>
 c05085c:	4601      	mov	r1, r0
 c05085e:	2800      	cmp	r0, #0
 c050860:	d16a      	bne.n	c050938 <mbedtls_rsa_gen_key+0x1b4>
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( &ctx->Q, &ctx->Q, 1 ) );
 c050862:	4631      	mov	r1, r6
 c050864:	2201      	movs	r2, #1
 c050866:	4630      	mov	r0, r6
 c050868:	f003 f964 	bl	c053b34 <mbedtls_mpi_sub_int>
 c05086c:	4601      	mov	r1, r0
 c05086e:	2800      	cmp	r0, #0
 c050870:	d162      	bne.n	c050938 <mbedtls_rsa_gen_key+0x1b4>
        MBEDTLS_MPI_CHK( rsa_mpi2pka_mul( &H, &ctx->P, &ctx->Q ) );
 c050872:	4629      	mov	r1, r5
 c050874:	4632      	mov	r2, r6
 c050876:	a807      	add	r0, sp, #28
 c050878:	f7fe fa8e 	bl	c04ed98 <rsa_mpi2pka_mul>
 c05087c:	4601      	mov	r1, r0
 c05087e:	2800      	cmp	r0, #0
 c050880:	d15a      	bne.n	c050938 <mbedtls_rsa_gen_key+0x1b4>
        MBEDTLS_MPI_CHK( mbedtls_mpi_gcd( &G, &ctx->E, &H  ) );
 c050882:	4651      	mov	r1, sl
 c050884:	aa07      	add	r2, sp, #28
 c050886:	a80a      	add	r0, sp, #40	@ 0x28
 c050888:	f003 fedf 	bl	c05464a <mbedtls_mpi_gcd>
 c05088c:	4601      	mov	r1, r0
 c05088e:	2800      	cmp	r0, #0
 c050890:	d152      	bne.n	c050938 <mbedtls_rsa_gen_key+0x1b4>
        if( mbedtls_mpi_cmp_int( &G, 1 ) != 0 )
 c050892:	2101      	movs	r1, #1
 c050894:	a80a      	add	r0, sp, #40	@ 0x28
 c050896:	f003 f814 	bl	c0538c2 <mbedtls_mpi_cmp_int>
 c05089a:	2800      	cmp	r0, #0
 c05089c:	d1a6      	bne.n	c0507ec <mbedtls_rsa_gen_key+0x68>
        MBEDTLS_MPI_CHK( mbedtls_mpi_gcd( &G, &ctx->P, &ctx->Q ) );
 c05089e:	4629      	mov	r1, r5
 c0508a0:	4632      	mov	r2, r6
 c0508a2:	a80a      	add	r0, sp, #40	@ 0x28
 c0508a4:	f003 fed1 	bl	c05464a <mbedtls_mpi_gcd>
 c0508a8:	4601      	mov	r1, r0
 c0508aa:	2800      	cmp	r0, #0
 c0508ac:	d144      	bne.n	c050938 <mbedtls_rsa_gen_key+0x1b4>
        MBEDTLS_MPI_CHK( mbedtls_mpi_div_mpi( &L, NULL, &H, &G ) );
 c0508ae:	ab0a      	add	r3, sp, #40	@ 0x28
 c0508b0:	aa07      	add	r2, sp, #28
 c0508b2:	a80d      	add	r0, sp, #52	@ 0x34
 c0508b4:	f003 fa79 	bl	c053daa <mbedtls_mpi_div_mpi>
 c0508b8:	4601      	mov	r1, r0
 c0508ba:	2800      	cmp	r0, #0
 c0508bc:	d13c      	bne.n	c050938 <mbedtls_rsa_gen_key+0x1b4>
        MBEDTLS_MPI_CHK( mbedtls_mpi_inv_mod( &ctx->D, &ctx->E, &L ) );
 c0508be:	f104 0920 	add.w	r9, r4, #32
 c0508c2:	4651      	mov	r1, sl
 c0508c4:	4648      	mov	r0, r9
 c0508c6:	aa0d      	add	r2, sp, #52	@ 0x34
 c0508c8:	f004 f81a 	bl	c054900 <mbedtls_mpi_inv_mod>
 c0508cc:	4601      	mov	r1, r0
 c0508ce:	bb98      	cbnz	r0, c050938 <mbedtls_rsa_gen_key+0x1b4>
        if( mbedtls_mpi_bitlen( &ctx->D ) <= ( ( nbits + 1 ) / 2 ) ) // (FIPS 186-4 par. B.3.1 criterion 3(a))
 c0508d0:	4648      	mov	r0, r9
 c0508d2:	f002 fe24 	bl	c05351e <mbedtls_mpi_bitlen>
 c0508d6:	9b04      	ldr	r3, [sp, #16]
 c0508d8:	4298      	cmp	r0, r3
 c0508da:	d987      	bls.n	c0507ec <mbedtls_rsa_gen_key+0x68>
    MBEDTLS_MPI_CHK( mbedtls_mpi_add_int( &ctx->P,  &ctx->P, 1 ) );
 c0508dc:	4629      	mov	r1, r5
 c0508de:	2201      	movs	r2, #1
 c0508e0:	4628      	mov	r0, r5
 c0508e2:	f003 f911 	bl	c053b08 <mbedtls_mpi_add_int>
 c0508e6:	4601      	mov	r1, r0
 c0508e8:	bb30      	cbnz	r0, c050938 <mbedtls_rsa_gen_key+0x1b4>
    MBEDTLS_MPI_CHK( mbedtls_mpi_add_int( &ctx->Q,  &ctx->Q, 1 ) );
 c0508ea:	4631      	mov	r1, r6
 c0508ec:	2201      	movs	r2, #1
 c0508ee:	4630      	mov	r0, r6
 c0508f0:	f003 f90a 	bl	c053b08 <mbedtls_mpi_add_int>
 c0508f4:	4601      	mov	r1, r0
 c0508f6:	b9f8      	cbnz	r0, c050938 <mbedtls_rsa_gen_key+0x1b4>
    MBEDTLS_MPI_CHK( rsa_mpi2pka_mul( &ctx->N, &ctx->P, &ctx->Q ) );
 c0508f8:	f104 0708 	add.w	r7, r4, #8
 c0508fc:	4629      	mov	r1, r5
 c0508fe:	4632      	mov	r2, r6
 c050900:	4638      	mov	r0, r7
 c050902:	f7fe fa49 	bl	c04ed98 <rsa_mpi2pka_mul>
 c050906:	4601      	mov	r1, r0
 c050908:	b9b0      	cbnz	r0, c050938 <mbedtls_rsa_gen_key+0x1b4>
    ctx->len = mbedtls_mpi_size( &ctx->N );
 c05090a:	4638      	mov	r0, r7
 c05090c:	f002 fe25 	bl	c05355a <mbedtls_mpi_size>
    MBEDTLS_MPI_CHK( mbedtls_rsa_deduce_crt( &ctx->P, &ctx->Q, &ctx->D,
 c050910:	f104 0368 	add.w	r3, r4, #104	@ 0x68
    ctx->len = mbedtls_mpi_size( &ctx->N );
 c050914:	6060      	str	r0, [r4, #4]
    MBEDTLS_MPI_CHK( mbedtls_rsa_deduce_crt( &ctx->P, &ctx->Q, &ctx->D,
 c050916:	9301      	str	r3, [sp, #4]
 c050918:	f104 035c 	add.w	r3, r4, #92	@ 0x5c
 c05091c:	4631      	mov	r1, r6
 c05091e:	9300      	str	r3, [sp, #0]
 c050920:	464a      	mov	r2, r9
 c050922:	4628      	mov	r0, r5
 c050924:	f104 0350 	add.w	r3, r4, #80	@ 0x50
 c050928:	f007 fc48 	bl	c0581bc <mbedtls_rsa_deduce_crt>
 c05092c:	4601      	mov	r1, r0
 c05092e:	b918      	cbnz	r0, c050938 <mbedtls_rsa_gen_key+0x1b4>
    MBEDTLS_MPI_CHK( mbedtls_rsa_check_privkey( ctx ) );
 c050930:	4620      	mov	r0, r4
 c050932:	f7fe fec5 	bl	c04f6c0 <mbedtls_rsa_check_privkey>
 c050936:	4601      	mov	r1, r0
    mbedtls_mpi_free( &H );
 c050938:	a807      	add	r0, sp, #28
 c05093a:	9102      	str	r1, [sp, #8]
 c05093c:	f002 fce1 	bl	c053302 <mbedtls_mpi_free>
    mbedtls_mpi_free( &G );
 c050940:	a80a      	add	r0, sp, #40	@ 0x28
 c050942:	f002 fcde 	bl	c053302 <mbedtls_mpi_free>
    mbedtls_mpi_free( &L );
 c050946:	a80d      	add	r0, sp, #52	@ 0x34
 c050948:	f002 fcdb 	bl	c053302 <mbedtls_mpi_free>
    if( ret != 0 )
 c05094c:	9902      	ldr	r1, [sp, #8]
 c05094e:	b141      	cbz	r1, c050962 <mbedtls_rsa_gen_key+0x1de>
        mbedtls_rsa_free( ctx );
 c050950:	4620      	mov	r0, r4
 c050952:	f7ff fed9 	bl	c050708 <mbedtls_rsa_free>
        if( ( -ret & ~0x7f ) == 0 )
 c050956:	9902      	ldr	r1, [sp, #8]
 c050958:	424b      	negs	r3, r1
 c05095a:	2b7f      	cmp	r3, #127	@ 0x7f
 c05095c:	bf98      	it	ls
 c05095e:	f5a1 4183 	subls.w	r1, r1, #16768	@ 0x4180
}
 c050962:	4608      	mov	r0, r1
 c050964:	b011      	add	sp, #68	@ 0x44
 c050966:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        ret = MBEDTLS_ERR_RSA_BAD_INPUT_DATA;
 c05096a:	4901      	ldr	r1, [pc, #4]	@ (c050970 <mbedtls_rsa_gen_key+0x1ec>)
 c05096c:	e7e4      	b.n	c050938 <mbedtls_rsa_gen_key+0x1b4>
 c05096e:	bf00      	nop
 c050970:	ffffbf80 	.word	0xffffbf80

0c050974 <mbedtls_sha256_init>:
static void mbedtls_zeroize(void *v, size_t n)
{
    volatile unsigned char *p = (unsigned char *)v;
    while (n--)
    {
        *p++ = 0;
 c050974:	2100      	movs	r1, #0
    }
}

void mbedtls_sha256_init(mbedtls_sha256_context *ctx)
{
 c050976:	b082      	sub	sp, #8
 c050978:	f500 73ba 	add.w	r3, r0, #372	@ 0x174
        *p++ = 0;
 c05097c:	4602      	mov	r2, r0
 c05097e:	3001      	adds	r0, #1
    while (n--)
 c050980:	4283      	cmp	r3, r0
        *p++ = 0;
 c050982:	7011      	strb	r1, [r2, #0]
    while (n--)
 c050984:	d1fa      	bne.n	c05097c <mbedtls_sha256_init+0x8>
    SHA256_VALIDATE( ctx != NULL );

    mbedtls_zeroize(ctx, sizeof(mbedtls_sha256_context));

    /* Enable HASH clock */
    __HAL_RCC_HASH_CLK_ENABLE();
 c050986:	4b07      	ldr	r3, [pc, #28]	@ (c0509a4 <mbedtls_sha256_init+0x30>)
 c050988:	f8d3 208c 	ldr.w	r2, [r3, #140]	@ 0x8c
 c05098c:	f442 3200 	orr.w	r2, r2, #131072	@ 0x20000
 c050990:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
 c050994:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 c050998:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 c05099c:	9301      	str	r3, [sp, #4]
 c05099e:	9b01      	ldr	r3, [sp, #4]
}
 c0509a0:	b002      	add	sp, #8
 c0509a2:	4770      	bx	lr
 c0509a4:	56020c00 	.word	0x56020c00

0c0509a8 <mbedtls_sha256_free>:

void mbedtls_sha256_free(mbedtls_sha256_context *ctx)
{
    if (ctx == NULL)
 c0509a8:	b138      	cbz	r0, c0509ba <mbedtls_sha256_free+0x12>
        *p++ = 0;
 c0509aa:	2100      	movs	r1, #0
 c0509ac:	f500 73ba 	add.w	r3, r0, #372	@ 0x174
 c0509b0:	4602      	mov	r2, r0
 c0509b2:	3001      	adds	r0, #1
    while (n--)
 c0509b4:	4283      	cmp	r3, r0
        *p++ = 0;
 c0509b6:	7011      	strb	r1, [r2, #0]
    while (n--)
 c0509b8:	d1fa      	bne.n	c0509b0 <mbedtls_sha256_free+0x8>
    {
        return;
    }
    mbedtls_zeroize(ctx, sizeof(mbedtls_sha256_context));
}
 c0509ba:	4770      	bx	lr

0c0509bc <mbedtls_sha256_clone>:

void mbedtls_sha256_clone(mbedtls_sha256_context *dst,
                          const mbedtls_sha256_context *src)
{
 c0509bc:	b508      	push	{r3, lr}
    SHA256_VALIDATE( dst != NULL );
    SHA256_VALIDATE( src != NULL );

    *dst = *src;
 c0509be:	f44f 72ba 	mov.w	r2, #372	@ 0x174
 c0509c2:	f00a fe43 	bl	c05b64c <memcpy>
}
 c0509c6:	bd08      	pop	{r3, pc}

0c0509c8 <mbedtls_sha256_starts_ret>:

int mbedtls_sha256_starts_ret(mbedtls_sha256_context *ctx, int is224)
{
 c0509c8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    SHA256_VALIDATE_RET( ctx != NULL );
    SHA256_VALIDATE_RET( is224 == 0 || is224 == 1 );

    /* HASH Configuration */
    if (HAL_HASH_DeInit(&ctx->hhash) != HAL_OK)
 c0509ca:	1d06      	adds	r6, r0, #4
{
 c0509cc:	4605      	mov	r5, r0
    if (HAL_HASH_DeInit(&ctx->hhash) != HAL_OK)
 c0509ce:	4630      	mov	r0, r6
{
 c0509d0:	460f      	mov	r7, r1
    if (HAL_HASH_DeInit(&ctx->hhash) != HAL_OK)
 c0509d2:	f7ee f912 	bl	c03ebfa <HAL_HASH_DeInit>
 c0509d6:	b110      	cbz	r0, c0509de <mbedtls_sha256_starts_ret+0x16>
    {
        return MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED;
 c0509d8:	f06f 006f 	mvn.w	r0, #111	@ 0x6f
    /* save hw context */
    HAL_HASH_ContextSaving(&ctx->hhash, ctx->ctx_save_regs);
#endif /* ST_HW_CONTEXT_SAVING */

    return 0;
}
 c0509dc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    ctx->hhash.Init.DataType = HASH_DATATYPE_8B;
 c0509de:	2320      	movs	r3, #32
    if (HAL_HASH_Init(&ctx->hhash) != HAL_OK)
 c0509e0:	4630      	mov	r0, r6
    ctx->hhash.Init.DataType = HASH_DATATYPE_8B;
 c0509e2:	606b      	str	r3, [r5, #4]
    if (HAL_HASH_Init(&ctx->hhash) != HAL_OK)
 c0509e4:	f7ee f8da 	bl	c03eb9c <HAL_HASH_Init>
 c0509e8:	4604      	mov	r4, r0
 c0509ea:	2800      	cmp	r0, #0
 c0509ec:	d1f4      	bne.n	c0509d8 <mbedtls_sha256_starts_ret+0x10>
    ctx->first = ST_SHA256_EXTRA_BYTES;
 c0509ee:	2304      	movs	r3, #4
    ctx->sbuf_len = 0;
 c0509f0:	f885 008c 	strb.w	r0, [r5, #140]	@ 0x8c
    ctx->is224 = is224;
 c0509f4:	602f      	str	r7, [r5, #0]
    HAL_HASH_ContextSaving(&ctx->hhash, ctx->ctx_save_regs);
 c0509f6:	4630      	mov	r0, r6
    ctx->first = ST_SHA256_EXTRA_BYTES;
 c0509f8:	f885 3171 	strb.w	r3, [r5, #369]	@ 0x171
    HAL_HASH_ContextSaving(&ctx->hhash, ctx->ctx_save_regs);
 c0509fc:	f105 018d 	add.w	r1, r5, #141	@ 0x8d
 c050a00:	f7ee f914 	bl	c03ec2c <HAL_HASH_ContextSaving>
    return 0;
 c050a04:	4620      	mov	r0, r4
 c050a06:	e7e9      	b.n	c0509dc <mbedtls_sha256_starts_ret+0x14>

0c050a08 <mbedtls_sha256_update_ret>:

    return 0;
}

int mbedtls_sha256_update_ret(mbedtls_sha256_context *ctx, const unsigned char *input, size_t ilen)
{
 c050a08:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 c050a0c:	4604      	mov	r4, r0
 c050a0e:	4616      	mov	r6, r2
    SHA256_VALIDATE_RET( ctx != NULL );
    SHA256_VALIDATE_RET( ilen == 0 || input != NULL );

#ifdef ST_HW_CONTEXT_SAVING
    /* restore hw context */
    HAL_HASH_ContextRestoring(&ctx->hhash, ctx->ctx_save_regs);
 c050a10:	f100 0a8d 	add.w	sl, r0, #141	@ 0x8d
 c050a14:	1d07      	adds	r7, r0, #4
 c050a16:	4638      	mov	r0, r7
{
 c050a18:	4688      	mov	r8, r1
    HAL_HASH_ContextRestoring(&ctx->hhash, ctx->ctx_save_regs);
 c050a1a:	4651      	mov	r1, sl
 c050a1c:	f7ee f92c 	bl	c03ec78 <HAL_HASH_ContextRestoring>
#endif /* ST_HW_CONTEXT_SAVING */

    if (currentlen < (ST_SHA256_BLOCK_SIZE + ctx->first - ctx->sbuf_len))
 c050a20:	f894 2171 	ldrb.w	r2, [r4, #369]	@ 0x171
 c050a24:	f894 008c 	ldrb.w	r0, [r4, #140]	@ 0x8c
 c050a28:	3240      	adds	r2, #64	@ 0x40
 c050a2a:	1a12      	subs	r2, r2, r0
    {
        /* only store input data in context buffer */
        memcpy(ctx->sbuf + ctx->sbuf_len, input, currentlen);
 c050a2c:	f104 0948 	add.w	r9, r4, #72	@ 0x48
    if (currentlen < (ST_SHA256_BLOCK_SIZE + ctx->first - ctx->sbuf_len))
 c050a30:	42b2      	cmp	r2, r6
 c050a32:	4448      	add	r0, r9
 c050a34:	d90e      	bls.n	c050a54 <mbedtls_sha256_update_ret+0x4c>
        memcpy(ctx->sbuf + ctx->sbuf_len, input, currentlen);
 c050a36:	4632      	mov	r2, r6
 c050a38:	4641      	mov	r1, r8
 c050a3a:	f00a fe07 	bl	c05b64c <memcpy>
        ctx->sbuf_len += currentlen;
 c050a3e:	f894 308c 	ldrb.w	r3, [r4, #140]	@ 0x8c
 c050a42:	4433      	add	r3, r6
 c050a44:	f884 308c 	strb.w	r3, [r4, #140]	@ 0x8c
        }
    }

#ifdef ST_HW_CONTEXT_SAVING
    /* save hw context */
    HAL_HASH_ContextSaving(&ctx->hhash, ctx->ctx_save_regs);
 c050a48:	4638      	mov	r0, r7
 c050a4a:	4651      	mov	r1, sl
 c050a4c:	f7ee f8ee 	bl	c03ec2c <HAL_HASH_ContextSaving>
#endif /* ST_HW_CONTEXT_SAVING */
    return 0;
 c050a50:	2000      	movs	r0, #0
 c050a52:	e03b      	b.n	c050acc <mbedtls_sha256_update_ret+0xc4>
        memcpy(ctx->sbuf + ctx->sbuf_len, input, (ST_SHA256_BLOCK_SIZE + ctx->first - ctx->sbuf_len));
 c050a54:	4641      	mov	r1, r8
 c050a56:	f00a fdf9 	bl	c05b64c <memcpy>
        currentlen -= (ST_SHA256_BLOCK_SIZE + ctx->first - ctx->sbuf_len);
 c050a5a:	f894 208c 	ldrb.w	r2, [r4, #140]	@ 0x8c
 c050a5e:	f1a6 0140 	sub.w	r1, r6, #64	@ 0x40
 c050a62:	440a      	add	r2, r1
 c050a64:	f894 3171 	ldrb.w	r3, [r4, #369]	@ 0x171
        if (ctx->is224 == 0)
 c050a68:	6821      	ldr	r1, [r4, #0]
        currentlen -= (ST_SHA256_BLOCK_SIZE + ctx->first - ctx->sbuf_len);
 c050a6a:	1ad5      	subs	r5, r2, r3
        if (ctx->is224 == 0)
 c050a6c:	f103 0240 	add.w	r2, r3, #64	@ 0x40
 c050a70:	b9a9      	cbnz	r1, c050a9e <mbedtls_sha256_update_ret+0x96>
            if (HAL_HASHEx_SHA256_Accmlt(&ctx->hhash, (uint8_t *)(ctx->sbuf), ST_SHA256_BLOCK_SIZE + ctx->first) != 0)
 c050a72:	4649      	mov	r1, r9
 c050a74:	4638      	mov	r0, r7
 c050a76:	f7ee fa1b 	bl	c03eeb0 <HAL_HASHEx_SHA256_Accmlt>
 c050a7a:	bb28      	cbnz	r0, c050ac8 <mbedtls_sha256_update_ret+0xc0>
        if (iter != 0)
 c050a7c:	2d3f      	cmp	r5, #63	@ 0x3f
 c050a7e:	d813      	bhi.n	c050aa8 <mbedtls_sha256_update_ret+0xa0>
        ctx->first = 0;
 c050a80:	2300      	movs	r3, #0
        ctx->sbuf_len = currentlen % ST_SHA256_BLOCK_SIZE;
 c050a82:	f005 023f 	and.w	r2, r5, #63	@ 0x3f
        ctx->first = 0;
 c050a86:	f884 3171 	strb.w	r3, [r4, #369]	@ 0x171
        ctx->sbuf_len = currentlen % ST_SHA256_BLOCK_SIZE;
 c050a8a:	f884 208c 	strb.w	r2, [r4, #140]	@ 0x8c
        if (ctx->sbuf_len != 0)
 c050a8e:	2a00      	cmp	r2, #0
 c050a90:	d0da      	beq.n	c050a48 <mbedtls_sha256_update_ret+0x40>
            memcpy(ctx->sbuf, input + ilen - ctx->sbuf_len, ctx->sbuf_len);
 c050a92:	1ab1      	subs	r1, r6, r2
 c050a94:	4648      	mov	r0, r9
 c050a96:	4441      	add	r1, r8
 c050a98:	f00a fdd8 	bl	c05b64c <memcpy>
 c050a9c:	e7d4      	b.n	c050a48 <mbedtls_sha256_update_ret+0x40>
            if (HAL_HASHEx_SHA224_Accmlt(&ctx->hhash, (uint8_t *)(ctx->sbuf), ST_SHA256_BLOCK_SIZE + ctx->first) != 0)
 c050a9e:	4649      	mov	r1, r9
 c050aa0:	4638      	mov	r0, r7
 c050aa2:	f7ee f9f5 	bl	c03ee90 <HAL_HASHEx_SHA224_Accmlt>
 c050aa6:	e7e8      	b.n	c050a7a <mbedtls_sha256_update_ret+0x72>
                if (HAL_HASHEx_SHA256_Accmlt(&ctx->hhash, (uint8_t *)(input + ST_SHA256_BLOCK_SIZE + ctx->first - ctx->sbuf_len), (iter * ST_SHA256_BLOCK_SIZE)) != 0)
 c050aa8:	f894 1171 	ldrb.w	r1, [r4, #369]	@ 0x171
 c050aac:	f894 308c 	ldrb.w	r3, [r4, #140]	@ 0x8c
 c050ab0:	3140      	adds	r1, #64	@ 0x40
 c050ab2:	1ac9      	subs	r1, r1, r3
            if (ctx->is224 == 0)
 c050ab4:	6823      	ldr	r3, [r4, #0]
                if (HAL_HASHEx_SHA256_Accmlt(&ctx->hhash, (uint8_t *)(input + ST_SHA256_BLOCK_SIZE + ctx->first - ctx->sbuf_len), (iter * ST_SHA256_BLOCK_SIZE)) != 0)
 c050ab6:	4638      	mov	r0, r7
 c050ab8:	4441      	add	r1, r8
 c050aba:	f025 023f 	bic.w	r2, r5, #63	@ 0x3f
            if (ctx->is224 == 0)
 c050abe:	b93b      	cbnz	r3, c050ad0 <mbedtls_sha256_update_ret+0xc8>
                if (HAL_HASHEx_SHA256_Accmlt(&ctx->hhash, (uint8_t *)(input + ST_SHA256_BLOCK_SIZE + ctx->first - ctx->sbuf_len), (iter * ST_SHA256_BLOCK_SIZE)) != 0)
 c050ac0:	f7ee f9f6 	bl	c03eeb0 <HAL_HASHEx_SHA256_Accmlt>
                if (HAL_HASHEx_SHA224_Accmlt(&ctx->hhash, (uint8_t *)(input + ST_SHA256_BLOCK_SIZE + ctx->first - ctx->sbuf_len), (iter * ST_SHA256_BLOCK_SIZE)) != 0)
 c050ac4:	2800      	cmp	r0, #0
 c050ac6:	d0db      	beq.n	c050a80 <mbedtls_sha256_update_ret+0x78>
                return MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED;
 c050ac8:	f06f 006f 	mvn.w	r0, #111	@ 0x6f
}
 c050acc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
                if (HAL_HASHEx_SHA224_Accmlt(&ctx->hhash, (uint8_t *)(input + ST_SHA256_BLOCK_SIZE + ctx->first - ctx->sbuf_len), (iter * ST_SHA256_BLOCK_SIZE)) != 0)
 c050ad0:	f7ee f9de 	bl	c03ee90 <HAL_HASHEx_SHA224_Accmlt>
 c050ad4:	e7f6      	b.n	c050ac4 <mbedtls_sha256_update_ret+0xbc>

0c050ad6 <mbedtls_sha256_finish_ret>:

int mbedtls_sha256_finish_ret(mbedtls_sha256_context *ctx, unsigned char output[32])
{
 c050ad6:	b573      	push	{r0, r1, r4, r5, r6, lr}
 c050ad8:	4604      	mov	r4, r0
    SHA256_VALIDATE_RET( ctx != NULL );
    SHA256_VALIDATE_RET( (unsigned char *)output != NULL );

#ifdef ST_HW_CONTEXT_SAVING
    /* restore hw context */
    HAL_HASH_ContextRestoring(&ctx->hhash, ctx->ctx_save_regs);
 c050ada:	1d06      	adds	r6, r0, #4
{
 c050adc:	460d      	mov	r5, r1
    HAL_HASH_ContextRestoring(&ctx->hhash, ctx->ctx_save_regs);
 c050ade:	f100 018d 	add.w	r1, r0, #141	@ 0x8d
 c050ae2:	4630      	mov	r0, r6
 c050ae4:	f7ee f8c8 	bl	c03ec78 <HAL_HASH_ContextRestoring>
#endif /* ST_HW_CONTEXT_SAVING */

    /* Last accumulation for pending bytes in sbuf_len, then trig processing and get digest */
    if (ctx->is224 == 0)
    {
        if (HAL_HASHEx_SHA256_Accmlt_End(&ctx->hhash, ctx->sbuf, ctx->sbuf_len, output, ST_SHA256_TIMEOUT) != 0)
 c050ae8:	4621      	mov	r1, r4
 c050aea:	2303      	movs	r3, #3
    if (ctx->is224 == 0)
 c050aec:	f851 0b48 	ldr.w	r0, [r1], #72
 c050af0:	f894 208c 	ldrb.w	r2, [r4, #140]	@ 0x8c
        if (HAL_HASHEx_SHA256_Accmlt_End(&ctx->hhash, ctx->sbuf, ctx->sbuf_len, output, ST_SHA256_TIMEOUT) != 0)
 c050af4:	9300      	str	r3, [sp, #0]
 c050af6:	462b      	mov	r3, r5
    if (ctx->is224 == 0)
 c050af8:	b958      	cbnz	r0, c050b12 <mbedtls_sha256_finish_ret+0x3c>
        if (HAL_HASHEx_SHA256_Accmlt_End(&ctx->hhash, ctx->sbuf, ctx->sbuf_len, output, ST_SHA256_TIMEOUT) != 0)
 c050afa:	4630      	mov	r0, r6
 c050afc:	f7ee f9dc 	bl	c03eeb8 <HAL_HASHEx_SHA256_Accmlt_End>
 c050b00:	b920      	cbnz	r0, c050b0c <mbedtls_sha256_finish_ret+0x36>
        {
            return MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED;
        }
    }

    ctx->sbuf_len = 0;
 c050b02:	2000      	movs	r0, #0
 c050b04:	f884 008c 	strb.w	r0, [r4, #140]	@ 0x8c

    return 0;
}
 c050b08:	b002      	add	sp, #8
 c050b0a:	bd70      	pop	{r4, r5, r6, pc}
            return MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED;
 c050b0c:	f06f 006f 	mvn.w	r0, #111	@ 0x6f
 c050b10:	e7fa      	b.n	c050b08 <mbedtls_sha256_finish_ret+0x32>
        if (HAL_HASHEx_SHA224_Accmlt_End(&ctx->hhash, ctx->sbuf, ctx->sbuf_len, output, ST_SHA256_TIMEOUT) != 0)
 c050b12:	4630      	mov	r0, r6
 c050b14:	f7ee f9c0 	bl	c03ee98 <HAL_HASHEx_SHA224_Accmlt_End>
 c050b18:	e7f2      	b.n	c050b00 <mbedtls_sha256_finish_ret+0x2a>
	...

0c050b1c <tfm_spm_hal_configure_default_isolation>:

#ifdef TFM_FIH_PROFILE_ON
fih_int tfm_spm_hal_configure_default_isolation(
                  uint32_t partition_idx,
                  const struct platform_data_t *platform_data)
{
 c050b1c:	4603      	mov	r3, r0
    /* plat data are ignored */
    return FIH_SUCCESS;
 c050b1e:	4a03      	ldr	r2, [pc, #12]	@ (c050b2c <tfm_spm_hal_configure_default_isolation+0x10>)
 c050b20:	e892 0003 	ldmia.w	r2, {r0, r1}
 c050b24:	e883 0003 	stmia.w	r3, {r0, r1}
}
 c050b28:	4618      	mov	r0, r3
 c050b2a:	4770      	bx	lr
 c050b2c:	30030924 	.word	0x30030924

0c050b30 <tfm_spm_hal_get_ns_VTOR>:


uint32_t tfm_spm_hal_get_ns_VTOR(void)
{
    return memory_regions.non_secure_code_start;
}
 c050b30:	4b01      	ldr	r3, [pc, #4]	@ (c050b38 <tfm_spm_hal_get_ns_VTOR+0x8>)
 c050b32:	6818      	ldr	r0, [r3, #0]
 c050b34:	4770      	bx	lr
 c050b36:	bf00      	nop
 c050b38:	0c05f92c 	.word	0x0c05f92c

0c050b3c <tfm_spm_hal_get_ns_MSP>:

uint32_t tfm_spm_hal_get_ns_MSP(void)
{
    return *((uint32_t *)memory_regions.non_secure_code_start);
 c050b3c:	4b01      	ldr	r3, [pc, #4]	@ (c050b44 <tfm_spm_hal_get_ns_MSP+0x8>)
 c050b3e:	681b      	ldr	r3, [r3, #0]
}
 c050b40:	6818      	ldr	r0, [r3, #0]
 c050b42:	4770      	bx	lr
 c050b44:	0c05f92c 	.word	0x0c05f92c

0c050b48 <tfm_spm_hal_get_ns_entry_point>:

uint32_t tfm_spm_hal_get_ns_entry_point(void)
{
    return *((uint32_t *)(memory_regions.non_secure_code_start+ 4));
 c050b48:	4b01      	ldr	r3, [pc, #4]	@ (c050b50 <tfm_spm_hal_get_ns_entry_point+0x8>)
 c050b4a:	681b      	ldr	r3, [r3, #0]
}
 c050b4c:	6858      	ldr	r0, [r3, #4]
 c050b4e:	4770      	bx	lr
 c050b50:	0c05f92c 	.word	0x0c05f92c

0c050b54 <tfm_spm_hal_set_secure_irq_priority>:
  if ((int32_t)(IRQn) >= 0)
 c050b54:	2800      	cmp	r0, #0
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 c050b56:	bfac      	ite	ge
 c050b58:	f100 4060 	addge.w	r0, r0, #3758096384	@ 0xe0000000
  }
  else
  {
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 c050b5c:	4b06      	ldrlt	r3, [pc, #24]	@ (c050b78 <tfm_spm_hal_set_secure_irq_priority+0x24>)
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 c050b5e:	f001 01f0 	and.w	r1, r1, #240	@ 0xf0
 c050b62:	bfab      	itete	ge
 c050b64:	f500 4061 	addge.w	r0, r0, #57600	@ 0xe100
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 c050b68:	f000 000f 	andlt.w	r0, r0, #15
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 c050b6c:	f880 1300 	strbge.w	r1, [r0, #768]	@ 0x300
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 c050b70:	5419      	strblt	r1, [r3, r0]
                                                        uint32_t priority)
{
    uint32_t quantized_priority = priority >> (8U - __NVIC_PRIO_BITS);
    NVIC_SetPriority(irq_line, quantized_priority);
    return TFM_PLAT_ERR_SUCCESS;
}
 c050b72:	2000      	movs	r0, #0
 c050b74:	4770      	bx	lr
 c050b76:	bf00      	nop
 c050b78:	e000ed14 	.word	0xe000ed14

0c050b7c <tfm_spm_hal_clear_pending_irq>:
  if ((int32_t)(IRQn) >= 0)
 c050b7c:	2800      	cmp	r0, #0
 c050b7e:	db08      	blt.n	c050b92 <tfm_spm_hal_clear_pending_irq+0x16>
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 c050b80:	2201      	movs	r2, #1
 c050b82:	0943      	lsrs	r3, r0, #5
 c050b84:	4903      	ldr	r1, [pc, #12]	@ (c050b94 <tfm_spm_hal_clear_pending_irq+0x18>)
 c050b86:	f000 001f 	and.w	r0, r0, #31
 c050b8a:	4082      	lsls	r2, r0
 c050b8c:	3360      	adds	r3, #96	@ 0x60
 c050b8e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

void tfm_spm_hal_clear_pending_irq(IRQn_Type irq_line)
{
    NVIC_ClearPendingIRQ(irq_line);
}
 c050b92:	4770      	bx	lr
 c050b94:	e000e100 	.word	0xe000e100

0c050b98 <tfm_spm_hal_enable_irq>:
  if ((int32_t)(IRQn) >= 0)
 c050b98:	2800      	cmp	r0, #0
 c050b9a:	db07      	blt.n	c050bac <tfm_spm_hal_enable_irq+0x14>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 c050b9c:	2301      	movs	r3, #1
 c050b9e:	0941      	lsrs	r1, r0, #5
 c050ba0:	4a03      	ldr	r2, [pc, #12]	@ (c050bb0 <tfm_spm_hal_enable_irq+0x18>)
 c050ba2:	f000 001f 	and.w	r0, r0, #31
 c050ba6:	4083      	lsls	r3, r0
 c050ba8:	f842 3021 	str.w	r3, [r2, r1, lsl #2]

void tfm_spm_hal_enable_irq(IRQn_Type irq_line)
{
    NVIC_EnableIRQ(irq_line);
}
 c050bac:	4770      	bx	lr
 c050bae:	bf00      	nop
 c050bb0:	e000e100 	.word	0xe000e100

0c050bb4 <tfm_spm_hal_disable_irq>:
  if ((int32_t)(IRQn) >= 0)
 c050bb4:	2800      	cmp	r0, #0
 c050bb6:	db0c      	blt.n	c050bd2 <tfm_spm_hal_disable_irq+0x1e>
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 c050bb8:	2201      	movs	r2, #1
 c050bba:	4906      	ldr	r1, [pc, #24]	@ (c050bd4 <tfm_spm_hal_disable_irq+0x20>)
 c050bbc:	0943      	lsrs	r3, r0, #5
 c050bbe:	f000 001f 	and.w	r0, r0, #31
 c050bc2:	4082      	lsls	r2, r0
 c050bc4:	3320      	adds	r3, #32
 c050bc6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  __ASM volatile ("dsb 0xF":::"memory");
 c050bca:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 c050bce:	f3bf 8f6f 	isb	sy

void tfm_spm_hal_disable_irq(IRQn_Type irq_line)
{
    NVIC_DisableIRQ(irq_line);
}
 c050bd2:	4770      	bx	lr
 c050bd4:	e000e100 	.word	0xe000e100

0c050bd8 <tfm_spm_hal_set_irq_target_state>:

enum irq_target_state_t tfm_spm_hal_set_irq_target_state(
                                           IRQn_Type irq_line,
                                           enum irq_target_state_t target_state)
{
 c050bd8:	4603      	mov	r3, r0
    uint32_t result;

    if (target_state == TFM_IRQ_TARGET_STATE_SECURE) {
 c050bda:	4608      	mov	r0, r1
 c050bdc:	b9c1      	cbnz	r1, c050c10 <tfm_spm_hal_set_irq_target_state+0x38>
  if ((int32_t)(IRQn) >= 0)
 c050bde:	2b00      	cmp	r3, #0
 c050be0:	db27      	blt.n	c050c32 <tfm_spm_hal_set_irq_target_state+0x5a>
    NVIC->ITNS[(((uint32_t)IRQn) >> 5UL)] &= ~((uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL)));
 c050be2:	2001      	movs	r0, #1
 c050be4:	095a      	lsrs	r2, r3, #5
 c050be6:	0092      	lsls	r2, r2, #2
 c050be8:	f102 4260 	add.w	r2, r2, #3758096384	@ 0xe0000000
 c050bec:	f502 4261 	add.w	r2, r2, #57600	@ 0xe100
 c050bf0:	f8d2 1280 	ldr.w	r1, [r2, #640]	@ 0x280
 c050bf4:	f003 031f 	and.w	r3, r3, #31
 c050bf8:	4098      	lsls	r0, r3
 c050bfa:	ea21 0100 	bic.w	r1, r1, r0
    NVIC->ITNS[(((uint32_t)IRQn) >> 5UL)] |=  ((uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL)));
 c050bfe:	f8c2 1280 	str.w	r1, [r2, #640]	@ 0x280
    return((uint32_t)(((NVIC->ITNS[(((uint32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
 c050c02:	f8d2 0280 	ldr.w	r0, [r2, #640]	@ 0x280
 c050c06:	40d8      	lsrs	r0, r3
 c050c08:	f000 0001 	and.w	r0, r0, #1
        result = NVIC_ClearTargetState(irq_line);
    } else {
        result = NVIC_SetTargetState(irq_line);
    }

    if (result) {
 c050c0c:	b2c0      	uxtb	r0, r0
 c050c0e:	4770      	bx	lr
  if ((int32_t)(IRQn) >= 0)
 c050c10:	2b00      	cmp	r3, #0
 c050c12:	db0d      	blt.n	c050c30 <tfm_spm_hal_set_irq_target_state+0x58>
    NVIC->ITNS[(((uint32_t)IRQn) >> 5UL)] |=  ((uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL)));
 c050c14:	2101      	movs	r1, #1
 c050c16:	095a      	lsrs	r2, r3, #5
 c050c18:	0092      	lsls	r2, r2, #2
 c050c1a:	f102 4260 	add.w	r2, r2, #3758096384	@ 0xe0000000
 c050c1e:	f502 4261 	add.w	r2, r2, #57600	@ 0xe100
 c050c22:	f8d2 0280 	ldr.w	r0, [r2, #640]	@ 0x280
 c050c26:	f003 031f 	and.w	r3, r3, #31
 c050c2a:	4099      	lsls	r1, r3
 c050c2c:	4301      	orrs	r1, r0
 c050c2e:	e7e6      	b.n	c050bfe <tfm_spm_hal_set_irq_target_state+0x26>
        return TFM_IRQ_TARGET_STATE_NON_SECURE;
    } else {
        return TFM_IRQ_TARGET_STATE_SECURE;
 c050c30:	2000      	movs	r0, #0
    }
}
 c050c32:	4770      	bx	lr

0c050c34 <tfm_spm_hal_enable_fault_handlers>:

enum tfm_plat_err_t tfm_spm_hal_enable_fault_handlers(void)
{
/*    return enable_fault_handlers();*/
    return TFM_PLAT_ERR_SUCCESS;
}
 c050c34:	2000      	movs	r0, #0
 c050c36:	4770      	bx	lr

0c050c38 <tfm_spm_hal_system_reset_cfg>:



enum tfm_plat_err_t tfm_spm_hal_system_reset_cfg(void)
 c050c38:	2000      	movs	r0, #0
 c050c3a:	4770      	bx	lr

0c050c3c <tfm_spm_hal_nvic_interrupt_target_state_cfg>:
}


enum tfm_plat_err_t tfm_spm_hal_nvic_interrupt_target_state_cfg(void)
{
    return nvic_interrupt_target_state_cfg();
 c050c3c:	f000 bb00 	b.w	c051240 <nvic_interrupt_target_state_cfg>

0c050c40 <tfm_spm_hal_nvic_interrupt_enable>:
}

enum tfm_plat_err_t tfm_spm_hal_nvic_interrupt_enable(void)
 c050c40:	2000      	movs	r0, #0
 c050c42:	4770      	bx	lr

0c050c44 <StSafeA_HostKeys_Init>:
  * @retval  0 if success. An error code otherwise
  */
int32_t StSafeA_HostKeys_Init()
{
  return 0;
}
 c050c44:	2000      	movs	r0, #0
 c050c46:	4770      	bx	lr

0c050c48 <StSafeA_Crypto_GetKeys>:
#if (USE_SELF_PROVISIONING)
  SE_Pairing(aHostCipherKey, aHostMacKey);
#endif
  return STSAFEA_OK;
#endif
}
 c050c48:	2000      	movs	r0, #0
 c050c4a:	4770      	bx	lr

0c050c4c <StSafeA_AES_MAC_Start>:
  *
  * @param   ppAesMacCtx : AES MAC context
  * @retval  None
  */
void StSafeA_AES_MAC_Start(void **ppAesMacCtx)
{
 c050c4c:	b538      	push	{r3, r4, r5, lr}
 c050c4e:	4604      	mov	r4, r0
#if defined MBEDTLS_AES_C & defined MBEDTLS_CIPHER_MODE_CBC
  *ppAesMacCtx = &cipher_ctx;
 c050c50:	4809      	ldr	r0, [pc, #36]	@ (c050c78 <StSafeA_AES_MAC_Start+0x2c>)
 c050c52:	6020      	str	r0, [r4, #0]

  mbedtls_cipher_init(*ppAesMacCtx);
 c050c54:	f004 f9dc 	bl	c055010 <mbedtls_cipher_init>
  (void)mbedtls_cipher_setup(*ppAesMacCtx, mbedtls_cipher_info_from_type(MBEDTLS_CIPHER_AES_128_ECB));
 c050c58:	2002      	movs	r0, #2
 c050c5a:	6825      	ldr	r5, [r4, #0]
 c050c5c:	f004 f9b6 	bl	c054fcc <mbedtls_cipher_info_from_type>
 c050c60:	4601      	mov	r1, r0
 c050c62:	4628      	mov	r0, r5
 c050c64:	f004 fbc4 	bl	c0553f0 <mbedtls_cipher_setup>
  (void)mbedtls_cipher_cmac_starts(*ppAesMacCtx, aHostMacKey, STSAFEA_HOST_KEY_LENGTH * 8U);
 c050c68:	6820      	ldr	r0, [r4, #0]
 c050c6a:	2280      	movs	r2, #128	@ 0x80
#endif /* MBEDTLS_AES_C - MBEDTLS_CIPHER_MODE_CBC */
}
 c050c6c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  (void)mbedtls_cipher_cmac_starts(*ppAesMacCtx, aHostMacKey, STSAFEA_HOST_KEY_LENGTH * 8U);
 c050c70:	4902      	ldr	r1, [pc, #8]	@ (c050c7c <StSafeA_AES_MAC_Start+0x30>)
 c050c72:	f004 bc5f 	b.w	c055534 <mbedtls_cipher_cmac_starts>
 c050c76:	bf00      	nop
 c050c78:	30030c10 	.word	0x30030c10
 c050c7c:	300308b8 	.word	0x300308b8

0c050c80 <StSafeA_AES_MAC_Update>:
  * @param   InDataLength : data buffer length
  * @param   pAesMacCtx : AES MAC context
  * @retval  None
  */
void StSafeA_AES_MAC_Update(uint8_t *pInData, uint16_t InDataLength, void *pAesMacCtx)
{
 c050c80:	4613      	mov	r3, r2
#if defined MBEDTLS_AES_C & defined MBEDTLS_CIPHER_MODE_CBC
  (void)mbedtls_cipher_cmac_update(pAesMacCtx, pInData, InDataLength);
 c050c82:	460a      	mov	r2, r1
 c050c84:	4601      	mov	r1, r0
 c050c86:	4618      	mov	r0, r3
 c050c88:	f004 bc7a 	b.w	c055580 <mbedtls_cipher_cmac_update>

0c050c8c <StSafeA_AES_MAC_LastUpdate>:
  * @param   pInData : data buffer
  * @param   InDataLength : data buffer length
  * @param   pAesMacCtx : AES MAC context
  * @retval  None
  */
void StSafeA_AES_MAC_LastUpdate(uint8_t *pInData, uint16_t InDataLength, void *pAesMacCtx)
 c050c8c:	4613      	mov	r3, r2
 c050c8e:	460a      	mov	r2, r1
 c050c90:	4601      	mov	r1, r0
 c050c92:	4618      	mov	r0, r3
 c050c94:	f004 bc74 	b.w	c055580 <mbedtls_cipher_cmac_update>

0c050c98 <StSafeA_AES_MAC_Final>:
  * @param   pOutMac : calculated MAC
  * @param   ppAesMacCtx : AES MAC context
  * @retval  None
  */
void StSafeA_AES_MAC_Final(uint8_t *pOutMac, void **ppAesMacCtx)
{
 c050c98:	b510      	push	{r4, lr}
 c050c9a:	460c      	mov	r4, r1
#if defined MBEDTLS_AES_C & defined MBEDTLS_CIPHER_MODE_CBC
  (void)mbedtls_cipher_cmac_finish(*ppAesMacCtx, pOutMac);
 c050c9c:	4601      	mov	r1, r0
 c050c9e:	6820      	ldr	r0, [r4, #0]
 c050ca0:	f004 fcd2 	bl	c055648 <mbedtls_cipher_cmac_finish>
  mbedtls_cipher_free(*ppAesMacCtx);
 c050ca4:	6820      	ldr	r0, [r4, #0]
 c050ca6:	f004 f9b7 	bl	c055018 <mbedtls_cipher_free>
  *ppAesMacCtx = NULL;
 c050caa:	2300      	movs	r3, #0
 c050cac:	6023      	str	r3, [r4, #0]
#endif /* MBEDTLS_AES_C - MBEDTLS_CIPHER_MODE_CBC */
}
 c050cae:	bd10      	pop	{r4, pc}

0c050cb0 <StSafeA_AES_ECB_Encrypt>:
  *            @arg STSAFEA_KEY_TYPE_AES_128: AES 128-bits
  *            @arg STSAFEA_KEY_TYPE_AES_256: AES 256-bits
  * @retval  0 if success, an error code otherwise
  */
int32_t StSafeA_AES_ECB_Encrypt(uint8_t *pInData, uint8_t *pOutData, uint8_t InAesType)
{
 c050cb0:	b570      	push	{r4, r5, r6, lr}
#ifdef MBEDTLS_AES_C
  int32_t status_code;
  mbedtls_aes_context aes;

  switch (InAesType)
 c050cb2:	2a01      	cmp	r2, #1
{
 c050cb4:	4605      	mov	r5, r0
 c050cb6:	460e      	mov	r6, r1
 c050cb8:	4614      	mov	r4, r2
 c050cba:	b0a4      	sub	sp, #144	@ 0x90
  switch (InAesType)
 c050cbc:	d819      	bhi.n	c050cf2 <StSafeA_AES_ECB_Encrypt+0x42>
  {
    case STSAFEA_KEY_TYPE_AES_128:
    case STSAFEA_KEY_TYPE_AES_256:
      mbedtls_aes_init(&aes);
 c050cbe:	4668      	mov	r0, sp
 c050cc0:	f7fa ff3e 	bl	c04bb40 <mbedtls_aes_init>
      status_code = mbedtls_aes_setkey_enc(&aes, aHostCipherKey, STSAFEA_AES_KEY_BITSIZE((uint32_t)InAesType));
 c050cc4:	1c62      	adds	r2, r4, #1
 c050cc6:	4668      	mov	r0, sp
 c050cc8:	490b      	ldr	r1, [pc, #44]	@ (c050cf8 <StSafeA_AES_ECB_Encrypt+0x48>)
 c050cca:	01d2      	lsls	r2, r2, #7
 c050ccc:	f7fa ff4c 	bl	c04bb68 <mbedtls_aes_setkey_enc>
      if ((status_code == 0) && (pInData != NULL) && (pOutData != NULL))
 c050cd0:	4604      	mov	r4, r0
 c050cd2:	b940      	cbnz	r0, c050ce6 <StSafeA_AES_ECB_Encrypt+0x36>
 c050cd4:	b13d      	cbz	r5, c050ce6 <StSafeA_AES_ECB_Encrypt+0x36>
 c050cd6:	b136      	cbz	r6, c050ce6 <StSafeA_AES_ECB_Encrypt+0x36>
      {
        status_code = mbedtls_aes_crypt_ecb(&aes, MBEDTLS_AES_ENCRYPT, pInData, pOutData);
 c050cd8:	4633      	mov	r3, r6
 c050cda:	462a      	mov	r2, r5
 c050cdc:	2101      	movs	r1, #1
 c050cde:	4668      	mov	r0, sp
 c050ce0:	f7fb f808 	bl	c04bcf4 <mbedtls_aes_crypt_ecb>
 c050ce4:	4604      	mov	r4, r0
      }
      mbedtls_aes_free(&aes);
 c050ce6:	4668      	mov	r0, sp
 c050ce8:	f7fa ff34 	bl	c04bb54 <mbedtls_aes_free>

  return status_code;
#else
  return 1;
#endif /* MBEDTLS_AES_C */
}
 c050cec:	4620      	mov	r0, r4
 c050cee:	b024      	add	sp, #144	@ 0x90
 c050cf0:	bd70      	pop	{r4, r5, r6, pc}
      status_code = 1;
 c050cf2:	2401      	movs	r4, #1
  return status_code;
 c050cf4:	e7fa      	b.n	c050cec <StSafeA_AES_ECB_Encrypt+0x3c>
 c050cf6:	bf00      	nop
 c050cf8:	300308c8 	.word	0x300308c8

0c050cfc <StSafeA_AES_CBC_Encrypt>:
  *            @arg STSAFEA_KEY_TYPE_AES_256: AES 256-bits
  * @retval  0 if success, an error code otherwise
  */
int32_t StSafeA_AES_CBC_Encrypt(uint8_t *pInData, uint16_t InDataLength, uint8_t *pOutData,
                                uint8_t *InInitialValue, uint8_t InAesType)
{
 c050cfc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 c050d00:	b0a6      	sub	sp, #152	@ 0x98
 c050d02:	f89d 40b0 	ldrb.w	r4, [sp, #176]	@ 0xb0
 c050d06:	4606      	mov	r6, r0
#if defined MBEDTLS_AES_C & defined MBEDTLS_CIPHER_MODE_CBC
  int32_t status_code;
  mbedtls_aes_context aes;

  switch (InAesType)
 c050d08:	2c01      	cmp	r4, #1
{
 c050d0a:	4688      	mov	r8, r1
 c050d0c:	4617      	mov	r7, r2
 c050d0e:	461d      	mov	r5, r3
  switch (InAesType)
 c050d10:	d81d      	bhi.n	c050d4e <StSafeA_AES_CBC_Encrypt+0x52>
  {
    case STSAFEA_KEY_TYPE_AES_128:
    case STSAFEA_KEY_TYPE_AES_256:
      mbedtls_aes_init(&aes);
 c050d12:	a802      	add	r0, sp, #8
 c050d14:	f7fa ff14 	bl	c04bb40 <mbedtls_aes_init>
      status_code = mbedtls_aes_setkey_enc(&aes, aHostCipherKey, STSAFEA_AES_KEY_BITSIZE((uint32_t)InAesType));
 c050d18:	1c62      	adds	r2, r4, #1
 c050d1a:	490e      	ldr	r1, [pc, #56]	@ (c050d54 <StSafeA_AES_CBC_Encrypt+0x58>)
 c050d1c:	01d2      	lsls	r2, r2, #7
 c050d1e:	a802      	add	r0, sp, #8
 c050d20:	f7fa ff22 	bl	c04bb68 <mbedtls_aes_setkey_enc>
      if ((status_code == 0) && (pInData != NULL) && (pOutData != NULL) && (InInitialValue != NULL))
 c050d24:	4604      	mov	r4, r0
 c050d26:	b958      	cbnz	r0, c050d40 <StSafeA_AES_CBC_Encrypt+0x44>
 c050d28:	b156      	cbz	r6, c050d40 <StSafeA_AES_CBC_Encrypt+0x44>
 c050d2a:	b14f      	cbz	r7, c050d40 <StSafeA_AES_CBC_Encrypt+0x44>
 c050d2c:	b145      	cbz	r5, c050d40 <StSafeA_AES_CBC_Encrypt+0x44>
      {
        status_code = mbedtls_aes_crypt_cbc(&aes, MBEDTLS_AES_ENCRYPT, InDataLength, InInitialValue, pInData, pOutData);
 c050d2e:	462b      	mov	r3, r5
 c050d30:	4642      	mov	r2, r8
 c050d32:	2101      	movs	r1, #1
 c050d34:	e9cd 6700 	strd	r6, r7, [sp]
 c050d38:	a802      	add	r0, sp, #8
 c050d3a:	f7fa ff19 	bl	c04bb70 <mbedtls_aes_crypt_cbc>
 c050d3e:	4604      	mov	r4, r0
      }
      mbedtls_aes_free(&aes);
 c050d40:	a802      	add	r0, sp, #8
 c050d42:	f7fa ff07 	bl	c04bb54 <mbedtls_aes_free>

  return status_code;
#else
  return 1;
#endif /* MBEDTLS_AES_C - MBEDTLS_CIPHER_MODE_CBC */
}
 c050d46:	4620      	mov	r0, r4
 c050d48:	b026      	add	sp, #152	@ 0x98
 c050d4a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      status_code = 1;
 c050d4e:	2401      	movs	r4, #1
  return status_code;
 c050d50:	e7f9      	b.n	c050d46 <StSafeA_AES_CBC_Encrypt+0x4a>
 c050d52:	bf00      	nop
 c050d54:	300308c8 	.word	0x300308c8

0c050d58 <StSafeA_AES_CBC_Decrypt>:
  *            @arg STSAFEA_KEY_TYPE_AES_256: AES 256-bits
  * @retval  0 if success, an error code otherwise
  */
int32_t StSafeA_AES_CBC_Decrypt(uint8_t *pInData, uint16_t InDataLength, uint8_t *pOutData,
                                uint8_t *InInitialValue, uint8_t InAesType)
{
 c050d58:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 c050d5c:	b0a6      	sub	sp, #152	@ 0x98
 c050d5e:	f89d 40b0 	ldrb.w	r4, [sp, #176]	@ 0xb0
 c050d62:	4606      	mov	r6, r0
#if defined MBEDTLS_AES_C & defined MBEDTLS_CIPHER_MODE_CBC
  int32_t status_code;
  mbedtls_aes_context aes;

  switch (InAesType)
 c050d64:	2c01      	cmp	r4, #1
{
 c050d66:	4688      	mov	r8, r1
 c050d68:	4617      	mov	r7, r2
 c050d6a:	461d      	mov	r5, r3
  switch (InAesType)
 c050d6c:	d81d      	bhi.n	c050daa <StSafeA_AES_CBC_Decrypt+0x52>
  {
    case STSAFEA_KEY_TYPE_AES_128:
    case STSAFEA_KEY_TYPE_AES_256:
      mbedtls_aes_init(&aes);
 c050d6e:	a802      	add	r0, sp, #8
 c050d70:	f7fa fee6 	bl	c04bb40 <mbedtls_aes_init>
      status_code = mbedtls_aes_setkey_dec(&aes, aHostCipherKey, STSAFEA_AES_KEY_BITSIZE((uint32_t)InAesType));
 c050d74:	1c62      	adds	r2, r4, #1
 c050d76:	490e      	ldr	r1, [pc, #56]	@ (c050db0 <StSafeA_AES_CBC_Decrypt+0x58>)
 c050d78:	01d2      	lsls	r2, r2, #7
 c050d7a:	a802      	add	r0, sp, #8
 c050d7c:	f7fa fef6 	bl	c04bb6c <mbedtls_aes_setkey_dec>
      if ((status_code == 0) && (pInData != NULL) && (pOutData != NULL) && (InInitialValue != NULL))
 c050d80:	4604      	mov	r4, r0
 c050d82:	b958      	cbnz	r0, c050d9c <StSafeA_AES_CBC_Decrypt+0x44>
 c050d84:	b156      	cbz	r6, c050d9c <StSafeA_AES_CBC_Decrypt+0x44>
 c050d86:	b14f      	cbz	r7, c050d9c <StSafeA_AES_CBC_Decrypt+0x44>
 c050d88:	b145      	cbz	r5, c050d9c <StSafeA_AES_CBC_Decrypt+0x44>
      {
        status_code = mbedtls_aes_crypt_cbc(&aes, MBEDTLS_AES_DECRYPT, InDataLength, InInitialValue, pInData, pOutData);
 c050d8a:	4601      	mov	r1, r0
 c050d8c:	462b      	mov	r3, r5
 c050d8e:	4642      	mov	r2, r8
 c050d90:	e9cd 6700 	strd	r6, r7, [sp]
 c050d94:	a802      	add	r0, sp, #8
 c050d96:	f7fa feeb 	bl	c04bb70 <mbedtls_aes_crypt_cbc>
 c050d9a:	4604      	mov	r4, r0
      }
      mbedtls_aes_free(&aes);
 c050d9c:	a802      	add	r0, sp, #8
 c050d9e:	f7fa fed9 	bl	c04bb54 <mbedtls_aes_free>

  return status_code;
#else
  return 1;
#endif /* MBEDTLS_AES_C - MBEDTLS_CIPHER_MODE_CBC */
}
 c050da2:	4620      	mov	r0, r4
 c050da4:	b026      	add	sp, #152	@ 0x98
 c050da6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      status_code = 1;
 c050daa:	2401      	movs	r4, #1
  return status_code;
 c050dac:	e7f9      	b.n	c050da2 <StSafeA_AES_CBC_Decrypt+0x4a>
 c050dae:	bf00      	nop
 c050db0:	300308c8 	.word	0x300308c8

0c050db4 <CRC16X25_Init>:
  * @retval  BSP status
  */
int32_t CRC16X25_Init(void)
{
  return STSAFEA_BUS_OK;
}
 c050db4:	2000      	movs	r0, #0
 c050db6:	4770      	bx	lr

0c050db8 <CRC_Compute>:
  * @param   pData2  : Pointer to 2nd input data buffer.
  * @param   Length2 : Size of 2nd input data buffer.
  * @retval  uint32_t CRC (returned value LSBs for CRC)
  */
uint32_t CRC_Compute(uint8_t *pData1, uint16_t Length1, uint8_t *pData2, uint16_t Length2)
{
 c050db8:	b5f0      	push	{r4, r5, r6, r7, lr}
  (void)Length1;
  uint16_t crc16 = 0;
  if ((pData1 != NULL) && (pData2 != NULL))
 c050dba:	b180      	cbz	r0, c050dde <CRC_Compute+0x26>
 c050dbc:	b392      	cbz	r2, c050e24 <CRC_Compute+0x6c>
#if (!STSAFEA_USE_OPTIMIZATION_CRC_TABLE)
    /* Instead of reflecting the data coming in, and the CRC coming in, and
       the CRC going out, simply reflect the polynomial and the operations.
       Only need to do that oncethrough the code.
       The reflected polynomial is 0x8408. */
    if (crc16_reflected_lookup_table[1] == 0x0000U)
 c050dbe:	4d1a      	ldr	r5, [pc, #104]	@ (c050e28 <CRC_Compute+0x70>)
    crc16 = StSafeA_Crc16_ccitt(pData1[0], pData2, Length2);
 c050dc0:	7806      	ldrb	r6, [r0, #0]
    if (crc16_reflected_lookup_table[1] == 0x0000U)
 c050dc2:	8868      	ldrh	r0, [r5, #2]
 c050dc4:	b160      	cbz	r0, c050de0 <CRC_Compute+0x28>
        crc16_reflected_lookup_table[dividend] = remainder;
      }
    }
#endif /* STSAFEA_USE_OPTIMIZATION_CRC_TABLE */

    ndx = (uint8_t)(0xFFU & (crc ^ Header));
 c050dc6:	43f6      	mvns	r6, r6
    crc = (crc16_reflected_lookup_table[ndx] ^ 0xFFU);
 c050dc8:	b2f6      	uxtb	r6, r6
 c050dca:	f835 1016 	ldrh.w	r1, [r5, r6, lsl #1]
 c050dce:	4413      	add	r3, r2
 c050dd0:	f081 01ff 	eor.w	r1, r1, #255	@ 0xff

    for (i = 0; i < Length; i++)
 c050dd4:	4293      	cmp	r3, r2
 c050dd6:	d11c      	bne.n	c050e12 <CRC_Compute+0x5a>
    crc16 = (uint16_t)SWAP2BYTES(crc16);
 c050dd8:	ba49      	rev16	r1, r1
    crc16 ^= 0xFFFFU;
 c050dda:	43c8      	mvns	r0, r1
 c050ddc:	b280      	uxth	r0, r0
}
 c050dde:	bdf0      	pop	{r4, r5, r6, r7, pc}
 c050de0:	462f      	mov	r7, r5
            remainder = (remainder >> 1) ^ 0x8408;
 c050de2:	f248 4c08 	movw	ip, #33800	@ 0x8408
      for (int dividend = 0; dividend < 256; ++dividend)
 c050de6:	2408      	movs	r4, #8
 c050de8:	b281      	uxth	r1, r0
          if (remainder & 1)
 c050dea:	f001 0e01 	and.w	lr, r1, #1
            remainder = (remainder >> 1) ^ 0x8408;
 c050dee:	0849      	lsrs	r1, r1, #1
          if (remainder & 1)
 c050df0:	f1be 0f00 	cmp.w	lr, #0
 c050df4:	d002      	beq.n	c050dfc <CRC_Compute+0x44>
            remainder = (remainder >> 1) ^ 0x8408;
 c050df6:	ea81 010c 	eor.w	r1, r1, ip
 c050dfa:	b289      	uxth	r1, r1
        for (uint8_t bit = 8; bit > 0; --bit)
 c050dfc:	3c01      	subs	r4, #1
 c050dfe:	f014 04ff 	ands.w	r4, r4, #255	@ 0xff
 c050e02:	d1f2      	bne.n	c050dea <CRC_Compute+0x32>
      for (int dividend = 0; dividend < 256; ++dividend)
 c050e04:	3001      	adds	r0, #1
 c050e06:	f5b0 7f80 	cmp.w	r0, #256	@ 0x100
        crc16_reflected_lookup_table[dividend] = remainder;
 c050e0a:	f827 1b02 	strh.w	r1, [r7], #2
      for (int dividend = 0; dividend < 256; ++dividend)
 c050e0e:	d1ea      	bne.n	c050de6 <CRC_Compute+0x2e>
 c050e10:	e7d9      	b.n	c050dc6 <CRC_Compute+0xe>
    {
      ndx = (uint8_t)(0xFFU & (crc ^ pData[i]));
 c050e12:	f812 4b01 	ldrb.w	r4, [r2], #1
 c050e16:	404c      	eors	r4, r1
      crc = (crc16_reflected_lookup_table[ndx] ^ (crc >> 8));
 c050e18:	b2e4      	uxtb	r4, r4
 c050e1a:	f835 0014 	ldrh.w	r0, [r5, r4, lsl #1]
 c050e1e:	ea80 2111 	eor.w	r1, r0, r1, lsr #8
    for (i = 0; i < Length; i++)
 c050e22:	e7d7      	b.n	c050dd4 <CRC_Compute+0x1c>
  uint16_t crc16 = 0;
 c050e24:	4610      	mov	r0, r2
 c050e26:	e7da      	b.n	c050dde <CRC_Compute+0x26>
 c050e28:	30030c54 	.word	0x30030c54

0c050e2c <HW_IO_Init>:
int32_t HW_IO_Init(void)
{
  GPIO_InitTypeDef GPIO_InitStruct;

  /* GPIO Ports Clock Enable */
  STSAFEA_VREG_GPIO_PORT_CLK_ENABLE();
 c050e2c:	4b1b      	ldr	r3, [pc, #108]	@ (c050e9c <HW_IO_Init+0x70>)
{
 c050e2e:	b510      	push	{r4, lr}
  STSAFEA_VREG_GPIO_PORT_CLK_ENABLE();
 c050e30:	f8d3 208c 	ldr.w	r2, [r3, #140]	@ 0x8c
{
 c050e34:	b086      	sub	sp, #24
  STSAFEA_VREG_GPIO_PORT_CLK_ENABLE();
 c050e36:	f042 0220 	orr.w	r2, r2, #32
 c050e3a:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
 c050e3e:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c

  /* Configure GPIO pin : RST/EN Pin */
  GPIO_InitStruct.Pin = STSAFEA_VREG_PIN;
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 c050e42:	f44f 6400 	mov.w	r4, #2048	@ 0x800
  STSAFEA_VREG_GPIO_PORT_CLK_ENABLE();
 c050e46:	f003 0320 	and.w	r3, r3, #32
 c050e4a:	9300      	str	r3, [sp, #0]
 c050e4c:	9b00      	ldr	r3, [sp, #0]
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 c050e4e:	2300      	movs	r3, #0
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(STSAFEA_VREG_GPIO_PORT, &GPIO_InitStruct);
 c050e50:	a901      	add	r1, sp, #4
 c050e52:	4813      	ldr	r0, [pc, #76]	@ (c050ea0 <HW_IO_Init+0x74>)
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 c050e54:	e9cd 4301 	strd	r4, r3, [sp, #4]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 c050e58:	e9cd 3303 	strd	r3, r3, [sp, #12]
  HAL_GPIO_Init(STSAFEA_VREG_GPIO_PORT, &GPIO_InitStruct);
 c050e5c:	f7ed f936 	bl	c03e0cc <HAL_GPIO_Init>

  // Check Board revision.
  // Rev-C: reading VREG pin will return 0 => enable = 1
  // Rev-D: reading VREG pin will return 1 => enable = 0
  GPIO_PinState enable = HAL_GPIO_ReadPin(STSAFEA_VREG_GPIO_PORT, STSAFEA_VREG_PIN) == GPIO_PIN_RESET ? GPIO_PIN_SET : GPIO_PIN_RESET;
 c050e60:	4621      	mov	r1, r4
 c050e62:	480f      	ldr	r0, [pc, #60]	@ (c050ea0 <HW_IO_Init+0x74>)
 c050e64:	f7ed fac6 	bl	c03e3f4 <HAL_GPIO_ReadPin>
 c050e68:	2800      	cmp	r0, #0

#if TFM_SPM_LOG_LEVEL >= TFM_SPM_LOG_LEVEL_INFO
  if(enable)
  {
      SPMLOG_INFMSG("Board: Rev C02\r\n");
 c050e6a:	bf0c      	ite	eq
 c050e6c:	480d      	ldreq	r0, [pc, #52]	@ (c050ea4 <HW_IO_Init+0x78>)
  }
  else
  {
      SPMLOG_INFMSG("Board: Rev D01\r\n");
 c050e6e:	480e      	ldrne	r0, [pc, #56]	@ (c050ea8 <HW_IO_Init+0x7c>)
      SPMLOG_INFMSG("Board: Rev C02\r\n");
 c050e70:	f04f 0111 	mov.w	r1, #17
  GPIO_PinState enable = HAL_GPIO_ReadPin(STSAFEA_VREG_GPIO_PORT, STSAFEA_VREG_PIN) == GPIO_PIN_RESET ? GPIO_PIN_SET : GPIO_PIN_RESET;
 c050e74:	bf0c      	ite	eq
 c050e76:	2401      	moveq	r4, #1
 c050e78:	2400      	movne	r4, #0
      SPMLOG_INFMSG("Board: Rev D01\r\n");
 c050e7a:	f00d f897 	bl	c05dfac <tfm_hal_output_spm_log>
  }
#endif

  /* Configure GPIO pin : RST/EN Pin */
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 c050e7e:	2301      	movs	r3, #1
  HAL_GPIO_Init(STSAFEA_VREG_GPIO_PORT, &GPIO_InitStruct);
 c050e80:	a901      	add	r1, sp, #4
 c050e82:	4807      	ldr	r0, [pc, #28]	@ (c050ea0 <HW_IO_Init+0x74>)
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 c050e84:	9302      	str	r3, [sp, #8]
  HAL_GPIO_Init(STSAFEA_VREG_GPIO_PORT, &GPIO_InitStruct);
 c050e86:	f7ed f921 	bl	c03e0cc <HAL_GPIO_Init>

  /* Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(STSAFEA_VREG_GPIO_PORT, STSAFEA_VREG_PIN, enable);
 c050e8a:	4622      	mov	r2, r4
 c050e8c:	f44f 6100 	mov.w	r1, #2048	@ 0x800
 c050e90:	4803      	ldr	r0, [pc, #12]	@ (c050ea0 <HW_IO_Init+0x74>)
 c050e92:	f7ed fab5 	bl	c03e400 <HAL_GPIO_WritePin>
  // STSAFE takes up to 50 ms to get ready, but it might take less.
  // The first command will use the retry mechanism to cop with this delay
  // HAL_Delay(50);

  return STSAFEA_BUS_OK;
}
 c050e96:	2000      	movs	r0, #0
 c050e98:	b006      	add	sp, #24
 c050e9a:	bd10      	pop	{r4, pc}
 c050e9c:	56020c00 	.word	0x56020c00
 c050ea0:	52021400 	.word	0x52021400
 c050ea4:	0c05f848 	.word	0x0c05f848
 c050ea8:	0c05f859 	.word	0x0c05f859

0c050eac <BSP_I2C2_Recv>:
  * @param  pData  Pointer to data buffer to read
  * @param  Length Data Length
  * @retval BSP status
  */
int32_t  BSP_I2C2_Recv(uint16_t DevAddr, uint8_t *pData, uint16_t Length)
{
 c050eac:	4613      	mov	r3, r2
  int32_t ret = STSAFEA_BUS_ERR;
  uint32_t hal_error;

  if (HAL_I2C_Master_Receive(hbus_i2c,
 c050eae:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
{
 c050eb2:	b513      	push	{r0, r1, r4, lr}
  if (HAL_I2C_Master_Receive(hbus_i2c,
 c050eb4:	4c08      	ldr	r4, [pc, #32]	@ (c050ed8 <BSP_I2C2_Recv+0x2c>)
 c050eb6:	9200      	str	r2, [sp, #0]
 c050eb8:	460a      	mov	r2, r1
 c050eba:	4601      	mov	r1, r0
 c050ebc:	6820      	ldr	r0, [r4, #0]
 c050ebe:	f7ee fa75 	bl	c03f3ac <HAL_I2C_Master_Receive>
 c050ec2:	b138      	cbz	r0, c050ed4 <BSP_I2C2_Recv+0x28>
    hal_error = HAL_I2C_GetError(hbus_i2c);
 c050ec4:	6820      	ldr	r0, [r4, #0]
 c050ec6:	f7ee fb0c 	bl	c03f4e2 <HAL_I2C_GetError>
      ret =  STSAFEA_BUS_ERR;
 c050eca:	2804      	cmp	r0, #4
 c050ecc:	bf0c      	ite	eq
 c050ece:	2001      	moveq	r0, #1
 c050ed0:	f04f 30ff 	movne.w	r0, #4294967295	@ 0xffffffff
      ret =  STSAFEA_BUS_ERR;
    }
  }

  return ret;
}
 c050ed4:	b002      	add	sp, #8
 c050ed6:	bd10      	pop	{r4, pc}
 c050ed8:	300308d8 	.word	0x300308d8

0c050edc <BSP_I2C2_DeInit>:
  * @retval None
  */
static void I2C2_MspDeInit(I2C_HandleTypeDef *hI2c)
{
  /* Disable I2C clock */
  __HAL_RCC_I2C2_CLK_DISABLE();
 c050edc:	4a0c      	ldr	r2, [pc, #48]	@ (c050f10 <BSP_I2C2_DeInit+0x34>)
{
 c050ede:	b510      	push	{r4, lr}
  __HAL_RCC_I2C2_CLK_DISABLE();
 c050ee0:	f8d2 309c 	ldr.w	r3, [r2, #156]	@ 0x9c

  /* DeInitialize peripheral GPIOs */
  HAL_GPIO_DeInit(BUS_I2C2_SDA_GPIO_PORT, BUS_I2C2_SDA_GPIO_PIN);
 c050ee4:	4c0b      	ldr	r4, [pc, #44]	@ (c050f14 <BSP_I2C2_DeInit+0x38>)
  __HAL_RCC_I2C2_CLK_DISABLE();
 c050ee6:	f423 0380 	bic.w	r3, r3, #4194304	@ 0x400000
 c050eea:	f8c2 309c 	str.w	r3, [r2, #156]	@ 0x9c
  HAL_GPIO_DeInit(BUS_I2C2_SDA_GPIO_PORT, BUS_I2C2_SDA_GPIO_PIN);
 c050eee:	4620      	mov	r0, r4
 c050ef0:	2120      	movs	r1, #32
 c050ef2:	f7ed f9fd 	bl	c03e2f0 <HAL_GPIO_DeInit>
  HAL_GPIO_DeInit(BUS_I2C2_SCL_GPIO_PORT, BUS_I2C2_SCL_GPIO_PIN);
 c050ef6:	2110      	movs	r1, #16
 c050ef8:	4620      	mov	r0, r4
 c050efa:	f7ed f9f9 	bl	c03e2f0 <HAL_GPIO_DeInit>
  if (HAL_I2C_DeInit(hbus_i2c) == HAL_OK)
 c050efe:	4b06      	ldr	r3, [pc, #24]	@ (c050f18 <BSP_I2C2_DeInit+0x3c>)
 c050f00:	6818      	ldr	r0, [r3, #0]
 c050f02:	f7ee f9a3 	bl	c03f24c <HAL_I2C_DeInit>
 c050f06:	3800      	subs	r0, #0
 c050f08:	bf18      	it	ne
 c050f0a:	2001      	movne	r0, #1
}
 c050f0c:	4240      	negs	r0, r0
 c050f0e:	bd10      	pop	{r4, pc}
 c050f10:	56020c00 	.word	0x56020c00
 c050f14:	52021c00 	.word	0x52021c00
 c050f18:	300308d8 	.word	0x300308d8

0c050f1c <BSP_I2C2_Send>:
{
 c050f1c:	4613      	mov	r3, r2
  if (HAL_I2C_Master_Transmit(hbus_i2c,
 c050f1e:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
{
 c050f22:	b513      	push	{r0, r1, r4, lr}
  if (HAL_I2C_Master_Transmit(hbus_i2c,
 c050f24:	4c08      	ldr	r4, [pc, #32]	@ (c050f48 <BSP_I2C2_Send+0x2c>)
 c050f26:	9200      	str	r2, [sp, #0]
 c050f28:	460a      	mov	r2, r1
 c050f2a:	4601      	mov	r1, r0
 c050f2c:	6820      	ldr	r0, [r4, #0]
 c050f2e:	f7ee f9a7 	bl	c03f280 <HAL_I2C_Master_Transmit>
 c050f32:	b138      	cbz	r0, c050f44 <BSP_I2C2_Send+0x28>
    hal_error = HAL_I2C_GetError(hbus_i2c);
 c050f34:	6820      	ldr	r0, [r4, #0]
 c050f36:	f7ee fad4 	bl	c03f4e2 <HAL_I2C_GetError>
      ret =  STSAFEA_BUS_ERR;
 c050f3a:	2804      	cmp	r0, #4
 c050f3c:	bf0c      	ite	eq
 c050f3e:	2001      	moveq	r0, #1
 c050f40:	f04f 30ff 	movne.w	r0, #4294967295	@ 0xffffffff
}
 c050f44:	b002      	add	sp, #8
 c050f46:	bd10      	pop	{r4, pc}
 c050f48:	300308d8 	.word	0x300308d8

0c050f4c <StSafeA_HW_Probe>:
  CurProbe = HwCtx;
 c050f4c:	4b0a      	ldr	r3, [pc, #40]	@ (c050f78 <StSafeA_HW_Probe+0x2c>)
 c050f4e:	6018      	str	r0, [r3, #0]
  HwCtx->IOInit     = HW_IO_Init;
 c050f50:	4b0a      	ldr	r3, [pc, #40]	@ (c050f7c <StSafeA_HW_Probe+0x30>)
 c050f52:	6003      	str	r3, [r0, #0]
  HwCtx->BusInit    = BSP_I2C2_Init;
 c050f54:	4b0a      	ldr	r3, [pc, #40]	@ (c050f80 <StSafeA_HW_Probe+0x34>)
 c050f56:	6043      	str	r3, [r0, #4]
  HwCtx->BusDeInit  = BSP_I2C2_DeInit;
 c050f58:	4b0a      	ldr	r3, [pc, #40]	@ (c050f84 <StSafeA_HW_Probe+0x38>)
 c050f5a:	6083      	str	r3, [r0, #8]
  HwCtx->BusSend    = BSP_I2C2_Send;
 c050f5c:	4b0a      	ldr	r3, [pc, #40]	@ (c050f88 <StSafeA_HW_Probe+0x3c>)
 c050f5e:	6103      	str	r3, [r0, #16]
  HwCtx->BusRecv    = BSP_I2C2_Recv;
 c050f60:	4b0a      	ldr	r3, [pc, #40]	@ (c050f8c <StSafeA_HW_Probe+0x40>)
 c050f62:	60c3      	str	r3, [r0, #12]
  HwCtx->CrcInit    = CRC16X25_Init;
 c050f64:	4b0a      	ldr	r3, [pc, #40]	@ (c050f90 <StSafeA_HW_Probe+0x44>)
 c050f66:	6183      	str	r3, [r0, #24]
  HwCtx->CrcCompute = CRC_Compute;
 c050f68:	4b0a      	ldr	r3, [pc, #40]	@ (c050f94 <StSafeA_HW_Probe+0x48>)
 c050f6a:	61c3      	str	r3, [r0, #28]
  HwCtx->TimeDelay  = HAL_Delay;
 c050f6c:	4b0a      	ldr	r3, [pc, #40]	@ (c050f98 <StSafeA_HW_Probe+0x4c>)
 c050f6e:	6143      	str	r3, [r0, #20]
  HwCtx->DevAddr    = STSAFEA_DEVICE_ADDRESS;
 c050f70:	2320      	movs	r3, #32
 c050f72:	8403      	strh	r3, [r0, #32]
}
 c050f74:	2000      	movs	r0, #0
 c050f76:	4770      	bx	lr
 c050f78:	30030e54 	.word	0x30030e54
 c050f7c:	0c050e2d 	.word	0x0c050e2d
 c050f80:	0c050fdd 	.word	0x0c050fdd
 c050f84:	0c050edd 	.word	0x0c050edd
 c050f88:	0c050f1d 	.word	0x0c050f1d
 c050f8c:	0c050ead 	.word	0x0c050ead
 c050f90:	0c050db5 	.word	0x0c050db5
 c050f94:	0c050db9 	.word	0x0c050db9
 c050f98:	0c03ca41 	.word	0x0c03ca41

0c050f9c <MX_I2C2_Init>:
  phi2c->Init.AddressingMode   = I2C_ADDRESSINGMODE_7BIT;
 c050f9c:	2300      	movs	r3, #0
 c050f9e:	2201      	movs	r2, #1
{
 c050fa0:	b510      	push	{r4, lr}
  phi2c->Init.AddressingMode   = I2C_ADDRESSINGMODE_7BIT;
 c050fa2:	e9c0 3202 	strd	r3, r2, [r0, #8]
  phi2c->Init.OwnAddress2      = 0;
 c050fa6:	e9c0 3304 	strd	r3, r3, [r0, #16]
  phi2c->Init.NoStretchMode    = I2C_NOSTRETCH_DISABLE;
 c050faa:	e9c0 3307 	strd	r3, r3, [r0, #28]
  phi2c->Init.Timing           = timing;
 c050fae:	6041      	str	r1, [r0, #4]
{
 c050fb0:	4604      	mov	r4, r0
  if (HAL_I2C_Init(phi2c) == HAL_OK)
 c050fb2:	f7ee f8f9 	bl	c03f1a8 <HAL_I2C_Init>
 c050fb6:	b108      	cbz	r0, c050fbc <MX_I2C2_Init+0x20>
  HAL_StatusTypeDef ret = HAL_ERROR;
 c050fb8:	2001      	movs	r0, #1
}
 c050fba:	bd10      	pop	{r4, pc}
    if (HAL_I2CEx_ConfigAnalogFilter(phi2c, I2C_ANALOGFILTER_DISABLE) == HAL_OK)
 c050fbc:	f44f 5180 	mov.w	r1, #4096	@ 0x1000
 c050fc0:	4620      	mov	r0, r4
 c050fc2:	f7ee fa90 	bl	c03f4e6 <HAL_I2CEx_ConfigAnalogFilter>
 c050fc6:	2800      	cmp	r0, #0
 c050fc8:	d1f6      	bne.n	c050fb8 <MX_I2C2_Init+0x1c>
      if (HAL_I2CEx_ConfigDigitalFilter(phi2c, I2C_ANALOG_FILTER_DELAY_DEFAULT) == HAL_OK)
 c050fca:	2102      	movs	r1, #2
 c050fcc:	4620      	mov	r0, r4
 c050fce:	f7ee fab0 	bl	c03f532 <HAL_I2CEx_ConfigDigitalFilter>
 c050fd2:	3800      	subs	r0, #0
 c050fd4:	bf18      	it	ne
 c050fd6:	2001      	movne	r0, #1
 c050fd8:	e7ef      	b.n	c050fba <MX_I2C2_Init+0x1e>
	...

0c050fdc <BSP_I2C2_Init>:
{
 c050fdc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  hbus_i2c->Instance  = I2C2;
 c050fe0:	4d2d      	ldr	r5, [pc, #180]	@ (c051098 <BSP_I2C2_Init+0xbc>)
 c050fe2:	4b2e      	ldr	r3, [pc, #184]	@ (c05109c <BSP_I2C2_Init+0xc0>)
 c050fe4:	6828      	ldr	r0, [r5, #0]
{
 c050fe6:	b088      	sub	sp, #32
  hbus_i2c->Instance  = I2C2;
 c050fe8:	6003      	str	r3, [r0, #0]
  if (HAL_I2C_GetState(hbus_i2c) == HAL_I2C_STATE_RESET)
 c050fea:	f7ee fa77 	bl	c03f4dc <HAL_I2C_GetState>
 c050fee:	4604      	mov	r4, r0
 c050ff0:	2800      	cmp	r0, #0
 c050ff2:	d14c      	bne.n	c05108e <BSP_I2C2_Init+0xb2>
  BUS_I2C2_CLK_ENABLE();
 c050ff4:	4b2a      	ldr	r3, [pc, #168]	@ (c0510a0 <BSP_I2C2_Init+0xc4>)
  gpio_init.Mode = GPIO_MODE_AF_OD;
 c050ff6:	f04f 0812 	mov.w	r8, #18
  BUS_I2C2_CLK_ENABLE();
 c050ffa:	f8d3 209c 	ldr.w	r2, [r3, #156]	@ 0x9c
  gpio_init.Alternate = BUS_I2C2_SDA_GPIO_AF;
 c050ffe:	2703      	movs	r7, #3
  BUS_I2C2_CLK_ENABLE();
 c051000:	f442 0280 	orr.w	r2, r2, #4194304	@ 0x400000
 c051004:	f8c3 209c 	str.w	r2, [r3, #156]	@ 0x9c
 c051008:	f8d3 209c 	ldr.w	r2, [r3, #156]	@ 0x9c
  gpio_init.Alternate = BUS_I2C2_SDA_GPIO_AF;
 c05100c:	2604      	movs	r6, #4
  BUS_I2C2_CLK_ENABLE();
 c05100e:	f402 0280 	and.w	r2, r2, #4194304	@ 0x400000
 c051012:	9200      	str	r2, [sp, #0]
 c051014:	9a00      	ldr	r2, [sp, #0]
  BUS_I2C2_SDA_GPIO_CLK_ENABLE();
 c051016:	f8d3 208c 	ldr.w	r2, [r3, #140]	@ 0x8c
  HAL_GPIO_Init(BUS_I2C2_SDA_GPIO_PORT, &gpio_init);
 c05101a:	a903      	add	r1, sp, #12
  BUS_I2C2_SDA_GPIO_CLK_ENABLE();
 c05101c:	f042 0280 	orr.w	r2, r2, #128	@ 0x80
 c051020:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
 c051024:	f8d3 208c 	ldr.w	r2, [r3, #140]	@ 0x8c
 c051028:	f002 0280 	and.w	r2, r2, #128	@ 0x80
 c05102c:	9201      	str	r2, [sp, #4]
 c05102e:	9a01      	ldr	r2, [sp, #4]
  BUS_I2C2_SCL_GPIO_CLK_ENABLE();
 c051030:	f8d3 208c 	ldr.w	r2, [r3, #140]	@ 0x8c
 c051034:	f042 0280 	orr.w	r2, r2, #128	@ 0x80
 c051038:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
 c05103c:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
  gpio_init.Pull = GPIO_NOPULL;
 c051040:	9005      	str	r0, [sp, #20]
  BUS_I2C2_SCL_GPIO_CLK_ENABLE();
 c051042:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 c051046:	9302      	str	r3, [sp, #8]
 c051048:	9b02      	ldr	r3, [sp, #8]
  gpio_init.Mode = GPIO_MODE_AF_OD;
 c05104a:	2320      	movs	r3, #32
  HAL_GPIO_Init(BUS_I2C2_SDA_GPIO_PORT, &gpio_init);
 c05104c:	4815      	ldr	r0, [pc, #84]	@ (c0510a4 <BSP_I2C2_Init+0xc8>)
  gpio_init.Mode = GPIO_MODE_AF_OD;
 c05104e:	e9cd 3803 	strd	r3, r8, [sp, #12]
  gpio_init.Alternate = BUS_I2C2_SDA_GPIO_AF;
 c051052:	e9cd 7606 	strd	r7, r6, [sp, #24]
  HAL_GPIO_Init(BUS_I2C2_SDA_GPIO_PORT, &gpio_init);
 c051056:	f7ed f839 	bl	c03e0cc <HAL_GPIO_Init>
  gpio_init.Pin = BUS_I2C2_SCL_GPIO_PIN;
 c05105a:	2310      	movs	r3, #16
  HAL_GPIO_Init(BUS_I2C2_SCL_GPIO_PORT, &gpio_init);
 c05105c:	4811      	ldr	r0, [pc, #68]	@ (c0510a4 <BSP_I2C2_Init+0xc8>)
 c05105e:	a903      	add	r1, sp, #12
  gpio_init.Mode = GPIO_MODE_AF_OD;
 c051060:	e9cd 3803 	strd	r3, r8, [sp, #12]
  gpio_init.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 c051064:	e9cd 4705 	strd	r4, r7, [sp, #20]
  gpio_init.Alternate = BUS_I2C2_SCL_GPIO_AF;
 c051068:	9607      	str	r6, [sp, #28]
  HAL_GPIO_Init(BUS_I2C2_SCL_GPIO_PORT, &gpio_init);
 c05106a:	f7ed f82f 	bl	c03e0cc <HAL_GPIO_Init>
    if (MX_I2C2_Init(hbus_i2c, BUS_I2C2_TIMING) == HAL_OK)
 c05106e:	490e      	ldr	r1, [pc, #56]	@ (c0510a8 <BSP_I2C2_Init+0xcc>)
 c051070:	6828      	ldr	r0, [r5, #0]
 c051072:	f7ff ff93 	bl	c050f9c <MX_I2C2_Init>
 c051076:	4601      	mov	r1, r0
 c051078:	b958      	cbnz	r0, c051092 <BSP_I2C2_Init+0xb6>
      if (HAL_I2CEx_ConfigAnalogFilter(hbus_i2c, I2C_ANALOGFILTER_ENABLE) == HAL_OK)
 c05107a:	6828      	ldr	r0, [r5, #0]
 c05107c:	f7ee fa33 	bl	c03f4e6 <HAL_I2CEx_ConfigAnalogFilter>
 c051080:	3800      	subs	r0, #0
 c051082:	bf18      	it	ne
 c051084:	2001      	movne	r0, #1
 c051086:	4240      	negs	r0, r0
}
 c051088:	b008      	add	sp, #32
 c05108a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    ret = STSAFEA_BUS_OK;
 c05108e:	2000      	movs	r0, #0
 c051090:	e7fa      	b.n	c051088 <BSP_I2C2_Init+0xac>
  int32_t ret = STSAFEA_BUS_ERR;
 c051092:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
  return ret;
 c051096:	e7f7      	b.n	c051088 <BSP_I2C2_Init+0xac>
 c051098:	300308d8 	.word	0x300308d8
 c05109c:	50005800 	.word	0x50005800
 c0510a0:	56020c00 	.word	0x56020c00
 c0510a4:	52021c00 	.word	0x52021c00
 c0510a8:	00f07bff 	.word	0x00f07bff

0c0510ac <StSafeA_Set_I2C_Address>:
  if (CurProbe != NULL)
 c0510ac:	4b02      	ldr	r3, [pc, #8]	@ (c0510b8 <StSafeA_Set_I2C_Address+0xc>)
 c0510ae:	681b      	ldr	r3, [r3, #0]
 c0510b0:	b103      	cbz	r3, c0510b4 <StSafeA_Set_I2C_Address+0x8>
    CurProbe->DevAddr = DevAddr;
 c0510b2:	8418      	strh	r0, [r3, #32]
}
 c0510b4:	2000      	movs	r0, #0
 c0510b6:	4770      	bx	lr
 c0510b8:	30030e54 	.word	0x30030e54

0c0510bc <gtzc_config_sram>:
static void gtzc_config_sram(uint32_t base, uint32_t max_size, uint32_t off_start, uint32_t off_end, uint32_t flag);
static void gtzc_internal_flash_priv(uint32_t offset_start, uint32_t offset_end);

/*------------------- Memory configuration functions -------------------------*/
static void  gtzc_config_sram(uint32_t base, uint32_t max_size, uint32_t off_start, uint32_t off_end, uint32_t flag)
{
 c0510bc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  /* by default SRAM is privileged secure */
  MPCBB_ConfigTypeDef MPCBB_desc;
  uint32_t secure_regwrite = 0xffffffff;
  uint32_t privilege_regwrite = 0xffffffff;
  uint32_t index;
  uint32_t block_start = (off_start) / (MPCBB_BLOCK_SIZE);
 c0510c0:	ea4f 2852 	mov.w	r8, r2, lsr #9
  uint32_t block_end = (off_end + 1) / (MPCBB_BLOCK_SIZE);
 c0510c4:	1c5e      	adds	r6, r3, #1

  /*  Check alignment to avoid further problem  */
  if ((off_start & (MPCBB_BLOCK_SIZE - 1)) ||
 c0510c6:	f3c2 0208 	ubfx	r2, r2, #0, #9
{
 c0510ca:	4607      	mov	r7, r0
 c0510cc:	460d      	mov	r5, r1
 c0510ce:	461c      	mov	r4, r3
 c0510d0:	b0c7      	sub	sp, #284	@ 0x11c
  uint32_t block_end = (off_end + 1) / (MPCBB_BLOCK_SIZE);
 c0510d2:	0a76      	lsrs	r6, r6, #9
  if ((off_start & (MPCBB_BLOCK_SIZE - 1)) ||
 c0510d4:	b92a      	cbnz	r2, c0510e2 <gtzc_config_sram+0x26>
     ((off_end & (MPCBB_BLOCK_SIZE - 1))!=(MPCBB_BLOCK_SIZE - 1)))
 c0510d6:	f3c3 0208 	ubfx	r2, r3, #0, #9
  if ((off_start & (MPCBB_BLOCK_SIZE - 1)) ||
 c0510da:	f240 13ff 	movw	r3, #511	@ 0x1ff
 c0510de:	429a      	cmp	r2, r3
 c0510e0:	d001      	beq.n	c0510e6 <gtzc_config_sram+0x2a>
    Error_Handler();
 c0510e2:	f001 fc41 	bl	c052968 <Error_Handler>
  if (off_end >  (max_size-1))
 c0510e6:	1e6b      	subs	r3, r5, #1
 c0510e8:	42a3      	cmp	r3, r4
 c0510ea:	d201      	bcs.n	c0510f0 <gtzc_config_sram+0x34>
    Error_Handler();
 c0510ec:	f001 fc3c 	bl	c052968 <Error_Handler>

  if (HAL_GTZC_MPCBB_GetConfigMem(base, &MPCBB_desc) != HAL_OK)
 c0510f0:	f10d 0a0c 	add.w	sl, sp, #12
 c0510f4:	4651      	mov	r1, sl
 c0510f6:	4638      	mov	r0, r7
 c0510f8:	f7ed fbcc 	bl	c03e894 <HAL_GTZC_MPCBB_GetConfigMem>
 c0510fc:	b108      	cbz	r0, c051102 <gtzc_config_sram+0x46>
  {
    Error_Handler();
 c0510fe:	f001 fc33 	bl	c052968 <Error_Handler>
  }
  /* compute index to start and to end */
  /* start and end index is on superblock */
  /* end index is highest supreblock */
  for (index = 0; index < (max_size/MPCBB_BLOCK_SIZE); index++)
 c051102:	f04f 39ff 	mov.w	r9, #4294967295	@ 0xffffffff
 c051106:	ea4f 2b55 	mov.w	fp, r5, lsr #9
 c05110a:	2400      	movs	r4, #0
 c05110c:	464d      	mov	r5, r9
      secure_regwrite = MPCBB_desc.AttributeConfig.MPCBB_SecConfig_array[index >> 5];
      privilege_regwrite = MPCBB_desc.AttributeConfig.MPCBB_PrivConfig_array[index >> 5];
    }
    if ((index >= block_start) && (index < block_end))
    {
      if (flag & FLAG_NSEC)
 c05110e:	9b50      	ldr	r3, [sp, #320]	@ 0x140
 c051110:	f003 0302 	and.w	r3, r3, #2
 c051114:	9300      	str	r3, [sp, #0]
    if (!(index & 0x1f))
 c051116:	f014 0c1f 	ands.w	ip, r4, #31
 c05111a:	d11b      	bne.n	c051154 <gtzc_config_sram+0x98>
      secure_regwrite = MPCBB_desc.AttributeConfig.MPCBB_SecConfig_array[index >> 5];
 c05111c:	0963      	lsrs	r3, r4, #5
 c05111e:	1c9a      	adds	r2, r3, #2
    if ((index >= block_start) && (index < block_end))
 c051120:	45a0      	cmp	r8, r4
      privilege_regwrite = MPCBB_desc.AttributeConfig.MPCBB_PrivConfig_array[index >> 5];
 c051122:	f103 0322 	add.w	r3, r3, #34	@ 0x22
      secure_regwrite = MPCBB_desc.AttributeConfig.MPCBB_SecConfig_array[index >> 5];
 c051126:	f85a 5022 	ldr.w	r5, [sl, r2, lsl #2]
      privilege_regwrite = MPCBB_desc.AttributeConfig.MPCBB_PrivConfig_array[index >> 5];
 c05112a:	f85a 9023 	ldr.w	r9, [sl, r3, lsl #2]
    if ((index >= block_start) && (index < block_end))
 c05112e:	d946      	bls.n	c0511be <gtzc_config_sram+0x102>
  for (index = 0; index < (max_size/MPCBB_BLOCK_SIZE); index++)
 c051130:	3401      	adds	r4, #1
 c051132:	455c      	cmp	r4, fp
 c051134:	d1ef      	bne.n	c051116 <gtzc_config_sram+0x5a>
            Error_Handler();
      }
    }
  }

  if ((uFlowStage == FLOW_STAGE_CFG) && (HAL_GTZC_MPCBB_ConfigMem(base, &MPCBB_desc) != HAL_OK))
 c051136:	4b23      	ldr	r3, [pc, #140]	@ (c0511c4 <gtzc_config_sram+0x108>)
 c051138:	681b      	ldr	r3, [r3, #0]
 c05113a:	f513 7f00 	cmn.w	r3, #512	@ 0x200
 c05113e:	d106      	bne.n	c05114e <gtzc_config_sram+0x92>
 c051140:	4651      	mov	r1, sl
 c051142:	4638      	mov	r0, r7
 c051144:	f7ed fb38 	bl	c03e7b8 <HAL_GTZC_MPCBB_ConfigMem>
 c051148:	b108      	cbz	r0, c05114e <gtzc_config_sram+0x92>
    /* FIX ME */
    Error_Handler();
 c05114a:	f001 fc0d 	bl	c052968 <Error_Handler>

}
 c05114e:	b047      	add	sp, #284	@ 0x11c
 c051150:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if ((index >= block_start) && (index < block_end))
 c051154:	45a0      	cmp	r8, r4
 c051156:	d80f      	bhi.n	c051178 <gtzc_config_sram+0xbc>
 c051158:	42a6      	cmp	r6, r4
 c05115a:	d90d      	bls.n	c051178 <gtzc_config_sram+0xbc>
        secure_regwrite &= ~(1 << (index & 0x1f));
 c05115c:	2301      	movs	r3, #1
 c05115e:	fa03 f00c 	lsl.w	r0, r3, ip
      if (flag & FLAG_NSEC)
 c051162:	9b00      	ldr	r3, [sp, #0]
 c051164:	b1d3      	cbz	r3, c05119c <gtzc_config_sram+0xe0>
        secure_regwrite &= ~(1 << (index & 0x1f));
 c051166:	ea25 0500 	bic.w	r5, r5, r0
      if (flag & FLAG_NPRIV)
 c05116a:	9b50      	ldr	r3, [sp, #320]	@ 0x140
 c05116c:	07db      	lsls	r3, r3, #31
        privilege_regwrite &=  ~(1 << (index & 0x1f));
 c05116e:	bf4c      	ite	mi
 c051170:	ea29 0900 	bicmi.w	r9, r9, r0
        privilege_regwrite |=  (1 << (index & 0x1f));
 c051174:	ea49 0900 	orrpl.w	r9, r9, r0
    if ((index & 0x1f) == 0x1f)
 c051178:	f1bc 0f1f 	cmp.w	ip, #31
 c05117c:	d1d8      	bne.n	c051130 <gtzc_config_sram+0x74>
      if (uFlowStage == FLOW_STAGE_CFG)
 c05117e:	4b11      	ldr	r3, [pc, #68]	@ (c0511c4 <gtzc_config_sram+0x108>)
      secure_regwrite = MPCBB_desc.AttributeConfig.MPCBB_SecConfig_array[index >> 5];
 c051180:	0960      	lsrs	r0, r4, #5
      if (uFlowStage == FLOW_STAGE_CFG)
 c051182:	681b      	ldr	r3, [r3, #0]
 c051184:	f100 0c02 	add.w	ip, r0, #2
 c051188:	f513 7f00 	cmn.w	r3, #512	@ 0x200
 c05118c:	f100 0022 	add.w	r0, r0, #34	@ 0x22
 c051190:	d106      	bne.n	c0511a0 <gtzc_config_sram+0xe4>
        MPCBB_desc.AttributeConfig.MPCBB_SecConfig_array[index >> 5] = secure_regwrite;
 c051192:	f84a 502c 	str.w	r5, [sl, ip, lsl #2]
        MPCBB_desc.AttributeConfig.MPCBB_PrivConfig_array[index >> 5] = privilege_regwrite;
 c051196:	f84a 9020 	str.w	r9, [sl, r0, lsl #2]
 c05119a:	e7c9      	b.n	c051130 <gtzc_config_sram+0x74>
        secure_regwrite |= (1 << (index & 0x1f));
 c05119c:	4305      	orrs	r5, r0
 c05119e:	e7e4      	b.n	c05116a <gtzc_config_sram+0xae>
        if (MPCBB_desc.AttributeConfig.MPCBB_SecConfig_array[index >> 5] != secure_regwrite )
 c0511a0:	f85a 302c 	ldr.w	r3, [sl, ip, lsl #2]
 c0511a4:	42ab      	cmp	r3, r5
 c0511a6:	d003      	beq.n	c0511b0 <gtzc_config_sram+0xf4>
 c0511a8:	9001      	str	r0, [sp, #4]
            Error_Handler();
 c0511aa:	f001 fbdd 	bl	c052968 <Error_Handler>
 c0511ae:	9801      	ldr	r0, [sp, #4]
        if (MPCBB_desc.AttributeConfig.MPCBB_PrivConfig_array[index >> 5] != privilege_regwrite)
 c0511b0:	f85a 0020 	ldr.w	r0, [sl, r0, lsl #2]
 c0511b4:	4548      	cmp	r0, r9
 c0511b6:	d0bb      	beq.n	c051130 <gtzc_config_sram+0x74>
            Error_Handler();
 c0511b8:	f001 fbd6 	bl	c052968 <Error_Handler>
 c0511bc:	e7b8      	b.n	c051130 <gtzc_config_sram+0x74>
    if ((index >= block_start) && (index < block_end))
 c0511be:	42a6      	cmp	r6, r4
 c0511c0:	d8cc      	bhi.n	c05115c <gtzc_config_sram+0xa0>
 c0511c2:	e7b5      	b.n	c051130 <gtzc_config_sram+0x74>
 c0511c4:	300308dc 	.word	0x300308dc

0c0511c8 <gtzc_internal_flash_priv.constprop.0>:

static void gtzc_internal_flash_priv(uint32_t offset_start, uint32_t offset_end)
 c0511c8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 c0511cc:	b088      	sub	sp, #32
{
#if defined(STM32U535xx) || defined(STM32U545xx)
  __IO uint32_t *PrivBB[2] = {&FLASH_S->PRIVBB1R1, &FLASH_S->PRIVBB2R1};
#else
  __IO uint32_t *PrivBB[8] = {&FLASH_S->PRIVBB1R1, &FLASH_S->PRIVBB1R2, &FLASH_S->PRIVBB1R3, &FLASH_S->PRIVBB1R4,
 c0511ce:	466c      	mov	r4, sp
 c0511d0:	4d19      	ldr	r5, [pc, #100]	@ (c051238 <gtzc_internal_flash_priv.constprop.0+0x70>)
static void gtzc_internal_flash_priv(uint32_t offset_start, uint32_t offset_end)
 c0511d2:	4606      	mov	r6, r0
  __IO uint32_t *PrivBB[8] = {&FLASH_S->PRIVBB1R1, &FLASH_S->PRIVBB1R2, &FLASH_S->PRIVBB1R3, &FLASH_S->PRIVBB1R4,
 c0511d4:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 c0511d6:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 c0511d8:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
                              &FLASH_S->PRIVBB2R1, &FLASH_S->PRIVBB2R2, &FLASH_S->PRIVBB2R3, &FLASH_S->PRIVBB2R4};
#endif /* defined(STM32U535xx) || defined(STM32U545xx) */
  __IO uint32_t *ptr;
  uint32_t regwrite = 0x0;
 c0511dc:	2500      	movs	r5, #0
  __IO uint32_t *PrivBB[8] = {&FLASH_S->PRIVBB1R1, &FLASH_S->PRIVBB1R2, &FLASH_S->PRIVBB1R3, &FLASH_S->PRIVBB1R4,
 c0511de:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
    /* clean register on index aligned */
    if (!(index & 0x1f)) {
      regwrite = 0x0;
    }
    if ((index >= block_start) && (index <= block_end)) {
      regwrite = regwrite | (1 << (index & 0x1f));
 c0511e2:	f04f 0801 	mov.w	r8, #1
  for (index = block_start & ~0x1f; index < ((sizeof(PrivBB)/sizeof(PrivBB[0])) << 5) ; index++) {
 c0511e6:	462c      	mov	r4, r5
    }
    /* write register when 32 sub block are set or last block to set  */
    if ((index & 0x1f) == 0x1f) {
      ptr = (uint32_t *)PrivBB[index >> 5];
      if (uFlowStage == FLOW_STAGE_CFG)
 c0511e8:	4f14      	ldr	r7, [pc, #80]	@ (c05123c <gtzc_internal_flash_priv.constprop.0+0x74>)
  block_end = block_end / FLASH_AREA_IMAGE_SECTOR_SIZE ;
 c0511ea:	0b76      	lsrs	r6, r6, #13
    if (!(index & 0x1f)) {
 c0511ec:	f014 031f 	ands.w	r3, r4, #31
 c0511f0:	d01e      	beq.n	c051230 <gtzc_internal_flash_priv.constprop.0+0x68>
    if ((index >= block_start) && (index <= block_end)) {
 c0511f2:	42a6      	cmp	r6, r4
 c0511f4:	d302      	bcc.n	c0511fc <gtzc_internal_flash_priv.constprop.0+0x34>
      regwrite = regwrite | (1 << (index & 0x1f));
 c0511f6:	fa08 f203 	lsl.w	r2, r8, r3
 c0511fa:	4315      	orrs	r5, r2
    if ((index & 0x1f) == 0x1f) {
 c0511fc:	2b1f      	cmp	r3, #31
 c0511fe:	d10a      	bne.n	c051216 <gtzc_internal_flash_priv.constprop.0+0x4e>
      ptr = (uint32_t *)PrivBB[index >> 5];
 c051200:	aa08      	add	r2, sp, #32
 c051202:	0963      	lsrs	r3, r4, #5
 c051204:	eb02 0383 	add.w	r3, r2, r3, lsl #2
      if (uFlowStage == FLOW_STAGE_CFG)
 c051208:	683a      	ldr	r2, [r7, #0]
      ptr = (uint32_t *)PrivBB[index >> 5];
 c05120a:	f853 3c20 	ldr.w	r3, [r3, #-32]
      if (uFlowStage == FLOW_STAGE_CFG)
 c05120e:	f512 7f00 	cmn.w	r2, #512	@ 0x200
 c051212:	d107      	bne.n	c051224 <gtzc_internal_flash_priv.constprop.0+0x5c>
        *ptr =  regwrite;
 c051214:	601d      	str	r5, [r3, #0]
  for (index = block_start & ~0x1f; index < ((sizeof(PrivBB)/sizeof(PrivBB[0])) << 5) ; index++) {
 c051216:	3401      	adds	r4, #1
 c051218:	f5b4 7f80 	cmp.w	r4, #256	@ 0x100
 c05121c:	d1e6      	bne.n	c0511ec <gtzc_internal_flash_priv.constprop.0+0x24>
      else if (*ptr != regwrite)
        Error_Handler();
    }
  }
}
 c05121e:	b008      	add	sp, #32
 c051220:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      else if (*ptr != regwrite)
 c051224:	681b      	ldr	r3, [r3, #0]
 c051226:	429d      	cmp	r5, r3
 c051228:	d0f5      	beq.n	c051216 <gtzc_internal_flash_priv.constprop.0+0x4e>
        Error_Handler();
 c05122a:	f001 fb9d 	bl	c052968 <Error_Handler>
 c05122e:	e7f2      	b.n	c051216 <gtzc_internal_flash_priv.constprop.0+0x4e>
    if ((index >= block_start) && (index <= block_end)) {
 c051230:	42a6      	cmp	r6, r4
      regwrite = 0x0;
 c051232:	461d      	mov	r5, r3
    if ((index >= block_start) && (index <= block_end)) {
 c051234:	d2df      	bcs.n	c0511f6 <gtzc_internal_flash_priv.constprop.0+0x2e>
 c051236:	e7ee      	b.n	c051216 <gtzc_internal_flash_priv.constprop.0+0x4e>
 c051238:	0c05f940 	.word	0x0c05f940
 c05123c:	300308dc 	.word	0x300308dc

0c051240 <nvic_interrupt_target_state_cfg>:
{
 c051240:	2300      	movs	r3, #0
    NVIC->ITNS[i] = 0xFFFFFFFF;
 c051242:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 c051246:	4a05      	ldr	r2, [pc, #20]	@ (c05125c <nvic_interrupt_target_state_cfg+0x1c>)
 c051248:	f103 01a0 	add.w	r1, r3, #160	@ 0xa0
  for (uint8_t i = 0; i < sizeof(NVIC->ITNS) / sizeof(NVIC->ITNS[0]); i++)
 c05124c:	3301      	adds	r3, #1
 c05124e:	2b10      	cmp	r3, #16
    NVIC->ITNS[i] = 0xFFFFFFFF;
 c051250:	f842 0021 	str.w	r0, [r2, r1, lsl #2]
  for (uint8_t i = 0; i < sizeof(NVIC->ITNS) / sizeof(NVIC->ITNS[0]); i++)
 c051254:	d1f8      	bne.n	c051248 <nvic_interrupt_target_state_cfg+0x8>
}
 c051256:	2000      	movs	r0, #0
 c051258:	4770      	bx	lr
 c05125a:	bf00      	nop
 c05125c:	e000e100 	.word	0xe000e100

0c051260 <pinmux_init_cfg>:
  __HAL_RCC_GPIOA_CLK_ENABLE();
 c051260:	4b47      	ldr	r3, [pc, #284]	@ (c051380 <pinmux_init_cfg+0x120>)
{
 c051262:	b530      	push	{r4, r5, lr}
  __HAL_RCC_GPIOA_CLK_ENABLE();
 c051264:	f8d3 208c 	ldr.w	r2, [r3, #140]	@ 0x8c
{
 c051268:	b08d      	sub	sp, #52	@ 0x34
  __HAL_RCC_GPIOA_CLK_ENABLE();
 c05126a:	f042 0201 	orr.w	r2, r2, #1
 c05126e:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
 c051272:	f8d3 208c 	ldr.w	r2, [r3, #140]	@ 0x8c
  GPIOA_S->SECCFGR = 0x0;
 c051276:	2400      	movs	r4, #0
  __HAL_RCC_GPIOA_CLK_ENABLE();
 c051278:	f002 0201 	and.w	r2, r2, #1
 c05127c:	9200      	str	r2, [sp, #0]
 c05127e:	9a00      	ldr	r2, [sp, #0]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 c051280:	f8d3 208c 	ldr.w	r2, [r3, #140]	@ 0x8c
{
 c051284:	4605      	mov	r5, r0
  __HAL_RCC_GPIOB_CLK_ENABLE();
 c051286:	f042 0202 	orr.w	r2, r2, #2
 c05128a:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
 c05128e:	f8d3 208c 	ldr.w	r2, [r3, #140]	@ 0x8c
 c051292:	f002 0202 	and.w	r2, r2, #2
 c051296:	9201      	str	r2, [sp, #4]
 c051298:	9a01      	ldr	r2, [sp, #4]
  __HAL_RCC_GPIOC_CLK_ENABLE();
 c05129a:	f8d3 208c 	ldr.w	r2, [r3, #140]	@ 0x8c
 c05129e:	f042 0204 	orr.w	r2, r2, #4
 c0512a2:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
 c0512a6:	f8d3 208c 	ldr.w	r2, [r3, #140]	@ 0x8c
 c0512aa:	f002 0204 	and.w	r2, r2, #4
 c0512ae:	9202      	str	r2, [sp, #8]
 c0512b0:	9a02      	ldr	r2, [sp, #8]
  __HAL_RCC_GPIOD_CLK_ENABLE();
 c0512b2:	f8d3 208c 	ldr.w	r2, [r3, #140]	@ 0x8c
 c0512b6:	f042 0208 	orr.w	r2, r2, #8
 c0512ba:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
 c0512be:	f8d3 208c 	ldr.w	r2, [r3, #140]	@ 0x8c
 c0512c2:	f002 0208 	and.w	r2, r2, #8
 c0512c6:	9203      	str	r2, [sp, #12]
 c0512c8:	9a03      	ldr	r2, [sp, #12]
  __HAL_RCC_GPIOE_CLK_ENABLE();
 c0512ca:	f8d3 208c 	ldr.w	r2, [r3, #140]	@ 0x8c
 c0512ce:	f042 0210 	orr.w	r2, r2, #16
 c0512d2:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
 c0512d6:	f8d3 208c 	ldr.w	r2, [r3, #140]	@ 0x8c
 c0512da:	f002 0210 	and.w	r2, r2, #16
 c0512de:	9204      	str	r2, [sp, #16]
 c0512e0:	9a04      	ldr	r2, [sp, #16]
  __HAL_RCC_GPIOF_CLK_ENABLE();
 c0512e2:	f8d3 208c 	ldr.w	r2, [r3, #140]	@ 0x8c
 c0512e6:	f042 0220 	orr.w	r2, r2, #32
 c0512ea:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
 c0512ee:	f8d3 208c 	ldr.w	r2, [r3, #140]	@ 0x8c
 c0512f2:	f002 0220 	and.w	r2, r2, #32
 c0512f6:	9205      	str	r2, [sp, #20]
 c0512f8:	9a05      	ldr	r2, [sp, #20]
  __HAL_RCC_GPIOG_CLK_ENABLE();
 c0512fa:	f8d3 208c 	ldr.w	r2, [r3, #140]	@ 0x8c
 c0512fe:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
 c051302:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
 c051306:	f8d3 208c 	ldr.w	r2, [r3, #140]	@ 0x8c
 c05130a:	f002 0240 	and.w	r2, r2, #64	@ 0x40
 c05130e:	9206      	str	r2, [sp, #24]
 c051310:	9a06      	ldr	r2, [sp, #24]
  __HAL_RCC_GPIOH_CLK_ENABLE();
 c051312:	f8d3 208c 	ldr.w	r2, [r3, #140]	@ 0x8c
 c051316:	f042 0280 	orr.w	r2, r2, #128	@ 0x80
 c05131a:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
 c05131e:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 c051322:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 c051326:	9307      	str	r3, [sp, #28]
 c051328:	9b07      	ldr	r3, [sp, #28]
  GPIOA_S->SECCFGR = 0x0;
 c05132a:	4b16      	ldr	r3, [pc, #88]	@ (c051384 <pinmux_init_cfg+0x124>)
 c05132c:	631c      	str	r4, [r3, #48]	@ 0x30
  GPIOB_S->SECCFGR = 0x0;
 c05132e:	f8c3 4430 	str.w	r4, [r3, #1072]	@ 0x430
  GPIOC_S->SECCFGR = 0x0;
 c051332:	f8c3 4830 	str.w	r4, [r3, #2096]	@ 0x830
  GPIOD_S->SECCFGR = 0x0;
 c051336:	f8c3 4c30 	str.w	r4, [r3, #3120]	@ 0xc30
  GPIOB_S->SECCFGR = 0x0;
 c05133a:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
  GPIOE_S->SECCFGR = 0x0;
 c05133e:	f8c3 4c30 	str.w	r4, [r3, #3120]	@ 0xc30
  GPIOC_S->SECCFGR = 0x0;
 c051342:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
  GPIOF_S->SECCFGR = 0x0;
 c051346:	f8c3 4c30 	str.w	r4, [r3, #3120]	@ 0xc30
  GPIOD_S->SECCFGR = 0x0;
 c05134a:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
  GPIOG_S->SECCFGR = 0x0;
 c05134e:	f8c3 4c30 	str.w	r4, [r3, #3120]	@ 0xc30
  GPIOE_S->SECCFGR = 0x0;
 c051352:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
  GPIOH_S->SECCFGR = 0x0;
 c051356:	f8c3 4c30 	str.w	r4, [r3, #3120]	@ 0xc30
  FIH_RET(fih_int_encode(TFM_PLAT_ERR_SUCCESS));
 c05135a:	f00a fad3 	bl	c05b904 <fih_cfi_decrement>

/* Convert an int to a fih_int, can be used to encode specific error codes. */
__attribute__((always_inline)) inline
fih_int fih_int_encode(int32_t x)
{
    fih_int ret = {x, x ^ _FIH_MASK_VALUE};
 c05135e:	4b0a      	ldr	r3, [pc, #40]	@ (c051388 <pinmux_init_cfg+0x128>)
 c051360:	940a      	str	r4, [sp, #40]	@ 0x28
 c051362:	aa0c      	add	r2, sp, #48	@ 0x30
 c051364:	930b      	str	r3, [sp, #44]	@ 0x2c
 c051366:	ab08      	add	r3, sp, #32
 c051368:	e912 0003 	ldmdb	r2, {r0, r1}
 c05136c:	e883 0003 	stmia.w	r3, {r0, r1}
    return ret;
 c051370:	e893 0003 	ldmia.w	r3, {r0, r1}
 c051374:	e885 0003 	stmia.w	r5, {r0, r1}
}
 c051378:	4628      	mov	r0, r5
 c05137a:	b00d      	add	sp, #52	@ 0x34
 c05137c:	bd30      	pop	{r4, r5, pc}
 c05137e:	bf00      	nop
 c051380:	56020c00 	.word	0x56020c00
 c051384:	52020000 	.word	0x52020000
 c051388:	a5c35a3c 	.word	0xa5c35a3c

0c05138c <sau_and_idau_cfg>:
{
 c05138c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if (uFlowStage == FLOW_STAGE_CFG)
 c051390:	4b6f      	ldr	r3, [pc, #444]	@ (c051550 <sau_and_idau_cfg+0x1c4>)
{
 c051392:	4606      	mov	r6, r0
  if (uFlowStage == FLOW_STAGE_CFG)
 c051394:	681b      	ldr	r3, [r3, #0]
{
 c051396:	b086      	sub	sp, #24
  if (uFlowStage == FLOW_STAGE_CFG)
 c051398:	f513 7f00 	cmn.w	r3, #512	@ 0x200
 c05139c:	d167      	bne.n	c05146e <sau_and_idau_cfg+0xe2>
    for (i = 0; i < ARRAY_SIZE(sau_init_cfg); i++)
 c05139e:	f04f 0800 	mov.w	r8, #0
    SCB->NSACR = (SCB->NSACR & ~(SCB_NSACR_CP10_Msk | SCB_NSACR_CP11_Msk)) |
 c0513a2:	4c6c      	ldr	r4, [pc, #432]	@ (c051554 <sau_and_idau_cfg+0x1c8>)
    FPU->FPCCR = (FPU->FPCCR & ~(FPU_FPCCR_TS_Msk | FPU_FPCCR_CLRONRETS_Msk | FPU_FPCCR_CLRONRET_Msk)) |
 c0513a4:	4a6c      	ldr	r2, [pc, #432]	@ (c051558 <sau_and_idau_cfg+0x1cc>)
    SCB->NSACR = (SCB->NSACR & ~(SCB_NSACR_CP10_Msk | SCB_NSACR_CP11_Msk)) |
 c0513a6:	f8d4 308c 	ldr.w	r3, [r4, #140]	@ 0x8c
 c0513aa:	4d6c      	ldr	r5, [pc, #432]	@ (c05155c <sau_and_idau_cfg+0x1d0>)
 c0513ac:	f443 6340 	orr.w	r3, r3, #3072	@ 0xc00
 c0513b0:	f8c4 308c 	str.w	r3, [r4, #140]	@ 0x8c
    FPU->FPCCR = (FPU->FPCCR & ~(FPU_FPCCR_TS_Msk | FPU_FPCCR_CLRONRETS_Msk | FPU_FPCCR_CLRONRET_Msk)) |
 c0513b4:	6b53      	ldr	r3, [r2, #52]	@ 0x34
      FLOW_CONTROL_STEP(uFlowProtectValue, sau_init_cfg[i].flow_step_enable,
 c0513b6:	4f6a      	ldr	r7, [pc, #424]	@ (c051560 <sau_and_idau_cfg+0x1d4>)
                 ((FPU_FPCCR_TS_VAL        << FPU_FPCCR_TS_Pos) & FPU_FPCCR_TS_Msk) |
 c0513b8:	f023 53e0 	bic.w	r3, r3, #469762048	@ 0x1c000000
                 ((FPU_FPCCR_CLRONRETS_VAL << FPU_FPCCR_CLRONRETS_Pos) & FPU_FPCCR_CLRONRETS_Msk) |
 c0513bc:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
    FPU->FPCCR = (FPU->FPCCR & ~(FPU_FPCCR_TS_Msk | FPU_FPCCR_CLRONRETS_Msk | FPU_FPCCR_CLRONRET_Msk)) |
 c0513c0:	6353      	str	r3, [r2, #52]	@ 0x34
  \brief   Disable SAU
  \details Disables the Security Attribution Unit (SAU).
 */
__STATIC_INLINE void TZ_SAU_Disable(void)
{
    SAU->CTRL &= ~(SAU_CTRL_ENABLE_Msk);
 c0513c2:	f8d4 30d0 	ldr.w	r3, [r4, #208]	@ 0xd0
 c0513c6:	f023 0301 	bic.w	r3, r3, #1
 c0513ca:	f8c4 30d0 	str.w	r3, [r4, #208]	@ 0xd0
      SAU->RNR = sau_init_cfg[i].RNR;
 c0513ce:	682b      	ldr	r3, [r5, #0]
 c0513d0:	f8c4 30d8 	str.w	r3, [r4, #216]	@ 0xd8
      SAU->RBAR = sau_init_cfg[i].RBAR & SAU_RBAR_BADDR_Msk;
 c0513d4:	686b      	ldr	r3, [r5, #4]
 c0513d6:	f023 031f 	bic.w	r3, r3, #31
 c0513da:	f8c4 30dc 	str.w	r3, [r4, #220]	@ 0xdc
                  (sau_init_cfg[i].nsc ? SAU_RLAR_NSC_Msk : 0U) |
 c0513de:	7b2a      	ldrb	r2, [r5, #12]
      SAU->RLAR = (sau_init_cfg[i].RLAR & SAU_RLAR_LADDR_Msk) |
 c0513e0:	68ab      	ldr	r3, [r5, #8]
                  (sau_init_cfg[i].nsc ? SAU_RLAR_NSC_Msk : 0U) |
 c0513e2:	3a00      	subs	r2, #0
 c0513e4:	bf18      	it	ne
 c0513e6:	2201      	movne	r2, #1
      SAU->RLAR = (sau_init_cfg[i].RLAR & SAU_RLAR_LADDR_Msk) |
 c0513e8:	f023 031f 	bic.w	r3, r3, #31
 c0513ec:	ea43 0342 	orr.w	r3, r3, r2, lsl #1
                  (sau_init_cfg[i].nsc ? SAU_RLAR_NSC_Msk : 0U) |
 c0513f0:	f043 0301 	orr.w	r3, r3, #1
      SAU->RLAR = (sau_init_cfg[i].RLAR & SAU_RLAR_LADDR_Msk) |
 c0513f4:	f8c4 30e0 	str.w	r3, [r4, #224]	@ 0xe0
      FLOW_CONTROL_STEP(uFlowProtectValue, sau_init_cfg[i].flow_step_enable,
 c0513f8:	683b      	ldr	r3, [r7, #0]
 c0513fa:	692a      	ldr	r2, [r5, #16]
 c0513fc:	4053      	eors	r3, r2
 c0513fe:	603b      	str	r3, [r7, #0]
 c051400:	683b      	ldr	r3, [r7, #0]
 c051402:	696a      	ldr	r2, [r5, #20]
 c051404:	429a      	cmp	r2, r3
 c051406:	d001      	beq.n	c05140c <sau_and_idau_cfg+0x80>
 c051408:	f001 faae 	bl	c052968 <Error_Handler>
    for (i = 0; i < ARRAY_SIZE(sau_init_cfg); i++)
 c05140c:	f108 0801 	add.w	r8, r8, #1
 c051410:	f1b8 0f06 	cmp.w	r8, #6
 c051414:	f105 0520 	add.w	r5, r5, #32
 c051418:	d1d9      	bne.n	c0513ce <sau_and_idau_cfg+0x42>
  __ASM volatile ("dsb 0xF":::"memory");
 c05141a:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 c05141e:	f3bf 8f6f 	isb	sy
    SAU->CTRL |=  (SAU_CTRL_ENABLE_Msk);
 c051422:	f8d4 30d0 	ldr.w	r3, [r4, #208]	@ 0xd0
 c051426:	f043 0301 	orr.w	r3, r3, #1
 c05142a:	f8c4 30d0 	str.w	r3, [r4, #208]	@ 0xd0
    FLOW_CONTROL_STEP(uFlowProtectValue, FLOW_STEP_SAU_EN, FLOW_CTRL_SAU_EN);
 c05142e:	683b      	ldr	r3, [r7, #0]
 c051430:	f483 33db 	eor.w	r3, r3, #112128	@ 0x1b600
 c051434:	f083 0396 	eor.w	r3, r3, #150	@ 0x96
 c051438:	603b      	str	r3, [r7, #0]
 c05143a:	683a      	ldr	r2, [r7, #0]
 c05143c:	4b49      	ldr	r3, [pc, #292]	@ (c051564 <sau_and_idau_cfg+0x1d8>)
 c05143e:	429a      	cmp	r2, r3
 c051440:	d001      	beq.n	c051446 <sau_and_idau_cfg+0xba>
 c051442:	f001 fa91 	bl	c052968 <Error_Handler>
  FIH_RET(fih_int_encode(TFM_PLAT_ERR_SUCCESS));
 c051446:	f00a fa5d 	bl	c05b904 <fih_cfi_decrement>
    fih_int ret = {x, x ^ _FIH_MASK_VALUE};
 c05144a:	2300      	movs	r3, #0
 c05144c:	9304      	str	r3, [sp, #16]
 c05144e:	4b46      	ldr	r3, [pc, #280]	@ (c051568 <sau_and_idau_cfg+0x1dc>)
 c051450:	aa06      	add	r2, sp, #24
 c051452:	9305      	str	r3, [sp, #20]
 c051454:	ab02      	add	r3, sp, #8
 c051456:	e912 0003 	ldmdb	r2, {r0, r1}
 c05145a:	e883 0003 	stmia.w	r3, {r0, r1}
    return ret;
 c05145e:	e893 0003 	ldmia.w	r3, {r0, r1}
 c051462:	e886 0003 	stmia.w	r6, {r0, r1}
}
 c051466:	4630      	mov	r0, r6
 c051468:	b006      	add	sp, #24
 c05146a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    for (i = 0; i < ARRAY_SIZE(sau_init_cfg); i++)
 c05146e:	f04f 0800 	mov.w	r8, #0
 c051472:	4d3a      	ldr	r5, [pc, #232]	@ (c05155c <sau_and_idau_cfg+0x1d0>)
      SAU->RNR = sau_init_cfg[i].RNR;
 c051474:	4f37      	ldr	r7, [pc, #220]	@ (c051554 <sau_and_idau_cfg+0x1c8>)
      FLOW_CONTROL_STEP(uFlowProtectValue, sau_init_cfg[i].flow_step_check,
 c051476:	4c3a      	ldr	r4, [pc, #232]	@ (c051560 <sau_and_idau_cfg+0x1d4>)
      SAU->RNR = sau_init_cfg[i].RNR;
 c051478:	6828      	ldr	r0, [r5, #0]
 c05147a:	f8c7 00d8 	str.w	r0, [r7, #216]	@ 0xd8
                  (sau_init_cfg[i].nsc ? SAU_RLAR_NSC_Msk : 0U) |
 c05147e:	7b29      	ldrb	r1, [r5, #12]
      rlar = (sau_init_cfg[i].RLAR & SAU_RLAR_LADDR_Msk) |
 c051480:	68ab      	ldr	r3, [r5, #8]
                  (sau_init_cfg[i].nsc ? SAU_RLAR_NSC_Msk : 0U) |
 c051482:	3900      	subs	r1, #0
 c051484:	bf18      	it	ne
 c051486:	2101      	movne	r1, #1
      rnr_reg = SAU->RNR;
 c051488:	f8d7 e0d8 	ldr.w	lr, [r7, #216]	@ 0xd8
      rbar = sau_init_cfg[i].RBAR & SAU_RBAR_BADDR_Msk;
 c05148c:	686a      	ldr	r2, [r5, #4]
      rlar = (sau_init_cfg[i].RLAR & SAU_RLAR_LADDR_Msk) |
 c05148e:	f023 031f 	bic.w	r3, r3, #31
 c051492:	ea43 0341 	orr.w	r3, r3, r1, lsl #1
      if ((rnr_reg != rnr) || (rbar_reg != rbar) || (rlar_reg != rlar))
 c051496:	4570      	cmp	r0, lr
      rbar_reg = SAU->RBAR;
 c051498:	f8d7 c0dc 	ldr.w	ip, [r7, #220]	@ 0xdc
      rbar = sau_init_cfg[i].RBAR & SAU_RBAR_BADDR_Msk;
 c05149c:	f022 021f 	bic.w	r2, r2, #31
      rlar_reg = SAU->RLAR;
 c0514a0:	f8d7 10e0 	ldr.w	r1, [r7, #224]	@ 0xe0
      rlar = (sau_init_cfg[i].RLAR & SAU_RLAR_LADDR_Msk) |
 c0514a4:	f043 0301 	orr.w	r3, r3, #1
      if ((rnr_reg != rnr) || (rbar_reg != rbar) || (rlar_reg != rlar))
 c0514a8:	d103      	bne.n	c0514b2 <sau_and_idau_cfg+0x126>
 c0514aa:	4562      	cmp	r2, ip
 c0514ac:	d101      	bne.n	c0514b2 <sau_and_idau_cfg+0x126>
 c0514ae:	428b      	cmp	r3, r1
 c0514b0:	d000      	beq.n	c0514b4 <sau_and_idau_cfg+0x128>
        while (1);
 c0514b2:	e7fe      	b.n	c0514b2 <sau_and_idau_cfg+0x126>
      FLOW_CONTROL_STEP(uFlowProtectValue, sau_init_cfg[i].flow_step_check,
 c0514b4:	6823      	ldr	r3, [r4, #0]
 c0514b6:	69aa      	ldr	r2, [r5, #24]
 c0514b8:	4053      	eors	r3, r2
 c0514ba:	6023      	str	r3, [r4, #0]
 c0514bc:	6823      	ldr	r3, [r4, #0]
 c0514be:	69ea      	ldr	r2, [r5, #28]
 c0514c0:	429a      	cmp	r2, r3
 c0514c2:	d001      	beq.n	c0514c8 <sau_and_idau_cfg+0x13c>
 c0514c4:	f001 fa50 	bl	c052968 <Error_Handler>
    for (i = 0; i < ARRAY_SIZE(sau_init_cfg); i++)
 c0514c8:	f108 0801 	add.w	r8, r8, #1
 c0514cc:	f1b8 0f06 	cmp.w	r8, #6
 c0514d0:	f105 0520 	add.w	r5, r5, #32
 c0514d4:	d1d0      	bne.n	c051478 <sau_and_idau_cfg+0xec>
    ctrl_reg = SAU->CTRL;
 c0514d6:	4b1f      	ldr	r3, [pc, #124]	@ (c051554 <sau_and_idau_cfg+0x1c8>)
 c0514d8:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
    if ((ctrl_reg && SAU_CTRL_ENABLE_Msk) != 1U)
 c0514dc:	b903      	cbnz	r3, c0514e0 <sau_and_idau_cfg+0x154>
        while (1);
 c0514de:	e7fe      	b.n	c0514de <sau_and_idau_cfg+0x152>
      FLOW_CONTROL_STEP(uFlowProtectValue, FLOW_STEP_SAU_CH, FLOW_CTRL_SAU_CH);
 c0514e0:	6823      	ldr	r3, [r4, #0]
 c0514e2:	f483 3372 	eor.w	r3, r3, #247808	@ 0x3c800
 c0514e6:	f483 73de 	eor.w	r3, r3, #444	@ 0x1bc
 c0514ea:	6023      	str	r3, [r4, #0]
 c0514ec:	6822      	ldr	r2, [r4, #0]
 c0514ee:	4b1f      	ldr	r3, [pc, #124]	@ (c05156c <sau_and_idau_cfg+0x1e0>)
 c0514f0:	429a      	cmp	r2, r3
 c0514f2:	d001      	beq.n	c0514f8 <sau_and_idau_cfg+0x16c>
 c0514f4:	f001 fa38 	bl	c052968 <Error_Handler>
    __IO uint32_t read_reg = (uint32_t) &SYSCFG->CSLCKR;
 c0514f8:	4b1d      	ldr	r3, [pc, #116]	@ (c051570 <sau_and_idau_cfg+0x1e4>)
 c0514fa:	9300      	str	r3, [sp, #0]
    __HAL_RCC_SYSCFG_CLK_ENABLE();
 c0514fc:	4b1d      	ldr	r3, [pc, #116]	@ (c051574 <sau_and_idau_cfg+0x1e8>)
 c0514fe:	f8d3 20a8 	ldr.w	r2, [r3, #168]	@ 0xa8
 c051502:	f042 0202 	orr.w	r2, r2, #2
 c051506:	f8c3 20a8 	str.w	r2, [r3, #168]	@ 0xa8
 c05150a:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
    SYSCFG->CSLCKR |= SYSCFG_CSLCKR_LOCKSAU;
 c05150e:	4a1a      	ldr	r2, [pc, #104]	@ (c051578 <sau_and_idau_cfg+0x1ec>)
    __HAL_RCC_SYSCFG_CLK_ENABLE();
 c051510:	f003 0302 	and.w	r3, r3, #2
 c051514:	9301      	str	r3, [sp, #4]
 c051516:	9b01      	ldr	r3, [sp, #4]
    SYSCFG->CSLCKR |= SYSCFG_CSLCKR_LOCKSAU;
 c051518:	6913      	ldr	r3, [r2, #16]
 c05151a:	f043 0304 	orr.w	r3, r3, #4
 c05151e:	6113      	str	r3, [r2, #16]
    FLOW_CONTROL_STEP(uFlowProtectValue, FLOW_STEP_SAU_LCK, FLOW_CTRL_SAU_LCK);
 c051520:	6822      	ldr	r2, [r4, #0]
 c051522:	4b16      	ldr	r3, [pc, #88]	@ (c05157c <sau_and_idau_cfg+0x1f0>)
 c051524:	4053      	eors	r3, r2
 c051526:	6023      	str	r3, [r4, #0]
 c051528:	6822      	ldr	r2, [r4, #0]
 c05152a:	4b15      	ldr	r3, [pc, #84]	@ (c051580 <sau_and_idau_cfg+0x1f4>)
 c05152c:	429a      	cmp	r2, r3
 c05152e:	d001      	beq.n	c051534 <sau_and_idau_cfg+0x1a8>
 c051530:	f001 fa1a 	bl	c052968 <Error_Handler>
    if (!((*(uint32_t *)read_reg) &  SYSCFG_CSLCKR_LOCKSAU))
 c051534:	9b00      	ldr	r3, [sp, #0]
 c051536:	681b      	ldr	r3, [r3, #0]
 c051538:	075b      	lsls	r3, r3, #29
 c05153a:	d401      	bmi.n	c051540 <sau_and_idau_cfg+0x1b4>
        Error_Handler();
 c05153c:	f001 fa14 	bl	c052968 <Error_Handler>
    FLOW_CONTROL_STEP(uFlowProtectValue, FLOW_STEP_SAU_LCK_CH, FLOW_CTRL_SAU_LCK_CH);
 c051540:	6822      	ldr	r2, [r4, #0]
 c051542:	4b10      	ldr	r3, [pc, #64]	@ (c051584 <sau_and_idau_cfg+0x1f8>)
 c051544:	4053      	eors	r3, r2
 c051546:	6023      	str	r3, [r4, #0]
 c051548:	6822      	ldr	r2, [r4, #0]
 c05154a:	4b0f      	ldr	r3, [pc, #60]	@ (c051588 <sau_and_idau_cfg+0x1fc>)
 c05154c:	e777      	b.n	c05143e <sau_and_idau_cfg+0xb2>
 c05154e:	bf00      	nop
 c051550:	300308dc 	.word	0x300308dc
 c051554:	e000ed00 	.word	0xe000ed00
 c051558:	e000ef00 	.word	0xe000ef00
 c05155c:	0c05f86c 	.word	0x0c05f86c
 c051560:	300308e0 	.word	0x300308e0
 c051564:	0006a1f5 	.word	0x0006a1f5
 c051568:	a5c35a3c 	.word	0xa5c35a3c
 c05156c:	00068371 	.word	0x00068371
 c051570:	56000410 	.word	0x56000410
 c051574:	56020c00 	.word	0x56020c00
 c051578:	56000400 	.word	0x56000400
 c05157c:	0052295a 	.word	0x0052295a
 c051580:	0054aa2b 	.word	0x0054aa2b
 c051584:	005291ac 	.word	0x005291ac
 c051588:	00063b87 	.word	0x00063b87

0c05158c <gtzc_init_cfg>:
#ifdef TFM_FIH_PROFILE_ON
fih_int gtzc_init_cfg(void)
#else
void gtzc_init_cfg(void)
#endif
{
 c05158c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  uint32_t gtzc_periph_att;

  if (uFlowStage == FLOW_STAGE_CFG)
 c051590:	4b9f      	ldr	r3, [pc, #636]	@ (c051810 <gtzc_init_cfg+0x284>)
    /* Enable GTZC clock */
    __HAL_RCC_GTZC1_CLK_ENABLE();
    __HAL_RCC_GTZC2_CLK_ENABLE();
    /* assume non secure ram is only in SRAM 1 , SRAM 2 is reserved for secure */
    gtzc_config_sram(SRAM1_BASE, SRAM1_SIZE, 0, SRAM1_SIZE -1, FLAG_NPRIV | FLAG_NSEC);
    if (DATA_NPRIV_START <=(SRAM2_BASE + SRAM2_SIZE))
 c051592:	4da0      	ldr	r5, [pc, #640]	@ (c051814 <gtzc_init_cfg+0x288>)
  if (uFlowStage == FLOW_STAGE_CFG)
 c051594:	681b      	ldr	r3, [r3, #0]
{
 c051596:	b0a6      	sub	sp, #152	@ 0x98
  if (uFlowStage == FLOW_STAGE_CFG)
 c051598:	f513 7f00 	cmn.w	r3, #512	@ 0x200
{
 c05159c:	4606      	mov	r6, r0
 c05159e:	4c9e      	ldr	r4, [pc, #632]	@ (c051818 <gtzc_init_cfg+0x28c>)
 c0515a0:	f105 484f 	add.w	r8, r5, #3472883712	@ 0xcf000000
 c0515a4:	af08      	add	r7, sp, #32
  if (uFlowStage == FLOW_STAGE_CFG)
 c0515a6:	f040 8173 	bne.w	c051890 <gtzc_init_cfg+0x304>
    if (!(SYSCFG->CSLCKR & SYSCFG_CSLCKR_LOCKSVTAIRCR))
 c0515aa:	4b9c      	ldr	r3, [pc, #624]	@ (c05181c <gtzc_init_cfg+0x290>)
 c0515ac:	691b      	ldr	r3, [r3, #16]
 c0515ae:	07da      	lsls	r2, r3, #31
 c0515b0:	d401      	bmi.n	c0515b6 <gtzc_init_cfg+0x2a>
        Error_Handler();
 c0515b2:	f001 f9d9 	bl	c052968 <Error_Handler>
    FLOW_CONTROL_STEP(uFlowProtectValue, FLOW_STEP_GTZC_VTOR_LCK, FLOW_CTRL_GTZC_VTOR_LCK);
 c0515b6:	6823      	ldr	r3, [r4, #0]
 c0515b8:	f483 3327 	eor.w	r3, r3, #171008	@ 0x29c00
 c0515bc:	f083 03f6 	eor.w	r3, r3, #246	@ 0xf6
 c0515c0:	6023      	str	r3, [r4, #0]
 c0515c2:	6822      	ldr	r2, [r4, #0]
 c0515c4:	4b96      	ldr	r3, [pc, #600]	@ (c051820 <gtzc_init_cfg+0x294>)
 c0515c6:	429a      	cmp	r2, r3
 c0515c8:	d001      	beq.n	c0515ce <gtzc_init_cfg+0x42>
 c0515ca:	f001 f9cd 	bl	c052968 <Error_Handler>
    if( (SCB->AIRCR & SCB_AIRCR_PRIS_Msk) == 0 )
 c0515ce:	4b95      	ldr	r3, [pc, #596]	@ (c051824 <gtzc_init_cfg+0x298>)
 c0515d0:	68db      	ldr	r3, [r3, #12]
 c0515d2:	045b      	lsls	r3, r3, #17
 c0515d4:	d401      	bmi.n	c0515da <gtzc_init_cfg+0x4e>
      Error_Handler();
 c0515d6:	f001 f9c7 	bl	c052968 <Error_Handler>
    FLOW_CONTROL_STEP(uFlowProtectValue, FLOW_STEP_GTZC_PRIS_EN, FLOW_CTRL_GTZC_PRIS_EN);
 c0515da:	6823      	ldr	r3, [r4, #0]
 c0515dc:	f483 33aa 	eor.w	r3, r3, #87040	@ 0x15400
 c0515e0:	f083 03b5 	eor.w	r3, r3, #181	@ 0xb5
 c0515e4:	6023      	str	r3, [r4, #0]
 c0515e6:	6822      	ldr	r2, [r4, #0]
 c0515e8:	4b8f      	ldr	r3, [pc, #572]	@ (c051828 <gtzc_init_cfg+0x29c>)
 c0515ea:	429a      	cmp	r2, r3
 c0515ec:	d001      	beq.n	c0515f2 <gtzc_init_cfg+0x66>
 c0515ee:	f001 f9bb 	bl	c052968 <Error_Handler>
    __HAL_RCC_GTZC1_CLK_ENABLE();
 c0515f2:	4b8e      	ldr	r3, [pc, #568]	@ (c05182c <gtzc_init_cfg+0x2a0>)
    if (DATA_NPRIV_START <=(SRAM2_BASE + SRAM2_SIZE))
 c0515f4:	f8df 9238 	ldr.w	r9, [pc, #568]	@ c051830 <gtzc_init_cfg+0x2a4>
    __HAL_RCC_GTZC1_CLK_ENABLE();
 c0515f8:	f8d3 2088 	ldr.w	r2, [r3, #136]	@ 0x88
    gtzc_config_sram(SRAM1_BASE, SRAM1_SIZE, 0, SRAM1_SIZE -1, FLAG_NPRIV | FLAG_NSEC);
 c0515fc:	f44f 3140 	mov.w	r1, #196608	@ 0x30000
    __HAL_RCC_GTZC1_CLK_ENABLE();
 c051600:	f042 7280 	orr.w	r2, r2, #16777216	@ 0x1000000
 c051604:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
 c051608:	f8d3 2088 	ldr.w	r2, [r3, #136]	@ 0x88
    gtzc_config_sram(SRAM1_BASE, SRAM1_SIZE, 0, SRAM1_SIZE -1, FLAG_NPRIV | FLAG_NSEC);
 c05160c:	f04f 5040 	mov.w	r0, #805306368	@ 0x30000000
    __HAL_RCC_GTZC1_CLK_ENABLE();
 c051610:	f002 7280 	and.w	r2, r2, #16777216	@ 0x1000000
 c051614:	9203      	str	r2, [sp, #12]
 c051616:	9a03      	ldr	r2, [sp, #12]
    __HAL_RCC_GTZC2_CLK_ENABLE();
 c051618:	f8d3 2094 	ldr.w	r2, [r3, #148]	@ 0x94
 c05161c:	f442 5280 	orr.w	r2, r2, #4096	@ 0x1000
 c051620:	f8c3 2094 	str.w	r2, [r3, #148]	@ 0x94
 c051624:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
    gtzc_config_sram(SRAM1_BASE, SRAM1_SIZE, 0, SRAM1_SIZE -1, FLAG_NPRIV | FLAG_NSEC);
 c051628:	2200      	movs	r2, #0
    __HAL_RCC_GTZC2_CLK_ENABLE();
 c05162a:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
 c05162e:	9304      	str	r3, [sp, #16]
 c051630:	9b04      	ldr	r3, [sp, #16]
    gtzc_config_sram(SRAM1_BASE, SRAM1_SIZE, 0, SRAM1_SIZE -1, FLAG_NPRIV | FLAG_NSEC);
 c051632:	2303      	movs	r3, #3
 c051634:	9300      	str	r3, [sp, #0]
 c051636:	4b7f      	ldr	r3, [pc, #508]	@ (c051834 <gtzc_init_cfg+0x2a8>)
 c051638:	f7ff fd40 	bl	c0510bc <gtzc_config_sram>
    if (DATA_NPRIV_START <=(SRAM2_BASE + SRAM2_SIZE))
 c05163c:	454d      	cmp	r5, r9
 c05163e:	f04f 0500 	mov.w	r5, #0
    {
        gtzc_config_sram(SRAM2_BASE, SRAM2_SIZE, 0, DATA_NPRIV_START - SRAM2_BASE -1, 0);
 c051642:	9500      	str	r5, [sp, #0]
    if (DATA_NPRIV_START <=(SRAM2_BASE + SRAM2_SIZE))
 c051644:	f200 80cc 	bhi.w	c0517e0 <gtzc_init_cfg+0x254>
        gtzc_config_sram(SRAM2_BASE, SRAM2_SIZE, DATA_NPRIV_START - SRAM2_BASE, SRAM2_SIZE -1, FLAG_NPRIV);
 c051648:	f04f 0a01 	mov.w	sl, #1
        gtzc_config_sram(SRAM2_BASE, SRAM2_SIZE, 0, DATA_NPRIV_START - SRAM2_BASE -1, 0);
 c05164c:	462a      	mov	r2, r5
 c05164e:	f44f 3180 	mov.w	r1, #65536	@ 0x10000
 c051652:	4b79      	ldr	r3, [pc, #484]	@ (c051838 <gtzc_init_cfg+0x2ac>)
 c051654:	4879      	ldr	r0, [pc, #484]	@ (c05183c <gtzc_init_cfg+0x2b0>)
 c051656:	f7ff fd31 	bl	c0510bc <gtzc_config_sram>
        gtzc_config_sram(SRAM2_BASE, SRAM2_SIZE, DATA_NPRIV_START - SRAM2_BASE, SRAM2_SIZE -1, FLAG_NPRIV);
 c05165a:	f64f 73ff 	movw	r3, #65535	@ 0xffff
 c05165e:	f508 027d 	add.w	r2, r8, #16580608	@ 0xfd0000
 c051662:	f44f 3180 	mov.w	r1, #65536	@ 0x10000
 c051666:	4875      	ldr	r0, [pc, #468]	@ (c05183c <gtzc_init_cfg+0x2b0>)
 c051668:	f8cd a000 	str.w	sl, [sp]
 c05166c:	f7ff fd26 	bl	c0510bc <gtzc_config_sram>
#ifdef SRAM3_BASE
        gtzc_config_sram(SRAM3_BASE, SRAM3_SIZE, 0,  SRAM3_S_SIZE -1, FLAG_NPRIV);
 c051670:	f647 73ff 	movw	r3, #32767	@ 0x7fff
 c051674:	462a      	mov	r2, r5
 c051676:	f8cd a000 	str.w	sl, [sp]
        gtzc_config_sram(SRAM3_BASE, SRAM3_SIZE, 0, DATA_NPRIV_START - SRAM3_BASE -1, 0);
        gtzc_config_sram(SRAM3_BASE, SRAM3_SIZE, DATA_NPRIV_START - SRAM3_BASE,  SRAM3_S_SIZE -1, FLAG_NPRIV);
#endif /* SRAM3_BASE */
    }
#ifdef SRAM3_BASE
    gtzc_config_sram(SRAM3_BASE, SRAM3_SIZE, SRAM3_S_SIZE, SRAM3_SIZE -1, FLAG_NPRIV | FLAG_NSEC);
 c05167a:	2503      	movs	r5, #3
        gtzc_config_sram(SRAM3_BASE, SRAM3_SIZE, DATA_NPRIV_START - SRAM3_BASE,  SRAM3_S_SIZE -1, FLAG_NPRIV);
 c05167c:	f44f 2100 	mov.w	r1, #524288	@ 0x80000
 c051680:	4648      	mov	r0, r9
 c051682:	f7ff fd1b 	bl	c0510bc <gtzc_config_sram>
    gtzc_config_sram(SRAM3_BASE, SRAM3_SIZE, SRAM3_S_SIZE, SRAM3_SIZE -1, FLAG_NPRIV | FLAG_NSEC);
 c051686:	f44f 4200 	mov.w	r2, #32768	@ 0x8000
 c05168a:	f44f 2100 	mov.w	r1, #524288	@ 0x80000
 c05168e:	4b6c      	ldr	r3, [pc, #432]	@ (c051840 <gtzc_init_cfg+0x2b4>)
 c051690:	4867      	ldr	r0, [pc, #412]	@ (c051830 <gtzc_init_cfg+0x2a4>)
 c051692:	9500      	str	r5, [sp, #0]
 c051694:	f7ff fd12 	bl	c0510bc <gtzc_config_sram>
#endif /* SRAM3_BASE */

#if defined(STM32U595xx) || defined(STM32U599xx) || defined(STM32U5A5xx) || defined(STM32U5A9xx)
    gtzc_config_sram(SRAM5_BASE, SRAM5_SIZE, 0, SRAM5_SIZE -1, FLAG_NPRIV | FLAG_NSEC);
#endif /* defined(STM32U595xx) || defined(STM32U599xx) || defined(STM32U5A5xx) || defined(STM32U5A9xx) */
    gtzc_config_sram(SRAM4_BASE, SRAM4_SIZE, 0, SRAM4_SIZE -1, FLAG_NPRIV | FLAG_NSEC);
 c051698:	f44f 4180 	mov.w	r1, #16384	@ 0x4000
 c05169c:	f643 73ff 	movw	r3, #16383	@ 0x3fff
 c0516a0:	2200      	movs	r2, #0
 c0516a2:	f04f 5060 	mov.w	r0, #939524096	@ 0x38000000
 c0516a6:	9500      	str	r5, [sp, #0]
 c0516a8:	f7ff fd08 	bl	c0510bc <gtzc_config_sram>
    GTZC_MPCBB1_S->CFGLOCKR1=MPCBB_LOCK(SRAM1_SIZE);
 c0516ac:	f640 72ff 	movw	r2, #4095	@ 0xfff
 c0516b0:	4b64      	ldr	r3, [pc, #400]	@ (c051844 <gtzc_init_cfg+0x2b8>)
    GTZC_MPCBB4_S->CFGLOCKR1=MPCBB_LOCK(SRAM4_SIZE);
#if defined(STM32U595xx) || defined(STM32U599xx) || defined(STM32U5A5xx) || defined(STM32U5A9xx)
    GTZC_MPCBB5_S->CFGLOCKR1=MPCBB_LOCK(SRAM5_SIZE);
#endif
    /* privileged secure internal flash */
    gtzc_internal_flash_priv(0x0, (uint32_t)(&REGION_NAME(Image$$, TFM_UNPRIV_CODE, $$RO$$Base)) - FLASH_BASE_S - 1);
 c0516b2:	4865      	ldr	r0, [pc, #404]	@ (c051848 <gtzc_init_cfg+0x2bc>)
    GTZC_MPCBB1_S->CFGLOCKR1=MPCBB_LOCK(SRAM1_SIZE);
 c0516b4:	611a      	str	r2, [r3, #16]
    GTZC_MPCBB2_S->CFGLOCKR1=MPCBB_LOCK(SRAM2_SIZE);
 c0516b6:	220f      	movs	r2, #15
 c0516b8:	f8c3 2410 	str.w	r2, [r3, #1040]	@ 0x410
    GTZC_MPCBB3_S->CFGLOCKR1=MPCBB_LOCK(SRAM3_SIZE);
 c0516bc:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 c0516c0:	f8c3 2810 	str.w	r2, [r3, #2064]	@ 0x810
    GTZC_MPCBB4_S->CFGLOCKR1=MPCBB_LOCK(SRAM4_SIZE);
 c0516c4:	2201      	movs	r2, #1
 c0516c6:	4b61      	ldr	r3, [pc, #388]	@ (c05184c <gtzc_init_cfg+0x2c0>)
 c0516c8:	611a      	str	r2, [r3, #16]
    gtzc_internal_flash_priv(0x0, (uint32_t)(&REGION_NAME(Image$$, TFM_UNPRIV_CODE, $$RO$$Base)) - FLASH_BASE_S - 1);
 c0516ca:	f7ff fd7d 	bl	c0511c8 <gtzc_internal_flash_priv.constprop.0>

    /*  use sticky bit to lock all SRAM config  */

    /* Configure Secure peripherals */
    HAL_GTZC_TZSC_ConfigPeriphAttributes(GTZC_PERIPH_RNG, GTZC_TZSC_PERIPH_SEC | GTZC_TZSC_PERIPH_PRIV);
 c0516ce:	f240 3103 	movw	r1, #771	@ 0x303
 c0516d2:	485f      	ldr	r0, [pc, #380]	@ (c051850 <gtzc_init_cfg+0x2c4>)
 c0516d4:	f7ec fe9a 	bl	c03e40c <HAL_GTZC_TZSC_ConfigPeriphAttributes>
    HAL_GTZC_TZIC_EnableIT(GTZC_PERIPH_RNG);
 c0516d8:	485d      	ldr	r0, [pc, #372]	@ (c051850 <gtzc_init_cfg+0x2c4>)
 c0516da:	f7ed f92f 	bl	c03e93c <HAL_GTZC_TZIC_EnableIT>

#if (defined (MBEDTLS_SHA256_C) && defined (MBEDTLS_SHA256_ALT)) \
 || (defined (MBEDTLS_SHA1_C) && defined (MBEDTLS_SHA1_ALT)) \
 || (defined (MBEDTLS_MD5_C) && defined (MBEDTLS_MD5_ALT))
    HAL_GTZC_TZSC_ConfigPeriphAttributes(GTZC_PERIPH_HASH, GTZC_TZSC_PERIPH_SEC | GTZC_TZSC_PERIPH_PRIV);
 c0516de:	f240 3103 	movw	r1, #771	@ 0x303
 c0516e2:	485c      	ldr	r0, [pc, #368]	@ (c051854 <gtzc_init_cfg+0x2c8>)
 c0516e4:	f7ec fe92 	bl	c03e40c <HAL_GTZC_TZSC_ConfigPeriphAttributes>
    HAL_GTZC_TZIC_EnableIT(GTZC_PERIPH_HASH);
 c0516e8:	485a      	ldr	r0, [pc, #360]	@ (c051854 <gtzc_init_cfg+0x2c8>)
 c0516ea:	f7ed f927 	bl	c03e93c <HAL_GTZC_TZIC_EnableIT>
#endif
#if (defined (MBEDTLS_ECP_C) && defined (MBEDTLS_ECP_ALT)) \
 || (defined (MBEDTLS_ECDSA_C) && (defined (MBEDTLS_ECDSA_SIGN_ALT) || defined (MBEDTLS_ECDSA_VERIFY_ALT)))
    HAL_GTZC_TZSC_ConfigPeriphAttributes(GTZC_PERIPH_PKA, GTZC_TZSC_PERIPH_SEC | GTZC_TZSC_PERIPH_PRIV);
 c0516ee:	f240 3103 	movw	r1, #771	@ 0x303
 c0516f2:	4859      	ldr	r0, [pc, #356]	@ (c051858 <gtzc_init_cfg+0x2cc>)
 c0516f4:	f7ec fe8a 	bl	c03e40c <HAL_GTZC_TZSC_ConfigPeriphAttributes>
    HAL_GTZC_TZIC_EnableIT(GTZC_PERIPH_PKA);
 c0516f8:	4857      	ldr	r0, [pc, #348]	@ (c051858 <gtzc_init_cfg+0x2cc>)
 c0516fa:	f7ed f91f 	bl	c03e93c <HAL_GTZC_TZIC_EnableIT>
#endif
#if (defined (MBEDTLS_AES_C) && defined (MBEDTLS_AES_ALT)) \
 || (defined (MBEDTLS_GCM_C) && defined (MBEDTLS_GCM_ALT)) \
 || (defined (MBEDTLS_CCM_C) && defined (MBEDTLS_CCM_ALT))
    HAL_GTZC_TZSC_ConfigPeriphAttributes(GTZC_PERIPH_AES, GTZC_TZSC_PERIPH_SEC | GTZC_TZSC_PERIPH_PRIV);
 c0516fe:	f240 3103 	movw	r1, #771	@ 0x303
 c051702:	4856      	ldr	r0, [pc, #344]	@ (c05185c <gtzc_init_cfg+0x2d0>)
 c051704:	f7ec fe82 	bl	c03e40c <HAL_GTZC_TZSC_ConfigPeriphAttributes>
    HAL_GTZC_TZIC_EnableIT(GTZC_PERIPH_AES);
 c051708:	4854      	ldr	r0, [pc, #336]	@ (c05185c <gtzc_init_cfg+0x2d0>)
 c05170a:	f7ed f917 	bl	c03e93c <HAL_GTZC_TZIC_EnableIT>
#endif
#if defined (HW_CRYPTO_DPA_AES) || defined (HW_CRYPTO_DPA_GCM)
    HAL_GTZC_TZSC_ConfigPeriphAttributes(GTZC_PERIPH_SAES, GTZC_TZSC_PERIPH_SEC | GTZC_TZSC_PERIPH_PRIV);
 c05170e:	f240 3103 	movw	r1, #771	@ 0x303
 c051712:	4853      	ldr	r0, [pc, #332]	@ (c051860 <gtzc_init_cfg+0x2d4>)
 c051714:	f7ec fe7a 	bl	c03e40c <HAL_GTZC_TZSC_ConfigPeriphAttributes>
    HAL_GTZC_TZIC_EnableIT(GTZC_PERIPH_SAES);
 c051718:	4851      	ldr	r0, [pc, #324]	@ (c051860 <gtzc_init_cfg+0x2d4>)
 c05171a:	f7ed f90f 	bl	c03e93c <HAL_GTZC_TZIC_EnableIT>
#endif

    FLOW_CONTROL_STEP(uFlowProtectValue, FLOW_STEP_GTZC_PERIPH_CFG, FLOW_CTRL_GTZC_PERIPH_CFG);
 c05171e:	6822      	ldr	r2, [r4, #0]
 c051720:	4b50      	ldr	r3, [pc, #320]	@ (c051864 <gtzc_init_cfg+0x2d8>)
 c051722:	4053      	eors	r3, r2
 c051724:	6023      	str	r3, [r4, #0]
 c051726:	6822      	ldr	r2, [r4, #0]
 c051728:	4b4f      	ldr	r3, [pc, #316]	@ (c051868 <gtzc_init_cfg+0x2dc>)
 c05172a:	429a      	cmp	r2, r3
 c05172c:	d001      	beq.n	c051732 <gtzc_init_cfg+0x1a6>
 c05172e:	f001 f91b 	bl	c052968 <Error_Handler>

    /*  enable interruption on illegal access on FLASH ,FLASH reg , Secure SRAM2 and Secure Peripheral*/
    HAL_GTZC_TZIC_EnableIT(GTZC_PERIPH_FLASH);
 c051732:	484e      	ldr	r0, [pc, #312]	@ (c05186c <gtzc_init_cfg+0x2e0>)
 c051734:	f7ed f902 	bl	c03e93c <HAL_GTZC_TZIC_EnableIT>
    HAL_GTZC_TZIC_EnableIT(GTZC_PERIPH_FLASH_REG);
 c051738:	484d      	ldr	r0, [pc, #308]	@ (c051870 <gtzc_init_cfg+0x2e4>)
 c05173a:	f7ed f8ff 	bl	c03e93c <HAL_GTZC_TZIC_EnableIT>
    HAL_GTZC_TZIC_EnableIT(GTZC_PERIPH_SRAM2);
 c05173e:	484d      	ldr	r0, [pc, #308]	@ (c051874 <gtzc_init_cfg+0x2e8>)
 c051740:	f7ed f8fc 	bl	c03e93c <HAL_GTZC_TZIC_EnableIT>
    /* GTZC register */
    HAL_GTZC_TZIC_EnableIT(GTZC_PERIPH_TZSC1);
 c051744:	484c      	ldr	r0, [pc, #304]	@ (c051878 <gtzc_init_cfg+0x2ec>)
 c051746:	f7ed f8f9 	bl	c03e93c <HAL_GTZC_TZIC_EnableIT>
    HAL_GTZC_TZIC_EnableIT(GTZC_PERIPH_TZIC1);
 c05174a:	484c      	ldr	r0, [pc, #304]	@ (c05187c <gtzc_init_cfg+0x2f0>)
 c05174c:	f7ed f8f6 	bl	c03e93c <HAL_GTZC_TZIC_EnableIT>
    HAL_GTZC_TZIC_EnableIT(GTZC_PERIPH_TZIC2);
 c051750:	484b      	ldr	r0, [pc, #300]	@ (c051880 <gtzc_init_cfg+0x2f4>)
 c051752:	f7ed f8f3 	bl	c03e93c <HAL_GTZC_TZIC_EnableIT>
    HAL_GTZC_TZIC_EnableIT(GTZC_PERIPH_TZSC2);
 c051756:	484b      	ldr	r0, [pc, #300]	@ (c051884 <gtzc_init_cfg+0x2f8>)
 c051758:	f7ed f8f0 	bl	c03e93c <HAL_GTZC_TZIC_EnableIT>
  __ASM volatile ("dsb 0xF":::"memory");
 c05175c:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 c051760:	f3bf 8f6f 	isb	sy
     */
    __DSB();
    __ISB();
#if defined(TFM_PARTITION_APP_ROT)
    /* enable GPDMA illegal access interrupt */
    HAL_GTZC_TZIC_EnableIT(GTZC_PERIPH_GPDMA1);
 c051764:	f04f 5040 	mov.w	r0, #805306368	@ 0x30000000
 c051768:	f7ed f8e8 	bl	c03e93c <HAL_GTZC_TZIC_EnableIT>
    /* set GPDMA 1 for secure unprivileged */
    DMA_HandleTypeDef DMAHandle;
    __HAL_RCC_GPDMA1_CLK_ENABLE();
 c05176c:	4b2f      	ldr	r3, [pc, #188]	@ (c05182c <gtzc_init_cfg+0x2a0>)
    DMAHandle.Instance                    = GPDMA1_Channel0;
    DMAHandle.Init.Request                = DMA_REQUEST_SW;
    DMAHandle.Init.BlkHWRequest           = DMA_BREQ_SINGLE_BURST;
    DMAHandle.Init.Direction              = DMA_MEMORY_TO_MEMORY;
    DMAHandle.Init.SrcInc                 = DMA_SINC_INCREMENTED;
    DMAHandle.Init.DestInc                = DMA_DINC_INCREMENTED;
 c05176e:	2108      	movs	r1, #8
    __HAL_RCC_GPDMA1_CLK_ENABLE();
 c051770:	f8d3 2088 	ldr.w	r2, [r3, #136]	@ 0x88
    DMAHandle.Init.SrcDataWidth           = DMA_SRC_DATAWIDTH_WORD;
    DMAHandle.Init.DestDataWidth          = DMA_DEST_DATAWIDTH_WORD;
 c051774:	2002      	movs	r0, #2
    __HAL_RCC_GPDMA1_CLK_ENABLE();
 c051776:	f042 0201 	orr.w	r2, r2, #1
 c05177a:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
    DMAHandle.Init.Request                = DMA_REQUEST_SW;
 c05177e:	f44f 7200 	mov.w	r2, #512	@ 0x200
    __HAL_RCC_GPDMA1_CLK_ENABLE();
 c051782:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 c051786:	f003 0301 	and.w	r3, r3, #1
 c05178a:	9305      	str	r3, [sp, #20]
 c05178c:	9b05      	ldr	r3, [sp, #20]
    DMAHandle.Init.Request                = DMA_REQUEST_SW;
 c05178e:	4b3e      	ldr	r3, [pc, #248]	@ (c051888 <gtzc_init_cfg+0x2fc>)
 c051790:	e9cd 3208 	strd	r3, r2, [sp, #32]
    DMAHandle.Init.BlkHWRequest           = DMA_BREQ_SINGLE_BURST;
 c051794:	2300      	movs	r3, #0
    DMAHandle.Init.Direction              = DMA_MEMORY_TO_MEMORY;
 c051796:	e9cd 320a 	strd	r3, r2, [sp, #40]	@ 0x28
    DMAHandle.Init.DestInc                = DMA_DINC_INCREMENTED;
 c05179a:	f44f 2200 	mov.w	r2, #524288	@ 0x80000
 c05179e:	e9cd 120c 	strd	r1, r2, [sp, #48]	@ 0x30
    DMAHandle.Init.DestDataWidth          = DMA_DEST_DATAWIDTH_WORD;
 c0517a2:	f44f 3200 	mov.w	r2, #131072	@ 0x20000
 c0517a6:	e9cd 020e 	strd	r0, r2, [sp, #56]	@ 0x38
    DMAHandle.Init.SrcBurstLength         = 1;
 c0517aa:	2201      	movs	r2, #1
    DMAHandle.Init.DestBurstLength        = 1;
 c0517ac:	e9cd 2211 	strd	r2, r2, [sp, #68]	@ 0x44
    DMAHandle.Init.Priority               = DMA_LOW_PRIORITY_HIGH_WEIGHT;
 c0517b0:	f44f 0200 	mov.w	r2, #8388608	@ 0x800000
 c0517b4:	9210      	str	r2, [sp, #64]	@ 0x40
    DMAHandle.Init.TransferEventMode      = DMA_TCEM_BLOCK_TRANSFER;
    DMAHandle.Init.TransferAllocatedPort  = DMA_SRC_ALLOCATED_PORT0 | DMA_DEST_ALLOCATED_PORT1;
 c0517b6:	f04f 4280 	mov.w	r2, #1073741824	@ 0x40000000
    DMAHandle.Mode                        = DMA_NORMAL;
    if (HAL_DMA_Init(&DMAHandle) != HAL_OK)
 c0517ba:	4638      	mov	r0, r7
    DMAHandle.Init.TransferEventMode      = DMA_TCEM_BLOCK_TRANSFER;
 c0517bc:	9314      	str	r3, [sp, #80]	@ 0x50
    DMAHandle.Init.TransferAllocatedPort  = DMA_SRC_ALLOCATED_PORT0 | DMA_DEST_ALLOCATED_PORT1;
 c0517be:	9213      	str	r2, [sp, #76]	@ 0x4c
    DMAHandle.Mode                        = DMA_NORMAL;
 c0517c0:	931c      	str	r3, [sp, #112]	@ 0x70
    if (HAL_DMA_Init(&DMAHandle) != HAL_OK)
 c0517c2:	f7ec f801 	bl	c03d7c8 <HAL_DMA_Init>
 c0517c6:	b108      	cbz	r0, c0517cc <gtzc_init_cfg+0x240>
    {
        Error_Handler();
 c0517c8:	f001 f8ce 	bl	c052968 <Error_Handler>
    }
    /* set channel as secure channel an unprivileged access (this setting requires secure privileged access) */
    if (HAL_DMA_ConfigChannelAttributes(&DMAHandle, DMA_CHANNEL_SEC | DMA_CHANNEL_NPRIV)!=HAL_OK)
 c0517cc:	2132      	movs	r1, #50	@ 0x32
 c0517ce:	4638      	mov	r0, r7
 c0517d0:	f7ec fab1 	bl	c03dd36 <HAL_DMA_ConfigChannelAttributes>
 c0517d4:	2800      	cmp	r0, #0
 c0517d6:	f000 80f3 	beq.w	c0519c0 <gtzc_init_cfg+0x434>
    if (gtzc_periph_att != (GTZC_TZSC_PERIPH_SEC | GTZC_TZSC_PERIPH_PRIV)) {
      Error_Handler();
    }
#endif

    FLOW_CONTROL_STEP(uFlowProtectValue, FLOW_STEP_GTZC_PERIPH_CH, FLOW_CTRL_GTZC_PERIPH_CH);
 c0517da:	f001 f8c5 	bl	c052968 <Error_Handler>
 c0517de:	e0ef      	b.n	c0519c0 <gtzc_init_cfg+0x434>
        gtzc_config_sram(SRAM2_BASE, SRAM2_SIZE, 0,SRAM2_SIZE -1, 0);
 c0517e0:	f64f 73ff 	movw	r3, #65535	@ 0xffff
 c0517e4:	462a      	mov	r2, r5
 c0517e6:	f44f 3180 	mov.w	r1, #65536	@ 0x10000
 c0517ea:	4814      	ldr	r0, [pc, #80]	@ (c05183c <gtzc_init_cfg+0x2b0>)
 c0517ec:	f7ff fc66 	bl	c0510bc <gtzc_config_sram>
        gtzc_config_sram(SRAM3_BASE, SRAM3_SIZE, 0, DATA_NPRIV_START - SRAM3_BASE -1, 0);
 c0517f0:	462a      	mov	r2, r5
 c0517f2:	4b26      	ldr	r3, [pc, #152]	@ (c05188c <gtzc_init_cfg+0x300>)
 c0517f4:	f44f 2100 	mov.w	r1, #524288	@ 0x80000
 c0517f8:	4648      	mov	r0, r9
 c0517fa:	9500      	str	r5, [sp, #0]
 c0517fc:	f7ff fc5e 	bl	c0510bc <gtzc_config_sram>
        gtzc_config_sram(SRAM3_BASE, SRAM3_SIZE, DATA_NPRIV_START - SRAM3_BASE,  SRAM3_S_SIZE -1, FLAG_NPRIV);
 c051800:	2301      	movs	r3, #1
 c051802:	f508 027c 	add.w	r2, r8, #16515072	@ 0xfc0000
 c051806:	9300      	str	r3, [sp, #0]
 c051808:	f647 73ff 	movw	r3, #32767	@ 0x7fff
 c05180c:	e735      	b.n	c05167a <gtzc_init_cfg+0xee>
 c05180e:	bf00      	nop
 c051810:	300308dc 	.word	0x300308dc
 c051814:	3003ea00 	.word	0x3003ea00
 c051818:	300308e0 	.word	0x300308e0
 c05181c:	56000400 	.word	0x56000400
 c051820:	0004d2b5 	.word	0x0004d2b5
 c051824:	e000ed00 	.word	0xe000ed00
 c051828:	00058600 	.word	0x00058600
 c05182c:	56020c00 	.word	0x56020c00
 c051830:	30040000 	.word	0x30040000
 c051834:	0002ffff 	.word	0x0002ffff
 c051838:	0000e9ff 	.word	0x0000e9ff
 c05183c:	30030000 	.word	0x30030000
 c051840:	0007ffff 	.word	0x0007ffff
 c051844:	50032c00 	.word	0x50032c00
 c051848:	0003bfff 	.word	0x0003bfff
 c05184c:	56023800 	.word	0x56023800
 c051850:	2000000d 	.word	0x2000000d
 c051854:	2000000c 	.word	0x2000000c
 c051858:	2000000e 	.word	0x2000000e
 c05185c:	2000000b 	.word	0x2000000b
 c051860:	2000000f 	.word	0x2000000f
 c051864:	00028f7d 	.word	0x00028f7d
 c051868:	0007097d 	.word	0x0007097d
 c05186c:	30000002 	.word	0x30000002
 c051870:	30000001 	.word	0x30000001
 c051874:	3000001a 	.word	0x3000001a
 c051878:	3000000e 	.word	0x3000000e
 c05187c:	3000000f 	.word	0x3000000f
 c051880:	5000000f 	.word	0x5000000f
 c051884:	5000000e 	.word	0x5000000e
 c051888:	50020050 	.word	0x50020050
 c05188c:	ffffe9ff 	.word	0xffffe9ff
    gtzc_config_sram(SRAM1_BASE, SRAM1_SIZE, 0, SRAM1_SIZE -1, FLAG_NPRIV | FLAG_NSEC);
 c051890:	2303      	movs	r3, #3
    if (DATA_NPRIV_START <=(SRAM2_BASE + SRAM2_SIZE))
 c051892:	f8df 918c 	ldr.w	r9, [pc, #396]	@ c051a20 <gtzc_init_cfg+0x494>
    gtzc_config_sram(SRAM1_BASE, SRAM1_SIZE, 0, SRAM1_SIZE -1, FLAG_NPRIV | FLAG_NSEC);
 c051896:	9300      	str	r3, [sp, #0]
 c051898:	2200      	movs	r2, #0
 c05189a:	f44f 3140 	mov.w	r1, #196608	@ 0x30000
 c05189e:	f04f 5040 	mov.w	r0, #805306368	@ 0x30000000
 c0518a2:	4b60      	ldr	r3, [pc, #384]	@ (c051a24 <gtzc_init_cfg+0x498>)
 c0518a4:	f7ff fc0a 	bl	c0510bc <gtzc_config_sram>
    if (DATA_NPRIV_START <=(SRAM2_BASE + SRAM2_SIZE))
 c0518a8:	454d      	cmp	r5, r9
 c0518aa:	f04f 0500 	mov.w	r5, #0
        gtzc_config_sram(SRAM2_BASE, SRAM2_SIZE, 0, DATA_NPRIV_START - SRAM2_BASE -1, 0);
 c0518ae:	9500      	str	r5, [sp, #0]
    if (DATA_NPRIV_START <=(SRAM2_BASE + SRAM2_SIZE))
 c0518b0:	f200 809f 	bhi.w	c0519f2 <gtzc_init_cfg+0x466>
        gtzc_config_sram(SRAM2_BASE, SRAM2_SIZE, DATA_NPRIV_START - SRAM2_BASE, SRAM2_SIZE -1, FLAG_NPRIV);
 c0518b4:	f04f 0a01 	mov.w	sl, #1
        gtzc_config_sram(SRAM2_BASE, SRAM2_SIZE, 0, DATA_NPRIV_START - SRAM2_BASE -1, 0);
 c0518b8:	462a      	mov	r2, r5
 c0518ba:	f44f 3180 	mov.w	r1, #65536	@ 0x10000
 c0518be:	4b5a      	ldr	r3, [pc, #360]	@ (c051a28 <gtzc_init_cfg+0x49c>)
 c0518c0:	485a      	ldr	r0, [pc, #360]	@ (c051a2c <gtzc_init_cfg+0x4a0>)
 c0518c2:	f7ff fbfb 	bl	c0510bc <gtzc_config_sram>
        gtzc_config_sram(SRAM2_BASE, SRAM2_SIZE, DATA_NPRIV_START - SRAM2_BASE, SRAM2_SIZE -1, FLAG_NPRIV);
 c0518c6:	f64f 73ff 	movw	r3, #65535	@ 0xffff
 c0518ca:	f508 027d 	add.w	r2, r8, #16580608	@ 0xfd0000
 c0518ce:	f44f 3180 	mov.w	r1, #65536	@ 0x10000
 c0518d2:	4856      	ldr	r0, [pc, #344]	@ (c051a2c <gtzc_init_cfg+0x4a0>)
 c0518d4:	f8cd a000 	str.w	sl, [sp]
 c0518d8:	f7ff fbf0 	bl	c0510bc <gtzc_config_sram>
        gtzc_config_sram(SRAM3_BASE, SRAM3_SIZE, 0,  SRAM3_S_SIZE -1, FLAG_NPRIV);
 c0518dc:	f647 73ff 	movw	r3, #32767	@ 0x7fff
 c0518e0:	462a      	mov	r2, r5
 c0518e2:	f8cd a000 	str.w	sl, [sp]
    gtzc_config_sram(SRAM3_BASE, SRAM3_SIZE, SRAM3_S_SIZE, SRAM3_SIZE -1, FLAG_NPRIV | FLAG_NSEC);
 c0518e6:	2503      	movs	r5, #3
        gtzc_config_sram(SRAM3_BASE, SRAM3_SIZE, DATA_NPRIV_START - SRAM3_BASE,  SRAM3_S_SIZE -1, FLAG_NPRIV);
 c0518e8:	f44f 2100 	mov.w	r1, #524288	@ 0x80000
 c0518ec:	4648      	mov	r0, r9
 c0518ee:	f7ff fbe5 	bl	c0510bc <gtzc_config_sram>
    gtzc_config_sram(SRAM3_BASE, SRAM3_SIZE, SRAM3_S_SIZE, SRAM3_SIZE -1, FLAG_NPRIV | FLAG_NSEC);
 c0518f2:	f44f 4200 	mov.w	r2, #32768	@ 0x8000
 c0518f6:	f44f 2100 	mov.w	r1, #524288	@ 0x80000
 c0518fa:	4b4d      	ldr	r3, [pc, #308]	@ (c051a30 <gtzc_init_cfg+0x4a4>)
 c0518fc:	4848      	ldr	r0, [pc, #288]	@ (c051a20 <gtzc_init_cfg+0x494>)
 c0518fe:	9500      	str	r5, [sp, #0]
 c051900:	f7ff fbdc 	bl	c0510bc <gtzc_config_sram>
    gtzc_config_sram(SRAM4_BASE, SRAM4_SIZE, 0, SRAM4_SIZE -1, FLAG_NPRIV | FLAG_NSEC);
 c051904:	f643 73ff 	movw	r3, #16383	@ 0x3fff
 c051908:	2200      	movs	r2, #0
 c05190a:	f44f 4180 	mov.w	r1, #16384	@ 0x4000
 c05190e:	f04f 5060 	mov.w	r0, #939524096	@ 0x38000000
 c051912:	9500      	str	r5, [sp, #0]
 c051914:	f7ff fbd2 	bl	c0510bc <gtzc_config_sram>
    if (GTZC_MPCBB1_S->CFGLOCKR1 != MPCBB_LOCK(SRAM1_SIZE)) Error_Handler();
 c051918:	4b46      	ldr	r3, [pc, #280]	@ (c051a34 <gtzc_init_cfg+0x4a8>)
 c05191a:	691a      	ldr	r2, [r3, #16]
 c05191c:	f640 73ff 	movw	r3, #4095	@ 0xfff
 c051920:	429a      	cmp	r2, r3
 c051922:	d001      	beq.n	c051928 <gtzc_init_cfg+0x39c>
 c051924:	f001 f820 	bl	c052968 <Error_Handler>
    if (GTZC_MPCBB2_S->CFGLOCKR1 != MPCBB_LOCK(SRAM2_SIZE)) Error_Handler();
 c051928:	4b43      	ldr	r3, [pc, #268]	@ (c051a38 <gtzc_init_cfg+0x4ac>)
 c05192a:	691b      	ldr	r3, [r3, #16]
 c05192c:	2b0f      	cmp	r3, #15
 c05192e:	d001      	beq.n	c051934 <gtzc_init_cfg+0x3a8>
 c051930:	f001 f81a 	bl	c052968 <Error_Handler>
    if (GTZC_MPCBB3_S->CFGLOCKR1 != MPCBB_LOCK(SRAM3_SIZE)) Error_Handler();
 c051934:	4b41      	ldr	r3, [pc, #260]	@ (c051a3c <gtzc_init_cfg+0x4b0>)
 c051936:	691b      	ldr	r3, [r3, #16]
 c051938:	3301      	adds	r3, #1
 c05193a:	d001      	beq.n	c051940 <gtzc_init_cfg+0x3b4>
 c05193c:	f001 f814 	bl	c052968 <Error_Handler>
    if (GTZC_MPCBB4_S->CFGLOCKR1 != MPCBB_LOCK(SRAM4_SIZE)) Error_Handler();
 c051940:	4b3f      	ldr	r3, [pc, #252]	@ (c051a40 <gtzc_init_cfg+0x4b4>)
 c051942:	691b      	ldr	r3, [r3, #16]
 c051944:	2b01      	cmp	r3, #1
 c051946:	d001      	beq.n	c05194c <gtzc_init_cfg+0x3c0>
 c051948:	f001 f80e 	bl	c052968 <Error_Handler>
    gtzc_internal_flash_priv(0x0, (uint32_t)(&REGION_NAME(Image$$, TFM_UNPRIV_CODE, $$RO$$Base)) - FLASH_BASE_S - 1);
 c05194c:	483d      	ldr	r0, [pc, #244]	@ (c051a44 <gtzc_init_cfg+0x4b8>)
 c05194e:	f7ff fc3b 	bl	c0511c8 <gtzc_internal_flash_priv.constprop.0>
    HAL_GTZC_TZSC_GetConfigPeriphAttributes(GTZC_PERIPH_HASH, &gtzc_periph_att);
 c051952:	483d      	ldr	r0, [pc, #244]	@ (c051a48 <gtzc_init_cfg+0x4bc>)
 c051954:	a902      	add	r1, sp, #8
 c051956:	f7ec fe25 	bl	c03e5a4 <HAL_GTZC_TZSC_GetConfigPeriphAttributes>
    if (gtzc_periph_att != (GTZC_TZSC_PERIPH_SEC | GTZC_TZSC_PERIPH_PRIV)) {
 c05195a:	f240 3303 	movw	r3, #771	@ 0x303
 c05195e:	9a02      	ldr	r2, [sp, #8]
 c051960:	429a      	cmp	r2, r3
 c051962:	d001      	beq.n	c051968 <gtzc_init_cfg+0x3dc>
      Error_Handler();
 c051964:	f001 f800 	bl	c052968 <Error_Handler>
    HAL_GTZC_TZSC_GetConfigPeriphAttributes(GTZC_PERIPH_PKA, &gtzc_periph_att);
 c051968:	4838      	ldr	r0, [pc, #224]	@ (c051a4c <gtzc_init_cfg+0x4c0>)
 c05196a:	a902      	add	r1, sp, #8
 c05196c:	f7ec fe1a 	bl	c03e5a4 <HAL_GTZC_TZSC_GetConfigPeriphAttributes>
    if (gtzc_periph_att != (GTZC_TZSC_PERIPH_SEC | GTZC_TZSC_PERIPH_PRIV)) {
 c051970:	f240 3303 	movw	r3, #771	@ 0x303
 c051974:	9a02      	ldr	r2, [sp, #8]
 c051976:	429a      	cmp	r2, r3
 c051978:	d001      	beq.n	c05197e <gtzc_init_cfg+0x3f2>
      Error_Handler();
 c05197a:	f000 fff5 	bl	c052968 <Error_Handler>
    HAL_GTZC_TZSC_GetConfigPeriphAttributes(GTZC_PERIPH_AES, &gtzc_periph_att);
 c05197e:	4834      	ldr	r0, [pc, #208]	@ (c051a50 <gtzc_init_cfg+0x4c4>)
 c051980:	a902      	add	r1, sp, #8
 c051982:	f7ec fe0f 	bl	c03e5a4 <HAL_GTZC_TZSC_GetConfigPeriphAttributes>
    if (gtzc_periph_att != (GTZC_TZSC_PERIPH_SEC | GTZC_TZSC_PERIPH_PRIV)) {
 c051986:	f240 3303 	movw	r3, #771	@ 0x303
 c05198a:	9a02      	ldr	r2, [sp, #8]
 c05198c:	429a      	cmp	r2, r3
 c05198e:	d001      	beq.n	c051994 <gtzc_init_cfg+0x408>
      Error_Handler();
 c051990:	f000 ffea 	bl	c052968 <Error_Handler>
    HAL_GTZC_TZSC_GetConfigPeriphAttributes(GTZC_PERIPH_SAES, &gtzc_periph_att);
 c051994:	482f      	ldr	r0, [pc, #188]	@ (c051a54 <gtzc_init_cfg+0x4c8>)
 c051996:	a902      	add	r1, sp, #8
 c051998:	f7ec fe04 	bl	c03e5a4 <HAL_GTZC_TZSC_GetConfigPeriphAttributes>
    if (gtzc_periph_att != (GTZC_TZSC_PERIPH_SEC | GTZC_TZSC_PERIPH_PRIV)) {
 c05199c:	f240 3303 	movw	r3, #771	@ 0x303
 c0519a0:	9a02      	ldr	r2, [sp, #8]
 c0519a2:	429a      	cmp	r2, r3
 c0519a4:	d001      	beq.n	c0519aa <gtzc_init_cfg+0x41e>
      Error_Handler();
 c0519a6:	f000 ffdf 	bl	c052968 <Error_Handler>
    FLOW_CONTROL_STEP(uFlowProtectValue, FLOW_STEP_GTZC_PERIPH_CH, FLOW_CTRL_GTZC_PERIPH_CH);
 c0519aa:	6823      	ldr	r3, [r4, #0]
 c0519ac:	f483 3339 	eor.w	r3, r3, #189440	@ 0x2e400
 c0519b0:	f483 73b7 	eor.w	r3, r3, #366	@ 0x16e
 c0519b4:	6023      	str	r3, [r4, #0]
 c0519b6:	6822      	ldr	r2, [r4, #0]
 c0519b8:	4b27      	ldr	r3, [pc, #156]	@ (c051a58 <gtzc_init_cfg+0x4cc>)
 c0519ba:	429a      	cmp	r2, r3
 c0519bc:	f47f af0d 	bne.w	c0517da <gtzc_init_cfg+0x24e>
  }
  /* Lock GTZC */
  HAL_GTZC_TZSC_Lock(GTZC_TZSC1_S);
 c0519c0:	4826      	ldr	r0, [pc, #152]	@ (c051a5c <gtzc_init_cfg+0x4d0>)
 c0519c2:	f7ec fef3 	bl	c03e7ac <HAL_GTZC_TZSC_Lock>
  HAL_GTZC_TZSC_Lock(GTZC_TZSC2_S);
 c0519c6:	4826      	ldr	r0, [pc, #152]	@ (c051a60 <gtzc_init_cfg+0x4d4>)
 c0519c8:	f7ec fef0 	bl	c03e7ac <HAL_GTZC_TZSC_Lock>
#ifdef TFM_FIH_PROFILE_ON
  FIH_RET(fih_int_encode(TFM_PLAT_ERR_SUCCESS));
 c0519cc:	f009 ff9a 	bl	c05b904 <fih_cfi_decrement>
    fih_int ret = {x, x ^ _FIH_MASK_VALUE};
 c0519d0:	2300      	movs	r3, #0
 c0519d2:	9308      	str	r3, [sp, #32]
 c0519d4:	4b23      	ldr	r3, [pc, #140]	@ (c051a64 <gtzc_init_cfg+0x4d8>)
 c0519d6:	9309      	str	r3, [sp, #36]	@ 0x24
 c0519d8:	ab06      	add	r3, sp, #24
 c0519da:	e897 0003 	ldmia.w	r7, {r0, r1}
 c0519de:	e883 0003 	stmia.w	r3, {r0, r1}
    return ret;
 c0519e2:	e893 0003 	ldmia.w	r3, {r0, r1}
 c0519e6:	e886 0003 	stmia.w	r6, {r0, r1}
#endif
}
 c0519ea:	4630      	mov	r0, r6
 c0519ec:	b026      	add	sp, #152	@ 0x98
 c0519ee:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        gtzc_config_sram(SRAM2_BASE, SRAM2_SIZE, 0,SRAM2_SIZE -1, 0);
 c0519f2:	f64f 73ff 	movw	r3, #65535	@ 0xffff
 c0519f6:	462a      	mov	r2, r5
 c0519f8:	f44f 3180 	mov.w	r1, #65536	@ 0x10000
 c0519fc:	480b      	ldr	r0, [pc, #44]	@ (c051a2c <gtzc_init_cfg+0x4a0>)
 c0519fe:	f7ff fb5d 	bl	c0510bc <gtzc_config_sram>
        gtzc_config_sram(SRAM3_BASE, SRAM3_SIZE, 0, DATA_NPRIV_START - SRAM3_BASE -1, 0);
 c051a02:	462a      	mov	r2, r5
 c051a04:	4b18      	ldr	r3, [pc, #96]	@ (c051a68 <gtzc_init_cfg+0x4dc>)
 c051a06:	f44f 2100 	mov.w	r1, #524288	@ 0x80000
 c051a0a:	4648      	mov	r0, r9
 c051a0c:	9500      	str	r5, [sp, #0]
 c051a0e:	f7ff fb55 	bl	c0510bc <gtzc_config_sram>
        gtzc_config_sram(SRAM3_BASE, SRAM3_SIZE, DATA_NPRIV_START - SRAM3_BASE,  SRAM3_S_SIZE -1, FLAG_NPRIV);
 c051a12:	2301      	movs	r3, #1
 c051a14:	f508 027c 	add.w	r2, r8, #16515072	@ 0xfc0000
 c051a18:	9300      	str	r3, [sp, #0]
 c051a1a:	f647 73ff 	movw	r3, #32767	@ 0x7fff
 c051a1e:	e762      	b.n	c0518e6 <gtzc_init_cfg+0x35a>
 c051a20:	30040000 	.word	0x30040000
 c051a24:	0002ffff 	.word	0x0002ffff
 c051a28:	0000e9ff 	.word	0x0000e9ff
 c051a2c:	30030000 	.word	0x30030000
 c051a30:	0007ffff 	.word	0x0007ffff
 c051a34:	50032c00 	.word	0x50032c00
 c051a38:	50033000 	.word	0x50033000
 c051a3c:	50033400 	.word	0x50033400
 c051a40:	56023800 	.word	0x56023800
 c051a44:	0003bfff 	.word	0x0003bfff
 c051a48:	2000000c 	.word	0x2000000c
 c051a4c:	2000000e 	.word	0x2000000e
 c051a50:	2000000b 	.word	0x2000000b
 c051a54:	2000000f 	.word	0x2000000f
 c051a58:	0004449b 	.word	0x0004449b
 c051a5c:	50032400 	.word	0x50032400
 c051a60:	56023000 	.word	0x56023000
 c051a64:	a5c35a3c 	.word	0xa5c35a3c
 c051a68:	ffffe9ff 	.word	0xffffe9ff

0c051a6c <tfm_spm_hal_init_debug>:

#ifdef TFM_FIH_PROFILE_ON

fih_int tfm_spm_hal_init_debug(void)
{
 c051a6c:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 c051a6e:	4604      	mov	r4, r0
  /*  debug is available  only with RDP 0 for secure*/
  FIH_RET(fih_int_encode(TFM_PLAT_ERR_SUCCESS));
 c051a70:	f009 ff48 	bl	c05b904 <fih_cfi_decrement>
    fih_int ret = {x, x ^ _FIH_MASK_VALUE};
 c051a74:	2300      	movs	r3, #0
 c051a76:	9302      	str	r3, [sp, #8]
 c051a78:	4b07      	ldr	r3, [pc, #28]	@ (c051a98 <tfm_spm_hal_init_debug+0x2c>)
 c051a7a:	aa04      	add	r2, sp, #16
 c051a7c:	9303      	str	r3, [sp, #12]
 c051a7e:	466b      	mov	r3, sp
 c051a80:	e912 0003 	ldmdb	r2, {r0, r1}
 c051a84:	e883 0003 	stmia.w	r3, {r0, r1}
    return ret;
 c051a88:	e893 0003 	ldmia.w	r3, {r0, r1}
 c051a8c:	e884 0003 	stmia.w	r4, {r0, r1}
}
 c051a90:	4620      	mov	r0, r4
 c051a92:	b004      	add	sp, #16
 c051a94:	bd10      	pop	{r4, pc}
 c051a96:	bf00      	nop
 c051a98:	a5c35a3c 	.word	0xa5c35a3c

0c051a9c <tfm_spm_hal_verify_isolation_hw>:

fih_int tfm_spm_hal_verify_isolation_hw(void)
 c051a9c:	b510      	push	{r4, lr}
 c051a9e:	4604      	mov	r4, r0
 c051aa0:	f7ff ffe4 	bl	c051a6c <tfm_spm_hal_init_debug>
 c051aa4:	4620      	mov	r0, r4
 c051aa6:	bd10      	pop	{r4, pc}

0c051aa8 <tfm_hal_random_init>:
unsigned char seed_buf[RNG_NUMBER] = {0};
size_t index_seed_buf = 0;

int32_t tfm_hal_random_init(void)
{
  size_t len = 0U;
 c051aa8:	2300      	movs	r3, #0
{
 c051aaa:	b507      	push	{r0, r1, r2, lr}
  size_t len = 0U;
 c051aac:	9301      	str	r3, [sp, #4]

  RNG_Init();
 c051aae:	f7fc ff59 	bl	c04e964 <RNG_Init>
  /* generate several random */
  RNG_GetBytes((unsigned char *)seed_buf, sizeof(seed_buf),(size_t *)&len);
 c051ab2:	2120      	movs	r1, #32
 c051ab4:	480b      	ldr	r0, [pc, #44]	@ (c051ae4 <tfm_hal_random_init+0x3c>)
 c051ab6:	aa01      	add	r2, sp, #4
 c051ab8:	f7fc ff90 	bl	c04e9dc <RNG_GetBytes>
  if(len == 0)/* fail to generate random values */
 c051abc:	9b01      	ldr	r3, [sp, #4]
 c051abe:	b90b      	cbnz	r3, c051ac4 <tfm_hal_random_init+0x1c>
  {
    Error_Handler();
 c051ac0:	f000 ff52 	bl	c052968 <Error_Handler>
  }
  /* use flow control to check that the buffer is filled */
  FLOW_CONTROL_STEP(uFlowProtectValue, FLOW_STEP_FIH_RAND_GEN, FLOW_CTRL_FIH_RAND_GEN);
 c051ac4:	4b08      	ldr	r3, [pc, #32]	@ (c051ae8 <tfm_hal_random_init+0x40>)
 c051ac6:	4a09      	ldr	r2, [pc, #36]	@ (c051aec <tfm_hal_random_init+0x44>)
 c051ac8:	6819      	ldr	r1, [r3, #0]
 c051aca:	404a      	eors	r2, r1
 c051acc:	601a      	str	r2, [r3, #0]
 c051ace:	681a      	ldr	r2, [r3, #0]
 c051ad0:	4b07      	ldr	r3, [pc, #28]	@ (c051af0 <tfm_hal_random_init+0x48>)
 c051ad2:	429a      	cmp	r2, r3
 c051ad4:	d001      	beq.n	c051ada <tfm_hal_random_init+0x32>
 c051ad6:	f000 ff47 	bl	c052968 <Error_Handler>
  return 0;
}
 c051ada:	2000      	movs	r0, #0
 c051adc:	b003      	add	sp, #12
 c051ade:	f85d fb04 	ldr.w	pc, [sp], #4
 c051ae2:	bf00      	nop
 c051ae4:	30030ead 	.word	0x30030ead
 c051ae8:	300308e0 	.word	0x300308e0
 c051aec:	00061935 	.word	0x00061935
 c051af0:	00064e43 	.word	0x00064e43

0c051af4 <tfm_hal_random_generate>:

int32_t tfm_hal_random_generate(uint8_t *rand, size_t size)
{
  static uint8_t index_seed_buf = 0U;

  *rand = seed_buf[index_seed_buf];
 c051af4:	4a06      	ldr	r2, [pc, #24]	@ (c051b10 <tfm_hal_random_generate+0x1c>)
 c051af6:	4907      	ldr	r1, [pc, #28]	@ (c051b14 <tfm_hal_random_generate+0x20>)
 c051af8:	7813      	ldrb	r3, [r2, #0]
 c051afa:	5cc9      	ldrb	r1, [r1, r3]
  index_seed_buf++;
 c051afc:	3301      	adds	r3, #1
 c051afe:	b2db      	uxtb	r3, r3

  if (RNG_NUMBER == index_seed_buf)
 c051b00:	2b20      	cmp	r3, #32
 c051b02:	bf08      	it	eq
 c051b04:	2300      	moveq	r3, #0
  *rand = seed_buf[index_seed_buf];
 c051b06:	7001      	strb	r1, [r0, #0]
  index_seed_buf++;
 c051b08:	7013      	strb	r3, [r2, #0]
  {
    index_seed_buf = 0;
  }
  return 0;
}
 c051b0a:	2000      	movs	r0, #0
 c051b0c:	4770      	bx	lr
 c051b0e:	bf00      	nop
 c051b10:	30030eac 	.word	0x30030eac
 c051b14:	30030ead 	.word	0x30030ead

0c051b18 <mpu_init>:
#ifdef TFM_FIH_PROFILE_ON
static fih_int mpu_init(void)
#else
static enum tfm_hal_status_t mpu_init(void)
#endif
{
 c051b18:	b5f0      	push	{r4, r5, r6, r7, lr}
  struct mpu_armv8m_dev_t dev_mpu_s = { MPU_BASE };
 c051b1a:	4b56      	ldr	r3, [pc, #344]	@ (c051c74 <mpu_init+0x15c>)
{
 c051b1c:	b08d      	sub	sp, #52	@ 0x34
  struct mpu_armv8m_dev_t dev_mpu_s = { MPU_BASE };
 c051b1e:	9301      	str	r3, [sp, #4]
  uint32_t i;

  /* configuration stage */
  if (uFlowStage == FLOW_STAGE_CFG)
 c051b20:	4b55      	ldr	r3, [pc, #340]	@ (c051c78 <mpu_init+0x160>)
{
 c051b22:	4605      	mov	r5, r0
  if (uFlowStage == FLOW_STAGE_CFG)
 c051b24:	681b      	ldr	r3, [r3, #0]
 c051b26:	f513 7f00 	cmn.w	r3, #512	@ 0x200
 c051b2a:	d14b      	bne.n	c051bc4 <mpu_init+0xac>
  {
    /* FIXME disable secure MPU to be able to re config it for the appli */
    mpu_armv8m_disable(&dev_mpu_s);
 c051b2c:	a801      	add	r0, sp, #4
 c051b2e:	f7fc ffdd 	bl	c04eaec <mpu_armv8m_disable>
    mpu_armv8m_clean(&dev_mpu_s);
 c051b32:	a801      	add	r0, sp, #4
 c051b34:	f7fd f842 	bl	c04ebbc <mpu_armv8m_clean>

    /* configure secure MPU regions */
    for (i = 0; i < ARRAY_SIZE(region_cfg_init_s); i++)
 c051b38:	2700      	movs	r7, #0
 c051b3a:	4e50      	ldr	r6, [pc, #320]	@ (c051c7c <mpu_init+0x164>)
#endif
      }
      else
      {
        /* Execution stopped if flow control failed */
        FLOW_CONTROL_STEP(uFlowProtectValue, region_cfg_init_s[i].flow_step_enable,
 c051b3c:	4c50      	ldr	r4, [pc, #320]	@ (c051c80 <mpu_init+0x168>)
      if (mpu_armv8m_region_enable(&dev_mpu_s,
 c051b3e:	4631      	mov	r1, r6
 c051b40:	a801      	add	r0, sp, #4
 c051b42:	f7fc ffd7 	bl	c04eaf4 <mpu_armv8m_region_enable>
 c051b46:	b190      	cbz	r0, c051b6e <mpu_init+0x56>
	FIH_RET(fih_int_encode(TFM_HAL_ERROR_GENERIC));
 c051b48:	f009 fedc 	bl	c05b904 <fih_cfi_decrement>
    fih_int ret = {x, x ^ _FIH_MASK_VALUE};
 c051b4c:	f643 33da 	movw	r3, #15322	@ 0x3bda
 c051b50:	9306      	str	r3, [sp, #24]
 c051b52:	4b4c      	ldr	r3, [pc, #304]	@ (c051c84 <mpu_init+0x16c>)
 c051b54:	9307      	str	r3, [sp, #28]
 c051b56:	ab04      	add	r3, sp, #16
 c051b58:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 c051b5c:	e883 0003 	stmia.w	r3, {r0, r1}
    return ret;
 c051b60:	e893 0003 	ldmia.w	r3, {r0, r1}
 c051b64:	e885 0003 	stmia.w	r5, {r0, r1}
#ifdef TFM_FIH_PROFILE_ON
  FIH_RET(fih_int_encode(TFM_HAL_SUCCESS));
#else
   return TFM_HAL_SUCCESS;
#endif
}
 c051b68:	4628      	mov	r0, r5
 c051b6a:	b00d      	add	sp, #52	@ 0x34
 c051b6c:	bdf0      	pop	{r4, r5, r6, r7, pc}
        FLOW_CONTROL_STEP(uFlowProtectValue, region_cfg_init_s[i].flow_step_enable,
 c051b6e:	6823      	ldr	r3, [r4, #0]
 c051b70:	6972      	ldr	r2, [r6, #20]
 c051b72:	4053      	eors	r3, r2
 c051b74:	6023      	str	r3, [r4, #0]
 c051b76:	6823      	ldr	r3, [r4, #0]
 c051b78:	69b2      	ldr	r2, [r6, #24]
 c051b7a:	429a      	cmp	r2, r3
 c051b7c:	d001      	beq.n	c051b82 <mpu_init+0x6a>
 c051b7e:	f000 fef3 	bl	c052968 <Error_Handler>
    for (i = 0; i < ARRAY_SIZE(region_cfg_init_s); i++)
 c051b82:	3701      	adds	r7, #1
 c051b84:	2f08      	cmp	r7, #8
 c051b86:	f106 0624 	add.w	r6, r6, #36	@ 0x24
 c051b8a:	d1d8      	bne.n	c051b3e <mpu_init+0x26>
    mpu_armv8m_enable(&dev_mpu_s, PRIVILEGED_DEFAULT_DISABLE, HARDFAULT_NMI_ENABLE);
 c051b8c:	2201      	movs	r2, #1
 c051b8e:	2100      	movs	r1, #0
 c051b90:	a801      	add	r0, sp, #4
 c051b92:	f7fc ff77 	bl	c04ea84 <mpu_armv8m_enable>
    FLOW_CONTROL_STEP(uFlowProtectValue, FLOW_STEP_MPU_S_EN, FLOW_CTRL_MPU_S_EN);
 c051b96:	6823      	ldr	r3, [r4, #0]
 c051b98:	f483 4363 	eor.w	r3, r3, #58112	@ 0xe300
 c051b9c:	f083 03dc 	eor.w	r3, r3, #220	@ 0xdc
 c051ba0:	6023      	str	r3, [r4, #0]
 c051ba2:	6822      	ldr	r2, [r4, #0]
 c051ba4:	4b38      	ldr	r3, [pc, #224]	@ (c051c88 <mpu_init+0x170>)
 c051ba6:	429a      	cmp	r2, r3
 c051ba8:	d001      	beq.n	c051bae <mpu_init+0x96>
 c051baa:	f000 fedd 	bl	c052968 <Error_Handler>
  FIH_RET(fih_int_encode(TFM_HAL_SUCCESS));
 c051bae:	f009 fea9 	bl	c05b904 <fih_cfi_decrement>
    fih_int ret = {x, x ^ _FIH_MASK_VALUE};
 c051bb2:	2300      	movs	r3, #0
 c051bb4:	930a      	str	r3, [sp, #40]	@ 0x28
 c051bb6:	4b35      	ldr	r3, [pc, #212]	@ (c051c8c <mpu_init+0x174>)
 c051bb8:	aa0c      	add	r2, sp, #48	@ 0x30
 c051bba:	930b      	str	r3, [sp, #44]	@ 0x2c
 c051bbc:	e912 0003 	ldmdb	r2, {r0, r1}
 c051bc0:	ab08      	add	r3, sp, #32
 c051bc2:	e7cb      	b.n	c051b5c <mpu_init+0x44>
    for (i = 0; i < ARRAY_SIZE(region_cfg_init_s); i++)
 c051bc4:	2600      	movs	r6, #0
 c051bc6:	4c2d      	ldr	r4, [pc, #180]	@ (c051c7c <mpu_init+0x164>)
        FLOW_CONTROL_STEP(uFlowProtectValue, region_cfg_init_s[i].flow_step_check,
 c051bc8:	4f2d      	ldr	r7, [pc, #180]	@ (c051c80 <mpu_init+0x168>)
      if (mpu_armv8m_region_enable_check(&dev_mpu_s,
 c051bca:	4621      	mov	r1, r4
 c051bcc:	a801      	add	r0, sp, #4
 c051bce:	f7fc ffc0 	bl	c04eb52 <mpu_armv8m_region_enable_check>
 c051bd2:	2800      	cmp	r0, #0
 c051bd4:	d03b      	beq.n	c051c4e <mpu_init+0x136>
        Error_Handler();
 c051bd6:	f000 fec7 	bl	c052968 <Error_Handler>
    for (i = 0; i < ARRAY_SIZE(region_cfg_init_s); i++)
 c051bda:	3601      	adds	r6, #1
 c051bdc:	2e08      	cmp	r6, #8
 c051bde:	f104 0424 	add.w	r4, r4, #36	@ 0x24
 c051be2:	d1f2      	bne.n	c051bca <mpu_init+0xb2>
    if (mpu_armv8m_check(&dev_mpu_s, PRIVILEGED_DEFAULT_DISABLE,
 c051be4:	2201      	movs	r2, #1
 c051be6:	2100      	movs	r1, #0
 c051be8:	a801      	add	r0, sp, #4
 c051bea:	f7fc ff65 	bl	c04eab8 <mpu_armv8m_check>
 c051bee:	4c24      	ldr	r4, [pc, #144]	@ (c051c80 <mpu_init+0x168>)
 c051bf0:	2800      	cmp	r0, #0
 c051bf2:	d035      	beq.n	c051c60 <mpu_init+0x148>
      Error_Handler();
 c051bf4:	f000 feb8 	bl	c052968 <Error_Handler>
    __IO uint32_t read_reg = (uint32_t) &SYSCFG->CSLCKR;
 c051bf8:	4b25      	ldr	r3, [pc, #148]	@ (c051c90 <mpu_init+0x178>)
 c051bfa:	9302      	str	r3, [sp, #8]
    __HAL_RCC_SYSCFG_CLK_ENABLE();
 c051bfc:	4b25      	ldr	r3, [pc, #148]	@ (c051c94 <mpu_init+0x17c>)
 c051bfe:	f8d3 20a8 	ldr.w	r2, [r3, #168]	@ 0xa8
 c051c02:	f042 0202 	orr.w	r2, r2, #2
 c051c06:	f8c3 20a8 	str.w	r2, [r3, #168]	@ 0xa8
 c051c0a:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
    SYSCFG->CSLCKR |= SYSCFG_CSLCKR_LOCKSMPU;
 c051c0e:	4a22      	ldr	r2, [pc, #136]	@ (c051c98 <mpu_init+0x180>)
    __HAL_RCC_SYSCFG_CLK_ENABLE();
 c051c10:	f003 0302 	and.w	r3, r3, #2
 c051c14:	9303      	str	r3, [sp, #12]
 c051c16:	9b03      	ldr	r3, [sp, #12]
    SYSCFG->CSLCKR |= SYSCFG_CSLCKR_LOCKSMPU;
 c051c18:	6913      	ldr	r3, [r2, #16]
 c051c1a:	f043 0302 	orr.w	r3, r3, #2
 c051c1e:	6113      	str	r3, [r2, #16]
    FLOW_CONTROL_STEP(uFlowProtectValue, FLOW_STEP_MPU_S_LCK, FLOW_CTRL_MPU_S_LCK);
 c051c20:	6822      	ldr	r2, [r4, #0]
 c051c22:	4b1e      	ldr	r3, [pc, #120]	@ (c051c9c <mpu_init+0x184>)
 c051c24:	4053      	eors	r3, r2
 c051c26:	6023      	str	r3, [r4, #0]
 c051c28:	6822      	ldr	r2, [r4, #0]
 c051c2a:	4b1d      	ldr	r3, [pc, #116]	@ (c051ca0 <mpu_init+0x188>)
 c051c2c:	429a      	cmp	r2, r3
 c051c2e:	d001      	beq.n	c051c34 <mpu_init+0x11c>
 c051c30:	f000 fe9a 	bl	c052968 <Error_Handler>
    if (!((*(uint32_t *)read_reg) & SYSCFG_CSLCKR_LOCKSMPU))
 c051c34:	9b02      	ldr	r3, [sp, #8]
 c051c36:	681b      	ldr	r3, [r3, #0]
 c051c38:	079b      	lsls	r3, r3, #30
 c051c3a:	d401      	bmi.n	c051c40 <mpu_init+0x128>
        Error_Handler();
 c051c3c:	f000 fe94 	bl	c052968 <Error_Handler>
    FLOW_CONTROL_STEP(uFlowProtectValue, FLOW_STEP_MPU_S_LCK_CH, FLOW_CTRL_MPU_S_LCK_CH);
 c051c40:	6822      	ldr	r2, [r4, #0]
 c051c42:	4b18      	ldr	r3, [pc, #96]	@ (c051ca4 <mpu_init+0x18c>)
 c051c44:	4053      	eors	r3, r2
 c051c46:	6023      	str	r3, [r4, #0]
 c051c48:	6822      	ldr	r2, [r4, #0]
 c051c4a:	4b17      	ldr	r3, [pc, #92]	@ (c051ca8 <mpu_init+0x190>)
 c051c4c:	e7ab      	b.n	c051ba6 <mpu_init+0x8e>
        FLOW_CONTROL_STEP(uFlowProtectValue, region_cfg_init_s[i].flow_step_check,
 c051c4e:	683b      	ldr	r3, [r7, #0]
 c051c50:	69e2      	ldr	r2, [r4, #28]
 c051c52:	4053      	eors	r3, r2
 c051c54:	603b      	str	r3, [r7, #0]
 c051c56:	683b      	ldr	r3, [r7, #0]
 c051c58:	6a22      	ldr	r2, [r4, #32]
 c051c5a:	429a      	cmp	r2, r3
 c051c5c:	d0bd      	beq.n	c051bda <mpu_init+0xc2>
 c051c5e:	e7ba      	b.n	c051bd6 <mpu_init+0xbe>
      FLOW_CONTROL_STEP(uFlowProtectValue, FLOW_STEP_MPU_S_CH, FLOW_CTRL_MPU_S_CH);
 c051c60:	6822      	ldr	r2, [r4, #0]
 c051c62:	4b12      	ldr	r3, [pc, #72]	@ (c051cac <mpu_init+0x194>)
 c051c64:	4053      	eors	r3, r2
 c051c66:	6023      	str	r3, [r4, #0]
 c051c68:	6822      	ldr	r2, [r4, #0]
 c051c6a:	4b11      	ldr	r3, [pc, #68]	@ (c051cb0 <mpu_init+0x198>)
 c051c6c:	429a      	cmp	r2, r3
 c051c6e:	d0c3      	beq.n	c051bf8 <mpu_init+0xe0>
 c051c70:	e7c0      	b.n	c051bf4 <mpu_init+0xdc>
 c051c72:	bf00      	nop
 c051c74:	e000ed90 	.word	0xe000ed90
 c051c78:	300308dc 	.word	0x300308dc
 c051c7c:	0c05f960 	.word	0x0c05f960
 c051c80:	300308e0 	.word	0x300308e0
 c051c84:	a5c361e6 	.word	0xa5c361e6
 c051c88:	0006ac56 	.word	0x0006ac56
 c051c8c:	a5c35a3c 	.word	0xa5c35a3c
 c051c90:	56000410 	.word	0x56000410
 c051c94:	56020c00 	.word	0x56020c00
 c051c98:	56000400 	.word	0x56000400
 c051c9c:	005176a3 	.word	0x005176a3
 c051ca0:	00560a1b 	.word	0x00560a1b
 c051ca4:	0051ebea 	.word	0x0051ebea
 c051ca8:	0007e1f1 	.word	0x0007e1f1
 c051cac:	00024fda 	.word	0x00024fda
 c051cb0:	00077cb8 	.word	0x00077cb8

0c051cb4 <tfm_hal_set_up_static_boundaries>:
 c051cb4:	f643 33da 	movw	r3, #15322	@ 0x3bda
#ifdef TFM_FIH_PROFILE_ON
fih_int tfm_hal_set_up_static_boundaries(void)
#else
enum tfm_hal_status_t tfm_hal_set_up_static_boundaries(void)
#endif
{
 c051cb8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c051cbc:	f5ad 7d43 	sub.w	sp, sp, #780	@ 0x30c
 c051cc0:	9368      	str	r3, [sp, #416]	@ 0x1a0
 c051cc2:	4bb7      	ldr	r3, [pc, #732]	@ (c051fa0 <FIH_LABEL_FIH_CALL_END_0_903+0x96>)
 c051cc4:	aa68      	add	r2, sp, #416	@ 0x1a0
 c051cc6:	9369      	str	r3, [sp, #420]	@ 0x1a4
 c051cc8:	ab66      	add	r3, sp, #408	@ 0x198
 c051cca:	4606      	mov	r6, r0
 c051ccc:	e892 0003 	ldmia.w	r2, {r0, r1}
 c051cd0:	e883 0003 	stmia.w	r3, {r0, r1}
    return ret;
 c051cd4:	ac3a      	add	r4, sp, #232	@ 0xe8
 c051cd6:	e893 0003 	ldmia.w	r3, {r0, r1}
 c051cda:	e884 0003 	stmia.w	r4, {r0, r1}
             duration should be kept 1ms since PPP_TIMEOUT_VALUEs are defined and
             handled in milliseconds basis.
       - Set NVIC Group Priority to 3
       - Low Level Initialization
     */
  HAL_Init();
 c051cde:	f7ea fe87 	bl	c03c9f0 <HAL_Init>

  /* Configures non-secure memory spaces in the target */
  uFlowStage = FLOW_STAGE_CFG;
 c051ce2:	4bb0      	ldr	r3, [pc, #704]	@ (c051fa4 <FIH_LABEL_FIH_CALL_END_0_903+0x9a>)
 c051ce4:	4ab0      	ldr	r2, [pc, #704]	@ (c051fa8 <FIH_LABEL_FIH_CALL_END_0_903+0x9e>)
 c051ce6:	601a      	str	r2, [r3, #0]

0c051ce8 <FIH_LABEL_FIH_CALL_START_gtzc_init_cfg_0_410>:
#ifdef TFM_FIH_PROFILE_ON
  FIH_CALL(gtzc_init_cfg, fih_rc);
 c051ce8:	ad3c      	add	r5, sp, #240	@ 0xf0
 c051cea:	2101      	movs	r1, #1
 c051cec:	4628      	mov	r0, r5
 c051cee:	f009 fd3d 	bl	c05b76c <fih_cfi_get_and_increment>
    volatile uint32_t counter = 0;
 c051cf2:	2300      	movs	r3, #0
    volatile uint32_t delay = FIH_NEGATIVE_VALUE;
 c051cf4:	f8df 82b4 	ldr.w	r8, [pc, #692]	@ c051fac <FIH_LABEL_FIH_CALL_END_0_903+0xa2>
 c051cf8:	4fad      	ldr	r7, [pc, #692]	@ (c051fb0 <FIH_LABEL_FIH_CALL_END_0_903+0xa6>)
 c051cfa:	e897 0003 	ldmia.w	r7, {r0, r1}
 c051cfe:	e884 0003 	stmia.w	r4, {r0, r1}
 c051d02:	f8cd 8020 	str.w	r8, [sp, #32]
    volatile uint32_t counter = 0;
 c051d06:	9309      	str	r3, [sp, #36]	@ 0x24
    delay = fih_delay_random();
 c051d08:	f009 fe5f 	bl	c05b9ca <fih_delay_random>
 c051d0c:	9008      	str	r0, [sp, #32]
    if (delay == FIH_NEGATIVE_VALUE) {
 c051d0e:	9b08      	ldr	r3, [sp, #32]
 c051d10:	4543      	cmp	r3, r8
 c051d12:	46b8      	mov	r8, r7
 c051d14:	d101      	bne.n	c051d1a <FIH_LABEL_FIH_CALL_START_gtzc_init_cfg_0_410+0x32>
        FIH_PANIC;
 c051d16:	f000 fe27 	bl	c052968 <Error_Handler>
    delay &= 0xFF;
 c051d1a:	9b08      	ldr	r3, [sp, #32]
 c051d1c:	b2db      	uxtb	r3, r3
 c051d1e:	9308      	str	r3, [sp, #32]
    for (i = 0; i < delay; i++) {
 c051d20:	2300      	movs	r3, #0
 c051d22:	9a08      	ldr	r2, [sp, #32]
 c051d24:	4293      	cmp	r3, r2
 c051d26:	f0c0 8595 	bcc.w	c052854 <FIH_LABEL_FIH_CALL_END_0_2867+0x136>
    uint8_t local_delay = delay;
 c051d2a:	9b08      	ldr	r3, [sp, #32]
    if (counter != local_delay) {
 c051d2c:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 c051d2e:	b2db      	uxtb	r3, r3
 c051d30:	4293      	cmp	r3, r2
 c051d32:	d001      	beq.n	c051d38 <FIH_LABEL_FIH_CALL_START_gtzc_init_cfg_0_410+0x50>
        FIH_PANIC;
 c051d34:	f000 fe18 	bl	c052968 <Error_Handler>
 c051d38:	466f      	mov	r7, sp
 c051d3a:	4638      	mov	r0, r7
 c051d3c:	f7ff fc26 	bl	c05158c <gtzc_init_cfg>
 c051d40:	e897 0003 	ldmia.w	r7, {r0, r1}
 c051d44:	e884 0003 	stmia.w	r4, {r0, r1}
 c051d48:	e895 0003 	ldmia.w	r5, {r0, r1}
 c051d4c:	f009 fda2 	bl	c05b894 <fih_cfi_validate>
 c051d50:	e894 0003 	ldmia.w	r4, {r0, r1}
 c051d54:	ab64      	add	r3, sp, #400	@ 0x190
 c051d56:	e883 0003 	stmia.w	r3, {r0, r1}
    if (x.val != x_msk) {
 c051d5a:	4d96      	ldr	r5, [pc, #600]	@ (c051fb4 <FIH_LABEL_FIH_CALL_END_0_903+0xaa>)
    int x_msk = x.msk;
 c051d5c:	685a      	ldr	r2, [r3, #4]
    if (x.val != x_msk) {
 c051d5e:	6819      	ldr	r1, [r3, #0]
 c051d60:	ea82 0305 	eor.w	r3, r2, r5
 c051d64:	428b      	cmp	r3, r1
 c051d66:	d001      	beq.n	c051d6c <FIH_LABEL_FIH_CALL_END_0_524>
        FIH_PANIC;
 c051d68:	f000 fdfe 	bl	c052968 <Error_Handler>

0c051d6c <FIH_LABEL_FIH_CALL_END_0_524>:
    fih_int ret = {x, x ^ _FIH_MASK_VALUE};
 c051d6c:	f04f 0c00 	mov.w	ip, #0
 c051d70:	aa60      	add	r2, sp, #384	@ 0x180
 c051d72:	f8cd c188 	str.w	ip, [sp, #392]	@ 0x188
 c051d76:	ab62      	add	r3, sp, #392	@ 0x188
 c051d78:	9563      	str	r5, [sp, #396]	@ 0x18c
 c051d7a:	e893 0003 	ldmia.w	r3, {r0, r1}
 c051d7e:	e882 0003 	stmia.w	r2, {r0, r1}
    return ret;
 c051d82:	ab4a      	add	r3, sp, #296	@ 0x128
 c051d84:	e892 0003 	ldmia.w	r2, {r0, r1}
 c051d88:	e883 0003 	stmia.w	r3, {r0, r1}
 c051d8c:	e894 0003 	ldmia.w	r4, {r0, r1}
 c051d90:	f50d 7ab0 	add.w	sl, sp, #352	@ 0x160
 c051d94:	f50d 79b4 	add.w	r9, sp, #360	@ 0x168
 c051d98:	e88a 0003 	stmia.w	sl, {r0, r1}
 c051d9c:	e893 0003 	ldmia.w	r3, {r0, r1}
 c051da0:	e889 0003 	stmia.w	r9, {r0, r1}
}

__attribute__((always_inline)) inline
int32_t fih_not_eq(fih_int x, fih_int y)
{
    volatile int32_t rc1 = FIH_FALSE;
 c051da4:	ab5c      	add	r3, sp, #368	@ 0x170
 c051da6:	f8cd c008 	str.w	ip, [sp, #8]
    volatile int32_t rc2 = FIH_FALSE;
 c051daa:	f8cd c00c 	str.w	ip, [sp, #12]

    fih_int_validate(x);
 c051dae:	e89a 0003 	ldmia.w	sl, {r0, r1}
 c051db2:	e883 0003 	stmia.w	r3, {r0, r1}
    int x_msk = x.msk;
 c051db6:	685a      	ldr	r2, [r3, #4]
    if (x.val != x_msk) {
 c051db8:	6819      	ldr	r1, [r3, #0]
 c051dba:	ea82 0305 	eor.w	r3, r2, r5
 c051dbe:	428b      	cmp	r3, r1
 c051dc0:	d001      	beq.n	c051dc6 <FIH_LABEL_FIH_CALL_END_0_524+0x5a>
        FIH_PANIC;
 c051dc2:	f000 fdd1 	bl	c052968 <Error_Handler>
    fih_int_validate(y);
 c051dc6:	e899 0003 	ldmia.w	r9, {r0, r1}
 c051dca:	ab5e      	add	r3, sp, #376	@ 0x178
 c051dcc:	e883 0003 	stmia.w	r3, {r0, r1}
    int x_msk = x.msk;
 c051dd0:	685a      	ldr	r2, [r3, #4]
    if (x.val != x_msk) {
 c051dd2:	6819      	ldr	r1, [r3, #0]
 c051dd4:	ea82 0305 	eor.w	r3, r2, r5
 c051dd8:	428b      	cmp	r3, r1
 c051dda:	d001      	beq.n	c051de0 <FIH_LABEL_FIH_CALL_END_0_524+0x74>
        FIH_PANIC;
 c051ddc:	f000 fdc4 	bl	c052968 <Error_Handler>

    int x_val = x.val;
 c051de0:	f8da 2000 	ldr.w	r2, [sl]
    if (x_val != y.val) {
 c051de4:	f8d9 3000 	ldr.w	r3, [r9]
    volatile uint32_t delay = FIH_NEGATIVE_VALUE;
 c051de8:	f8df b1c0 	ldr.w	fp, [pc, #448]	@ c051fac <FIH_LABEL_FIH_CALL_END_0_903+0xa2>
    if (x_val != y.val) {
 c051dec:	429a      	cmp	r2, r3
        rc1 = FIH_TRUE;
 c051dee:	bf1c      	itt	ne
 c051df0:	f24c 335a 	movwne	r3, #50010	@ 0xc35a
 c051df4:	9302      	strne	r3, [sp, #8]
    volatile uint32_t counter = 0;
 c051df6:	2300      	movs	r3, #0
    volatile uint32_t delay = FIH_NEGATIVE_VALUE;
 c051df8:	f8cd b018 	str.w	fp, [sp, #24]
    volatile uint32_t counter = 0;
 c051dfc:	9307      	str	r3, [sp, #28]
    delay = fih_delay_random();
 c051dfe:	f009 fde4 	bl	c05b9ca <fih_delay_random>
 c051e02:	9006      	str	r0, [sp, #24]
    if (delay == FIH_NEGATIVE_VALUE) {
 c051e04:	9b06      	ldr	r3, [sp, #24]
 c051e06:	455b      	cmp	r3, fp
 c051e08:	d101      	bne.n	c051e0e <FIH_LABEL_FIH_CALL_END_0_524+0xa2>
        FIH_PANIC;
 c051e0a:	f000 fdad 	bl	c052968 <Error_Handler>
    delay &= 0xFF;
 c051e0e:	9b06      	ldr	r3, [sp, #24]
 c051e10:	b2db      	uxtb	r3, r3
 c051e12:	9306      	str	r3, [sp, #24]
    for (i = 0; i < delay; i++) {
 c051e14:	2300      	movs	r3, #0
 c051e16:	9a06      	ldr	r2, [sp, #24]
 c051e18:	4293      	cmp	r3, r2
 c051e1a:	f0c0 8521 	bcc.w	c052860 <FIH_LABEL_FIH_CALL_END_0_2867+0x142>
    uint8_t local_delay = delay;
 c051e1e:	9b06      	ldr	r3, [sp, #24]
    if (counter != local_delay) {
 c051e20:	9a07      	ldr	r2, [sp, #28]
 c051e22:	b2db      	uxtb	r3, r3
 c051e24:	4293      	cmp	r3, r2
 c051e26:	d001      	beq.n	c051e2c <FIH_LABEL_FIH_CALL_END_0_524+0xc0>
        FIH_PANIC;
 c051e28:	f000 fd9e 	bl	c052968 <Error_Handler>
    }

    fih_delay();

    int x_msk = x.msk;
 c051e2c:	f8da 2004 	ldr.w	r2, [sl, #4]
    if (x_msk != y.msk) {
 c051e30:	f8d9 3004 	ldr.w	r3, [r9, #4]
    volatile uint32_t delay = FIH_NEGATIVE_VALUE;
 c051e34:	f8df 9174 	ldr.w	r9, [pc, #372]	@ c051fac <FIH_LABEL_FIH_CALL_END_0_903+0xa2>
    if (x_msk != y.msk) {
 c051e38:	429a      	cmp	r2, r3
        rc2 = FIH_TRUE;
 c051e3a:	bf1c      	itt	ne
 c051e3c:	f24c 335a 	movwne	r3, #50010	@ 0xc35a
 c051e40:	9303      	strne	r3, [sp, #12]
    volatile uint32_t counter = 0;
 c051e42:	2300      	movs	r3, #0
    volatile uint32_t delay = FIH_NEGATIVE_VALUE;
 c051e44:	f8cd 9010 	str.w	r9, [sp, #16]
    volatile uint32_t counter = 0;
 c051e48:	9305      	str	r3, [sp, #20]
    delay = fih_delay_random();
 c051e4a:	f009 fdbe 	bl	c05b9ca <fih_delay_random>
 c051e4e:	9004      	str	r0, [sp, #16]
    if (delay == FIH_NEGATIVE_VALUE) {
 c051e50:	9b04      	ldr	r3, [sp, #16]
 c051e52:	454b      	cmp	r3, r9
 c051e54:	d101      	bne.n	c051e5a <FIH_LABEL_FIH_CALL_END_0_524+0xee>
        FIH_PANIC;
 c051e56:	f000 fd87 	bl	c052968 <Error_Handler>
    delay &= 0xFF;
 c051e5a:	9b04      	ldr	r3, [sp, #16]
 c051e5c:	b2db      	uxtb	r3, r3
 c051e5e:	9304      	str	r3, [sp, #16]
    for (i = 0; i < delay; i++) {
 c051e60:	2300      	movs	r3, #0
 c051e62:	9a04      	ldr	r2, [sp, #16]
 c051e64:	4293      	cmp	r3, r2
 c051e66:	f0c0 8501 	bcc.w	c05286c <FIH_LABEL_FIH_CALL_END_0_2867+0x14e>
    uint8_t local_delay = delay;
 c051e6a:	9b04      	ldr	r3, [sp, #16]
    if (counter != local_delay) {
 c051e6c:	9a05      	ldr	r2, [sp, #20]
 c051e6e:	b2db      	uxtb	r3, r3
 c051e70:	4293      	cmp	r3, r2
 c051e72:	d001      	beq.n	c051e78 <FIH_LABEL_FIH_CALL_END_0_524+0x10c>
        FIH_PANIC;
 c051e74:	f000 fd78 	bl	c052968 <Error_Handler>
    }

    fih_delay();

    int loc_rc1 = rc1;
 c051e78:	9a02      	ldr	r2, [sp, #8]
    if (loc_rc1 != rc2) {
 c051e7a:	9b03      	ldr	r3, [sp, #12]
 c051e7c:	429a      	cmp	r2, r3
 c051e7e:	d001      	beq.n	c051e84 <FIH_LABEL_FIH_CALL_END_0_524+0x118>
        FIH_PANIC;
 c051e80:	f000 fd72 	bl	c052968 <Error_Handler>
    }

    return rc1;
 c051e84:	9b02      	ldr	r3, [sp, #8]
  if (fih_not_eq(fih_rc, fih_int_encode(TFM_HAL_SUCCESS))) {
 c051e86:	b10b      	cbz	r3, c051e8c <FIH_LABEL_FIH_CALL_START_sau_and_idau_cfg_0_794>
    Error_Handler();
 c051e88:	f000 fd6e 	bl	c052968 <Error_Handler>

0c051e8c <FIH_LABEL_FIH_CALL_START_sau_and_idau_cfg_0_794>:
#else
  gtzc_init_cfg();
#endif

#ifdef TFM_FIH_PROFILE_ON
  FIH_CALL(sau_and_idau_cfg, fih_rc);
 c051e8c:	f10d 09f8 	add.w	r9, sp, #248	@ 0xf8
 c051e90:	2101      	movs	r1, #1
 c051e92:	4648      	mov	r0, r9
 c051e94:	f009 fc6a 	bl	c05b76c <fih_cfi_get_and_increment>
 c051e98:	e898 0003 	ldmia.w	r8, {r0, r1}
    volatile uint32_t counter = 0;
 c051e9c:	2300      	movs	r3, #0
    volatile uint32_t delay = FIH_NEGATIVE_VALUE;
 c051e9e:	f8df 810c 	ldr.w	r8, [pc, #268]	@ c051fac <FIH_LABEL_FIH_CALL_END_0_903+0xa2>
 c051ea2:	e884 0003 	stmia.w	r4, {r0, r1}
 c051ea6:	f8cd 8040 	str.w	r8, [sp, #64]	@ 0x40
    volatile uint32_t counter = 0;
 c051eaa:	9311      	str	r3, [sp, #68]	@ 0x44
    delay = fih_delay_random();
 c051eac:	f009 fd8d 	bl	c05b9ca <fih_delay_random>
 c051eb0:	9010      	str	r0, [sp, #64]	@ 0x40
    if (delay == FIH_NEGATIVE_VALUE) {
 c051eb2:	9b10      	ldr	r3, [sp, #64]	@ 0x40
 c051eb4:	4543      	cmp	r3, r8
 c051eb6:	d101      	bne.n	c051ebc <FIH_LABEL_FIH_CALL_START_sau_and_idau_cfg_0_794+0x30>
        FIH_PANIC;
 c051eb8:	f000 fd56 	bl	c052968 <Error_Handler>
    delay &= 0xFF;
 c051ebc:	9b10      	ldr	r3, [sp, #64]	@ 0x40
 c051ebe:	b2db      	uxtb	r3, r3
 c051ec0:	9310      	str	r3, [sp, #64]	@ 0x40
    for (i = 0; i < delay; i++) {
 c051ec2:	2300      	movs	r3, #0
 c051ec4:	9a10      	ldr	r2, [sp, #64]	@ 0x40
 c051ec6:	4293      	cmp	r3, r2
 c051ec8:	f0c0 84d6 	bcc.w	c052878 <FIH_LABEL_FIH_CALL_END_0_2867+0x15a>
    uint8_t local_delay = delay;
 c051ecc:	9b10      	ldr	r3, [sp, #64]	@ 0x40
    if (counter != local_delay) {
 c051ece:	9a11      	ldr	r2, [sp, #68]	@ 0x44
 c051ed0:	b2db      	uxtb	r3, r3
 c051ed2:	4293      	cmp	r3, r2
 c051ed4:	d001      	beq.n	c051eda <FIH_LABEL_FIH_CALL_START_sau_and_idau_cfg_0_794+0x4e>
        FIH_PANIC;
 c051ed6:	f000 fd47 	bl	c052968 <Error_Handler>
 c051eda:	4638      	mov	r0, r7
 c051edc:	f7ff fa56 	bl	c05138c <sau_and_idau_cfg>
 c051ee0:	e897 0003 	ldmia.w	r7, {r0, r1}
 c051ee4:	e884 0003 	stmia.w	r4, {r0, r1}
 c051ee8:	e899 0003 	ldmia.w	r9, {r0, r1}
 c051eec:	f009 fcd2 	bl	c05b894 <fih_cfi_validate>
 c051ef0:	e894 0003 	ldmia.w	r4, {r0, r1}
 c051ef4:	ab76      	add	r3, sp, #472	@ 0x1d8
 c051ef6:	e883 0003 	stmia.w	r3, {r0, r1}
    int x_msk = x.msk;
 c051efa:	685a      	ldr	r2, [r3, #4]
    if (x.val != x_msk) {
 c051efc:	6819      	ldr	r1, [r3, #0]
 c051efe:	ea82 0305 	eor.w	r3, r2, r5
 c051f02:	428b      	cmp	r3, r1
 c051f04:	d001      	beq.n	c051f0a <FIH_LABEL_FIH_CALL_END_0_903>
        FIH_PANIC;
 c051f06:	f000 fd2f 	bl	c052968 <Error_Handler>

0c051f0a <FIH_LABEL_FIH_CALL_END_0_903>:
    fih_int ret = {x, x ^ _FIH_MASK_VALUE};
 c051f0a:	f04f 0c00 	mov.w	ip, #0
 c051f0e:	aa72      	add	r2, sp, #456	@ 0x1c8
 c051f10:	f8cd c1d0 	str.w	ip, [sp, #464]	@ 0x1d0
 c051f14:	ab74      	add	r3, sp, #464	@ 0x1d0
 c051f16:	9575      	str	r5, [sp, #468]	@ 0x1d4
 c051f18:	e893 0003 	ldmia.w	r3, {r0, r1}
 c051f1c:	e882 0003 	stmia.w	r2, {r0, r1}
    return ret;
 c051f20:	ab4c      	add	r3, sp, #304	@ 0x130
 c051f22:	e892 0003 	ldmia.w	r2, {r0, r1}
 c051f26:	e883 0003 	stmia.w	r3, {r0, r1}
 c051f2a:	e894 0003 	ldmia.w	r4, {r0, r1}
 c051f2e:	af6a      	add	r7, sp, #424	@ 0x1a8
 c051f30:	ac6c      	add	r4, sp, #432	@ 0x1b0
 c051f32:	e887 0003 	stmia.w	r7, {r0, r1}
 c051f36:	e893 0003 	ldmia.w	r3, {r0, r1}
 c051f3a:	e884 0003 	stmia.w	r4, {r0, r1}
    volatile int32_t rc1 = FIH_FALSE;
 c051f3e:	ab6e      	add	r3, sp, #440	@ 0x1b8
 c051f40:	f8cd c028 	str.w	ip, [sp, #40]	@ 0x28
    volatile int32_t rc2 = FIH_FALSE;
 c051f44:	f8cd c02c 	str.w	ip, [sp, #44]	@ 0x2c
    fih_int_validate(x);
 c051f48:	e897 0003 	ldmia.w	r7, {r0, r1}
 c051f4c:	e883 0003 	stmia.w	r3, {r0, r1}
    int x_msk = x.msk;
 c051f50:	685a      	ldr	r2, [r3, #4]
    if (x.val != x_msk) {
 c051f52:	6819      	ldr	r1, [r3, #0]
 c051f54:	ea82 0305 	eor.w	r3, r2, r5
 c051f58:	428b      	cmp	r3, r1
 c051f5a:	d001      	beq.n	c051f60 <FIH_LABEL_FIH_CALL_END_0_903+0x56>
        FIH_PANIC;
 c051f5c:	f000 fd04 	bl	c052968 <Error_Handler>
    fih_int_validate(y);
 c051f60:	e894 0003 	ldmia.w	r4, {r0, r1}
 c051f64:	ab70      	add	r3, sp, #448	@ 0x1c0
 c051f66:	e883 0003 	stmia.w	r3, {r0, r1}
    int x_msk = x.msk;
 c051f6a:	685a      	ldr	r2, [r3, #4]
    if (x.val != x_msk) {
 c051f6c:	6819      	ldr	r1, [r3, #0]
 c051f6e:	ea82 0305 	eor.w	r3, r2, r5
 c051f72:	428b      	cmp	r3, r1
 c051f74:	d001      	beq.n	c051f7a <FIH_LABEL_FIH_CALL_END_0_903+0x70>
        FIH_PANIC;
 c051f76:	f000 fcf7 	bl	c052968 <Error_Handler>
    int x_val = x.val;
 c051f7a:	683a      	ldr	r2, [r7, #0]
    if (x_val != y.val) {
 c051f7c:	6823      	ldr	r3, [r4, #0]
    volatile uint32_t delay = FIH_NEGATIVE_VALUE;
 c051f7e:	4d0b      	ldr	r5, [pc, #44]	@ (c051fac <FIH_LABEL_FIH_CALL_END_0_903+0xa2>)
    if (x_val != y.val) {
 c051f80:	429a      	cmp	r2, r3
        rc1 = FIH_TRUE;
 c051f82:	bf1c      	itt	ne
 c051f84:	f24c 335a 	movwne	r3, #50010	@ 0xc35a
 c051f88:	930a      	strne	r3, [sp, #40]	@ 0x28
    volatile uint32_t counter = 0;
 c051f8a:	2300      	movs	r3, #0
    volatile uint32_t delay = FIH_NEGATIVE_VALUE;
 c051f8c:	950e      	str	r5, [sp, #56]	@ 0x38
    volatile uint32_t counter = 0;
 c051f8e:	930f      	str	r3, [sp, #60]	@ 0x3c
    delay = fih_delay_random();
 c051f90:	f009 fd1b 	bl	c05b9ca <fih_delay_random>
 c051f94:	900e      	str	r0, [sp, #56]	@ 0x38
    if (delay == FIH_NEGATIVE_VALUE) {
 c051f96:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
 c051f98:	42ab      	cmp	r3, r5
 c051f9a:	d10f      	bne.n	c051fbc <FIH_LABEL_FIH_CALL_END_0_903+0xb2>
 c051f9c:	e00c      	b.n	c051fb8 <FIH_LABEL_FIH_CALL_END_0_903+0xae>
 c051f9e:	bf00      	nop
 c051fa0:	a5c361e6 	.word	0xa5c361e6
 c051fa4:	300308dc 	.word	0x300308dc
 c051fa8:	fffffe00 	.word	0xfffffe00
 c051fac:	aaaa5555 	.word	0xaaaa5555
 c051fb0:	3003091c 	.word	0x3003091c
 c051fb4:	a5c35a3c 	.word	0xa5c35a3c
        FIH_PANIC;
 c051fb8:	f000 fcd6 	bl	c052968 <Error_Handler>
    delay &= 0xFF;
 c051fbc:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
 c051fbe:	b2db      	uxtb	r3, r3
 c051fc0:	930e      	str	r3, [sp, #56]	@ 0x38
    for (i = 0; i < delay; i++) {
 c051fc2:	2300      	movs	r3, #0
 c051fc4:	9a0e      	ldr	r2, [sp, #56]	@ 0x38
 c051fc6:	4293      	cmp	r3, r2
 c051fc8:	f0c0 845c 	bcc.w	c052884 <FIH_LABEL_FIH_CALL_END_0_2867+0x166>
    uint8_t local_delay = delay;
 c051fcc:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
    if (counter != local_delay) {
 c051fce:	9a0f      	ldr	r2, [sp, #60]	@ 0x3c
 c051fd0:	b2db      	uxtb	r3, r3
 c051fd2:	4293      	cmp	r3, r2
 c051fd4:	d001      	beq.n	c051fda <FIH_LABEL_FIH_CALL_END_0_903+0xd0>
        FIH_PANIC;
 c051fd6:	f000 fcc7 	bl	c052968 <Error_Handler>
    int x_msk = x.msk;
 c051fda:	687a      	ldr	r2, [r7, #4]
    if (x_msk != y.msk) {
 c051fdc:	6863      	ldr	r3, [r4, #4]
    volatile uint32_t delay = FIH_NEGATIVE_VALUE;
 c051fde:	4cb1      	ldr	r4, [pc, #708]	@ (c0522a4 <FIH_LABEL_FIH_CALL_END_0_1685+0x4c>)
    if (x_msk != y.msk) {
 c051fe0:	429a      	cmp	r2, r3
        rc2 = FIH_TRUE;
 c051fe2:	bf1c      	itt	ne
 c051fe4:	f24c 335a 	movwne	r3, #50010	@ 0xc35a
 c051fe8:	930b      	strne	r3, [sp, #44]	@ 0x2c
    volatile uint32_t counter = 0;
 c051fea:	2300      	movs	r3, #0
    volatile uint32_t delay = FIH_NEGATIVE_VALUE;
 c051fec:	940c      	str	r4, [sp, #48]	@ 0x30
    volatile uint32_t counter = 0;
 c051fee:	930d      	str	r3, [sp, #52]	@ 0x34
    delay = fih_delay_random();
 c051ff0:	f009 fceb 	bl	c05b9ca <fih_delay_random>
 c051ff4:	900c      	str	r0, [sp, #48]	@ 0x30
    if (delay == FIH_NEGATIVE_VALUE) {
 c051ff6:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
 c051ff8:	42a3      	cmp	r3, r4
 c051ffa:	d101      	bne.n	c052000 <FIH_LABEL_FIH_CALL_END_0_903+0xf6>
        FIH_PANIC;
 c051ffc:	f000 fcb4 	bl	c052968 <Error_Handler>
    delay &= 0xFF;
 c052000:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
 c052002:	b2db      	uxtb	r3, r3
 c052004:	930c      	str	r3, [sp, #48]	@ 0x30
    for (i = 0; i < delay; i++) {
 c052006:	2300      	movs	r3, #0
 c052008:	9a0c      	ldr	r2, [sp, #48]	@ 0x30
 c05200a:	4293      	cmp	r3, r2
 c05200c:	f0c0 8440 	bcc.w	c052890 <FIH_LABEL_FIH_CALL_END_0_2867+0x172>
    uint8_t local_delay = delay;
 c052010:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
    if (counter != local_delay) {
 c052012:	9a0d      	ldr	r2, [sp, #52]	@ 0x34
 c052014:	b2db      	uxtb	r3, r3
 c052016:	4293      	cmp	r3, r2
 c052018:	d001      	beq.n	c05201e <FIH_LABEL_FIH_CALL_END_0_903+0x114>
        FIH_PANIC;
 c05201a:	f000 fca5 	bl	c052968 <Error_Handler>
    int loc_rc1 = rc1;
 c05201e:	9a0a      	ldr	r2, [sp, #40]	@ 0x28
    if (loc_rc1 != rc2) {
 c052020:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 c052022:	429a      	cmp	r2, r3
 c052024:	d001      	beq.n	c05202a <FIH_LABEL_FIH_CALL_END_0_903+0x120>
        FIH_PANIC;
 c052026:	f000 fc9f 	bl	c052968 <Error_Handler>
    return rc1;
 c05202a:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
  if (fih_not_eq(fih_rc, fih_int_encode(TFM_HAL_SUCCESS))) {
 c05202c:	b10b      	cbz	r3, c052032 <FIH_LABEL_FIH_CALL_START_pinmux_init_cfg_0_1187>
    Error_Handler();
 c05202e:	f000 fc9b 	bl	c052968 <Error_Handler>

0c052032 <FIH_LABEL_FIH_CALL_START_pinmux_init_cfg_0_1187>:
#else
  sau_and_idau_cfg();
#endif

#ifdef TFM_FIH_PROFILE_ON
  FIH_CALL(pinmux_init_cfg, fih_rc);
 c052032:	ad40      	add	r5, sp, #256	@ 0x100
 c052034:	2101      	movs	r1, #1
 c052036:	4628      	mov	r0, r5
 c052038:	f009 fb98 	bl	c05b76c <fih_cfi_get_and_increment>
    volatile uint32_t counter = 0;
 c05203c:	2300      	movs	r3, #0
    volatile uint32_t delay = FIH_NEGATIVE_VALUE;
 c05203e:	f8df 8264 	ldr.w	r8, [pc, #612]	@ c0522a4 <FIH_LABEL_FIH_CALL_END_0_1685+0x4c>
 c052042:	4f99      	ldr	r7, [pc, #612]	@ (c0522a8 <FIH_LABEL_FIH_CALL_END_0_1685+0x50>)
 c052044:	ac3a      	add	r4, sp, #232	@ 0xe8
 c052046:	e897 0003 	ldmia.w	r7, {r0, r1}
 c05204a:	e884 0003 	stmia.w	r4, {r0, r1}
 c05204e:	f8cd 8060 	str.w	r8, [sp, #96]	@ 0x60
    volatile uint32_t counter = 0;
 c052052:	9319      	str	r3, [sp, #100]	@ 0x64
    delay = fih_delay_random();
 c052054:	f009 fcb9 	bl	c05b9ca <fih_delay_random>
 c052058:	9018      	str	r0, [sp, #96]	@ 0x60
    if (delay == FIH_NEGATIVE_VALUE) {
 c05205a:	9b18      	ldr	r3, [sp, #96]	@ 0x60
 c05205c:	4543      	cmp	r3, r8
 c05205e:	46b8      	mov	r8, r7
 c052060:	d101      	bne.n	c052066 <FIH_LABEL_FIH_CALL_START_pinmux_init_cfg_0_1187+0x34>
        FIH_PANIC;
 c052062:	f000 fc81 	bl	c052968 <Error_Handler>
    delay &= 0xFF;
 c052066:	9b18      	ldr	r3, [sp, #96]	@ 0x60
 c052068:	b2db      	uxtb	r3, r3
 c05206a:	9318      	str	r3, [sp, #96]	@ 0x60
    for (i = 0; i < delay; i++) {
 c05206c:	2300      	movs	r3, #0
 c05206e:	9a18      	ldr	r2, [sp, #96]	@ 0x60
 c052070:	4293      	cmp	r3, r2
 c052072:	f0c0 8413 	bcc.w	c05289c <FIH_LABEL_FIH_CALL_END_0_2867+0x17e>
    uint8_t local_delay = delay;
 c052076:	9b18      	ldr	r3, [sp, #96]	@ 0x60
    if (counter != local_delay) {
 c052078:	9a19      	ldr	r2, [sp, #100]	@ 0x64
 c05207a:	b2db      	uxtb	r3, r3
 c05207c:	4293      	cmp	r3, r2
 c05207e:	d001      	beq.n	c052084 <FIH_LABEL_FIH_CALL_START_pinmux_init_cfg_0_1187+0x52>
        FIH_PANIC;
 c052080:	f000 fc72 	bl	c052968 <Error_Handler>
 c052084:	466f      	mov	r7, sp
 c052086:	4638      	mov	r0, r7
 c052088:	f7ff f8ea 	bl	c051260 <pinmux_init_cfg>
 c05208c:	e897 0003 	ldmia.w	r7, {r0, r1}
 c052090:	e884 0003 	stmia.w	r4, {r0, r1}
 c052094:	e895 0003 	ldmia.w	r5, {r0, r1}
 c052098:	f009 fbfc 	bl	c05b894 <fih_cfi_validate>
 c05209c:	e894 0003 	ldmia.w	r4, {r0, r1}
 c0520a0:	ab84      	add	r3, sp, #528	@ 0x210
 c0520a2:	e883 0003 	stmia.w	r3, {r0, r1}
    if (x.val != x_msk) {
 c0520a6:	4d81      	ldr	r5, [pc, #516]	@ (c0522ac <FIH_LABEL_FIH_CALL_END_0_1685+0x54>)
    int x_msk = x.msk;
 c0520a8:	9b85      	ldr	r3, [sp, #532]	@ 0x214
    if (x.val != x_msk) {
 c0520aa:	9a84      	ldr	r2, [sp, #528]	@ 0x210
 c0520ac:	406b      	eors	r3, r5
 c0520ae:	4293      	cmp	r3, r2
 c0520b0:	d001      	beq.n	c0520b6 <FIH_LABEL_FIH_CALL_END_0_1302>
        FIH_PANIC;
 c0520b2:	f000 fc59 	bl	c052968 <Error_Handler>

0c0520b6 <FIH_LABEL_FIH_CALL_END_0_1302>:
    fih_int ret = {x, x ^ _FIH_MASK_VALUE};
 c0520b6:	f04f 0c00 	mov.w	ip, #0
 c0520ba:	aa80      	add	r2, sp, #512	@ 0x200
 c0520bc:	f8cd c208 	str.w	ip, [sp, #520]	@ 0x208
 c0520c0:	ab82      	add	r3, sp, #520	@ 0x208
 c0520c2:	9583      	str	r5, [sp, #524]	@ 0x20c
 c0520c4:	e893 0003 	ldmia.w	r3, {r0, r1}
 c0520c8:	e882 0003 	stmia.w	r2, {r0, r1}
    return ret;
 c0520cc:	ab4e      	add	r3, sp, #312	@ 0x138
 c0520ce:	e892 0003 	ldmia.w	r2, {r0, r1}
 c0520d2:	e883 0003 	stmia.w	r3, {r0, r1}
 c0520d6:	e894 0003 	ldmia.w	r4, {r0, r1}
 c0520da:	f50d 7af0 	add.w	sl, sp, #480	@ 0x1e0
 c0520de:	f50d 79f4 	add.w	r9, sp, #488	@ 0x1e8
 c0520e2:	e88a 0003 	stmia.w	sl, {r0, r1}
 c0520e6:	e893 0003 	ldmia.w	r3, {r0, r1}
 c0520ea:	e889 0003 	stmia.w	r9, {r0, r1}
    volatile int32_t rc1 = FIH_FALSE;
 c0520ee:	ab7c      	add	r3, sp, #496	@ 0x1f0
 c0520f0:	f8cd c048 	str.w	ip, [sp, #72]	@ 0x48
    volatile int32_t rc2 = FIH_FALSE;
 c0520f4:	f8cd c04c 	str.w	ip, [sp, #76]	@ 0x4c
    fih_int_validate(x);
 c0520f8:	e89a 0003 	ldmia.w	sl, {r0, r1}
 c0520fc:	e883 0003 	stmia.w	r3, {r0, r1}
    int x_msk = x.msk;
 c052100:	685a      	ldr	r2, [r3, #4]
    if (x.val != x_msk) {
 c052102:	6819      	ldr	r1, [r3, #0]
 c052104:	ea82 0305 	eor.w	r3, r2, r5
 c052108:	428b      	cmp	r3, r1
 c05210a:	d001      	beq.n	c052110 <FIH_LABEL_FIH_CALL_END_0_1302+0x5a>
        FIH_PANIC;
 c05210c:	f000 fc2c 	bl	c052968 <Error_Handler>
    fih_int_validate(y);
 c052110:	e899 0003 	ldmia.w	r9, {r0, r1}
 c052114:	ab7e      	add	r3, sp, #504	@ 0x1f8
 c052116:	e883 0003 	stmia.w	r3, {r0, r1}
    int x_msk = x.msk;
 c05211a:	685a      	ldr	r2, [r3, #4]
    if (x.val != x_msk) {
 c05211c:	6819      	ldr	r1, [r3, #0]
 c05211e:	ea82 0305 	eor.w	r3, r2, r5
 c052122:	428b      	cmp	r3, r1
 c052124:	d001      	beq.n	c05212a <FIH_LABEL_FIH_CALL_END_0_1302+0x74>
        FIH_PANIC;
 c052126:	f000 fc1f 	bl	c052968 <Error_Handler>
    int x_val = x.val;
 c05212a:	f8da 2000 	ldr.w	r2, [sl]
    if (x_val != y.val) {
 c05212e:	f8d9 3000 	ldr.w	r3, [r9]
    volatile uint32_t delay = FIH_NEGATIVE_VALUE;
 c052132:	f8df b170 	ldr.w	fp, [pc, #368]	@ c0522a4 <FIH_LABEL_FIH_CALL_END_0_1685+0x4c>
    if (x_val != y.val) {
 c052136:	429a      	cmp	r2, r3
        rc1 = FIH_TRUE;
 c052138:	bf1c      	itt	ne
 c05213a:	f24c 335a 	movwne	r3, #50010	@ 0xc35a
 c05213e:	9312      	strne	r3, [sp, #72]	@ 0x48
    volatile uint32_t counter = 0;
 c052140:	2300      	movs	r3, #0
    volatile uint32_t delay = FIH_NEGATIVE_VALUE;
 c052142:	f8cd b058 	str.w	fp, [sp, #88]	@ 0x58
    volatile uint32_t counter = 0;
 c052146:	9317      	str	r3, [sp, #92]	@ 0x5c
    delay = fih_delay_random();
 c052148:	f009 fc3f 	bl	c05b9ca <fih_delay_random>
 c05214c:	9016      	str	r0, [sp, #88]	@ 0x58
    if (delay == FIH_NEGATIVE_VALUE) {
 c05214e:	9b16      	ldr	r3, [sp, #88]	@ 0x58
 c052150:	455b      	cmp	r3, fp
 c052152:	d101      	bne.n	c052158 <FIH_LABEL_FIH_CALL_END_0_1302+0xa2>
        FIH_PANIC;
 c052154:	f000 fc08 	bl	c052968 <Error_Handler>
    delay &= 0xFF;
 c052158:	9b16      	ldr	r3, [sp, #88]	@ 0x58
 c05215a:	b2db      	uxtb	r3, r3
 c05215c:	9316      	str	r3, [sp, #88]	@ 0x58
    for (i = 0; i < delay; i++) {
 c05215e:	2300      	movs	r3, #0
 c052160:	9a16      	ldr	r2, [sp, #88]	@ 0x58
 c052162:	4293      	cmp	r3, r2
 c052164:	f0c0 83a8 	bcc.w	c0528b8 <FIH_LABEL_FIH_CALL_END_0_2867+0x19a>
    uint8_t local_delay = delay;
 c052168:	9b16      	ldr	r3, [sp, #88]	@ 0x58
    if (counter != local_delay) {
 c05216a:	9a17      	ldr	r2, [sp, #92]	@ 0x5c
 c05216c:	b2db      	uxtb	r3, r3
 c05216e:	4293      	cmp	r3, r2
 c052170:	d001      	beq.n	c052176 <FIH_LABEL_FIH_CALL_END_0_1302+0xc0>
        FIH_PANIC;
 c052172:	f000 fbf9 	bl	c052968 <Error_Handler>
    int x_msk = x.msk;
 c052176:	f8da 2004 	ldr.w	r2, [sl, #4]
    if (x_msk != y.msk) {
 c05217a:	f8d9 3004 	ldr.w	r3, [r9, #4]
    volatile uint32_t delay = FIH_NEGATIVE_VALUE;
 c05217e:	f8df 9124 	ldr.w	r9, [pc, #292]	@ c0522a4 <FIH_LABEL_FIH_CALL_END_0_1685+0x4c>
    if (x_msk != y.msk) {
 c052182:	429a      	cmp	r2, r3
        rc2 = FIH_TRUE;
 c052184:	bf1c      	itt	ne
 c052186:	f24c 335a 	movwne	r3, #50010	@ 0xc35a
 c05218a:	9313      	strne	r3, [sp, #76]	@ 0x4c
    volatile uint32_t counter = 0;
 c05218c:	2300      	movs	r3, #0
    volatile uint32_t delay = FIH_NEGATIVE_VALUE;
 c05218e:	f8cd 9050 	str.w	r9, [sp, #80]	@ 0x50
    volatile uint32_t counter = 0;
 c052192:	9315      	str	r3, [sp, #84]	@ 0x54
    delay = fih_delay_random();
 c052194:	f009 fc19 	bl	c05b9ca <fih_delay_random>
 c052198:	9014      	str	r0, [sp, #80]	@ 0x50
    if (delay == FIH_NEGATIVE_VALUE) {
 c05219a:	9b14      	ldr	r3, [sp, #80]	@ 0x50
 c05219c:	454b      	cmp	r3, r9
 c05219e:	d101      	bne.n	c0521a4 <FIH_LABEL_FIH_CALL_END_0_1302+0xee>
        FIH_PANIC;
 c0521a0:	f000 fbe2 	bl	c052968 <Error_Handler>
    delay &= 0xFF;
 c0521a4:	9b14      	ldr	r3, [sp, #80]	@ 0x50
 c0521a6:	b2db      	uxtb	r3, r3
 c0521a8:	9314      	str	r3, [sp, #80]	@ 0x50
    for (i = 0; i < delay; i++) {
 c0521aa:	2300      	movs	r3, #0
 c0521ac:	9a14      	ldr	r2, [sp, #80]	@ 0x50
 c0521ae:	4293      	cmp	r3, r2
 c0521b0:	f0c0 8387 	bcc.w	c0528c2 <FIH_LABEL_FIH_CALL_END_0_2867+0x1a4>
    uint8_t local_delay = delay;
 c0521b4:	9b14      	ldr	r3, [sp, #80]	@ 0x50
    if (counter != local_delay) {
 c0521b6:	9a15      	ldr	r2, [sp, #84]	@ 0x54
 c0521b8:	b2db      	uxtb	r3, r3
 c0521ba:	4293      	cmp	r3, r2
 c0521bc:	d001      	beq.n	c0521c2 <FIH_LABEL_FIH_CALL_END_0_1302+0x10c>
        FIH_PANIC;
 c0521be:	f000 fbd3 	bl	c052968 <Error_Handler>
    int loc_rc1 = rc1;
 c0521c2:	9a12      	ldr	r2, [sp, #72]	@ 0x48
    if (loc_rc1 != rc2) {
 c0521c4:	9b13      	ldr	r3, [sp, #76]	@ 0x4c
 c0521c6:	429a      	cmp	r2, r3
 c0521c8:	d001      	beq.n	c0521ce <FIH_LABEL_FIH_CALL_END_0_1302+0x118>
        FIH_PANIC;
 c0521ca:	f000 fbcd 	bl	c052968 <Error_Handler>
    return rc1;
 c0521ce:	9b12      	ldr	r3, [sp, #72]	@ 0x48
  if (fih_not_eq(fih_rc, fih_int_encode(TFM_HAL_SUCCESS))) {
 c0521d0:	b10b      	cbz	r3, c0521d6 <FIH_LABEL_FIH_CALL_END_0_1302+0x120>
    Error_Handler();
 c0521d2:	f000 fbc9 	bl	c052968 <Error_Handler>
  pinmux_init_cfg();
#endif


  /* Check configurations with Flow control to resist to basic HW attacks */
  uFlowStage = FLOW_STAGE_CHK;
 c0521d6:	4b36      	ldr	r3, [pc, #216]	@ (c0522b0 <FIH_LABEL_FIH_CALL_END_0_1685+0x58>)
 c0521d8:	4a36      	ldr	r2, [pc, #216]	@ (c0522b4 <FIH_LABEL_FIH_CALL_END_0_1685+0x5c>)
 c0521da:	601a      	str	r2, [r3, #0]

0c0521dc <FIH_LABEL_FIH_CALL_START_gtzc_init_cfg_0_1576>:
  #ifdef TFM_FIH_PROFILE_ON
  FIH_CALL(gtzc_init_cfg, fih_rc);
 c0521dc:	f50d 7984 	add.w	r9, sp, #264	@ 0x108
 c0521e0:	2101      	movs	r1, #1
 c0521e2:	4648      	mov	r0, r9
 c0521e4:	f009 fac2 	bl	c05b76c <fih_cfi_get_and_increment>
 c0521e8:	e898 0003 	ldmia.w	r8, {r0, r1}
    volatile uint32_t counter = 0;
 c0521ec:	2300      	movs	r3, #0
    volatile uint32_t delay = FIH_NEGATIVE_VALUE;
 c0521ee:	f8df 80b4 	ldr.w	r8, [pc, #180]	@ c0522a4 <FIH_LABEL_FIH_CALL_END_0_1685+0x4c>
 c0521f2:	e884 0003 	stmia.w	r4, {r0, r1}
 c0521f6:	f8cd 8080 	str.w	r8, [sp, #128]	@ 0x80
    volatile uint32_t counter = 0;
 c0521fa:	9321      	str	r3, [sp, #132]	@ 0x84
    delay = fih_delay_random();
 c0521fc:	f009 fbe5 	bl	c05b9ca <fih_delay_random>
 c052200:	9020      	str	r0, [sp, #128]	@ 0x80
    if (delay == FIH_NEGATIVE_VALUE) {
 c052202:	9b20      	ldr	r3, [sp, #128]	@ 0x80
 c052204:	4543      	cmp	r3, r8
 c052206:	d101      	bne.n	c05220c <FIH_LABEL_FIH_CALL_START_gtzc_init_cfg_0_1576+0x30>
        FIH_PANIC;
 c052208:	f000 fbae 	bl	c052968 <Error_Handler>
    delay &= 0xFF;
 c05220c:	9b20      	ldr	r3, [sp, #128]	@ 0x80
 c05220e:	b2db      	uxtb	r3, r3
 c052210:	9320      	str	r3, [sp, #128]	@ 0x80
    for (i = 0; i < delay; i++) {
 c052212:	2300      	movs	r3, #0
 c052214:	9a20      	ldr	r2, [sp, #128]	@ 0x80
 c052216:	4293      	cmp	r3, r2
 c052218:	f0c0 8358 	bcc.w	c0528cc <FIH_LABEL_FIH_CALL_END_0_2867+0x1ae>
    uint8_t local_delay = delay;
 c05221c:	9b20      	ldr	r3, [sp, #128]	@ 0x80
    if (counter != local_delay) {
 c05221e:	9a21      	ldr	r2, [sp, #132]	@ 0x84
 c052220:	b2db      	uxtb	r3, r3
 c052222:	4293      	cmp	r3, r2
 c052224:	d001      	beq.n	c05222a <FIH_LABEL_FIH_CALL_START_gtzc_init_cfg_0_1576+0x4e>
        FIH_PANIC;
 c052226:	f000 fb9f 	bl	c052968 <Error_Handler>
 c05222a:	4638      	mov	r0, r7
 c05222c:	f7ff f9ae 	bl	c05158c <gtzc_init_cfg>
 c052230:	e897 0003 	ldmia.w	r7, {r0, r1}
 c052234:	e884 0003 	stmia.w	r4, {r0, r1}
 c052238:	e899 0003 	ldmia.w	r9, {r0, r1}
 c05223c:	f009 fb2a 	bl	c05b894 <fih_cfi_validate>
 c052240:	e894 0003 	ldmia.w	r4, {r0, r1}
 c052244:	ab92      	add	r3, sp, #584	@ 0x248
 c052246:	e883 0003 	stmia.w	r3, {r0, r1}
    int x_msk = x.msk;
 c05224a:	9b93      	ldr	r3, [sp, #588]	@ 0x24c
    if (x.val != x_msk) {
 c05224c:	9a92      	ldr	r2, [sp, #584]	@ 0x248
 c05224e:	406b      	eors	r3, r5
 c052250:	4293      	cmp	r3, r2
 c052252:	d001      	beq.n	c052258 <FIH_LABEL_FIH_CALL_END_0_1685>
        FIH_PANIC;
 c052254:	f000 fb88 	bl	c052968 <Error_Handler>

0c052258 <FIH_LABEL_FIH_CALL_END_0_1685>:
    fih_int ret = {x, x ^ _FIH_MASK_VALUE};
 c052258:	2700      	movs	r7, #0
 c05225a:	ab8e      	add	r3, sp, #568	@ 0x238
 c05225c:	9790      	str	r7, [sp, #576]	@ 0x240
 c05225e:	9591      	str	r5, [sp, #580]	@ 0x244
 c052260:	e9dd 0190 	ldrd	r0, r1, [sp, #576]	@ 0x240
 c052264:	e883 0003 	stmia.w	r3, {r0, r1}
    return ret;
 c052268:	aa50      	add	r2, sp, #320	@ 0x140
 c05226a:	e893 0003 	ldmia.w	r3, {r0, r1}
 c05226e:	e882 0003 	stmia.w	r2, {r0, r1}
 c052272:	e894 0003 	ldmia.w	r4, {r0, r1}
 c052276:	ab86      	add	r3, sp, #536	@ 0x218
 c052278:	ac88      	add	r4, sp, #544	@ 0x220
 c05227a:	e883 0003 	stmia.w	r3, {r0, r1}
 c05227e:	e892 0003 	ldmia.w	r2, {r0, r1}
 c052282:	e884 0003 	stmia.w	r4, {r0, r1}
    volatile int32_t rc1 = FIH_FALSE;
 c052286:	aa8a      	add	r2, sp, #552	@ 0x228
 c052288:	971a      	str	r7, [sp, #104]	@ 0x68
    volatile int32_t rc2 = FIH_FALSE;
 c05228a:	971b      	str	r7, [sp, #108]	@ 0x6c
    fih_int_validate(x);
 c05228c:	e893 0003 	ldmia.w	r3, {r0, r1}
 c052290:	e882 0003 	stmia.w	r2, {r0, r1}
    int x_msk = x.msk;
 c052294:	9b8b      	ldr	r3, [sp, #556]	@ 0x22c
    if (x.val != x_msk) {
 c052296:	9a8a      	ldr	r2, [sp, #552]	@ 0x228
 c052298:	406b      	eors	r3, r5
 c05229a:	4293      	cmp	r3, r2
 c05229c:	d00c      	beq.n	c0522b8 <FIH_LABEL_FIH_CALL_END_0_1685+0x60>
        FIH_PANIC;
 c05229e:	f000 fb63 	bl	c052968 <Error_Handler>
 c0522a2:	e009      	b.n	c0522b8 <FIH_LABEL_FIH_CALL_END_0_1685+0x60>
 c0522a4:	aaaa5555 	.word	0xaaaa5555
 c0522a8:	3003091c 	.word	0x3003091c
 c0522ac:	a5c35a3c 	.word	0xa5c35a3c
 c0522b0:	300308dc 	.word	0x300308dc
 c0522b4:	ffffe01e 	.word	0xffffe01e
    fih_int_validate(y);
 c0522b8:	e894 0003 	ldmia.w	r4, {r0, r1}
 c0522bc:	ab8c      	add	r3, sp, #560	@ 0x230
 c0522be:	e883 0003 	stmia.w	r3, {r0, r1}
    int x_msk = x.msk;
 c0522c2:	9b8d      	ldr	r3, [sp, #564]	@ 0x234
    if (x.val != x_msk) {
 c0522c4:	9a8c      	ldr	r2, [sp, #560]	@ 0x230
 c0522c6:	406b      	eors	r3, r5
 c0522c8:	4293      	cmp	r3, r2
 c0522ca:	d001      	beq.n	c0522d0 <FIH_LABEL_FIH_CALL_END_0_1685+0x78>
        FIH_PANIC;
 c0522cc:	f000 fb4c 	bl	c052968 <Error_Handler>
    int x_val = x.val;
 c0522d0:	9a86      	ldr	r2, [sp, #536]	@ 0x218
    if (x_val != y.val) {
 c0522d2:	9b88      	ldr	r3, [sp, #544]	@ 0x220
    volatile uint32_t delay = FIH_NEGATIVE_VALUE;
 c0522d4:	4cac      	ldr	r4, [pc, #688]	@ (c052588 <FIH_LABEL_FIH_CALL_START_mpu_init_0_2355+0x7e>)
    if (x_val != y.val) {
 c0522d6:	429a      	cmp	r2, r3
        rc1 = FIH_TRUE;
 c0522d8:	bf1c      	itt	ne
 c0522da:	f24c 335a 	movwne	r3, #50010	@ 0xc35a
 c0522de:	931a      	strne	r3, [sp, #104]	@ 0x68
    volatile uint32_t counter = 0;
 c0522e0:	2300      	movs	r3, #0
    volatile uint32_t delay = FIH_NEGATIVE_VALUE;
 c0522e2:	941e      	str	r4, [sp, #120]	@ 0x78
    volatile uint32_t counter = 0;
 c0522e4:	931f      	str	r3, [sp, #124]	@ 0x7c
    delay = fih_delay_random();
 c0522e6:	f009 fb70 	bl	c05b9ca <fih_delay_random>
 c0522ea:	901e      	str	r0, [sp, #120]	@ 0x78
    if (delay == FIH_NEGATIVE_VALUE) {
 c0522ec:	9b1e      	ldr	r3, [sp, #120]	@ 0x78
 c0522ee:	42a3      	cmp	r3, r4
 c0522f0:	d101      	bne.n	c0522f6 <FIH_LABEL_FIH_CALL_END_0_1685+0x9e>
        FIH_PANIC;
 c0522f2:	f000 fb39 	bl	c052968 <Error_Handler>
    delay &= 0xFF;
 c0522f6:	9b1e      	ldr	r3, [sp, #120]	@ 0x78
 c0522f8:	b2db      	uxtb	r3, r3
 c0522fa:	931e      	str	r3, [sp, #120]	@ 0x78
    for (i = 0; i < delay; i++) {
 c0522fc:	2300      	movs	r3, #0
 c0522fe:	9a1e      	ldr	r2, [sp, #120]	@ 0x78
 c052300:	4293      	cmp	r3, r2
 c052302:	f0c0 82e8 	bcc.w	c0528d6 <FIH_LABEL_FIH_CALL_END_0_2867+0x1b8>
    uint8_t local_delay = delay;
 c052306:	9b1e      	ldr	r3, [sp, #120]	@ 0x78
    if (counter != local_delay) {
 c052308:	9a1f      	ldr	r2, [sp, #124]	@ 0x7c
 c05230a:	b2db      	uxtb	r3, r3
 c05230c:	4293      	cmp	r3, r2
 c05230e:	d001      	beq.n	c052314 <FIH_LABEL_FIH_CALL_END_0_1685+0xbc>
        FIH_PANIC;
 c052310:	f000 fb2a 	bl	c052968 <Error_Handler>
    int x_msk = x.msk;
 c052314:	9a87      	ldr	r2, [sp, #540]	@ 0x21c
    if (x_msk != y.msk) {
 c052316:	9b89      	ldr	r3, [sp, #548]	@ 0x224
    volatile uint32_t delay = FIH_NEGATIVE_VALUE;
 c052318:	4c9b      	ldr	r4, [pc, #620]	@ (c052588 <FIH_LABEL_FIH_CALL_START_mpu_init_0_2355+0x7e>)
    if (x_msk != y.msk) {
 c05231a:	429a      	cmp	r2, r3
        rc2 = FIH_TRUE;
 c05231c:	bf1c      	itt	ne
 c05231e:	f24c 335a 	movwne	r3, #50010	@ 0xc35a
 c052322:	931b      	strne	r3, [sp, #108]	@ 0x6c
    volatile uint32_t counter = 0;
 c052324:	2300      	movs	r3, #0
    volatile uint32_t delay = FIH_NEGATIVE_VALUE;
 c052326:	941c      	str	r4, [sp, #112]	@ 0x70
    volatile uint32_t counter = 0;
 c052328:	931d      	str	r3, [sp, #116]	@ 0x74
    delay = fih_delay_random();
 c05232a:	f009 fb4e 	bl	c05b9ca <fih_delay_random>
 c05232e:	901c      	str	r0, [sp, #112]	@ 0x70
    if (delay == FIH_NEGATIVE_VALUE) {
 c052330:	9b1c      	ldr	r3, [sp, #112]	@ 0x70
 c052332:	42a3      	cmp	r3, r4
 c052334:	d101      	bne.n	c05233a <FIH_LABEL_FIH_CALL_END_0_1685+0xe2>
        FIH_PANIC;
 c052336:	f000 fb17 	bl	c052968 <Error_Handler>
    delay &= 0xFF;
 c05233a:	9b1c      	ldr	r3, [sp, #112]	@ 0x70
 c05233c:	b2db      	uxtb	r3, r3
 c05233e:	931c      	str	r3, [sp, #112]	@ 0x70
    for (i = 0; i < delay; i++) {
 c052340:	2300      	movs	r3, #0
 c052342:	9a1c      	ldr	r2, [sp, #112]	@ 0x70
 c052344:	4293      	cmp	r3, r2
 c052346:	f0c0 82cb 	bcc.w	c0528e0 <FIH_LABEL_FIH_CALL_END_0_2867+0x1c2>
    uint8_t local_delay = delay;
 c05234a:	9b1c      	ldr	r3, [sp, #112]	@ 0x70
    if (counter != local_delay) {
 c05234c:	9a1d      	ldr	r2, [sp, #116]	@ 0x74
 c05234e:	b2db      	uxtb	r3, r3
 c052350:	4293      	cmp	r3, r2
 c052352:	d001      	beq.n	c052358 <FIH_LABEL_FIH_CALL_END_0_1685+0x100>
        FIH_PANIC;
 c052354:	f000 fb08 	bl	c052968 <Error_Handler>
    int loc_rc1 = rc1;
 c052358:	9a1a      	ldr	r2, [sp, #104]	@ 0x68
    if (loc_rc1 != rc2) {
 c05235a:	9b1b      	ldr	r3, [sp, #108]	@ 0x6c
 c05235c:	429a      	cmp	r2, r3
 c05235e:	d001      	beq.n	c052364 <FIH_LABEL_FIH_CALL_END_0_1685+0x10c>
        FIH_PANIC;
 c052360:	f000 fb02 	bl	c052968 <Error_Handler>
    return rc1;
 c052364:	9b1a      	ldr	r3, [sp, #104]	@ 0x68
  if (fih_not_eq(fih_rc, fih_int_encode(TFM_HAL_SUCCESS))) {
 c052366:	b10b      	cbz	r3, c05236c <FIH_LABEL_FIH_CALL_START_sau_and_idau_cfg_0_1967>
    Error_Handler();
 c052368:	f000 fafe 	bl	c052968 <Error_Handler>

0c05236c <FIH_LABEL_FIH_CALL_START_sau_and_idau_cfg_0_1967>:
#else
  gtzc_init_cfg();
#endif

#ifdef TFM_FIH_PROFILE_ON
  FIH_CALL(sau_and_idau_cfg, fih_rc);
 c05236c:	ad44      	add	r5, sp, #272	@ 0x110
 c05236e:	2101      	movs	r1, #1
 c052370:	4628      	mov	r0, r5
 c052372:	f009 f9fb 	bl	c05b76c <fih_cfi_get_and_increment>
    volatile uint32_t counter = 0;
 c052376:	2300      	movs	r3, #0
    volatile uint32_t delay = FIH_NEGATIVE_VALUE;
 c052378:	f8df 820c 	ldr.w	r8, [pc, #524]	@ c052588 <FIH_LABEL_FIH_CALL_START_mpu_init_0_2355+0x7e>
 c05237c:	4f83      	ldr	r7, [pc, #524]	@ (c05258c <FIH_LABEL_FIH_CALL_START_mpu_init_0_2355+0x82>)
 c05237e:	ac3a      	add	r4, sp, #232	@ 0xe8
 c052380:	e897 0003 	ldmia.w	r7, {r0, r1}
 c052384:	e884 0003 	stmia.w	r4, {r0, r1}
 c052388:	f8cd 80a0 	str.w	r8, [sp, #160]	@ 0xa0
    volatile uint32_t counter = 0;
 c05238c:	9329      	str	r3, [sp, #164]	@ 0xa4
    delay = fih_delay_random();
 c05238e:	f009 fb1c 	bl	c05b9ca <fih_delay_random>
 c052392:	9028      	str	r0, [sp, #160]	@ 0xa0
    if (delay == FIH_NEGATIVE_VALUE) {
 c052394:	9b28      	ldr	r3, [sp, #160]	@ 0xa0
 c052396:	4543      	cmp	r3, r8
 c052398:	46b8      	mov	r8, r7
 c05239a:	d101      	bne.n	c0523a0 <FIH_LABEL_FIH_CALL_START_sau_and_idau_cfg_0_1967+0x34>
        FIH_PANIC;
 c05239c:	f000 fae4 	bl	c052968 <Error_Handler>
    delay &= 0xFF;
 c0523a0:	9b28      	ldr	r3, [sp, #160]	@ 0xa0
 c0523a2:	b2db      	uxtb	r3, r3
 c0523a4:	9328      	str	r3, [sp, #160]	@ 0xa0
    for (i = 0; i < delay; i++) {
 c0523a6:	2300      	movs	r3, #0
 c0523a8:	9a28      	ldr	r2, [sp, #160]	@ 0xa0
 c0523aa:	4293      	cmp	r3, r2
 c0523ac:	f0c0 829d 	bcc.w	c0528ea <FIH_LABEL_FIH_CALL_END_0_2867+0x1cc>
    uint8_t local_delay = delay;
 c0523b0:	9b28      	ldr	r3, [sp, #160]	@ 0xa0
    if (counter != local_delay) {
 c0523b2:	9a29      	ldr	r2, [sp, #164]	@ 0xa4
 c0523b4:	b2db      	uxtb	r3, r3
 c0523b6:	4293      	cmp	r3, r2
 c0523b8:	d001      	beq.n	c0523be <FIH_LABEL_FIH_CALL_START_sau_and_idau_cfg_0_1967+0x52>
        FIH_PANIC;
 c0523ba:	f000 fad5 	bl	c052968 <Error_Handler>
 c0523be:	466f      	mov	r7, sp
 c0523c0:	4638      	mov	r0, r7
 c0523c2:	f7fe ffe3 	bl	c05138c <sau_and_idau_cfg>
 c0523c6:	e897 0003 	ldmia.w	r7, {r0, r1}
 c0523ca:	e884 0003 	stmia.w	r4, {r0, r1}
 c0523ce:	e895 0003 	ldmia.w	r5, {r0, r1}
 c0523d2:	f009 fa5f 	bl	c05b894 <fih_cfi_validate>
 c0523d6:	e894 0003 	ldmia.w	r4, {r0, r1}
 c0523da:	aba0      	add	r3, sp, #640	@ 0x280
 c0523dc:	e883 0003 	stmia.w	r3, {r0, r1}
    if (x.val != x_msk) {
 c0523e0:	4d6b      	ldr	r5, [pc, #428]	@ (c052590 <FIH_LABEL_FIH_CALL_START_mpu_init_0_2355+0x86>)
    int x_msk = x.msk;
 c0523e2:	9ba1      	ldr	r3, [sp, #644]	@ 0x284
    if (x.val != x_msk) {
 c0523e4:	9aa0      	ldr	r2, [sp, #640]	@ 0x280
 c0523e6:	406b      	eors	r3, r5
 c0523e8:	4293      	cmp	r3, r2
 c0523ea:	d001      	beq.n	c0523f0 <FIH_LABEL_FIH_CALL_END_0_2082>
        FIH_PANIC;
 c0523ec:	f000 fabc 	bl	c052968 <Error_Handler>

0c0523f0 <FIH_LABEL_FIH_CALL_END_0_2082>:
    fih_int ret = {x, x ^ _FIH_MASK_VALUE};
 c0523f0:	f04f 0c00 	mov.w	ip, #0
 c0523f4:	ab9c      	add	r3, sp, #624	@ 0x270
 c0523f6:	f8cd c278 	str.w	ip, [sp, #632]	@ 0x278
 c0523fa:	959f      	str	r5, [sp, #636]	@ 0x27c
 c0523fc:	e9dd 019e 	ldrd	r0, r1, [sp, #632]	@ 0x278
 c052400:	e883 0003 	stmia.w	r3, {r0, r1}
    return ret;
 c052404:	aa52      	add	r2, sp, #328	@ 0x148
 c052406:	e893 0003 	ldmia.w	r3, {r0, r1}
 c05240a:	e882 0003 	stmia.w	r2, {r0, r1}
 c05240e:	e894 0003 	ldmia.w	r4, {r0, r1}
 c052412:	ab94      	add	r3, sp, #592	@ 0x250
 c052414:	f50d 7916 	add.w	r9, sp, #600	@ 0x258
 c052418:	e883 0003 	stmia.w	r3, {r0, r1}
 c05241c:	e892 0003 	ldmia.w	r2, {r0, r1}
 c052420:	e889 0003 	stmia.w	r9, {r0, r1}
    volatile int32_t rc1 = FIH_FALSE;
 c052424:	aa98      	add	r2, sp, #608	@ 0x260
 c052426:	f8cd c088 	str.w	ip, [sp, #136]	@ 0x88
    volatile int32_t rc2 = FIH_FALSE;
 c05242a:	f8cd c08c 	str.w	ip, [sp, #140]	@ 0x8c
    fih_int_validate(x);
 c05242e:	e893 0003 	ldmia.w	r3, {r0, r1}
 c052432:	e882 0003 	stmia.w	r2, {r0, r1}
    int x_msk = x.msk;
 c052436:	9b99      	ldr	r3, [sp, #612]	@ 0x264
    if (x.val != x_msk) {
 c052438:	9a98      	ldr	r2, [sp, #608]	@ 0x260
 c05243a:	406b      	eors	r3, r5
 c05243c:	4293      	cmp	r3, r2
 c05243e:	d001      	beq.n	c052444 <FIH_LABEL_FIH_CALL_END_0_2082+0x54>
        FIH_PANIC;
 c052440:	f000 fa92 	bl	c052968 <Error_Handler>
    fih_int_validate(y);
 c052444:	e899 0003 	ldmia.w	r9, {r0, r1}
 c052448:	ab9a      	add	r3, sp, #616	@ 0x268
 c05244a:	e883 0003 	stmia.w	r3, {r0, r1}
    int x_msk = x.msk;
 c05244e:	9b9b      	ldr	r3, [sp, #620]	@ 0x26c
    if (x.val != x_msk) {
 c052450:	9a9a      	ldr	r2, [sp, #616]	@ 0x268
 c052452:	406b      	eors	r3, r5
 c052454:	4293      	cmp	r3, r2
 c052456:	d001      	beq.n	c05245c <FIH_LABEL_FIH_CALL_END_0_2082+0x6c>
        FIH_PANIC;
 c052458:	f000 fa86 	bl	c052968 <Error_Handler>
    int x_val = x.val;
 c05245c:	9a94      	ldr	r2, [sp, #592]	@ 0x250
    if (x_val != y.val) {
 c05245e:	9b96      	ldr	r3, [sp, #600]	@ 0x258
    volatile uint32_t delay = FIH_NEGATIVE_VALUE;
 c052460:	f8df 9124 	ldr.w	r9, [pc, #292]	@ c052588 <FIH_LABEL_FIH_CALL_START_mpu_init_0_2355+0x7e>
    if (x_val != y.val) {
 c052464:	429a      	cmp	r2, r3
        rc1 = FIH_TRUE;
 c052466:	bf1c      	itt	ne
 c052468:	f24c 335a 	movwne	r3, #50010	@ 0xc35a
 c05246c:	9322      	strne	r3, [sp, #136]	@ 0x88
    volatile uint32_t counter = 0;
 c05246e:	2300      	movs	r3, #0
    volatile uint32_t delay = FIH_NEGATIVE_VALUE;
 c052470:	f8cd 9098 	str.w	r9, [sp, #152]	@ 0x98
    volatile uint32_t counter = 0;
 c052474:	9327      	str	r3, [sp, #156]	@ 0x9c
    delay = fih_delay_random();
 c052476:	f009 faa8 	bl	c05b9ca <fih_delay_random>
 c05247a:	9026      	str	r0, [sp, #152]	@ 0x98
    if (delay == FIH_NEGATIVE_VALUE) {
 c05247c:	9b26      	ldr	r3, [sp, #152]	@ 0x98
 c05247e:	454b      	cmp	r3, r9
 c052480:	d101      	bne.n	c052486 <FIH_LABEL_FIH_CALL_END_0_2082+0x96>
        FIH_PANIC;
 c052482:	f000 fa71 	bl	c052968 <Error_Handler>
    delay &= 0xFF;
 c052486:	9b26      	ldr	r3, [sp, #152]	@ 0x98
 c052488:	b2db      	uxtb	r3, r3
 c05248a:	9326      	str	r3, [sp, #152]	@ 0x98
    for (i = 0; i < delay; i++) {
 c05248c:	2300      	movs	r3, #0
 c05248e:	9a26      	ldr	r2, [sp, #152]	@ 0x98
 c052490:	4293      	cmp	r3, r2
 c052492:	f0c0 822f 	bcc.w	c0528f4 <FIH_LABEL_FIH_CALL_END_0_2867+0x1d6>
    uint8_t local_delay = delay;
 c052496:	9b26      	ldr	r3, [sp, #152]	@ 0x98
    if (counter != local_delay) {
 c052498:	9a27      	ldr	r2, [sp, #156]	@ 0x9c
 c05249a:	b2db      	uxtb	r3, r3
 c05249c:	4293      	cmp	r3, r2
 c05249e:	d001      	beq.n	c0524a4 <FIH_LABEL_FIH_CALL_END_0_2082+0xb4>
        FIH_PANIC;
 c0524a0:	f000 fa62 	bl	c052968 <Error_Handler>
    int x_msk = x.msk;
 c0524a4:	9a95      	ldr	r2, [sp, #596]	@ 0x254
    if (x_msk != y.msk) {
 c0524a6:	9b97      	ldr	r3, [sp, #604]	@ 0x25c
    volatile uint32_t delay = FIH_NEGATIVE_VALUE;
 c0524a8:	f8df 90dc 	ldr.w	r9, [pc, #220]	@ c052588 <FIH_LABEL_FIH_CALL_START_mpu_init_0_2355+0x7e>
    if (x_msk != y.msk) {
 c0524ac:	429a      	cmp	r2, r3
        rc2 = FIH_TRUE;
 c0524ae:	bf1c      	itt	ne
 c0524b0:	f24c 335a 	movwne	r3, #50010	@ 0xc35a
 c0524b4:	9323      	strne	r3, [sp, #140]	@ 0x8c
    volatile uint32_t counter = 0;
 c0524b6:	2300      	movs	r3, #0
    volatile uint32_t delay = FIH_NEGATIVE_VALUE;
 c0524b8:	f8cd 9090 	str.w	r9, [sp, #144]	@ 0x90
    volatile uint32_t counter = 0;
 c0524bc:	9325      	str	r3, [sp, #148]	@ 0x94
    delay = fih_delay_random();
 c0524be:	f009 fa84 	bl	c05b9ca <fih_delay_random>
 c0524c2:	9024      	str	r0, [sp, #144]	@ 0x90
    if (delay == FIH_NEGATIVE_VALUE) {
 c0524c4:	9b24      	ldr	r3, [sp, #144]	@ 0x90
 c0524c6:	454b      	cmp	r3, r9
 c0524c8:	d101      	bne.n	c0524ce <FIH_LABEL_FIH_CALL_END_0_2082+0xde>
        FIH_PANIC;
 c0524ca:	f000 fa4d 	bl	c052968 <Error_Handler>
    delay &= 0xFF;
 c0524ce:	9b24      	ldr	r3, [sp, #144]	@ 0x90
 c0524d0:	b2db      	uxtb	r3, r3
 c0524d2:	9324      	str	r3, [sp, #144]	@ 0x90
    for (i = 0; i < delay; i++) {
 c0524d4:	2300      	movs	r3, #0
 c0524d6:	9a24      	ldr	r2, [sp, #144]	@ 0x90
 c0524d8:	4293      	cmp	r3, r2
 c0524da:	f0c0 8210 	bcc.w	c0528fe <FIH_LABEL_FIH_CALL_END_0_2867+0x1e0>
    uint8_t local_delay = delay;
 c0524de:	9b24      	ldr	r3, [sp, #144]	@ 0x90
    if (counter != local_delay) {
 c0524e0:	9a25      	ldr	r2, [sp, #148]	@ 0x94
 c0524e2:	b2db      	uxtb	r3, r3
 c0524e4:	4293      	cmp	r3, r2
 c0524e6:	d001      	beq.n	c0524ec <FIH_LABEL_FIH_CALL_END_0_2082+0xfc>
        FIH_PANIC;
 c0524e8:	f000 fa3e 	bl	c052968 <Error_Handler>
    int loc_rc1 = rc1;
 c0524ec:	9a22      	ldr	r2, [sp, #136]	@ 0x88
    if (loc_rc1 != rc2) {
 c0524ee:	9b23      	ldr	r3, [sp, #140]	@ 0x8c
 c0524f0:	429a      	cmp	r2, r3
 c0524f2:	d001      	beq.n	c0524f8 <FIH_LABEL_FIH_CALL_END_0_2082+0x108>
        FIH_PANIC;
 c0524f4:	f000 fa38 	bl	c052968 <Error_Handler>
    return rc1;
 c0524f8:	9b22      	ldr	r3, [sp, #136]	@ 0x88
  if (fih_not_eq(fih_rc, fih_int_encode(TFM_HAL_SUCCESS))) {
 c0524fa:	b10b      	cbz	r3, c052500 <FIH_LABEL_FIH_CALL_END_0_2082+0x110>
    Error_Handler();
 c0524fc:	f000 fa34 	bl	c052968 <Error_Handler>
                          HARDFAULT_NMI_ENABLE) != MPU_ARMV8M_OK) {
        return TFM_HAL_ERROR_GENERIC;
    }

#else /* TFM_LVL == 3 */
    uFlowStage = FLOW_STAGE_CFG;
 c052500:	f8df 9090 	ldr.w	r9, [pc, #144]	@ c052594 <FIH_LABEL_FIH_CALL_START_mpu_init_0_2355+0x8a>
 c052504:	4b24      	ldr	r3, [pc, #144]	@ (c052598 <FIH_LABEL_FIH_CALL_START_mpu_init_0_2355+0x8e>)
 c052506:	f8c9 3000 	str.w	r3, [r9]

0c05250a <FIH_LABEL_FIH_CALL_START_mpu_init_0_2355>:
#ifdef TFM_FIH_PROFILE_ON
    FIH_CALL(mpu_init, fih_rc);
 c05250a:	f50d 7a8c 	add.w	sl, sp, #280	@ 0x118
 c05250e:	2101      	movs	r1, #1
 c052510:	4650      	mov	r0, sl
 c052512:	f009 f92b 	bl	c05b76c <fih_cfi_get_and_increment>
 c052516:	e898 0003 	ldmia.w	r8, {r0, r1}
    volatile uint32_t counter = 0;
 c05251a:	2300      	movs	r3, #0
    volatile uint32_t delay = FIH_NEGATIVE_VALUE;
 c05251c:	f8df 8068 	ldr.w	r8, [pc, #104]	@ c052588 <FIH_LABEL_FIH_CALL_START_mpu_init_0_2355+0x7e>
 c052520:	e884 0003 	stmia.w	r4, {r0, r1}
 c052524:	f8cd 80c0 	str.w	r8, [sp, #192]	@ 0xc0
    volatile uint32_t counter = 0;
 c052528:	9331      	str	r3, [sp, #196]	@ 0xc4
    delay = fih_delay_random();
 c05252a:	f009 fa4e 	bl	c05b9ca <fih_delay_random>
 c05252e:	9030      	str	r0, [sp, #192]	@ 0xc0
    if (delay == FIH_NEGATIVE_VALUE) {
 c052530:	9b30      	ldr	r3, [sp, #192]	@ 0xc0
 c052532:	4543      	cmp	r3, r8
 c052534:	d101      	bne.n	c05253a <FIH_LABEL_FIH_CALL_START_mpu_init_0_2355+0x30>
        FIH_PANIC;
 c052536:	f000 fa17 	bl	c052968 <Error_Handler>
    delay &= 0xFF;
 c05253a:	9b30      	ldr	r3, [sp, #192]	@ 0xc0
 c05253c:	b2db      	uxtb	r3, r3
 c05253e:	9330      	str	r3, [sp, #192]	@ 0xc0
    for (i = 0; i < delay; i++) {
 c052540:	2300      	movs	r3, #0
 c052542:	9a30      	ldr	r2, [sp, #192]	@ 0xc0
 c052544:	4293      	cmp	r3, r2
 c052546:	f0c0 81df 	bcc.w	c052908 <FIH_LABEL_FIH_CALL_END_0_2867+0x1ea>
    uint8_t local_delay = delay;
 c05254a:	9b30      	ldr	r3, [sp, #192]	@ 0xc0
    if (counter != local_delay) {
 c05254c:	9a31      	ldr	r2, [sp, #196]	@ 0xc4
 c05254e:	b2db      	uxtb	r3, r3
 c052550:	4293      	cmp	r3, r2
 c052552:	d001      	beq.n	c052558 <FIH_LABEL_FIH_CALL_START_mpu_init_0_2355+0x4e>
        FIH_PANIC;
 c052554:	f000 fa08 	bl	c052968 <Error_Handler>
 c052558:	4638      	mov	r0, r7
 c05255a:	f7ff fadd 	bl	c051b18 <mpu_init>
 c05255e:	e897 0003 	ldmia.w	r7, {r0, r1}
 c052562:	e884 0003 	stmia.w	r4, {r0, r1}
 c052566:	e89a 0003 	ldmia.w	sl, {r0, r1}
 c05256a:	f009 f993 	bl	c05b894 <fih_cfi_validate>
 c05256e:	e894 0003 	ldmia.w	r4, {r0, r1}
 c052572:	abae      	add	r3, sp, #696	@ 0x2b8
 c052574:	e883 0003 	stmia.w	r3, {r0, r1}
    int x_msk = x.msk;
 c052578:	9baf      	ldr	r3, [sp, #700]	@ 0x2bc
    if (x.val != x_msk) {
 c05257a:	9aae      	ldr	r2, [sp, #696]	@ 0x2b8
 c05257c:	406b      	eors	r3, r5
 c05257e:	4293      	cmp	r3, r2
 c052580:	d00c      	beq.n	c05259c <FIH_LABEL_FIH_CALL_END_0_2477>
        FIH_PANIC;
 c052582:	f000 f9f1 	bl	c052968 <Error_Handler>
 c052586:	e009      	b.n	c05259c <FIH_LABEL_FIH_CALL_END_0_2477>
 c052588:	aaaa5555 	.word	0xaaaa5555
 c05258c:	3003091c 	.word	0x3003091c
 c052590:	a5c35a3c 	.word	0xa5c35a3c
 c052594:	300308dc 	.word	0x300308dc
 c052598:	fffffe00 	.word	0xfffffe00

0c05259c <FIH_LABEL_FIH_CALL_END_0_2477>:
    fih_int ret = {x, x ^ _FIH_MASK_VALUE};
 c05259c:	2700      	movs	r7, #0
 c05259e:	abaa      	add	r3, sp, #680	@ 0x2a8
 c0525a0:	97ac      	str	r7, [sp, #688]	@ 0x2b0
 c0525a2:	95ad      	str	r5, [sp, #692]	@ 0x2b4
 c0525a4:	e9dd 01ac 	ldrd	r0, r1, [sp, #688]	@ 0x2b0
 c0525a8:	e883 0003 	stmia.w	r3, {r0, r1}
    return ret;
 c0525ac:	aa54      	add	r2, sp, #336	@ 0x150
 c0525ae:	e893 0003 	ldmia.w	r3, {r0, r1}
 c0525b2:	e882 0003 	stmia.w	r2, {r0, r1}
 c0525b6:	e894 0003 	ldmia.w	r4, {r0, r1}
 c0525ba:	aba2      	add	r3, sp, #648	@ 0x288
 c0525bc:	aca4      	add	r4, sp, #656	@ 0x290
 c0525be:	e883 0003 	stmia.w	r3, {r0, r1}
 c0525c2:	e892 0003 	ldmia.w	r2, {r0, r1}
 c0525c6:	e884 0003 	stmia.w	r4, {r0, r1}
    volatile int32_t rc1 = FIH_FALSE;
 c0525ca:	aaa6      	add	r2, sp, #664	@ 0x298
 c0525cc:	972a      	str	r7, [sp, #168]	@ 0xa8
    volatile int32_t rc2 = FIH_FALSE;
 c0525ce:	972b      	str	r7, [sp, #172]	@ 0xac
    fih_int_validate(x);
 c0525d0:	e893 0003 	ldmia.w	r3, {r0, r1}
 c0525d4:	e882 0003 	stmia.w	r2, {r0, r1}
    int x_msk = x.msk;
 c0525d8:	9ba7      	ldr	r3, [sp, #668]	@ 0x29c
    if (x.val != x_msk) {
 c0525da:	9aa6      	ldr	r2, [sp, #664]	@ 0x298
 c0525dc:	406b      	eors	r3, r5
 c0525de:	4293      	cmp	r3, r2
 c0525e0:	d001      	beq.n	c0525e6 <FIH_LABEL_FIH_CALL_END_0_2477+0x4a>
        FIH_PANIC;
 c0525e2:	f000 f9c1 	bl	c052968 <Error_Handler>
    fih_int_validate(y);
 c0525e6:	e894 0003 	ldmia.w	r4, {r0, r1}
 c0525ea:	aba8      	add	r3, sp, #672	@ 0x2a0
 c0525ec:	e883 0003 	stmia.w	r3, {r0, r1}
    int x_msk = x.msk;
 c0525f0:	9ba9      	ldr	r3, [sp, #676]	@ 0x2a4
    if (x.val != x_msk) {
 c0525f2:	9aa8      	ldr	r2, [sp, #672]	@ 0x2a0
 c0525f4:	406b      	eors	r3, r5
 c0525f6:	4293      	cmp	r3, r2
 c0525f8:	d001      	beq.n	c0525fe <FIH_LABEL_FIH_CALL_END_0_2477+0x62>
        FIH_PANIC;
 c0525fa:	f000 f9b5 	bl	c052968 <Error_Handler>
    int x_val = x.val;
 c0525fe:	9aa2      	ldr	r2, [sp, #648]	@ 0x288
    if (x_val != y.val) {
 c052600:	9ba4      	ldr	r3, [sp, #656]	@ 0x290
    volatile uint32_t delay = FIH_NEGATIVE_VALUE;
 c052602:	4ca9      	ldr	r4, [pc, #676]	@ (c0528a8 <FIH_LABEL_FIH_CALL_END_0_2867+0x18a>)
    if (x_val != y.val) {
 c052604:	429a      	cmp	r2, r3
        rc1 = FIH_TRUE;
 c052606:	bf1c      	itt	ne
 c052608:	f24c 335a 	movwne	r3, #50010	@ 0xc35a
 c05260c:	932a      	strne	r3, [sp, #168]	@ 0xa8
    volatile uint32_t counter = 0;
 c05260e:	2300      	movs	r3, #0
    volatile uint32_t delay = FIH_NEGATIVE_VALUE;
 c052610:	942e      	str	r4, [sp, #184]	@ 0xb8
    volatile uint32_t counter = 0;
 c052612:	932f      	str	r3, [sp, #188]	@ 0xbc
    delay = fih_delay_random();
 c052614:	f009 f9d9 	bl	c05b9ca <fih_delay_random>
 c052618:	902e      	str	r0, [sp, #184]	@ 0xb8
    if (delay == FIH_NEGATIVE_VALUE) {
 c05261a:	9b2e      	ldr	r3, [sp, #184]	@ 0xb8
 c05261c:	42a3      	cmp	r3, r4
 c05261e:	d101      	bne.n	c052624 <FIH_LABEL_FIH_CALL_END_0_2477+0x88>
        FIH_PANIC;
 c052620:	f000 f9a2 	bl	c052968 <Error_Handler>
    delay &= 0xFF;
 c052624:	9b2e      	ldr	r3, [sp, #184]	@ 0xb8
 c052626:	b2db      	uxtb	r3, r3
 c052628:	932e      	str	r3, [sp, #184]	@ 0xb8
    for (i = 0; i < delay; i++) {
 c05262a:	2300      	movs	r3, #0
 c05262c:	9a2e      	ldr	r2, [sp, #184]	@ 0xb8
 c05262e:	4293      	cmp	r3, r2
 c052630:	f0c0 816f 	bcc.w	c052912 <FIH_LABEL_FIH_CALL_END_0_2867+0x1f4>
    uint8_t local_delay = delay;
 c052634:	9b2e      	ldr	r3, [sp, #184]	@ 0xb8
    if (counter != local_delay) {
 c052636:	9a2f      	ldr	r2, [sp, #188]	@ 0xbc
 c052638:	b2db      	uxtb	r3, r3
 c05263a:	4293      	cmp	r3, r2
 c05263c:	d001      	beq.n	c052642 <FIH_LABEL_FIH_CALL_END_0_2477+0xa6>
        FIH_PANIC;
 c05263e:	f000 f993 	bl	c052968 <Error_Handler>
    int x_msk = x.msk;
 c052642:	9aa3      	ldr	r2, [sp, #652]	@ 0x28c
    if (x_msk != y.msk) {
 c052644:	9ba5      	ldr	r3, [sp, #660]	@ 0x294
    volatile uint32_t delay = FIH_NEGATIVE_VALUE;
 c052646:	4c98      	ldr	r4, [pc, #608]	@ (c0528a8 <FIH_LABEL_FIH_CALL_END_0_2867+0x18a>)
    if (x_msk != y.msk) {
 c052648:	429a      	cmp	r2, r3
        rc2 = FIH_TRUE;
 c05264a:	bf1c      	itt	ne
 c05264c:	f24c 335a 	movwne	r3, #50010	@ 0xc35a
 c052650:	932b      	strne	r3, [sp, #172]	@ 0xac
    volatile uint32_t counter = 0;
 c052652:	2300      	movs	r3, #0
    volatile uint32_t delay = FIH_NEGATIVE_VALUE;
 c052654:	942c      	str	r4, [sp, #176]	@ 0xb0
    volatile uint32_t counter = 0;
 c052656:	932d      	str	r3, [sp, #180]	@ 0xb4
    delay = fih_delay_random();
 c052658:	f009 f9b7 	bl	c05b9ca <fih_delay_random>
 c05265c:	902c      	str	r0, [sp, #176]	@ 0xb0
    if (delay == FIH_NEGATIVE_VALUE) {
 c05265e:	9b2c      	ldr	r3, [sp, #176]	@ 0xb0
 c052660:	42a3      	cmp	r3, r4
 c052662:	d101      	bne.n	c052668 <FIH_LABEL_FIH_CALL_END_0_2477+0xcc>
        FIH_PANIC;
 c052664:	f000 f980 	bl	c052968 <Error_Handler>
    delay &= 0xFF;
 c052668:	9b2c      	ldr	r3, [sp, #176]	@ 0xb0
 c05266a:	b2db      	uxtb	r3, r3
 c05266c:	932c      	str	r3, [sp, #176]	@ 0xb0
    for (i = 0; i < delay; i++) {
 c05266e:	2300      	movs	r3, #0
 c052670:	9a2c      	ldr	r2, [sp, #176]	@ 0xb0
 c052672:	4293      	cmp	r3, r2
 c052674:	f0c0 8152 	bcc.w	c05291c <FIH_LABEL_FIH_CALL_END_0_2867+0x1fe>
    uint8_t local_delay = delay;
 c052678:	9b2c      	ldr	r3, [sp, #176]	@ 0xb0
    if (counter != local_delay) {
 c05267a:	9a2d      	ldr	r2, [sp, #180]	@ 0xb4
 c05267c:	b2db      	uxtb	r3, r3
 c05267e:	4293      	cmp	r3, r2
 c052680:	d001      	beq.n	c052686 <FIH_LABEL_FIH_CALL_END_0_2477+0xea>
        FIH_PANIC;
 c052682:	f000 f971 	bl	c052968 <Error_Handler>
    int loc_rc1 = rc1;
 c052686:	9a2a      	ldr	r2, [sp, #168]	@ 0xa8
    if (loc_rc1 != rc2) {
 c052688:	9b2b      	ldr	r3, [sp, #172]	@ 0xac
 c05268a:	429a      	cmp	r2, r3
 c05268c:	d001      	beq.n	c052692 <FIH_LABEL_FIH_CALL_END_0_2477+0xf6>
        FIH_PANIC;
 c05268e:	f000 f96b 	bl	c052968 <Error_Handler>
    return rc1;
 c052692:	9b2a      	ldr	r3, [sp, #168]	@ 0xa8
    if (fih_not_eq(fih_rc, fih_int_encode(TFM_PLAT_ERR_SUCCESS))) {
 c052694:	b10b      	cbz	r3, c05269a <FIH_LABEL_FIH_CALL_END_0_2477+0xfe>
      Error_Handler();
 c052696:	f000 f967 	bl	c052968 <Error_Handler>
    }
#else
    mpu_init();
#endif

    uFlowStage = FLOW_STAGE_CHK;
 c05269a:	4b84      	ldr	r3, [pc, #528]	@ (c0528ac <FIH_LABEL_FIH_CALL_END_0_2867+0x18e>)
 c05269c:	f8c9 3000 	str.w	r3, [r9]

0c0526a0 <FIH_LABEL_FIH_CALL_START_mpu_init_0_2749>:
#ifdef TFM_FIH_PROFILE_ON
    FIH_CALL(mpu_init, fih_rc);
 c0526a0:	ad48      	add	r5, sp, #288	@ 0x120
 c0526a2:	2101      	movs	r1, #1
 c0526a4:	4628      	mov	r0, r5
 c0526a6:	f009 f861 	bl	c05b76c <fih_cfi_get_and_increment>
 c0526aa:	4b81      	ldr	r3, [pc, #516]	@ (c0528b0 <FIH_LABEL_FIH_CALL_END_0_2867+0x192>)
    volatile uint32_t delay = FIH_NEGATIVE_VALUE;
 c0526ac:	4f7e      	ldr	r7, [pc, #504]	@ (c0528a8 <FIH_LABEL_FIH_CALL_END_0_2867+0x18a>)
 c0526ae:	e893 0003 	ldmia.w	r3, {r0, r1}
    volatile uint32_t counter = 0;
 c0526b2:	2300      	movs	r3, #0
 c0526b4:	ac3a      	add	r4, sp, #232	@ 0xe8
 c0526b6:	e884 0003 	stmia.w	r4, {r0, r1}
    volatile uint32_t delay = FIH_NEGATIVE_VALUE;
 c0526ba:	9738      	str	r7, [sp, #224]	@ 0xe0
    volatile uint32_t counter = 0;
 c0526bc:	9339      	str	r3, [sp, #228]	@ 0xe4
    delay = fih_delay_random();
 c0526be:	f009 f984 	bl	c05b9ca <fih_delay_random>
 c0526c2:	9038      	str	r0, [sp, #224]	@ 0xe0
    if (delay == FIH_NEGATIVE_VALUE) {
 c0526c4:	9b38      	ldr	r3, [sp, #224]	@ 0xe0
 c0526c6:	42bb      	cmp	r3, r7
 c0526c8:	d101      	bne.n	c0526ce <FIH_LABEL_FIH_CALL_START_mpu_init_0_2749+0x2e>
        FIH_PANIC;
 c0526ca:	f000 f94d 	bl	c052968 <Error_Handler>
    delay &= 0xFF;
 c0526ce:	9b38      	ldr	r3, [sp, #224]	@ 0xe0
 c0526d0:	b2db      	uxtb	r3, r3
 c0526d2:	9338      	str	r3, [sp, #224]	@ 0xe0
    for (i = 0; i < delay; i++) {
 c0526d4:	2300      	movs	r3, #0
 c0526d6:	9a38      	ldr	r2, [sp, #224]	@ 0xe0
 c0526d8:	4293      	cmp	r3, r2
 c0526da:	f0c0 8124 	bcc.w	c052926 <FIH_LABEL_FIH_CALL_END_0_2867+0x208>
    uint8_t local_delay = delay;
 c0526de:	9b38      	ldr	r3, [sp, #224]	@ 0xe0
    if (counter != local_delay) {
 c0526e0:	9a39      	ldr	r2, [sp, #228]	@ 0xe4
 c0526e2:	b2db      	uxtb	r3, r3
 c0526e4:	4293      	cmp	r3, r2
 c0526e6:	d001      	beq.n	c0526ec <FIH_LABEL_FIH_CALL_START_mpu_init_0_2749+0x4c>
        FIH_PANIC;
 c0526e8:	f000 f93e 	bl	c052968 <Error_Handler>
 c0526ec:	466f      	mov	r7, sp
 c0526ee:	4638      	mov	r0, r7
 c0526f0:	f7ff fa12 	bl	c051b18 <mpu_init>
 c0526f4:	e897 0003 	ldmia.w	r7, {r0, r1}
 c0526f8:	e884 0003 	stmia.w	r4, {r0, r1}
 c0526fc:	e895 0003 	ldmia.w	r5, {r0, r1}
 c052700:	f009 f8c8 	bl	c05b894 <fih_cfi_validate>
 c052704:	e894 0003 	ldmia.w	r4, {r0, r1}
 c052708:	abbc      	add	r3, sp, #752	@ 0x2f0
 c05270a:	e883 0003 	stmia.w	r3, {r0, r1}
    if (x.val != x_msk) {
 c05270e:	4d69      	ldr	r5, [pc, #420]	@ (c0528b4 <FIH_LABEL_FIH_CALL_END_0_2867+0x196>)
    int x_msk = x.msk;
 c052710:	9bbd      	ldr	r3, [sp, #756]	@ 0x2f4
    if (x.val != x_msk) {
 c052712:	9abc      	ldr	r2, [sp, #752]	@ 0x2f0
 c052714:	406b      	eors	r3, r5
 c052716:	4293      	cmp	r3, r2
 c052718:	d001      	beq.n	c05271e <FIH_LABEL_FIH_CALL_END_0_2867>
        FIH_PANIC;
 c05271a:	f000 f925 	bl	c052968 <Error_Handler>

0c05271e <FIH_LABEL_FIH_CALL_END_0_2867>:
    fih_int ret = {x, x ^ _FIH_MASK_VALUE};
 c05271e:	f04f 0c00 	mov.w	ip, #0
 c052722:	abb8      	add	r3, sp, #736	@ 0x2e0
 c052724:	f8cd c2e8 	str.w	ip, [sp, #744]	@ 0x2e8
 c052728:	95bb      	str	r5, [sp, #748]	@ 0x2ec
 c05272a:	e9dd 01ba 	ldrd	r0, r1, [sp, #744]	@ 0x2e8
 c05272e:	e883 0003 	stmia.w	r3, {r0, r1}
    return ret;
 c052732:	aa56      	add	r2, sp, #344	@ 0x158
 c052734:	e893 0003 	ldmia.w	r3, {r0, r1}
 c052738:	e882 0003 	stmia.w	r2, {r0, r1}
 c05273c:	e894 0003 	ldmia.w	r4, {r0, r1}
 c052740:	abb0      	add	r3, sp, #704	@ 0x2c0
 c052742:	afb2      	add	r7, sp, #712	@ 0x2c8
 c052744:	e883 0003 	stmia.w	r3, {r0, r1}
 c052748:	e892 0003 	ldmia.w	r2, {r0, r1}
 c05274c:	e887 0003 	stmia.w	r7, {r0, r1}
    volatile int32_t rc1 = FIH_FALSE;
 c052750:	aab4      	add	r2, sp, #720	@ 0x2d0
 c052752:	f8cd c0c8 	str.w	ip, [sp, #200]	@ 0xc8
    volatile int32_t rc2 = FIH_FALSE;
 c052756:	f8cd c0cc 	str.w	ip, [sp, #204]	@ 0xcc
    fih_int_validate(x);
 c05275a:	e893 0003 	ldmia.w	r3, {r0, r1}
 c05275e:	e882 0003 	stmia.w	r2, {r0, r1}
    int x_msk = x.msk;
 c052762:	9bb5      	ldr	r3, [sp, #724]	@ 0x2d4
    if (x.val != x_msk) {
 c052764:	9ab4      	ldr	r2, [sp, #720]	@ 0x2d0
 c052766:	406b      	eors	r3, r5
 c052768:	4293      	cmp	r3, r2
 c05276a:	d001      	beq.n	c052770 <FIH_LABEL_FIH_CALL_END_0_2867+0x52>
        FIH_PANIC;
 c05276c:	f000 f8fc 	bl	c052968 <Error_Handler>
    fih_int_validate(y);
 c052770:	e897 0003 	ldmia.w	r7, {r0, r1}
 c052774:	abb6      	add	r3, sp, #728	@ 0x2d8
 c052776:	e883 0003 	stmia.w	r3, {r0, r1}
    int x_msk = x.msk;
 c05277a:	9bb7      	ldr	r3, [sp, #732]	@ 0x2dc
    if (x.val != x_msk) {
 c05277c:	9ab6      	ldr	r2, [sp, #728]	@ 0x2d8
 c05277e:	406b      	eors	r3, r5
 c052780:	4293      	cmp	r3, r2
 c052782:	d001      	beq.n	c052788 <FIH_LABEL_FIH_CALL_END_0_2867+0x6a>
        FIH_PANIC;
 c052784:	f000 f8f0 	bl	c052968 <Error_Handler>
    int x_val = x.val;
 c052788:	9ab0      	ldr	r2, [sp, #704]	@ 0x2c0
    if (x_val != y.val) {
 c05278a:	9bb2      	ldr	r3, [sp, #712]	@ 0x2c8
    volatile uint32_t delay = FIH_NEGATIVE_VALUE;
 c05278c:	4f46      	ldr	r7, [pc, #280]	@ (c0528a8 <FIH_LABEL_FIH_CALL_END_0_2867+0x18a>)
    if (x_val != y.val) {
 c05278e:	429a      	cmp	r2, r3
        rc1 = FIH_TRUE;
 c052790:	bf1c      	itt	ne
 c052792:	f24c 335a 	movwne	r3, #50010	@ 0xc35a
 c052796:	9332      	strne	r3, [sp, #200]	@ 0xc8
    volatile uint32_t counter = 0;
 c052798:	2300      	movs	r3, #0
    volatile uint32_t delay = FIH_NEGATIVE_VALUE;
 c05279a:	9736      	str	r7, [sp, #216]	@ 0xd8
    volatile uint32_t counter = 0;
 c05279c:	9337      	str	r3, [sp, #220]	@ 0xdc
    delay = fih_delay_random();
 c05279e:	f009 f914 	bl	c05b9ca <fih_delay_random>
 c0527a2:	9036      	str	r0, [sp, #216]	@ 0xd8
    if (delay == FIH_NEGATIVE_VALUE) {
 c0527a4:	9b36      	ldr	r3, [sp, #216]	@ 0xd8
 c0527a6:	42bb      	cmp	r3, r7
 c0527a8:	d101      	bne.n	c0527ae <FIH_LABEL_FIH_CALL_END_0_2867+0x90>
        FIH_PANIC;
 c0527aa:	f000 f8dd 	bl	c052968 <Error_Handler>
    delay &= 0xFF;
 c0527ae:	9b36      	ldr	r3, [sp, #216]	@ 0xd8
 c0527b0:	b2db      	uxtb	r3, r3
 c0527b2:	9336      	str	r3, [sp, #216]	@ 0xd8
    for (i = 0; i < delay; i++) {
 c0527b4:	2300      	movs	r3, #0
 c0527b6:	9a36      	ldr	r2, [sp, #216]	@ 0xd8
 c0527b8:	4293      	cmp	r3, r2
 c0527ba:	f0c0 80b9 	bcc.w	c052930 <FIH_LABEL_FIH_CALL_END_0_2867+0x212>
    uint8_t local_delay = delay;
 c0527be:	9b36      	ldr	r3, [sp, #216]	@ 0xd8
    if (counter != local_delay) {
 c0527c0:	9a37      	ldr	r2, [sp, #220]	@ 0xdc
 c0527c2:	b2db      	uxtb	r3, r3
 c0527c4:	4293      	cmp	r3, r2
 c0527c6:	d001      	beq.n	c0527cc <FIH_LABEL_FIH_CALL_END_0_2867+0xae>
        FIH_PANIC;
 c0527c8:	f000 f8ce 	bl	c052968 <Error_Handler>
    int x_msk = x.msk;
 c0527cc:	9ab1      	ldr	r2, [sp, #708]	@ 0x2c4
    if (x_msk != y.msk) {
 c0527ce:	9bb3      	ldr	r3, [sp, #716]	@ 0x2cc
    volatile uint32_t delay = FIH_NEGATIVE_VALUE;
 c0527d0:	4f35      	ldr	r7, [pc, #212]	@ (c0528a8 <FIH_LABEL_FIH_CALL_END_0_2867+0x18a>)
    if (x_msk != y.msk) {
 c0527d2:	429a      	cmp	r2, r3
        rc2 = FIH_TRUE;
 c0527d4:	bf1c      	itt	ne
 c0527d6:	f24c 335a 	movwne	r3, #50010	@ 0xc35a
 c0527da:	9333      	strne	r3, [sp, #204]	@ 0xcc
    volatile uint32_t counter = 0;
 c0527dc:	2300      	movs	r3, #0
    volatile uint32_t delay = FIH_NEGATIVE_VALUE;
 c0527de:	9734      	str	r7, [sp, #208]	@ 0xd0
    volatile uint32_t counter = 0;
 c0527e0:	9335      	str	r3, [sp, #212]	@ 0xd4
    delay = fih_delay_random();
 c0527e2:	f009 f8f2 	bl	c05b9ca <fih_delay_random>
 c0527e6:	9034      	str	r0, [sp, #208]	@ 0xd0
    if (delay == FIH_NEGATIVE_VALUE) {
 c0527e8:	9b34      	ldr	r3, [sp, #208]	@ 0xd0
 c0527ea:	42bb      	cmp	r3, r7
 c0527ec:	d101      	bne.n	c0527f2 <FIH_LABEL_FIH_CALL_END_0_2867+0xd4>
        FIH_PANIC;
 c0527ee:	f000 f8bb 	bl	c052968 <Error_Handler>
    delay &= 0xFF;
 c0527f2:	9b34      	ldr	r3, [sp, #208]	@ 0xd0
 c0527f4:	b2db      	uxtb	r3, r3
 c0527f6:	9334      	str	r3, [sp, #208]	@ 0xd0
    for (i = 0; i < delay; i++) {
 c0527f8:	2300      	movs	r3, #0
 c0527fa:	9a34      	ldr	r2, [sp, #208]	@ 0xd0
 c0527fc:	4293      	cmp	r3, r2
 c0527fe:	f0c0 809c 	bcc.w	c05293a <FIH_LABEL_FIH_CALL_END_0_2867+0x21c>
    uint8_t local_delay = delay;
 c052802:	9b34      	ldr	r3, [sp, #208]	@ 0xd0
    if (counter != local_delay) {
 c052804:	9a35      	ldr	r2, [sp, #212]	@ 0xd4
 c052806:	b2db      	uxtb	r3, r3
 c052808:	4293      	cmp	r3, r2
 c05280a:	d001      	beq.n	c052810 <FIH_LABEL_FIH_CALL_END_0_2867+0xf2>
        FIH_PANIC;
 c05280c:	f000 f8ac 	bl	c052968 <Error_Handler>
    int loc_rc1 = rc1;
 c052810:	9a32      	ldr	r2, [sp, #200]	@ 0xc8
    if (loc_rc1 != rc2) {
 c052812:	9b33      	ldr	r3, [sp, #204]	@ 0xcc
 c052814:	429a      	cmp	r2, r3
 c052816:	d001      	beq.n	c05281c <FIH_LABEL_FIH_CALL_END_0_2867+0xfe>
        FIH_PANIC;
 c052818:	f000 f8a6 	bl	c052968 <Error_Handler>
    return rc1;
 c05281c:	9b32      	ldr	r3, [sp, #200]	@ 0xc8
    if (fih_not_eq(fih_rc, fih_int_encode(TFM_PLAT_ERR_SUCCESS))) {
 c05281e:	b10b      	cbz	r3, c052824 <FIH_LABEL_FIH_CALL_END_0_2867+0x106>
      Error_Handler();
 c052820:	f000 f8a2 	bl	c052968 <Error_Handler>
    fih_int ret = {x, x ^ _FIH_MASK_VALUE};
 c052824:	2300      	movs	r3, #0
 c052826:	aac2      	add	r2, sp, #776	@ 0x308
 c052828:	93c0      	str	r3, [sp, #768]	@ 0x300
 c05282a:	95c1      	str	r5, [sp, #772]	@ 0x304
 c05282c:	abbe      	add	r3, sp, #760	@ 0x2f8
 c05282e:	e912 0003 	ldmdb	r2, {r0, r1}
 c052832:	e883 0003 	stmia.w	r3, {r0, r1}
    return ret;
 c052836:	e893 0003 	ldmia.w	r3, {r0, r1}
 c05283a:	e884 0003 	stmia.w	r4, {r0, r1}

#endif /* CONFIG_TFM_ENABLE_MEMORY_PROTECT */

#ifdef TFM_FIH_PROFILE_ON
    fih_rc = fih_int_encode(TFM_HAL_SUCCESS);
    FIH_RET(fih_rc);
 c05283e:	f009 f861 	bl	c05b904 <fih_cfi_decrement>
 c052842:	e894 0003 	ldmia.w	r4, {r0, r1}
 c052846:	e886 0003 	stmia.w	r6, {r0, r1}
#else
    return TFM_HAL_SUCCESS;
#endif
}
 c05284a:	4630      	mov	r0, r6
 c05284c:	f50d 7d43 	add.w	sp, sp, #780	@ 0x30c
 c052850:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        counter++;
 c052854:	9a09      	ldr	r2, [sp, #36]	@ 0x24
    for (i = 0; i < delay; i++) {
 c052856:	3301      	adds	r3, #1
        counter++;
 c052858:	3201      	adds	r2, #1
 c05285a:	9209      	str	r2, [sp, #36]	@ 0x24
    for (i = 0; i < delay; i++) {
 c05285c:	f7ff ba61 	b.w	c051d22 <FIH_LABEL_FIH_CALL_START_gtzc_init_cfg_0_410+0x3a>
        counter++;
 c052860:	9a07      	ldr	r2, [sp, #28]
    for (i = 0; i < delay; i++) {
 c052862:	3301      	adds	r3, #1
        counter++;
 c052864:	3201      	adds	r2, #1
 c052866:	9207      	str	r2, [sp, #28]
    for (i = 0; i < delay; i++) {
 c052868:	f7ff bad5 	b.w	c051e16 <FIH_LABEL_FIH_CALL_END_0_524+0xaa>
        counter++;
 c05286c:	9a05      	ldr	r2, [sp, #20]
    for (i = 0; i < delay; i++) {
 c05286e:	3301      	adds	r3, #1
        counter++;
 c052870:	3201      	adds	r2, #1
 c052872:	9205      	str	r2, [sp, #20]
    for (i = 0; i < delay; i++) {
 c052874:	f7ff baf5 	b.w	c051e62 <FIH_LABEL_FIH_CALL_END_0_524+0xf6>
        counter++;
 c052878:	9a11      	ldr	r2, [sp, #68]	@ 0x44
    for (i = 0; i < delay; i++) {
 c05287a:	3301      	adds	r3, #1
        counter++;
 c05287c:	3201      	adds	r2, #1
 c05287e:	9211      	str	r2, [sp, #68]	@ 0x44
    for (i = 0; i < delay; i++) {
 c052880:	f7ff bb20 	b.w	c051ec4 <FIH_LABEL_FIH_CALL_START_sau_and_idau_cfg_0_794+0x38>
        counter++;
 c052884:	9a0f      	ldr	r2, [sp, #60]	@ 0x3c
    for (i = 0; i < delay; i++) {
 c052886:	3301      	adds	r3, #1
        counter++;
 c052888:	3201      	adds	r2, #1
 c05288a:	920f      	str	r2, [sp, #60]	@ 0x3c
    for (i = 0; i < delay; i++) {
 c05288c:	f7ff bb9a 	b.w	c051fc4 <FIH_LABEL_FIH_CALL_END_0_903+0xba>
        counter++;
 c052890:	9a0d      	ldr	r2, [sp, #52]	@ 0x34
    for (i = 0; i < delay; i++) {
 c052892:	3301      	adds	r3, #1
        counter++;
 c052894:	3201      	adds	r2, #1
 c052896:	920d      	str	r2, [sp, #52]	@ 0x34
    for (i = 0; i < delay; i++) {
 c052898:	f7ff bbb6 	b.w	c052008 <FIH_LABEL_FIH_CALL_END_0_903+0xfe>
        counter++;
 c05289c:	9a19      	ldr	r2, [sp, #100]	@ 0x64
    for (i = 0; i < delay; i++) {
 c05289e:	3301      	adds	r3, #1
        counter++;
 c0528a0:	3201      	adds	r2, #1
 c0528a2:	9219      	str	r2, [sp, #100]	@ 0x64
    for (i = 0; i < delay; i++) {
 c0528a4:	f7ff bbe3 	b.w	c05206e <FIH_LABEL_FIH_CALL_START_pinmux_init_cfg_0_1187+0x3c>
 c0528a8:	aaaa5555 	.word	0xaaaa5555
 c0528ac:	ffffe01e 	.word	0xffffe01e
 c0528b0:	3003091c 	.word	0x3003091c
 c0528b4:	a5c35a3c 	.word	0xa5c35a3c
        counter++;
 c0528b8:	9a17      	ldr	r2, [sp, #92]	@ 0x5c
    for (i = 0; i < delay; i++) {
 c0528ba:	3301      	adds	r3, #1
        counter++;
 c0528bc:	3201      	adds	r2, #1
 c0528be:	9217      	str	r2, [sp, #92]	@ 0x5c
    for (i = 0; i < delay; i++) {
 c0528c0:	e44e      	b.n	c052160 <FIH_LABEL_FIH_CALL_END_0_1302+0xaa>
        counter++;
 c0528c2:	9a15      	ldr	r2, [sp, #84]	@ 0x54
    for (i = 0; i < delay; i++) {
 c0528c4:	3301      	adds	r3, #1
        counter++;
 c0528c6:	3201      	adds	r2, #1
 c0528c8:	9215      	str	r2, [sp, #84]	@ 0x54
    for (i = 0; i < delay; i++) {
 c0528ca:	e46f      	b.n	c0521ac <FIH_LABEL_FIH_CALL_END_0_1302+0xf6>
        counter++;
 c0528cc:	9a21      	ldr	r2, [sp, #132]	@ 0x84
    for (i = 0; i < delay; i++) {
 c0528ce:	3301      	adds	r3, #1
        counter++;
 c0528d0:	3201      	adds	r2, #1
 c0528d2:	9221      	str	r2, [sp, #132]	@ 0x84
    for (i = 0; i < delay; i++) {
 c0528d4:	e49e      	b.n	c052214 <FIH_LABEL_FIH_CALL_START_gtzc_init_cfg_0_1576+0x38>
        counter++;
 c0528d6:	9a1f      	ldr	r2, [sp, #124]	@ 0x7c
    for (i = 0; i < delay; i++) {
 c0528d8:	3301      	adds	r3, #1
        counter++;
 c0528da:	3201      	adds	r2, #1
 c0528dc:	921f      	str	r2, [sp, #124]	@ 0x7c
    for (i = 0; i < delay; i++) {
 c0528de:	e50e      	b.n	c0522fe <FIH_LABEL_FIH_CALL_END_0_1685+0xa6>
        counter++;
 c0528e0:	9a1d      	ldr	r2, [sp, #116]	@ 0x74
    for (i = 0; i < delay; i++) {
 c0528e2:	3301      	adds	r3, #1
        counter++;
 c0528e4:	3201      	adds	r2, #1
 c0528e6:	921d      	str	r2, [sp, #116]	@ 0x74
    for (i = 0; i < delay; i++) {
 c0528e8:	e52b      	b.n	c052342 <FIH_LABEL_FIH_CALL_END_0_1685+0xea>
        counter++;
 c0528ea:	9a29      	ldr	r2, [sp, #164]	@ 0xa4
    for (i = 0; i < delay; i++) {
 c0528ec:	3301      	adds	r3, #1
        counter++;
 c0528ee:	3201      	adds	r2, #1
 c0528f0:	9229      	str	r2, [sp, #164]	@ 0xa4
    for (i = 0; i < delay; i++) {
 c0528f2:	e559      	b.n	c0523a8 <FIH_LABEL_FIH_CALL_START_sau_and_idau_cfg_0_1967+0x3c>
        counter++;
 c0528f4:	9a27      	ldr	r2, [sp, #156]	@ 0x9c
    for (i = 0; i < delay; i++) {
 c0528f6:	3301      	adds	r3, #1
        counter++;
 c0528f8:	3201      	adds	r2, #1
 c0528fa:	9227      	str	r2, [sp, #156]	@ 0x9c
    for (i = 0; i < delay; i++) {
 c0528fc:	e5c7      	b.n	c05248e <FIH_LABEL_FIH_CALL_END_0_2082+0x9e>
        counter++;
 c0528fe:	9a25      	ldr	r2, [sp, #148]	@ 0x94
    for (i = 0; i < delay; i++) {
 c052900:	3301      	adds	r3, #1
        counter++;
 c052902:	3201      	adds	r2, #1
 c052904:	9225      	str	r2, [sp, #148]	@ 0x94
    for (i = 0; i < delay; i++) {
 c052906:	e5e6      	b.n	c0524d6 <FIH_LABEL_FIH_CALL_END_0_2082+0xe6>
        counter++;
 c052908:	9a31      	ldr	r2, [sp, #196]	@ 0xc4
    for (i = 0; i < delay; i++) {
 c05290a:	3301      	adds	r3, #1
        counter++;
 c05290c:	3201      	adds	r2, #1
 c05290e:	9231      	str	r2, [sp, #196]	@ 0xc4
    for (i = 0; i < delay; i++) {
 c052910:	e617      	b.n	c052542 <FIH_LABEL_FIH_CALL_START_mpu_init_0_2355+0x38>
        counter++;
 c052912:	9a2f      	ldr	r2, [sp, #188]	@ 0xbc
    for (i = 0; i < delay; i++) {
 c052914:	3301      	adds	r3, #1
        counter++;
 c052916:	3201      	adds	r2, #1
 c052918:	922f      	str	r2, [sp, #188]	@ 0xbc
    for (i = 0; i < delay; i++) {
 c05291a:	e687      	b.n	c05262c <FIH_LABEL_FIH_CALL_END_0_2477+0x90>
        counter++;
 c05291c:	9a2d      	ldr	r2, [sp, #180]	@ 0xb4
    for (i = 0; i < delay; i++) {
 c05291e:	3301      	adds	r3, #1
        counter++;
 c052920:	3201      	adds	r2, #1
 c052922:	922d      	str	r2, [sp, #180]	@ 0xb4
    for (i = 0; i < delay; i++) {
 c052924:	e6a4      	b.n	c052670 <FIH_LABEL_FIH_CALL_END_0_2477+0xd4>
        counter++;
 c052926:	9a39      	ldr	r2, [sp, #228]	@ 0xe4
    for (i = 0; i < delay; i++) {
 c052928:	3301      	adds	r3, #1
        counter++;
 c05292a:	3201      	adds	r2, #1
 c05292c:	9239      	str	r2, [sp, #228]	@ 0xe4
    for (i = 0; i < delay; i++) {
 c05292e:	e6d2      	b.n	c0526d6 <FIH_LABEL_FIH_CALL_START_mpu_init_0_2749+0x36>
        counter++;
 c052930:	9a37      	ldr	r2, [sp, #220]	@ 0xdc
    for (i = 0; i < delay; i++) {
 c052932:	3301      	adds	r3, #1
        counter++;
 c052934:	3201      	adds	r2, #1
 c052936:	9237      	str	r2, [sp, #220]	@ 0xdc
    for (i = 0; i < delay; i++) {
 c052938:	e73d      	b.n	c0527b6 <FIH_LABEL_FIH_CALL_END_0_2867+0x98>
        counter++;
 c05293a:	9a35      	ldr	r2, [sp, #212]	@ 0xd4
    for (i = 0; i < delay; i++) {
 c05293c:	3301      	adds	r3, #1
        counter++;
 c05293e:	3201      	adds	r2, #1
 c052940:	9235      	str	r2, [sp, #212]	@ 0xd4
    for (i = 0; i < delay; i++) {
 c052942:	e75a      	b.n	c0527fa <FIH_LABEL_FIH_CALL_END_0_2867+0xdc>

0c052944 <__NVIC_SystemReset>:
  __ASM volatile ("dsb 0xF":::"memory");
 c052944:	f3bf 8f4f 	dsb	sy
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 c052948:	4905      	ldr	r1, [pc, #20]	@ (c052960 <__NVIC_SystemReset+0x1c>)
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 c05294a:	4b06      	ldr	r3, [pc, #24]	@ (c052964 <__NVIC_SystemReset+0x20>)
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 c05294c:	68ca      	ldr	r2, [r1, #12]
 c05294e:	f402 62e0 	and.w	r2, r2, #1792	@ 0x700
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 c052952:	4313      	orrs	r3, r2
 c052954:	60cb      	str	r3, [r1, #12]
 c052956:	f3bf 8f4f 	dsb	sy
    __NOP();
 c05295a:	bf00      	nop
  for(;;)                                                           /* wait until reset */
 c05295c:	e7fd      	b.n	c05295a <__NVIC_SystemReset+0x16>
 c05295e:	bf00      	nop
 c052960:	e000ed00 	.word	0xe000ed00
 c052964:	05fa0004 	.word	0x05fa0004

0c052968 <Error_Handler>:
{
 c052968:	b508      	push	{r3, lr}
    NVIC_SystemReset();
 c05296a:	f7ff ffeb 	bl	c052944 <__NVIC_SystemReset>

0c05296e <tfm_hal_system_reset>:
void tfm_hal_system_reset(void)
 c05296e:	b508      	push	{r3, lr}
 c052970:	f7ff ffe8 	bl	c052944 <__NVIC_SystemReset>

0c052974 <SystemInit>:
{
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
   SCB->CPACR |= ((3UL << 20U)|(3UL << 22U));  /* set CP10 and CP11 Full Access */
  #endif
}
 c052974:	4770      	bx	lr

0c052976 <mbedtls_asn1_get_len>:
 */
int mbedtls_asn1_get_len( unsigned char **p,
                  const unsigned char *end,
                  size_t *len )
{
    if( ( end - *p ) < 1 )
 c052976:	6803      	ldr	r3, [r0, #0]
{
 c052978:	b570      	push	{r4, r5, r6, lr}
    if( ( end - *p ) < 1 )
 c05297a:	1acd      	subs	r5, r1, r3
 c05297c:	2d00      	cmp	r5, #0
 c05297e:	dc02      	bgt.n	c052986 <mbedtls_asn1_get_len+0x10>
        return( MBEDTLS_ERR_ASN1_OUT_OF_DATA );
 c052980:	f06f 005f 	mvn.w	r0, #95	@ 0x5f

    if( *len > (size_t) ( end - *p ) )
        return( MBEDTLS_ERR_ASN1_OUT_OF_DATA );

    return( 0 );
}
 c052984:	bd70      	pop	{r4, r5, r6, pc}
    if( ( **p & 0x80 ) == 0 )
 c052986:	f993 6000 	ldrsb.w	r6, [r3]
 c05298a:	781c      	ldrb	r4, [r3, #0]
 c05298c:	2e00      	cmp	r6, #0
 c05298e:	db0a      	blt.n	c0529a6 <mbedtls_asn1_get_len+0x30>
        *len = *(*p)++;
 c052990:	1c5c      	adds	r4, r3, #1
 c052992:	6004      	str	r4, [r0, #0]
 c052994:	781b      	ldrb	r3, [r3, #0]
 c052996:	6013      	str	r3, [r2, #0]
    if( *len > (size_t) ( end - *p ) )
 c052998:	6803      	ldr	r3, [r0, #0]
 c05299a:	1ac9      	subs	r1, r1, r3
 c05299c:	6813      	ldr	r3, [r2, #0]
 c05299e:	428b      	cmp	r3, r1
 c0529a0:	d8ee      	bhi.n	c052980 <mbedtls_asn1_get_len+0xa>
    return( 0 );
 c0529a2:	2000      	movs	r0, #0
 c0529a4:	e7ee      	b.n	c052984 <mbedtls_asn1_get_len+0xe>
        switch( **p & 0x7F )
 c0529a6:	f004 047f 	and.w	r4, r4, #127	@ 0x7f
 c0529aa:	3c01      	subs	r4, #1
 c0529ac:	2c03      	cmp	r4, #3
 c0529ae:	d827      	bhi.n	c052a00 <mbedtls_asn1_get_len+0x8a>
 c0529b0:	e8df f004 	tbb	[pc, r4]
 c0529b4:	1e120902 	.word	0x1e120902
            if( ( end - *p ) < 2 )
 c0529b8:	2d01      	cmp	r5, #1
 c0529ba:	d0e1      	beq.n	c052980 <mbedtls_asn1_get_len+0xa>
            *len = (*p)[1];
 c0529bc:	785c      	ldrb	r4, [r3, #1]
            (*p) += 2;
 c0529be:	3302      	adds	r3, #2
            *len = (*p)[1];
 c0529c0:	6014      	str	r4, [r2, #0]
            (*p) += 5;
 c0529c2:	6003      	str	r3, [r0, #0]
            break;
 c0529c4:	e7e8      	b.n	c052998 <mbedtls_asn1_get_len+0x22>
            if( ( end - *p ) < 3 )
 c0529c6:	2d02      	cmp	r5, #2
 c0529c8:	ddda      	ble.n	c052980 <mbedtls_asn1_get_len+0xa>
            *len = ( (size_t)(*p)[1] << 8 ) | (*p)[2];
 c0529ca:	f8b3 4001 	ldrh.w	r4, [r3, #1]
            (*p) += 3;
 c0529ce:	3303      	adds	r3, #3
            *len = ( (size_t)(*p)[1] << 8 ) | (*p)[2];
 c0529d0:	ba64      	rev16	r4, r4
 c0529d2:	b2a4      	uxth	r4, r4
 c0529d4:	6014      	str	r4, [r2, #0]
            (*p) += 3;
 c0529d6:	e7f4      	b.n	c0529c2 <mbedtls_asn1_get_len+0x4c>
            if( ( end - *p ) < 4 )
 c0529d8:	2d03      	cmp	r5, #3
 c0529da:	ddd1      	ble.n	c052980 <mbedtls_asn1_get_len+0xa>
                   ( (size_t)(*p)[2] << 8  ) | (*p)[3];
 c0529dc:	789c      	ldrb	r4, [r3, #2]
            *len = ( (size_t)(*p)[1] << 16 ) |
 c0529de:	785d      	ldrb	r5, [r3, #1]
                   ( (size_t)(*p)[2] << 8  ) | (*p)[3];
 c0529e0:	0224      	lsls	r4, r4, #8
            *len = ( (size_t)(*p)[1] << 16 ) |
 c0529e2:	ea44 4405 	orr.w	r4, r4, r5, lsl #16
                   ( (size_t)(*p)[2] << 8  ) | (*p)[3];
 c0529e6:	78dd      	ldrb	r5, [r3, #3]
            (*p) += 4;
 c0529e8:	3304      	adds	r3, #4
                   ( (size_t)(*p)[2] << 8  ) | (*p)[3];
 c0529ea:	432c      	orrs	r4, r5
            *len = ( (size_t)(*p)[1] << 16 ) |
 c0529ec:	6014      	str	r4, [r2, #0]
            (*p) += 4;
 c0529ee:	e7e8      	b.n	c0529c2 <mbedtls_asn1_get_len+0x4c>
            if( ( end - *p ) < 5 )
 c0529f0:	2d04      	cmp	r5, #4
 c0529f2:	ddc5      	ble.n	c052980 <mbedtls_asn1_get_len+0xa>
            *len = ( (size_t)(*p)[1] << 24 ) | ( (size_t)(*p)[2] << 16 ) |
 c0529f4:	f8d3 4001 	ldr.w	r4, [r3, #1]
            (*p) += 5;
 c0529f8:	3305      	adds	r3, #5
 c0529fa:	ba24      	rev	r4, r4
            *len = ( (size_t)(*p)[1] << 24 ) | ( (size_t)(*p)[2] << 16 ) |
 c0529fc:	6014      	str	r4, [r2, #0]
            (*p) += 5;
 c0529fe:	e7e0      	b.n	c0529c2 <mbedtls_asn1_get_len+0x4c>
        switch( **p & 0x7F )
 c052a00:	f06f 0063 	mvn.w	r0, #99	@ 0x63
 c052a04:	e7be      	b.n	c052984 <mbedtls_asn1_get_len+0xe>

0c052a06 <mbedtls_asn1_get_tag>:

int mbedtls_asn1_get_tag( unsigned char **p,
                  const unsigned char *end,
                  size_t *len, int tag )
{
 c052a06:	b470      	push	{r4, r5, r6}
    if( ( end - *p ) < 1 )
 c052a08:	6804      	ldr	r4, [r0, #0]
 c052a0a:	1b0e      	subs	r6, r1, r4
 c052a0c:	2e00      	cmp	r6, #0
 c052a0e:	dd07      	ble.n	c052a20 <mbedtls_asn1_get_tag+0x1a>
        return( MBEDTLS_ERR_ASN1_OUT_OF_DATA );

    if( **p != tag )
 c052a10:	7826      	ldrb	r6, [r4, #0]
 c052a12:	429e      	cmp	r6, r3
 c052a14:	d108      	bne.n	c052a28 <mbedtls_asn1_get_tag+0x22>
        return( MBEDTLS_ERR_ASN1_UNEXPECTED_TAG );

    (*p)++;
 c052a16:	3401      	adds	r4, #1
 c052a18:	6004      	str	r4, [r0, #0]

    return( mbedtls_asn1_get_len( p, end, len ) );
}
 c052a1a:	bc70      	pop	{r4, r5, r6}
    return( mbedtls_asn1_get_len( p, end, len ) );
 c052a1c:	f7ff bfab 	b.w	c052976 <mbedtls_asn1_get_len>
        return( MBEDTLS_ERR_ASN1_OUT_OF_DATA );
 c052a20:	f06f 005f 	mvn.w	r0, #95	@ 0x5f
}
 c052a24:	bc70      	pop	{r4, r5, r6}
 c052a26:	4770      	bx	lr
        return( MBEDTLS_ERR_ASN1_UNEXPECTED_TAG );
 c052a28:	f06f 0061 	mvn.w	r0, #97	@ 0x61
 c052a2c:	e7fa      	b.n	c052a24 <mbedtls_asn1_get_tag+0x1e>

0c052a2e <asn1_get_tagged_int>:
}

static int asn1_get_tagged_int( unsigned char **p,
                                const unsigned char *end,
                                int tag, int *val )
{
 c052a2e:	b573      	push	{r0, r1, r4, r5, r6, lr}
 c052a30:	461d      	mov	r5, r3
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    size_t len;

    if( ( ret = mbedtls_asn1_get_tag( p, end, &len, tag ) ) != 0 )
 c052a32:	4613      	mov	r3, r2
 c052a34:	aa01      	add	r2, sp, #4
{
 c052a36:	4604      	mov	r4, r0
    if( ( ret = mbedtls_asn1_get_tag( p, end, &len, tag ) ) != 0 )
 c052a38:	f7ff ffe5 	bl	c052a06 <mbedtls_asn1_get_tag>
 c052a3c:	b918      	cbnz	r0, c052a46 <asn1_get_tagged_int+0x18>

    /*
     * len==0 is malformed (0 must be represented as 020100 for INTEGER,
     * or 0A0100 for ENUMERATED tags
     */
    if( len == 0 )
 c052a3e:	9a01      	ldr	r2, [sp, #4]
 c052a40:	b91a      	cbnz	r2, c052a4a <asn1_get_tagged_int+0x1c>
        return( MBEDTLS_ERR_ASN1_INVALID_LENGTH );
 c052a42:	f06f 0063 	mvn.w	r0, #99	@ 0x63
        *val = ( *val << 8 ) | **p;
        (*p)++;
    }

    return( 0 );
}
 c052a46:	b002      	add	sp, #8
 c052a48:	bd70      	pop	{r4, r5, r6, pc}
    if( ( **p & 0x80 ) != 0 )
 c052a4a:	6823      	ldr	r3, [r4, #0]
 c052a4c:	f993 3000 	ldrsb.w	r3, [r3]
 c052a50:	2b00      	cmp	r3, #0
 c052a52:	dbf6      	blt.n	c052a42 <asn1_get_tagged_int+0x14>
 c052a54:	4601      	mov	r1, r0
    while( len > 0 && **p == 0 )
 c052a56:	6823      	ldr	r3, [r4, #0]
 c052a58:	781e      	ldrb	r6, [r3, #0]
 c052a5a:	b14e      	cbz	r6, c052a70 <asn1_get_tagged_int+0x42>
 c052a5c:	b101      	cbz	r1, c052a60 <asn1_get_tagged_int+0x32>
 c052a5e:	9201      	str	r2, [sp, #4]
    if( len > sizeof( int ) )
 c052a60:	2a04      	cmp	r2, #4
 c052a62:	d8ee      	bhi.n	c052a42 <asn1_get_tagged_int+0x14>
    if( len == sizeof( int ) && ( **p & 0x80 ) != 0 )
 c052a64:	d10b      	bne.n	c052a7e <asn1_get_tagged_int+0x50>
 c052a66:	f993 3000 	ldrsb.w	r3, [r3]
 c052a6a:	2b00      	cmp	r3, #0
 c052a6c:	da07      	bge.n	c052a7e <asn1_get_tagged_int+0x50>
 c052a6e:	e7e8      	b.n	c052a42 <asn1_get_tagged_int+0x14>
        ++( *p );
 c052a70:	3301      	adds	r3, #1
    while( len > 0 && **p == 0 )
 c052a72:	3a01      	subs	r2, #1
 c052a74:	f04f 0101 	mov.w	r1, #1
        ++( *p );
 c052a78:	6023      	str	r3, [r4, #0]
    while( len > 0 && **p == 0 )
 c052a7a:	d1ec      	bne.n	c052a56 <asn1_get_tagged_int+0x28>
 c052a7c:	9201      	str	r2, [sp, #4]
    *val = 0;
 c052a7e:	2300      	movs	r3, #0
 c052a80:	602b      	str	r3, [r5, #0]
    while( len-- > 0 )
 c052a82:	9b01      	ldr	r3, [sp, #4]
 c052a84:	3b01      	subs	r3, #1
 c052a86:	d3de      	bcc.n	c052a46 <asn1_get_tagged_int+0x18>
        *val = ( *val << 8 ) | **p;
 c052a88:	6822      	ldr	r2, [r4, #0]
 c052a8a:	682e      	ldr	r6, [r5, #0]
 c052a8c:	f812 1b01 	ldrb.w	r1, [r2], #1
 c052a90:	ea41 2106 	orr.w	r1, r1, r6, lsl #8
 c052a94:	6029      	str	r1, [r5, #0]
        (*p)++;
 c052a96:	6022      	str	r2, [r4, #0]
 c052a98:	e7f4      	b.n	c052a84 <asn1_get_tagged_int+0x56>

0c052a9a <mbedtls_asn1_get_int>:

int mbedtls_asn1_get_int( unsigned char **p,
                          const unsigned char *end,
                          int *val )
{
 c052a9a:	4613      	mov	r3, r2
    return( asn1_get_tagged_int( p, end, MBEDTLS_ASN1_INTEGER, val) );
 c052a9c:	2202      	movs	r2, #2
 c052a9e:	f7ff bfc6 	b.w	c052a2e <asn1_get_tagged_int>

0c052aa2 <mbedtls_asn1_get_mpi>:

#if defined(MBEDTLS_BIGNUM_C)
int mbedtls_asn1_get_mpi( unsigned char **p,
                  const unsigned char *end,
                  mbedtls_mpi *X )
{
 c052aa2:	b573      	push	{r0, r1, r4, r5, r6, lr}
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    size_t len;

    if( ( ret = mbedtls_asn1_get_tag( p, end, &len, MBEDTLS_ASN1_INTEGER ) ) != 0 )
 c052aa4:	2302      	movs	r3, #2
{
 c052aa6:	4615      	mov	r5, r2
    if( ( ret = mbedtls_asn1_get_tag( p, end, &len, MBEDTLS_ASN1_INTEGER ) ) != 0 )
 c052aa8:	aa01      	add	r2, sp, #4
{
 c052aaa:	4604      	mov	r4, r0
    if( ( ret = mbedtls_asn1_get_tag( p, end, &len, MBEDTLS_ASN1_INTEGER ) ) != 0 )
 c052aac:	f7ff ffab 	bl	c052a06 <mbedtls_asn1_get_tag>
 c052ab0:	b940      	cbnz	r0, c052ac4 <mbedtls_asn1_get_mpi+0x22>
        return( ret );

    ret = mbedtls_mpi_read_binary( X, *p, len );
 c052ab2:	9e01      	ldr	r6, [sp, #4]
 c052ab4:	4628      	mov	r0, r5
 c052ab6:	4632      	mov	r2, r6
 c052ab8:	6821      	ldr	r1, [r4, #0]
 c052aba:	f000 fd76 	bl	c0535aa <mbedtls_mpi_read_binary>

    *p += len;
 c052abe:	6823      	ldr	r3, [r4, #0]
 c052ac0:	4433      	add	r3, r6
 c052ac2:	6023      	str	r3, [r4, #0]

    return( ret );
}
 c052ac4:	b002      	add	sp, #8
 c052ac6:	bd70      	pop	{r4, r5, r6, pc}

0c052ac8 <mbedtls_asn1_get_bitstring_null>:
/*
 * Get a bit string without unused bits
 */
int mbedtls_asn1_get_bitstring_null( unsigned char **p, const unsigned char *end,
                             size_t *len )
{
 c052ac8:	b538      	push	{r3, r4, r5, lr}
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;

    if( ( ret = mbedtls_asn1_get_tag( p, end, len, MBEDTLS_ASN1_BIT_STRING ) ) != 0 )
 c052aca:	2303      	movs	r3, #3
{
 c052acc:	4604      	mov	r4, r0
    if( ( ret = mbedtls_asn1_get_tag( p, end, len, MBEDTLS_ASN1_BIT_STRING ) ) != 0 )
 c052ace:	f7ff ff9a 	bl	c052a06 <mbedtls_asn1_get_tag>
 c052ad2:	b918      	cbnz	r0, c052adc <mbedtls_asn1_get_bitstring_null+0x14>
        return( ret );

    if( *len == 0 )
 c052ad4:	6813      	ldr	r3, [r2, #0]
 c052ad6:	b913      	cbnz	r3, c052ade <mbedtls_asn1_get_bitstring_null+0x16>
        return( MBEDTLS_ERR_ASN1_INVALID_DATA );
 c052ad8:	f06f 0067 	mvn.w	r0, #103	@ 0x67
    if( **p != 0 )
        return( MBEDTLS_ERR_ASN1_INVALID_DATA );
    ++( *p );

    return( 0 );
}
 c052adc:	bd38      	pop	{r3, r4, r5, pc}
    --( *len );
 c052ade:	3b01      	subs	r3, #1
 c052ae0:	6013      	str	r3, [r2, #0]
    if( **p != 0 )
 c052ae2:	6823      	ldr	r3, [r4, #0]
 c052ae4:	781a      	ldrb	r2, [r3, #0]
 c052ae6:	2a00      	cmp	r2, #0
 c052ae8:	d1f6      	bne.n	c052ad8 <mbedtls_asn1_get_bitstring_null+0x10>
    ++( *p );
 c052aea:	3301      	adds	r3, #1
 c052aec:	6023      	str	r3, [r4, #0]
    return( 0 );
 c052aee:	e7f5      	b.n	c052adc <mbedtls_asn1_get_bitstring_null+0x14>

0c052af0 <mbedtls_asn1_get_alg>:
}

int mbedtls_asn1_get_alg( unsigned char **p,
                  const unsigned char *end,
                  mbedtls_asn1_buf *alg, mbedtls_asn1_buf *params )
{
 c052af0:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 c052af4:	4690      	mov	r8, r2
 c052af6:	461f      	mov	r7, r3
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    size_t len;

    if( ( ret = mbedtls_asn1_get_tag( p, end, &len,
 c052af8:	aa01      	add	r2, sp, #4
 c052afa:	2330      	movs	r3, #48	@ 0x30
{
 c052afc:	4605      	mov	r5, r0
 c052afe:	4689      	mov	r9, r1
    if( ( ret = mbedtls_asn1_get_tag( p, end, &len,
 c052b00:	f7ff ff81 	bl	c052a06 <mbedtls_asn1_get_tag>
 c052b04:	4604      	mov	r4, r0
 c052b06:	b9f8      	cbnz	r0, c052b48 <mbedtls_asn1_get_alg+0x58>
            MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) ) != 0 )
        return( ret );

    if( ( end - *p ) < 1 )
 c052b08:	682e      	ldr	r6, [r5, #0]
 c052b0a:	eba9 0906 	sub.w	r9, r9, r6
 c052b0e:	f1b9 0f00 	cmp.w	r9, #0
 c052b12:	dd32      	ble.n	c052b7a <mbedtls_asn1_get_alg+0x8a>
        return( MBEDTLS_ERR_ASN1_OUT_OF_DATA );

    alg->tag = **p;
 c052b14:	4642      	mov	r2, r8
 c052b16:	7833      	ldrb	r3, [r6, #0]
    end = *p + len;

    if( ( ret = mbedtls_asn1_get_tag( p, end, &alg->len, MBEDTLS_ASN1_OID ) ) != 0 )
 c052b18:	4628      	mov	r0, r5
    alg->tag = **p;
 c052b1a:	f842 3b04 	str.w	r3, [r2], #4
    end = *p + len;
 c052b1e:	9b01      	ldr	r3, [sp, #4]
 c052b20:	441e      	add	r6, r3
    if( ( ret = mbedtls_asn1_get_tag( p, end, &alg->len, MBEDTLS_ASN1_OID ) ) != 0 )
 c052b22:	4631      	mov	r1, r6
 c052b24:	2306      	movs	r3, #6
 c052b26:	f7ff ff6e 	bl	c052a06 <mbedtls_asn1_get_tag>
 c052b2a:	4604      	mov	r4, r0
 c052b2c:	b960      	cbnz	r0, c052b48 <mbedtls_asn1_get_alg+0x58>
        return( ret );

    alg->p = *p;
 c052b2e:	682a      	ldr	r2, [r5, #0]
    *p += alg->len;
 c052b30:	f8d8 1004 	ldr.w	r1, [r8, #4]
    alg->p = *p;
 c052b34:	f8c8 2008 	str.w	r2, [r8, #8]
    *p += alg->len;
 c052b38:	1853      	adds	r3, r2, r1

    if( *p == end )
 c052b3a:	42b3      	cmp	r3, r6
    *p += alg->len;
 c052b3c:	602b      	str	r3, [r5, #0]
    if( *p == end )
 c052b3e:	d107      	bne.n	c052b50 <mbedtls_asn1_get_alg+0x60>
    {
        mbedtls_platform_zeroize( params, sizeof(mbedtls_asn1_buf) );
 c052b40:	210c      	movs	r1, #12
 c052b42:	4638      	mov	r0, r7
 c052b44:	f7e8 fc44 	bl	c03b3d0 <mbedtls_platform_zeroize>

    if( *p != end )
        return( MBEDTLS_ERR_ASN1_LENGTH_MISMATCH );

    return( 0 );
}
 c052b48:	4620      	mov	r0, r4
 c052b4a:	b003      	add	sp, #12
 c052b4c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    params->tag = **p;
 c052b50:	5c51      	ldrb	r1, [r2, r1]
 c052b52:	463a      	mov	r2, r7
    (*p)++;
 c052b54:	3301      	adds	r3, #1
    params->tag = **p;
 c052b56:	f842 1b04 	str.w	r1, [r2], #4
    if( ( ret = mbedtls_asn1_get_len( p, end, &params->len ) ) != 0 )
 c052b5a:	4628      	mov	r0, r5
 c052b5c:	4631      	mov	r1, r6
    (*p)++;
 c052b5e:	602b      	str	r3, [r5, #0]
    if( ( ret = mbedtls_asn1_get_len( p, end, &params->len ) ) != 0 )
 c052b60:	f7ff ff09 	bl	c052976 <mbedtls_asn1_get_len>
 c052b64:	b960      	cbnz	r0, c052b80 <mbedtls_asn1_get_alg+0x90>
    params->p = *p;
 c052b66:	682b      	ldr	r3, [r5, #0]
    *p += params->len;
 c052b68:	687a      	ldr	r2, [r7, #4]
    params->p = *p;
 c052b6a:	60bb      	str	r3, [r7, #8]
    *p += params->len;
 c052b6c:	4413      	add	r3, r2
        return( MBEDTLS_ERR_ASN1_LENGTH_MISMATCH );
 c052b6e:	42b3      	cmp	r3, r6
 c052b70:	bf18      	it	ne
 c052b72:	f06f 0465 	mvnne.w	r4, #101	@ 0x65
    *p += params->len;
 c052b76:	602b      	str	r3, [r5, #0]
    if( *p != end )
 c052b78:	e7e6      	b.n	c052b48 <mbedtls_asn1_get_alg+0x58>
        return( MBEDTLS_ERR_ASN1_OUT_OF_DATA );
 c052b7a:	f06f 045f 	mvn.w	r4, #95	@ 0x5f
 c052b7e:	e7e3      	b.n	c052b48 <mbedtls_asn1_get_alg+0x58>
 c052b80:	4604      	mov	r4, r0
 c052b82:	e7e1      	b.n	c052b48 <mbedtls_asn1_get_alg+0x58>

0c052b84 <mbedtls_asn1_write_len>:

int mbedtls_asn1_write_len( unsigned char **p, unsigned char *start, size_t len )
{
    if( len < 0x80 )
    {
        if( *p - start < 1 )
 c052b84:	6803      	ldr	r3, [r0, #0]
    if( len < 0x80 )
 c052b86:	2a7f      	cmp	r2, #127	@ 0x7f
        if( *p - start < 1 )
 c052b88:	eba3 0101 	sub.w	r1, r3, r1
    if( len < 0x80 )
 c052b8c:	d807      	bhi.n	c052b9e <mbedtls_asn1_write_len+0x1a>
        if( *p - start < 1 )
 c052b8e:	2900      	cmp	r1, #0
 c052b90:	dd69      	ble.n	c052c66 <mbedtls_asn1_write_len+0xe2>
            return( MBEDTLS_ERR_ASN1_BUF_TOO_SMALL );

        *--(*p) = (unsigned char) len;
 c052b92:	1e59      	subs	r1, r3, #1
 c052b94:	6001      	str	r1, [r0, #0]
        return( 1 );
 c052b96:	2001      	movs	r0, #1
        *--(*p) = (unsigned char) len;
 c052b98:	f803 2c01 	strb.w	r2, [r3, #-1]
        return( 1 );
 c052b9c:	4770      	bx	lr
    }

    if( len <= 0xFF )
 c052b9e:	2aff      	cmp	r2, #255	@ 0xff
 c052ba0:	d80d      	bhi.n	c052bbe <mbedtls_asn1_write_len+0x3a>
    {
        if( *p - start < 2 )
 c052ba2:	2901      	cmp	r1, #1
 c052ba4:	dd5f      	ble.n	c052c66 <mbedtls_asn1_write_len+0xe2>
            return( MBEDTLS_ERR_ASN1_BUF_TOO_SMALL );

        *--(*p) = (unsigned char) len;
 c052ba6:	1e59      	subs	r1, r3, #1
 c052ba8:	6001      	str	r1, [r0, #0]
 c052baa:	f803 2c01 	strb.w	r2, [r3, #-1]
        *--(*p) = 0x81;
 c052bae:	6803      	ldr	r3, [r0, #0]
 c052bb0:	1e5a      	subs	r2, r3, #1
 c052bb2:	6002      	str	r2, [r0, #0]
 c052bb4:	2281      	movs	r2, #129	@ 0x81
        return( 2 );
 c052bb6:	2002      	movs	r0, #2
        *--(*p) = 0x81;
 c052bb8:	f803 2c01 	strb.w	r2, [r3, #-1]
        return( 2 );
 c052bbc:	4770      	bx	lr
    }

    if( len <= 0xFFFF )
 c052bbe:	f5b2 3f80 	cmp.w	r2, #65536	@ 0x10000
 c052bc2:	d213      	bcs.n	c052bec <mbedtls_asn1_write_len+0x68>
    {
        if( *p - start < 3 )
 c052bc4:	2902      	cmp	r1, #2
 c052bc6:	dd4e      	ble.n	c052c66 <mbedtls_asn1_write_len+0xe2>
            return( MBEDTLS_ERR_ASN1_BUF_TOO_SMALL );

        *--(*p) = MBEDTLS_BYTE_0( len );
 c052bc8:	1e59      	subs	r1, r3, #1
 c052bca:	6001      	str	r1, [r0, #0]
 c052bcc:	f803 2c01 	strb.w	r2, [r3, #-1]
        *--(*p) = MBEDTLS_BYTE_1( len );
 c052bd0:	6803      	ldr	r3, [r0, #0]
 c052bd2:	0a12      	lsrs	r2, r2, #8
 c052bd4:	1e59      	subs	r1, r3, #1
 c052bd6:	6001      	str	r1, [r0, #0]
 c052bd8:	f803 2c01 	strb.w	r2, [r3, #-1]
        *--(*p) = 0x82;
 c052bdc:	6803      	ldr	r3, [r0, #0]
 c052bde:	1e5a      	subs	r2, r3, #1
 c052be0:	6002      	str	r2, [r0, #0]
 c052be2:	2282      	movs	r2, #130	@ 0x82
        return( 3 );
 c052be4:	2003      	movs	r0, #3
        *--(*p) = 0x82;
 c052be6:	f803 2c01 	strb.w	r2, [r3, #-1]
        return( 3 );
 c052bea:	4770      	bx	lr
    }

    if( len <= 0xFFFFFF )
 c052bec:	f1b2 7f80 	cmp.w	r2, #16777216	@ 0x1000000
 c052bf0:	d219      	bcs.n	c052c26 <mbedtls_asn1_write_len+0xa2>
    {
        if( *p - start < 4 )
 c052bf2:	2903      	cmp	r1, #3
 c052bf4:	dd37      	ble.n	c052c66 <mbedtls_asn1_write_len+0xe2>
            return( MBEDTLS_ERR_ASN1_BUF_TOO_SMALL );

        *--(*p) = MBEDTLS_BYTE_0( len );
 c052bf6:	1e59      	subs	r1, r3, #1
 c052bf8:	6001      	str	r1, [r0, #0]
 c052bfa:	f803 2c01 	strb.w	r2, [r3, #-1]
        *--(*p) = MBEDTLS_BYTE_1( len );
 c052bfe:	6803      	ldr	r3, [r0, #0]
 c052c00:	1e59      	subs	r1, r3, #1
 c052c02:	6001      	str	r1, [r0, #0]
 c052c04:	0a11      	lsrs	r1, r2, #8
 c052c06:	f803 1c01 	strb.w	r1, [r3, #-1]
        *--(*p) = MBEDTLS_BYTE_2( len );
 c052c0a:	6803      	ldr	r3, [r0, #0]
 c052c0c:	0c12      	lsrs	r2, r2, #16
 c052c0e:	1e59      	subs	r1, r3, #1
 c052c10:	6001      	str	r1, [r0, #0]
 c052c12:	f803 2c01 	strb.w	r2, [r3, #-1]
        *--(*p) = 0x83;
 c052c16:	6803      	ldr	r3, [r0, #0]
 c052c18:	1e5a      	subs	r2, r3, #1
 c052c1a:	6002      	str	r2, [r0, #0]
 c052c1c:	2283      	movs	r2, #131	@ 0x83
        return( 4 );
 c052c1e:	2004      	movs	r0, #4
        *--(*p) = 0x83;
 c052c20:	f803 2c01 	strb.w	r2, [r3, #-1]
        return( 4 );
 c052c24:	4770      	bx	lr

#if SIZE_MAX > 0xFFFFFFFF
    if( len <= 0xFFFFFFFF )
#endif
    {
        if( *p - start < 5 )
 c052c26:	2904      	cmp	r1, #4
 c052c28:	dd1d      	ble.n	c052c66 <mbedtls_asn1_write_len+0xe2>
            return( MBEDTLS_ERR_ASN1_BUF_TOO_SMALL );

        *--(*p) = MBEDTLS_BYTE_0( len );
 c052c2a:	1e59      	subs	r1, r3, #1
 c052c2c:	6001      	str	r1, [r0, #0]
 c052c2e:	f803 2c01 	strb.w	r2, [r3, #-1]
        *--(*p) = MBEDTLS_BYTE_1( len );
 c052c32:	6803      	ldr	r3, [r0, #0]
 c052c34:	1e59      	subs	r1, r3, #1
 c052c36:	6001      	str	r1, [r0, #0]
 c052c38:	0a11      	lsrs	r1, r2, #8
 c052c3a:	f803 1c01 	strb.w	r1, [r3, #-1]
        *--(*p) = MBEDTLS_BYTE_2( len );
 c052c3e:	6803      	ldr	r3, [r0, #0]
 c052c40:	1e59      	subs	r1, r3, #1
 c052c42:	6001      	str	r1, [r0, #0]
 c052c44:	0c11      	lsrs	r1, r2, #16
 c052c46:	f803 1c01 	strb.w	r1, [r3, #-1]
        *--(*p) = MBEDTLS_BYTE_3( len );
 c052c4a:	6803      	ldr	r3, [r0, #0]
 c052c4c:	0e12      	lsrs	r2, r2, #24
 c052c4e:	1e59      	subs	r1, r3, #1
 c052c50:	6001      	str	r1, [r0, #0]
 c052c52:	f803 2c01 	strb.w	r2, [r3, #-1]
        *--(*p) = 0x84;
 c052c56:	6803      	ldr	r3, [r0, #0]
 c052c58:	1e5a      	subs	r2, r3, #1
 c052c5a:	6002      	str	r2, [r0, #0]
 c052c5c:	2284      	movs	r2, #132	@ 0x84
        return( 5 );
 c052c5e:	2005      	movs	r0, #5
        *--(*p) = 0x84;
 c052c60:	f803 2c01 	strb.w	r2, [r3, #-1]
        return( 5 );
 c052c64:	4770      	bx	lr
            return( MBEDTLS_ERR_ASN1_BUF_TOO_SMALL );
 c052c66:	f06f 006b 	mvn.w	r0, #107	@ 0x6b
    }

#if SIZE_MAX > 0xFFFFFFFF
    return( MBEDTLS_ERR_ASN1_INVALID_LENGTH );
#endif
}
 c052c6a:	4770      	bx	lr

0c052c6c <mbedtls_asn1_write_tag>:

int mbedtls_asn1_write_tag( unsigned char **p, unsigned char *start, unsigned char tag )
{
    if( *p - start < 1 )
 c052c6c:	6803      	ldr	r3, [r0, #0]
 c052c6e:	1a59      	subs	r1, r3, r1
 c052c70:	2900      	cmp	r1, #0
        return( MBEDTLS_ERR_ASN1_BUF_TOO_SMALL );

    *--(*p) = tag;
 c052c72:	bfc1      	itttt	gt
 c052c74:	f103 31ff 	addgt.w	r1, r3, #4294967295	@ 0xffffffff
 c052c78:	6001      	strgt	r1, [r0, #0]

    return( 1 );
 c052c7a:	2001      	movgt	r0, #1
    *--(*p) = tag;
 c052c7c:	f803 2c01 	strbgt.w	r2, [r3, #-1]
        return( MBEDTLS_ERR_ASN1_BUF_TOO_SMALL );
 c052c80:	bfd8      	it	le
 c052c82:	f06f 006b 	mvnle.w	r0, #107	@ 0x6b
}
 c052c86:	4770      	bx	lr

0c052c88 <asn1_write_tagged_int>:

    return( (int) len );
}

static int asn1_write_tagged_int( unsigned char **p, unsigned char *start, int val, int tag )
{
 c052c88:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 c052c8c:	4698      	mov	r8, r3
 c052c8e:	4605      	mov	r5, r0
 c052c90:	460e      	mov	r6, r1
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    size_t len = 0;
 c052c92:	2300      	movs	r3, #0

    do
    {
        if( *p - start < 1 )
 c052c94:	6829      	ldr	r1, [r5, #0]
 c052c96:	1b88      	subs	r0, r1, r6
 c052c98:	2800      	cmp	r0, #0
 c052c9a:	dc06      	bgt.n	c052caa <asn1_write_tagged_int+0x22>
            return( MBEDTLS_ERR_ASN1_BUF_TOO_SMALL );
 c052c9c:	f06f 046b 	mvn.w	r4, #107	@ 0x6b

    MBEDTLS_ASN1_CHK_ADD( len, mbedtls_asn1_write_len( p, start, len ) );
    MBEDTLS_ASN1_CHK_ADD( len, mbedtls_asn1_write_tag( p, start, tag ) );

    return( (int) len );
}
 c052ca0:	4620      	mov	r0, r4
 c052ca2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        len += 1;
 c052ca6:	463b      	mov	r3, r7
 c052ca8:	e7f4      	b.n	c052c94 <asn1_write_tagged_int+0xc>
        *--(*p) = val & 0xff;
 c052caa:	1e48      	subs	r0, r1, #1
 c052cac:	6028      	str	r0, [r5, #0]
 c052cae:	f801 2c01 	strb.w	r2, [r1, #-1]
        val >>= 8;
 c052cb2:	1212      	asrs	r2, r2, #8
    while( val > 0 );
 c052cb4:	2a00      	cmp	r2, #0
        len += 1;
 c052cb6:	f103 0701 	add.w	r7, r3, #1
    while( val > 0 );
 c052cba:	dcf4      	bgt.n	c052ca6 <asn1_write_tagged_int+0x1e>
    if( **p & 0x80 )
 c052cbc:	6829      	ldr	r1, [r5, #0]
 c052cbe:	f991 2000 	ldrsb.w	r2, [r1]
 c052cc2:	2a00      	cmp	r2, #0
 c052cc4:	da08      	bge.n	c052cd8 <asn1_write_tagged_int+0x50>
        if( *p - start < 1 )
 c052cc6:	1b8a      	subs	r2, r1, r6
 c052cc8:	2a00      	cmp	r2, #0
 c052cca:	dde7      	ble.n	c052c9c <asn1_write_tagged_int+0x14>
        *--(*p) = 0x00;
 c052ccc:	1e4a      	subs	r2, r1, #1
 c052cce:	602a      	str	r2, [r5, #0]
 c052cd0:	2200      	movs	r2, #0
        len += 1;
 c052cd2:	1c9f      	adds	r7, r3, #2
        *--(*p) = 0x00;
 c052cd4:	f801 2c01 	strb.w	r2, [r1, #-1]
    MBEDTLS_ASN1_CHK_ADD( len, mbedtls_asn1_write_len( p, start, len ) );
 c052cd8:	463a      	mov	r2, r7
 c052cda:	4631      	mov	r1, r6
 c052cdc:	4628      	mov	r0, r5
 c052cde:	f7ff ff51 	bl	c052b84 <mbedtls_asn1_write_len>
 c052ce2:	1e04      	subs	r4, r0, #0
 c052ce4:	dbdc      	blt.n	c052ca0 <asn1_write_tagged_int+0x18>
    MBEDTLS_ASN1_CHK_ADD( len, mbedtls_asn1_write_tag( p, start, tag ) );
 c052ce6:	4631      	mov	r1, r6
 c052ce8:	4628      	mov	r0, r5
 c052cea:	fa5f f288 	uxtb.w	r2, r8
 c052cee:	f7ff ffbd 	bl	c052c6c <mbedtls_asn1_write_tag>
 c052cf2:	2800      	cmp	r0, #0
    MBEDTLS_ASN1_CHK_ADD( len, mbedtls_asn1_write_len( p, start, len ) );
 c052cf4:	bfaa      	itet	ge
 c052cf6:	19e4      	addge	r4, r4, r7
    return( (int) len );
 c052cf8:	4604      	movlt	r4, r0
    MBEDTLS_ASN1_CHK_ADD( len, mbedtls_asn1_write_tag( p, start, tag ) );
 c052cfa:	1824      	addge	r4, r4, r0
 c052cfc:	e7d0      	b.n	c052ca0 <asn1_write_tagged_int+0x18>

0c052cfe <mbedtls_asn1_write_raw_buffer>:
{
 c052cfe:	b570      	push	{r4, r5, r6, lr}
 c052d00:	460d      	mov	r5, r1
 c052d02:	4606      	mov	r6, r0
    if( *p < start || (size_t)( *p - start ) < size )
 c052d04:	6800      	ldr	r0, [r0, #0]
{
 c052d06:	4611      	mov	r1, r2
    if( *p < start || (size_t)( *p - start ) < size )
 c052d08:	42a8      	cmp	r0, r5
{
 c052d0a:	461c      	mov	r4, r3
    if( *p < start || (size_t)( *p - start ) < size )
 c052d0c:	d309      	bcc.n	c052d22 <mbedtls_asn1_write_raw_buffer+0x24>
 c052d0e:	1b45      	subs	r5, r0, r5
 c052d10:	429d      	cmp	r5, r3
 c052d12:	d306      	bcc.n	c052d22 <mbedtls_asn1_write_raw_buffer+0x24>
    (*p) -= len;
 c052d14:	1ac0      	subs	r0, r0, r3
    memcpy( *p, buf, len );
 c052d16:	461a      	mov	r2, r3
    (*p) -= len;
 c052d18:	6030      	str	r0, [r6, #0]
    memcpy( *p, buf, len );
 c052d1a:	f008 fc97 	bl	c05b64c <memcpy>
    return( (int) len );
 c052d1e:	4620      	mov	r0, r4
}
 c052d20:	bd70      	pop	{r4, r5, r6, pc}
        return( MBEDTLS_ERR_ASN1_BUF_TOO_SMALL );
 c052d22:	f06f 006b 	mvn.w	r0, #107	@ 0x6b
 c052d26:	e7fb      	b.n	c052d20 <mbedtls_asn1_write_raw_buffer+0x22>

0c052d28 <mbedtls_asn1_write_mpi>:
{
 c052d28:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 c052d2c:	4680      	mov	r8, r0
 c052d2e:	460f      	mov	r7, r1
    len = mbedtls_mpi_size( X );
 c052d30:	4610      	mov	r0, r2
{
 c052d32:	4615      	mov	r5, r2
    len = mbedtls_mpi_size( X );
 c052d34:	f000 fc11 	bl	c05355a <mbedtls_mpi_size>
    if( *p < start || (size_t)( *p - start ) < len )
 c052d38:	f8d8 1000 	ldr.w	r1, [r8]
    len = mbedtls_mpi_size( X );
 c052d3c:	4606      	mov	r6, r0
    if( *p < start || (size_t)( *p - start ) < len )
 c052d3e:	42b9      	cmp	r1, r7
 c052d40:	d204      	bcs.n	c052d4c <mbedtls_asn1_write_mpi+0x24>
        return( MBEDTLS_ERR_ASN1_BUF_TOO_SMALL );
 c052d42:	f06f 046b 	mvn.w	r4, #107	@ 0x6b
}
 c052d46:	4620      	mov	r0, r4
 c052d48:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if( *p < start || (size_t)( *p - start ) < len )
 c052d4c:	1bca      	subs	r2, r1, r7
 c052d4e:	4282      	cmp	r2, r0
 c052d50:	d3f7      	bcc.n	c052d42 <mbedtls_asn1_write_mpi+0x1a>
    (*p) -= len;
 c052d52:	1a09      	subs	r1, r1, r0
    MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( X, *p, len ) );
 c052d54:	4602      	mov	r2, r0
    (*p) -= len;
 c052d56:	f8c8 1000 	str.w	r1, [r8]
    MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( X, *p, len ) );
 c052d5a:	4628      	mov	r0, r5
 c052d5c:	f000 fc7c 	bl	c053658 <mbedtls_mpi_write_binary>
 c052d60:	4604      	mov	r4, r0
 c052d62:	2800      	cmp	r0, #0
 c052d64:	d1ef      	bne.n	c052d46 <mbedtls_asn1_write_mpi+0x1e>
    if( X->s ==1 && **p & 0x80 )
 c052d66:	682b      	ldr	r3, [r5, #0]
 c052d68:	2b01      	cmp	r3, #1
 c052d6a:	d10e      	bne.n	c052d8a <mbedtls_asn1_write_mpi+0x62>
 c052d6c:	f8d8 3000 	ldr.w	r3, [r8]
 c052d70:	f993 2000 	ldrsb.w	r2, [r3]
 c052d74:	2a00      	cmp	r2, #0
 c052d76:	da08      	bge.n	c052d8a <mbedtls_asn1_write_mpi+0x62>
        if( *p - start < 1 )
 c052d78:	1bda      	subs	r2, r3, r7
 c052d7a:	2a00      	cmp	r2, #0
 c052d7c:	dde1      	ble.n	c052d42 <mbedtls_asn1_write_mpi+0x1a>
        *--(*p) = 0x00;
 c052d7e:	1e5a      	subs	r2, r3, #1
 c052d80:	f8c8 2000 	str.w	r2, [r8]
        len += 1;
 c052d84:	3601      	adds	r6, #1
        *--(*p) = 0x00;
 c052d86:	f803 0c01 	strb.w	r0, [r3, #-1]
    MBEDTLS_ASN1_CHK_ADD( len, mbedtls_asn1_write_len( p, start, len ) );
 c052d8a:	4632      	mov	r2, r6
 c052d8c:	4639      	mov	r1, r7
 c052d8e:	4640      	mov	r0, r8
 c052d90:	f7ff fef8 	bl	c052b84 <mbedtls_asn1_write_len>
 c052d94:	1e04      	subs	r4, r0, #0
 c052d96:	dbd6      	blt.n	c052d46 <mbedtls_asn1_write_mpi+0x1e>
    MBEDTLS_ASN1_CHK_ADD( len, mbedtls_asn1_write_tag( p, start, MBEDTLS_ASN1_INTEGER ) );
 c052d98:	2202      	movs	r2, #2
 c052d9a:	4639      	mov	r1, r7
 c052d9c:	4640      	mov	r0, r8
 c052d9e:	f7ff ff65 	bl	c052c6c <mbedtls_asn1_write_tag>
 c052da2:	1e03      	subs	r3, r0, #0
    MBEDTLS_ASN1_CHK_ADD( len, mbedtls_asn1_write_len( p, start, len ) );
 c052da4:	bfaa      	itet	ge
 c052da6:	19a2      	addge	r2, r4, r6
 c052da8:	461c      	movlt	r4, r3
    MBEDTLS_ASN1_CHK_ADD( len, mbedtls_asn1_write_tag( p, start, MBEDTLS_ASN1_INTEGER ) );
 c052daa:	189c      	addge	r4, r3, r2
    ret = (int) len;
 c052dac:	e7cb      	b.n	c052d46 <mbedtls_asn1_write_mpi+0x1e>

0c052dae <mbedtls_asn1_write_oid>:
{
 c052dae:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 c052db0:	4605      	mov	r5, r0
 c052db2:	460e      	mov	r6, r1
    MBEDTLS_ASN1_CHK_ADD( len, mbedtls_asn1_write_raw_buffer( p, start,
 c052db4:	f7ff ffa3 	bl	c052cfe <mbedtls_asn1_write_raw_buffer>
 c052db8:	1e04      	subs	r4, r0, #0
 c052dba:	db11      	blt.n	c052de0 <mbedtls_asn1_write_oid+0x32>
    MBEDTLS_ASN1_CHK_ADD( len , mbedtls_asn1_write_len( p, start, len ) );
 c052dbc:	4622      	mov	r2, r4
 c052dbe:	4631      	mov	r1, r6
 c052dc0:	4628      	mov	r0, r5
 c052dc2:	f7ff fedf 	bl	c052b84 <mbedtls_asn1_write_len>
    MBEDTLS_ASN1_CHK_ADD( len, mbedtls_asn1_write_raw_buffer( p, start,
 c052dc6:	4627      	mov	r7, r4
    MBEDTLS_ASN1_CHK_ADD( len , mbedtls_asn1_write_len( p, start, len ) );
 c052dc8:	1e04      	subs	r4, r0, #0
 c052dca:	db09      	blt.n	c052de0 <mbedtls_asn1_write_oid+0x32>
    MBEDTLS_ASN1_CHK_ADD( len , mbedtls_asn1_write_tag( p, start, MBEDTLS_ASN1_OID ) );
 c052dcc:	2206      	movs	r2, #6
 c052dce:	4631      	mov	r1, r6
 c052dd0:	4628      	mov	r0, r5
 c052dd2:	f7ff ff4b 	bl	c052c6c <mbedtls_asn1_write_tag>
 c052dd6:	2800      	cmp	r0, #0
 c052dd8:	bfb2      	itee	lt
 c052dda:	4604      	movlt	r4, r0
    MBEDTLS_ASN1_CHK_ADD( len , mbedtls_asn1_write_len( p, start, len ) );
 c052ddc:	19e4      	addge	r4, r4, r7
    MBEDTLS_ASN1_CHK_ADD( len , mbedtls_asn1_write_tag( p, start, MBEDTLS_ASN1_OID ) );
 c052dde:	1824      	addge	r4, r4, r0
}
 c052de0:	4620      	mov	r0, r4
 c052de2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0c052de4 <mbedtls_asn1_write_int>:

int mbedtls_asn1_write_int( unsigned char **p, unsigned char *start, int val )
{
    return( asn1_write_tagged_int( p, start, val, MBEDTLS_ASN1_INTEGER ) );
 c052de4:	2302      	movs	r3, #2
 c052de6:	f7ff bf4f 	b.w	c052c88 <asn1_write_tagged_int>

0c052dea <mbedtls_asn1_write_octet_string>:
    return( (int) len );
}

int mbedtls_asn1_write_octet_string( unsigned char **p, unsigned char *start,
                             const unsigned char *buf, size_t size )
{
 c052dea:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 c052dec:	4605      	mov	r5, r0
 c052dee:	460e      	mov	r6, r1
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    size_t len = 0;

    MBEDTLS_ASN1_CHK_ADD( len, mbedtls_asn1_write_raw_buffer( p, start, buf, size ) );
 c052df0:	f7ff ff85 	bl	c052cfe <mbedtls_asn1_write_raw_buffer>
 c052df4:	1e04      	subs	r4, r0, #0
 c052df6:	db11      	blt.n	c052e1c <mbedtls_asn1_write_octet_string+0x32>

    MBEDTLS_ASN1_CHK_ADD( len, mbedtls_asn1_write_len( p, start, len ) );
 c052df8:	4622      	mov	r2, r4
 c052dfa:	4631      	mov	r1, r6
 c052dfc:	4628      	mov	r0, r5
 c052dfe:	f7ff fec1 	bl	c052b84 <mbedtls_asn1_write_len>
    MBEDTLS_ASN1_CHK_ADD( len, mbedtls_asn1_write_raw_buffer( p, start, buf, size ) );
 c052e02:	4627      	mov	r7, r4
    MBEDTLS_ASN1_CHK_ADD( len, mbedtls_asn1_write_len( p, start, len ) );
 c052e04:	1e04      	subs	r4, r0, #0
 c052e06:	db09      	blt.n	c052e1c <mbedtls_asn1_write_octet_string+0x32>
    MBEDTLS_ASN1_CHK_ADD( len, mbedtls_asn1_write_tag( p, start, MBEDTLS_ASN1_OCTET_STRING ) );
 c052e08:	2204      	movs	r2, #4
 c052e0a:	4631      	mov	r1, r6
 c052e0c:	4628      	mov	r0, r5
 c052e0e:	f7ff ff2d 	bl	c052c6c <mbedtls_asn1_write_tag>
 c052e12:	2800      	cmp	r0, #0
 c052e14:	bfb2      	itee	lt
 c052e16:	4604      	movlt	r4, r0
    MBEDTLS_ASN1_CHK_ADD( len, mbedtls_asn1_write_len( p, start, len ) );
 c052e18:	19e4      	addge	r4, r4, r7
    MBEDTLS_ASN1_CHK_ADD( len, mbedtls_asn1_write_tag( p, start, MBEDTLS_ASN1_OCTET_STRING ) );
 c052e1a:	1824      	addge	r4, r4, r0

    return( (int) len );
}
 c052e1c:	4620      	mov	r0, r4
 c052e1e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0c052e20 <mpi_get_digit>:

/*
 * Convert an ASCII character to digit value
 */
static int mpi_get_digit( mbedtls_mpi_uint *d, int radix, char c )
{
 c052e20:	4613      	mov	r3, r2
    *d = 255;

    if( c >= 0x30 && c <= 0x39 ) *d = c - 0x30;
 c052e22:	3a30      	subs	r2, #48	@ 0x30
{
 c052e24:	b510      	push	{r4, lr}
    if( c >= 0x30 && c <= 0x39 ) *d = c - 0x30;
 c052e26:	b2d4      	uxtb	r4, r2
 c052e28:	2c09      	cmp	r4, #9
 c052e2a:	d905      	bls.n	c052e38 <mpi_get_digit+0x18>
    if( c >= 0x41 && c <= 0x46 ) *d = c - 0x37;
 c052e2c:	f1a3 0241 	sub.w	r2, r3, #65	@ 0x41
 c052e30:	2a05      	cmp	r2, #5
 c052e32:	d808      	bhi.n	c052e46 <mpi_get_digit+0x26>
 c052e34:	f1a3 0237 	sub.w	r2, r3, #55	@ 0x37
    if( c >= 0x61 && c <= 0x66 ) *d = c - 0x57;

    if( *d >= (mbedtls_mpi_uint) radix )
        return( MBEDTLS_ERR_MPI_INVALID_CHARACTER );

    return( 0 );
 c052e38:	428a      	cmp	r2, r1
    *d = 255;
 c052e3a:	6002      	str	r2, [r0, #0]
}
 c052e3c:	bf2c      	ite	cs
 c052e3e:	f06f 0005 	mvncs.w	r0, #5
 c052e42:	2000      	movcc	r0, #0
 c052e44:	bd10      	pop	{r4, pc}
    if( c >= 0x61 && c <= 0x66 ) *d = c - 0x57;
 c052e46:	f1a3 0261 	sub.w	r2, r3, #97	@ 0x61
 c052e4a:	2a05      	cmp	r2, #5
 c052e4c:	bf8c      	ite	hi
 c052e4e:	22ff      	movhi	r2, #255	@ 0xff
 c052e50:	f1a3 0257 	subls.w	r2, r3, #87	@ 0x57
 c052e54:	e7f0      	b.n	c052e38 <mpi_get_digit+0x18>

0c052e56 <mpi_mul_hlp>:
#endif
void mpi_mul_hlp( size_t i,
                  const mbedtls_mpi_uint *s,
                  mbedtls_mpi_uint *d,
                  mbedtls_mpi_uint b )
{
 c052e56:	b5f0      	push	{r4, r5, r6, r7, lr}
        MULADDC_INIT
        MULADDC_CORE
        MULADDC_STOP
    }
#else /* MULADDC_HUIT */
    for( ; i >= 16; i -= 16 )
 c052e58:	4684      	mov	ip, r0
{
 c052e5a:	4617      	mov	r7, r2
 c052e5c:	460e      	mov	r6, r1
 c052e5e:	4614      	mov	r4, r2
    mbedtls_mpi_uint c = 0, t = 0;
 c052e60:	2500      	movs	r5, #0
    for( ; i >= 16; i -= 16 )
 c052e62:	f1bc 0f0f 	cmp.w	ip, #15
 c052e66:	f106 0640 	add.w	r6, r6, #64	@ 0x40
 c052e6a:	f104 0440 	add.w	r4, r4, #64	@ 0x40
 c052e6e:	d877      	bhi.n	c052f60 <mpi_mul_hlp+0x10a>
 c052e70:	f06f 020f 	mvn.w	r2, #15
 c052e74:	0904      	lsrs	r4, r0, #4
 c052e76:	fb02 0004 	mla	r0, r2, r4, r0
        MULADDC_CORE   MULADDC_CORE
        MULADDC_CORE   MULADDC_CORE
        MULADDC_STOP
    }

    for( ; i >= 8; i -= 8 )
 c052e7a:	2807      	cmp	r0, #7
 c052e7c:	ea4f 1c84 	mov.w	ip, r4, lsl #6
 c052e80:	eb01 1684 	add.w	r6, r1, r4, lsl #6
 c052e84:	eb07 1484 	add.w	r4, r7, r4, lsl #6
 c052e88:	d95d      	bls.n	c052f46 <mpi_mul_hlp+0xf0>
    {
        MULADDC_INIT
        MULADDC_CORE   MULADDC_CORE
 c052e8a:	f851 100c 	ldr.w	r1, [r1, ip]
    for( ; i >= 8; i -= 8 )
 c052e8e:	3808      	subs	r0, #8
        MULADDC_CORE   MULADDC_CORE
 c052e90:	fba3 1201 	umull	r1, r2, r3, r1
 c052e94:	1869      	adds	r1, r5, r1
 c052e96:	f857 500c 	ldr.w	r5, [r7, ip]
 c052e9a:	f142 0200 	adc.w	r2, r2, #0
 c052e9e:	1949      	adds	r1, r1, r5
 c052ea0:	f847 100c 	str.w	r1, [r7, ip]
 c052ea4:	6871      	ldr	r1, [r6, #4]
 c052ea6:	f142 0200 	adc.w	r2, r2, #0
 c052eaa:	fba3 5101 	umull	r5, r1, r3, r1
 c052eae:	1952      	adds	r2, r2, r5
 c052eb0:	6865      	ldr	r5, [r4, #4]
 c052eb2:	f141 0100 	adc.w	r1, r1, #0
 c052eb6:	1952      	adds	r2, r2, r5
 c052eb8:	6062      	str	r2, [r4, #4]
        MULADDC_CORE   MULADDC_CORE
 c052eba:	68b2      	ldr	r2, [r6, #8]
        MULADDC_CORE   MULADDC_CORE
 c052ebc:	f141 0100 	adc.w	r1, r1, #0
        MULADDC_CORE   MULADDC_CORE
 c052ec0:	fba3 5202 	umull	r5, r2, r3, r2
 c052ec4:	1949      	adds	r1, r1, r5
 c052ec6:	68a5      	ldr	r5, [r4, #8]
 c052ec8:	f142 0200 	adc.w	r2, r2, #0
 c052ecc:	1949      	adds	r1, r1, r5
 c052ece:	60a1      	str	r1, [r4, #8]
 c052ed0:	68f1      	ldr	r1, [r6, #12]
 c052ed2:	f142 0200 	adc.w	r2, r2, #0
 c052ed6:	fba3 5101 	umull	r5, r1, r3, r1
 c052eda:	1952      	adds	r2, r2, r5
 c052edc:	68e5      	ldr	r5, [r4, #12]
 c052ede:	f141 0100 	adc.w	r1, r1, #0
 c052ee2:	1952      	adds	r2, r2, r5
 c052ee4:	60e2      	str	r2, [r4, #12]

        MULADDC_CORE   MULADDC_CORE
 c052ee6:	6932      	ldr	r2, [r6, #16]
        MULADDC_CORE   MULADDC_CORE
 c052ee8:	f141 0100 	adc.w	r1, r1, #0
        MULADDC_CORE   MULADDC_CORE
 c052eec:	fba3 5202 	umull	r5, r2, r3, r2
 c052ef0:	1949      	adds	r1, r1, r5
 c052ef2:	6925      	ldr	r5, [r4, #16]
 c052ef4:	f142 0200 	adc.w	r2, r2, #0
 c052ef8:	1949      	adds	r1, r1, r5
 c052efa:	6121      	str	r1, [r4, #16]
 c052efc:	6971      	ldr	r1, [r6, #20]
 c052efe:	f142 0200 	adc.w	r2, r2, #0
 c052f02:	fba3 5101 	umull	r5, r1, r3, r1
 c052f06:	1952      	adds	r2, r2, r5
 c052f08:	6965      	ldr	r5, [r4, #20]
 c052f0a:	f141 0100 	adc.w	r1, r1, #0
 c052f0e:	1952      	adds	r2, r2, r5
 c052f10:	6162      	str	r2, [r4, #20]
        MULADDC_CORE   MULADDC_CORE
 c052f12:	69b2      	ldr	r2, [r6, #24]
        MULADDC_CORE   MULADDC_CORE
 c052f14:	f141 0100 	adc.w	r1, r1, #0
        MULADDC_CORE   MULADDC_CORE
 c052f18:	fba3 5202 	umull	r5, r2, r3, r2
 c052f1c:	1949      	adds	r1, r1, r5
 c052f1e:	69a5      	ldr	r5, [r4, #24]
 c052f20:	f142 0200 	adc.w	r2, r2, #0
 c052f24:	1949      	adds	r1, r1, r5
 c052f26:	61a1      	str	r1, [r4, #24]
 c052f28:	69f1      	ldr	r1, [r6, #28]
 c052f2a:	f142 0200 	adc.w	r2, r2, #0
 c052f2e:	fba3 1501 	umull	r1, r5, r3, r1
 c052f32:	1852      	adds	r2, r2, r1
 c052f34:	69e1      	ldr	r1, [r4, #28]
 c052f36:	f145 0500 	adc.w	r5, r5, #0
 c052f3a:	1852      	adds	r2, r2, r1
 c052f3c:	61e2      	str	r2, [r4, #28]
 c052f3e:	f145 0500 	adc.w	r5, r5, #0
 c052f42:	3420      	adds	r4, #32
 c052f44:	3620      	adds	r6, #32
 c052f46:	4627      	mov	r7, r4
 c052f48:	ea4f 0c80 	mov.w	ip, r0, lsl #2
 c052f4c:	eb06 0080 	add.w	r0, r6, r0, lsl #2
        MULADDC_STOP
    }

    for( ; i > 0; i-- )
 c052f50:	42b0      	cmp	r0, r6
 c052f52:	f040 8106 	bne.w	c053162 <mpi_mul_hlp+0x30c>
 c052f56:	4464      	add	r4, ip
    }
#endif /* MULADDC_HUIT */

    t++;

    while( c != 0 )
 c052f58:	2d00      	cmp	r5, #0
 c052f5a:	f040 8110 	bne.w	c05317e <mpi_mul_hlp+0x328>
    {
        *d += c; c = ( *d < c ); d++;
    }
}
 c052f5e:	bdf0      	pop	{r4, r5, r6, r7, pc}
        MULADDC_CORE   MULADDC_CORE
 c052f60:	f856 2c40 	ldr.w	r2, [r6, #-64]
    for( ; i >= 16; i -= 16 )
 c052f64:	f1ac 0c10 	sub.w	ip, ip, #16
        MULADDC_CORE   MULADDC_CORE
 c052f68:	fba3 e202 	umull	lr, r2, r3, r2
 c052f6c:	eb15 0e0e 	adds.w	lr, r5, lr
 c052f70:	f854 5c40 	ldr.w	r5, [r4, #-64]
 c052f74:	f142 0200 	adc.w	r2, r2, #0
 c052f78:	eb15 050e 	adds.w	r5, r5, lr
 c052f7c:	f844 5c40 	str.w	r5, [r4, #-64]
 c052f80:	f856 5c3c 	ldr.w	r5, [r6, #-60]
 c052f84:	f142 0200 	adc.w	r2, r2, #0
 c052f88:	fba3 e505 	umull	lr, r5, r3, r5
 c052f8c:	eb12 0e0e 	adds.w	lr, r2, lr
 c052f90:	f854 2c3c 	ldr.w	r2, [r4, #-60]
 c052f94:	f145 0500 	adc.w	r5, r5, #0
 c052f98:	eb12 020e 	adds.w	r2, r2, lr
 c052f9c:	f844 2c3c 	str.w	r2, [r4, #-60]
        MULADDC_CORE   MULADDC_CORE
 c052fa0:	f856 2c38 	ldr.w	r2, [r6, #-56]
        MULADDC_CORE   MULADDC_CORE
 c052fa4:	f145 0500 	adc.w	r5, r5, #0
        MULADDC_CORE   MULADDC_CORE
 c052fa8:	fba3 e202 	umull	lr, r2, r3, r2
 c052fac:	eb15 0e0e 	adds.w	lr, r5, lr
 c052fb0:	f854 5c38 	ldr.w	r5, [r4, #-56]
 c052fb4:	f142 0200 	adc.w	r2, r2, #0
 c052fb8:	eb15 050e 	adds.w	r5, r5, lr
 c052fbc:	f844 5c38 	str.w	r5, [r4, #-56]
 c052fc0:	f856 5c34 	ldr.w	r5, [r6, #-52]
 c052fc4:	f142 0200 	adc.w	r2, r2, #0
 c052fc8:	fba3 e505 	umull	lr, r5, r3, r5
 c052fcc:	eb12 0e0e 	adds.w	lr, r2, lr
 c052fd0:	f854 2c34 	ldr.w	r2, [r4, #-52]
 c052fd4:	f145 0500 	adc.w	r5, r5, #0
 c052fd8:	eb12 020e 	adds.w	r2, r2, lr
 c052fdc:	f844 2c34 	str.w	r2, [r4, #-52]
        MULADDC_CORE   MULADDC_CORE
 c052fe0:	f856 2c30 	ldr.w	r2, [r6, #-48]
        MULADDC_CORE   MULADDC_CORE
 c052fe4:	f145 0500 	adc.w	r5, r5, #0
        MULADDC_CORE   MULADDC_CORE
 c052fe8:	fba3 e202 	umull	lr, r2, r3, r2
 c052fec:	eb15 0e0e 	adds.w	lr, r5, lr
 c052ff0:	f854 5c30 	ldr.w	r5, [r4, #-48]
 c052ff4:	f142 0200 	adc.w	r2, r2, #0
 c052ff8:	eb15 050e 	adds.w	r5, r5, lr
 c052ffc:	f844 5c30 	str.w	r5, [r4, #-48]
 c053000:	f856 5c2c 	ldr.w	r5, [r6, #-44]
 c053004:	f142 0200 	adc.w	r2, r2, #0
 c053008:	fba3 e505 	umull	lr, r5, r3, r5
 c05300c:	eb12 0e0e 	adds.w	lr, r2, lr
 c053010:	f854 2c2c 	ldr.w	r2, [r4, #-44]
 c053014:	f145 0500 	adc.w	r5, r5, #0
 c053018:	eb12 020e 	adds.w	r2, r2, lr
 c05301c:	f844 2c2c 	str.w	r2, [r4, #-44]
        MULADDC_CORE   MULADDC_CORE
 c053020:	f856 2c28 	ldr.w	r2, [r6, #-40]
        MULADDC_CORE   MULADDC_CORE
 c053024:	f145 0500 	adc.w	r5, r5, #0
        MULADDC_CORE   MULADDC_CORE
 c053028:	fba3 e202 	umull	lr, r2, r3, r2
 c05302c:	eb15 0e0e 	adds.w	lr, r5, lr
 c053030:	f854 5c28 	ldr.w	r5, [r4, #-40]
 c053034:	f142 0200 	adc.w	r2, r2, #0
 c053038:	eb15 050e 	adds.w	r5, r5, lr
 c05303c:	f844 5c28 	str.w	r5, [r4, #-40]
 c053040:	f856 5c24 	ldr.w	r5, [r6, #-36]
 c053044:	f142 0200 	adc.w	r2, r2, #0
 c053048:	fba3 e505 	umull	lr, r5, r3, r5
 c05304c:	eb12 0e0e 	adds.w	lr, r2, lr
 c053050:	f854 2c24 	ldr.w	r2, [r4, #-36]
 c053054:	f145 0500 	adc.w	r5, r5, #0
 c053058:	eb12 020e 	adds.w	r2, r2, lr
 c05305c:	f844 2c24 	str.w	r2, [r4, #-36]
        MULADDC_CORE   MULADDC_CORE
 c053060:	f856 2c20 	ldr.w	r2, [r6, #-32]
        MULADDC_CORE   MULADDC_CORE
 c053064:	f145 0500 	adc.w	r5, r5, #0
        MULADDC_CORE   MULADDC_CORE
 c053068:	fba3 e202 	umull	lr, r2, r3, r2
 c05306c:	eb15 0e0e 	adds.w	lr, r5, lr
 c053070:	f854 5c20 	ldr.w	r5, [r4, #-32]
 c053074:	f142 0200 	adc.w	r2, r2, #0
 c053078:	eb15 050e 	adds.w	r5, r5, lr
 c05307c:	f844 5c20 	str.w	r5, [r4, #-32]
 c053080:	f856 5c1c 	ldr.w	r5, [r6, #-28]
 c053084:	f142 0200 	adc.w	r2, r2, #0
 c053088:	fba3 e505 	umull	lr, r5, r3, r5
 c05308c:	eb12 0e0e 	adds.w	lr, r2, lr
 c053090:	f854 2c1c 	ldr.w	r2, [r4, #-28]
 c053094:	f145 0500 	adc.w	r5, r5, #0
 c053098:	eb12 020e 	adds.w	r2, r2, lr
 c05309c:	f844 2c1c 	str.w	r2, [r4, #-28]
        MULADDC_CORE   MULADDC_CORE
 c0530a0:	f856 2c18 	ldr.w	r2, [r6, #-24]
        MULADDC_CORE   MULADDC_CORE
 c0530a4:	f145 0500 	adc.w	r5, r5, #0
        MULADDC_CORE   MULADDC_CORE
 c0530a8:	fba3 e202 	umull	lr, r2, r3, r2
 c0530ac:	eb15 0e0e 	adds.w	lr, r5, lr
 c0530b0:	f854 5c18 	ldr.w	r5, [r4, #-24]
 c0530b4:	f142 0200 	adc.w	r2, r2, #0
 c0530b8:	eb15 050e 	adds.w	r5, r5, lr
 c0530bc:	f844 5c18 	str.w	r5, [r4, #-24]
 c0530c0:	f856 5c14 	ldr.w	r5, [r6, #-20]
 c0530c4:	f142 0200 	adc.w	r2, r2, #0
 c0530c8:	fba3 e505 	umull	lr, r5, r3, r5
 c0530cc:	eb12 0e0e 	adds.w	lr, r2, lr
 c0530d0:	f854 2c14 	ldr.w	r2, [r4, #-20]
 c0530d4:	f145 0500 	adc.w	r5, r5, #0
 c0530d8:	eb12 020e 	adds.w	r2, r2, lr
 c0530dc:	f844 2c14 	str.w	r2, [r4, #-20]
        MULADDC_CORE   MULADDC_CORE
 c0530e0:	f856 2c10 	ldr.w	r2, [r6, #-16]
        MULADDC_CORE   MULADDC_CORE
 c0530e4:	f145 0500 	adc.w	r5, r5, #0
        MULADDC_CORE   MULADDC_CORE
 c0530e8:	fba3 e202 	umull	lr, r2, r3, r2
 c0530ec:	eb15 0e0e 	adds.w	lr, r5, lr
 c0530f0:	f854 5c10 	ldr.w	r5, [r4, #-16]
 c0530f4:	f142 0200 	adc.w	r2, r2, #0
 c0530f8:	eb15 050e 	adds.w	r5, r5, lr
 c0530fc:	f844 5c10 	str.w	r5, [r4, #-16]
 c053100:	f856 5c0c 	ldr.w	r5, [r6, #-12]
 c053104:	f142 0200 	adc.w	r2, r2, #0
 c053108:	fba3 e505 	umull	lr, r5, r3, r5
 c05310c:	eb12 0e0e 	adds.w	lr, r2, lr
 c053110:	f854 2c0c 	ldr.w	r2, [r4, #-12]
 c053114:	f145 0500 	adc.w	r5, r5, #0
 c053118:	eb12 020e 	adds.w	r2, r2, lr
 c05311c:	f844 2c0c 	str.w	r2, [r4, #-12]
        MULADDC_CORE   MULADDC_CORE
 c053120:	f856 2c08 	ldr.w	r2, [r6, #-8]
        MULADDC_CORE   MULADDC_CORE
 c053124:	f145 0500 	adc.w	r5, r5, #0
        MULADDC_CORE   MULADDC_CORE
 c053128:	fba3 e202 	umull	lr, r2, r3, r2
 c05312c:	eb15 0e0e 	adds.w	lr, r5, lr
 c053130:	f854 5c08 	ldr.w	r5, [r4, #-8]
 c053134:	f142 0200 	adc.w	r2, r2, #0
 c053138:	eb15 050e 	adds.w	r5, r5, lr
 c05313c:	f844 5c08 	str.w	r5, [r4, #-8]
 c053140:	f856 5c04 	ldr.w	r5, [r6, #-4]
 c053144:	f142 0200 	adc.w	r2, r2, #0
 c053148:	fba3 5e05 	umull	r5, lr, r3, r5
 c05314c:	1952      	adds	r2, r2, r5
 c05314e:	f854 5c04 	ldr.w	r5, [r4, #-4]
 c053152:	f14e 0e00 	adc.w	lr, lr, #0
 c053156:	18aa      	adds	r2, r5, r2
 c053158:	f14e 0500 	adc.w	r5, lr, #0
 c05315c:	f844 2c04 	str.w	r2, [r4, #-4]
    for( ; i >= 16; i -= 16 )
 c053160:	e67f      	b.n	c052e62 <mpi_mul_hlp+0xc>
        MULADDC_CORE
 c053162:	f856 2b04 	ldr.w	r2, [r6], #4
 c053166:	fba3 2102 	umull	r2, r1, r3, r2
 c05316a:	18aa      	adds	r2, r5, r2
 c05316c:	f141 0500 	adc.w	r5, r1, #0
 c053170:	6839      	ldr	r1, [r7, #0]
 c053172:	1889      	adds	r1, r1, r2
 c053174:	f145 0500 	adc.w	r5, r5, #0
 c053178:	f847 1b04 	str.w	r1, [r7], #4
    for( ; i > 0; i-- )
 c05317c:	e6e8      	b.n	c052f50 <mpi_mul_hlp+0xfa>
        *d += c; c = ( *d < c ); d++;
 c05317e:	6823      	ldr	r3, [r4, #0]
 c053180:	195b      	adds	r3, r3, r5
 c053182:	bf2c      	ite	cs
 c053184:	2501      	movcs	r5, #1
 c053186:	2500      	movcc	r5, #0
 c053188:	f844 3b04 	str.w	r3, [r4], #4
 c05318c:	e6e4      	b.n	c052f58 <mpi_mul_hlp+0x102>

0c05318e <mpi_montmul>:
 *                      Note that unlike the usual convention in the library
 *                      for `const mbedtls_mpi*`, the content of T can change.
 */
static void mpi_montmul( mbedtls_mpi *A, const mbedtls_mpi *B, const mbedtls_mpi *N, mbedtls_mpi_uint mm,
                         const mbedtls_mpi *T )
{
 c05318e:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c053192:	468a      	mov	sl, r1
 c053194:	4617      	mov	r7, r2
 c053196:	b085      	sub	sp, #20
 c053198:	9c0e      	ldr	r4, [sp, #56]	@ 0x38
 c05319a:	9000      	str	r0, [sp, #0]
    size_t i, n, m;
    mbedtls_mpi_uint u0, u1, *d;

    memset( T->p, 0, T->n * ciL );
 c05319c:	6862      	ldr	r2, [r4, #4]
 c05319e:	68a0      	ldr	r0, [r4, #8]
 c0531a0:	2100      	movs	r1, #0
 c0531a2:	0092      	lsls	r2, r2, #2
{
 c0531a4:	9303      	str	r3, [sp, #12]
    memset( T->p, 0, T->n * ciL );
 c0531a6:	f008 fac2 	bl	c05b72e <memset>

    d = T->p;
    n = N->n;
 c0531aa:	687e      	ldr	r6, [r7, #4]
    m = ( B->n < n ) ? B->n : n;
 c0531ac:	f8da 3004 	ldr.w	r3, [sl, #4]
    d = T->p;
 c0531b0:	68a5      	ldr	r5, [r4, #8]
    m = ( B->n < n ) ? B->n : n;
 c0531b2:	42b3      	cmp	r3, r6
 c0531b4:	bf28      	it	cs
 c0531b6:	4633      	movcs	r3, r6
    d = T->p;
 c0531b8:	46a9      	mov	r9, r5

    for( i = 0; i < n; i++ )
 c0531ba:	f04f 0800 	mov.w	r8, #0
        u1 = ( d[0] + u0 * B->p[0] ) * mm;

        mpi_mul_hlp( m, B->p, d, u0 );
        mpi_mul_hlp( n, N->p, d, u1 );

        *d++ = u0; d[n + 1] = 0;
 c0531be:	1c74      	adds	r4, r6, #1
    m = ( B->n < n ) ? B->n : n;
 c0531c0:	9301      	str	r3, [sp, #4]
        *d++ = u0; d[n + 1] = 0;
 c0531c2:	00a4      	lsls	r4, r4, #2
        u0 = A->p[i];
 c0531c4:	9b00      	ldr	r3, [sp, #0]
    for( i = 0; i < n; i++ )
 c0531c6:	45b0      	cmp	r8, r6
        u0 = A->p[i];
 c0531c8:	6898      	ldr	r0, [r3, #8]
    for( i = 0; i < n; i++ )
 c0531ca:	d11c      	bne.n	c053206 <mpi_montmul+0x78>
 c0531cc:	3c04      	subs	r4, #4
 c0531ce:	4425      	add	r5, r4
     * plus N. We now potentially subtract N, avoiding leaking whether the
     * subtraction is performed through side channels. */

    /* Copy the n least significant limbs of d to A, so that
     * A = d if d < N (recall that N has n limbs). */
    memcpy( A->p, d, n * ciL );
 c0531d0:	4622      	mov	r2, r4
 c0531d2:	4629      	mov	r1, r5
 c0531d4:	f008 fa3a 	bl	c05b64c <memcpy>
    mbedtls_mpi_uint c = 0, t, z;
 c0531d8:	2200      	movs	r2, #0
    /* If d >= N then we want to set A to d - N. To prevent timing attacks,
     * do the calculation without using conditional tests. */
    /* Set d to d0 + (2^biL)^n - N where d0 is the current value of d. */
    d[n] += 1;
 c0531da:	592b      	ldr	r3, [r5, r4]
    d[n] -= mpi_sub_hlp( n, d, d, N->p );
 c0531dc:	f8d7 e008 	ldr.w	lr, [r7, #8]
    d[n] += 1;
 c0531e0:	3301      	adds	r3, #1
 c0531e2:	512b      	str	r3, [r5, r4]
    for( i = 0; i < n; i++ )
 c0531e4:	4613      	mov	r3, r2
 c0531e6:	1f28      	subs	r0, r5, #4
 c0531e8:	429e      	cmp	r6, r3
 c0531ea:	d12b      	bne.n	c053244 <mpi_montmul+0xb6>
    d[n] -= mpi_sub_hlp( n, d, d, N->p );
 c0531ec:	592b      	ldr	r3, [r5, r4]
     * so d[n] == 0 and we want to keep A as it is.
     * If d0 >= N then d >= (2^biL)^n, and d <= (2^biL)^n + N < 2 * (2^biL)^n
     * so d[n] == 1 and we want to set A to the result of the subtraction
     * which is d - (2^biL)^n, i.e. the n least significant limbs of d.
     * This exactly corresponds to a conditional assignment. */
    mbedtls_ct_mpi_uint_cond_assign( n, A->p, d, (unsigned char) d[n] );
 c0531ee:	4630      	mov	r0, r6
    d[n] -= mpi_sub_hlp( n, d, d, N->p );
 c0531f0:	1a9b      	subs	r3, r3, r2
    mbedtls_ct_mpi_uint_cond_assign( n, A->p, d, (unsigned char) d[n] );
 c0531f2:	462a      	mov	r2, r5
 c0531f4:	9900      	ldr	r1, [sp, #0]
    d[n] -= mpi_sub_hlp( n, d, d, N->p );
 c0531f6:	512b      	str	r3, [r5, r4]
    mbedtls_ct_mpi_uint_cond_assign( n, A->p, d, (unsigned char) d[n] );
 c0531f8:	6889      	ldr	r1, [r1, #8]
 c0531fa:	b2db      	uxtb	r3, r3
}
 c0531fc:	b005      	add	sp, #20
 c0531fe:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    mbedtls_ct_mpi_uint_cond_assign( n, A->p, d, (unsigned char) d[n] );
 c053202:	f002 baca 	b.w	c05579a <mbedtls_ct_mpi_uint_cond_assign>
        u1 = ( d[0] + u0 * B->p[0] ) * mm;
 c053206:	f8da 1008 	ldr.w	r1, [sl, #8]
        u0 = A->p[i];
 c05320a:	f850 b028 	ldr.w	fp, [r0, r8, lsl #2]
        u1 = ( d[0] + u0 * B->p[0] ) * mm;
 c05320e:	f8d9 3000 	ldr.w	r3, [r9]
 c053212:	6808      	ldr	r0, [r1, #0]
 c053214:	9a03      	ldr	r2, [sp, #12]
 c053216:	fb00 330b 	mla	r3, r0, fp, r3
 c05321a:	4353      	muls	r3, r2
        mpi_mul_hlp( m, B->p, d, u0 );
 c05321c:	9801      	ldr	r0, [sp, #4]
 c05321e:	464a      	mov	r2, r9
        u1 = ( d[0] + u0 * B->p[0] ) * mm;
 c053220:	9302      	str	r3, [sp, #8]
        mpi_mul_hlp( m, B->p, d, u0 );
 c053222:	465b      	mov	r3, fp
 c053224:	f7ff fe17 	bl	c052e56 <mpi_mul_hlp>
        mpi_mul_hlp( n, N->p, d, u1 );
 c053228:	464a      	mov	r2, r9
 c05322a:	9b02      	ldr	r3, [sp, #8]
 c05322c:	4630      	mov	r0, r6
 c05322e:	68b9      	ldr	r1, [r7, #8]
 c053230:	f7ff fe11 	bl	c052e56 <mpi_mul_hlp>
        *d++ = u0; d[n + 1] = 0;
 c053234:	2300      	movs	r3, #0
 c053236:	f849 bb04 	str.w	fp, [r9], #4
 c05323a:	f849 3004 	str.w	r3, [r9, r4]
    for( i = 0; i < n; i++ )
 c05323e:	f108 0801 	add.w	r8, r8, #1
 c053242:	e7bf      	b.n	c0531c4 <mpi_montmul+0x36>
        z = ( l[i] <  c );    t = l[i] - c;
 c053244:	f850 cf04 	ldr.w	ip, [r0, #4]!
        c = ( t < r[i] ) + z; d[i] = t - r[i];
 c053248:	f85e 7023 	ldr.w	r7, [lr, r3, lsl #2]
        z = ( l[i] <  c );    t = l[i] - c;
 c05324c:	ebac 0102 	sub.w	r1, ip, r2
        c = ( t < r[i] ) + z; d[i] = t - r[i];
 c053250:	42b9      	cmp	r1, r7
 c053252:	bf2c      	ite	cs
 c053254:	f04f 0800 	movcs.w	r8, #0
 c053258:	f04f 0801 	movcc.w	r8, #1
 c05325c:	1bc9      	subs	r1, r1, r7
 c05325e:	4594      	cmp	ip, r2
 c053260:	bf2c      	ite	cs
 c053262:	4642      	movcs	r2, r8
 c053264:	f108 0201 	addcc.w	r2, r8, #1
 c053268:	6001      	str	r1, [r0, #0]
    for( i = 0; i < n; i++ )
 c05326a:	3301      	adds	r3, #1
 c05326c:	e7bc      	b.n	c0531e8 <mpi_montmul+0x5a>

0c05326e <mpi_bigendian_to_host.part.0>:
    for( cur_limb_left = p, cur_limb_right = p + ( limbs - 1 );
 c05326e:	f101 4180 	add.w	r1, r1, #1073741824	@ 0x40000000
 c053272:	3901      	subs	r1, #1
 c053274:	eb00 0181 	add.w	r1, r0, r1, lsl #2
         cur_limb_left <= cur_limb_right;
 c053278:	4281      	cmp	r1, r0
 c05327a:	4603      	mov	r3, r0
 c05327c:	d200      	bcs.n	c053280 <mpi_bigendian_to_host.part.0+0x12>
}
 c05327e:	4770      	bx	lr
            return( __builtin_bswap32(x) );
 c053280:	681b      	ldr	r3, [r3, #0]
 c053282:	680a      	ldr	r2, [r1, #0]
 c053284:	ba1b      	rev	r3, r3
 c053286:	ba12      	rev	r2, r2
        *cur_limb_left  = mpi_uint_bigendian_to_host( *cur_limb_right );
 c053288:	f840 2b04 	str.w	r2, [r0], #4
        *cur_limb_right = tmp;
 c05328c:	f841 3904 	str.w	r3, [r1], #-4
         cur_limb_left++, cur_limb_right-- )
 c053290:	e7f2      	b.n	c053278 <mpi_bigendian_to_host.part.0+0xa>

0c053292 <mpi_fill_random_internal>:
 * n_bytes must not be 0.
 */
static int mpi_fill_random_internal(
    mbedtls_mpi *X, size_t n_bytes,
    int (*f_rng)(void *, unsigned char *, size_t), void *p_rng )
{
 c053292:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    const size_t limbs = CHARS_TO_LIMBS( n_bytes );
 c053296:	f011 0403 	ands.w	r4, r1, #3
 c05329a:	bf18      	it	ne
 c05329c:	2401      	movne	r4, #1
{
 c05329e:	4698      	mov	r8, r3
    const size_t overhead = ( limbs * ciL ) - n_bytes;

    if( X->n < limbs )
 c0532a0:	6843      	ldr	r3, [r0, #4]
    const size_t limbs = CHARS_TO_LIMBS( n_bytes );
 c0532a2:	eb04 0491 	add.w	r4, r4, r1, lsr #2
    if( X->n < limbs )
 c0532a6:	42a3      	cmp	r3, r4
{
 c0532a8:	4605      	mov	r5, r0
 c0532aa:	460e      	mov	r6, r1
 c0532ac:	4617      	mov	r7, r2
    const size_t overhead = ( limbs * ciL ) - n_bytes;
 c0532ae:	ea4f 0a84 	mov.w	sl, r4, lsl #2
 c0532b2:	ebc1 0984 	rsb	r9, r1, r4, lsl #2
    if( X->n < limbs )
 c0532b6:	d31b      	bcc.n	c0532f0 <mpi_fill_random_internal+0x5e>
        return( MBEDTLS_ERR_MPI_BAD_INPUT_DATA );

    memset( X->p, 0, overhead );
 c0532b8:	464a      	mov	r2, r9
 c0532ba:	2100      	movs	r1, #0
 c0532bc:	6880      	ldr	r0, [r0, #8]
 c0532be:	f008 fa36 	bl	c05b72e <memset>
    memset( (unsigned char *) X->p + limbs * ciL, 0, ( X->n - limbs ) * ciL );
 c0532c2:	686a      	ldr	r2, [r5, #4]
 c0532c4:	68a8      	ldr	r0, [r5, #8]
 c0532c6:	1b12      	subs	r2, r2, r4
 c0532c8:	2100      	movs	r1, #0
 c0532ca:	0092      	lsls	r2, r2, #2
 c0532cc:	4450      	add	r0, sl
 c0532ce:	f008 fa2e 	bl	c05b72e <memset>
    MBEDTLS_MPI_CHK( f_rng( p_rng, (unsigned char *) X->p + overhead, n_bytes ) );
 c0532d2:	68a9      	ldr	r1, [r5, #8]
 c0532d4:	4632      	mov	r2, r6
 c0532d6:	4640      	mov	r0, r8
 c0532d8:	4449      	add	r1, r9
 c0532da:	47b8      	blx	r7
 c0532dc:	4606      	mov	r6, r0
 c0532de:	b920      	cbnz	r0, c0532ea <mpi_fill_random_internal+0x58>
    if( limbs == 0 )
 c0532e0:	b11c      	cbz	r4, c0532ea <mpi_fill_random_internal+0x58>
 c0532e2:	4621      	mov	r1, r4
 c0532e4:	68a8      	ldr	r0, [r5, #8]
 c0532e6:	f7ff ffc2 	bl	c05326e <mpi_bigendian_to_host.part.0>
    mpi_bigendian_to_host( X->p, limbs );

cleanup:
    return( ret );
}
 c0532ea:	4630      	mov	r0, r6
 c0532ec:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        return( MBEDTLS_ERR_MPI_BAD_INPUT_DATA );
 c0532f0:	f06f 0603 	mvn.w	r6, #3
 c0532f4:	e7f9      	b.n	c0532ea <mpi_fill_random_internal+0x58>

0c0532f6 <mbedtls_mpi_init>:
    X->n = 0;
 c0532f6:	2300      	movs	r3, #0
 c0532f8:	2201      	movs	r2, #1
    X->p = NULL;
 c0532fa:	6083      	str	r3, [r0, #8]
    X->n = 0;
 c0532fc:	e9c0 2300 	strd	r2, r3, [r0]
}
 c053300:	4770      	bx	lr

0c053302 <mbedtls_mpi_free>:
{
 c053302:	b510      	push	{r4, lr}
    if( X == NULL )
 c053304:	4604      	mov	r4, r0
 c053306:	b168      	cbz	r0, c053324 <mbedtls_mpi_free+0x22>
    if( X->p != NULL )
 c053308:	6880      	ldr	r0, [r0, #8]
 c05330a:	b130      	cbz	r0, c05331a <mbedtls_mpi_free+0x18>
    mbedtls_platform_zeroize( v, ciL * n );
 c05330c:	6861      	ldr	r1, [r4, #4]
 c05330e:	0089      	lsls	r1, r1, #2
 c053310:	f7e8 f85e 	bl	c03b3d0 <mbedtls_platform_zeroize>
        mbedtls_free( X->p );
 c053314:	68a0      	ldr	r0, [r4, #8]
 c053316:	f7e8 f84b 	bl	c03b3b0 <mbedtls_free>
    X->n = 0;
 c05331a:	2300      	movs	r3, #0
 c05331c:	2201      	movs	r2, #1
 c05331e:	e9c4 2300 	strd	r2, r3, [r4]
    X->p = NULL;
 c053322:	60a3      	str	r3, [r4, #8]
}
 c053324:	bd10      	pop	{r4, pc}

0c053326 <mbedtls_mpi_grow>:
    if( nblimbs > MBEDTLS_MPI_MAX_LIMBS )
 c053326:	f242 7310 	movw	r3, #10000	@ 0x2710
 c05332a:	4299      	cmp	r1, r3
{
 c05332c:	b570      	push	{r4, r5, r6, lr}
 c05332e:	4604      	mov	r4, r0
 c053330:	460d      	mov	r5, r1
    if( nblimbs > MBEDTLS_MPI_MAX_LIMBS )
 c053332:	d902      	bls.n	c05333a <mbedtls_mpi_grow+0x14>
        return( MBEDTLS_ERR_MPI_ALLOC_FAILED );
 c053334:	f06f 000f 	mvn.w	r0, #15
}
 c053338:	bd70      	pop	{r4, r5, r6, pc}
    if( X->n < nblimbs )
 c05333a:	6843      	ldr	r3, [r0, #4]
 c05333c:	428b      	cmp	r3, r1
 c05333e:	d301      	bcc.n	c053344 <mbedtls_mpi_grow+0x1e>
    return( 0 );
 c053340:	2000      	movs	r0, #0
 c053342:	e7f9      	b.n	c053338 <mbedtls_mpi_grow+0x12>
        if( ( p = (mbedtls_mpi_uint*)mbedtls_calloc( nblimbs, ciL ) ) == NULL )
 c053344:	2104      	movs	r1, #4
 c053346:	4628      	mov	r0, r5
 c053348:	f7e8 f82c 	bl	c03b3a4 <mbedtls_calloc>
 c05334c:	4606      	mov	r6, r0
 c05334e:	2800      	cmp	r0, #0
 c053350:	d0f0      	beq.n	c053334 <mbedtls_mpi_grow+0xe>
        if( X->p != NULL )
 c053352:	68a1      	ldr	r1, [r4, #8]
 c053354:	b159      	cbz	r1, c05336e <mbedtls_mpi_grow+0x48>
            memcpy( p, X->p, X->n * ciL );
 c053356:	6862      	ldr	r2, [r4, #4]
 c053358:	0092      	lsls	r2, r2, #2
 c05335a:	f008 f977 	bl	c05b64c <memcpy>
    mbedtls_platform_zeroize( v, ciL * n );
 c05335e:	6861      	ldr	r1, [r4, #4]
 c053360:	68a0      	ldr	r0, [r4, #8]
 c053362:	0089      	lsls	r1, r1, #2
 c053364:	f7e8 f834 	bl	c03b3d0 <mbedtls_platform_zeroize>
            mbedtls_free( X->p );
 c053368:	68a0      	ldr	r0, [r4, #8]
 c05336a:	f7e8 f821 	bl	c03b3b0 <mbedtls_free>
        X->p = p;
 c05336e:	e9c4 5601 	strd	r5, r6, [r4, #4]
 c053372:	e7e5      	b.n	c053340 <mbedtls_mpi_grow+0x1a>

0c053374 <mbedtls_mpi_resize_clear>:
{
 c053374:	b538      	push	{r3, r4, r5, lr}
 c053376:	4604      	mov	r4, r0
    if( limbs == 0 )
 c053378:	460d      	mov	r5, r1
 c05337a:	b919      	cbnz	r1, c053384 <mbedtls_mpi_resize_clear+0x10>
        mbedtls_mpi_free( X );
 c05337c:	f7ff ffc1 	bl	c053302 <mbedtls_mpi_free>
}
 c053380:	2000      	movs	r0, #0
 c053382:	bd38      	pop	{r3, r4, r5, pc}
    else if( X->n == limbs )
 c053384:	6842      	ldr	r2, [r0, #4]
 c053386:	428a      	cmp	r2, r1
 c053388:	d107      	bne.n	c05339a <mbedtls_mpi_resize_clear+0x26>
        memset( X->p, 0, limbs * ciL );
 c05338a:	2100      	movs	r1, #0
 c05338c:	6880      	ldr	r0, [r0, #8]
 c05338e:	0092      	lsls	r2, r2, #2
 c053390:	f008 f9cd 	bl	c05b72e <memset>
        X->s = 1;
 c053394:	2301      	movs	r3, #1
 c053396:	6023      	str	r3, [r4, #0]
        return( 0 );
 c053398:	e7f2      	b.n	c053380 <mbedtls_mpi_resize_clear+0xc>
        mbedtls_mpi_free( X );
 c05339a:	f7ff ffb2 	bl	c053302 <mbedtls_mpi_free>
        return( mbedtls_mpi_grow( X, limbs ) );
 c05339e:	4629      	mov	r1, r5
 c0533a0:	4620      	mov	r0, r4
}
 c0533a2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
        return( mbedtls_mpi_grow( X, limbs ) );
 c0533a6:	f7ff bfbe 	b.w	c053326 <mbedtls_mpi_grow>

0c0533aa <mbedtls_mpi_copy>:
    if( X == Y )
 c0533aa:	4288      	cmp	r0, r1
{
 c0533ac:	b570      	push	{r4, r5, r6, lr}
 c0533ae:	4605      	mov	r5, r0
 c0533b0:	460e      	mov	r6, r1
    if( X == Y )
 c0533b2:	d009      	beq.n	c0533c8 <mbedtls_mpi_copy+0x1e>
    if( Y->n == 0 )
 c0533b4:	6849      	ldr	r1, [r1, #4]
        if( X->n != 0 )
 c0533b6:	6842      	ldr	r2, [r0, #4]
    if( Y->n == 0 )
 c0533b8:	b941      	cbnz	r1, c0533cc <mbedtls_mpi_copy+0x22>
        if( X->n != 0 )
 c0533ba:	b12a      	cbz	r2, c0533c8 <mbedtls_mpi_copy+0x1e>
            X->s = 1;
 c0533bc:	2301      	movs	r3, #1
            memset( X->p, 0, X->n * ciL );
 c0533be:	0092      	lsls	r2, r2, #2
            X->s = 1;
 c0533c0:	6003      	str	r3, [r0, #0]
            memset( X->p, 0, X->n * ciL );
 c0533c2:	6880      	ldr	r0, [r0, #8]
 c0533c4:	f008 f9b3 	bl	c05b72e <memset>
        return( 0 );
 c0533c8:	2000      	movs	r0, #0
}
 c0533ca:	bd70      	pop	{r4, r5, r6, pc}
    for( i = Y->n - 1; i > 0; i-- )
 c0533cc:	1e4c      	subs	r4, r1, #1
 c0533ce:	b984      	cbnz	r4, c0533f2 <mbedtls_mpi_copy+0x48>
    X->s = Y->s;
 c0533d0:	6833      	ldr	r3, [r6, #0]
    i++;
 c0533d2:	3401      	adds	r4, #1
    if( X->n < i )
 c0533d4:	4294      	cmp	r4, r2
    X->s = Y->s;
 c0533d6:	602b      	str	r3, [r5, #0]
    if( X->n < i )
 c0533d8:	d912      	bls.n	c053400 <mbedtls_mpi_copy+0x56>
        MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, i ) );
 c0533da:	4621      	mov	r1, r4
 c0533dc:	4628      	mov	r0, r5
 c0533de:	f7ff ffa2 	bl	c053326 <mbedtls_mpi_grow>
 c0533e2:	2800      	cmp	r0, #0
 c0533e4:	d1f1      	bne.n	c0533ca <mbedtls_mpi_copy+0x20>
    memcpy( X->p, Y->p, i * ciL );
 c0533e6:	68b1      	ldr	r1, [r6, #8]
 c0533e8:	68a8      	ldr	r0, [r5, #8]
 c0533ea:	00a2      	lsls	r2, r4, #2
 c0533ec:	f008 f92e 	bl	c05b64c <memcpy>
 c0533f0:	e7ea      	b.n	c0533c8 <mbedtls_mpi_copy+0x1e>
        if( Y->p[i] != 0 )
 c0533f2:	68b3      	ldr	r3, [r6, #8]
 c0533f4:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
 c0533f8:	2b00      	cmp	r3, #0
 c0533fa:	d1e9      	bne.n	c0533d0 <mbedtls_mpi_copy+0x26>
    for( i = Y->n - 1; i > 0; i-- )
 c0533fc:	3c01      	subs	r4, #1
 c0533fe:	e7e6      	b.n	c0533ce <mbedtls_mpi_copy+0x24>
        memset( X->p + i, 0, ( X->n - i ) * ciL );
 c053400:	68a8      	ldr	r0, [r5, #8]
 c053402:	1b12      	subs	r2, r2, r4
 c053404:	2100      	movs	r1, #0
 c053406:	0092      	lsls	r2, r2, #2
 c053408:	eb00 0084 	add.w	r0, r0, r4, lsl #2
 c05340c:	f008 f98f 	bl	c05b72e <memset>
 c053410:	e7e9      	b.n	c0533e6 <mbedtls_mpi_copy+0x3c>

0c053412 <mbedtls_mpi_swap>:
{
 c053412:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 c053414:	4602      	mov	r2, r0
 c053416:	460b      	mov	r3, r1
    memcpy( &T,  X, sizeof( mbedtls_mpi ) );
 c053418:	6800      	ldr	r0, [r0, #0]
 c05341a:	6851      	ldr	r1, [r2, #4]
 c05341c:	ac01      	add	r4, sp, #4
 c05341e:	c403      	stmia	r4!, {r0, r1}
 c053420:	6890      	ldr	r0, [r2, #8]
    memcpy(  X,  Y, sizeof( mbedtls_mpi ) );
 c053422:	6819      	ldr	r1, [r3, #0]
    memcpy( &T,  X, sizeof( mbedtls_mpi ) );
 c053424:	4604      	mov	r4, r0
    memcpy(  X,  Y, sizeof( mbedtls_mpi ) );
 c053426:	6011      	str	r1, [r2, #0]
 c053428:	6859      	ldr	r1, [r3, #4]
 c05342a:	6051      	str	r1, [r2, #4]
 c05342c:	6899      	ldr	r1, [r3, #8]
 c05342e:	6091      	str	r1, [r2, #8]
    memcpy(  Y, &T, sizeof( mbedtls_mpi ) );
 c053430:	aa01      	add	r2, sp, #4
 c053432:	ca03      	ldmia	r2!, {r0, r1}
 c053434:	609c      	str	r4, [r3, #8]
 c053436:	6018      	str	r0, [r3, #0]
 c053438:	6059      	str	r1, [r3, #4]
}
 c05343a:	b004      	add	sp, #16
 c05343c:	bd10      	pop	{r4, pc}

0c05343e <mbedtls_mpi_lset>:
{
 c05343e:	b570      	push	{r4, r5, r6, lr}
 c053440:	460e      	mov	r6, r1
    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, 1 ) );
 c053442:	2101      	movs	r1, #1
{
 c053444:	4604      	mov	r4, r0
    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, 1 ) );
 c053446:	f7ff ff6e 	bl	c053326 <mbedtls_mpi_grow>
 c05344a:	4605      	mov	r5, r0
 c05344c:	b988      	cbnz	r0, c053472 <mbedtls_mpi_lset+0x34>
    memset( X->p, 0, X->n * ciL );
 c05344e:	6862      	ldr	r2, [r4, #4]
 c053450:	4601      	mov	r1, r0
 c053452:	0092      	lsls	r2, r2, #2
 c053454:	68a0      	ldr	r0, [r4, #8]
 c053456:	f008 f96a 	bl	c05b72e <memset>
    X->p[0] = ( z < 0 ) ? -z : z;
 c05345a:	68a3      	ldr	r3, [r4, #8]
 c05345c:	ea86 72e6 	eor.w	r2, r6, r6, asr #31
    X->s    = ( z < 0 ) ? -1 : 1;
 c053460:	2e00      	cmp	r6, #0
    X->p[0] = ( z < 0 ) ? -z : z;
 c053462:	eba2 72e6 	sub.w	r2, r2, r6, asr #31
 c053466:	601a      	str	r2, [r3, #0]
    X->s    = ( z < 0 ) ? -1 : 1;
 c053468:	bfac      	ite	ge
 c05346a:	2301      	movge	r3, #1
 c05346c:	f04f 33ff 	movlt.w	r3, #4294967295	@ 0xffffffff
 c053470:	6023      	str	r3, [r4, #0]
}
 c053472:	4628      	mov	r0, r5
 c053474:	bd70      	pop	{r4, r5, r6, pc}

0c053476 <mbedtls_mpi_get_bit>:
    if( X->n * biL <= pos )
 c053476:	6843      	ldr	r3, [r0, #4]
 c053478:	ebb1 1f43 	cmp.w	r1, r3, lsl #5
    return( ( X->p[pos / biL] >> ( pos % biL ) ) & 0x01 );
 c05347c:	bf3f      	itttt	cc
 c05347e:	6883      	ldrcc	r3, [r0, #8]
 c053480:	094a      	lsrcc	r2, r1, #5
 c053482:	f853 0022 	ldrcc.w	r0, [r3, r2, lsl #2]
 c053486:	f001 011f 	andcc.w	r1, r1, #31
 c05348a:	bf3a      	itte	cc
 c05348c:	40c8      	lsrcc	r0, r1
 c05348e:	f000 0001 	andcc.w	r0, r0, #1
        return( 0 );
 c053492:	2000      	movcs	r0, #0
}
 c053494:	4770      	bx	lr

0c053496 <mbedtls_mpi_set_bit>:
    if( val != 0 && val != 1 )
 c053496:	2a01      	cmp	r2, #1
{
 c053498:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 c05349a:	4607      	mov	r7, r0
 c05349c:	460c      	mov	r4, r1
 c05349e:	4615      	mov	r5, r2
    size_t off = pos / biL;
 c0534a0:	ea4f 1651 	mov.w	r6, r1, lsr #5
    if( val != 0 && val != 1 )
 c0534a4:	d81b      	bhi.n	c0534de <mbedtls_mpi_set_bit+0x48>
    if( X->n * biL <= pos )
 c0534a6:	6843      	ldr	r3, [r0, #4]
 c0534a8:	ebb1 1f43 	cmp.w	r1, r3, lsl #5
 c0534ac:	d20f      	bcs.n	c0534ce <mbedtls_mpi_set_bit+0x38>
    X->p[off] &= ~( (mbedtls_mpi_uint) 0x01 << idx );
 c0534ae:	2201      	movs	r2, #1
 c0534b0:	68b9      	ldr	r1, [r7, #8]
    size_t idx = pos % biL;
 c0534b2:	f004 041f 	and.w	r4, r4, #31
    X->p[off] &= ~( (mbedtls_mpi_uint) 0x01 << idx );
 c0534b6:	f851 3026 	ldr.w	r3, [r1, r6, lsl #2]
 c0534ba:	40a2      	lsls	r2, r4
 c0534bc:	ea23 0302 	bic.w	r3, r3, r2
    X->p[off] |= (mbedtls_mpi_uint) val << idx;
 c0534c0:	fa05 f404 	lsl.w	r4, r5, r4
 c0534c4:	4323      	orrs	r3, r4
 c0534c6:	f841 3026 	str.w	r3, [r1, r6, lsl #2]
            return( 0 );
 c0534ca:	2000      	movs	r0, #0
}
 c0534cc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        if( val == 0 )
 c0534ce:	2a00      	cmp	r2, #0
 c0534d0:	d0fb      	beq.n	c0534ca <mbedtls_mpi_set_bit+0x34>
        MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, off + 1 ) );
 c0534d2:	1c71      	adds	r1, r6, #1
 c0534d4:	f7ff ff27 	bl	c053326 <mbedtls_mpi_grow>
 c0534d8:	2800      	cmp	r0, #0
 c0534da:	d0e8      	beq.n	c0534ae <mbedtls_mpi_set_bit+0x18>
 c0534dc:	e7f6      	b.n	c0534cc <mbedtls_mpi_set_bit+0x36>
        return( MBEDTLS_ERR_MPI_BAD_INPUT_DATA );
 c0534de:	f06f 0003 	mvn.w	r0, #3
 c0534e2:	e7f3      	b.n	c0534cc <mbedtls_mpi_set_bit+0x36>

0c0534e4 <mbedtls_mpi_lsb>:
    size_t i, j, count = 0;
 c0534e4:	2200      	movs	r2, #0
{
 c0534e6:	b5f0      	push	{r4, r5, r6, r7, lr}
    for( i = 0; i < X->n; i++ )
 c0534e8:	4611      	mov	r1, r2
{
 c0534ea:	4604      	mov	r4, r0
    for( i = 0; i < X->n; i++ )
 c0534ec:	6846      	ldr	r6, [r0, #4]
 c0534ee:	428e      	cmp	r6, r1
 c0534f0:	d013      	beq.n	c05351a <mbedtls_mpi_lsb+0x36>
            if( ( ( X->p[i] >> j ) & 1 ) != 0 )
 c0534f2:	68a3      	ldr	r3, [r4, #8]
 c0534f4:	f853 5021 	ldr.w	r5, [r3, r1, lsl #2]
 c0534f8:	f015 0301 	ands.w	r3, r5, #1
 c0534fc:	d005      	beq.n	c05350a <mbedtls_mpi_lsb+0x26>
 c0534fe:	4610      	mov	r0, r2
}
 c053500:	bdf0      	pop	{r4, r5, r6, r7, pc}
            if( ( ( X->p[i] >> j ) & 1 ) != 0 )
 c053502:	fa25 f703 	lsr.w	r7, r5, r3
 c053506:	07ff      	lsls	r7, r7, #31
 c053508:	d4fa      	bmi.n	c053500 <mbedtls_mpi_lsb+0x1c>
        for( j = 0; j < biL; j++, count++ )
 c05350a:	3301      	adds	r3, #1
 c05350c:	2b20      	cmp	r3, #32
 c05350e:	eb02 0003 	add.w	r0, r2, r3
 c053512:	d1f6      	bne.n	c053502 <mbedtls_mpi_lsb+0x1e>
 c053514:	4602      	mov	r2, r0
    for( i = 0; i < X->n; i++ )
 c053516:	3101      	adds	r1, #1
 c053518:	e7e9      	b.n	c0534ee <mbedtls_mpi_lsb+0xa>
    return( 0 );
 c05351a:	2000      	movs	r0, #0
 c05351c:	e7f0      	b.n	c053500 <mbedtls_mpi_lsb+0x1c>

0c05351e <mbedtls_mpi_bitlen>:
{
 c05351e:	4602      	mov	r2, r0
    if( X->n == 0 )
 c053520:	6840      	ldr	r0, [r0, #4]
 c053522:	b198      	cbz	r0, c05354c <mbedtls_mpi_bitlen+0x2e>
        if( X->p[i] != 0 )
 c053524:	6892      	ldr	r2, [r2, #8]
    for( i = X->n - 1; i > 0; i-- )
 c053526:	1e43      	subs	r3, r0, #1
 c053528:	b98b      	cbnz	r3, c05354e <mbedtls_mpi_bitlen+0x30>
    j = biL - mbedtls_clz( X->p[i] );
 c05352a:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
    for( j = 0; j < biL; j++ )
 c05352e:	2000      	movs	r0, #0
        if( x & mask ) break;
 c053530:	2900      	cmp	r1, #0
 c053532:	db08      	blt.n	c053546 <mbedtls_mpi_bitlen+0x28>
    mbedtls_mpi_uint mask = (mbedtls_mpi_uint) 1 << (biL - 1);
 c053534:	f04f 4200 	mov.w	r2, #2147483648	@ 0x80000000
    for( j = 0; j < biL; j++ )
 c053538:	3001      	adds	r0, #1
 c05353a:	2820      	cmp	r0, #32
        mask >>= 1;
 c05353c:	ea4f 0252 	mov.w	r2, r2, lsr #1
    for( j = 0; j < biL; j++ )
 c053540:	d001      	beq.n	c053546 <mbedtls_mpi_bitlen+0x28>
        if( x & mask ) break;
 c053542:	4211      	tst	r1, r2
 c053544:	d0f8      	beq.n	c053538 <mbedtls_mpi_bitlen+0x1a>
    return( ( i * biL ) + j );
 c053546:	3301      	adds	r3, #1
 c053548:	ebc0 1043 	rsb	r0, r0, r3, lsl #5
}
 c05354c:	4770      	bx	lr
        if( X->p[i] != 0 )
 c05354e:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
 c053552:	2900      	cmp	r1, #0
 c053554:	d1e9      	bne.n	c05352a <mbedtls_mpi_bitlen+0xc>
    for( i = X->n - 1; i > 0; i-- )
 c053556:	3b01      	subs	r3, #1
 c053558:	e7e6      	b.n	c053528 <mbedtls_mpi_bitlen+0xa>

0c05355a <mbedtls_mpi_size>:
{
 c05355a:	b508      	push	{r3, lr}
    return( ( mbedtls_mpi_bitlen( X ) + 7 ) >> 3 );
 c05355c:	f7ff ffdf 	bl	c05351e <mbedtls_mpi_bitlen>
 c053560:	3007      	adds	r0, #7
}
 c053562:	08c0      	lsrs	r0, r0, #3
 c053564:	bd08      	pop	{r3, pc}

0c053566 <mbedtls_mpi_read_binary_le>:
{
 c053566:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 c053568:	460e      	mov	r6, r1
    size_t const limbs = CHARS_TO_LIMBS( buflen );
 c05356a:	f012 0103 	ands.w	r1, r2, #3
 c05356e:	bf18      	it	ne
 c053570:	2101      	movne	r1, #1
    MBEDTLS_MPI_CHK( mbedtls_mpi_resize_clear( X, limbs ) );
 c053572:	eb01 0192 	add.w	r1, r1, r2, lsr #2
{
 c053576:	4605      	mov	r5, r0
 c053578:	4614      	mov	r4, r2
    MBEDTLS_MPI_CHK( mbedtls_mpi_resize_clear( X, limbs ) );
 c05357a:	f7ff fefb 	bl	c053374 <mbedtls_mpi_resize_clear>
 c05357e:	b190      	cbz	r0, c0535a6 <mbedtls_mpi_read_binary_le+0x40>
}
 c053580:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        X->p[i / ciL] |= ((mbedtls_mpi_uint) buf[i]) << ((i % ciL) << 3);
 c053582:	5cf1      	ldrb	r1, [r6, r3]
 c053584:	f8d5 c008 	ldr.w	ip, [r5, #8]
 c053588:	00da      	lsls	r2, r3, #3
 c05358a:	f023 0703 	bic.w	r7, r3, #3
 c05358e:	f002 0218 	and.w	r2, r2, #24
 c053592:	4091      	lsls	r1, r2
 c053594:	f85c 2007 	ldr.w	r2, [ip, r7]
    for( i = 0; i < buflen; i++ )
 c053598:	3301      	adds	r3, #1
        X->p[i / ciL] |= ((mbedtls_mpi_uint) buf[i]) << ((i % ciL) << 3);
 c05359a:	430a      	orrs	r2, r1
 c05359c:	f84c 2007 	str.w	r2, [ip, r7]
    for( i = 0; i < buflen; i++ )
 c0535a0:	42a3      	cmp	r3, r4
 c0535a2:	d1ee      	bne.n	c053582 <mbedtls_mpi_read_binary_le+0x1c>
cleanup:
 c0535a4:	e7ec      	b.n	c053580 <mbedtls_mpi_read_binary_le+0x1a>
    for( i = 0; i < buflen; i++ )
 c0535a6:	4603      	mov	r3, r0
 c0535a8:	e7fa      	b.n	c0535a0 <mbedtls_mpi_read_binary_le+0x3a>

0c0535aa <mbedtls_mpi_read_binary>:
{
 c0535aa:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    size_t const limbs    = CHARS_TO_LIMBS( buflen );
 c0535ae:	f012 0403 	ands.w	r4, r2, #3
 c0535b2:	bf18      	it	ne
 c0535b4:	2401      	movne	r4, #1
 c0535b6:	eb04 0492 	add.w	r4, r4, r2, lsr #2
{
 c0535ba:	4688      	mov	r8, r1
    MBEDTLS_MPI_CHK( mbedtls_mpi_resize_clear( X, limbs ) );
 c0535bc:	4621      	mov	r1, r4
{
 c0535be:	4607      	mov	r7, r0
 c0535c0:	4615      	mov	r5, r2
    MBEDTLS_MPI_CHK( mbedtls_mpi_resize_clear( X, limbs ) );
 c0535c2:	f7ff fed7 	bl	c053374 <mbedtls_mpi_resize_clear>
 c0535c6:	4606      	mov	r6, r0
 c0535c8:	b968      	cbnz	r0, c0535e6 <mbedtls_mpi_read_binary+0x3c>
    if( buflen != 0 )
 c0535ca:	b165      	cbz	r5, c0535e6 <mbedtls_mpi_read_binary+0x3c>
        memcpy( Xp + overhead, buf, buflen );
 c0535cc:	68bb      	ldr	r3, [r7, #8]
    size_t const overhead = ( limbs * ciL ) - buflen;
 c0535ce:	ebc5 0084 	rsb	r0, r5, r4, lsl #2
        memcpy( Xp + overhead, buf, buflen );
 c0535d2:	462a      	mov	r2, r5
 c0535d4:	4641      	mov	r1, r8
 c0535d6:	4418      	add	r0, r3
 c0535d8:	f008 f838 	bl	c05b64c <memcpy>
        mpi_bigendian_to_host( X->p, limbs );
 c0535dc:	68b8      	ldr	r0, [r7, #8]
    if( limbs == 0 )
 c0535de:	b114      	cbz	r4, c0535e6 <mbedtls_mpi_read_binary+0x3c>
 c0535e0:	4621      	mov	r1, r4
 c0535e2:	f7ff fe44 	bl	c05326e <mpi_bigendian_to_host.part.0>
}
 c0535e6:	4630      	mov	r0, r6
 c0535e8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0c0535ec <mbedtls_mpi_write_binary_le>:
{
 c0535ec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    size_t stored_bytes = X->n * ciL;
 c0535ee:	6843      	ldr	r3, [r0, #4]
{
 c0535f0:	460e      	mov	r6, r1
    if( stored_bytes < buflen )
 c0535f2:	ebb2 0f83 	cmp.w	r2, r3, lsl #2
    size_t stored_bytes = X->n * ciL;
 c0535f6:	ea4f 0483 	mov.w	r4, r3, lsl #2
    if( stored_bytes < buflen )
 c0535fa:	d816      	bhi.n	c05362a <mbedtls_mpi_write_binary_le+0x3e>
 c0535fc:	4613      	mov	r3, r2
        for( i = bytes_to_copy; i < stored_bytes; i++ )
 c0535fe:	42a3      	cmp	r3, r4
 c053600:	d107      	bne.n	c053612 <mbedtls_mpi_write_binary_le+0x26>
 c053602:	4617      	mov	r7, r2
    for( i = 0; i < bytes_to_copy; i++ )
 c053604:	2300      	movs	r3, #0
 c053606:	429f      	cmp	r7, r3
 c053608:	d111      	bne.n	c05362e <mbedtls_mpi_write_binary_le+0x42>
    if( stored_bytes < buflen )
 c05360a:	4294      	cmp	r4, r2
 c05360c:	d31b      	bcc.n	c053646 <mbedtls_mpi_write_binary_le+0x5a>
    return( 0 );
 c05360e:	2000      	movs	r0, #0
}
 c053610:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            if( GET_BYTE( X, i ) != 0 )
 c053612:	6885      	ldr	r5, [r0, #8]
 c053614:	f023 0703 	bic.w	r7, r3, #3
 c053618:	59ed      	ldr	r5, [r5, r7]
 c05361a:	f003 0103 	and.w	r1, r3, #3
 c05361e:	00c9      	lsls	r1, r1, #3
 c053620:	40cd      	lsrs	r5, r1
 c053622:	b2ed      	uxtb	r5, r5
 c053624:	b9ad      	cbnz	r5, c053652 <mbedtls_mpi_write_binary_le+0x66>
        for( i = bytes_to_copy; i < stored_bytes; i++ )
 c053626:	3301      	adds	r3, #1
 c053628:	e7e9      	b.n	c0535fe <mbedtls_mpi_write_binary_le+0x12>
 c05362a:	4627      	mov	r7, r4
 c05362c:	e7ea      	b.n	c053604 <mbedtls_mpi_write_binary_le+0x18>
        buf[i] = GET_BYTE( X, i );
 c05362e:	6881      	ldr	r1, [r0, #8]
 c053630:	f023 0c03 	bic.w	ip, r3, #3
 c053634:	f851 100c 	ldr.w	r1, [r1, ip]
 c053638:	f003 0503 	and.w	r5, r3, #3
 c05363c:	00ed      	lsls	r5, r5, #3
 c05363e:	40e9      	lsrs	r1, r5
 c053640:	54f1      	strb	r1, [r6, r3]
    for( i = 0; i < bytes_to_copy; i++ )
 c053642:	3301      	adds	r3, #1
 c053644:	e7df      	b.n	c053606 <mbedtls_mpi_write_binary_le+0x1a>
        memset( buf + stored_bytes, 0, buflen - stored_bytes );
 c053646:	2100      	movs	r1, #0
 c053648:	1b12      	subs	r2, r2, r4
 c05364a:	1930      	adds	r0, r6, r4
 c05364c:	f008 f86f 	bl	c05b72e <memset>
 c053650:	e7dd      	b.n	c05360e <mbedtls_mpi_write_binary_le+0x22>
                return( MBEDTLS_ERR_MPI_BUFFER_TOO_SMALL );
 c053652:	f06f 0007 	mvn.w	r0, #7
 c053656:	e7db      	b.n	c053610 <mbedtls_mpi_write_binary_le+0x24>

0c053658 <mbedtls_mpi_write_binary>:
{
 c053658:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 c05365a:	4604      	mov	r4, r0
    stored_bytes = X->n * ciL;
 c05365c:	6863      	ldr	r3, [r4, #4]
{
 c05365e:	4608      	mov	r0, r1
    if( stored_bytes < buflen )
 c053660:	ebb2 0f83 	cmp.w	r2, r3, lsl #2
    stored_bytes = X->n * ciL;
 c053664:	ea4f 0583 	mov.w	r5, r3, lsl #2
    if( stored_bytes < buflen )
 c053668:	d91a      	bls.n	c0536a0 <mbedtls_mpi_write_binary+0x48>
        p = buf + buflen - stored_bytes;
 c05366a:	1b52      	subs	r2, r2, r5
 c05366c:	188e      	adds	r6, r1, r2
        memset( buf, 0, buflen - stored_bytes );
 c05366e:	2100      	movs	r1, #0
 c053670:	f008 f85d 	bl	c05b72e <memset>
        p = buf + buflen - stored_bytes;
 c053674:	4630      	mov	r0, r6
 c053676:	462a      	mov	r2, r5
    for( i = 0; i < bytes_to_copy; i++ )
 c053678:	2100      	movs	r1, #0
 c05367a:	1883      	adds	r3, r0, r2
 c05367c:	428a      	cmp	r2, r1
 c05367e:	d111      	bne.n	c0536a4 <mbedtls_mpi_write_binary+0x4c>
    return( 0 );
 c053680:	2000      	movs	r0, #0
}
 c053682:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            if( GET_BYTE( X, i ) != 0 )
 c053684:	68a1      	ldr	r1, [r4, #8]
 c053686:	f023 0703 	bic.w	r7, r3, #3
 c05368a:	59c9      	ldr	r1, [r1, r7]
 c05368c:	f003 0603 	and.w	r6, r3, #3
 c053690:	00f6      	lsls	r6, r6, #3
 c053692:	40f1      	lsrs	r1, r6
 c053694:	b2c9      	uxtb	r1, r1
 c053696:	b989      	cbnz	r1, c0536bc <mbedtls_mpi_write_binary+0x64>
        for( i = bytes_to_copy; i < stored_bytes; i++ )
 c053698:	3301      	adds	r3, #1
 c05369a:	42ab      	cmp	r3, r5
 c05369c:	d1f2      	bne.n	c053684 <mbedtls_mpi_write_binary+0x2c>
 c05369e:	e7eb      	b.n	c053678 <mbedtls_mpi_write_binary+0x20>
 c0536a0:	4613      	mov	r3, r2
 c0536a2:	e7fa      	b.n	c05369a <mbedtls_mpi_write_binary+0x42>
        p[bytes_to_copy - i - 1] = GET_BYTE( X, i );
 c0536a4:	68a6      	ldr	r6, [r4, #8]
 c0536a6:	f021 0003 	bic.w	r0, r1, #3
 c0536aa:	5830      	ldr	r0, [r6, r0]
 c0536ac:	f001 0503 	and.w	r5, r1, #3
 c0536b0:	00ed      	lsls	r5, r5, #3
 c0536b2:	40e8      	lsrs	r0, r5
 c0536b4:	f803 0d01 	strb.w	r0, [r3, #-1]!
    for( i = 0; i < bytes_to_copy; i++ )
 c0536b8:	3101      	adds	r1, #1
 c0536ba:	e7df      	b.n	c05367c <mbedtls_mpi_write_binary+0x24>
                return( MBEDTLS_ERR_MPI_BUFFER_TOO_SMALL );
 c0536bc:	f06f 0007 	mvn.w	r0, #7
 c0536c0:	e7df      	b.n	c053682 <mbedtls_mpi_write_binary+0x2a>

0c0536c2 <mbedtls_mpi_shift_l>:
{
 c0536c2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 c0536c4:	4605      	mov	r5, r0
 c0536c6:	460e      	mov	r6, r1
    v0 = count / (biL    );
 c0536c8:	094c      	lsrs	r4, r1, #5
    t1 = count & (biL - 1);
 c0536ca:	f001 071f 	and.w	r7, r1, #31
    i = mbedtls_mpi_bitlen( X ) + count;
 c0536ce:	f7ff ff26 	bl	c05351e <mbedtls_mpi_bitlen>
    if( X->n * biL < i )
 c0536d2:	686b      	ldr	r3, [r5, #4]
    i = mbedtls_mpi_bitlen( X ) + count;
 c0536d4:	4430      	add	r0, r6
    if( X->n * biL < i )
 c0536d6:	ebb0 1f43 	cmp.w	r0, r3, lsl #5
 c0536da:	d804      	bhi.n	c0536e6 <mbedtls_mpi_shift_l+0x24>
    if( v0 > 0 )
 c0536dc:	2e1f      	cmp	r6, #31
 c0536de:	d80e      	bhi.n	c0536fe <mbedtls_mpi_shift_l+0x3c>
    if( t1 > 0 )
 c0536e0:	bb6f      	cbnz	r7, c05373e <mbedtls_mpi_shift_l+0x7c>
    ret = 0;
 c0536e2:	2000      	movs	r0, #0
 c0536e4:	e00a      	b.n	c0536fc <mbedtls_mpi_shift_l+0x3a>
        MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, BITS_TO_LIMBS( i ) ) );
 c0536e6:	f010 011f 	ands.w	r1, r0, #31
 c0536ea:	bf18      	it	ne
 c0536ec:	2101      	movne	r1, #1
 c0536ee:	eb01 1150 	add.w	r1, r1, r0, lsr #5
 c0536f2:	4628      	mov	r0, r5
 c0536f4:	f7ff fe17 	bl	c053326 <mbedtls_mpi_grow>
 c0536f8:	2800      	cmp	r0, #0
 c0536fa:	d0ef      	beq.n	c0536dc <mbedtls_mpi_shift_l+0x1a>
}
 c0536fc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        for( i = X->n; i > v0; i-- )
 c0536fe:	f06f 0003 	mvn.w	r0, #3
 c053702:	686b      	ldr	r3, [r5, #4]
 c053704:	4360      	muls	r0, r4
 c053706:	4619      	mov	r1, r3
 c053708:	009a      	lsls	r2, r3, #2
 c05370a:	42a1      	cmp	r1, r4
 c05370c:	f1a2 0204 	sub.w	r2, r2, #4
 c053710:	d80c      	bhi.n	c05372c <mbedtls_mpi_shift_l+0x6a>
 c053712:	1ae2      	subs	r2, r4, r3
 c053714:	429c      	cmp	r4, r3
 c053716:	bf88      	it	hi
 c053718:	2200      	movhi	r2, #0
 c05371a:	4413      	add	r3, r2
            X->p[i - 1] = 0;
 c05371c:	2200      	movs	r2, #0
 c05371e:	009b      	lsls	r3, r3, #2
        for( ; i > 0; i-- )
 c053720:	3b04      	subs	r3, #4
 c053722:	1d19      	adds	r1, r3, #4
 c053724:	d0dc      	beq.n	c0536e0 <mbedtls_mpi_shift_l+0x1e>
            X->p[i - 1] = 0;
 c053726:	68a9      	ldr	r1, [r5, #8]
 c053728:	50ca      	str	r2, [r1, r3]
        for( ; i > 0; i-- )
 c05372a:	e7f9      	b.n	c053720 <mbedtls_mpi_shift_l+0x5e>
            X->p[i - 1] = X->p[i - v0 - 1];
 c05372c:	68ae      	ldr	r6, [r5, #8]
        for( i = X->n; i > v0; i-- )
 c05372e:	3901      	subs	r1, #1
            X->p[i - 1] = X->p[i - v0 - 1];
 c053730:	eb06 0c02 	add.w	ip, r6, r2
 c053734:	f85c c000 	ldr.w	ip, [ip, r0]
 c053738:	f846 c002 	str.w	ip, [r6, r2]
        for( i = X->n; i > v0; i-- )
 c05373c:	e7e5      	b.n	c05370a <mbedtls_mpi_shift_l+0x48>
    mbedtls_mpi_uint r0 = 0, r1;
 c05373e:	2200      	movs	r2, #0
        for( i = v0; i < X->n; i++ )
 c053740:	686e      	ldr	r6, [r5, #4]
            r1 = X->p[i] >> (biL - t1);
 c053742:	f1c7 0c20 	rsb	ip, r7, #32
        for( i = v0; i < X->n; i++ )
 c053746:	42a6      	cmp	r6, r4
 c053748:	d9cb      	bls.n	c0536e2 <mbedtls_mpi_shift_l+0x20>
            r1 = X->p[i] >> (biL - t1);
 c05374a:	68a8      	ldr	r0, [r5, #8]
 c05374c:	f850 1024 	ldr.w	r1, [r0, r4, lsl #2]
            X->p[i] <<= t1;
 c053750:	fa01 f307 	lsl.w	r3, r1, r7
            X->p[i] |= r0;
 c053754:	4313      	orrs	r3, r2
 c053756:	f840 3024 	str.w	r3, [r0, r4, lsl #2]
            r0 = r1;
 c05375a:	fa21 f20c 	lsr.w	r2, r1, ip
        for( i = v0; i < X->n; i++ )
 c05375e:	3401      	adds	r4, #1
 c053760:	e7f1      	b.n	c053746 <mbedtls_mpi_shift_l+0x84>

0c053762 <mbedtls_mpi_shift_r>:
    if( v0 > X->n || ( v0 == X->n && v1 > 0 ) )
 c053762:	6843      	ldr	r3, [r0, #4]
{
 c053764:	b4f0      	push	{r4, r5, r6, r7}
    v0 = count /  biL;
 c053766:	094e      	lsrs	r6, r1, #5
    if( v0 > X->n || ( v0 == X->n && v1 > 0 ) )
 c053768:	42b3      	cmp	r3, r6
    v1 = count & (biL - 1);
 c05376a:	f001 041f 	and.w	r4, r1, #31
    if( v0 > X->n || ( v0 == X->n && v1 > 0 ) )
 c05376e:	d301      	bcc.n	c053774 <mbedtls_mpi_shift_r+0x12>
 c053770:	d104      	bne.n	c05377c <mbedtls_mpi_shift_r+0x1a>
 c053772:	b35c      	cbz	r4, c0537cc <mbedtls_mpi_shift_r+0x6a>
}
 c053774:	bcf0      	pop	{r4, r5, r6, r7}
        return mbedtls_mpi_lset( X, 0 );
 c053776:	2100      	movs	r1, #0
 c053778:	f7ff be61 	b.w	c05343e <mbedtls_mpi_lset>
    if( v0 > 0 )
 c05377c:	291f      	cmp	r1, #31
 c05377e:	d827      	bhi.n	c0537d0 <mbedtls_mpi_shift_r+0x6e>
    if( v1 > 0 )
 c053780:	bb04      	cbnz	r4, c0537c4 <mbedtls_mpi_shift_r+0x62>
}
 c053782:	bcf0      	pop	{r4, r5, r6, r7}
 c053784:	2000      	movs	r0, #0
 c053786:	4770      	bx	lr
            X->p[i] = X->p[i + v0];
 c053788:	6882      	ldr	r2, [r0, #8]
 c05378a:	5957      	ldr	r7, [r2, r5]
 c05378c:	3504      	adds	r5, #4
 c05378e:	f842 7021 	str.w	r7, [r2, r1, lsl #2]
        for( i = 0; i < X->n - v0; i++ )
 c053792:	3101      	adds	r1, #1
 c053794:	1b9a      	subs	r2, r3, r6
 c053796:	428a      	cmp	r2, r1
 c053798:	d8f6      	bhi.n	c053788 <mbedtls_mpi_shift_r+0x26>
            X->p[i] = 0;
 c05379a:	2100      	movs	r1, #0
        for( ; i < X->n; i++ )
 c05379c:	4293      	cmp	r3, r2
 c05379e:	d9ef      	bls.n	c053780 <mbedtls_mpi_shift_r+0x1e>
            X->p[i] = 0;
 c0537a0:	6885      	ldr	r5, [r0, #8]
 c0537a2:	f845 1022 	str.w	r1, [r5, r2, lsl #2]
        for( ; i < X->n; i++ )
 c0537a6:	3201      	adds	r2, #1
 c0537a8:	e7f8      	b.n	c05379c <mbedtls_mpi_shift_r+0x3a>
            r1 = X->p[i - 1] << (biL - v1);
 c0537aa:	6886      	ldr	r6, [r0, #8]
 c0537ac:	f856 5023 	ldr.w	r5, [r6, r3, lsl #2]
            X->p[i - 1] >>= v1;
 c0537b0:	fa25 f204 	lsr.w	r2, r5, r4
            X->p[i - 1] |= r0;
 c0537b4:	430a      	orrs	r2, r1
 c0537b6:	f846 2023 	str.w	r2, [r6, r3, lsl #2]
            r0 = r1;
 c0537ba:	fa05 f107 	lsl.w	r1, r5, r7
        for( i = X->n; i > 0; i-- )
 c0537be:	3b01      	subs	r3, #1
 c0537c0:	d2f3      	bcs.n	c0537aa <mbedtls_mpi_shift_r+0x48>
 c0537c2:	e7de      	b.n	c053782 <mbedtls_mpi_shift_r+0x20>
    mbedtls_mpi_uint r0 = 0, r1;
 c0537c4:	2100      	movs	r1, #0
            r1 = X->p[i - 1] << (biL - v1);
 c0537c6:	f1c4 0720 	rsb	r7, r4, #32
 c0537ca:	e7f8      	b.n	c0537be <mbedtls_mpi_shift_r+0x5c>
    if( v0 > 0 )
 c0537cc:	291f      	cmp	r1, #31
 c0537ce:	d9d8      	bls.n	c053782 <mbedtls_mpi_shift_r+0x20>
{
 c0537d0:	2100      	movs	r1, #0
 c0537d2:	00b5      	lsls	r5, r6, #2
 c0537d4:	e7de      	b.n	c053794 <mbedtls_mpi_shift_r+0x32>

0c0537d6 <mbedtls_mpi_cmp_abs>:
{
 c0537d6:	b530      	push	{r4, r5, lr}
    for( i = X->n; i > 0; i-- )
 c0537d8:	6843      	ldr	r3, [r0, #4]
 c0537da:	b92b      	cbnz	r3, c0537e8 <mbedtls_mpi_cmp_abs+0x12>
    for( j = Y->n; j > 0; j-- )
 c0537dc:	684a      	ldr	r2, [r1, #4]
 c0537de:	b962      	cbnz	r2, c0537fa <mbedtls_mpi_cmp_abs+0x24>
    if( i == 0 && j == 0 )
 c0537e0:	1e18      	subs	r0, r3, #0
 c0537e2:	bf18      	it	ne
 c0537e4:	2001      	movne	r0, #1
 c0537e6:	e028      	b.n	c05383a <mbedtls_mpi_cmp_abs+0x64>
        if( X->p[i - 1] != 0 )
 c0537e8:	6882      	ldr	r2, [r0, #8]
 c0537ea:	eb02 0283 	add.w	r2, r2, r3, lsl #2
 c0537ee:	f852 2c04 	ldr.w	r2, [r2, #-4]
 c0537f2:	2a00      	cmp	r2, #0
 c0537f4:	d1f2      	bne.n	c0537dc <mbedtls_mpi_cmp_abs+0x6>
    for( i = X->n; i > 0; i-- )
 c0537f6:	3b01      	subs	r3, #1
 c0537f8:	e7ef      	b.n	c0537da <mbedtls_mpi_cmp_abs+0x4>
        if( Y->p[j - 1] != 0 )
 c0537fa:	688c      	ldr	r4, [r1, #8]
 c0537fc:	eb04 0582 	add.w	r5, r4, r2, lsl #2
 c053800:	f855 5c04 	ldr.w	r5, [r5, #-4]
 c053804:	b985      	cbnz	r5, c053828 <mbedtls_mpi_cmp_abs+0x52>
    for( j = Y->n; j > 0; j-- )
 c053806:	3a01      	subs	r2, #1
 c053808:	e7e9      	b.n	c0537de <mbedtls_mpi_cmp_abs+0x8>
        if( X->p[i - 1] > Y->p[i - 1] ) return(  1 );
 c05380a:	6882      	ldr	r2, [r0, #8]
 c05380c:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
 c053810:	f854 2023 	ldr.w	r2, [r4, r3, lsl #2]
 c053814:	4291      	cmp	r1, r2
 c053816:	d805      	bhi.n	c053824 <mbedtls_mpi_cmp_abs+0x4e>
        if( X->p[i - 1] < Y->p[i - 1] ) return( -1 );
 c053818:	f103 33ff 	add.w	r3, r3, #4294967295	@ 0xffffffff
 c05381c:	d20a      	bcs.n	c053834 <mbedtls_mpi_cmp_abs+0x5e>
    if( j > i ) return( -1 );
 c05381e:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 c053822:	e00a      	b.n	c05383a <mbedtls_mpi_cmp_abs+0x64>
    if( i > j ) return(  1 );
 c053824:	2001      	movs	r0, #1
 c053826:	e008      	b.n	c05383a <mbedtls_mpi_cmp_abs+0x64>
    if( i == 0 && j == 0 )
 c053828:	2b00      	cmp	r3, #0
 c05382a:	d0f8      	beq.n	c05381e <mbedtls_mpi_cmp_abs+0x48>
    if( i > j ) return(  1 );
 c05382c:	4293      	cmp	r3, r2
 c05382e:	d8f9      	bhi.n	c053824 <mbedtls_mpi_cmp_abs+0x4e>
    if( j > i ) return( -1 );
 c053830:	d3f5      	bcc.n	c05381e <mbedtls_mpi_cmp_abs+0x48>
 c053832:	3b01      	subs	r3, #1
    for( ; i > 0; i-- )
 c053834:	1c5a      	adds	r2, r3, #1
 c053836:	d1e8      	bne.n	c05380a <mbedtls_mpi_cmp_abs+0x34>
        return( 0 );
 c053838:	2000      	movs	r0, #0
}
 c05383a:	bd30      	pop	{r4, r5, pc}

0c05383c <mbedtls_mpi_cmp_mpi>:
{
 c05383c:	4602      	mov	r2, r0
 c05383e:	b530      	push	{r4, r5, lr}
    for( i = X->n; i > 0; i-- )
 c053840:	6843      	ldr	r3, [r0, #4]
 c053842:	b923      	cbnz	r3, c05384e <mbedtls_mpi_cmp_mpi+0x12>
    for( j = Y->n; j > 0; j-- )
 c053844:	6848      	ldr	r0, [r1, #4]
 c053846:	b958      	cbnz	r0, c053860 <mbedtls_mpi_cmp_mpi+0x24>
    if( i == 0 && j == 0 )
 c053848:	2b00      	cmp	r3, #0
 c05384a:	d138      	bne.n	c0538be <mbedtls_mpi_cmp_mpi+0x82>
 c05384c:	e031      	b.n	c0538b2 <mbedtls_mpi_cmp_mpi+0x76>
        if( X->p[i - 1] != 0 )
 c05384e:	6890      	ldr	r0, [r2, #8]
 c053850:	eb00 0083 	add.w	r0, r0, r3, lsl #2
 c053854:	f850 0c04 	ldr.w	r0, [r0, #-4]
 c053858:	2800      	cmp	r0, #0
 c05385a:	d1f3      	bne.n	c053844 <mbedtls_mpi_cmp_mpi+0x8>
    for( i = X->n; i > 0; i-- )
 c05385c:	3b01      	subs	r3, #1
 c05385e:	e7f0      	b.n	c053842 <mbedtls_mpi_cmp_mpi+0x6>
        if( Y->p[j - 1] != 0 )
 c053860:	688c      	ldr	r4, [r1, #8]
 c053862:	eb04 0580 	add.w	r5, r4, r0, lsl #2
 c053866:	f855 5c04 	ldr.w	r5, [r5, #-4]
 c05386a:	bb25      	cbnz	r5, c0538b6 <mbedtls_mpi_cmp_mpi+0x7a>
    for( j = Y->n; j > 0; j-- )
 c05386c:	3801      	subs	r0, #1
 c05386e:	e7ea      	b.n	c053846 <mbedtls_mpi_cmp_mpi+0xa>
    if( j > i ) return( -Y->s );
 c053870:	4283      	cmp	r3, r0
 c053872:	6809      	ldr	r1, [r1, #0]
 c053874:	d201      	bcs.n	c05387a <mbedtls_mpi_cmp_mpi+0x3e>
 c053876:	4248      	negs	r0, r1
 c053878:	e022      	b.n	c0538c0 <mbedtls_mpi_cmp_mpi+0x84>
    if( X->s > 0 && Y->s < 0 ) return(  1 );
 c05387a:	6810      	ldr	r0, [r2, #0]
 c05387c:	2800      	cmp	r0, #0
 c05387e:	dd03      	ble.n	c053888 <mbedtls_mpi_cmp_mpi+0x4c>
 c053880:	2900      	cmp	r1, #0
 c053882:	da13      	bge.n	c0538ac <mbedtls_mpi_cmp_mpi+0x70>
 c053884:	2001      	movs	r0, #1
 c053886:	e01b      	b.n	c0538c0 <mbedtls_mpi_cmp_mpi+0x84>
    if( Y->s > 0 && X->s < 0 ) return( -1 );
 c053888:	2900      	cmp	r1, #0
 c05388a:	dd0f      	ble.n	c0538ac <mbedtls_mpi_cmp_mpi+0x70>
 c05388c:	b170      	cbz	r0, c0538ac <mbedtls_mpi_cmp_mpi+0x70>
 c05388e:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 c053892:	e015      	b.n	c0538c0 <mbedtls_mpi_cmp_mpi+0x84>
        if( X->p[i - 1] > Y->p[i - 1] ) return(  X->s );
 c053894:	6891      	ldr	r1, [r2, #8]
 c053896:	f851 5023 	ldr.w	r5, [r1, r3, lsl #2]
 c05389a:	f854 1023 	ldr.w	r1, [r4, r3, lsl #2]
 c05389e:	428d      	cmp	r5, r1
 c0538a0:	d80e      	bhi.n	c0538c0 <mbedtls_mpi_cmp_mpi+0x84>
        if( X->p[i - 1] < Y->p[i - 1] ) return( -X->s );
 c0538a2:	f103 33ff 	add.w	r3, r3, #4294967295	@ 0xffffffff
 c0538a6:	d202      	bcs.n	c0538ae <mbedtls_mpi_cmp_mpi+0x72>
 c0538a8:	4240      	negs	r0, r0
 c0538aa:	e009      	b.n	c0538c0 <mbedtls_mpi_cmp_mpi+0x84>
 c0538ac:	3b01      	subs	r3, #1
    for( ; i > 0; i-- )
 c0538ae:	1c59      	adds	r1, r3, #1
 c0538b0:	d1f0      	bne.n	c053894 <mbedtls_mpi_cmp_mpi+0x58>
        return( 0 );
 c0538b2:	2000      	movs	r0, #0
 c0538b4:	e004      	b.n	c0538c0 <mbedtls_mpi_cmp_mpi+0x84>
    if( i == 0 && j == 0 )
 c0538b6:	2b00      	cmp	r3, #0
 c0538b8:	d0da      	beq.n	c053870 <mbedtls_mpi_cmp_mpi+0x34>
    if( i > j ) return(  X->s );
 c0538ba:	4283      	cmp	r3, r0
 c0538bc:	d9d8      	bls.n	c053870 <mbedtls_mpi_cmp_mpi+0x34>
 c0538be:	6810      	ldr	r0, [r2, #0]
}
 c0538c0:	bd30      	pop	{r4, r5, pc}

0c0538c2 <mbedtls_mpi_cmp_int>:
{
 c0538c2:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    *p  = ( z < 0 ) ? -z : z;
 c0538c4:	ea81 73e1 	eor.w	r3, r1, r1, asr #31
 c0538c8:	eba3 73e1 	sub.w	r3, r3, r1, asr #31
    Y.s = ( z < 0 ) ? -1 : 1;
 c0538cc:	2900      	cmp	r1, #0
    *p  = ( z < 0 ) ? -z : z;
 c0538ce:	9300      	str	r3, [sp, #0]
    Y.s = ( z < 0 ) ? -1 : 1;
 c0538d0:	bfac      	ite	ge
 c0538d2:	2301      	movge	r3, #1
 c0538d4:	f04f 33ff 	movlt.w	r3, #4294967295	@ 0xffffffff
 c0538d8:	9301      	str	r3, [sp, #4]
    Y.n = 1;
 c0538da:	2301      	movs	r3, #1
    return( mbedtls_mpi_cmp_mpi( X, &Y ) );
 c0538dc:	a901      	add	r1, sp, #4
    Y.n = 1;
 c0538de:	9302      	str	r3, [sp, #8]
    Y.p = p;
 c0538e0:	f8cd d00c 	str.w	sp, [sp, #12]
    return( mbedtls_mpi_cmp_mpi( X, &Y ) );
 c0538e4:	f7ff ffaa 	bl	c05383c <mbedtls_mpi_cmp_mpi>
}
 c0538e8:	b005      	add	sp, #20
 c0538ea:	f85d fb04 	ldr.w	pc, [sp], #4

0c0538ee <mbedtls_mpi_add_abs>:
    if( X == B )
 c0538ee:	4290      	cmp	r0, r2
{
 c0538f0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 c0538f4:	4606      	mov	r6, r0
 c0538f6:	460f      	mov	r7, r1
 c0538f8:	4615      	mov	r5, r2
    if( X == B )
 c0538fa:	d002      	beq.n	c053902 <mbedtls_mpi_add_abs+0x14>
    if( X != A )
 c0538fc:	4288      	cmp	r0, r1
 c0538fe:	d129      	bne.n	c053954 <mbedtls_mpi_add_abs+0x66>
{
 c053900:	462f      	mov	r7, r5
    X->s = 1;
 c053902:	2301      	movs	r3, #1
    for( j = B->n; j > 0; j-- )
 c053904:	687d      	ldr	r5, [r7, #4]
    X->s = 1;
 c053906:	6033      	str	r3, [r6, #0]
    for( j = B->n; j > 0; j-- )
 c053908:	bb65      	cbnz	r5, c053964 <mbedtls_mpi_add_abs+0x76>
    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, j ) );
 c05390a:	4629      	mov	r1, r5
 c05390c:	4630      	mov	r0, r6
 c05390e:	f7ff fd0a 	bl	c053326 <mbedtls_mpi_grow>
 c053912:	4604      	mov	r4, r0
 c053914:	bb18      	cbnz	r0, c05395e <mbedtls_mpi_add_abs+0x70>
    o = B->p; p = X->p; c = 0;
 c053916:	68b3      	ldr	r3, [r6, #8]
 c053918:	68b9      	ldr	r1, [r7, #8]
 c05391a:	469c      	mov	ip, r3
 c05391c:	4607      	mov	r7, r0
    for( i = 0; i < j; i++, o++, p++ )
 c05391e:	4285      	cmp	r5, r0
 c053920:	d129      	bne.n	c053976 <mbedtls_mpi_add_abs+0x88>
 c053922:	eb03 0385 	add.w	r3, r3, r5, lsl #2
    while( c != 0 )
 c053926:	b1d7      	cbz	r7, c05395e <mbedtls_mpi_add_abs+0x70>
        if( i >= X->n )
 c053928:	6872      	ldr	r2, [r6, #4]
            MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, i + 1 ) );
 c05392a:	f105 0801 	add.w	r8, r5, #1
        if( i >= X->n )
 c05392e:	42aa      	cmp	r2, r5
 c053930:	d807      	bhi.n	c053942 <mbedtls_mpi_add_abs+0x54>
            MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, i + 1 ) );
 c053932:	4641      	mov	r1, r8
 c053934:	4630      	mov	r0, r6
 c053936:	f7ff fcf6 	bl	c053326 <mbedtls_mpi_grow>
 c05393a:	bb68      	cbnz	r0, c053998 <mbedtls_mpi_add_abs+0xaa>
            p = X->p + i;
 c05393c:	68b3      	ldr	r3, [r6, #8]
 c05393e:	eb03 0385 	add.w	r3, r3, r5, lsl #2
        *p += c; c = ( *p < c ); i++; p++;
 c053942:	681a      	ldr	r2, [r3, #0]
 c053944:	4645      	mov	r5, r8
 c053946:	19d2      	adds	r2, r2, r7
 c053948:	bf2c      	ite	cs
 c05394a:	2701      	movcs	r7, #1
 c05394c:	2700      	movcc	r7, #0
 c05394e:	f843 2b04 	str.w	r2, [r3], #4
 c053952:	e7e8      	b.n	c053926 <mbedtls_mpi_add_abs+0x38>
        MBEDTLS_MPI_CHK( mbedtls_mpi_copy( X, A ) );
 c053954:	f7ff fd29 	bl	c0533aa <mbedtls_mpi_copy>
 c053958:	4604      	mov	r4, r0
 c05395a:	2800      	cmp	r0, #0
 c05395c:	d0d0      	beq.n	c053900 <mbedtls_mpi_add_abs+0x12>
}
 c05395e:	4620      	mov	r0, r4
 c053960:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        if( B->p[j - 1] != 0 )
 c053964:	68bb      	ldr	r3, [r7, #8]
 c053966:	eb03 0385 	add.w	r3, r3, r5, lsl #2
 c05396a:	f853 3c04 	ldr.w	r3, [r3, #-4]
 c05396e:	2b00      	cmp	r3, #0
 c053970:	d1cb      	bne.n	c05390a <mbedtls_mpi_add_abs+0x1c>
    for( j = B->n; j > 0; j-- )
 c053972:	3d01      	subs	r5, #1
 c053974:	e7c8      	b.n	c053908 <mbedtls_mpi_add_abs+0x1a>
        *p +=  c; c  = ( *p <  c );
 c053976:	f8dc 2000 	ldr.w	r2, [ip]
 c05397a:	19d2      	adds	r2, r2, r7
 c05397c:	bf2c      	ite	cs
 c05397e:	f04f 0e01 	movcs.w	lr, #1
 c053982:	f04f 0e00 	movcc.w	lr, #0
        *p += tmp; c += ( *p < tmp );
 c053986:	f851 7020 	ldr.w	r7, [r1, r0, lsl #2]
    for( i = 0; i < j; i++, o++, p++ )
 c05398a:	3001      	adds	r0, #1
 c05398c:	19d2      	adds	r2, r2, r7
        *p += tmp; c += ( *p < tmp );
 c05398e:	f84c 2b04 	str.w	r2, [ip], #4
 c053992:	f14e 0700 	adc.w	r7, lr, #0
    for( i = 0; i < j; i++, o++, p++ )
 c053996:	e7c2      	b.n	c05391e <mbedtls_mpi_add_abs+0x30>
            MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, i + 1 ) );
 c053998:	4604      	mov	r4, r0
    return( ret );
 c05399a:	e7e0      	b.n	c05395e <mbedtls_mpi_add_abs+0x70>

0c05399c <mbedtls_mpi_sub_abs>:
{
 c05399c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 c0539a0:	4605      	mov	r5, r0
 c0539a2:	460e      	mov	r6, r1
 c0539a4:	4690      	mov	r8, r2
    for( n = B->n; n > 0; n-- )
 c0539a6:	6854      	ldr	r4, [r2, #4]
 c0539a8:	b93c      	cbnz	r4, c0539ba <mbedtls_mpi_sub_abs+0x1e>
    if( n > A->n )
 c0539aa:	6871      	ldr	r1, [r6, #4]
 c0539ac:	42a1      	cmp	r1, r4
 c0539ae:	d20e      	bcs.n	c0539ce <mbedtls_mpi_sub_abs+0x32>
        ret = MBEDTLS_ERR_MPI_NEGATIVE_VALUE;
 c0539b0:	f06f 0709 	mvn.w	r7, #9
}
 c0539b4:	4638      	mov	r0, r7
 c0539b6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        if( B->p[n - 1] != 0 )
 c0539ba:	f8d8 3008 	ldr.w	r3, [r8, #8]
 c0539be:	eb03 0384 	add.w	r3, r3, r4, lsl #2
 c0539c2:	f853 3c04 	ldr.w	r3, [r3, #-4]
 c0539c6:	2b00      	cmp	r3, #0
 c0539c8:	d1ef      	bne.n	c0539aa <mbedtls_mpi_sub_abs+0xe>
    for( n = B->n; n > 0; n-- )
 c0539ca:	3c01      	subs	r4, #1
 c0539cc:	e7ec      	b.n	c0539a8 <mbedtls_mpi_sub_abs+0xc>
    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, A->n ) );
 c0539ce:	4628      	mov	r0, r5
 c0539d0:	f7ff fca9 	bl	c053326 <mbedtls_mpi_grow>
 c0539d4:	4607      	mov	r7, r0
 c0539d6:	2800      	cmp	r0, #0
 c0539d8:	d1ec      	bne.n	c0539b4 <mbedtls_mpi_sub_abs+0x18>
    if( A->n > n )
 c0539da:	6872      	ldr	r2, [r6, #4]
 c0539dc:	42a2      	cmp	r2, r4
 c0539de:	d909      	bls.n	c0539f4 <mbedtls_mpi_sub_abs+0x58>
        memcpy( X->p + n, A->p + n, ( A->n - n ) * ciL );
 c0539e0:	68a8      	ldr	r0, [r5, #8]
 c0539e2:	68b1      	ldr	r1, [r6, #8]
 c0539e4:	1b12      	subs	r2, r2, r4
 c0539e6:	0092      	lsls	r2, r2, #2
 c0539e8:	eb01 0184 	add.w	r1, r1, r4, lsl #2
 c0539ec:	eb00 0084 	add.w	r0, r0, r4, lsl #2
 c0539f0:	f007 fe2c 	bl	c05b64c <memcpy>
    if( X->n > A->n )
 c0539f4:	686a      	ldr	r2, [r5, #4]
 c0539f6:	6870      	ldr	r0, [r6, #4]
 c0539f8:	4282      	cmp	r2, r0
 c0539fa:	d907      	bls.n	c053a0c <mbedtls_mpi_sub_abs+0x70>
        memset( X->p + A->n, 0, ( X->n - A->n ) * ciL );
 c0539fc:	68ab      	ldr	r3, [r5, #8]
 c0539fe:	1a12      	subs	r2, r2, r0
 c053a00:	2100      	movs	r1, #0
 c053a02:	0092      	lsls	r2, r2, #2
 c053a04:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 c053a08:	f007 fe91 	bl	c05b72e <memset>
    mbedtls_mpi_uint c = 0, t, z;
 c053a0c:	2200      	movs	r2, #0
    for( i = 0; i < n; i++ )
 c053a0e:	4613      	mov	r3, r2
    carry = mpi_sub_hlp( n, X->p, A->p, B->p );
 c053a10:	68a9      	ldr	r1, [r5, #8]
 c053a12:	f8d6 e008 	ldr.w	lr, [r6, #8]
 c053a16:	f8d8 8008 	ldr.w	r8, [r8, #8]
    for( i = 0; i < n; i++ )
 c053a1a:	429c      	cmp	r4, r3
 c053a1c:	d111      	bne.n	c053a42 <mbedtls_mpi_sub_abs+0xa6>
    if( carry != 0 )
 c053a1e:	b16a      	cbz	r2, c053a3c <mbedtls_mpi_sub_abs+0xa0>
            --X->p[n];
 c053a20:	f04f 36ff 	mov.w	r6, #4294967295	@ 0xffffffff
        for( ; n < X->n && X->p[n] == 0; n++ )
 c053a24:	6868      	ldr	r0, [r5, #4]
 c053a26:	eb01 0384 	add.w	r3, r1, r4, lsl #2
 c053a2a:	42a0      	cmp	r0, r4
 c053a2c:	d923      	bls.n	c053a76 <mbedtls_mpi_sub_abs+0xda>
 c053a2e:	681a      	ldr	r2, [r3, #0]
 c053a30:	b1ea      	cbz	r2, c053a6e <mbedtls_mpi_sub_abs+0xd2>
        --X->p[n];
 c053a32:	f851 3024 	ldr.w	r3, [r1, r4, lsl #2]
 c053a36:	3b01      	subs	r3, #1
 c053a38:	f841 3024 	str.w	r3, [r1, r4, lsl #2]
    X->s = 1;
 c053a3c:	2301      	movs	r3, #1
 c053a3e:	602b      	str	r3, [r5, #0]
    return( ret );
 c053a40:	e7b8      	b.n	c0539b4 <mbedtls_mpi_sub_abs+0x18>
        z = ( l[i] <  c );    t = l[i] - c;
 c053a42:	f85e c023 	ldr.w	ip, [lr, r3, lsl #2]
        c = ( t < r[i] ) + z; d[i] = t - r[i];
 c053a46:	f858 6023 	ldr.w	r6, [r8, r3, lsl #2]
        z = ( l[i] <  c );    t = l[i] - c;
 c053a4a:	ebac 0002 	sub.w	r0, ip, r2
        c = ( t < r[i] ) + z; d[i] = t - r[i];
 c053a4e:	42b0      	cmp	r0, r6
 c053a50:	bf2c      	ite	cs
 c053a52:	f04f 0900 	movcs.w	r9, #0
 c053a56:	f04f 0901 	movcc.w	r9, #1
 c053a5a:	1b80      	subs	r0, r0, r6
 c053a5c:	f841 0023 	str.w	r0, [r1, r3, lsl #2]
 c053a60:	4594      	cmp	ip, r2
 c053a62:	bf2c      	ite	cs
 c053a64:	464a      	movcs	r2, r9
 c053a66:	f109 0201 	addcc.w	r2, r9, #1
    for( i = 0; i < n; i++ )
 c053a6a:	3301      	adds	r3, #1
 c053a6c:	e7d5      	b.n	c053a1a <mbedtls_mpi_sub_abs+0x7e>
            --X->p[n];
 c053a6e:	f843 6b04 	str.w	r6, [r3], #4
        for( ; n < X->n && X->p[n] == 0; n++ )
 c053a72:	3401      	adds	r4, #1
 c053a74:	e7d9      	b.n	c053a2a <mbedtls_mpi_sub_abs+0x8e>
        if( n == X->n )
 c053a76:	d1dc      	bne.n	c053a32 <mbedtls_mpi_sub_abs+0x96>
 c053a78:	e79a      	b.n	c0539b0 <mbedtls_mpi_sub_abs+0x14>

0c053a7a <mbedtls_mpi_add_mpi>:
{
 c053a7a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    s = A->s;
 c053a7c:	680f      	ldr	r7, [r1, #0]
    if( A->s * B->s < 0 )
 c053a7e:	6813      	ldr	r3, [r2, #0]
{
 c053a80:	4606      	mov	r6, r0
    if( A->s * B->s < 0 )
 c053a82:	437b      	muls	r3, r7
{
 c053a84:	460d      	mov	r5, r1
 c053a86:	4614      	mov	r4, r2
    if( A->s * B->s < 0 )
 c053a88:	d517      	bpl.n	c053aba <mbedtls_mpi_add_mpi+0x40>
        if( mbedtls_mpi_cmp_abs( A, B ) >= 0 )
 c053a8a:	4611      	mov	r1, r2
 c053a8c:	4628      	mov	r0, r5
 c053a8e:	f7ff fea2 	bl	c0537d6 <mbedtls_mpi_cmp_abs>
 c053a92:	2800      	cmp	r0, #0
 c053a94:	db06      	blt.n	c053aa4 <mbedtls_mpi_add_mpi+0x2a>
            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_abs( X, A, B ) );
 c053a96:	4622      	mov	r2, r4
 c053a98:	4629      	mov	r1, r5
 c053a9a:	4630      	mov	r0, r6
 c053a9c:	f7ff ff7e 	bl	c05399c <mbedtls_mpi_sub_abs>
        MBEDTLS_MPI_CHK( mbedtls_mpi_add_abs( X, A, B ) );
 c053aa0:	b140      	cbz	r0, c053ab4 <mbedtls_mpi_add_mpi+0x3a>
}
 c053aa2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_abs( X, B, A ) );
 c053aa4:	462a      	mov	r2, r5
 c053aa6:	4621      	mov	r1, r4
 c053aa8:	4630      	mov	r0, r6
 c053aaa:	f7ff ff77 	bl	c05399c <mbedtls_mpi_sub_abs>
 c053aae:	2800      	cmp	r0, #0
 c053ab0:	d1f7      	bne.n	c053aa2 <mbedtls_mpi_add_mpi+0x28>
            X->s = -s;
 c053ab2:	427f      	negs	r7, r7
            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_abs( X, B, A ) );
 c053ab4:	2000      	movs	r0, #0
        X->s = s;
 c053ab6:	6037      	str	r7, [r6, #0]
    return( ret );
 c053ab8:	e7f3      	b.n	c053aa2 <mbedtls_mpi_add_mpi+0x28>
        MBEDTLS_MPI_CHK( mbedtls_mpi_add_abs( X, A, B ) );
 c053aba:	f7ff ff18 	bl	c0538ee <mbedtls_mpi_add_abs>
 c053abe:	e7ef      	b.n	c053aa0 <mbedtls_mpi_add_mpi+0x26>

0c053ac0 <mbedtls_mpi_sub_mpi>:
{
 c053ac0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    s = A->s;
 c053ac2:	680f      	ldr	r7, [r1, #0]
    if( A->s * B->s > 0 )
 c053ac4:	6813      	ldr	r3, [r2, #0]
{
 c053ac6:	4606      	mov	r6, r0
    if( A->s * B->s > 0 )
 c053ac8:	437b      	muls	r3, r7
 c053aca:	2b00      	cmp	r3, #0
{
 c053acc:	460d      	mov	r5, r1
 c053ace:	4614      	mov	r4, r2
    if( A->s * B->s > 0 )
 c053ad0:	dd17      	ble.n	c053b02 <mbedtls_mpi_sub_mpi+0x42>
        if( mbedtls_mpi_cmp_abs( A, B ) >= 0 )
 c053ad2:	4611      	mov	r1, r2
 c053ad4:	4628      	mov	r0, r5
 c053ad6:	f7ff fe7e 	bl	c0537d6 <mbedtls_mpi_cmp_abs>
 c053ada:	2800      	cmp	r0, #0
 c053adc:	db06      	blt.n	c053aec <mbedtls_mpi_sub_mpi+0x2c>
            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_abs( X, A, B ) );
 c053ade:	4622      	mov	r2, r4
 c053ae0:	4629      	mov	r1, r5
 c053ae2:	4630      	mov	r0, r6
 c053ae4:	f7ff ff5a 	bl	c05399c <mbedtls_mpi_sub_abs>
        MBEDTLS_MPI_CHK( mbedtls_mpi_add_abs( X, A, B ) );
 c053ae8:	b140      	cbz	r0, c053afc <mbedtls_mpi_sub_mpi+0x3c>
}
 c053aea:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_abs( X, B, A ) );
 c053aec:	462a      	mov	r2, r5
 c053aee:	4621      	mov	r1, r4
 c053af0:	4630      	mov	r0, r6
 c053af2:	f7ff ff53 	bl	c05399c <mbedtls_mpi_sub_abs>
 c053af6:	2800      	cmp	r0, #0
 c053af8:	d1f7      	bne.n	c053aea <mbedtls_mpi_sub_mpi+0x2a>
            X->s = -s;
 c053afa:	427f      	negs	r7, r7
            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_abs( X, B, A ) );
 c053afc:	2000      	movs	r0, #0
        X->s = s;
 c053afe:	6037      	str	r7, [r6, #0]
    return( ret );
 c053b00:	e7f3      	b.n	c053aea <mbedtls_mpi_sub_mpi+0x2a>
        MBEDTLS_MPI_CHK( mbedtls_mpi_add_abs( X, A, B ) );
 c053b02:	f7ff fef4 	bl	c0538ee <mbedtls_mpi_add_abs>
 c053b06:	e7ef      	b.n	c053ae8 <mbedtls_mpi_sub_mpi+0x28>

0c053b08 <mbedtls_mpi_add_int>:
{
 c053b08:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    p[0] = ( b < 0 ) ? -b : b;
 c053b0a:	ea82 73e2 	eor.w	r3, r2, r2, asr #31
 c053b0e:	eba3 73e2 	sub.w	r3, r3, r2, asr #31
    B.s = ( b < 0 ) ? -1 : 1;
 c053b12:	2a00      	cmp	r2, #0
    p[0] = ( b < 0 ) ? -b : b;
 c053b14:	9300      	str	r3, [sp, #0]
    B.s = ( b < 0 ) ? -1 : 1;
 c053b16:	bfac      	ite	ge
 c053b18:	2301      	movge	r3, #1
 c053b1a:	f04f 33ff 	movlt.w	r3, #4294967295	@ 0xffffffff
 c053b1e:	9301      	str	r3, [sp, #4]
    B.n = 1;
 c053b20:	2301      	movs	r3, #1
    return( mbedtls_mpi_add_mpi( X, A, &B ) );
 c053b22:	aa01      	add	r2, sp, #4
    B.n = 1;
 c053b24:	9302      	str	r3, [sp, #8]
    B.p = p;
 c053b26:	f8cd d00c 	str.w	sp, [sp, #12]
    return( mbedtls_mpi_add_mpi( X, A, &B ) );
 c053b2a:	f7ff ffa6 	bl	c053a7a <mbedtls_mpi_add_mpi>
}
 c053b2e:	b005      	add	sp, #20
 c053b30:	f85d fb04 	ldr.w	pc, [sp], #4

0c053b34 <mbedtls_mpi_sub_int>:
{
 c053b34:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    p[0] = ( b < 0 ) ? -b : b;
 c053b36:	ea82 73e2 	eor.w	r3, r2, r2, asr #31
 c053b3a:	eba3 73e2 	sub.w	r3, r3, r2, asr #31
    B.s = ( b < 0 ) ? -1 : 1;
 c053b3e:	2a00      	cmp	r2, #0
    p[0] = ( b < 0 ) ? -b : b;
 c053b40:	9300      	str	r3, [sp, #0]
    B.s = ( b < 0 ) ? -1 : 1;
 c053b42:	bfac      	ite	ge
 c053b44:	2301      	movge	r3, #1
 c053b46:	f04f 33ff 	movlt.w	r3, #4294967295	@ 0xffffffff
 c053b4a:	9301      	str	r3, [sp, #4]
    B.n = 1;
 c053b4c:	2301      	movs	r3, #1
    return( mbedtls_mpi_sub_mpi( X, A, &B ) );
 c053b4e:	aa01      	add	r2, sp, #4
    B.n = 1;
 c053b50:	9302      	str	r3, [sp, #8]
    B.p = p;
 c053b52:	f8cd d00c 	str.w	sp, [sp, #12]
    return( mbedtls_mpi_sub_mpi( X, A, &B ) );
 c053b56:	f7ff ffb3 	bl	c053ac0 <mbedtls_mpi_sub_mpi>
}
 c053b5a:	b005      	add	sp, #20
 c053b5c:	f85d fb04 	ldr.w	pc, [sp], #4

0c053b60 <mbedtls_mpi_mul_mpi>:
{
 c053b60:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    X->n = 0;
 c053b64:	2300      	movs	r3, #0
{
 c053b66:	4617      	mov	r7, r2
    X->n = 0;
 c053b68:	2201      	movs	r2, #1
{
 c053b6a:	b086      	sub	sp, #24
    if( X == A ) { MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &TA, A ) ); A = &TA; }
 c053b6c:	4288      	cmp	r0, r1
{
 c053b6e:	4680      	mov	r8, r0
 c053b70:	460e      	mov	r6, r1
    X->n = 0;
 c053b72:	e9cd 2300 	strd	r2, r3, [sp]
    X->s = 1;
 c053b76:	e9cd 3202 	strd	r3, r2, [sp, #8]
    X->p = NULL;
 c053b7a:	e9cd 3304 	strd	r3, r3, [sp, #16]
    if( X == A ) { MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &TA, A ) ); A = &TA; }
 c053b7e:	d105      	bne.n	c053b8c <mbedtls_mpi_mul_mpi+0x2c>
 c053b80:	4668      	mov	r0, sp
 c053b82:	f7ff fc12 	bl	c0533aa <mbedtls_mpi_copy>
 c053b86:	4604      	mov	r4, r0
 c053b88:	bb50      	cbnz	r0, c053be0 <mbedtls_mpi_mul_mpi+0x80>
 c053b8a:	466e      	mov	r6, sp
    if( X == B ) { MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &TB, B ) ); B = &TB; }
 c053b8c:	45b8      	cmp	r8, r7
 c053b8e:	d106      	bne.n	c053b9e <mbedtls_mpi_mul_mpi+0x3e>
 c053b90:	4641      	mov	r1, r8
 c053b92:	a803      	add	r0, sp, #12
 c053b94:	f7ff fc09 	bl	c0533aa <mbedtls_mpi_copy>
 c053b98:	4604      	mov	r4, r0
 c053b9a:	bb08      	cbnz	r0, c053be0 <mbedtls_mpi_mul_mpi+0x80>
 c053b9c:	af03      	add	r7, sp, #12
    for( i = A->n; i > 0; i-- )
 c053b9e:	f8d6 a004 	ldr.w	sl, [r6, #4]
 c053ba2:	f1ba 0f00 	cmp.w	sl, #0
 c053ba6:	d125      	bne.n	c053bf4 <mbedtls_mpi_mul_mpi+0x94>
    for( j = B->n; j > 0; j-- )
 c053ba8:	687d      	ldr	r5, [r7, #4]
 c053baa:	bb6d      	cbnz	r5, c053c08 <mbedtls_mpi_mul_mpi+0xa8>
        result_is_zero = 1;
 c053bac:	f04f 0901 	mov.w	r9, #1
    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, i + j ) );
 c053bb0:	4640      	mov	r0, r8
 c053bb2:	eb0a 0105 	add.w	r1, sl, r5
 c053bb6:	f7ff fbb6 	bl	c053326 <mbedtls_mpi_grow>
 c053bba:	4604      	mov	r4, r0
 c053bbc:	b980      	cbnz	r0, c053be0 <mbedtls_mpi_mul_mpi+0x80>
    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( X, 0 ) );
 c053bbe:	4601      	mov	r1, r0
 c053bc0:	4640      	mov	r0, r8
 c053bc2:	f7ff fc3c 	bl	c05343e <mbedtls_mpi_lset>
 c053bc6:	4604      	mov	r4, r0
 c053bc8:	b950      	cbnz	r0, c053be0 <mbedtls_mpi_mul_mpi+0x80>
    for( ; j > 0; j-- )
 c053bca:	3d01      	subs	r5, #1
 c053bcc:	d224      	bcs.n	c053c18 <mbedtls_mpi_mul_mpi+0xb8>
    if( result_is_zero )
 c053bce:	f1b9 0f00 	cmp.w	r9, #0
 c053bd2:	d103      	bne.n	c053bdc <mbedtls_mpi_mul_mpi+0x7c>
        X->s = A->s * B->s;
 c053bd4:	6833      	ldr	r3, [r6, #0]
 c053bd6:	683a      	ldr	r2, [r7, #0]
 c053bd8:	fb02 f903 	mul.w	r9, r2, r3
 c053bdc:	f8c8 9000 	str.w	r9, [r8]
    mbedtls_mpi_free( &TB ); mbedtls_mpi_free( &TA );
 c053be0:	a803      	add	r0, sp, #12
 c053be2:	f7ff fb8e 	bl	c053302 <mbedtls_mpi_free>
 c053be6:	4668      	mov	r0, sp
 c053be8:	f7ff fb8b 	bl	c053302 <mbedtls_mpi_free>
}
 c053bec:	4620      	mov	r0, r4
 c053bee:	b006      	add	sp, #24
 c053bf0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        if( A->p[i - 1] != 0 )
 c053bf4:	68b3      	ldr	r3, [r6, #8]
 c053bf6:	eb03 038a 	add.w	r3, r3, sl, lsl #2
 c053bfa:	f853 3c04 	ldr.w	r3, [r3, #-4]
 c053bfe:	2b00      	cmp	r3, #0
 c053c00:	d1d2      	bne.n	c053ba8 <mbedtls_mpi_mul_mpi+0x48>
    for( i = A->n; i > 0; i-- )
 c053c02:	f10a 3aff 	add.w	sl, sl, #4294967295	@ 0xffffffff
 c053c06:	e7cc      	b.n	c053ba2 <mbedtls_mpi_mul_mpi+0x42>
        if( B->p[j - 1] != 0 )
 c053c08:	68bb      	ldr	r3, [r7, #8]
 c053c0a:	eb03 0385 	add.w	r3, r3, r5, lsl #2
 c053c0e:	f853 3c04 	ldr.w	r3, [r3, #-4]
 c053c12:	b96b      	cbnz	r3, c053c30 <mbedtls_mpi_mul_mpi+0xd0>
    for( j = B->n; j > 0; j-- )
 c053c14:	3d01      	subs	r5, #1
 c053c16:	e7c8      	b.n	c053baa <mbedtls_mpi_mul_mpi+0x4a>
        mpi_mul_hlp( i, A->p, X->p + j - 1, B->p[j - 1] );
 c053c18:	68bb      	ldr	r3, [r7, #8]
 c053c1a:	f8d8 2008 	ldr.w	r2, [r8, #8]
 c053c1e:	4650      	mov	r0, sl
 c053c20:	f853 3025 	ldr.w	r3, [r3, r5, lsl #2]
 c053c24:	68b1      	ldr	r1, [r6, #8]
 c053c26:	eb02 0285 	add.w	r2, r2, r5, lsl #2
 c053c2a:	f7ff f914 	bl	c052e56 <mpi_mul_hlp>
 c053c2e:	e7cc      	b.n	c053bca <mbedtls_mpi_mul_mpi+0x6a>
    if( i == 0 )
 c053c30:	faba f98a 	clz	r9, sl
 c053c34:	ea4f 1959 	mov.w	r9, r9, lsr #5
 c053c38:	e7ba      	b.n	c053bb0 <mbedtls_mpi_mul_mpi+0x50>

0c053c3a <mbedtls_mpi_mul_int>:
{
 c053c3a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 c053c3e:	4605      	mov	r5, r0
 c053c40:	460f      	mov	r7, r1
 c053c42:	4690      	mov	r8, r2
    size_t n = A->n;
 c053c44:	684e      	ldr	r6, [r1, #4]
    while( n > 0 && A->p[n - 1] == 0 )
 c053c46:	b146      	cbz	r6, c053c5a <mbedtls_mpi_mul_int+0x20>
 c053c48:	68bb      	ldr	r3, [r7, #8]
 c053c4a:	eb03 0386 	add.w	r3, r3, r6, lsl #2
 c053c4e:	f853 3c04 	ldr.w	r3, [r3, #-4]
 c053c52:	b143      	cbz	r3, c053c66 <mbedtls_mpi_mul_int+0x2c>
    if( b == 0 || n == 0 )
 c053c54:	f1b8 0f00 	cmp.w	r8, #0
 c053c58:	d107      	bne.n	c053c6a <mbedtls_mpi_mul_int+0x30>
        return( mbedtls_mpi_lset( X, 0 ) );
 c053c5a:	4628      	mov	r0, r5
}
 c053c5c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
        return( mbedtls_mpi_lset( X, 0 ) );
 c053c60:	2100      	movs	r1, #0
 c053c62:	f7ff bbec 	b.w	c05343e <mbedtls_mpi_lset>
        --n;
 c053c66:	3e01      	subs	r6, #1
 c053c68:	e7ed      	b.n	c053c46 <mbedtls_mpi_mul_int+0xc>
    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, n + 1 ) );
 c053c6a:	4628      	mov	r0, r5
 c053c6c:	1c71      	adds	r1, r6, #1
 c053c6e:	f7ff fb5a 	bl	c053326 <mbedtls_mpi_grow>
 c053c72:	4604      	mov	r4, r0
 c053c74:	b960      	cbnz	r0, c053c90 <mbedtls_mpi_mul_int+0x56>
    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( X, A ) );
 c053c76:	4639      	mov	r1, r7
 c053c78:	4628      	mov	r0, r5
 c053c7a:	f7ff fb96 	bl	c0533aa <mbedtls_mpi_copy>
 c053c7e:	4604      	mov	r4, r0
 c053c80:	b930      	cbnz	r0, c053c90 <mbedtls_mpi_mul_int+0x56>
    mpi_mul_hlp( n, A->p, X->p, b - 1 );
 c053c82:	4630      	mov	r0, r6
 c053c84:	68aa      	ldr	r2, [r5, #8]
 c053c86:	68b9      	ldr	r1, [r7, #8]
 c053c88:	f108 33ff 	add.w	r3, r8, #4294967295	@ 0xffffffff
 c053c8c:	f7ff f8e3 	bl	c052e56 <mpi_mul_hlp>
}
 c053c90:	4620      	mov	r0, r4
 c053c92:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0c053c96 <mbedtls_mpi_read_string>:
{
 c053c96:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    if( radix < 2 || radix > 16 )
 c053c9a:	1e8b      	subs	r3, r1, #2
 c053c9c:	2b0e      	cmp	r3, #14
{
 c053c9e:	4606      	mov	r6, r0
 c053ca0:	4688      	mov	r8, r1
 c053ca2:	4615      	mov	r5, r2
 c053ca4:	b085      	sub	sp, #20
    if( radix < 2 || radix > 16 )
 c053ca6:	d905      	bls.n	c053cb4 <mbedtls_mpi_read_string+0x1e>
        return( MBEDTLS_ERR_MPI_BAD_INPUT_DATA );
 c053ca8:	f06f 0403 	mvn.w	r4, #3
}
 c053cac:	4620      	mov	r0, r4
 c053cae:	b005      	add	sp, #20
 c053cb0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    X->n = 0;
 c053cb4:	2200      	movs	r2, #0
 c053cb6:	2301      	movs	r3, #1
    if( s[0] == 0 )
 c053cb8:	782c      	ldrb	r4, [r5, #0]
    X->n = 0;
 c053cba:	e9cd 3201 	strd	r3, r2, [sp, #4]
    X->p = NULL;
 c053cbe:	9203      	str	r2, [sp, #12]
    if( s[0] == 0 )
 c053cc0:	b914      	cbnz	r4, c053cc8 <mbedtls_mpi_read_string+0x32>
    mbedtls_mpi_free( &T );
 c053cc2:	f7ff fb1e 	bl	c053302 <mbedtls_mpi_free>
    return( ret );
 c053cc6:	e7f1      	b.n	c053cac <mbedtls_mpi_read_string+0x16>
    if( s[0] == '-' )
 c053cc8:	2c2d      	cmp	r4, #45	@ 0x2d
        ++s;
 c053cca:	bf08      	it	eq
 c053ccc:	3501      	addeq	r5, #1
    slen = strlen( s );
 c053cce:	4628      	mov	r0, r5
        sign = -1;
 c053cd0:	bf0c      	ite	eq
 c053cd2:	f04f 39ff 	moveq.w	r9, #4294967295	@ 0xffffffff
    int sign = 1;
 c053cd6:	4699      	movne	r9, r3
    slen = strlen( s );
 c053cd8:	f7ee fce1 	bl	c04269e <strlen>
    if( radix == 16 )
 c053cdc:	f1b8 0f10 	cmp.w	r8, #16
    slen = strlen( s );
 c053ce0:	4607      	mov	r7, r0
    if( radix == 16 )
 c053ce2:	d140      	bne.n	c053d66 <mbedtls_mpi_read_string+0xd0>
        if( slen > MPI_SIZE_T_MAX >> 2 )
 c053ce4:	f1b0 4f80 	cmp.w	r0, #1073741824	@ 0x40000000
 c053ce8:	d2de      	bcs.n	c053ca8 <mbedtls_mpi_read_string+0x12>
        n = BITS_TO_LIMBS( slen << 2 );
 c053cea:	0083      	lsls	r3, r0, #2
 c053cec:	f013 0f1c 	tst.w	r3, #28
 c053cf0:	bf14      	ite	ne
 c053cf2:	2101      	movne	r1, #1
 c053cf4:	2100      	moveq	r1, #0
        MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, n ) );
 c053cf6:	4630      	mov	r0, r6
 c053cf8:	eb01 1153 	add.w	r1, r1, r3, lsr #5
 c053cfc:	f7ff fb13 	bl	c053326 <mbedtls_mpi_grow>
 c053d00:	4604      	mov	r4, r0
 c053d02:	2800      	cmp	r0, #0
 c053d04:	d14f      	bne.n	c053da6 <mbedtls_mpi_read_string+0x110>
        MBEDTLS_MPI_CHK( mbedtls_mpi_lset( X, 0 ) );
 c053d06:	4601      	mov	r1, r0
 c053d08:	4630      	mov	r0, r6
 c053d0a:	f7ff fb98 	bl	c05343e <mbedtls_mpi_lset>
 c053d0e:	4604      	mov	r4, r0
 c053d10:	2800      	cmp	r0, #0
 c053d12:	d148      	bne.n	c053da6 <mbedtls_mpi_read_string+0x110>
        for( i = slen, j = 0; i > 0; i--, j++ )
 c053d14:	4680      	mov	r8, r0
 c053d16:	443d      	add	r5, r7
 c053d18:	45b8      	cmp	r8, r7
 c053d1a:	d10a      	bne.n	c053d32 <mbedtls_mpi_read_string+0x9c>
    if( sign < 0 && mbedtls_mpi_bitlen( X ) != 0 )
 c053d1c:	f1b9 3fff 	cmp.w	r9, #4294967295	@ 0xffffffff
 c053d20:	d105      	bne.n	c053d2e <mbedtls_mpi_read_string+0x98>
 c053d22:	4630      	mov	r0, r6
 c053d24:	f7ff fbfb 	bl	c05351e <mbedtls_mpi_bitlen>
 c053d28:	b108      	cbz	r0, c053d2e <mbedtls_mpi_read_string+0x98>
        X->s = -1;
 c053d2a:	f8c6 9000 	str.w	r9, [r6]
        for( i = slen, j = 0; i > 0; i--, j++ )
 c053d2e:	2400      	movs	r4, #0
 c053d30:	e039      	b.n	c053da6 <mbedtls_mpi_read_string+0x110>
            MBEDTLS_MPI_CHK( mpi_get_digit( &d, radix, s[i - 1] ) );
 c053d32:	2110      	movs	r1, #16
 c053d34:	4668      	mov	r0, sp
 c053d36:	f815 2d01 	ldrb.w	r2, [r5, #-1]!
 c053d3a:	f7ff f871 	bl	c052e20 <mpi_get_digit>
 c053d3e:	4604      	mov	r4, r0
 c053d40:	bb88      	cbnz	r0, c053da6 <mbedtls_mpi_read_string+0x110>
            X->p[j / ( 2 * ciL )] |= d << ( ( j % ( 2 * ciL ) ) << 2 );
 c053d42:	68b1      	ldr	r1, [r6, #8]
 c053d44:	9b00      	ldr	r3, [sp, #0]
 c053d46:	ea4f 0288 	mov.w	r2, r8, lsl #2
 c053d4a:	ea4f 00d8 	mov.w	r0, r8, lsr #3
 c053d4e:	f002 021c 	and.w	r2, r2, #28
 c053d52:	fa03 f202 	lsl.w	r2, r3, r2
 c053d56:	f851 3020 	ldr.w	r3, [r1, r0, lsl #2]
        for( i = slen, j = 0; i > 0; i--, j++ )
 c053d5a:	f108 0801 	add.w	r8, r8, #1
            X->p[j / ( 2 * ciL )] |= d << ( ( j % ( 2 * ciL ) ) << 2 );
 c053d5e:	4313      	orrs	r3, r2
 c053d60:	f841 3020 	str.w	r3, [r1, r0, lsl #2]
        for( i = slen, j = 0; i > 0; i--, j++ )
 c053d64:	e7d8      	b.n	c053d18 <mbedtls_mpi_read_string+0x82>
        MBEDTLS_MPI_CHK( mbedtls_mpi_lset( X, 0 ) );
 c053d66:	2100      	movs	r1, #0
 c053d68:	4630      	mov	r0, r6
 c053d6a:	f7ff fb68 	bl	c05343e <mbedtls_mpi_lset>
 c053d6e:	4604      	mov	r4, r0
 c053d70:	b9c8      	cbnz	r0, c053da6 <mbedtls_mpi_read_string+0x110>
 c053d72:	442f      	add	r7, r5
        for( i = 0; i < slen; i++ )
 c053d74:	42af      	cmp	r7, r5
 c053d76:	d0d1      	beq.n	c053d1c <mbedtls_mpi_read_string+0x86>
            MBEDTLS_MPI_CHK( mpi_get_digit( &d, radix, s[i] ) );
 c053d78:	4641      	mov	r1, r8
 c053d7a:	4668      	mov	r0, sp
 c053d7c:	f815 2b01 	ldrb.w	r2, [r5], #1
 c053d80:	f7ff f84e 	bl	c052e20 <mpi_get_digit>
 c053d84:	4604      	mov	r4, r0
 c053d86:	b970      	cbnz	r0, c053da6 <mbedtls_mpi_read_string+0x110>
            MBEDTLS_MPI_CHK( mbedtls_mpi_mul_int( &T, X, radix ) );
 c053d88:	4642      	mov	r2, r8
 c053d8a:	4631      	mov	r1, r6
 c053d8c:	a801      	add	r0, sp, #4
 c053d8e:	f7ff ff54 	bl	c053c3a <mbedtls_mpi_mul_int>
 c053d92:	4604      	mov	r4, r0
 c053d94:	b938      	cbnz	r0, c053da6 <mbedtls_mpi_read_string+0x110>
            MBEDTLS_MPI_CHK( mbedtls_mpi_add_int( X, &T, d ) );
 c053d96:	4630      	mov	r0, r6
 c053d98:	9a00      	ldr	r2, [sp, #0]
 c053d9a:	a901      	add	r1, sp, #4
 c053d9c:	f7ff feb4 	bl	c053b08 <mbedtls_mpi_add_int>
 c053da0:	4604      	mov	r4, r0
 c053da2:	2800      	cmp	r0, #0
 c053da4:	d0e6      	beq.n	c053d74 <mbedtls_mpi_read_string+0xde>
    mbedtls_mpi_free( &T );
 c053da6:	a801      	add	r0, sp, #4
 c053da8:	e78b      	b.n	c053cc2 <mbedtls_mpi_read_string+0x2c>

0c053daa <mbedtls_mpi_div_mpi>:
{
 c053daa:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c053dae:	4683      	mov	fp, r0
 c053db0:	b09d      	sub	sp, #116	@ 0x74
 c053db2:	460f      	mov	r7, r1
    if( mbedtls_mpi_cmp_int( B, 0 ) == 0 )
 c053db4:	4618      	mov	r0, r3
 c053db6:	2100      	movs	r1, #0
{
 c053db8:	4616      	mov	r6, r2
 c053dba:	9303      	str	r3, [sp, #12]
    if( mbedtls_mpi_cmp_int( B, 0 ) == 0 )
 c053dbc:	f7ff fd81 	bl	c0538c2 <mbedtls_mpi_cmp_int>
 c053dc0:	2800      	cmp	r0, #0
 c053dc2:	f000 8187 	beq.w	c0540d4 <mbedtls_mpi_div_mpi+0x32a>
    T2.n = sizeof( TP2 ) / sizeof( *TP2 );
 c053dc6:	2303      	movs	r3, #3
    X->n = 0;
 c053dc8:	2400      	movs	r4, #0
 c053dca:	2501      	movs	r5, #1
    T2.n = sizeof( TP2 ) / sizeof( *TP2 );
 c053dcc:	9317      	str	r3, [sp, #92]	@ 0x5c
    if( mbedtls_mpi_cmp_abs( A, B ) < 0 )
 c053dce:	4630      	mov	r0, r6
    T2.p = TP2;
 c053dd0:	ab19      	add	r3, sp, #100	@ 0x64
    if( mbedtls_mpi_cmp_abs( A, B ) < 0 )
 c053dd2:	9903      	ldr	r1, [sp, #12]
    X->n = 0;
 c053dd4:	e9cd 540a 	strd	r5, r4, [sp, #40]	@ 0x28
    X->s = 1;
 c053dd8:	e9cd 450c 	strd	r4, r5, [sp, #48]	@ 0x30
    X->p = NULL;
 c053ddc:	e9cd 440e 	strd	r4, r4, [sp, #56]	@ 0x38
    X->n = 0;
 c053de0:	e9cd 5410 	strd	r5, r4, [sp, #64]	@ 0x40
    X->s = 1;
 c053de4:	e9cd 4512 	strd	r4, r5, [sp, #72]	@ 0x48
    X->p = NULL;
 c053de8:	e9cd 4414 	strd	r4, r4, [sp, #80]	@ 0x50
    T2.s = 1;
 c053dec:	9516      	str	r5, [sp, #88]	@ 0x58
    T2.p = TP2;
 c053dee:	9318      	str	r3, [sp, #96]	@ 0x60
    if( mbedtls_mpi_cmp_abs( A, B ) < 0 )
 c053df0:	f7ff fcf1 	bl	c0537d6 <mbedtls_mpi_cmp_abs>
 c053df4:	42a0      	cmp	r0, r4
 c053df6:	da28      	bge.n	c053e4a <mbedtls_mpi_div_mpi+0xa0>
        if( Q != NULL ) MBEDTLS_MPI_CHK( mbedtls_mpi_lset( Q, 0 ) );
 c053df8:	f1bb 0f00 	cmp.w	fp, #0
 c053dfc:	d105      	bne.n	c053e0a <mbedtls_mpi_div_mpi+0x60>
        if( R != NULL ) MBEDTLS_MPI_CHK( mbedtls_mpi_copy( R, A ) );
 c053dfe:	b9e7      	cbnz	r7, c053e3a <mbedtls_mpi_div_mpi+0x90>
        return( 0 );
 c053e00:	2400      	movs	r4, #0
}
 c053e02:	4620      	mov	r0, r4
 c053e04:	b01d      	add	sp, #116	@ 0x74
 c053e06:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if( Q != NULL ) MBEDTLS_MPI_CHK( mbedtls_mpi_lset( Q, 0 ) );
 c053e0a:	4621      	mov	r1, r4
 c053e0c:	4658      	mov	r0, fp
 c053e0e:	f7ff fb16 	bl	c05343e <mbedtls_mpi_lset>
 c053e12:	4604      	mov	r4, r0
 c053e14:	2800      	cmp	r0, #0
 c053e16:	d0f2      	beq.n	c053dfe <mbedtls_mpi_div_mpi+0x54>
    mbedtls_mpi_free( &X ); mbedtls_mpi_free( &Y ); mbedtls_mpi_free( &Z );
 c053e18:	a80a      	add	r0, sp, #40	@ 0x28
 c053e1a:	f7ff fa72 	bl	c053302 <mbedtls_mpi_free>
 c053e1e:	a80d      	add	r0, sp, #52	@ 0x34
 c053e20:	f7ff fa6f 	bl	c053302 <mbedtls_mpi_free>
 c053e24:	a810      	add	r0, sp, #64	@ 0x40
 c053e26:	f7ff fa6c 	bl	c053302 <mbedtls_mpi_free>
    mbedtls_mpi_free( &T1 );
 c053e2a:	a813      	add	r0, sp, #76	@ 0x4c
 c053e2c:	f7ff fa69 	bl	c053302 <mbedtls_mpi_free>
    mbedtls_platform_zeroize( TP2, sizeof( TP2 ) );
 c053e30:	210c      	movs	r1, #12
 c053e32:	a819      	add	r0, sp, #100	@ 0x64
 c053e34:	f7e7 facc 	bl	c03b3d0 <mbedtls_platform_zeroize>
    return( ret );
 c053e38:	e7e3      	b.n	c053e02 <mbedtls_mpi_div_mpi+0x58>
        if( R != NULL ) MBEDTLS_MPI_CHK( mbedtls_mpi_copy( R, A ) );
 c053e3a:	4631      	mov	r1, r6
 c053e3c:	4638      	mov	r0, r7
 c053e3e:	f7ff fab4 	bl	c0533aa <mbedtls_mpi_copy>
 c053e42:	4604      	mov	r4, r0
 c053e44:	2800      	cmp	r0, #0
 c053e46:	d1e7      	bne.n	c053e18 <mbedtls_mpi_div_mpi+0x6e>
 c053e48:	e7da      	b.n	c053e00 <mbedtls_mpi_div_mpi+0x56>
    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &X, A ) );
 c053e4a:	4631      	mov	r1, r6
 c053e4c:	a80a      	add	r0, sp, #40	@ 0x28
 c053e4e:	f7ff faac 	bl	c0533aa <mbedtls_mpi_copy>
 c053e52:	4604      	mov	r4, r0
 c053e54:	2800      	cmp	r0, #0
 c053e56:	d1df      	bne.n	c053e18 <mbedtls_mpi_div_mpi+0x6e>
    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &Y, B ) );
 c053e58:	9903      	ldr	r1, [sp, #12]
 c053e5a:	a80d      	add	r0, sp, #52	@ 0x34
 c053e5c:	f7ff faa5 	bl	c0533aa <mbedtls_mpi_copy>
 c053e60:	4604      	mov	r4, r0
 c053e62:	2800      	cmp	r0, #0
 c053e64:	d1d8      	bne.n	c053e18 <mbedtls_mpi_div_mpi+0x6e>
    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( &Z, A->n + 2 ) );
 c053e66:	6871      	ldr	r1, [r6, #4]
 c053e68:	a810      	add	r0, sp, #64	@ 0x40
 c053e6a:	3102      	adds	r1, #2
    X.s = Y.s = 1;
 c053e6c:	950d      	str	r5, [sp, #52]	@ 0x34
 c053e6e:	950a      	str	r5, [sp, #40]	@ 0x28
    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( &Z, A->n + 2 ) );
 c053e70:	f7ff fa59 	bl	c053326 <mbedtls_mpi_grow>
 c053e74:	4604      	mov	r4, r0
 c053e76:	2800      	cmp	r0, #0
 c053e78:	d1ce      	bne.n	c053e18 <mbedtls_mpi_div_mpi+0x6e>
    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &Z,  0 ) );
 c053e7a:	4601      	mov	r1, r0
 c053e7c:	a810      	add	r0, sp, #64	@ 0x40
 c053e7e:	f7ff fade 	bl	c05343e <mbedtls_mpi_lset>
 c053e82:	4604      	mov	r4, r0
 c053e84:	2800      	cmp	r0, #0
 c053e86:	d1c7      	bne.n	c053e18 <mbedtls_mpi_div_mpi+0x6e>
    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( &T1, A->n + 2 ) );
 c053e88:	6871      	ldr	r1, [r6, #4]
 c053e8a:	a813      	add	r0, sp, #76	@ 0x4c
 c053e8c:	3102      	adds	r1, #2
 c053e8e:	f7ff fa4a 	bl	c053326 <mbedtls_mpi_grow>
 c053e92:	4604      	mov	r4, r0
 c053e94:	2800      	cmp	r0, #0
 c053e96:	d1bf      	bne.n	c053e18 <mbedtls_mpi_div_mpi+0x6e>
    k = mbedtls_mpi_bitlen( &Y ) % biL;
 c053e98:	a80d      	add	r0, sp, #52	@ 0x34
 c053e9a:	f7ff fb40 	bl	c05351e <mbedtls_mpi_bitlen>
 c053e9e:	f000 001f 	and.w	r0, r0, #31
    if( k < biL - 1 )
 c053ea2:	281f      	cmp	r0, #31
 c053ea4:	d070      	beq.n	c053f88 <mbedtls_mpi_div_mpi+0x1de>
        k = biL - 1 - k;
 c053ea6:	f1c0 031f 	rsb	r3, r0, #31
        MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &X, k ) );
 c053eaa:	4619      	mov	r1, r3
 c053eac:	a80a      	add	r0, sp, #40	@ 0x28
        k = biL - 1 - k;
 c053eae:	9301      	str	r3, [sp, #4]
        MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &X, k ) );
 c053eb0:	f7ff fc07 	bl	c0536c2 <mbedtls_mpi_shift_l>
 c053eb4:	4604      	mov	r4, r0
 c053eb6:	2800      	cmp	r0, #0
 c053eb8:	d1ae      	bne.n	c053e18 <mbedtls_mpi_div_mpi+0x6e>
        MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &Y, k ) );
 c053eba:	9901      	ldr	r1, [sp, #4]
 c053ebc:	a80d      	add	r0, sp, #52	@ 0x34
 c053ebe:	f7ff fc00 	bl	c0536c2 <mbedtls_mpi_shift_l>
 c053ec2:	4604      	mov	r4, r0
 c053ec4:	2800      	cmp	r0, #0
 c053ec6:	d1a7      	bne.n	c053e18 <mbedtls_mpi_div_mpi+0x6e>
    n = X.n - 1;
 c053ec8:	9d0b      	ldr	r5, [sp, #44]	@ 0x2c
    t = Y.n - 1;
 c053eca:	f8dd 8038 	ldr.w	r8, [sp, #56]	@ 0x38
    MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &Y, biL * ( n - t ) ) );
 c053ece:	a80d      	add	r0, sp, #52	@ 0x34
 c053ed0:	eba5 0a08 	sub.w	sl, r5, r8
 c053ed4:	ea4f 194a 	mov.w	r9, sl, lsl #5
 c053ed8:	4649      	mov	r1, r9
 c053eda:	f7ff fbf2 	bl	c0536c2 <mbedtls_mpi_shift_l>
 c053ede:	4604      	mov	r4, r0
 c053ee0:	2800      	cmp	r0, #0
 c053ee2:	d199      	bne.n	c053e18 <mbedtls_mpi_div_mpi+0x6e>
        Z.p[n - t]++;
 c053ee4:	ea4f 0a8a 	mov.w	sl, sl, lsl #2
    while( mbedtls_mpi_cmp_mpi( &X, &Y ) >= 0 )
 c053ee8:	a90d      	add	r1, sp, #52	@ 0x34
 c053eea:	a80a      	add	r0, sp, #40	@ 0x28
 c053eec:	f7ff fca6 	bl	c05383c <mbedtls_mpi_cmp_mpi>
 c053ef0:	2800      	cmp	r0, #0
 c053ef2:	da4b      	bge.n	c053f8c <mbedtls_mpi_div_mpi+0x1e2>
    MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &Y, biL * ( n - t ) ) );
 c053ef4:	4649      	mov	r1, r9
 c053ef6:	a80d      	add	r0, sp, #52	@ 0x34
 c053ef8:	f7ff fc33 	bl	c053762 <mbedtls_mpi_shift_r>
 c053efc:	4604      	mov	r4, r0
 c053efe:	2800      	cmp	r0, #0
 c053f00:	d18a      	bne.n	c053e18 <mbedtls_mpi_div_mpi+0x6e>
    t = Y.n - 1;
 c053f02:	f108 33ff 	add.w	r3, r8, #4294967295	@ 0xffffffff
 c053f06:	9305      	str	r3, [sp, #20]
        if( X.p[i] >= Y.p[t] )
 c053f08:	009b      	lsls	r3, r3, #2
    n = X.n - 1;
 c053f0a:	f105 3aff 	add.w	sl, r5, #4294967295	@ 0xffffffff
        if( X.p[i] >= Y.p[t] )
 c053f0e:	9306      	str	r3, [sp, #24]
 c053f10:	f105 4580 	add.w	r5, r5, #1073741824	@ 0x40000000
            T1.p[0] = ( t < 1 ) ? 0 : Y.p[t - 1];
 c053f14:	f108 4380 	add.w	r3, r8, #1073741824	@ 0x40000000
 c053f18:	3b02      	subs	r3, #2
 c053f1a:	3d01      	subs	r5, #1
 c053f1c:	009b      	lsls	r3, r3, #2
 c053f1e:	eba5 0508 	sub.w	r5, r5, r8
 c053f22:	9308      	str	r3, [sp, #32]
 c053f24:	00ab      	lsls	r3, r5, #2
 c053f26:	9302      	str	r3, [sp, #8]
    for( i = n; i > t ; i-- )
 c053f28:	9b05      	ldr	r3, [sp, #20]
 c053f2a:	459a      	cmp	sl, r3
 c053f2c:	d83d      	bhi.n	c053faa <mbedtls_mpi_div_mpi+0x200>
    if( Q != NULL )
 c053f2e:	f1bb 0f00 	cmp.w	fp, #0
 c053f32:	d00c      	beq.n	c053f4e <mbedtls_mpi_div_mpi+0x1a4>
        MBEDTLS_MPI_CHK( mbedtls_mpi_copy( Q, &Z ) );
 c053f34:	4658      	mov	r0, fp
 c053f36:	a910      	add	r1, sp, #64	@ 0x40
 c053f38:	f7ff fa37 	bl	c0533aa <mbedtls_mpi_copy>
 c053f3c:	2800      	cmp	r0, #0
 c053f3e:	f040 80c5 	bne.w	c0540cc <mbedtls_mpi_div_mpi+0x322>
        Q->s = A->s * B->s;
 c053f42:	9a03      	ldr	r2, [sp, #12]
 c053f44:	6833      	ldr	r3, [r6, #0]
 c053f46:	6812      	ldr	r2, [r2, #0]
 c053f48:	4353      	muls	r3, r2
 c053f4a:	f8cb 3000 	str.w	r3, [fp]
    if( R != NULL )
 c053f4e:	2f00      	cmp	r7, #0
 c053f50:	f43f af62 	beq.w	c053e18 <mbedtls_mpi_div_mpi+0x6e>
        MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &X, k ) );
 c053f54:	9901      	ldr	r1, [sp, #4]
 c053f56:	a80a      	add	r0, sp, #40	@ 0x28
 c053f58:	f7ff fc03 	bl	c053762 <mbedtls_mpi_shift_r>
 c053f5c:	2800      	cmp	r0, #0
 c053f5e:	f040 80b5 	bne.w	c0540cc <mbedtls_mpi_div_mpi+0x322>
        X.s = A->s;
 c053f62:	6833      	ldr	r3, [r6, #0]
        MBEDTLS_MPI_CHK( mbedtls_mpi_copy( R, &X ) );
 c053f64:	a90a      	add	r1, sp, #40	@ 0x28
 c053f66:	4638      	mov	r0, r7
        X.s = A->s;
 c053f68:	930a      	str	r3, [sp, #40]	@ 0x28
        MBEDTLS_MPI_CHK( mbedtls_mpi_copy( R, &X ) );
 c053f6a:	f7ff fa1e 	bl	c0533aa <mbedtls_mpi_copy>
 c053f6e:	4601      	mov	r1, r0
 c053f70:	2800      	cmp	r0, #0
 c053f72:	f040 80ad 	bne.w	c0540d0 <mbedtls_mpi_div_mpi+0x326>
        if( mbedtls_mpi_cmp_int( R, 0 ) == 0 )
 c053f76:	4638      	mov	r0, r7
 c053f78:	f7ff fca3 	bl	c0538c2 <mbedtls_mpi_cmp_int>
 c053f7c:	2800      	cmp	r0, #0
 c053f7e:	f47f af4b 	bne.w	c053e18 <mbedtls_mpi_div_mpi+0x6e>
            R->s = 1;
 c053f82:	2301      	movs	r3, #1
 c053f84:	603b      	str	r3, [r7, #0]
 c053f86:	e747      	b.n	c053e18 <mbedtls_mpi_div_mpi+0x6e>
    else k = 0;
 c053f88:	9401      	str	r4, [sp, #4]
 c053f8a:	e79d      	b.n	c053ec8 <mbedtls_mpi_div_mpi+0x11e>
        Z.p[n - t]++;
 c053f8c:	9a12      	ldr	r2, [sp, #72]	@ 0x48
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &X, &X, &Y ) );
 c053f8e:	a90a      	add	r1, sp, #40	@ 0x28
        Z.p[n - t]++;
 c053f90:	f852 300a 	ldr.w	r3, [r2, sl]
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &X, &X, &Y ) );
 c053f94:	4608      	mov	r0, r1
        Z.p[n - t]++;
 c053f96:	3301      	adds	r3, #1
 c053f98:	f842 300a 	str.w	r3, [r2, sl]
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &X, &X, &Y ) );
 c053f9c:	aa0d      	add	r2, sp, #52	@ 0x34
 c053f9e:	f7ff fd8f 	bl	c053ac0 <mbedtls_mpi_sub_mpi>
 c053fa2:	4604      	mov	r4, r0
 c053fa4:	2800      	cmp	r0, #0
 c053fa6:	d09f      	beq.n	c053ee8 <mbedtls_mpi_div_mpi+0x13e>
 c053fa8:	e736      	b.n	c053e18 <mbedtls_mpi_div_mpi+0x6e>
        if( X.p[i] >= Y.p[t] )
 c053faa:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
 c053fac:	9a06      	ldr	r2, [sp, #24]
 c053fae:	9304      	str	r3, [sp, #16]
 c053fb0:	4413      	add	r3, r2
 c053fb2:	f8dd 9030 	ldr.w	r9, [sp, #48]	@ 0x30
 c053fb6:	9307      	str	r3, [sp, #28]
 c053fb8:	9b04      	ldr	r3, [sp, #16]
 c053fba:	ea4f 088a 	mov.w	r8, sl, lsl #2
 c053fbe:	589a      	ldr	r2, [r3, r2]
 c053fc0:	f859 102a 	ldr.w	r1, [r9, sl, lsl #2]
            Z.p[i - t - 1] = mbedtls_int_div_int( X.p[i], X.p[i - 1],
 c053fc4:	f1a8 0304 	sub.w	r3, r8, #4
            Z.p[i - t - 1] = ~0;
 c053fc8:	9d12      	ldr	r5, [sp, #72]	@ 0x48
            Z.p[i - t - 1] = mbedtls_int_div_int( X.p[i], X.p[i - 1],
 c053fca:	9309      	str	r3, [sp, #36]	@ 0x24
            Z.p[i - t - 1] = ~0;
 c053fcc:	9b02      	ldr	r3, [sp, #8]
        if( X.p[i] >= Y.p[t] )
 c053fce:	4291      	cmp	r1, r2
            Z.p[i - t - 1] = ~0;
 c053fd0:	441d      	add	r5, r3
        if( X.p[i] >= Y.p[t] )
 c053fd2:	d276      	bcs.n	c0540c2 <mbedtls_mpi_div_mpi+0x318>
    quotient = dividend / d;
 c053fd4:	f1a8 0004 	sub.w	r0, r8, #4
 c053fd8:	2300      	movs	r3, #0
 c053fda:	f859 0000 	ldr.w	r0, [r9, r0]
 c053fde:	f7ef fce9 	bl	c0439b4 <__aeabi_uldivmod>
    if( quotient > ( (mbedtls_t_udbl) 1 << biL ) - 1 )
 c053fe2:	2900      	cmp	r1, #0
 c053fe4:	bf14      	ite	ne
 c053fe6:	f04f 33ff 	movne.w	r3, #4294967295	@ 0xffffffff
 c053fea:	4603      	moveq	r3, r0
        T2.p[0] = ( i < 2 ) ? 0 : X.p[i - 2];
 c053fec:	f1ba 0f01 	cmp.w	sl, #1
            Z.p[i - t - 1] = ~0;
 c053ff0:	602b      	str	r3, [r5, #0]
        T2.p[0] = ( i < 2 ) ? 0 : X.p[i - 2];
 c053ff2:	bf0e      	itee	eq
 c053ff4:	2300      	moveq	r3, #0
 c053ff6:	eb09 0308 	addne.w	r3, r9, r8
 c053ffa:	f853 3c08 	ldrne.w	r3, [r3, #-8]
 c053ffe:	9319      	str	r3, [sp, #100]	@ 0x64
        T2.p[1] = ( i < 1 ) ? 0 : X.p[i - 1];
 c054000:	f1a8 0304 	sub.w	r3, r8, #4
 c054004:	f859 3003 	ldr.w	r3, [r9, r3]
 c054008:	931a      	str	r3, [sp, #104]	@ 0x68
        T2.p[2] = X.p[i];
 c05400a:	f859 3008 	ldr.w	r3, [r9, r8]
            T1.p[0] = ( t < 1 ) ? 0 : Y.p[t - 1];
 c05400e:	f8dd 8010 	ldr.w	r8, [sp, #16]
        T2.p[2] = X.p[i];
 c054012:	931b      	str	r3, [sp, #108]	@ 0x6c
        Z.p[i - t - 1]++;
 c054014:	682b      	ldr	r3, [r5, #0]
 c054016:	3301      	adds	r3, #1
 c054018:	602b      	str	r3, [r5, #0]
            T1.p[0] = ( t < 1 ) ? 0 : Y.p[t - 1];
 c05401a:	9b08      	ldr	r3, [sp, #32]
 c05401c:	4498      	add	r8, r3
            Z.p[i - t - 1]--;
 c05401e:	682b      	ldr	r3, [r5, #0]
            MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &T1, 0 ) );
 c054020:	2100      	movs	r1, #0
            Z.p[i - t - 1]--;
 c054022:	3b01      	subs	r3, #1
 c054024:	602b      	str	r3, [r5, #0]
            MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &T1, 0 ) );
 c054026:	a813      	add	r0, sp, #76	@ 0x4c
 c054028:	f7ff fa09 	bl	c05343e <mbedtls_mpi_lset>
 c05402c:	2800      	cmp	r0, #0
 c05402e:	d14d      	bne.n	c0540cc <mbedtls_mpi_div_mpi+0x322>
            T1.p[0] = ( t < 1 ) ? 0 : Y.p[t - 1];
 c054030:	9b05      	ldr	r3, [sp, #20]
 c054032:	2b00      	cmp	r3, #0
 c054034:	d048      	beq.n	c0540c8 <mbedtls_mpi_div_mpi+0x31e>
 c054036:	f8d8 2000 	ldr.w	r2, [r8]
 c05403a:	9b15      	ldr	r3, [sp, #84]	@ 0x54
            MBEDTLS_MPI_CHK( mbedtls_mpi_mul_int( &T1, &T1, Z.p[i - t - 1] ) );
 c05403c:	a913      	add	r1, sp, #76	@ 0x4c
            T1.p[0] = ( t < 1 ) ? 0 : Y.p[t - 1];
 c05403e:	601a      	str	r2, [r3, #0]
            T1.p[1] = Y.p[t];
 c054040:	9a07      	ldr	r2, [sp, #28]
            MBEDTLS_MPI_CHK( mbedtls_mpi_mul_int( &T1, &T1, Z.p[i - t - 1] ) );
 c054042:	4608      	mov	r0, r1
            T1.p[1] = Y.p[t];
 c054044:	6812      	ldr	r2, [r2, #0]
 c054046:	605a      	str	r2, [r3, #4]
            MBEDTLS_MPI_CHK( mbedtls_mpi_mul_int( &T1, &T1, Z.p[i - t - 1] ) );
 c054048:	682a      	ldr	r2, [r5, #0]
 c05404a:	f7ff fdf6 	bl	c053c3a <mbedtls_mpi_mul_int>
 c05404e:	2800      	cmp	r0, #0
 c054050:	d13c      	bne.n	c0540cc <mbedtls_mpi_div_mpi+0x322>
        while( mbedtls_mpi_cmp_mpi( &T1, &T2 ) > 0 );
 c054052:	a916      	add	r1, sp, #88	@ 0x58
 c054054:	a813      	add	r0, sp, #76	@ 0x4c
 c054056:	f7ff fbf1 	bl	c05383c <mbedtls_mpi_cmp_mpi>
 c05405a:	2800      	cmp	r0, #0
 c05405c:	dcdf      	bgt.n	c05401e <mbedtls_mpi_div_mpi+0x274>
        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_int( &T1, &Y, Z.p[i - t - 1] ) );
 c05405e:	682a      	ldr	r2, [r5, #0]
 c054060:	a90d      	add	r1, sp, #52	@ 0x34
 c054062:	a813      	add	r0, sp, #76	@ 0x4c
 c054064:	f7ff fde9 	bl	c053c3a <mbedtls_mpi_mul_int>
 c054068:	bb80      	cbnz	r0, c0540cc <mbedtls_mpi_div_mpi+0x322>
        MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &T1,  biL * ( i - t - 1 ) ) );
 c05406a:	9b02      	ldr	r3, [sp, #8]
 c05406c:	a813      	add	r0, sp, #76	@ 0x4c
 c05406e:	ea4f 08c3 	mov.w	r8, r3, lsl #3
 c054072:	4641      	mov	r1, r8
 c054074:	f7ff fb25 	bl	c0536c2 <mbedtls_mpi_shift_l>
 c054078:	bb40      	cbnz	r0, c0540cc <mbedtls_mpi_div_mpi+0x322>
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &X, &X, &T1 ) );
 c05407a:	a90a      	add	r1, sp, #40	@ 0x28
 c05407c:	4608      	mov	r0, r1
 c05407e:	aa13      	add	r2, sp, #76	@ 0x4c
 c054080:	f7ff fd1e 	bl	c053ac0 <mbedtls_mpi_sub_mpi>
 c054084:	4601      	mov	r1, r0
 c054086:	bb18      	cbnz	r0, c0540d0 <mbedtls_mpi_div_mpi+0x326>
        if( mbedtls_mpi_cmp_int( &X, 0 ) < 0 )
 c054088:	a80a      	add	r0, sp, #40	@ 0x28
 c05408a:	f7ff fc1a 	bl	c0538c2 <mbedtls_mpi_cmp_int>
 c05408e:	2800      	cmp	r0, #0
 c054090:	da12      	bge.n	c0540b8 <mbedtls_mpi_div_mpi+0x30e>
            MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &T1, &Y ) );
 c054092:	a90d      	add	r1, sp, #52	@ 0x34
 c054094:	a813      	add	r0, sp, #76	@ 0x4c
 c054096:	f7ff f988 	bl	c0533aa <mbedtls_mpi_copy>
 c05409a:	b9b8      	cbnz	r0, c0540cc <mbedtls_mpi_div_mpi+0x322>
            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &T1, biL * ( i - t - 1 ) ) );
 c05409c:	4641      	mov	r1, r8
 c05409e:	a813      	add	r0, sp, #76	@ 0x4c
 c0540a0:	f7ff fb0f 	bl	c0536c2 <mbedtls_mpi_shift_l>
 c0540a4:	b990      	cbnz	r0, c0540cc <mbedtls_mpi_div_mpi+0x322>
            MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &X, &X, &T1 ) );
 c0540a6:	a90a      	add	r1, sp, #40	@ 0x28
 c0540a8:	4608      	mov	r0, r1
 c0540aa:	aa13      	add	r2, sp, #76	@ 0x4c
 c0540ac:	f7ff fce5 	bl	c053a7a <mbedtls_mpi_add_mpi>
 c0540b0:	b960      	cbnz	r0, c0540cc <mbedtls_mpi_div_mpi+0x322>
            Z.p[i - t - 1]--;
 c0540b2:	682b      	ldr	r3, [r5, #0]
 c0540b4:	3b01      	subs	r3, #1
 c0540b6:	602b      	str	r3, [r5, #0]
    for( i = n; i > t ; i-- )
 c0540b8:	9b02      	ldr	r3, [sp, #8]
 c0540ba:	f10a 3aff 	add.w	sl, sl, #4294967295	@ 0xffffffff
 c0540be:	3b04      	subs	r3, #4
 c0540c0:	e731      	b.n	c053f26 <mbedtls_mpi_div_mpi+0x17c>
 c0540c2:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 c0540c6:	e791      	b.n	c053fec <mbedtls_mpi_div_mpi+0x242>
            T1.p[0] = ( t < 1 ) ? 0 : Y.p[t - 1];
 c0540c8:	9a05      	ldr	r2, [sp, #20]
 c0540ca:	e7b6      	b.n	c05403a <mbedtls_mpi_div_mpi+0x290>
 c0540cc:	4604      	mov	r4, r0
 c0540ce:	e6a3      	b.n	c053e18 <mbedtls_mpi_div_mpi+0x6e>
 c0540d0:	460c      	mov	r4, r1
 c0540d2:	e6a1      	b.n	c053e18 <mbedtls_mpi_div_mpi+0x6e>
        return( MBEDTLS_ERR_MPI_DIVISION_BY_ZERO );
 c0540d4:	f06f 040b 	mvn.w	r4, #11
 c0540d8:	e693      	b.n	c053e02 <mbedtls_mpi_div_mpi+0x58>

0c0540da <mbedtls_mpi_mod_mpi>:
{
 c0540da:	b570      	push	{r4, r5, r6, lr}
 c0540dc:	4604      	mov	r4, r0
 c0540de:	460d      	mov	r5, r1
    if( mbedtls_mpi_cmp_int( B, 0 ) < 0 )
 c0540e0:	4610      	mov	r0, r2
 c0540e2:	2100      	movs	r1, #0
{
 c0540e4:	4616      	mov	r6, r2
    if( mbedtls_mpi_cmp_int( B, 0 ) < 0 )
 c0540e6:	f7ff fbec 	bl	c0538c2 <mbedtls_mpi_cmp_int>
 c0540ea:	2800      	cmp	r0, #0
 c0540ec:	db24      	blt.n	c054138 <mbedtls_mpi_mod_mpi+0x5e>
    MBEDTLS_MPI_CHK( mbedtls_mpi_div_mpi( NULL, R, A, B ) );
 c0540ee:	462a      	mov	r2, r5
 c0540f0:	4633      	mov	r3, r6
 c0540f2:	4621      	mov	r1, r4
 c0540f4:	2000      	movs	r0, #0
 c0540f6:	f7ff fe58 	bl	c053daa <mbedtls_mpi_div_mpi>
 c0540fa:	4605      	mov	r5, r0
 c0540fc:	b138      	cbz	r0, c05410e <mbedtls_mpi_mod_mpi+0x34>
}
 c0540fe:	4628      	mov	r0, r5
 c054100:	bd70      	pop	{r4, r5, r6, pc}
      MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( R, R, B ) );
 c054102:	4632      	mov	r2, r6
 c054104:	4621      	mov	r1, r4
 c054106:	4620      	mov	r0, r4
 c054108:	f7ff fcb7 	bl	c053a7a <mbedtls_mpi_add_mpi>
 c05410c:	b990      	cbnz	r0, c054134 <mbedtls_mpi_mod_mpi+0x5a>
    while( mbedtls_mpi_cmp_int( R, 0 ) < 0 )
 c05410e:	2100      	movs	r1, #0
 c054110:	4620      	mov	r0, r4
 c054112:	f7ff fbd6 	bl	c0538c2 <mbedtls_mpi_cmp_int>
 c054116:	2800      	cmp	r0, #0
 c054118:	dbf3      	blt.n	c054102 <mbedtls_mpi_mod_mpi+0x28>
    while( mbedtls_mpi_cmp_mpi( R, B ) >= 0 )
 c05411a:	4631      	mov	r1, r6
 c05411c:	4620      	mov	r0, r4
 c05411e:	f7ff fb8d 	bl	c05383c <mbedtls_mpi_cmp_mpi>
 c054122:	2800      	cmp	r0, #0
 c054124:	dbeb      	blt.n	c0540fe <mbedtls_mpi_mod_mpi+0x24>
      MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( R, R, B ) );
 c054126:	4632      	mov	r2, r6
 c054128:	4621      	mov	r1, r4
 c05412a:	4620      	mov	r0, r4
 c05412c:	f7ff fcc8 	bl	c053ac0 <mbedtls_mpi_sub_mpi>
 c054130:	2800      	cmp	r0, #0
 c054132:	d0f2      	beq.n	c05411a <mbedtls_mpi_mod_mpi+0x40>
 c054134:	4605      	mov	r5, r0
 c054136:	e7e2      	b.n	c0540fe <mbedtls_mpi_mod_mpi+0x24>
        return( MBEDTLS_ERR_MPI_NEGATIVE_VALUE );
 c054138:	f06f 0509 	mvn.w	r5, #9
 c05413c:	e7df      	b.n	c0540fe <mbedtls_mpi_mod_mpi+0x24>

0c05413e <mbedtls_mpi_mod_int>:
    if( b == 0 )
 c05413e:	2a00      	cmp	r2, #0
{
 c054140:	b570      	push	{r4, r5, r6, lr}
    if( b == 0 )
 c054142:	d02a      	beq.n	c05419a <mbedtls_mpi_mod_int+0x5c>
    if( b < 0 )
 c054144:	db2c      	blt.n	c0541a0 <mbedtls_mpi_mod_int+0x62>
    if( b == 1 )
 c054146:	2a01      	cmp	r2, #1
 c054148:	d008      	beq.n	c05415c <mbedtls_mpi_mod_int+0x1e>
    if( b == 2 )
 c05414a:	2a02      	cmp	r2, #2
 c05414c:	d108      	bne.n	c054160 <mbedtls_mpi_mod_int+0x22>
        *r = A->p[0] & 1;
 c05414e:	688b      	ldr	r3, [r1, #8]
 c054150:	681b      	ldr	r3, [r3, #0]
 c054152:	f003 0301 	and.w	r3, r3, #1
 c054156:	6003      	str	r3, [r0, #0]
        return( 0 );
 c054158:	2000      	movs	r0, #0
}
 c05415a:	bd70      	pop	{r4, r5, r6, pc}
 c05415c:	2300      	movs	r3, #0
 c05415e:	e7fa      	b.n	c054156 <mbedtls_mpi_mod_int+0x18>
    for( i = A->n, y = 0; i > 0; i-- )
 c054160:	2300      	movs	r3, #0
 c054162:	684e      	ldr	r6, [r1, #4]
 c054164:	3e01      	subs	r6, #1
 c054166:	d206      	bcs.n	c054176 <mbedtls_mpi_mod_int+0x38>
    if( A->s < 0 && y != 0 )
 c054168:	6809      	ldr	r1, [r1, #0]
 c05416a:	2900      	cmp	r1, #0
 c05416c:	daf3      	bge.n	c054156 <mbedtls_mpi_mod_int+0x18>
 c05416e:	2b00      	cmp	r3, #0
 c054170:	d0f1      	beq.n	c054156 <mbedtls_mpi_mod_int+0x18>
        y = b - y;
 c054172:	1ad3      	subs	r3, r2, r3
    return( 0 );
 c054174:	e7ef      	b.n	c054156 <mbedtls_mpi_mod_int+0x18>
        x  = A->p[i - 1];
 c054176:	688c      	ldr	r4, [r1, #8]
 c054178:	f854 4026 	ldr.w	r4, [r4, r6, lsl #2]
        y  = ( y << biH ) | ( x >> biH );
 c05417c:	0c25      	lsrs	r5, r4, #16
 c05417e:	ea45 4303 	orr.w	r3, r5, r3, lsl #16
        y  = ( y << biH ) | ( x >> biH );
 c054182:	fbb3 f5f2 	udiv	r5, r3, r2
 c054186:	fb02 3315 	mls	r3, r2, r5, r3
 c05418a:	b2a4      	uxth	r4, r4
 c05418c:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
 c054190:	fbb4 f3f2 	udiv	r3, r4, r2
 c054194:	fb02 4313 	mls	r3, r2, r3, r4
    for( i = A->n, y = 0; i > 0; i-- )
 c054198:	e7e4      	b.n	c054164 <mbedtls_mpi_mod_int+0x26>
        return( MBEDTLS_ERR_MPI_DIVISION_BY_ZERO );
 c05419a:	f06f 000b 	mvn.w	r0, #11
 c05419e:	e7dc      	b.n	c05415a <mbedtls_mpi_mod_int+0x1c>
        return( MBEDTLS_ERR_MPI_NEGATIVE_VALUE );
 c0541a0:	f06f 0009 	mvn.w	r0, #9
 c0541a4:	e7d9      	b.n	c05415a <mbedtls_mpi_mod_int+0x1c>
	...

0c0541a8 <mpi_check_small_factors>:
{
    int ret = 0;
    size_t i;
    mbedtls_mpi_uint r;

    if( ( X->p[0] & 1 ) == 0 )
 c0541a8:	6883      	ldr	r3, [r0, #8]
{
 c0541aa:	b573      	push	{r0, r1, r4, r5, r6, lr}
    if( ( X->p[0] & 1 ) == 0 )
 c0541ac:	681b      	ldr	r3, [r3, #0]
{
 c0541ae:	4604      	mov	r4, r0
    if( ( X->p[0] & 1 ) == 0 )
 c0541b0:	07db      	lsls	r3, r3, #31
 c0541b2:	d403      	bmi.n	c0541bc <mpi_check_small_factors+0x14>
        return( MBEDTLS_ERR_MPI_NOT_ACCEPTABLE );
 c0541b4:	f06f 000d 	mvn.w	r0, #13
            return( MBEDTLS_ERR_MPI_NOT_ACCEPTABLE );
    }

cleanup:
    return( ret );
}
 c0541b8:	b002      	add	sp, #8
 c0541ba:	bd70      	pop	{r4, r5, r6, pc}
 c0541bc:	4e0c      	ldr	r6, [pc, #48]	@ (c0541f0 <mpi_check_small_factors+0x48>)
    for( i = 0; small_prime[i] > 0; i++ )
 c0541be:	f856 5b04 	ldr.w	r5, [r6], #4
 c0541c2:	2d00      	cmp	r5, #0
 c0541c4:	dc01      	bgt.n	c0541ca <mpi_check_small_factors+0x22>
cleanup:
 c0541c6:	2000      	movs	r0, #0
 c0541c8:	e7f6      	b.n	c0541b8 <mpi_check_small_factors+0x10>
        if( mbedtls_mpi_cmp_int( X, small_prime[i] ) <= 0 )
 c0541ca:	4629      	mov	r1, r5
 c0541cc:	4620      	mov	r0, r4
 c0541ce:	f7ff fb78 	bl	c0538c2 <mbedtls_mpi_cmp_int>
 c0541d2:	2800      	cmp	r0, #0
 c0541d4:	dd0a      	ble.n	c0541ec <mpi_check_small_factors+0x44>
        MBEDTLS_MPI_CHK( mbedtls_mpi_mod_int( &r, X, small_prime[i] ) );
 c0541d6:	462a      	mov	r2, r5
 c0541d8:	4621      	mov	r1, r4
 c0541da:	a801      	add	r0, sp, #4
 c0541dc:	f7ff ffaf 	bl	c05413e <mbedtls_mpi_mod_int>
 c0541e0:	2800      	cmp	r0, #0
 c0541e2:	d1e9      	bne.n	c0541b8 <mpi_check_small_factors+0x10>
        if( r == 0 )
 c0541e4:	9b01      	ldr	r3, [sp, #4]
 c0541e6:	2b00      	cmp	r3, #0
 c0541e8:	d1e9      	bne.n	c0541be <mpi_check_small_factors+0x16>
 c0541ea:	e7e3      	b.n	c0541b4 <mpi_check_small_factors+0xc>
            return( 1 );
 c0541ec:	2001      	movs	r0, #1
 c0541ee:	e7e3      	b.n	c0541b8 <mpi_check_small_factors+0x10>
 c0541f0:	0c05fbb4 	.word	0x0c05fbb4

0c0541f4 <mbedtls_mpi_exp_mod>:
{
 c0541f4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c0541f8:	4606      	mov	r6, r0
 c0541fa:	f5ad 7d5b 	sub.w	sp, sp, #876	@ 0x36c
 c0541fe:	4689      	mov	r9, r1
    if( mbedtls_mpi_cmp_int( N, 0 ) <= 0 || ( N->p[0] & 1 ) == 0 )
 c054200:	4618      	mov	r0, r3
 c054202:	2100      	movs	r1, #0
{
 c054204:	461d      	mov	r5, r3
 c054206:	9205      	str	r2, [sp, #20]
    if( mbedtls_mpi_cmp_int( N, 0 ) <= 0 || ( N->p[0] & 1 ) == 0 )
 c054208:	f7ff fb5b 	bl	c0538c2 <mbedtls_mpi_cmp_int>
 c05420c:	2800      	cmp	r0, #0
 c05420e:	f340 8219 	ble.w	c054644 <mbedtls_mpi_exp_mod+0x450>
 c054212:	68ab      	ldr	r3, [r5, #8]
 c054214:	681c      	ldr	r4, [r3, #0]
 c054216:	f014 0301 	ands.w	r3, r4, #1
 c05421a:	9307      	str	r3, [sp, #28]
 c05421c:	f000 8212 	beq.w	c054644 <mbedtls_mpi_exp_mod+0x450>
    if( mbedtls_mpi_cmp_int( E, 0 ) < 0 )
 c054220:	2100      	movs	r1, #0
 c054222:	9805      	ldr	r0, [sp, #20]
 c054224:	f7ff fb4d 	bl	c0538c2 <mbedtls_mpi_cmp_int>
 c054228:	2800      	cmp	r0, #0
 c05422a:	f2c0 820b 	blt.w	c054644 <mbedtls_mpi_exp_mod+0x450>
    if( mbedtls_mpi_bitlen( E ) > MBEDTLS_MPI_MAX_BITS ||
 c05422e:	9805      	ldr	r0, [sp, #20]
 c054230:	f7ff f975 	bl	c05351e <mbedtls_mpi_bitlen>
 c054234:	f5b0 5f00 	cmp.w	r0, #8192	@ 0x2000
 c054238:	f200 8204 	bhi.w	c054644 <mbedtls_mpi_exp_mod+0x450>
        mbedtls_mpi_bitlen( N ) > MBEDTLS_MPI_MAX_BITS )
 c05423c:	4628      	mov	r0, r5
 c05423e:	f7ff f96e 	bl	c05351e <mbedtls_mpi_bitlen>
    if( mbedtls_mpi_bitlen( E ) > MBEDTLS_MPI_MAX_BITS ||
 c054242:	f5b0 5f00 	cmp.w	r0, #8192	@ 0x2000
 c054246:	f200 81fd 	bhi.w	c054644 <mbedtls_mpi_exp_mod+0x450>
    x += ( ( m0 + 2 ) & 4 ) << 1;
 c05424a:	2103      	movs	r1, #3
 c05424c:	f104 0802 	add.w	r8, r4, #2
 c054250:	ea4f 0848 	mov.w	r8, r8, lsl #1
 c054254:	f008 0808 	and.w	r8, r8, #8
 c054258:	44a0      	add	r8, r4
        x *= ( 2 - ( m0 * x ) );
 c05425a:	fb08 f304 	mul.w	r3, r8, r4
    for( i = biL; i >= 8; i /= 2 )
 c05425e:	3901      	subs	r1, #1
        x *= ( 2 - ( m0 * x ) );
 c054260:	f1c3 0302 	rsb	r3, r3, #2
 c054264:	fb03 f808 	mul.w	r8, r3, r8
    for( i = biL; i >= 8; i /= 2 )
 c054268:	d1f7      	bne.n	c05425a <mbedtls_mpi_exp_mod+0x66>
    X->s = 1;
 c05426a:	2301      	movs	r3, #1
    memset( W, 0, sizeof( W ) );
 c05426c:	f44f 7240 	mov.w	r2, #768	@ 0x300
 c054270:	a81a      	add	r0, sp, #104	@ 0x68
    X->n = 0;
 c054272:	e9cd 310b 	strd	r3, r1, [sp, #44]	@ 0x2c
    X->s = 1;
 c054276:	e9cd 130d 	strd	r1, r3, [sp, #52]	@ 0x34
    X->p = NULL;
 c05427a:	e9cd 110f 	strd	r1, r1, [sp, #60]	@ 0x3c
    X->n = 0;
 c05427e:	e9cd 3114 	strd	r3, r1, [sp, #80]	@ 0x50
 c054282:	e9cd 3111 	strd	r3, r1, [sp, #68]	@ 0x44
    X->p = NULL;
 c054286:	9116      	str	r1, [sp, #88]	@ 0x58
 c054288:	9113      	str	r1, [sp, #76]	@ 0x4c
    memset( W, 0, sizeof( W ) );
 c05428a:	f007 fa50 	bl	c05b72e <memset>
    i = mbedtls_mpi_bitlen( E );
 c05428e:	9805      	ldr	r0, [sp, #20]
 c054290:	f7ff f945 	bl	c05351e <mbedtls_mpi_bitlen>
    wsize = ( i > 671 ) ? 6 : ( i > 239 ) ? 5 :
 c054294:	f5b0 7f28 	cmp.w	r0, #672	@ 0x2a0
 c054298:	f080 80f7 	bcs.w	c05448a <mbedtls_mpi_exp_mod+0x296>
 c05429c:	28ef      	cmp	r0, #239	@ 0xef
 c05429e:	f200 80f6 	bhi.w	c05448e <mbedtls_mpi_exp_mod+0x29a>
 c0542a2:	284f      	cmp	r0, #79	@ 0x4f
 c0542a4:	f200 80f5 	bhi.w	c054492 <mbedtls_mpi_exp_mod+0x29e>
 c0542a8:	9b07      	ldr	r3, [sp, #28]
 c0542aa:	2818      	cmp	r0, #24
 c0542ac:	bf34      	ite	cc
 c0542ae:	461f      	movcc	r7, r3
 c0542b0:	2703      	movcs	r7, #3
    j = N->n + 1;
 c0542b2:	686b      	ldr	r3, [r5, #4]
    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, j ) );
 c0542b4:	4630      	mov	r0, r6
    j = N->n + 1;
 c0542b6:	f103 0a01 	add.w	sl, r3, #1
    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, j ) );
 c0542ba:	4651      	mov	r1, sl
 c0542bc:	f7ff f833 	bl	c053326 <mbedtls_mpi_grow>
 c0542c0:	4604      	mov	r4, r0
 c0542c2:	2800      	cmp	r0, #0
 c0542c4:	f040 80bf 	bne.w	c054446 <mbedtls_mpi_exp_mod+0x252>
    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( &W[1],  j ) );
 c0542c8:	4651      	mov	r1, sl
 c0542ca:	a81d      	add	r0, sp, #116	@ 0x74
 c0542cc:	f7ff f82b 	bl	c053326 <mbedtls_mpi_grow>
 c0542d0:	4604      	mov	r4, r0
 c0542d2:	2800      	cmp	r0, #0
 c0542d4:	f040 80b7 	bne.w	c054446 <mbedtls_mpi_exp_mod+0x252>
    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( &T, j * 2 ) );
 c0542d8:	ea4f 014a 	mov.w	r1, sl, lsl #1
 c0542dc:	a80e      	add	r0, sp, #56	@ 0x38
 c0542de:	f7ff f822 	bl	c053326 <mbedtls_mpi_grow>
 c0542e2:	4604      	mov	r4, r0
 c0542e4:	2800      	cmp	r0, #0
 c0542e6:	f040 80ae 	bne.w	c054446 <mbedtls_mpi_exp_mod+0x252>
    neg = ( A->s == -1 );
 c0542ea:	f8d9 3000 	ldr.w	r3, [r9]
 c0542ee:	9306      	str	r3, [sp, #24]
    if( neg )
 c0542f0:	3301      	adds	r3, #1
 c0542f2:	d10b      	bne.n	c05430c <mbedtls_mpi_exp_mod+0x118>
        MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &Apos, A ) );
 c0542f4:	4649      	mov	r1, r9
 c0542f6:	a814      	add	r0, sp, #80	@ 0x50
 c0542f8:	f7ff f857 	bl	c0533aa <mbedtls_mpi_copy>
 c0542fc:	4604      	mov	r4, r0
 c0542fe:	2800      	cmp	r0, #0
 c054300:	f040 80a1 	bne.w	c054446 <mbedtls_mpi_exp_mod+0x252>
        Apos.s = 1;
 c054304:	2301      	movs	r3, #1
        A = &Apos;
 c054306:	f10d 0950 	add.w	r9, sp, #80	@ 0x50
        Apos.s = 1;
 c05430a:	9314      	str	r3, [sp, #80]	@ 0x50
    if( prec_RR == NULL || prec_RR->p == NULL )
 c05430c:	9be4      	ldr	r3, [sp, #912]	@ 0x390
 c05430e:	b11b      	cbz	r3, c054318 <mbedtls_mpi_exp_mod+0x124>
 c054310:	689b      	ldr	r3, [r3, #8]
 c054312:	2b00      	cmp	r3, #0
 c054314:	f040 80bf 	bne.w	c054496 <mbedtls_mpi_exp_mod+0x2a2>
        MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &RR, 1 ) );
 c054318:	2101      	movs	r1, #1
 c05431a:	a80b      	add	r0, sp, #44	@ 0x2c
 c05431c:	f7ff f88f 	bl	c05343e <mbedtls_mpi_lset>
 c054320:	4604      	mov	r4, r0
 c054322:	2800      	cmp	r0, #0
 c054324:	f040 808f 	bne.w	c054446 <mbedtls_mpi_exp_mod+0x252>
        MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &RR, N->n * 2 * biL ) );
 c054328:	6869      	ldr	r1, [r5, #4]
 c05432a:	a80b      	add	r0, sp, #44	@ 0x2c
 c05432c:	0189      	lsls	r1, r1, #6
 c05432e:	f7ff f9c8 	bl	c0536c2 <mbedtls_mpi_shift_l>
 c054332:	4604      	mov	r4, r0
 c054334:	2800      	cmp	r0, #0
 c054336:	f040 8086 	bne.w	c054446 <mbedtls_mpi_exp_mod+0x252>
        MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( &RR, &RR, N ) );
 c05433a:	a90b      	add	r1, sp, #44	@ 0x2c
 c05433c:	462a      	mov	r2, r5
 c05433e:	4608      	mov	r0, r1
 c054340:	f7ff fecb 	bl	c0540da <mbedtls_mpi_mod_mpi>
 c054344:	4604      	mov	r4, r0
 c054346:	2800      	cmp	r0, #0
 c054348:	d17d      	bne.n	c054446 <mbedtls_mpi_exp_mod+0x252>
        if( prec_RR != NULL )
 c05434a:	9be4      	ldr	r3, [sp, #912]	@ 0x390
 c05434c:	b133      	cbz	r3, c05435c <mbedtls_mpi_exp_mod+0x168>
            memcpy( prec_RR, &RR, sizeof( mbedtls_mpi ) );
 c05434e:	9ae4      	ldr	r2, [sp, #912]	@ 0x390
 c054350:	ab0b      	add	r3, sp, #44	@ 0x2c
 c054352:	cb03      	ldmia	r3!, {r0, r1}
 c054354:	6010      	str	r0, [r2, #0]
 c054356:	6818      	ldr	r0, [r3, #0]
 c054358:	6051      	str	r1, [r2, #4]
 c05435a:	6090      	str	r0, [r2, #8]
    if( mbedtls_mpi_cmp_mpi( A, N ) >= 0 )
 c05435c:	4629      	mov	r1, r5
 c05435e:	4648      	mov	r0, r9
 c054360:	f7ff fa6c 	bl	c05383c <mbedtls_mpi_cmp_mpi>
 c054364:	2800      	cmp	r0, #0
 c054366:	f2c0 809e 	blt.w	c0544a6 <mbedtls_mpi_exp_mod+0x2b2>
        MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( &W[1], A, N ) );
 c05436a:	462a      	mov	r2, r5
 c05436c:	4649      	mov	r1, r9
 c05436e:	a81d      	add	r0, sp, #116	@ 0x74
 c054370:	f7ff feb3 	bl	c0540da <mbedtls_mpi_mod_mpi>
 c054374:	4604      	mov	r4, r0
 c054376:	2800      	cmp	r0, #0
 c054378:	d165      	bne.n	c054446 <mbedtls_mpi_exp_mod+0x252>
        MBEDTLS_MPI_CHK( mbedtls_mpi_grow( &W[1], N->n + 1 ) );
 c05437a:	6869      	ldr	r1, [r5, #4]
 c05437c:	a81d      	add	r0, sp, #116	@ 0x74
 c05437e:	3101      	adds	r1, #1
 c054380:	f7fe ffd1 	bl	c053326 <mbedtls_mpi_grow>
 c054384:	4604      	mov	r4, r0
 c054386:	2800      	cmp	r0, #0
 c054388:	d15d      	bne.n	c054446 <mbedtls_mpi_exp_mod+0x252>
    mpi_montmul( &W[1], &RR, N, mm, &T );
 c05438a:	f10d 0b38 	add.w	fp, sp, #56	@ 0x38
    *mm = ~x + 1;
 c05438e:	f1c8 0300 	rsb	r3, r8, #0
    mpi_montmul( &W[1], &RR, N, mm, &T );
 c054392:	462a      	mov	r2, r5
 c054394:	a90b      	add	r1, sp, #44	@ 0x2c
 c054396:	a81d      	add	r0, sp, #116	@ 0x74
 c054398:	f8cd b000 	str.w	fp, [sp]
    *mm = ~x + 1;
 c05439c:	9303      	str	r3, [sp, #12]
    mpi_montmul( &W[1], &RR, N, mm, &T );
 c05439e:	f7fe fef6 	bl	c05318e <mpi_montmul>
    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( X, &RR ) );
 c0543a2:	4630      	mov	r0, r6
 c0543a4:	a90b      	add	r1, sp, #44	@ 0x2c
 c0543a6:	f7ff f800 	bl	c0533aa <mbedtls_mpi_copy>
 c0543aa:	4604      	mov	r4, r0
 c0543ac:	2800      	cmp	r0, #0
 c0543ae:	d14a      	bne.n	c054446 <mbedtls_mpi_exp_mod+0x252>
    mbedtls_mpi_uint z = 1;
 c0543b0:	2301      	movs	r3, #1
 c0543b2:	aa0a      	add	r2, sp, #40	@ 0x28
    U.n = U.s = (int) z;
 c0543b4:	e9cd 3317 	strd	r3, r3, [sp, #92]	@ 0x5c
    mbedtls_mpi_uint z = 1;
 c0543b8:	930a      	str	r3, [sp, #40]	@ 0x28
    U.p = &z;
 c0543ba:	9219      	str	r2, [sp, #100]	@ 0x64
    mpi_montmul( A, &U, N, mm, T );
 c0543bc:	4630      	mov	r0, r6
 c0543be:	462a      	mov	r2, r5
 c0543c0:	9b03      	ldr	r3, [sp, #12]
 c0543c2:	f8cd b000 	str.w	fp, [sp]
 c0543c6:	a917      	add	r1, sp, #92	@ 0x5c
 c0543c8:	f7fe fee1 	bl	c05318e <mpi_montmul>
    if( wsize > 1 )
 c0543cc:	2f01      	cmp	r7, #1
 c0543ce:	d16f      	bne.n	c0544b0 <mbedtls_mpi_exp_mod+0x2bc>
    state   = 0;
 c0543d0:	f04f 0a00 	mov.w	sl, #0
    nbits   = 0;
 c0543d4:	46d0      	mov	r8, sl
    bufsize = 0;
 c0543d6:	46d3      	mov	fp, sl
    wbits   = 0;
 c0543d8:	46d1      	mov	r9, sl
    nblimbs = E->n;
 c0543da:	9b05      	ldr	r3, [sp, #20]
 c0543dc:	685b      	ldr	r3, [r3, #4]
 c0543de:	9304      	str	r3, [sp, #16]
        if( bufsize == 0 )
 c0543e0:	f1bb 0f00 	cmp.w	fp, #0
 c0543e4:	f040 80b3 	bne.w	c05454e <mbedtls_mpi_exp_mod+0x35a>
            if( nblimbs == 0 )
 c0543e8:	9b04      	ldr	r3, [sp, #16]
 c0543ea:	2b00      	cmp	r3, #0
 c0543ec:	f040 80aa 	bne.w	c054544 <mbedtls_mpi_exp_mod+0x350>
        if( ( wbits & ( one << wsize ) ) != 0 )
 c0543f0:	f04f 0b01 	mov.w	fp, #1
 c0543f4:	f10d 0a38 	add.w	sl, sp, #56	@ 0x38
 c0543f8:	fa0b fb07 	lsl.w	fp, fp, r7
    for( i = 0; i < nbits; i++ )
 c0543fc:	9b04      	ldr	r3, [sp, #16]
 c0543fe:	4543      	cmp	r3, r8
 c054400:	f040 80fe 	bne.w	c054600 <mbedtls_mpi_exp_mod+0x40c>
    mbedtls_mpi_uint z = 1;
 c054404:	2301      	movs	r3, #1
 c054406:	aa0a      	add	r2, sp, #40	@ 0x28
    U.n = U.s = (int) z;
 c054408:	e9cd 3317 	strd	r3, r3, [sp, #92]	@ 0x5c
    mbedtls_mpi_uint z = 1;
 c05440c:	930a      	str	r3, [sp, #40]	@ 0x28
    U.p = &z;
 c05440e:	9219      	str	r2, [sp, #100]	@ 0x64
    mpi_montmul( A, &U, N, mm, T );
 c054410:	9b03      	ldr	r3, [sp, #12]
 c054412:	462a      	mov	r2, r5
 c054414:	4630      	mov	r0, r6
 c054416:	f8cd a000 	str.w	sl, [sp]
 c05441a:	a917      	add	r1, sp, #92	@ 0x5c
 c05441c:	f7fe feb7 	bl	c05318e <mpi_montmul>
    if( neg && E->n != 0 && ( E->p[0] & 1 ) != 0 )
 c054420:	9b06      	ldr	r3, [sp, #24]
 c054422:	3301      	adds	r3, #1
 c054424:	d10f      	bne.n	c054446 <mbedtls_mpi_exp_mod+0x252>
 c054426:	9b05      	ldr	r3, [sp, #20]
 c054428:	685b      	ldr	r3, [r3, #4]
 c05442a:	b163      	cbz	r3, c054446 <mbedtls_mpi_exp_mod+0x252>
 c05442c:	9b05      	ldr	r3, [sp, #20]
 c05442e:	689b      	ldr	r3, [r3, #8]
 c054430:	681b      	ldr	r3, [r3, #0]
 c054432:	07db      	lsls	r3, r3, #31
 c054434:	d507      	bpl.n	c054446 <mbedtls_mpi_exp_mod+0x252>
        X->s = -1;
 c054436:	9b06      	ldr	r3, [sp, #24]
        MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( X, N, X ) );
 c054438:	4632      	mov	r2, r6
 c05443a:	4629      	mov	r1, r5
 c05443c:	4630      	mov	r0, r6
        X->s = -1;
 c05443e:	6033      	str	r3, [r6, #0]
        MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( X, N, X ) );
 c054440:	f7ff fb1b 	bl	c053a7a <mbedtls_mpi_add_mpi>
            MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &W[i], &W[i - 1] ) );
 c054444:	4604      	mov	r4, r0
    for( i = ( one << ( wsize - 1 ) ); i < ( one << wsize ); i++ )
 c054446:	2301      	movs	r3, #1
 c054448:	1e7d      	subs	r5, r7, #1
 c05444a:	fa03 f607 	lsl.w	r6, r3, r7
        mbedtls_mpi_free( &W[i] );
 c05444e:	270c      	movs	r7, #12
    for( i = ( one << ( wsize - 1 ) ); i < ( one << wsize ); i++ )
 c054450:	fa03 f505 	lsl.w	r5, r3, r5
 c054454:	42ae      	cmp	r6, r5
 c054456:	f200 80ee 	bhi.w	c054636 <mbedtls_mpi_exp_mod+0x442>
    mbedtls_mpi_free( &W[1] ); mbedtls_mpi_free( &T ); mbedtls_mpi_free( &Apos );
 c05445a:	a81d      	add	r0, sp, #116	@ 0x74
 c05445c:	f7fe ff51 	bl	c053302 <mbedtls_mpi_free>
 c054460:	a80e      	add	r0, sp, #56	@ 0x38
 c054462:	f7fe ff4e 	bl	c053302 <mbedtls_mpi_free>
 c054466:	a814      	add	r0, sp, #80	@ 0x50
 c054468:	f7fe ff4b 	bl	c053302 <mbedtls_mpi_free>
    mbedtls_mpi_free( &WW );
 c05446c:	a811      	add	r0, sp, #68	@ 0x44
 c05446e:	f7fe ff48 	bl	c053302 <mbedtls_mpi_free>
    if( prec_RR == NULL || prec_RR->p == NULL )
 c054472:	9be4      	ldr	r3, [sp, #912]	@ 0x390
 c054474:	b10b      	cbz	r3, c05447a <mbedtls_mpi_exp_mod+0x286>
 c054476:	689b      	ldr	r3, [r3, #8]
 c054478:	b913      	cbnz	r3, c054480 <mbedtls_mpi_exp_mod+0x28c>
        mbedtls_mpi_free( &RR );
 c05447a:	a80b      	add	r0, sp, #44	@ 0x2c
 c05447c:	f7fe ff41 	bl	c053302 <mbedtls_mpi_free>
}
 c054480:	4620      	mov	r0, r4
 c054482:	f50d 7d5b 	add.w	sp, sp, #876	@ 0x36c
 c054486:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    wsize = ( i > 671 ) ? 6 : ( i > 239 ) ? 5 :
 c05448a:	2706      	movs	r7, #6
 c05448c:	e711      	b.n	c0542b2 <mbedtls_mpi_exp_mod+0xbe>
 c05448e:	2705      	movs	r7, #5
 c054490:	e70f      	b.n	c0542b2 <mbedtls_mpi_exp_mod+0xbe>
 c054492:	2704      	movs	r7, #4
 c054494:	e70d      	b.n	c0542b2 <mbedtls_mpi_exp_mod+0xbe>
        memcpy( &RR, prec_RR, sizeof( mbedtls_mpi ) );
 c054496:	9ae4      	ldr	r2, [sp, #912]	@ 0x390
 c054498:	ab0b      	add	r3, sp, #44	@ 0x2c
 c05449a:	6810      	ldr	r0, [r2, #0]
 c05449c:	6851      	ldr	r1, [r2, #4]
 c05449e:	c303      	stmia	r3!, {r0, r1}
 c0544a0:	6890      	ldr	r0, [r2, #8]
 c0544a2:	6018      	str	r0, [r3, #0]
 c0544a4:	e75a      	b.n	c05435c <mbedtls_mpi_exp_mod+0x168>
        MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &W[1], A ) );
 c0544a6:	4649      	mov	r1, r9
 c0544a8:	a81d      	add	r0, sp, #116	@ 0x74
 c0544aa:	f7fe ff7e 	bl	c0533aa <mbedtls_mpi_copy>
 c0544ae:	e769      	b.n	c054384 <mbedtls_mpi_exp_mod+0x190>
        MBEDTLS_MPI_CHK( mbedtls_mpi_grow( &W[j], N->n + 1 ) );
 c0544b0:	230c      	movs	r3, #12
        j =  one << ( wsize - 1 );
 c0544b2:	f107 39ff 	add.w	r9, r7, #4294967295	@ 0xffffffff
        MBEDTLS_MPI_CHK( mbedtls_mpi_grow( &W[j], N->n + 1 ) );
 c0544b6:	6869      	ldr	r1, [r5, #4]
 c0544b8:	fa03 f309 	lsl.w	r3, r3, r9
 c0544bc:	aa1a      	add	r2, sp, #104	@ 0x68
 c0544be:	eb02 0803 	add.w	r8, r2, r3
 c0544c2:	4640      	mov	r0, r8
 c0544c4:	3101      	adds	r1, #1
 c0544c6:	f7fe ff2e 	bl	c053326 <mbedtls_mpi_grow>
 c0544ca:	2800      	cmp	r0, #0
 c0544cc:	d1ba      	bne.n	c054444 <mbedtls_mpi_exp_mod+0x250>
        MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &W[j], &W[1]    ) );
 c0544ce:	4640      	mov	r0, r8
 c0544d0:	a91d      	add	r1, sp, #116	@ 0x74
 c0544d2:	f7fe ff6a 	bl	c0533aa <mbedtls_mpi_copy>
 c0544d6:	2800      	cmp	r0, #0
 c0544d8:	d1b4      	bne.n	c054444 <mbedtls_mpi_exp_mod+0x250>
        for( i = 0; i < wsize - 1; i++ )
 c0544da:	46a2      	mov	sl, r4
            mpi_montmul( &W[j], &W[j], N, mm, &T );
 c0544dc:	462a      	mov	r2, r5
 c0544de:	4641      	mov	r1, r8
 c0544e0:	4640      	mov	r0, r8
 c0544e2:	9b03      	ldr	r3, [sp, #12]
 c0544e4:	f8cd b000 	str.w	fp, [sp]
        for( i = 0; i < wsize - 1; i++ )
 c0544e8:	f10a 0a01 	add.w	sl, sl, #1
            mpi_montmul( &W[j], &W[j], N, mm, &T );
 c0544ec:	f7fe fe4f 	bl	c05318e <mpi_montmul>
        for( i = 0; i < wsize - 1; i++ )
 c0544f0:	45ca      	cmp	sl, r9
 c0544f2:	d3f3      	bcc.n	c0544dc <mbedtls_mpi_exp_mod+0x2e8>
        j =  one << ( wsize - 1 );
 c0544f4:	f04f 0a01 	mov.w	sl, #1
 c0544f8:	fa0a f909 	lsl.w	r9, sl, r9
        for( i = j + 1; i < ( one << wsize ); i++ )
 c0544fc:	44d1      	add	r9, sl
 c0544fe:	fa0a fa07 	lsl.w	sl, sl, r7
 c054502:	45ca      	cmp	sl, r9
 c054504:	f67f af64 	bls.w	c0543d0 <mbedtls_mpi_exp_mod+0x1dc>
            MBEDTLS_MPI_CHK( mbedtls_mpi_grow( &W[i], N->n + 1 ) );
 c054508:	6869      	ldr	r1, [r5, #4]
 c05450a:	f108 0b0c 	add.w	fp, r8, #12
 c05450e:	4658      	mov	r0, fp
 c054510:	3101      	adds	r1, #1
 c054512:	f7fe ff08 	bl	c053326 <mbedtls_mpi_grow>
 c054516:	2800      	cmp	r0, #0
 c054518:	d194      	bne.n	c054444 <mbedtls_mpi_exp_mod+0x250>
            MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &W[i], &W[i - 1] ) );
 c05451a:	4641      	mov	r1, r8
 c05451c:	4658      	mov	r0, fp
 c05451e:	f7fe ff44 	bl	c0533aa <mbedtls_mpi_copy>
 c054522:	2800      	cmp	r0, #0
 c054524:	d18e      	bne.n	c054444 <mbedtls_mpi_exp_mod+0x250>
            mpi_montmul( &W[i], &W[1], N, mm, &T );
 c054526:	ab0e      	add	r3, sp, #56	@ 0x38
 c054528:	9300      	str	r3, [sp, #0]
 c05452a:	462a      	mov	r2, r5
 c05452c:	4658      	mov	r0, fp
 c05452e:	9b03      	ldr	r3, [sp, #12]
 c054530:	a91d      	add	r1, sp, #116	@ 0x74
 c054532:	f7fe fe2c 	bl	c05318e <mpi_montmul>
        for( i = j + 1; i < ( one << wsize ); i++ )
 c054536:	46d8      	mov	r8, fp
 c054538:	f109 0901 	add.w	r9, r9, #1
 c05453c:	e7e1      	b.n	c054502 <mbedtls_mpi_exp_mod+0x30e>
        state = 2;
 c05453e:	f04f 0a02 	mov.w	sl, #2
 c054542:	e74d      	b.n	c0543e0 <mbedtls_mpi_exp_mod+0x1ec>
            bufsize = sizeof( mbedtls_mpi_uint ) << 3;
 c054544:	f04f 0b20 	mov.w	fp, #32
            nblimbs--;
 c054548:	9b04      	ldr	r3, [sp, #16]
 c05454a:	3b01      	subs	r3, #1
 c05454c:	9304      	str	r3, [sp, #16]
        ei = (E->p[nblimbs] >> bufsize) & 1;
 c05454e:	9b05      	ldr	r3, [sp, #20]
 c054550:	9a04      	ldr	r2, [sp, #16]
 c054552:	689b      	ldr	r3, [r3, #8]
        bufsize--;
 c054554:	f10b 3bff 	add.w	fp, fp, #4294967295	@ 0xffffffff
        ei = (E->p[nblimbs] >> bufsize) & 1;
 c054558:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 c05455c:	fa23 f30b 	lsr.w	r3, r3, fp
        if( ei == 0 && state == 0 )
 c054560:	f013 0301 	ands.w	r3, r3, #1
 c054564:	d10f      	bne.n	c054586 <mbedtls_mpi_exp_mod+0x392>
 c054566:	f1ba 0f00 	cmp.w	sl, #0
 c05456a:	f43f af39 	beq.w	c0543e0 <mbedtls_mpi_exp_mod+0x1ec>
        if( ei == 0 && state == 1 )
 c05456e:	f1ba 0f01 	cmp.w	sl, #1
 c054572:	d108      	bne.n	c054586 <mbedtls_mpi_exp_mod+0x392>
            mpi_montmul( X, X, N, mm, &T );
 c054574:	ab0e      	add	r3, sp, #56	@ 0x38
 c054576:	9300      	str	r3, [sp, #0]
 c054578:	462a      	mov	r2, r5
 c05457a:	4631      	mov	r1, r6
 c05457c:	4630      	mov	r0, r6
 c05457e:	9b03      	ldr	r3, [sp, #12]
 c054580:	f7fe fe05 	bl	c05318e <mpi_montmul>
            continue;
 c054584:	e72c      	b.n	c0543e0 <mbedtls_mpi_exp_mod+0x1ec>
        nbits++;
 c054586:	f108 0801 	add.w	r8, r8, #1
        wbits |= ( ei << ( wsize - nbits ) );
 c05458a:	eba7 0208 	sub.w	r2, r7, r8
 c05458e:	4093      	lsls	r3, r2
        if( nbits == wsize )
 c054590:	4547      	cmp	r7, r8
        wbits |= ( ei << ( wsize - nbits ) );
 c054592:	ea49 0903 	orr.w	r9, r9, r3
        if( nbits == wsize )
 c054596:	d1d2      	bne.n	c05453e <mbedtls_mpi_exp_mod+0x34a>
            for( i = 0; i < wsize; i++ )
 c054598:	f04f 0a00 	mov.w	sl, #0
                mpi_montmul( X, X, N, mm, &T );
 c05459c:	ab0e      	add	r3, sp, #56	@ 0x38
 c05459e:	9300      	str	r3, [sp, #0]
 c0545a0:	462a      	mov	r2, r5
 c0545a2:	4631      	mov	r1, r6
 c0545a4:	4630      	mov	r0, r6
 c0545a6:	9b03      	ldr	r3, [sp, #12]
            for( i = 0; i < wsize; i++ )
 c0545a8:	f10a 0a01 	add.w	sl, sl, #1
                mpi_montmul( X, X, N, mm, &T );
 c0545ac:	f7fe fdef 	bl	c05318e <mpi_montmul>
            for( i = 0; i < wsize; i++ )
 c0545b0:	45d0      	cmp	r8, sl
 c0545b2:	d8f3      	bhi.n	c05459c <mbedtls_mpi_exp_mod+0x3a8>
            MBEDTLS_MPI_CHK( mpi_select( &WW, W, (size_t) 1 << wsize, wbits ) );
 c0545b4:	2301      	movs	r3, #1
 c0545b6:	fa03 f308 	lsl.w	r3, r3, r8
 c0545ba:	9308      	str	r3, [sp, #32]
    for( size_t i = 0; i < T_size; i++ )
 c0545bc:	2300      	movs	r3, #0
 c0545be:	f10d 0a68 	add.w	sl, sp, #104	@ 0x68
        MBEDTLS_MPI_CHK( mbedtls_mpi_safe_cond_assign( R, &T[i],
 c0545c2:	4649      	mov	r1, r9
 c0545c4:	4618      	mov	r0, r3
 c0545c6:	9309      	str	r3, [sp, #36]	@ 0x24
 c0545c8:	f001 f8da 	bl	c055780 <mbedtls_ct_size_bool_eq>
 c0545cc:	4651      	mov	r1, sl
 c0545ce:	b2c2      	uxtb	r2, r0
 c0545d0:	a811      	add	r0, sp, #68	@ 0x44
 c0545d2:	f001 f8f4 	bl	c0557be <mbedtls_mpi_safe_cond_assign>
 c0545d6:	4680      	mov	r8, r0
 c0545d8:	bb58      	cbnz	r0, c054632 <mbedtls_mpi_exp_mod+0x43e>
    for( size_t i = 0; i < T_size; i++ )
 c0545da:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 c0545dc:	9a08      	ldr	r2, [sp, #32]
 c0545de:	3301      	adds	r3, #1
 c0545e0:	429a      	cmp	r2, r3
 c0545e2:	f10a 0a0c 	add.w	sl, sl, #12
 c0545e6:	d1ec      	bne.n	c0545c2 <mbedtls_mpi_exp_mod+0x3ce>
            mpi_montmul( X, &WW, N, mm, &T );
 c0545e8:	ab0e      	add	r3, sp, #56	@ 0x38
 c0545ea:	9300      	str	r3, [sp, #0]
 c0545ec:	462a      	mov	r2, r5
 c0545ee:	4630      	mov	r0, r6
 c0545f0:	9b03      	ldr	r3, [sp, #12]
 c0545f2:	a911      	add	r1, sp, #68	@ 0x44
 c0545f4:	f7fe fdcb 	bl	c05318e <mpi_montmul>
            nbits = 0;
 c0545f8:	46c1      	mov	r9, r8
            state--;
 c0545fa:	f8dd a01c 	ldr.w	sl, [sp, #28]
 c0545fe:	e6ef      	b.n	c0543e0 <mbedtls_mpi_exp_mod+0x1ec>
        mpi_montmul( X, X, N, mm, &T );
 c054600:	462a      	mov	r2, r5
 c054602:	4631      	mov	r1, r6
 c054604:	4630      	mov	r0, r6
 c054606:	9b03      	ldr	r3, [sp, #12]
 c054608:	f8cd a000 	str.w	sl, [sp]
        wbits <<= 1;
 c05460c:	ea4f 0949 	mov.w	r9, r9, lsl #1
        mpi_montmul( X, X, N, mm, &T );
 c054610:	f7fe fdbd 	bl	c05318e <mpi_montmul>
        if( ( wbits & ( one << wsize ) ) != 0 )
 c054614:	ea1b 0f09 	tst.w	fp, r9
 c054618:	d007      	beq.n	c05462a <mbedtls_mpi_exp_mod+0x436>
            mpi_montmul( X, &W[1], N, mm, &T );
 c05461a:	462a      	mov	r2, r5
 c05461c:	4630      	mov	r0, r6
 c05461e:	9b03      	ldr	r3, [sp, #12]
 c054620:	f8cd a000 	str.w	sl, [sp]
 c054624:	a91d      	add	r1, sp, #116	@ 0x74
 c054626:	f7fe fdb2 	bl	c05318e <mpi_montmul>
    for( i = 0; i < nbits; i++ )
 c05462a:	9b04      	ldr	r3, [sp, #16]
 c05462c:	3301      	adds	r3, #1
 c05462e:	9304      	str	r3, [sp, #16]
 c054630:	e6e4      	b.n	c0543fc <mbedtls_mpi_exp_mod+0x208>
        MBEDTLS_MPI_CHK( mbedtls_mpi_safe_cond_assign( R, &T[i],
 c054632:	4604      	mov	r4, r0
 c054634:	e707      	b.n	c054446 <mbedtls_mpi_exp_mod+0x252>
        mbedtls_mpi_free( &W[i] );
 c054636:	ab1a      	add	r3, sp, #104	@ 0x68
 c054638:	fb07 3005 	mla	r0, r7, r5, r3
 c05463c:	f7fe fe61 	bl	c053302 <mbedtls_mpi_free>
    for( i = ( one << ( wsize - 1 ) ); i < ( one << wsize ); i++ )
 c054640:	3501      	adds	r5, #1
 c054642:	e707      	b.n	c054454 <mbedtls_mpi_exp_mod+0x260>
        return( MBEDTLS_ERR_MPI_BAD_INPUT_DATA );
 c054644:	f06f 0403 	mvn.w	r4, #3
 c054648:	e71a      	b.n	c054480 <mbedtls_mpi_exp_mod+0x28c>

0c05464a <mbedtls_mpi_gcd>:
{
 c05464a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    X->n = 0;
 c05464e:	2300      	movs	r3, #0
{
 c054650:	4616      	mov	r6, r2
    X->n = 0;
 c054652:	2201      	movs	r2, #1
{
 c054654:	b086      	sub	sp, #24
 c054656:	4605      	mov	r5, r0
    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &TA, A ) );
 c054658:	4668      	mov	r0, sp
{
 c05465a:	4688      	mov	r8, r1
    X->n = 0;
 c05465c:	e9cd 2300 	strd	r2, r3, [sp]
    X->s = 1;
 c054660:	e9cd 3202 	strd	r3, r2, [sp, #8]
    X->p = NULL;
 c054664:	e9cd 3304 	strd	r3, r3, [sp, #16]
    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &TA, A ) );
 c054668:	f7fe fe9f 	bl	c0533aa <mbedtls_mpi_copy>
 c05466c:	4604      	mov	r4, r0
 c05466e:	2800      	cmp	r0, #0
 c054670:	d153      	bne.n	c05471a <mbedtls_mpi_gcd+0xd0>
    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &TB, B ) );
 c054672:	4631      	mov	r1, r6
 c054674:	a803      	add	r0, sp, #12
 c054676:	f7fe fe98 	bl	c0533aa <mbedtls_mpi_copy>
 c05467a:	4604      	mov	r4, r0
 c05467c:	2800      	cmp	r0, #0
 c05467e:	d14c      	bne.n	c05471a <mbedtls_mpi_gcd+0xd0>
    lz = mbedtls_mpi_lsb( &TA );
 c054680:	4668      	mov	r0, sp
 c054682:	f7fe ff2f 	bl	c0534e4 <mbedtls_mpi_lsb>
 c054686:	4607      	mov	r7, r0
    lzt = mbedtls_mpi_lsb( &TB );
 c054688:	a803      	add	r0, sp, #12
 c05468a:	f7fe ff2b 	bl	c0534e4 <mbedtls_mpi_lsb>
    if( lzt == 0 && mbedtls_mpi_get_bit( &TB, 0 ) == 0 )
 c05468e:	4606      	mov	r6, r0
 c054690:	b950      	cbnz	r0, c0546a8 <mbedtls_mpi_gcd+0x5e>
 c054692:	4621      	mov	r1, r4
 c054694:	a803      	add	r0, sp, #12
 c054696:	f7fe feee 	bl	c053476 <mbedtls_mpi_get_bit>
 c05469a:	b928      	cbnz	r0, c0546a8 <mbedtls_mpi_gcd+0x5e>
        ret = mbedtls_mpi_copy( G, A );
 c05469c:	4641      	mov	r1, r8
    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( G, &TB ) );
 c05469e:	4628      	mov	r0, r5
 c0546a0:	f7fe fe83 	bl	c0533aa <mbedtls_mpi_copy>
 c0546a4:	4604      	mov	r4, r0
cleanup:
 c0546a6:	e038      	b.n	c05471a <mbedtls_mpi_gcd+0xd0>
    TA.s = TB.s = 1;
 c0546a8:	2301      	movs	r3, #1
 c0546aa:	9303      	str	r3, [sp, #12]
 c0546ac:	9300      	str	r3, [sp, #0]
    while( mbedtls_mpi_cmp_int( &TA, 0 ) != 0 )
 c0546ae:	2100      	movs	r1, #0
 c0546b0:	4668      	mov	r0, sp
 c0546b2:	f7ff f906 	bl	c0538c2 <mbedtls_mpi_cmp_int>
 c0546b6:	b950      	cbnz	r0, c0546ce <mbedtls_mpi_gcd+0x84>
    MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &TB, lz ) );
 c0546b8:	42b7      	cmp	r7, r6
 c0546ba:	4639      	mov	r1, r7
 c0546bc:	a803      	add	r0, sp, #12
 c0546be:	bf28      	it	cs
 c0546c0:	4631      	movcs	r1, r6
 c0546c2:	f7fe fffe 	bl	c0536c2 <mbedtls_mpi_shift_l>
 c0546c6:	4604      	mov	r4, r0
 c0546c8:	bb38      	cbnz	r0, c05471a <mbedtls_mpi_gcd+0xd0>
    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( G, &TB ) );
 c0546ca:	a903      	add	r1, sp, #12
 c0546cc:	e7e7      	b.n	c05469e <mbedtls_mpi_gcd+0x54>
        MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &TA, mbedtls_mpi_lsb( &TA ) ) );
 c0546ce:	4668      	mov	r0, sp
 c0546d0:	f7fe ff08 	bl	c0534e4 <mbedtls_mpi_lsb>
 c0546d4:	4601      	mov	r1, r0
 c0546d6:	4668      	mov	r0, sp
 c0546d8:	f7ff f843 	bl	c053762 <mbedtls_mpi_shift_r>
 c0546dc:	4604      	mov	r4, r0
 c0546de:	b9e0      	cbnz	r0, c05471a <mbedtls_mpi_gcd+0xd0>
        MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &TB, mbedtls_mpi_lsb( &TB ) ) );
 c0546e0:	a803      	add	r0, sp, #12
 c0546e2:	f7fe feff 	bl	c0534e4 <mbedtls_mpi_lsb>
 c0546e6:	4601      	mov	r1, r0
 c0546e8:	a803      	add	r0, sp, #12
 c0546ea:	f7ff f83a 	bl	c053762 <mbedtls_mpi_shift_r>
 c0546ee:	4604      	mov	r4, r0
 c0546f0:	b998      	cbnz	r0, c05471a <mbedtls_mpi_gcd+0xd0>
        if( mbedtls_mpi_cmp_mpi( &TA, &TB ) >= 0 )
 c0546f2:	4668      	mov	r0, sp
 c0546f4:	a903      	add	r1, sp, #12
 c0546f6:	f7ff f8a1 	bl	c05383c <mbedtls_mpi_cmp_mpi>
 c0546fa:	2800      	cmp	r0, #0
 c0546fc:	db17      	blt.n	c05472e <mbedtls_mpi_gcd+0xe4>
            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_abs( &TA, &TA, &TB ) );
 c0546fe:	4669      	mov	r1, sp
 c054700:	4668      	mov	r0, sp
 c054702:	aa03      	add	r2, sp, #12
 c054704:	f7ff f94a 	bl	c05399c <mbedtls_mpi_sub_abs>
 c054708:	4604      	mov	r4, r0
 c05470a:	b930      	cbnz	r0, c05471a <mbedtls_mpi_gcd+0xd0>
            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &TA, 1 ) );
 c05470c:	2101      	movs	r1, #1
 c05470e:	4668      	mov	r0, sp
            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &TB, 1 ) );
 c054710:	f7ff f827 	bl	c053762 <mbedtls_mpi_shift_r>
 c054714:	4604      	mov	r4, r0
 c054716:	2800      	cmp	r0, #0
 c054718:	d0c9      	beq.n	c0546ae <mbedtls_mpi_gcd+0x64>
    mbedtls_mpi_free( &TA ); mbedtls_mpi_free( &TB );
 c05471a:	4668      	mov	r0, sp
 c05471c:	f7fe fdf1 	bl	c053302 <mbedtls_mpi_free>
 c054720:	a803      	add	r0, sp, #12
 c054722:	f7fe fdee 	bl	c053302 <mbedtls_mpi_free>
}
 c054726:	4620      	mov	r0, r4
 c054728:	b006      	add	sp, #24
 c05472a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_abs( &TB, &TB, &TA ) );
 c05472e:	a903      	add	r1, sp, #12
 c054730:	466a      	mov	r2, sp
 c054732:	4608      	mov	r0, r1
 c054734:	f7ff f932 	bl	c05399c <mbedtls_mpi_sub_abs>
 c054738:	4604      	mov	r4, r0
 c05473a:	2800      	cmp	r0, #0
 c05473c:	d1ed      	bne.n	c05471a <mbedtls_mpi_gcd+0xd0>
            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &TB, 1 ) );
 c05473e:	2101      	movs	r1, #1
 c054740:	a803      	add	r0, sp, #12
 c054742:	e7e5      	b.n	c054710 <mbedtls_mpi_gcd+0xc6>

0c054744 <mbedtls_mpi_fill_random>:
{
 c054744:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 c054748:	460c      	mov	r4, r1
    size_t const limbs = CHARS_TO_LIMBS( size );
 c05474a:	f011 0103 	ands.w	r1, r1, #3
 c05474e:	bf18      	it	ne
 c054750:	2101      	movne	r1, #1
    MBEDTLS_MPI_CHK( mbedtls_mpi_resize_clear( X, limbs ) );
 c054752:	eb01 0194 	add.w	r1, r1, r4, lsr #2
{
 c054756:	4605      	mov	r5, r0
 c054758:	4616      	mov	r6, r2
 c05475a:	461f      	mov	r7, r3
    MBEDTLS_MPI_CHK( mbedtls_mpi_resize_clear( X, limbs ) );
 c05475c:	f7fe fe0a 	bl	c053374 <mbedtls_mpi_resize_clear>
 c054760:	b940      	cbnz	r0, c054774 <mbedtls_mpi_fill_random+0x30>
    if( size == 0 )
 c054762:	b13c      	cbz	r4, c054774 <mbedtls_mpi_fill_random+0x30>
    ret = mpi_fill_random_internal( X, size, f_rng, p_rng );
 c054764:	463b      	mov	r3, r7
 c054766:	4632      	mov	r2, r6
 c054768:	4621      	mov	r1, r4
 c05476a:	4628      	mov	r0, r5
}
 c05476c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    ret = mpi_fill_random_internal( X, size, f_rng, p_rng );
 c054770:	f7fe bd8f 	b.w	c053292 <mpi_fill_random_internal>
}
 c054774:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0c054778 <mpi_miller_rabin>:
 * Miller-Rabin pseudo-primality test  (HAC 4.24)
 */
static int mpi_miller_rabin( const mbedtls_mpi *X, size_t rounds,
                             int (*f_rng)(void *, unsigned char *, size_t),
                             void *p_rng )
{
 c054778:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c05477c:	b097      	sub	sp, #92	@ 0x5c
 c05477e:	e9cd 2303 	strd	r2, r3, [sp, #12]
    X->n = 0;
 c054782:	2300      	movs	r3, #0
 c054784:	2201      	movs	r2, #1
{
 c054786:	4605      	mov	r5, r0
 c054788:	460f      	mov	r7, r1

    /*
     * W = |X| - 1
     * R = W >> lsb( W )
     */
    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( &W, X, 1 ) );
 c05478a:	4601      	mov	r1, r0
 c05478c:	a807      	add	r0, sp, #28
    X->n = 0;
 c05478e:	e9cd 2307 	strd	r2, r3, [sp, #28]
    X->s = 1;
 c054792:	e9cd 3209 	strd	r3, r2, [sp, #36]	@ 0x24
    X->p = NULL;
 c054796:	e9cd 330b 	strd	r3, r3, [sp, #44]	@ 0x2c
    X->n = 0;
 c05479a:	e9cd 230d 	strd	r2, r3, [sp, #52]	@ 0x34
    X->s = 1;
 c05479e:	e9cd 320f 	strd	r3, r2, [sp, #60]	@ 0x3c
    X->p = NULL;
 c0547a2:	e9cd 3311 	strd	r3, r3, [sp, #68]	@ 0x44
    X->n = 0;
 c0547a6:	e9cd 2313 	strd	r2, r3, [sp, #76]	@ 0x4c
    X->p = NULL;
 c0547aa:	9315      	str	r3, [sp, #84]	@ 0x54
    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( &W, X, 1 ) );
 c0547ac:	f7ff f9c2 	bl	c053b34 <mbedtls_mpi_sub_int>
 c0547b0:	4604      	mov	r4, r0
 c0547b2:	2800      	cmp	r0, #0
 c0547b4:	d141      	bne.n	c05483a <mpi_miller_rabin+0xc2>
    s = mbedtls_mpi_lsb( &W );
 c0547b6:	a807      	add	r0, sp, #28
 c0547b8:	f7fe fe94 	bl	c0534e4 <mbedtls_mpi_lsb>
    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &R, &W ) );
 c0547bc:	a907      	add	r1, sp, #28
    s = mbedtls_mpi_lsb( &W );
 c0547be:	4606      	mov	r6, r0
    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &R, &W ) );
 c0547c0:	a80a      	add	r0, sp, #40	@ 0x28
 c0547c2:	f7fe fdf2 	bl	c0533aa <mbedtls_mpi_copy>
 c0547c6:	4604      	mov	r4, r0
 c0547c8:	2800      	cmp	r0, #0
 c0547ca:	d136      	bne.n	c05483a <mpi_miller_rabin+0xc2>
    MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &R, s ) );
 c0547cc:	4631      	mov	r1, r6
 c0547ce:	a80a      	add	r0, sp, #40	@ 0x28
 c0547d0:	f7fe ffc7 	bl	c053762 <mbedtls_mpi_shift_r>
 c0547d4:	4604      	mov	r4, r0
 c0547d6:	bb80      	cbnz	r0, c05483a <mpi_miller_rabin+0xc2>

    for( i = 0; i < rounds; i++ )
 c0547d8:	4680      	mov	r8, r0
            MBEDTLS_MPI_CHK( mbedtls_mpi_fill_random( &A, X->n * ciL, f_rng, p_rng ) );

            j = mbedtls_mpi_bitlen( &A );
            k = mbedtls_mpi_bitlen( &W );
            if (j > k) {
                A.p[A.n - 1] &= ( (mbedtls_mpi_uint) 1 << ( k - ( A.n - 1 ) * biL - 1 ) ) - 1;
 c0547da:	f06f 4a40 	mvn.w	sl, #3221225472	@ 0xc0000000
    for( i = 0; i < rounds; i++ )
 c0547de:	45b8      	cmp	r8, r7
 c0547e0:	d02b      	beq.n	c05483a <mpi_miller_rabin+0xc2>
 c0547e2:	f04f 0920 	mov.w	r9, #32
                A.p[A.n - 1] &= ( (mbedtls_mpi_uint) 1 << ( k - ( A.n - 1 ) * biL - 1 ) ) - 1;
 c0547e6:	f04f 3bff 	mov.w	fp, #4294967295	@ 0xffffffff
            MBEDTLS_MPI_CHK( mbedtls_mpi_fill_random( &A, X->n * ciL, f_rng, p_rng ) );
 c0547ea:	e9dd 2303 	ldrd	r2, r3, [sp, #12]
 c0547ee:	6869      	ldr	r1, [r5, #4]
 c0547f0:	a810      	add	r0, sp, #64	@ 0x40
 c0547f2:	0089      	lsls	r1, r1, #2
 c0547f4:	f7ff ffa6 	bl	c054744 <mbedtls_mpi_fill_random>
 c0547f8:	2800      	cmp	r0, #0
 c0547fa:	d17f      	bne.n	c0548fc <mpi_miller_rabin+0x184>
            j = mbedtls_mpi_bitlen( &A );
 c0547fc:	a810      	add	r0, sp, #64	@ 0x40
 c0547fe:	f7fe fe8e 	bl	c05351e <mbedtls_mpi_bitlen>
 c054802:	9005      	str	r0, [sp, #20]
            k = mbedtls_mpi_bitlen( &W );
 c054804:	a807      	add	r0, sp, #28
 c054806:	f7fe fe8a 	bl	c05351e <mbedtls_mpi_bitlen>
            if (j > k) {
 c05480a:	9b05      	ldr	r3, [sp, #20]
 c05480c:	4283      	cmp	r3, r0
 c05480e:	d90f      	bls.n	c054830 <mpi_miller_rabin+0xb8>
                A.p[A.n - 1] &= ( (mbedtls_mpi_uint) 1 << ( k - ( A.n - 1 ) * biL - 1 ) ) - 1;
 c054810:	9911      	ldr	r1, [sp, #68]	@ 0x44
 c054812:	9b12      	ldr	r3, [sp, #72]	@ 0x48
 c054814:	eb01 020a 	add.w	r2, r1, sl
 c054818:	3901      	subs	r1, #1
 c05481a:	eba0 1041 	sub.w	r0, r0, r1, lsl #5
 c05481e:	3801      	subs	r0, #1
 c054820:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 c054824:	fa0b f000 	lsl.w	r0, fp, r0
 c054828:	ea21 0100 	bic.w	r1, r1, r0
 c05482c:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
            }

            if (count++ > 30) {
 c054830:	f1b9 0901 	subs.w	r9, r9, #1
 c054834:	d114      	bne.n	c054860 <mpi_miller_rabin+0xe8>
                ret = MBEDTLS_ERR_MPI_NOT_ACCEPTABLE;
 c054836:	f06f 040d 	mvn.w	r4, #13
            break;
        }
    }

cleanup:
    mbedtls_mpi_free( &W ); mbedtls_mpi_free( &R );
 c05483a:	a807      	add	r0, sp, #28
 c05483c:	f7fe fd61 	bl	c053302 <mbedtls_mpi_free>
 c054840:	a80a      	add	r0, sp, #40	@ 0x28
 c054842:	f7fe fd5e 	bl	c053302 <mbedtls_mpi_free>
    mbedtls_mpi_free( &T ); mbedtls_mpi_free( &A );
 c054846:	a80d      	add	r0, sp, #52	@ 0x34
 c054848:	f7fe fd5b 	bl	c053302 <mbedtls_mpi_free>
 c05484c:	a810      	add	r0, sp, #64	@ 0x40
 c05484e:	f7fe fd58 	bl	c053302 <mbedtls_mpi_free>
    mbedtls_mpi_free( &RR );
 c054852:	a813      	add	r0, sp, #76	@ 0x4c
 c054854:	f7fe fd55 	bl	c053302 <mbedtls_mpi_free>

    return( ret );
}
 c054858:	4620      	mov	r0, r4
 c05485a:	b017      	add	sp, #92	@ 0x5c
 c05485c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        } while ( mbedtls_mpi_cmp_mpi( &A, &W ) >= 0 ||
 c054860:	a907      	add	r1, sp, #28
 c054862:	a810      	add	r0, sp, #64	@ 0x40
 c054864:	f7fe ffea 	bl	c05383c <mbedtls_mpi_cmp_mpi>
 c054868:	2800      	cmp	r0, #0
 c05486a:	dabe      	bge.n	c0547ea <mpi_miller_rabin+0x72>
                  mbedtls_mpi_cmp_int( &A, 1 )  <= 0    );
 c05486c:	2101      	movs	r1, #1
 c05486e:	a810      	add	r0, sp, #64	@ 0x40
 c054870:	f7ff f827 	bl	c0538c2 <mbedtls_mpi_cmp_int>
        } while ( mbedtls_mpi_cmp_mpi( &A, &W ) >= 0 ||
 c054874:	2800      	cmp	r0, #0
 c054876:	ddb8      	ble.n	c0547ea <mpi_miller_rabin+0x72>
        MBEDTLS_MPI_CHK( mbedtls_mpi_exp_mod( &A, &A, &R, X, &RR ) );
 c054878:	ab13      	add	r3, sp, #76	@ 0x4c
 c05487a:	a910      	add	r1, sp, #64	@ 0x40
 c05487c:	9300      	str	r3, [sp, #0]
 c05487e:	4608      	mov	r0, r1
 c054880:	462b      	mov	r3, r5
 c054882:	aa0a      	add	r2, sp, #40	@ 0x28
 c054884:	f7ff fcb6 	bl	c0541f4 <mbedtls_mpi_exp_mod>
 c054888:	2800      	cmp	r0, #0
 c05488a:	d137      	bne.n	c0548fc <mpi_miller_rabin+0x184>
        if( mbedtls_mpi_cmp_mpi( &A, &W ) == 0 ||
 c05488c:	a907      	add	r1, sp, #28
 c05488e:	a810      	add	r0, sp, #64	@ 0x40
 c054890:	f7fe ffd4 	bl	c05383c <mbedtls_mpi_cmp_mpi>
 c054894:	b910      	cbnz	r0, c05489c <mpi_miller_rabin+0x124>
    for( i = 0; i < rounds; i++ )
 c054896:	f108 0801 	add.w	r8, r8, #1
 c05489a:	e7a0      	b.n	c0547de <mpi_miller_rabin+0x66>
            mbedtls_mpi_cmp_int( &A,  1 ) == 0 )
 c05489c:	2101      	movs	r1, #1
 c05489e:	a810      	add	r0, sp, #64	@ 0x40
 c0548a0:	f7ff f80f 	bl	c0538c2 <mbedtls_mpi_cmp_int>
        if( mbedtls_mpi_cmp_mpi( &A, &W ) == 0 ||
 c0548a4:	2800      	cmp	r0, #0
 c0548a6:	d0f6      	beq.n	c054896 <mpi_miller_rabin+0x11e>
        j = 1;
 c0548a8:	f04f 0901 	mov.w	r9, #1
        while( j < s && mbedtls_mpi_cmp_mpi( &A, &W ) != 0 )
 c0548ac:	a907      	add	r1, sp, #28
 c0548ae:	a810      	add	r0, sp, #64	@ 0x40
 c0548b0:	f7fe ffc4 	bl	c05383c <mbedtls_mpi_cmp_mpi>
 c0548b4:	45b1      	cmp	r9, r6
 c0548b6:	d211      	bcs.n	c0548dc <mpi_miller_rabin+0x164>
 c0548b8:	b1b0      	cbz	r0, c0548e8 <mpi_miller_rabin+0x170>
            MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T, &A, &A ) );
 c0548ba:	aa10      	add	r2, sp, #64	@ 0x40
 c0548bc:	4611      	mov	r1, r2
 c0548be:	a80d      	add	r0, sp, #52	@ 0x34
 c0548c0:	f7ff f94e 	bl	c053b60 <mbedtls_mpi_mul_mpi>
 c0548c4:	b9d0      	cbnz	r0, c0548fc <mpi_miller_rabin+0x184>
            MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( &A, &T, X  ) );
 c0548c6:	462a      	mov	r2, r5
 c0548c8:	a90d      	add	r1, sp, #52	@ 0x34
 c0548ca:	a810      	add	r0, sp, #64	@ 0x40
 c0548cc:	f7ff fc05 	bl	c0540da <mbedtls_mpi_mod_mpi>
 c0548d0:	b9a0      	cbnz	r0, c0548fc <mpi_miller_rabin+0x184>
            if( mbedtls_mpi_cmp_int( &A, 1 ) == 0 )
 c0548d2:	2101      	movs	r1, #1
 c0548d4:	a810      	add	r0, sp, #64	@ 0x40
 c0548d6:	f7fe fff4 	bl	c0538c2 <mbedtls_mpi_cmp_int>
 c0548da:	b960      	cbnz	r0, c0548f6 <mpi_miller_rabin+0x17e>
        if( mbedtls_mpi_cmp_mpi( &A, &W ) != 0 ||
 c0548dc:	a907      	add	r1, sp, #28
 c0548de:	a810      	add	r0, sp, #64	@ 0x40
 c0548e0:	f7fe ffac 	bl	c05383c <mbedtls_mpi_cmp_mpi>
 c0548e4:	2800      	cmp	r0, #0
 c0548e6:	d1a6      	bne.n	c054836 <mpi_miller_rabin+0xbe>
            mbedtls_mpi_cmp_int( &A,  1 ) == 0 )
 c0548e8:	2101      	movs	r1, #1
 c0548ea:	a810      	add	r0, sp, #64	@ 0x40
 c0548ec:	f7fe ffe9 	bl	c0538c2 <mbedtls_mpi_cmp_int>
        if( mbedtls_mpi_cmp_mpi( &A, &W ) != 0 ||
 c0548f0:	2800      	cmp	r0, #0
 c0548f2:	d1d0      	bne.n	c054896 <mpi_miller_rabin+0x11e>
 c0548f4:	e79f      	b.n	c054836 <mpi_miller_rabin+0xbe>
            j++;
 c0548f6:	f109 0901 	add.w	r9, r9, #1
 c0548fa:	e7d7      	b.n	c0548ac <mpi_miller_rabin+0x134>
 c0548fc:	4604      	mov	r4, r0
 c0548fe:	e79c      	b.n	c05483a <mpi_miller_rabin+0xc2>

0c054900 <mbedtls_mpi_inv_mod>:
{
 c054900:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 c054904:	4606      	mov	r6, r0
 c054906:	4688      	mov	r8, r1
    if( mbedtls_mpi_cmp_int( N, 1 ) <= 0 )
 c054908:	4610      	mov	r0, r2
 c05490a:	2101      	movs	r1, #1
{
 c05490c:	b09c      	sub	sp, #112	@ 0x70
 c05490e:	4615      	mov	r5, r2
    if( mbedtls_mpi_cmp_int( N, 1 ) <= 0 )
 c054910:	f7fe ffd7 	bl	c0538c2 <mbedtls_mpi_cmp_int>
 c054914:	2800      	cmp	r0, #0
 c054916:	f340 814c 	ble.w	c054bb2 <mbedtls_mpi_inv_mod+0x2b2>
    X->n = 0;
 c05491a:	2300      	movs	r3, #0
 c05491c:	2701      	movs	r7, #1
    MBEDTLS_MPI_CHK( mbedtls_mpi_gcd( &G, A, N ) );
 c05491e:	462a      	mov	r2, r5
 c054920:	4641      	mov	r1, r8
 c054922:	a801      	add	r0, sp, #4
    X->n = 0;
 c054924:	e9cd 7304 	strd	r7, r3, [sp, #16]
    X->s = 1;
 c054928:	e9cd 3706 	strd	r3, r7, [sp, #24]
    X->p = NULL;
 c05492c:	e9cd 3308 	strd	r3, r3, [sp, #32]
    X->n = 0;
 c054930:	e9cd 730a 	strd	r7, r3, [sp, #40]	@ 0x28
    X->s = 1;
 c054934:	e9cd 370c 	strd	r3, r7, [sp, #48]	@ 0x30
    X->p = NULL;
 c054938:	e9cd 330e 	strd	r3, r3, [sp, #56]	@ 0x38
    X->n = 0;
 c05493c:	e9cd 7301 	strd	r7, r3, [sp, #4]
 c054940:	e9cd 7310 	strd	r7, r3, [sp, #64]	@ 0x40
    X->s = 1;
 c054944:	e9cd 3712 	strd	r3, r7, [sp, #72]	@ 0x48
    X->p = NULL;
 c054948:	e9cd 3314 	strd	r3, r3, [sp, #80]	@ 0x50
    X->n = 0;
 c05494c:	e9cd 7316 	strd	r7, r3, [sp, #88]	@ 0x58
    X->s = 1;
 c054950:	e9cd 3718 	strd	r3, r7, [sp, #96]	@ 0x60
    X->p = NULL;
 c054954:	e9cd 331a 	strd	r3, r3, [sp, #104]	@ 0x68
 c054958:	9303      	str	r3, [sp, #12]
    MBEDTLS_MPI_CHK( mbedtls_mpi_gcd( &G, A, N ) );
 c05495a:	f7ff fe76 	bl	c05464a <mbedtls_mpi_gcd>
 c05495e:	4604      	mov	r4, r0
 c054960:	2800      	cmp	r0, #0
 c054962:	f040 8097 	bne.w	c054a94 <mbedtls_mpi_inv_mod+0x194>
    if( mbedtls_mpi_cmp_int( &G, 1 ) != 0 )
 c054966:	4639      	mov	r1, r7
 c054968:	a801      	add	r0, sp, #4
 c05496a:	f7fe ffaa 	bl	c0538c2 <mbedtls_mpi_cmp_int>
 c05496e:	2800      	cmp	r0, #0
 c054970:	f040 811c 	bne.w	c054bac <mbedtls_mpi_inv_mod+0x2ac>
    MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( &TA, A, N ) );
 c054974:	462a      	mov	r2, r5
 c054976:	4641      	mov	r1, r8
 c054978:	a804      	add	r0, sp, #16
 c05497a:	f7ff fbae 	bl	c0540da <mbedtls_mpi_mod_mpi>
 c05497e:	4604      	mov	r4, r0
 c054980:	2800      	cmp	r0, #0
 c054982:	f040 8087 	bne.w	c054a94 <mbedtls_mpi_inv_mod+0x194>
    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &TU, &TA ) );
 c054986:	a904      	add	r1, sp, #16
 c054988:	a807      	add	r0, sp, #28
 c05498a:	f7fe fd0e 	bl	c0533aa <mbedtls_mpi_copy>
 c05498e:	4604      	mov	r4, r0
 c054990:	2800      	cmp	r0, #0
 c054992:	d17f      	bne.n	c054a94 <mbedtls_mpi_inv_mod+0x194>
    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &TB, N ) );
 c054994:	4629      	mov	r1, r5
 c054996:	a810      	add	r0, sp, #64	@ 0x40
 c054998:	f7fe fd07 	bl	c0533aa <mbedtls_mpi_copy>
 c05499c:	4604      	mov	r4, r0
 c05499e:	2800      	cmp	r0, #0
 c0549a0:	d178      	bne.n	c054a94 <mbedtls_mpi_inv_mod+0x194>
    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &TV, N ) );
 c0549a2:	4629      	mov	r1, r5
 c0549a4:	a813      	add	r0, sp, #76	@ 0x4c
 c0549a6:	f7fe fd00 	bl	c0533aa <mbedtls_mpi_copy>
 c0549aa:	4604      	mov	r4, r0
 c0549ac:	2800      	cmp	r0, #0
 c0549ae:	d171      	bne.n	c054a94 <mbedtls_mpi_inv_mod+0x194>
    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &U1, 1 ) );
 c0549b0:	4639      	mov	r1, r7
 c0549b2:	a80a      	add	r0, sp, #40	@ 0x28
 c0549b4:	f7fe fd43 	bl	c05343e <mbedtls_mpi_lset>
 c0549b8:	4604      	mov	r4, r0
 c0549ba:	2800      	cmp	r0, #0
 c0549bc:	d16a      	bne.n	c054a94 <mbedtls_mpi_inv_mod+0x194>
    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &U2, 0 ) );
 c0549be:	4601      	mov	r1, r0
 c0549c0:	a80d      	add	r0, sp, #52	@ 0x34
 c0549c2:	f7fe fd3c 	bl	c05343e <mbedtls_mpi_lset>
 c0549c6:	4604      	mov	r4, r0
 c0549c8:	2800      	cmp	r0, #0
 c0549ca:	d163      	bne.n	c054a94 <mbedtls_mpi_inv_mod+0x194>
    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &V1, 0 ) );
 c0549cc:	4601      	mov	r1, r0
 c0549ce:	a816      	add	r0, sp, #88	@ 0x58
 c0549d0:	f7fe fd35 	bl	c05343e <mbedtls_mpi_lset>
 c0549d4:	4604      	mov	r4, r0
 c0549d6:	2800      	cmp	r0, #0
 c0549d8:	d15c      	bne.n	c054a94 <mbedtls_mpi_inv_mod+0x194>
    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &V2, 1 ) );
 c0549da:	4639      	mov	r1, r7
 c0549dc:	a819      	add	r0, sp, #100	@ 0x64
 c0549de:	f7fe fd2e 	bl	c05343e <mbedtls_mpi_lset>
            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &U2, 1 ) );
 c0549e2:	4604      	mov	r4, r0
 c0549e4:	2800      	cmp	r0, #0
 c0549e6:	d155      	bne.n	c054a94 <mbedtls_mpi_inv_mod+0x194>
        while( ( TU.p[0] & 1 ) == 0 )
 c0549e8:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 c0549ea:	681b      	ldr	r3, [r3, #0]
 c0549ec:	07d8      	lsls	r0, r3, #31
 c0549ee:	d53c      	bpl.n	c054a6a <mbedtls_mpi_inv_mod+0x16a>
        while( ( TV.p[0] & 1 ) == 0 )
 c0549f0:	9b15      	ldr	r3, [sp, #84]	@ 0x54
 c0549f2:	681b      	ldr	r3, [r3, #0]
 c0549f4:	07db      	lsls	r3, r3, #31
 c0549f6:	f140 8082 	bpl.w	c054afe <mbedtls_mpi_inv_mod+0x1fe>
        if( mbedtls_mpi_cmp_mpi( &TU, &TV ) >= 0 )
 c0549fa:	a913      	add	r1, sp, #76	@ 0x4c
 c0549fc:	a807      	add	r0, sp, #28
 c0549fe:	f7fe ff1d 	bl	c05383c <mbedtls_mpi_cmp_mpi>
 c054a02:	2800      	cmp	r0, #0
 c054a04:	f2c0 80ab 	blt.w	c054b5e <mbedtls_mpi_inv_mod+0x25e>
            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &TU, &TU, &TV ) );
 c054a08:	a907      	add	r1, sp, #28
 c054a0a:	4608      	mov	r0, r1
 c054a0c:	aa13      	add	r2, sp, #76	@ 0x4c
 c054a0e:	f7ff f857 	bl	c053ac0 <mbedtls_mpi_sub_mpi>
 c054a12:	4604      	mov	r4, r0
 c054a14:	2800      	cmp	r0, #0
 c054a16:	d13d      	bne.n	c054a94 <mbedtls_mpi_inv_mod+0x194>
            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &U1, &U1, &V1 ) );
 c054a18:	a90a      	add	r1, sp, #40	@ 0x28
 c054a1a:	4608      	mov	r0, r1
 c054a1c:	aa16      	add	r2, sp, #88	@ 0x58
 c054a1e:	f7ff f84f 	bl	c053ac0 <mbedtls_mpi_sub_mpi>
 c054a22:	4604      	mov	r4, r0
 c054a24:	2800      	cmp	r0, #0
 c054a26:	d135      	bne.n	c054a94 <mbedtls_mpi_inv_mod+0x194>
            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &U2, &U2, &V2 ) );
 c054a28:	aa19      	add	r2, sp, #100	@ 0x64
 c054a2a:	a90d      	add	r1, sp, #52	@ 0x34
 c054a2c:	4608      	mov	r0, r1
 c054a2e:	f7ff f847 	bl	c053ac0 <mbedtls_mpi_sub_mpi>
 c054a32:	4604      	mov	r4, r0
 c054a34:	bb70      	cbnz	r0, c054a94 <mbedtls_mpi_inv_mod+0x194>
    while( mbedtls_mpi_cmp_int( &TU, 0 ) != 0 );
 c054a36:	2100      	movs	r1, #0
 c054a38:	a807      	add	r0, sp, #28
 c054a3a:	f7fe ff42 	bl	c0538c2 <mbedtls_mpi_cmp_int>
 c054a3e:	2800      	cmp	r0, #0
 c054a40:	d1d2      	bne.n	c0549e8 <mbedtls_mpi_inv_mod+0xe8>
    while( mbedtls_mpi_cmp_int( &V1, 0 ) < 0 )
 c054a42:	2100      	movs	r1, #0
 c054a44:	a816      	add	r0, sp, #88	@ 0x58
 c054a46:	f7fe ff3c 	bl	c0538c2 <mbedtls_mpi_cmp_int>
 c054a4a:	2800      	cmp	r0, #0
 c054a4c:	f2c0 809a 	blt.w	c054b84 <mbedtls_mpi_inv_mod+0x284>
    while( mbedtls_mpi_cmp_mpi( &V1, N ) >= 0 )
 c054a50:	4629      	mov	r1, r5
 c054a52:	a816      	add	r0, sp, #88	@ 0x58
 c054a54:	f7fe fef2 	bl	c05383c <mbedtls_mpi_cmp_mpi>
 c054a58:	2800      	cmp	r0, #0
 c054a5a:	f280 809d 	bge.w	c054b98 <mbedtls_mpi_inv_mod+0x298>
    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( X, &V1 ) );
 c054a5e:	4630      	mov	r0, r6
 c054a60:	a916      	add	r1, sp, #88	@ 0x58
 c054a62:	f7fe fca2 	bl	c0533aa <mbedtls_mpi_copy>
 c054a66:	4604      	mov	r4, r0
cleanup:
 c054a68:	e014      	b.n	c054a94 <mbedtls_mpi_inv_mod+0x194>
            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &TU, 1 ) );
 c054a6a:	2101      	movs	r1, #1
 c054a6c:	a807      	add	r0, sp, #28
 c054a6e:	f7fe fe78 	bl	c053762 <mbedtls_mpi_shift_r>
 c054a72:	4604      	mov	r4, r0
 c054a74:	b970      	cbnz	r0, c054a94 <mbedtls_mpi_inv_mod+0x194>
            if( ( U1.p[0] & 1 ) != 0 || ( U2.p[0] & 1 ) != 0 )
 c054a76:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
 c054a78:	681b      	ldr	r3, [r3, #0]
 c054a7a:	07df      	lsls	r7, r3, #31
 c054a7c:	d429      	bmi.n	c054ad2 <mbedtls_mpi_inv_mod+0x1d2>
 c054a7e:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
 c054a80:	681b      	ldr	r3, [r3, #0]
 c054a82:	07dc      	lsls	r4, r3, #31
 c054a84:	d425      	bmi.n	c054ad2 <mbedtls_mpi_inv_mod+0x1d2>
            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &U1, 1 ) );
 c054a86:	2101      	movs	r1, #1
 c054a88:	a80a      	add	r0, sp, #40	@ 0x28
 c054a8a:	f7fe fe6a 	bl	c053762 <mbedtls_mpi_shift_r>
 c054a8e:	4604      	mov	r4, r0
 c054a90:	2800      	cmp	r0, #0
 c054a92:	d02f      	beq.n	c054af4 <mbedtls_mpi_inv_mod+0x1f4>
    mbedtls_mpi_free( &TA ); mbedtls_mpi_free( &TU ); mbedtls_mpi_free( &U1 ); mbedtls_mpi_free( &U2 );
 c054a94:	a804      	add	r0, sp, #16
 c054a96:	f7fe fc34 	bl	c053302 <mbedtls_mpi_free>
 c054a9a:	a807      	add	r0, sp, #28
 c054a9c:	f7fe fc31 	bl	c053302 <mbedtls_mpi_free>
 c054aa0:	a80a      	add	r0, sp, #40	@ 0x28
 c054aa2:	f7fe fc2e 	bl	c053302 <mbedtls_mpi_free>
 c054aa6:	a80d      	add	r0, sp, #52	@ 0x34
 c054aa8:	f7fe fc2b 	bl	c053302 <mbedtls_mpi_free>
    mbedtls_mpi_free( &G ); mbedtls_mpi_free( &TB ); mbedtls_mpi_free( &TV );
 c054aac:	a801      	add	r0, sp, #4
 c054aae:	f7fe fc28 	bl	c053302 <mbedtls_mpi_free>
 c054ab2:	a810      	add	r0, sp, #64	@ 0x40
 c054ab4:	f7fe fc25 	bl	c053302 <mbedtls_mpi_free>
 c054ab8:	a813      	add	r0, sp, #76	@ 0x4c
 c054aba:	f7fe fc22 	bl	c053302 <mbedtls_mpi_free>
    mbedtls_mpi_free( &V1 ); mbedtls_mpi_free( &V2 );
 c054abe:	a816      	add	r0, sp, #88	@ 0x58
 c054ac0:	f7fe fc1f 	bl	c053302 <mbedtls_mpi_free>
 c054ac4:	a819      	add	r0, sp, #100	@ 0x64
 c054ac6:	f7fe fc1c 	bl	c053302 <mbedtls_mpi_free>
}
 c054aca:	4620      	mov	r0, r4
 c054acc:	b01c      	add	sp, #112	@ 0x70
 c054ace:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
                MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &U1, &U1, &TB ) );
 c054ad2:	a90a      	add	r1, sp, #40	@ 0x28
 c054ad4:	4608      	mov	r0, r1
 c054ad6:	aa10      	add	r2, sp, #64	@ 0x40
 c054ad8:	f7fe ffcf 	bl	c053a7a <mbedtls_mpi_add_mpi>
 c054adc:	4604      	mov	r4, r0
 c054ade:	2800      	cmp	r0, #0
 c054ae0:	d1d8      	bne.n	c054a94 <mbedtls_mpi_inv_mod+0x194>
                MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &U2, &U2, &TA ) );
 c054ae2:	a90d      	add	r1, sp, #52	@ 0x34
 c054ae4:	4608      	mov	r0, r1
 c054ae6:	aa04      	add	r2, sp, #16
 c054ae8:	f7fe ffea 	bl	c053ac0 <mbedtls_mpi_sub_mpi>
 c054aec:	4604      	mov	r4, r0
 c054aee:	2800      	cmp	r0, #0
 c054af0:	d0c9      	beq.n	c054a86 <mbedtls_mpi_inv_mod+0x186>
 c054af2:	e7cf      	b.n	c054a94 <mbedtls_mpi_inv_mod+0x194>
            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &U2, 1 ) );
 c054af4:	2101      	movs	r1, #1
 c054af6:	a80d      	add	r0, sp, #52	@ 0x34
 c054af8:	f7fe fe33 	bl	c053762 <mbedtls_mpi_shift_r>
 c054afc:	e771      	b.n	c0549e2 <mbedtls_mpi_inv_mod+0xe2>
            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &TV, 1 ) );
 c054afe:	2101      	movs	r1, #1
 c054b00:	a813      	add	r0, sp, #76	@ 0x4c
 c054b02:	f7fe fe2e 	bl	c053762 <mbedtls_mpi_shift_r>
 c054b06:	4604      	mov	r4, r0
 c054b08:	2800      	cmp	r0, #0
 c054b0a:	d1c3      	bne.n	c054a94 <mbedtls_mpi_inv_mod+0x194>
            if( ( V1.p[0] & 1 ) != 0 || ( V2.p[0] & 1 ) != 0 )
 c054b0c:	9b18      	ldr	r3, [sp, #96]	@ 0x60
 c054b0e:	681b      	ldr	r3, [r3, #0]
 c054b10:	07d9      	lsls	r1, r3, #31
 c054b12:	d413      	bmi.n	c054b3c <mbedtls_mpi_inv_mod+0x23c>
 c054b14:	9b1b      	ldr	r3, [sp, #108]	@ 0x6c
 c054b16:	681b      	ldr	r3, [r3, #0]
 c054b18:	07da      	lsls	r2, r3, #31
 c054b1a:	d40f      	bmi.n	c054b3c <mbedtls_mpi_inv_mod+0x23c>
            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &V1, 1 ) );
 c054b1c:	2101      	movs	r1, #1
 c054b1e:	a816      	add	r0, sp, #88	@ 0x58
 c054b20:	f7fe fe1f 	bl	c053762 <mbedtls_mpi_shift_r>
 c054b24:	4604      	mov	r4, r0
 c054b26:	2800      	cmp	r0, #0
 c054b28:	d1b4      	bne.n	c054a94 <mbedtls_mpi_inv_mod+0x194>
            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &V2, 1 ) );
 c054b2a:	2101      	movs	r1, #1
 c054b2c:	a819      	add	r0, sp, #100	@ 0x64
 c054b2e:	f7fe fe18 	bl	c053762 <mbedtls_mpi_shift_r>
 c054b32:	4604      	mov	r4, r0
 c054b34:	2800      	cmp	r0, #0
 c054b36:	f43f af5b 	beq.w	c0549f0 <mbedtls_mpi_inv_mod+0xf0>
 c054b3a:	e7ab      	b.n	c054a94 <mbedtls_mpi_inv_mod+0x194>
                MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &V1, &V1, &TB ) );
 c054b3c:	a916      	add	r1, sp, #88	@ 0x58
 c054b3e:	4608      	mov	r0, r1
 c054b40:	aa10      	add	r2, sp, #64	@ 0x40
 c054b42:	f7fe ff9a 	bl	c053a7a <mbedtls_mpi_add_mpi>
 c054b46:	4604      	mov	r4, r0
 c054b48:	2800      	cmp	r0, #0
 c054b4a:	d1a3      	bne.n	c054a94 <mbedtls_mpi_inv_mod+0x194>
                MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &V2, &V2, &TA ) );
 c054b4c:	a919      	add	r1, sp, #100	@ 0x64
 c054b4e:	4608      	mov	r0, r1
 c054b50:	aa04      	add	r2, sp, #16
 c054b52:	f7fe ffb5 	bl	c053ac0 <mbedtls_mpi_sub_mpi>
 c054b56:	4604      	mov	r4, r0
 c054b58:	2800      	cmp	r0, #0
 c054b5a:	d0df      	beq.n	c054b1c <mbedtls_mpi_inv_mod+0x21c>
 c054b5c:	e79a      	b.n	c054a94 <mbedtls_mpi_inv_mod+0x194>
            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &TV, &TV, &TU ) );
 c054b5e:	a913      	add	r1, sp, #76	@ 0x4c
 c054b60:	4608      	mov	r0, r1
 c054b62:	aa07      	add	r2, sp, #28
 c054b64:	f7fe ffac 	bl	c053ac0 <mbedtls_mpi_sub_mpi>
 c054b68:	4604      	mov	r4, r0
 c054b6a:	2800      	cmp	r0, #0
 c054b6c:	d192      	bne.n	c054a94 <mbedtls_mpi_inv_mod+0x194>
            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &V1, &V1, &U1 ) );
 c054b6e:	a916      	add	r1, sp, #88	@ 0x58
 c054b70:	4608      	mov	r0, r1
 c054b72:	aa0a      	add	r2, sp, #40	@ 0x28
 c054b74:	f7fe ffa4 	bl	c053ac0 <mbedtls_mpi_sub_mpi>
 c054b78:	4604      	mov	r4, r0
 c054b7a:	2800      	cmp	r0, #0
 c054b7c:	d18a      	bne.n	c054a94 <mbedtls_mpi_inv_mod+0x194>
            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &V2, &V2, &U2 ) );
 c054b7e:	aa0d      	add	r2, sp, #52	@ 0x34
 c054b80:	a919      	add	r1, sp, #100	@ 0x64
 c054b82:	e753      	b.n	c054a2c <mbedtls_mpi_inv_mod+0x12c>
        MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &V1, &V1, N ) );
 c054b84:	a916      	add	r1, sp, #88	@ 0x58
 c054b86:	462a      	mov	r2, r5
 c054b88:	4608      	mov	r0, r1
 c054b8a:	f7fe ff76 	bl	c053a7a <mbedtls_mpi_add_mpi>
 c054b8e:	4604      	mov	r4, r0
 c054b90:	2800      	cmp	r0, #0
 c054b92:	f43f af56 	beq.w	c054a42 <mbedtls_mpi_inv_mod+0x142>
 c054b96:	e77d      	b.n	c054a94 <mbedtls_mpi_inv_mod+0x194>
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &V1, &V1, N ) );
 c054b98:	a916      	add	r1, sp, #88	@ 0x58
 c054b9a:	462a      	mov	r2, r5
 c054b9c:	4608      	mov	r0, r1
 c054b9e:	f7fe ff8f 	bl	c053ac0 <mbedtls_mpi_sub_mpi>
 c054ba2:	4604      	mov	r4, r0
 c054ba4:	2800      	cmp	r0, #0
 c054ba6:	f43f af53 	beq.w	c054a50 <mbedtls_mpi_inv_mod+0x150>
 c054baa:	e773      	b.n	c054a94 <mbedtls_mpi_inv_mod+0x194>
        ret = MBEDTLS_ERR_MPI_NOT_ACCEPTABLE;
 c054bac:	f06f 040d 	mvn.w	r4, #13
 c054bb0:	e770      	b.n	c054a94 <mbedtls_mpi_inv_mod+0x194>
        return( MBEDTLS_ERR_MPI_BAD_INPUT_DATA );
 c054bb2:	f06f 0403 	mvn.w	r4, #3
 c054bb6:	e788      	b.n	c054aca <mbedtls_mpi_inv_mod+0x1ca>

0c054bb8 <mbedtls_mpi_is_prime_ext>:
 * Pseudo-primality test: small factors, then Miller-Rabin
 */
int mbedtls_mpi_is_prime_ext( const mbedtls_mpi *X, int rounds,
                              int (*f_rng)(void *, unsigned char *, size_t),
                              void *p_rng )
{
 c054bb8:	b5f0      	push	{r4, r5, r6, r7, lr}
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    mbedtls_mpi XX;
    MPI_VALIDATE_RET( X     != NULL );
    MPI_VALIDATE_RET( f_rng != NULL );

    XX.s = 1;
 c054bba:	2701      	movs	r7, #1
{
 c054bbc:	461e      	mov	r6, r3
    XX.n = X->n;
 c054bbe:	6843      	ldr	r3, [r0, #4]
{
 c054bc0:	b085      	sub	sp, #20
    XX.n = X->n;
 c054bc2:	9302      	str	r3, [sp, #8]
    XX.p = X->p;
 c054bc4:	6883      	ldr	r3, [r0, #8]
{
 c054bc6:	460c      	mov	r4, r1

    if( mbedtls_mpi_cmp_int( &XX, 0 ) == 0 ||
 c054bc8:	a801      	add	r0, sp, #4
 c054bca:	2100      	movs	r1, #0
{
 c054bcc:	4615      	mov	r5, r2
    XX.s = 1;
 c054bce:	9701      	str	r7, [sp, #4]
    XX.p = X->p;
 c054bd0:	9303      	str	r3, [sp, #12]
    if( mbedtls_mpi_cmp_int( &XX, 0 ) == 0 ||
 c054bd2:	f7fe fe76 	bl	c0538c2 <mbedtls_mpi_cmp_int>
 c054bd6:	b1c8      	cbz	r0, c054c0c <mbedtls_mpi_is_prime_ext+0x54>
        mbedtls_mpi_cmp_int( &XX, 1 ) == 0 )
 c054bd8:	4639      	mov	r1, r7
 c054bda:	a801      	add	r0, sp, #4
 c054bdc:	f7fe fe71 	bl	c0538c2 <mbedtls_mpi_cmp_int>
    if( mbedtls_mpi_cmp_int( &XX, 0 ) == 0 ||
 c054be0:	b1a0      	cbz	r0, c054c0c <mbedtls_mpi_is_prime_ext+0x54>
        return( MBEDTLS_ERR_MPI_NOT_ACCEPTABLE );

    if( mbedtls_mpi_cmp_int( &XX, 2 ) == 0 )
 c054be2:	2102      	movs	r1, #2
 c054be4:	a801      	add	r0, sp, #4
 c054be6:	f7fe fe6c 	bl	c0538c2 <mbedtls_mpi_cmp_int>
 c054bea:	b130      	cbz	r0, c054bfa <mbedtls_mpi_is_prime_ext+0x42>
        return( 0 );

    if( ( ret = mpi_check_small_factors( &XX ) ) != 0 )
 c054bec:	a801      	add	r0, sp, #4
 c054bee:	f7ff fadb 	bl	c0541a8 <mpi_check_small_factors>
 c054bf2:	b120      	cbz	r0, c054bfe <mbedtls_mpi_is_prime_ext+0x46>
        return( 0 );
 c054bf4:	42b8      	cmp	r0, r7
 c054bf6:	bf08      	it	eq
 c054bf8:	2000      	moveq	r0, #0

        return( ret );
    }

    return( mpi_miller_rabin( &XX, rounds, f_rng, p_rng ) );
}
 c054bfa:	b005      	add	sp, #20
 c054bfc:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return( mpi_miller_rabin( &XX, rounds, f_rng, p_rng ) );
 c054bfe:	4633      	mov	r3, r6
 c054c00:	462a      	mov	r2, r5
 c054c02:	4621      	mov	r1, r4
 c054c04:	a801      	add	r0, sp, #4
 c054c06:	f7ff fdb7 	bl	c054778 <mpi_miller_rabin>
 c054c0a:	e7f6      	b.n	c054bfa <mbedtls_mpi_is_prime_ext+0x42>
        return( MBEDTLS_ERR_MPI_NOT_ACCEPTABLE );
 c054c0c:	f06f 000d 	mvn.w	r0, #13
 c054c10:	e7f3      	b.n	c054bfa <mbedtls_mpi_is_prime_ext+0x42>
	...

0c054c14 <mbedtls_mpi_gen_prime>:
 * MBEDTLS_MPI_GEN_PRIME_FLAG_LOW_ERR.
 */
int mbedtls_mpi_gen_prime( mbedtls_mpi *X, size_t nbits, int flags,
                   int (*f_rng)(void *, unsigned char *, size_t),
                   void *p_rng )
{
 c054c14:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c054c18:	461f      	mov	r7, r3
    mbedtls_mpi Y;

    MPI_VALIDATE_RET( X     != NULL );
    MPI_VALIDATE_RET( f_rng != NULL );

    if( nbits < 3 || nbits > MBEDTLS_MPI_MAX_BITS )
 c054c1a:	f641 73fd 	movw	r3, #8189	@ 0x1ffd
{
 c054c1e:	460c      	mov	r4, r1
    if( nbits < 3 || nbits > MBEDTLS_MPI_MAX_BITS )
 c054c20:	3903      	subs	r1, #3
{
 c054c22:	b087      	sub	sp, #28
    if( nbits < 3 || nbits > MBEDTLS_MPI_MAX_BITS )
 c054c24:	4299      	cmp	r1, r3
{
 c054c26:	4605      	mov	r5, r0
 c054c28:	f8dd 9040 	ldr.w	r9, [sp, #64]	@ 0x40
    if( nbits < 3 || nbits > MBEDTLS_MPI_MAX_BITS )
 c054c2c:	f200 80f4 	bhi.w	c054e18 <mbedtls_mpi_gen_prime+0x204>
    X->n = 0;
 c054c30:	2300      	movs	r3, #0
 c054c32:	2101      	movs	r1, #1
    X->p = NULL;
 c054c34:	9305      	str	r3, [sp, #20]
    X->n = 0;
 c054c36:	e9cd 1303 	strd	r1, r3, [sp, #12]
        return( MBEDTLS_ERR_MPI_BAD_INPUT_DATA );

    mbedtls_mpi_init( &Y );

    n = BITS_TO_LIMBS( nbits );
 c054c3a:	f014 031f 	ands.w	r3, r4, #31
 c054c3e:	bf18      	it	ne
 c054c40:	2301      	movne	r3, #1

    if( ( flags & MBEDTLS_MPI_GEN_PRIME_FLAG_LOW_ERR ) == 0 )
 c054c42:	0790      	lsls	r0, r2, #30
    n = BITS_TO_LIMBS( nbits );
 c054c44:	eb03 1354 	add.w	r3, r3, r4, lsr #5
    if( ( flags & MBEDTLS_MPI_GEN_PRIME_FLAG_LOW_ERR ) == 0 )
 c054c48:	f100 8093 	bmi.w	c054d72 <mbedtls_mpi_gen_prime+0x15e>
    {
        /*
         * 2^-80 error probability, number of rounds chosen per HAC, table 4.4
         */
        rounds = ( ( nbits >= 1300 ) ?  2 : ( nbits >=  850 ) ?  3 :
 c054c4c:	f240 5113 	movw	r1, #1299	@ 0x513
 c054c50:	428c      	cmp	r4, r1
 c054c52:	f200 80ab 	bhi.w	c054dac <mbedtls_mpi_gen_prime+0x198>
 c054c56:	f240 3151 	movw	r1, #849	@ 0x351
 c054c5a:	428c      	cmp	r4, r1
 c054c5c:	f200 80a8 	bhi.w	c054db0 <mbedtls_mpi_gen_prime+0x19c>
                   ( nbits >=  650 ) ?  4 : ( nbits >=  350 ) ?  8 :
 c054c60:	f240 2189 	movw	r1, #649	@ 0x289
 c054c64:	428c      	cmp	r4, r1
 c054c66:	f200 80a7 	bhi.w	c054db8 <mbedtls_mpi_gen_prime+0x1a4>
 c054c6a:	f5b4 7faf 	cmp.w	r4, #350	@ 0x15e
 c054c6e:	f080 80ab 	bcs.w	c054dc8 <mbedtls_mpi_gen_prime+0x1b4>
                   ( nbits >=  250 ) ? 12 : ( nbits >=  150 ) ? 18 : 27 );
 c054c72:	2cf9      	cmp	r4, #249	@ 0xf9
 c054c74:	f200 809e 	bhi.w	c054db4 <mbedtls_mpi_gen_prime+0x1a0>
 c054c78:	2c95      	cmp	r4, #149	@ 0x95
 c054c7a:	bf8c      	ite	hi
 c054c7c:	2612      	movhi	r6, #18
 c054c7e:	261b      	movls	r6, #27
                   ( nbits >=  250 ) ? 28 : ( nbits >=   150 ) ? 40 : 51 );
    }

    while( 1 )
    {
        MBEDTLS_MPI_CHK( mbedtls_mpi_fill_random( X, n * ciL, f_rng, p_rng ) );
 c054c80:	ea4f 0a83 	mov.w	sl, r3, lsl #2
        /* make sure generated number is at least (nbits-1)+0.5 bits (FIPS 186-4 §B.3.3 steps 4.4, 5.5) */
        if( X->p[n-1] < CEIL_MAXUINT_DIV_SQRT2 ) continue;

        k = n * biL;
 c054c84:	ea4f 1b43 	mov.w	fp, r3, lsl #5
        if( k > nbits ) MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( X, k - nbits ) );
 c054c88:	ebc4 1343 	rsb	r3, r4, r3, lsl #5
 c054c8c:	9300      	str	r3, [sp, #0]
        X->p[0] |= 1;

        if( ( flags & MBEDTLS_MPI_GEN_PRIME_FLAG_DH ) == 0 )
 c054c8e:	f002 0301 	and.w	r3, r2, #1
        if( X->p[n-1] < CEIL_MAXUINT_DIV_SQRT2 ) continue;
 c054c92:	f1aa 0804 	sub.w	r8, sl, #4
        if( ( flags & MBEDTLS_MPI_GEN_PRIME_FLAG_DH ) == 0 )
 c054c96:	9301      	str	r3, [sp, #4]
        MBEDTLS_MPI_CHK( mbedtls_mpi_fill_random( X, n * ciL, f_rng, p_rng ) );
 c054c98:	464b      	mov	r3, r9
 c054c9a:	463a      	mov	r2, r7
 c054c9c:	4651      	mov	r1, sl
 c054c9e:	4628      	mov	r0, r5
 c054ca0:	f7ff fd50 	bl	c054744 <mbedtls_mpi_fill_random>
 c054ca4:	4603      	mov	r3, r0
 c054ca6:	2800      	cmp	r0, #0
 c054ca8:	f040 809c 	bne.w	c054de4 <mbedtls_mpi_gen_prime+0x1d0>
        if( X->p[n-1] < CEIL_MAXUINT_DIV_SQRT2 ) continue;
 c054cac:	68ab      	ldr	r3, [r5, #8]
 c054cae:	4a5c      	ldr	r2, [pc, #368]	@ (c054e20 <mbedtls_mpi_gen_prime+0x20c>)
 c054cb0:	f853 3008 	ldr.w	r3, [r3, r8]
 c054cb4:	4293      	cmp	r3, r2
 c054cb6:	d9ef      	bls.n	c054c98 <mbedtls_mpi_gen_prime+0x84>
        if( k > nbits ) MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( X, k - nbits ) );
 c054cb8:	455c      	cmp	r4, fp
 c054cba:	f0c0 808b 	bcc.w	c054dd4 <mbedtls_mpi_gen_prime+0x1c0>
        X->p[0] |= 1;
 c054cbe:	68aa      	ldr	r2, [r5, #8]
 c054cc0:	6813      	ldr	r3, [r2, #0]
 c054cc2:	f043 0101 	orr.w	r1, r3, #1
 c054cc6:	6011      	str	r1, [r2, #0]
        if( ( flags & MBEDTLS_MPI_GEN_PRIME_FLAG_DH ) == 0 )
 c054cc8:	9901      	ldr	r1, [sp, #4]
 c054cca:	2900      	cmp	r1, #0
 c054ccc:	f000 8093 	beq.w	c054df6 <mbedtls_mpi_gen_prime+0x1e2>
             * An necessary condition for Y and X = 2Y + 1 to be prime
             * is X = 2 mod 3 (which is equivalent to Y = 2 mod 3).
             * Make sure it is satisfied, while keeping X = 3 mod 4
             */

            X->p[0] |= 2;
 c054cd0:	f043 0303 	orr.w	r3, r3, #3
 c054cd4:	6013      	str	r3, [r2, #0]

            MBEDTLS_MPI_CHK( mbedtls_mpi_mod_int( &r, X, 3 ) );
 c054cd6:	4629      	mov	r1, r5
 c054cd8:	2203      	movs	r2, #3
 c054cda:	a802      	add	r0, sp, #8
 c054cdc:	f7ff fa2f 	bl	c05413e <mbedtls_mpi_mod_int>
 c054ce0:	4603      	mov	r3, r0
 c054ce2:	2800      	cmp	r0, #0
 c054ce4:	d17e      	bne.n	c054de4 <mbedtls_mpi_gen_prime+0x1d0>
            if( r == 0 )
 c054ce6:	9b02      	ldr	r3, [sp, #8]
 c054ce8:	2b00      	cmp	r3, #0
 c054cea:	f040 8090 	bne.w	c054e0e <mbedtls_mpi_gen_prime+0x1fa>
                MBEDTLS_MPI_CHK( mbedtls_mpi_add_int( X, X, 8 ) );
 c054cee:	2208      	movs	r2, #8
 c054cf0:	4629      	mov	r1, r5
 c054cf2:	4628      	mov	r0, r5
 c054cf4:	f7fe ff08 	bl	c053b08 <mbedtls_mpi_add_int>
 c054cf8:	4603      	mov	r3, r0
 c054cfa:	2800      	cmp	r0, #0
 c054cfc:	d172      	bne.n	c054de4 <mbedtls_mpi_gen_prime+0x1d0>
            else if( r == 1 )
                MBEDTLS_MPI_CHK( mbedtls_mpi_add_int( X, X, 4 ) );

            /* Set Y = (X-1) / 2, which is X / 2 because X is odd */
            MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &Y, X ) );
 c054cfe:	4629      	mov	r1, r5
 c054d00:	a803      	add	r0, sp, #12
 c054d02:	f7fe fb52 	bl	c0533aa <mbedtls_mpi_copy>
 c054d06:	4603      	mov	r3, r0
 c054d08:	2800      	cmp	r0, #0
 c054d0a:	d16b      	bne.n	c054de4 <mbedtls_mpi_gen_prime+0x1d0>
            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &Y, 1 ) );
 c054d0c:	2101      	movs	r1, #1
 c054d0e:	a803      	add	r0, sp, #12
 c054d10:	f7fe fd27 	bl	c053762 <mbedtls_mpi_shift_r>
 c054d14:	4603      	mov	r3, r0
 c054d16:	2800      	cmp	r0, #0
 c054d18:	d164      	bne.n	c054de4 <mbedtls_mpi_gen_prime+0x1d0>
            {
                /*
                 * First, check small factors for X and Y
                 * before doing Miller-Rabin on any of them
                 */
                if( ( ret = mpi_check_small_factors(  X         ) ) == 0 &&
 c054d1a:	4628      	mov	r0, r5
 c054d1c:	f7ff fa44 	bl	c0541a8 <mpi_check_small_factors>
 c054d20:	4603      	mov	r3, r0
 c054d22:	b9a8      	cbnz	r0, c054d50 <mbedtls_mpi_gen_prime+0x13c>
                    ( ret = mpi_check_small_factors( &Y         ) ) == 0 &&
 c054d24:	a803      	add	r0, sp, #12
 c054d26:	f7ff fa3f 	bl	c0541a8 <mpi_check_small_factors>
                if( ( ret = mpi_check_small_factors(  X         ) ) == 0 &&
 c054d2a:	4603      	mov	r3, r0
 c054d2c:	b980      	cbnz	r0, c054d50 <mbedtls_mpi_gen_prime+0x13c>
                    ( ret = mpi_miller_rabin(  X, rounds, f_rng, p_rng  ) )
 c054d2e:	464b      	mov	r3, r9
 c054d30:	463a      	mov	r2, r7
 c054d32:	4631      	mov	r1, r6
 c054d34:	4628      	mov	r0, r5
 c054d36:	f7ff fd1f 	bl	c054778 <mpi_miller_rabin>
                    ( ret = mpi_check_small_factors( &Y         ) ) == 0 &&
 c054d3a:	4603      	mov	r3, r0
 c054d3c:	b940      	cbnz	r0, c054d50 <mbedtls_mpi_gen_prime+0x13c>
                                                                    == 0 &&
                    ( ret = mpi_miller_rabin( &Y, rounds, f_rng, p_rng  ) )
 c054d3e:	464b      	mov	r3, r9
 c054d40:	463a      	mov	r2, r7
 c054d42:	4631      	mov	r1, r6
 c054d44:	a803      	add	r0, sp, #12
 c054d46:	f7ff fd17 	bl	c054778 <mpi_miller_rabin>
                                                                    == 0 &&
 c054d4a:	4603      	mov	r3, r0
 c054d4c:	2800      	cmp	r0, #0
 c054d4e:	d049      	beq.n	c054de4 <mbedtls_mpi_gen_prime+0x1d0>
                                                                    == 0 )
                    goto cleanup;

                if( ret != MBEDTLS_ERR_MPI_NOT_ACCEPTABLE )
 c054d50:	f113 0f0e 	cmn.w	r3, #14
 c054d54:	d146      	bne.n	c054de4 <mbedtls_mpi_gen_prime+0x1d0>
                /*
                 * Next candidates. We want to preserve Y = (X-1) / 2 and
                 * Y = 1 mod 2 and Y = 2 mod 3 (eq X = 3 mod 4 and X = 2 mod 3)
                 * so up Y by 6 and X by 12.
                 */
                MBEDTLS_MPI_CHK( mbedtls_mpi_add_int(  X,  X, 12 ) );
 c054d56:	220c      	movs	r2, #12
 c054d58:	4629      	mov	r1, r5
 c054d5a:	4628      	mov	r0, r5
 c054d5c:	f7fe fed4 	bl	c053b08 <mbedtls_mpi_add_int>
 c054d60:	4603      	mov	r3, r0
 c054d62:	2800      	cmp	r0, #0
 c054d64:	d13e      	bne.n	c054de4 <mbedtls_mpi_gen_prime+0x1d0>
                MBEDTLS_MPI_CHK( mbedtls_mpi_add_int( &Y, &Y, 6  ) );
 c054d66:	a903      	add	r1, sp, #12
 c054d68:	2206      	movs	r2, #6
 c054d6a:	4608      	mov	r0, r1
 c054d6c:	f7fe fecc 	bl	c053b08 <mbedtls_mpi_add_int>
 c054d70:	e7d0      	b.n	c054d14 <mbedtls_mpi_gen_prime+0x100>
        rounds = ( ( nbits >= 1450 ) ?  4 : ( nbits >=  1150 ) ?  5 :
 c054d72:	f240 51a9 	movw	r1, #1449	@ 0x5a9
 c054d76:	428c      	cmp	r4, r1
 c054d78:	d81e      	bhi.n	c054db8 <mbedtls_mpi_gen_prime+0x1a4>
 c054d7a:	f240 417d 	movw	r1, #1149	@ 0x47d
 c054d7e:	428c      	cmp	r4, r1
 c054d80:	d81c      	bhi.n	c054dbc <mbedtls_mpi_gen_prime+0x1a8>
                   ( nbits >= 1000 ) ?  6 : ( nbits >=   850 ) ?  7 :
 c054d82:	f5b4 7f7a 	cmp.w	r4, #1000	@ 0x3e8
 c054d86:	d21b      	bcs.n	c054dc0 <mbedtls_mpi_gen_prime+0x1ac>
 c054d88:	f240 3151 	movw	r1, #849	@ 0x351
 c054d8c:	428c      	cmp	r4, r1
 c054d8e:	d819      	bhi.n	c054dc4 <mbedtls_mpi_gen_prime+0x1b0>
                   ( nbits >=  750 ) ?  8 : ( nbits >=   500 ) ? 13 :
 c054d90:	f240 21ed 	movw	r1, #749	@ 0x2ed
 c054d94:	428c      	cmp	r4, r1
 c054d96:	d817      	bhi.n	c054dc8 <mbedtls_mpi_gen_prime+0x1b4>
 c054d98:	f5b4 7ffa 	cmp.w	r4, #500	@ 0x1f4
 c054d9c:	d216      	bcs.n	c054dcc <mbedtls_mpi_gen_prime+0x1b8>
                   ( nbits >=  250 ) ? 28 : ( nbits >=   150 ) ? 40 : 51 );
 c054d9e:	2cf9      	cmp	r4, #249	@ 0xf9
 c054da0:	d816      	bhi.n	c054dd0 <mbedtls_mpi_gen_prime+0x1bc>
 c054da2:	2c95      	cmp	r4, #149	@ 0x95
 c054da4:	bf8c      	ite	hi
 c054da6:	2628      	movhi	r6, #40	@ 0x28
 c054da8:	2633      	movls	r6, #51	@ 0x33
 c054daa:	e769      	b.n	c054c80 <mbedtls_mpi_gen_prime+0x6c>
        rounds = ( ( nbits >= 1300 ) ?  2 : ( nbits >=  850 ) ?  3 :
 c054dac:	2602      	movs	r6, #2
 c054dae:	e767      	b.n	c054c80 <mbedtls_mpi_gen_prime+0x6c>
 c054db0:	2603      	movs	r6, #3
 c054db2:	e765      	b.n	c054c80 <mbedtls_mpi_gen_prime+0x6c>
                   ( nbits >=  250 ) ? 12 : ( nbits >=  150 ) ? 18 : 27 );
 c054db4:	260c      	movs	r6, #12
 c054db6:	e763      	b.n	c054c80 <mbedtls_mpi_gen_prime+0x6c>
        rounds = ( ( nbits >= 1450 ) ?  4 : ( nbits >=  1150 ) ?  5 :
 c054db8:	2604      	movs	r6, #4
 c054dba:	e761      	b.n	c054c80 <mbedtls_mpi_gen_prime+0x6c>
 c054dbc:	2605      	movs	r6, #5
 c054dbe:	e75f      	b.n	c054c80 <mbedtls_mpi_gen_prime+0x6c>
                   ( nbits >= 1000 ) ?  6 : ( nbits >=   850 ) ?  7 :
 c054dc0:	2606      	movs	r6, #6
 c054dc2:	e75d      	b.n	c054c80 <mbedtls_mpi_gen_prime+0x6c>
 c054dc4:	2607      	movs	r6, #7
 c054dc6:	e75b      	b.n	c054c80 <mbedtls_mpi_gen_prime+0x6c>
                   ( nbits >=  750 ) ?  8 : ( nbits >=   500 ) ? 13 :
 c054dc8:	2608      	movs	r6, #8
 c054dca:	e759      	b.n	c054c80 <mbedtls_mpi_gen_prime+0x6c>
 c054dcc:	260d      	movs	r6, #13
 c054dce:	e757      	b.n	c054c80 <mbedtls_mpi_gen_prime+0x6c>
                   ( nbits >=  250 ) ? 28 : ( nbits >=   150 ) ? 40 : 51 );
 c054dd0:	261c      	movs	r6, #28
 c054dd2:	e755      	b.n	c054c80 <mbedtls_mpi_gen_prime+0x6c>
        if( k > nbits ) MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( X, k - nbits ) );
 c054dd4:	4628      	mov	r0, r5
 c054dd6:	9900      	ldr	r1, [sp, #0]
 c054dd8:	f7fe fcc3 	bl	c053762 <mbedtls_mpi_shift_r>
 c054ddc:	4603      	mov	r3, r0
 c054dde:	2800      	cmp	r0, #0
 c054de0:	f43f af6d 	beq.w	c054cbe <mbedtls_mpi_gen_prime+0xaa>
        }
    }

cleanup:

    mbedtls_mpi_free( &Y );
 c054de4:	a803      	add	r0, sp, #12
 c054de6:	9300      	str	r3, [sp, #0]
 c054de8:	f7fe fa8b 	bl	c053302 <mbedtls_mpi_free>

    return( ret );
 c054dec:	9b00      	ldr	r3, [sp, #0]
}
 c054dee:	4618      	mov	r0, r3
 c054df0:	b007      	add	sp, #28
 c054df2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            ret = mbedtls_mpi_is_prime_ext( X, rounds, f_rng, p_rng );
 c054df6:	464b      	mov	r3, r9
 c054df8:	463a      	mov	r2, r7
 c054dfa:	4631      	mov	r1, r6
 c054dfc:	4628      	mov	r0, r5
 c054dfe:	f7ff fedb 	bl	c054bb8 <mbedtls_mpi_is_prime_ext>
            if( ret != MBEDTLS_ERR_MPI_NOT_ACCEPTABLE )
 c054e02:	f110 0f0e 	cmn.w	r0, #14
            ret = mbedtls_mpi_is_prime_ext( X, rounds, f_rng, p_rng );
 c054e06:	4603      	mov	r3, r0
            if( ret != MBEDTLS_ERR_MPI_NOT_ACCEPTABLE )
 c054e08:	f43f af46 	beq.w	c054c98 <mbedtls_mpi_gen_prime+0x84>
 c054e0c:	e7ea      	b.n	c054de4 <mbedtls_mpi_gen_prime+0x1d0>
            else if( r == 1 )
 c054e0e:	2b01      	cmp	r3, #1
 c054e10:	f47f af75 	bne.w	c054cfe <mbedtls_mpi_gen_prime+0xea>
                MBEDTLS_MPI_CHK( mbedtls_mpi_add_int( X, X, 4 ) );
 c054e14:	2204      	movs	r2, #4
 c054e16:	e76b      	b.n	c054cf0 <mbedtls_mpi_gen_prime+0xdc>
        return( MBEDTLS_ERR_MPI_BAD_INPUT_DATA );
 c054e18:	f06f 0303 	mvn.w	r3, #3
 c054e1c:	e7e7      	b.n	c054dee <mbedtls_mpi_gen_prime+0x1da>
 c054e1e:	bf00      	nop
 c054e20:	b504f333 	.word	0xb504f333

0c054e24 <add_pkcs_padding>:
/*
 * PKCS7 (and PKCS5) padding: fill with ll bytes, with ll = padding_len
 */
static void add_pkcs_padding( unsigned char *output, size_t output_len,
        size_t data_len )
{
 c054e24:	b510      	push	{r4, lr}
    size_t padding_len = output_len - data_len;
    unsigned char i;

    for( i = 0; i < padding_len; i++ )
 c054e26:	2400      	movs	r4, #0
    size_t padding_len = output_len - data_len;
 c054e28:	1a89      	subs	r1, r1, r2
    for( i = 0; i < padding_len; i++ )
 c054e2a:	b2e3      	uxtb	r3, r4
 c054e2c:	4299      	cmp	r1, r3
 c054e2e:	f104 0401 	add.w	r4, r4, #1
 c054e32:	d800      	bhi.n	c054e36 <add_pkcs_padding+0x12>
        output[data_len + i] = (unsigned char) padding_len;
}
 c054e34:	bd10      	pop	{r4, pc}
        output[data_len + i] = (unsigned char) padding_len;
 c054e36:	4403      	add	r3, r0
 c054e38:	5499      	strb	r1, [r3, r2]
    for( i = 0; i < padding_len; i++ )
 c054e3a:	e7f6      	b.n	c054e2a <add_pkcs_padding+0x6>

0c054e3c <get_pkcs_padding>:

static int get_pkcs_padding( unsigned char *input, size_t input_len,
        size_t *data_len )
{
 c054e3c:	b5f0      	push	{r4, r5, r6, r7, lr}
    size_t i, pad_idx;
    unsigned char padding_len, bad = 0;

    if( NULL == input || NULL == data_len )
 c054e3e:	b300      	cbz	r0, c054e82 <get_pkcs_padding+0x46>
 c054e40:	b1fa      	cbz	r2, c054e82 <get_pkcs_padding+0x46>
        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );

    padding_len = input[input_len - 1];
 c054e42:	1843      	adds	r3, r0, r1
 c054e44:	f813 5c01 	ldrb.w	r5, [r3, #-1]
    *data_len = input_len - padding_len;

    /* Avoid logical || since it results in a branch */
    bad |= padding_len > input_len;
    bad |= padding_len == 0;
 c054e48:	fab5 f385 	clz	r3, r5
    *data_len = input_len - padding_len;
 c054e4c:	1b4e      	subs	r6, r1, r5
    bad |= padding_len == 0;
 c054e4e:	095b      	lsrs	r3, r3, #5
    *data_len = input_len - padding_len;
 c054e50:	6016      	str	r6, [r2, #0]
    bad |= padding_len == 0;
 c054e52:	428d      	cmp	r5, r1
 c054e54:	bf88      	it	hi
 c054e56:	f043 0301 	orrhi.w	r3, r3, #1

    /* The number of bytes checked must be independent of padding_len,
     * so pick input_len, which is usually 8 or 16 (one block) */
    pad_idx = input_len - padding_len;
    for( i = 0; i < input_len; i++ )
 c054e5a:	2200      	movs	r2, #0
 c054e5c:	428a      	cmp	r2, r1
 c054e5e:	d104      	bne.n	c054e6a <get_pkcs_padding+0x2e>
        bad |= ( input[i] ^ padding_len ) * ( i >= pad_idx );

    return( MBEDTLS_ERR_CIPHER_INVALID_PADDING * ( bad != 0 ) );
 c054e60:	2b00      	cmp	r3, #0
 c054e62:	4809      	ldr	r0, [pc, #36]	@ (c054e88 <get_pkcs_padding+0x4c>)
 c054e64:	bf08      	it	eq
 c054e66:	2000      	moveq	r0, #0
}
 c054e68:	bdf0      	pop	{r4, r5, r6, r7, pc}
        bad |= ( input[i] ^ padding_len ) * ( i >= pad_idx );
 c054e6a:	4296      	cmp	r6, r2
 c054e6c:	bf8c      	ite	hi
 c054e6e:	2700      	movhi	r7, #0
 c054e70:	2701      	movls	r7, #1
 c054e72:	5c84      	ldrb	r4, [r0, r2]
    for( i = 0; i < input_len; i++ )
 c054e74:	3201      	adds	r2, #1
        bad |= ( input[i] ^ padding_len ) * ( i >= pad_idx );
 c054e76:	406c      	eors	r4, r5
 c054e78:	fb14 f407 	smulbb	r4, r4, r7
 c054e7c:	4323      	orrs	r3, r4
 c054e7e:	b2db      	uxtb	r3, r3
    for( i = 0; i < input_len; i++ )
 c054e80:	e7ec      	b.n	c054e5c <get_pkcs_padding+0x20>
        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );
 c054e82:	4802      	ldr	r0, [pc, #8]	@ (c054e8c <get_pkcs_padding+0x50>)
 c054e84:	e7f0      	b.n	c054e68 <get_pkcs_padding+0x2c>
 c054e86:	bf00      	nop
 c054e88:	ffff9e00 	.word	0xffff9e00
 c054e8c:	ffff9f00 	.word	0xffff9f00

0c054e90 <add_one_and_zeros_padding>:
                                       size_t output_len, size_t data_len )
{
    size_t padding_len = output_len - data_len;
    unsigned char i = 0;

    output[data_len] = 0x80;
 c054e90:	2380      	movs	r3, #128	@ 0x80
{
 c054e92:	b530      	push	{r4, r5, lr}
    output[data_len] = 0x80;
 c054e94:	5483      	strb	r3, [r0, r2]
    for( i = 1; i < padding_len; i++ )
        output[data_len + i] = 0x00;
 c054e96:	2400      	movs	r4, #0
    for( i = 1; i < padding_len; i++ )
 c054e98:	2301      	movs	r3, #1
    size_t padding_len = output_len - data_len;
 c054e9a:	1a89      	subs	r1, r1, r2
    for( i = 1; i < padding_len; i++ )
 c054e9c:	428b      	cmp	r3, r1
 c054e9e:	d300      	bcc.n	c054ea2 <add_one_and_zeros_padding+0x12>
}
 c054ea0:	bd30      	pop	{r4, r5, pc}
        output[data_len + i] = 0x00;
 c054ea2:	18c5      	adds	r5, r0, r3
    for( i = 1; i < padding_len; i++ )
 c054ea4:	3301      	adds	r3, #1
        output[data_len + i] = 0x00;
 c054ea6:	54ac      	strb	r4, [r5, r2]
    for( i = 1; i < padding_len; i++ )
 c054ea8:	b2db      	uxtb	r3, r3
 c054eaa:	e7f7      	b.n	c054e9c <add_one_and_zeros_padding+0xc>

0c054eac <add_zeros_and_len_padding>:
/*
 * Zeros and len padding: fill with 00 ... 00 ll, where ll is padding length
 */
static void add_zeros_and_len_padding( unsigned char *output,
                                       size_t output_len, size_t data_len )
{
 c054eac:	b570      	push	{r4, r5, r6, lr}
    size_t padding_len = output_len - data_len;
    unsigned char i = 0;

    for( i = 1; i < padding_len; i++ )
 c054eae:	2301      	movs	r3, #1
        output[data_len + i - 1] = 0x00;
 c054eb0:	2600      	movs	r6, #0
    size_t padding_len = output_len - data_len;
 c054eb2:	1a8d      	subs	r5, r1, r2
    for( i = 1; i < padding_len; i++ )
 c054eb4:	42ab      	cmp	r3, r5
 c054eb6:	d303      	bcc.n	c054ec0 <add_zeros_and_len_padding+0x14>
    output[output_len - 1] = (unsigned char) padding_len;
 c054eb8:	4408      	add	r0, r1
 c054eba:	f800 5c01 	strb.w	r5, [r0, #-1]
}
 c054ebe:	bd70      	pop	{r4, r5, r6, pc}
        output[data_len + i - 1] = 0x00;
 c054ec0:	18c4      	adds	r4, r0, r3
 c054ec2:	4414      	add	r4, r2
    for( i = 1; i < padding_len; i++ )
 c054ec4:	3301      	adds	r3, #1
        output[data_len + i - 1] = 0x00;
 c054ec6:	f804 6c01 	strb.w	r6, [r4, #-1]
    for( i = 1; i < padding_len; i++ )
 c054eca:	b2db      	uxtb	r3, r3
 c054ecc:	e7f2      	b.n	c054eb4 <add_zeros_and_len_padding+0x8>
	...

0c054ed0 <get_zeros_and_len_padding>:

static int get_zeros_and_len_padding( unsigned char *input, size_t input_len,
                                      size_t *data_len )
{
 c054ed0:	b570      	push	{r4, r5, r6, lr}
    size_t i, pad_idx;
    unsigned char padding_len, bad = 0;

    if( NULL == input || NULL == data_len )
 c054ed2:	b1f0      	cbz	r0, c054f12 <get_zeros_and_len_padding+0x42>
 c054ed4:	b1ea      	cbz	r2, c054f12 <get_zeros_and_len_padding+0x42>
        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );

    padding_len = input[input_len - 1];
 c054ed6:	1e4d      	subs	r5, r1, #1
 c054ed8:	5d44      	ldrb	r4, [r0, r5]
    *data_len = input_len - padding_len;

    /* Avoid logical || since it results in a branch */
    bad |= padding_len > input_len;
    bad |= padding_len == 0;
 c054eda:	fab4 f384 	clz	r3, r4
    *data_len = input_len - padding_len;
 c054ede:	1b0e      	subs	r6, r1, r4
    bad |= padding_len == 0;
 c054ee0:	095b      	lsrs	r3, r3, #5
    *data_len = input_len - padding_len;
 c054ee2:	6016      	str	r6, [r2, #0]
    bad |= padding_len == 0;
 c054ee4:	428c      	cmp	r4, r1
 c054ee6:	bf88      	it	hi
 c054ee8:	f043 0301 	orrhi.w	r3, r3, #1

    /* The number of bytes checked must be independent of padding_len */
    pad_idx = input_len - padding_len;
    for( i = 0; i < input_len - 1; i++ )
 c054eec:	2200      	movs	r2, #0
 c054eee:	4295      	cmp	r5, r2
 c054ef0:	d804      	bhi.n	c054efc <get_zeros_and_len_padding+0x2c>
        bad |= input[i] * ( i >= pad_idx );

    return( MBEDTLS_ERR_CIPHER_INVALID_PADDING * ( bad != 0 ) );
 c054ef2:	2b00      	cmp	r3, #0
 c054ef4:	4808      	ldr	r0, [pc, #32]	@ (c054f18 <get_zeros_and_len_padding+0x48>)
 c054ef6:	bf08      	it	eq
 c054ef8:	2000      	moveq	r0, #0
}
 c054efa:	bd70      	pop	{r4, r5, r6, pc}
        bad |= input[i] * ( i >= pad_idx );
 c054efc:	4296      	cmp	r6, r2
 c054efe:	bf8c      	ite	hi
 c054f00:	2400      	movhi	r4, #0
 c054f02:	2401      	movls	r4, #1
 c054f04:	5c81      	ldrb	r1, [r0, r2]
    for( i = 0; i < input_len - 1; i++ )
 c054f06:	3201      	adds	r2, #1
        bad |= input[i] * ( i >= pad_idx );
 c054f08:	fb11 f104 	smulbb	r1, r1, r4
 c054f0c:	430b      	orrs	r3, r1
 c054f0e:	b2db      	uxtb	r3, r3
    for( i = 0; i < input_len - 1; i++ )
 c054f10:	e7ed      	b.n	c054eee <get_zeros_and_len_padding+0x1e>
        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );
 c054f12:	4802      	ldr	r0, [pc, #8]	@ (c054f1c <get_zeros_and_len_padding+0x4c>)
 c054f14:	e7f1      	b.n	c054efa <get_zeros_and_len_padding+0x2a>
 c054f16:	bf00      	nop
 c054f18:	ffff9e00 	.word	0xffff9e00
 c054f1c:	ffff9f00 	.word	0xffff9f00

0c054f20 <add_zeros_padding>:
/*
 * Zero padding: fill with 00 ... 00
 */
static void add_zeros_padding( unsigned char *output,
                               size_t output_len, size_t data_len )
{
 c054f20:	4613      	mov	r3, r2
    size_t i;

    for( i = data_len; i < output_len; i++ )
        output[i] = 0x00;
 c054f22:	1a8a      	subs	r2, r1, r2
 c054f24:	428b      	cmp	r3, r1
 c054f26:	bf88      	it	hi
 c054f28:	2200      	movhi	r2, #0
 c054f2a:	4418      	add	r0, r3
 c054f2c:	2100      	movs	r1, #0
 c054f2e:	f006 bbfe 	b.w	c05b72e <memset>
	...

0c054f34 <get_no_padding>:
 * but a trivial get_padding function
 */
static int get_no_padding( unsigned char *input, size_t input_len,
                              size_t *data_len )
{
    if( NULL == input || NULL == data_len )
 c054f34:	b118      	cbz	r0, c054f3e <get_no_padding+0xa>
 c054f36:	b112      	cbz	r2, c054f3e <get_no_padding+0xa>
        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );

    *data_len = input_len;

    return( 0 );
 c054f38:	2000      	movs	r0, #0
    *data_len = input_len;
 c054f3a:	6011      	str	r1, [r2, #0]
    return( 0 );
 c054f3c:	4770      	bx	lr
        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );
 c054f3e:	4801      	ldr	r0, [pc, #4]	@ (c054f44 <get_no_padding+0x10>)
}
 c054f40:	4770      	bx	lr
 c054f42:	bf00      	nop
 c054f44:	ffff9f00 	.word	0xffff9f00

0c054f48 <get_zeros_padding>:
{
 c054f48:	b5f0      	push	{r4, r5, r6, r7, lr}
    if( NULL == input || NULL == data_len )
 c054f4a:	b190      	cbz	r0, c054f72 <get_zeros_padding+0x2a>
 c054f4c:	b18a      	cbz	r2, c054f72 <get_zeros_padding+0x2a>
 c054f4e:	2300      	movs	r3, #0
    unsigned char done = 0, prev_done;
 c054f50:	461d      	mov	r5, r3
    *data_len = 0;
 c054f52:	6013      	str	r3, [r2, #0]
    for( i = input_len; i > 0; i-- )
 c054f54:	b909      	cbnz	r1, c054f5a <get_zeros_padding+0x12>
 c054f56:	4608      	mov	r0, r1
}
 c054f58:	bdf0      	pop	{r4, r5, r6, r7, pc}
        done |= ( input[i-1] != 0 );
 c054f5a:	1e4f      	subs	r7, r1, #1
 c054f5c:	5dc4      	ldrb	r4, [r0, r7]
 c054f5e:	3c00      	subs	r4, #0
 c054f60:	bf18      	it	ne
 c054f62:	2401      	movne	r4, #1
        *data_len |= i * ( done != prev_done );
 c054f64:	ea24 0605 	bic.w	r6, r4, r5
 c054f68:	4371      	muls	r1, r6
        done |= ( input[i-1] != 0 );
 c054f6a:	4325      	orrs	r5, r4
        *data_len |= i * ( done != prev_done );
 c054f6c:	430b      	orrs	r3, r1
    for( i = input_len; i > 0; i-- )
 c054f6e:	4639      	mov	r1, r7
 c054f70:	e7ef      	b.n	c054f52 <get_zeros_padding+0xa>
        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );
 c054f72:	4801      	ldr	r0, [pc, #4]	@ (c054f78 <get_zeros_padding+0x30>)
 c054f74:	e7f0      	b.n	c054f58 <get_zeros_padding+0x10>
 c054f76:	bf00      	nop
 c054f78:	ffff9f00 	.word	0xffff9f00

0c054f7c <get_one_and_zeros_padding>:
{
 c054f7c:	b5f0      	push	{r4, r5, r6, r7, lr}
    if( NULL == input || NULL == data_len )
 c054f7e:	b1f8      	cbz	r0, c054fc0 <get_one_and_zeros_padding+0x44>
 c054f80:	b1f2      	cbz	r2, c054fc0 <get_one_and_zeros_padding+0x44>
    *data_len = 0;
 c054f82:	2300      	movs	r3, #0
    bad = 0x80;
 c054f84:	2480      	movs	r4, #128	@ 0x80
    *data_len = 0;
 c054f86:	6013      	str	r3, [r2, #0]
static int get_one_and_zeros_padding( unsigned char *input, size_t input_len,
 c054f88:	4408      	add	r0, r1
    for( i = input_len; i > 0; i-- )
 c054f8a:	b921      	cbnz	r1, c054f96 <get_one_and_zeros_padding+0x1a>
    return( MBEDTLS_ERR_CIPHER_INVALID_PADDING * ( bad != 0 ) );
 c054f8c:	2c00      	cmp	r4, #0
 c054f8e:	480d      	ldr	r0, [pc, #52]	@ (c054fc4 <get_one_and_zeros_padding+0x48>)
 c054f90:	bf08      	it	eq
 c054f92:	2000      	moveq	r0, #0
}
 c054f94:	bdf0      	pop	{r4, r5, r6, r7, pc}
        done |= ( input[i - 1] != 0 );
 c054f96:	f810 5d01 	ldrb.w	r5, [r0, #-1]!
 c054f9a:	3901      	subs	r1, #1
 c054f9c:	3d00      	subs	r5, #0
 c054f9e:	bf18      	it	ne
 c054fa0:	2501      	movne	r5, #1
        *data_len |= ( i - 1 ) * ( done != prev_done );
 c054fa2:	ea25 0703 	bic.w	r7, r5, r3
 c054fa6:	fb01 fc07 	mul.w	ip, r1, r7
 c054faa:	6816      	ldr	r6, [r2, #0]
        done |= ( input[i - 1] != 0 );
 c054fac:	432b      	orrs	r3, r5
        *data_len |= ( i - 1 ) * ( done != prev_done );
 c054fae:	ea46 060c 	orr.w	r6, r6, ip
 c054fb2:	6016      	str	r6, [r2, #0]
        bad ^= input[i - 1] * ( done != prev_done );
 c054fb4:	7806      	ldrb	r6, [r0, #0]
 c054fb6:	fb16 f607 	smulbb	r6, r6, r7
 c054fba:	4074      	eors	r4, r6
 c054fbc:	b2e4      	uxtb	r4, r4
    for( i = input_len; i > 0; i-- )
 c054fbe:	e7e4      	b.n	c054f8a <get_one_and_zeros_padding+0xe>
        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );
 c054fc0:	4801      	ldr	r0, [pc, #4]	@ (c054fc8 <get_one_and_zeros_padding+0x4c>)
 c054fc2:	e7e7      	b.n	c054f94 <get_one_and_zeros_padding+0x18>
 c054fc4:	ffff9e00 	.word	0xffff9e00
 c054fc8:	ffff9f00 	.word	0xffff9f00

0c054fcc <mbedtls_cipher_info_from_type>:
{
 c054fcc:	4602      	mov	r2, r0
    for( def = mbedtls_cipher_definitions; def->info != NULL; def++ )
 c054fce:	4b04      	ldr	r3, [pc, #16]	@ (c054fe0 <mbedtls_cipher_info_from_type+0x14>)
 c054fd0:	6858      	ldr	r0, [r3, #4]
 c054fd2:	b900      	cbnz	r0, c054fd6 <mbedtls_cipher_info_from_type+0xa>
}
 c054fd4:	4770      	bx	lr
        if( def->type == cipher_type )
 c054fd6:	7819      	ldrb	r1, [r3, #0]
 c054fd8:	4291      	cmp	r1, r2
 c054fda:	d0fb      	beq.n	c054fd4 <mbedtls_cipher_info_from_type+0x8>
    for( def = mbedtls_cipher_definitions; def->info != NULL; def++ )
 c054fdc:	3308      	adds	r3, #8
 c054fde:	e7f7      	b.n	c054fd0 <mbedtls_cipher_info_from_type+0x4>
 c054fe0:	0c05fe54 	.word	0x0c05fe54

0c054fe4 <mbedtls_cipher_info_from_values>:
{
 c054fe4:	b530      	push	{r4, r5, lr}
 c054fe6:	4604      	mov	r4, r0
    for( def = mbedtls_cipher_definitions; def->info != NULL; def++ )
 c054fe8:	4b08      	ldr	r3, [pc, #32]	@ (c05500c <mbedtls_cipher_info_from_values+0x28>)
 c054fea:	6858      	ldr	r0, [r3, #4]
 c054fec:	b900      	cbnz	r0, c054ff0 <mbedtls_cipher_info_from_values+0xc>
}
 c054fee:	bd30      	pop	{r4, r5, pc}
        if( def->info->base->cipher == cipher_id &&
 c054ff0:	6985      	ldr	r5, [r0, #24]
 c054ff2:	782d      	ldrb	r5, [r5, #0]
 c054ff4:	42a5      	cmp	r5, r4
 c054ff6:	d106      	bne.n	c055006 <mbedtls_cipher_info_from_values+0x22>
 c054ff8:	6845      	ldr	r5, [r0, #4]
 c054ffa:	428d      	cmp	r5, r1
 c054ffc:	d000      	beq.n	c055000 <mbedtls_cipher_info_from_values+0x1c>
           ((def->info->key_bitlen == (unsigned) key_bitlen) || (key_bitlen == 0)) &&
 c054ffe:	b911      	cbnz	r1, c055006 <mbedtls_cipher_info_from_values+0x22>
 c055000:	7845      	ldrb	r5, [r0, #1]
 c055002:	4295      	cmp	r5, r2
 c055004:	d0f3      	beq.n	c054fee <mbedtls_cipher_info_from_values+0xa>
    for( def = mbedtls_cipher_definitions; def->info != NULL; def++ )
 c055006:	3308      	adds	r3, #8
 c055008:	e7ef      	b.n	c054fea <mbedtls_cipher_info_from_values+0x6>
 c05500a:	bf00      	nop
 c05500c:	0c05fe54 	.word	0x0c05fe54

0c055010 <mbedtls_cipher_init>:
    memset( ctx, 0, sizeof( mbedtls_cipher_context_t ) );
 c055010:	2244      	movs	r2, #68	@ 0x44
 c055012:	2100      	movs	r1, #0
 c055014:	f006 bb8b 	b.w	c05b72e <memset>

0c055018 <mbedtls_cipher_free>:
{
 c055018:	b510      	push	{r4, lr}
    if( ctx == NULL )
 c05501a:	4604      	mov	r4, r0
 c05501c:	b198      	cbz	r0, c055046 <mbedtls_cipher_free+0x2e>
    if( ctx->cmac_ctx )
 c05501e:	6c00      	ldr	r0, [r0, #64]	@ 0x40
 c055020:	b128      	cbz	r0, c05502e <mbedtls_cipher_free+0x16>
       mbedtls_platform_zeroize( ctx->cmac_ctx,
 c055022:	2124      	movs	r1, #36	@ 0x24
 c055024:	f7e6 f9d4 	bl	c03b3d0 <mbedtls_platform_zeroize>
       mbedtls_free( ctx->cmac_ctx );
 c055028:	6c20      	ldr	r0, [r4, #64]	@ 0x40
 c05502a:	f7e6 f9c1 	bl	c03b3b0 <mbedtls_free>
    if( ctx->cipher_ctx )
 c05502e:	6be0      	ldr	r0, [r4, #60]	@ 0x3c
 c055030:	b118      	cbz	r0, c05503a <mbedtls_cipher_free+0x22>
        ctx->cipher_info->base->ctx_free_func( ctx->cipher_ctx );
 c055032:	6823      	ldr	r3, [r4, #0]
 c055034:	699b      	ldr	r3, [r3, #24]
 c055036:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 c055038:	4798      	blx	r3
    mbedtls_platform_zeroize( ctx, sizeof(mbedtls_cipher_context_t) );
 c05503a:	4620      	mov	r0, r4
}
 c05503c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mbedtls_platform_zeroize( ctx, sizeof(mbedtls_cipher_context_t) );
 c055040:	2144      	movs	r1, #68	@ 0x44
 c055042:	f7e6 b9c5 	b.w	c03b3d0 <mbedtls_platform_zeroize>
}
 c055046:	bd10      	pop	{r4, pc}

0c055048 <mbedtls_cipher_setkey>:
{
 c055048:	b430      	push	{r4, r5}
    if( ctx->cipher_info == NULL )
 c05504a:	6804      	ldr	r4, [r0, #0]
 c05504c:	b1b4      	cbz	r4, c05507c <mbedtls_cipher_setkey+0x34>
    if( ( ctx->cipher_info->flags & MBEDTLS_CIPHER_VARIABLE_KEY_LEN ) == 0 &&
 c05504e:	6925      	ldr	r5, [r4, #16]
 c055050:	07ad      	lsls	r5, r5, #30
 c055052:	d402      	bmi.n	c05505a <mbedtls_cipher_setkey+0x12>
 c055054:	6865      	ldr	r5, [r4, #4]
 c055056:	4295      	cmp	r5, r2
 c055058:	d110      	bne.n	c05507c <mbedtls_cipher_setkey+0x34>
    if( MBEDTLS_ENCRYPT == operation ||
 c05505a:	2b01      	cmp	r3, #1
    ctx->key_bitlen = key_bitlen;
 c05505c:	6042      	str	r2, [r0, #4]
    ctx->operation = operation;
 c05505e:	7203      	strb	r3, [r0, #8]
    if( MBEDTLS_ENCRYPT == operation ||
 c055060:	d003      	beq.n	c05506a <mbedtls_cipher_setkey+0x22>
 c055062:	7865      	ldrb	r5, [r4, #1]
 c055064:	3d03      	subs	r5, #3
 c055066:	2d02      	cmp	r5, #2
 c055068:	d804      	bhi.n	c055074 <mbedtls_cipher_setkey+0x2c>
        return( ctx->cipher_info->base->setkey_enc_func( ctx->cipher_ctx, key,
 c05506a:	69a3      	ldr	r3, [r4, #24]
 c05506c:	699b      	ldr	r3, [r3, #24]
        return( ctx->cipher_info->base->setkey_dec_func( ctx->cipher_ctx, key,
 c05506e:	6bc0      	ldr	r0, [r0, #60]	@ 0x3c
}
 c055070:	bc30      	pop	{r4, r5}
        return( ctx->cipher_info->base->setkey_dec_func( ctx->cipher_ctx, key,
 c055072:	4718      	bx	r3
    if( MBEDTLS_DECRYPT == operation )
 c055074:	b913      	cbnz	r3, c05507c <mbedtls_cipher_setkey+0x34>
        return( ctx->cipher_info->base->setkey_dec_func( ctx->cipher_ctx, key,
 c055076:	69a3      	ldr	r3, [r4, #24]
 c055078:	69db      	ldr	r3, [r3, #28]
 c05507a:	e7f8      	b.n	c05506e <mbedtls_cipher_setkey+0x26>
}
 c05507c:	4801      	ldr	r0, [pc, #4]	@ (c055084 <mbedtls_cipher_setkey+0x3c>)
 c05507e:	bc30      	pop	{r4, r5}
 c055080:	4770      	bx	lr
 c055082:	bf00      	nop
 c055084:	ffff9f00 	.word	0xffff9f00

0c055088 <mbedtls_cipher_set_iv>:
{
 c055088:	b538      	push	{r3, r4, r5, lr}
    if( ctx->cipher_info == NULL )
 c05508a:	6803      	ldr	r3, [r0, #0]
{
 c05508c:	4605      	mov	r5, r0
 c05508e:	4614      	mov	r4, r2
    if( ctx->cipher_info == NULL )
 c055090:	b19b      	cbz	r3, c0550ba <mbedtls_cipher_set_iv+0x32>
    if( iv_len > MBEDTLS_MAX_IV_LENGTH )
 c055092:	2a10      	cmp	r2, #16
 c055094:	d80f      	bhi.n	c0550b6 <mbedtls_cipher_set_iv+0x2e>
    if( ( ctx->cipher_info->flags & MBEDTLS_CIPHER_VARIABLE_IV_LEN ) != 0 )
 c055096:	691a      	ldr	r2, [r3, #16]
 c055098:	07d2      	lsls	r2, r2, #31
 c05509a:	d403      	bmi.n	c0550a4 <mbedtls_cipher_set_iv+0x1c>
        actual_iv_size = ctx->cipher_info->iv_size;
 c05509c:	68db      	ldr	r3, [r3, #12]
        if( actual_iv_size > iv_len )
 c05509e:	429c      	cmp	r4, r3
 c0550a0:	d30b      	bcc.n	c0550ba <mbedtls_cipher_set_iv+0x32>
 c0550a2:	461c      	mov	r4, r3
    if ( actual_iv_size != 0 )
 c0550a4:	b12c      	cbz	r4, c0550b2 <mbedtls_cipher_set_iv+0x2a>
        memcpy( ctx->iv, iv, actual_iv_size );
 c0550a6:	4622      	mov	r2, r4
 c0550a8:	f105 0028 	add.w	r0, r5, #40	@ 0x28
 c0550ac:	f006 face 	bl	c05b64c <memcpy>
        ctx->iv_size = actual_iv_size;
 c0550b0:	63ac      	str	r4, [r5, #56]	@ 0x38
    return( 0 );
 c0550b2:	2000      	movs	r0, #0
}
 c0550b4:	bd38      	pop	{r3, r4, r5, pc}
        return( MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE );
 c0550b6:	4802      	ldr	r0, [pc, #8]	@ (c0550c0 <mbedtls_cipher_set_iv+0x38>)
 c0550b8:	e7fc      	b.n	c0550b4 <mbedtls_cipher_set_iv+0x2c>
        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );
 c0550ba:	4802      	ldr	r0, [pc, #8]	@ (c0550c4 <mbedtls_cipher_set_iv+0x3c>)
 c0550bc:	e7fa      	b.n	c0550b4 <mbedtls_cipher_set_iv+0x2c>
 c0550be:	bf00      	nop
 c0550c0:	ffff9f80 	.word	0xffff9f80
 c0550c4:	ffff9f00 	.word	0xffff9f00

0c0550c8 <mbedtls_cipher_update>:
{
 c0550c8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c0550cc:	4615      	mov	r5, r2
    if( ctx->cipher_info == NULL )
 c0550ce:	6802      	ldr	r2, [r0, #0]
{
 c0550d0:	b085      	sub	sp, #20
 c0550d2:	4604      	mov	r4, r0
 c0550d4:	460e      	mov	r6, r1
 c0550d6:	469a      	mov	sl, r3
 c0550d8:	f8dd 9038 	ldr.w	r9, [sp, #56]	@ 0x38
    if( ctx->cipher_info == NULL )
 c0550dc:	b91a      	cbnz	r2, c0550e6 <mbedtls_cipher_update+0x1e>
        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );
 c0550de:	4874      	ldr	r0, [pc, #464]	@ (c0552b0 <mbedtls_cipher_update+0x1e8>)
}
 c0550e0:	b005      	add	sp, #20
 c0550e2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    *olen = 0;
 c0550e6:	2100      	movs	r1, #0
 c0550e8:	f8c9 1000 	str.w	r1, [r9]
{
    MBEDTLS_INTERNAL_VALIDATE_RET( ctx != NULL, 0 );
    if( ctx->cipher_info == NULL )
        return 0;

    return ctx->cipher_info->block_size;
 c0550ec:	6957      	ldr	r7, [r2, #20]
    if ( 0 == block_size )
 c0550ee:	2f00      	cmp	r7, #0
 c0550f0:	f000 80d8 	beq.w	c0552a4 <mbedtls_cipher_update+0x1dc>
    if( ctx->cipher_info->mode == MBEDTLS_MODE_ECB )
 c0550f4:	7851      	ldrb	r1, [r2, #1]
 c0550f6:	2901      	cmp	r1, #1
 c0550f8:	d10f      	bne.n	c05511a <mbedtls_cipher_update+0x52>
        if( ilen != block_size )
 c0550fa:	42bd      	cmp	r5, r7
 c0550fc:	f040 80d4 	bne.w	c0552a8 <mbedtls_cipher_update+0x1e0>
        if( 0 != ( ret = ctx->cipher_info->base->ecb_func( ctx->cipher_ctx,
 c055100:	6992      	ldr	r2, [r2, #24]
        *olen = ilen;
 c055102:	f8c9 5000 	str.w	r5, [r9]
        if( 0 != ( ret = ctx->cipher_info->base->ecb_func( ctx->cipher_ctx,
 c055106:	6855      	ldr	r5, [r2, #4]
 c055108:	4632      	mov	r2, r6
 c05510a:	46ac      	mov	ip, r5
 c05510c:	f990 1008 	ldrsb.w	r1, [r0, #8]
 c055110:	6bc0      	ldr	r0, [r0, #60]	@ 0x3c
}
 c055112:	b005      	add	sp, #20
 c055114:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
        if( 0 != ( ret = ctx->cipher_info->base->ecb_func( ctx->cipher_ctx,
 c055118:	4760      	bx	ip
    if( ctx->cipher_info->mode == MBEDTLS_MODE_GCM )
 c05511a:	2906      	cmp	r1, #6
 c05511c:	d109      	bne.n	c055132 <mbedtls_cipher_update+0x6a>
        return( mbedtls_gcm_update( (mbedtls_gcm_context *) ctx->cipher_ctx, ilen, input,
 c05511e:	4632      	mov	r2, r6
 c055120:	4629      	mov	r1, r5
 c055122:	6bc0      	ldr	r0, [r0, #60]	@ 0x3c
        *olen = ilen;
 c055124:	f8c9 5000 	str.w	r5, [r9]
}
 c055128:	b005      	add	sp, #20
 c05512a:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
        return( mbedtls_gcm_update( (mbedtls_gcm_context *) ctx->cipher_ctx, ilen, input,
 c05512e:	f7f9 b86f 	b.w	c04e210 <mbedtls_gcm_update>
    if( input == output &&
 c055132:	429e      	cmp	r6, r3
 c055134:	d108      	bne.n	c055148 <mbedtls_cipher_update+0x80>
 c055136:	6a43      	ldr	r3, [r0, #36]	@ 0x24
 c055138:	2b00      	cmp	r3, #0
 c05513a:	d1d0      	bne.n	c0550de <mbedtls_cipher_update+0x16>
       ( ctx->unprocessed_len != 0 || ilen % block_size ) )
 c05513c:	fbb5 f3f7 	udiv	r3, r5, r7
 c055140:	fb07 5313 	mls	r3, r7, r3, r5
 c055144:	2b00      	cmp	r3, #0
 c055146:	d1ca      	bne.n	c0550de <mbedtls_cipher_update+0x16>
    if( ctx->cipher_info->mode == MBEDTLS_MODE_CBC )
 c055148:	3902      	subs	r1, #2
 c05514a:	2903      	cmp	r1, #3
 c05514c:	f200 80ae 	bhi.w	c0552ac <mbedtls_cipher_update+0x1e4>
 c055150:	e8df f001 	tbb	[pc, r1]
 c055154:	998d7902 	.word	0x998d7902
        if( ( ctx->operation == MBEDTLS_DECRYPT && NULL != ctx->add_padding &&
 c055158:	f994 3008 	ldrsb.w	r3, [r4, #8]
       ( ctx->unprocessed_len != 0 || ilen % block_size ) )
 c05515c:	f8d4 8024 	ldr.w	r8, [r4, #36]	@ 0x24
        if( ( ctx->operation == MBEDTLS_DECRYPT && NULL != ctx->add_padding &&
 c055160:	b98b      	cbnz	r3, c055186 <mbedtls_cipher_update+0xbe>
 c055162:	68e2      	ldr	r2, [r4, #12]
 c055164:	eba7 0308 	sub.w	r3, r7, r8
 c055168:	b18a      	cbz	r2, c05518e <mbedtls_cipher_update+0xc6>
 c05516a:	42ab      	cmp	r3, r5
 c05516c:	d311      	bcc.n	c055192 <mbedtls_cipher_update+0xca>
            memcpy( &( ctx->unprocessed_data[ctx->unprocessed_len] ), input,
 c05516e:	f108 0014 	add.w	r0, r8, #20
 c055172:	462a      	mov	r2, r5
 c055174:	4631      	mov	r1, r6
 c055176:	4420      	add	r0, r4
 c055178:	f006 fa68 	bl	c05b64c <memcpy>
            ctx->unprocessed_len += ilen;
 c05517c:	6a63      	ldr	r3, [r4, #36]	@ 0x24
 c05517e:	442b      	add	r3, r5
 c055180:	6263      	str	r3, [r4, #36]	@ 0x24
        return( 0 );
 c055182:	2000      	movs	r0, #0
 c055184:	e7ac      	b.n	c0550e0 <mbedtls_cipher_update+0x18>
                ilen < block_size - ctx->unprocessed_len ) ||
 c055186:	2b01      	cmp	r3, #1
 c055188:	d103      	bne.n	c055192 <mbedtls_cipher_update+0xca>
                ilen < block_size - ctx->unprocessed_len ) )
 c05518a:	eba7 0308 	sub.w	r3, r7, r8
             ( ctx->operation == MBEDTLS_ENCRYPT &&
 c05518e:	42ab      	cmp	r3, r5
 c055190:	d8ed      	bhi.n	c05516e <mbedtls_cipher_update+0xa6>
        if( 0 != ctx->unprocessed_len )
 c055192:	f1b8 0f00 	cmp.w	r8, #0
 c055196:	d024      	beq.n	c0551e2 <mbedtls_cipher_update+0x11a>
            copy_len = block_size - ctx->unprocessed_len;
 c055198:	eba7 0b08 	sub.w	fp, r7, r8
            memcpy( &( ctx->unprocessed_data[ctx->unprocessed_len] ), input,
 c05519c:	f108 0014 	add.w	r0, r8, #20
 c0551a0:	465a      	mov	r2, fp
 c0551a2:	4631      	mov	r1, r6
 c0551a4:	4420      	add	r0, r4
 c0551a6:	f006 fa51 	bl	c05b64c <memcpy>
            if( 0 != ( ret = ctx->cipher_info->base->cbc_func( ctx->cipher_ctx,
 c0551aa:	4623      	mov	r3, r4
 c0551ac:	f853 2b14 	ldr.w	r2, [r3], #20
 c0551b0:	6992      	ldr	r2, [r2, #24]
 c0551b2:	e9cd 3a00 	strd	r3, sl, [sp]
 c0551b6:	6893      	ldr	r3, [r2, #8]
 c0551b8:	f994 1008 	ldrsb.w	r1, [r4, #8]
 c0551bc:	469c      	mov	ip, r3
 c0551be:	463a      	mov	r2, r7
 c0551c0:	6be0      	ldr	r0, [r4, #60]	@ 0x3c
 c0551c2:	f104 0328 	add.w	r3, r4, #40	@ 0x28
 c0551c6:	47e0      	blx	ip
 c0551c8:	2800      	cmp	r0, #0
 c0551ca:	d189      	bne.n	c0550e0 <mbedtls_cipher_update+0x18>
            *olen += block_size;
 c0551cc:	f8d9 3000 	ldr.w	r3, [r9]
 c0551d0:	44a8      	add	r8, r5
 c0551d2:	443b      	add	r3, r7
 c0551d4:	f8c9 3000 	str.w	r3, [r9]
            output += block_size;
 c0551d8:	44ba      	add	sl, r7
            ctx->unprocessed_len = 0;
 c0551da:	6260      	str	r0, [r4, #36]	@ 0x24
            input += copy_len;
 c0551dc:	445e      	add	r6, fp
            ilen -= copy_len;
 c0551de:	eba8 0507 	sub.w	r5, r8, r7
        if( 0 != ilen )
 c0551e2:	2d00      	cmp	r5, #0
 c0551e4:	d0cd      	beq.n	c055182 <mbedtls_cipher_update+0xba>
            copy_len = ilen % block_size;
 c0551e6:	fbb5 f8f7 	udiv	r8, r5, r7
 c0551ea:	fb07 5818 	mls	r8, r7, r8, r5
            if( copy_len == 0 &&
 c0551ee:	f1b8 0f00 	cmp.w	r8, #0
 c0551f2:	d106      	bne.n	c055202 <mbedtls_cipher_update+0x13a>
 c0551f4:	f994 3008 	ldrsb.w	r3, [r4, #8]
 c0551f8:	b91b      	cbnz	r3, c055202 <mbedtls_cipher_update+0x13a>
                ctx->operation == MBEDTLS_DECRYPT &&
 c0551fa:	68e3      	ldr	r3, [r4, #12]
 c0551fc:	2b00      	cmp	r3, #0
 c0551fe:	bf18      	it	ne
 c055200:	46b8      	movne	r8, r7
            memcpy( ctx->unprocessed_data, &( input[ilen - copy_len] ),
 c055202:	eba5 0508 	sub.w	r5, r5, r8
 c055206:	4642      	mov	r2, r8
 c055208:	1971      	adds	r1, r6, r5
 c05520a:	f104 0014 	add.w	r0, r4, #20
 c05520e:	f006 fa1d 	bl	c05b64c <memcpy>
            ctx->unprocessed_len += copy_len;
 c055212:	6a63      	ldr	r3, [r4, #36]	@ 0x24
 c055214:	4443      	add	r3, r8
 c055216:	6263      	str	r3, [r4, #36]	@ 0x24
        if( ilen )
 c055218:	2d00      	cmp	r5, #0
 c05521a:	d0b2      	beq.n	c055182 <mbedtls_cipher_update+0xba>
            if( 0 != ( ret = ctx->cipher_info->base->cbc_func( ctx->cipher_ctx,
 c05521c:	6823      	ldr	r3, [r4, #0]
 c05521e:	462a      	mov	r2, r5
 c055220:	699b      	ldr	r3, [r3, #24]
 c055222:	e9cd 6a00 	strd	r6, sl, [sp]
 c055226:	689e      	ldr	r6, [r3, #8]
 c055228:	f994 1008 	ldrsb.w	r1, [r4, #8]
 c05522c:	6be0      	ldr	r0, [r4, #60]	@ 0x3c
 c05522e:	f104 0328 	add.w	r3, r4, #40	@ 0x28
 c055232:	47b0      	blx	r6
 c055234:	2800      	cmp	r0, #0
 c055236:	f47f af53 	bne.w	c0550e0 <mbedtls_cipher_update+0x18>
            *olen += ilen;
 c05523a:	f8d9 3000 	ldr.w	r3, [r9]
 c05523e:	442b      	add	r3, r5
 c055240:	f8c9 3000 	str.w	r3, [r9]
 c055244:	e79d      	b.n	c055182 <mbedtls_cipher_update+0xba>
        if( 0 != ( ret = ctx->cipher_info->base->cfb_func( ctx->cipher_ctx,
 c055246:	6993      	ldr	r3, [r2, #24]
 c055248:	e9cd 6a01 	strd	r6, sl, [sp, #4]
                ctx->operation, ilen, &ctx->unprocessed_len, ctx->iv,
 c05524c:	f104 0228 	add.w	r2, r4, #40	@ 0x28
        if( 0 != ( ret = ctx->cipher_info->base->cfb_func( ctx->cipher_ctx,
 c055250:	9200      	str	r2, [sp, #0]
 c055252:	68de      	ldr	r6, [r3, #12]
 c055254:	462a      	mov	r2, r5
 c055256:	f994 1008 	ldrsb.w	r1, [r4, #8]
 c05525a:	6be0      	ldr	r0, [r4, #60]	@ 0x3c
 c05525c:	f104 0324 	add.w	r3, r4, #36	@ 0x24
 c055260:	47b0      	blx	r6
        if( 0 != ( ret = ctx->cipher_info->base->ofb_func( ctx->cipher_ctx,
 c055262:	2800      	cmp	r0, #0
 c055264:	f47f af3c 	bne.w	c0550e0 <mbedtls_cipher_update+0x18>
        *olen = ilen;
 c055268:	f8c9 5000 	str.w	r5, [r9]
        return( 0 );
 c05526c:	e789      	b.n	c055182 <mbedtls_cipher_update+0xba>
        if( 0 != ( ret = ctx->cipher_info->base->ofb_func( ctx->cipher_ctx,
 c05526e:	6993      	ldr	r3, [r2, #24]
 c055270:	e9cd 6a00 	strd	r6, sl, [sp]
 c055274:	4629      	mov	r1, r5
 c055276:	691e      	ldr	r6, [r3, #16]
 c055278:	6be0      	ldr	r0, [r4, #60]	@ 0x3c
 c05527a:	f104 0328 	add.w	r3, r4, #40	@ 0x28
 c05527e:	f104 0224 	add.w	r2, r4, #36	@ 0x24
 c055282:	47b0      	blx	r6
 c055284:	e7ed      	b.n	c055262 <mbedtls_cipher_update+0x19a>
        if( 0 != ( ret = ctx->cipher_info->base->ctr_func( ctx->cipher_ctx,
 c055286:	6993      	ldr	r3, [r2, #24]
 c055288:	e9cd 6a01 	strd	r6, sl, [sp, #4]
                ctx->unprocessed_data, input, output ) ) )
 c05528c:	f104 0214 	add.w	r2, r4, #20
        if( 0 != ( ret = ctx->cipher_info->base->ctr_func( ctx->cipher_ctx,
 c055290:	9200      	str	r2, [sp, #0]
 c055292:	695e      	ldr	r6, [r3, #20]
 c055294:	4629      	mov	r1, r5
 c055296:	6be0      	ldr	r0, [r4, #60]	@ 0x3c
 c055298:	f104 0328 	add.w	r3, r4, #40	@ 0x28
 c05529c:	f104 0224 	add.w	r2, r4, #36	@ 0x24
 c0552a0:	47b0      	blx	r6
 c0552a2:	e7de      	b.n	c055262 <mbedtls_cipher_update+0x19a>
        return( MBEDTLS_ERR_CIPHER_INVALID_CONTEXT );
 c0552a4:	4803      	ldr	r0, [pc, #12]	@ (c0552b4 <mbedtls_cipher_update+0x1ec>)
 c0552a6:	e71b      	b.n	c0550e0 <mbedtls_cipher_update+0x18>
            return( MBEDTLS_ERR_CIPHER_FULL_BLOCK_EXPECTED );
 c0552a8:	4803      	ldr	r0, [pc, #12]	@ (c0552b8 <mbedtls_cipher_update+0x1f0>)
 c0552aa:	e719      	b.n	c0550e0 <mbedtls_cipher_update+0x18>
        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );
 c0552ac:	4803      	ldr	r0, [pc, #12]	@ (c0552bc <mbedtls_cipher_update+0x1f4>)
 c0552ae:	e717      	b.n	c0550e0 <mbedtls_cipher_update+0x18>
 c0552b0:	ffff9f00 	.word	0xffff9f00
 c0552b4:	ffff9c80 	.word	0xffff9c80
 c0552b8:	ffff9d80 	.word	0xffff9d80
 c0552bc:	ffff9f80 	.word	0xffff9f80

0c0552c0 <mbedtls_cipher_finish>:
                   unsigned char *output, size_t *olen )
{
    CIPHER_VALIDATE_RET( ctx != NULL );
    CIPHER_VALIDATE_RET( output != NULL );
    CIPHER_VALIDATE_RET( olen != NULL );
    if( ctx->cipher_info == NULL )
 c0552c0:	6803      	ldr	r3, [r0, #0]
{
 c0552c2:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 c0552c4:	4604      	mov	r4, r0
 c0552c6:	460e      	mov	r6, r1
 c0552c8:	4615      	mov	r5, r2
    if( ctx->cipher_info == NULL )
 c0552ca:	2b00      	cmp	r3, #0
 c0552cc:	d04e      	beq.n	c05536c <mbedtls_cipher_finish+0xac>
         * accessible through the cipher layer. */
        return( MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE );
    }
#endif /* MBEDTLS_USE_PSA_CRYPTO */

    *olen = 0;
 c0552ce:	2200      	movs	r2, #0
 c0552d0:	602a      	str	r2, [r5, #0]

    if( MBEDTLS_MODE_CFB == ctx->cipher_info->mode ||
 c0552d2:	785a      	ldrb	r2, [r3, #1]
 c0552d4:	1ed1      	subs	r1, r2, #3
 c0552d6:	2904      	cmp	r1, #4
 c0552d8:	d901      	bls.n	c0552de <mbedtls_cipher_finish+0x1e>
        MBEDTLS_MODE_OFB == ctx->cipher_info->mode ||
        MBEDTLS_MODE_CTR == ctx->cipher_info->mode ||
        MBEDTLS_MODE_GCM == ctx->cipher_info->mode ||
 c0552da:	2a09      	cmp	r2, #9
 c0552dc:	d102      	bne.n	c0552e4 <mbedtls_cipher_finish+0x24>
        MBEDTLS_MODE_XTS == ctx->cipher_info->mode ||
        MBEDTLS_MODE_STREAM == ctx->cipher_info->mode )
    {
        return( 0 );
 c0552de:	2000      	movs	r0, #0
#else
    ((void) output);
#endif /* MBEDTLS_CIPHER_MODE_CBC */

    return( MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE );
}
 c0552e0:	b003      	add	sp, #12
 c0552e2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if ( ( MBEDTLS_CIPHER_CHACHA20          == ctx->cipher_info->type ) ||
 c0552e4:	7819      	ldrb	r1, [r3, #0]
 c0552e6:	3948      	subs	r1, #72	@ 0x48
 c0552e8:	2901      	cmp	r1, #1
 c0552ea:	d9f8      	bls.n	c0552de <mbedtls_cipher_finish+0x1e>
    if( MBEDTLS_MODE_ECB == ctx->cipher_info->mode )
 c0552ec:	2a01      	cmp	r2, #1
 c0552ee:	d104      	bne.n	c0552fa <mbedtls_cipher_finish+0x3a>
        if( ctx->unprocessed_len != 0 )
 c0552f0:	6a43      	ldr	r3, [r0, #36]	@ 0x24
 c0552f2:	2b00      	cmp	r3, #0
 c0552f4:	d0f3      	beq.n	c0552de <mbedtls_cipher_finish+0x1e>
            return( MBEDTLS_ERR_CIPHER_FULL_BLOCK_EXPECTED );
 c0552f6:	481f      	ldr	r0, [pc, #124]	@ (c055374 <mbedtls_cipher_finish+0xb4>)
 c0552f8:	e7f2      	b.n	c0552e0 <mbedtls_cipher_finish+0x20>
    if( MBEDTLS_MODE_CBC == ctx->cipher_info->mode )
 c0552fa:	2a02      	cmp	r2, #2
 c0552fc:	d138      	bne.n	c055370 <mbedtls_cipher_finish+0xb0>
        if( MBEDTLS_ENCRYPT == ctx->operation )
 c0552fe:	f990 1008 	ldrsb.w	r1, [r0, #8]
        if( ctx->unprocessed_len != 0 )
 c055302:	6a42      	ldr	r2, [r0, #36]	@ 0x24
        if( MBEDTLS_ENCRYPT == ctx->operation )
 c055304:	2901      	cmp	r1, #1
 c055306:	d126      	bne.n	c055356 <mbedtls_cipher_finish+0x96>
            if( NULL == ctx->add_padding )
 c055308:	68c7      	ldr	r7, [r0, #12]
 c05530a:	b917      	cbnz	r7, c055312 <mbedtls_cipher_finish+0x52>
            if( NULL == ctx->add_padding && 0 == ctx->unprocessed_len )
 c05530c:	2a00      	cmp	r2, #0
 c05530e:	d0e6      	beq.n	c0552de <mbedtls_cipher_finish+0x1e>
 c055310:	e7f1      	b.n	c0552f6 <mbedtls_cipher_finish+0x36>
{
    MBEDTLS_INTERNAL_VALIDATE_RET( ctx != NULL, 0 );
    if( ctx->cipher_info == NULL )
        return 0;

    if( ctx->iv_size != 0 )
 c055312:	6ba1      	ldr	r1, [r4, #56]	@ 0x38
            ctx->add_padding( ctx->unprocessed_data, mbedtls_cipher_get_iv_size( ctx ),
 c055314:	3014      	adds	r0, #20
 c055316:	b901      	cbnz	r1, c05531a <mbedtls_cipher_finish+0x5a>
        return (int) ctx->iv_size;

    return (int) ctx->cipher_info->iv_size;
 c055318:	68d9      	ldr	r1, [r3, #12]
 c05531a:	47b8      	blx	r7
        if( 0 != ( ret = ctx->cipher_info->base->cbc_func( ctx->cipher_ctx,
 c05531c:	4623      	mov	r3, r4
 c05531e:	f853 2b28 	ldr.w	r2, [r3], #40
                ctx->unprocessed_data, output ) ) )
 c055322:	f104 0014 	add.w	r0, r4, #20
        if( 0 != ( ret = ctx->cipher_info->base->cbc_func( ctx->cipher_ctx,
 c055326:	6991      	ldr	r1, [r2, #24]
 c055328:	9601      	str	r6, [sp, #4]
 c05532a:	9000      	str	r0, [sp, #0]
 c05532c:	688f      	ldr	r7, [r1, #8]
 c05532e:	6952      	ldr	r2, [r2, #20]
 c055330:	f994 1008 	ldrsb.w	r1, [r4, #8]
 c055334:	6be0      	ldr	r0, [r4, #60]	@ 0x3c
 c055336:	47b8      	blx	r7
 c055338:	2800      	cmp	r0, #0
 c05533a:	d1d1      	bne.n	c0552e0 <mbedtls_cipher_finish+0x20>
        if( MBEDTLS_DECRYPT == ctx->operation )
 c05533c:	f994 3008 	ldrsb.w	r3, [r4, #8]
 c055340:	6821      	ldr	r1, [r4, #0]
 c055342:	b97b      	cbnz	r3, c055364 <mbedtls_cipher_finish+0xa4>
            return( ctx->get_padding( output, mbedtls_cipher_get_block_size( ctx ),
 c055344:	6923      	ldr	r3, [r4, #16]
    if( ctx->cipher_info == NULL )
 c055346:	b101      	cbz	r1, c05534a <mbedtls_cipher_finish+0x8a>
    return ctx->cipher_info->block_size;
 c055348:	6949      	ldr	r1, [r1, #20]
 c05534a:	462a      	mov	r2, r5
 c05534c:	4630      	mov	r0, r6
}
 c05534e:	b003      	add	sp, #12
 c055350:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
            return( ctx->get_padding( output, mbedtls_cipher_get_block_size( ctx ),
 c055354:	4718      	bx	r3
        else if( mbedtls_cipher_get_block_size( ctx ) != ctx->unprocessed_len )
 c055356:	695b      	ldr	r3, [r3, #20]
 c055358:	429a      	cmp	r2, r3
 c05535a:	d0df      	beq.n	c05531c <mbedtls_cipher_finish+0x5c>
            if( NULL == ctx->add_padding && 0 == ctx->unprocessed_len )
 c05535c:	68c3      	ldr	r3, [r0, #12]
 c05535e:	2b00      	cmp	r3, #0
 c055360:	d0d4      	beq.n	c05530c <mbedtls_cipher_finish+0x4c>
 c055362:	e7c8      	b.n	c0552f6 <mbedtls_cipher_finish+0x36>
    if( ctx->cipher_info == NULL )
 c055364:	b101      	cbz	r1, c055368 <mbedtls_cipher_finish+0xa8>
    return ctx->cipher_info->block_size;
 c055366:	6949      	ldr	r1, [r1, #20]
        *olen = mbedtls_cipher_get_block_size( ctx );
 c055368:	6029      	str	r1, [r5, #0]
        return( 0 );
 c05536a:	e7b8      	b.n	c0552de <mbedtls_cipher_finish+0x1e>
        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );
 c05536c:	4802      	ldr	r0, [pc, #8]	@ (c055378 <mbedtls_cipher_finish+0xb8>)
 c05536e:	e7b7      	b.n	c0552e0 <mbedtls_cipher_finish+0x20>
    return( MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE );
 c055370:	4802      	ldr	r0, [pc, #8]	@ (c05537c <mbedtls_cipher_finish+0xbc>)
 c055372:	e7b5      	b.n	c0552e0 <mbedtls_cipher_finish+0x20>
 c055374:	ffff9d80 	.word	0xffff9d80
 c055378:	ffff9f00 	.word	0xffff9f00
 c05537c:	ffff9f80 	.word	0xffff9f80

0c055380 <mbedtls_cipher_set_padding_mode>:
int mbedtls_cipher_set_padding_mode( mbedtls_cipher_context_t *ctx,
                                     mbedtls_cipher_padding_t mode )
{
    CIPHER_VALIDATE_RET( ctx != NULL );

    if( NULL == ctx->cipher_info || MBEDTLS_MODE_CBC != ctx->cipher_info->mode )
 c055380:	6803      	ldr	r3, [r0, #0]
 c055382:	b1db      	cbz	r3, c0553bc <mbedtls_cipher_set_padding_mode+0x3c>
 c055384:	785b      	ldrb	r3, [r3, #1]
 c055386:	2b02      	cmp	r3, #2
 c055388:	d118      	bne.n	c0553bc <mbedtls_cipher_set_padding_mode+0x3c>

        return( 0 );
    }
#endif /* MBEDTLS_USE_PSA_CRYPTO */

    switch( mode )
 c05538a:	2904      	cmp	r1, #4
 c05538c:	d818      	bhi.n	c0553c0 <mbedtls_cipher_set_padding_mode+0x40>
 c05538e:	e8df f001 	tbb	[pc, r1]
 c055392:	1203      	.short	0x1203
 c055394:	0c09      	.short	0x0c09
 c055396:	0f          	.byte	0x0f
 c055397:	00          	.byte	0x00
 c055398:	4a0a      	ldr	r2, [pc, #40]	@ (c0553c4 <mbedtls_cipher_set_padding_mode+0x44>)
 c05539a:	4b0b      	ldr	r3, [pc, #44]	@ (c0553c8 <mbedtls_cipher_set_padding_mode+0x48>)
        ctx->get_padding = get_zeros_padding;
        break;
#endif
    case MBEDTLS_PADDING_NONE:
        ctx->add_padding = NULL;
        ctx->get_padding = get_no_padding;
 c05539c:	e9c0 2303 	strd	r2, r3, [r0, #12]

    default:
        return( MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE );
    }

    return( 0 );
 c0553a0:	2000      	movs	r0, #0
 c0553a2:	4770      	bx	lr
        break;
 c0553a4:	4a09      	ldr	r2, [pc, #36]	@ (c0553cc <mbedtls_cipher_set_padding_mode+0x4c>)
 c0553a6:	4b0a      	ldr	r3, [pc, #40]	@ (c0553d0 <mbedtls_cipher_set_padding_mode+0x50>)
 c0553a8:	e7f8      	b.n	c05539c <mbedtls_cipher_set_padding_mode+0x1c>
        break;
 c0553aa:	4a0a      	ldr	r2, [pc, #40]	@ (c0553d4 <mbedtls_cipher_set_padding_mode+0x54>)
 c0553ac:	4b0a      	ldr	r3, [pc, #40]	@ (c0553d8 <mbedtls_cipher_set_padding_mode+0x58>)
 c0553ae:	e7f5      	b.n	c05539c <mbedtls_cipher_set_padding_mode+0x1c>
        break;
 c0553b0:	2200      	movs	r2, #0
 c0553b2:	4b0a      	ldr	r3, [pc, #40]	@ (c0553dc <mbedtls_cipher_set_padding_mode+0x5c>)
 c0553b4:	e7f2      	b.n	c05539c <mbedtls_cipher_set_padding_mode+0x1c>
    switch( mode )
 c0553b6:	4a0a      	ldr	r2, [pc, #40]	@ (c0553e0 <mbedtls_cipher_set_padding_mode+0x60>)
 c0553b8:	4b0a      	ldr	r3, [pc, #40]	@ (c0553e4 <mbedtls_cipher_set_padding_mode+0x64>)
 c0553ba:	e7ef      	b.n	c05539c <mbedtls_cipher_set_padding_mode+0x1c>
        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );
 c0553bc:	480a      	ldr	r0, [pc, #40]	@ (c0553e8 <mbedtls_cipher_set_padding_mode+0x68>)
 c0553be:	4770      	bx	lr
    switch( mode )
 c0553c0:	480a      	ldr	r0, [pc, #40]	@ (c0553ec <mbedtls_cipher_set_padding_mode+0x6c>)
}
 c0553c2:	4770      	bx	lr
 c0553c4:	0c054e25 	.word	0x0c054e25
 c0553c8:	0c054e3d 	.word	0x0c054e3d
 c0553cc:	0c054ead 	.word	0x0c054ead
 c0553d0:	0c054ed1 	.word	0x0c054ed1
 c0553d4:	0c054f21 	.word	0x0c054f21
 c0553d8:	0c054f49 	.word	0x0c054f49
 c0553dc:	0c054f35 	.word	0x0c054f35
 c0553e0:	0c054e91 	.word	0x0c054e91
 c0553e4:	0c054f7d 	.word	0x0c054f7d
 c0553e8:	ffff9f00 	.word	0xffff9f00
 c0553ec:	ffff9f80 	.word	0xffff9f80

0c0553f0 <mbedtls_cipher_setup>:
{
 c0553f0:	b538      	push	{r3, r4, r5, lr}
 c0553f2:	4604      	mov	r4, r0
    if( cipher_info == NULL )
 c0553f4:	460d      	mov	r5, r1
 c0553f6:	b179      	cbz	r1, c055418 <mbedtls_cipher_setup+0x28>
    memset( ctx, 0, sizeof( mbedtls_cipher_context_t ) );
 c0553f8:	2244      	movs	r2, #68	@ 0x44
 c0553fa:	2100      	movs	r1, #0
 c0553fc:	f006 f997 	bl	c05b72e <memset>
    if( NULL == ( ctx->cipher_ctx = cipher_info->base->ctx_alloc_func() ) )
 c055400:	69ab      	ldr	r3, [r5, #24]
 c055402:	6a1b      	ldr	r3, [r3, #32]
 c055404:	4798      	blx	r3
 c055406:	63e0      	str	r0, [r4, #60]	@ 0x3c
 c055408:	b140      	cbz	r0, c05541c <mbedtls_cipher_setup+0x2c>
    (void) mbedtls_cipher_set_padding_mode( ctx, MBEDTLS_PADDING_PKCS7 );
 c05540a:	2100      	movs	r1, #0
 c05540c:	4620      	mov	r0, r4
    ctx->cipher_info = cipher_info;
 c05540e:	6025      	str	r5, [r4, #0]
    (void) mbedtls_cipher_set_padding_mode( ctx, MBEDTLS_PADDING_PKCS7 );
 c055410:	f7ff ffb6 	bl	c055380 <mbedtls_cipher_set_padding_mode>
    return( 0 );
 c055414:	4608      	mov	r0, r1
}
 c055416:	bd38      	pop	{r3, r4, r5, pc}
        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );
 c055418:	4801      	ldr	r0, [pc, #4]	@ (c055420 <mbedtls_cipher_setup+0x30>)
 c05541a:	e7fc      	b.n	c055416 <mbedtls_cipher_setup+0x26>
        return( MBEDTLS_ERR_CIPHER_ALLOC_FAILED );
 c05541c:	4801      	ldr	r0, [pc, #4]	@ (c055424 <mbedtls_cipher_setup+0x34>)
 c05541e:	e7fa      	b.n	c055416 <mbedtls_cipher_setup+0x26>
 c055420:	ffff9f00 	.word	0xffff9f00
 c055424:	ffff9e80 	.word	0xffff9e80

0c055428 <ccm_ctx_free>:

    return( ctx );
}

static void ccm_ctx_free( void *ctx )
{
 c055428:	b510      	push	{r4, lr}
 c05542a:	4604      	mov	r4, r0
    mbedtls_ccm_free( ctx );
 c05542c:	f7f6 fe7c 	bl	c04c128 <mbedtls_ccm_free>
    mbedtls_free( ctx );
 c055430:	4620      	mov	r0, r4
}
 c055432:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mbedtls_free( ctx );
 c055436:	f7e5 bfbb 	b.w	c03b3b0 <mbedtls_free>

0c05543a <ccm_ctx_alloc>:
{
 c05543a:	b510      	push	{r4, lr}
    void *ctx = mbedtls_calloc( 1, sizeof( mbedtls_ccm_context ) );
 c05543c:	218c      	movs	r1, #140	@ 0x8c
 c05543e:	2001      	movs	r0, #1
 c055440:	f7e5 ffb0 	bl	c03b3a4 <mbedtls_calloc>
    if( ctx != NULL )
 c055444:	4604      	mov	r4, r0
 c055446:	b108      	cbz	r0, c05544c <ccm_ctx_alloc+0x12>
        mbedtls_ccm_init( (mbedtls_ccm_context *) ctx );
 c055448:	f7f6 fe12 	bl	c04c070 <mbedtls_ccm_init>
}
 c05544c:	4620      	mov	r0, r4
 c05544e:	bd10      	pop	{r4, pc}

0c055450 <ccm_aes_setkey_wrap>:
#endif /* MBEDTLS_GCM_C */

#if defined(MBEDTLS_CCM_C)
static int ccm_aes_setkey_wrap( void *ctx, const unsigned char *key,
                                unsigned int key_bitlen )
{
 c055450:	4613      	mov	r3, r2
    return mbedtls_ccm_setkey( (mbedtls_ccm_context *) ctx, MBEDTLS_CIPHER_ID_AES,
 c055452:	460a      	mov	r2, r1
 c055454:	2102      	movs	r1, #2
 c055456:	f7f6 be0f 	b.w	c04c078 <mbedtls_ccm_setkey>

0c05545a <gcm_ctx_free>:
{
 c05545a:	b510      	push	{r4, lr}
 c05545c:	4604      	mov	r4, r0
    mbedtls_gcm_free( ctx );
 c05545e:	f7f9 f81f 	bl	c04e4a0 <mbedtls_gcm_free>
    mbedtls_free( ctx );
 c055462:	4620      	mov	r0, r4
}
 c055464:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mbedtls_free( ctx );
 c055468:	f7e5 bfa2 	b.w	c03b3b0 <mbedtls_free>

0c05546c <gcm_ctx_alloc>:
{
 c05546c:	b510      	push	{r4, lr}
    void *ctx = mbedtls_calloc( 1, sizeof( mbedtls_gcm_context ) );
 c05546e:	f44f 71ec 	mov.w	r1, #472	@ 0x1d8
 c055472:	2001      	movs	r0, #1
 c055474:	f7e5 ff96 	bl	c03b3a4 <mbedtls_calloc>
    if( ctx != NULL )
 c055478:	4604      	mov	r4, r0
 c05547a:	b108      	cbz	r0, c055480 <gcm_ctx_alloc+0x14>
        mbedtls_gcm_init( (mbedtls_gcm_context *) ctx );
 c05547c:	f7f8 fd76 	bl	c04df6c <mbedtls_gcm_init>
}
 c055480:	4620      	mov	r0, r4
 c055482:	bd10      	pop	{r4, pc}

0c055484 <gcm_aes_setkey_wrap>:
{
 c055484:	4613      	mov	r3, r2
    return mbedtls_gcm_setkey( (mbedtls_gcm_context *) ctx, MBEDTLS_CIPHER_ID_AES,
 c055486:	460a      	mov	r2, r1
 c055488:	2102      	movs	r1, #2
 c05548a:	f7f8 bd85 	b.w	c04df98 <mbedtls_gcm_setkey>

0c05548e <aes_ctx_free>:
{
 c05548e:	b510      	push	{r4, lr}
 c055490:	4604      	mov	r4, r0
    mbedtls_aes_free( (mbedtls_aes_context *) ctx );
 c055492:	f7f6 fb5f 	bl	c04bb54 <mbedtls_aes_free>
    mbedtls_free( ctx );
 c055496:	4620      	mov	r0, r4
}
 c055498:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mbedtls_free( ctx );
 c05549c:	f7e5 bf88 	b.w	c03b3b0 <mbedtls_free>

0c0554a0 <aes_ctx_alloc>:
{
 c0554a0:	b510      	push	{r4, lr}
    mbedtls_aes_context *aes = mbedtls_calloc( 1, sizeof( mbedtls_aes_context ) );
 c0554a2:	2190      	movs	r1, #144	@ 0x90
 c0554a4:	2001      	movs	r0, #1
 c0554a6:	f7e5 ff7d 	bl	c03b3a4 <mbedtls_calloc>
    if( aes == NULL )
 c0554aa:	4604      	mov	r4, r0
 c0554ac:	b108      	cbz	r0, c0554b2 <aes_ctx_alloc+0x12>
    mbedtls_aes_init( aes );
 c0554ae:	f7f6 fb47 	bl	c04bb40 <mbedtls_aes_init>
}
 c0554b2:	4620      	mov	r0, r4
 c0554b4:	bd10      	pop	{r4, pc}

0c0554b6 <aes_setkey_dec_wrap>:
    return mbedtls_aes_setkey_dec( (mbedtls_aes_context *) ctx, key, key_bitlen );
 c0554b6:	f7f6 bb59 	b.w	c04bb6c <mbedtls_aes_setkey_dec>

0c0554ba <aes_setkey_enc_wrap>:
    return mbedtls_aes_setkey_enc( (mbedtls_aes_context *) ctx, key, key_bitlen );
 c0554ba:	f7f6 bb55 	b.w	c04bb68 <mbedtls_aes_setkey_enc>

0c0554be <aes_crypt_ctr_wrap>:
    return mbedtls_aes_crypt_ctr( (mbedtls_aes_context *) ctx, length, nc_off, nonce_counter,
 c0554be:	f7f6 bcad 	b.w	c04be1c <mbedtls_aes_crypt_ctr>

0c0554c2 <aes_crypt_ofb_wrap>:
    return mbedtls_aes_crypt_ofb( (mbedtls_aes_context *) ctx, length, iv_off,
 c0554c2:	f7f6 bc82 	b.w	c04bdca <mbedtls_aes_crypt_ofb>

0c0554c6 <aes_crypt_cfb128_wrap>:
    return mbedtls_aes_crypt_cfb128( (mbedtls_aes_context *) ctx, operation, length, iv_off, iv,
 c0554c6:	f7f6 bc40 	b.w	c04bd4a <mbedtls_aes_crypt_cfb128>

0c0554ca <aes_crypt_cbc_wrap>:
    return mbedtls_aes_crypt_cbc( (mbedtls_aes_context *) ctx, operation, length, iv, input,
 c0554ca:	f7f6 bb51 	b.w	c04bb70 <mbedtls_aes_crypt_cbc>

0c0554ce <aes_crypt_ecb_wrap>:
    return mbedtls_aes_crypt_ecb( (mbedtls_aes_context *) ctx, operation, input, output );
 c0554ce:	f7f6 bc11 	b.w	c04bcf4 <mbedtls_aes_crypt_ecb>
	...

0c0554d4 <cmac_multiply_by_u>:
    const unsigned char R_64 = 0x1B;
    unsigned char R_n, mask;
    unsigned char overflow = 0x00;
    int i;

    if( blocksize == MBEDTLS_AES_BLOCK_SIZE )
 c0554d4:	2a10      	cmp	r2, #16
{
 c0554d6:	b5f0      	push	{r4, r5, r6, r7, lr}
    if( blocksize == MBEDTLS_AES_BLOCK_SIZE )
 c0554d8:	d011      	beq.n	c0554fe <cmac_multiply_by_u+0x2a>
    {
        R_n = R_128;
    }
    else if( blocksize == MBEDTLS_DES3_BLOCK_SIZE )
 c0554da:	2a08      	cmp	r2, #8
 c0554dc:	d11a      	bne.n	c055514 <cmac_multiply_by_u+0x40>
    {
        R_n = R_64;
 c0554de:	231b      	movs	r3, #27
    else
    {
        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );
    }

    for( i = (int)blocksize - 1; i >= 0; i-- )
 c0554e0:	1e55      	subs	r5, r2, #1
    unsigned char overflow = 0x00;
 c0554e2:	2400      	movs	r4, #0
 c0554e4:	462e      	mov	r6, r5
 c0554e6:	440a      	add	r2, r1
    for( i = (int)blocksize - 1; i >= 0; i-- )
 c0554e8:	2d00      	cmp	r5, #0
 c0554ea:	da0a      	bge.n	c055502 <cmac_multiply_by_u+0x2e>
     * well-defined and precisely what we want to do here */
#if defined(_MSC_VER)
#pragma warning( push )
#pragma warning( disable : 4146 )
#endif
    mask = - ( input[0] >> 7 );
 c0554ec:	f991 2000 	ldrsb.w	r2, [r1]
#if defined(_MSC_VER)
#pragma warning( pop )
#endif

    output[ blocksize - 1 ] ^= R_n & mask;
 c0554f0:	ea03 73e2 	and.w	r3, r3, r2, asr #31
 c0554f4:	5d82      	ldrb	r2, [r0, r6]
 c0554f6:	4053      	eors	r3, r2
 c0554f8:	5583      	strb	r3, [r0, r6]

    return( 0 );
 c0554fa:	2000      	movs	r0, #0
}
 c0554fc:	bdf0      	pop	{r4, r5, r6, r7, pc}
        R_n = R_128;
 c0554fe:	2387      	movs	r3, #135	@ 0x87
 c055500:	e7ee      	b.n	c0554e0 <cmac_multiply_by_u+0xc>
        output[i] = input[i] << 1 | overflow;
 c055502:	f812 7d01 	ldrb.w	r7, [r2, #-1]!
 c055506:	ea44 0447 	orr.w	r4, r4, r7, lsl #1
 c05550a:	5544      	strb	r4, [r0, r5]
        overflow = input[i] >> 7;
 c05550c:	7814      	ldrb	r4, [r2, #0]
    for( i = (int)blocksize - 1; i >= 0; i-- )
 c05550e:	3d01      	subs	r5, #1
        overflow = input[i] >> 7;
 c055510:	09e4      	lsrs	r4, r4, #7
    for( i = (int)blocksize - 1; i >= 0; i-- )
 c055512:	e7e9      	b.n	c0554e8 <cmac_multiply_by_u+0x14>
        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );
 c055514:	4800      	ldr	r0, [pc, #0]	@ (c055518 <cmac_multiply_by_u+0x44>)
 c055516:	e7f1      	b.n	c0554fc <cmac_multiply_by_u+0x28>
 c055518:	ffff9f00 	.word	0xffff9f00

0c05551c <cmac_xor_block>:

#if !defined(MBEDTLS_CMAC_ALT)
static void cmac_xor_block( unsigned char *output, const unsigned char *input1,
                            const unsigned char *input2,
                            const size_t block_size )
{
 c05551c:	b570      	push	{r4, r5, r6, lr}
    size_t idx;

    for( idx = 0; idx < block_size; idx++ )
 c05551e:	2400      	movs	r4, #0
 c055520:	429c      	cmp	r4, r3
 c055522:	d100      	bne.n	c055526 <cmac_xor_block+0xa>
        output[ idx ] = input1[ idx ] ^ input2[ idx ];
}
 c055524:	bd70      	pop	{r4, r5, r6, pc}
        output[ idx ] = input1[ idx ] ^ input2[ idx ];
 c055526:	5d0d      	ldrb	r5, [r1, r4]
 c055528:	5d16      	ldrb	r6, [r2, r4]
 c05552a:	4075      	eors	r5, r6
 c05552c:	5505      	strb	r5, [r0, r4]
    for( idx = 0; idx < block_size; idx++ )
 c05552e:	3401      	adds	r4, #1
 c055530:	e7f6      	b.n	c055520 <cmac_xor_block+0x4>
	...

0c055534 <mbedtls_cipher_cmac_starts>:
    }
}

int mbedtls_cipher_cmac_starts( mbedtls_cipher_context_t *ctx,
                                const unsigned char *key, size_t keybits )
{
 c055534:	b538      	push	{r3, r4, r5, lr}
    mbedtls_cipher_type_t type;
    mbedtls_cmac_context_t *cmac_ctx;
    int retval;

    if( ctx == NULL || ctx->cipher_info == NULL || key == NULL )
 c055536:	4605      	mov	r5, r0
 c055538:	b1c8      	cbz	r0, c05556e <mbedtls_cipher_cmac_starts+0x3a>
 c05553a:	6804      	ldr	r4, [r0, #0]
 c05553c:	b1bc      	cbz	r4, c05556e <mbedtls_cipher_cmac_starts+0x3a>
 c05553e:	b1b1      	cbz	r1, c05556e <mbedtls_cipher_cmac_starts+0x3a>
        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );

    if( ( retval = mbedtls_cipher_setkey( ctx, key, (int)keybits,
 c055540:	2301      	movs	r3, #1
 c055542:	f7ff fd81 	bl	c055048 <mbedtls_cipher_setkey>
 c055546:	4604      	mov	r4, r0
 c055548:	b990      	cbnz	r0, c055570 <mbedtls_cipher_cmac_starts+0x3c>
                                          MBEDTLS_ENCRYPT ) ) != 0 )
        return( retval );

    type = ctx->cipher_info->type;
 c05554a:	682b      	ldr	r3, [r5, #0]
 c05554c:	781b      	ldrb	r3, [r3, #0]

    switch( type )
 c05554e:	2b04      	cmp	r3, #4
 c055550:	d80b      	bhi.n	c05556a <mbedtls_cipher_cmac_starts+0x36>
 c055552:	2b01      	cmp	r3, #1
 c055554:	d90b      	bls.n	c05556e <mbedtls_cipher_cmac_starts+0x3a>
            return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );
    }

    /* Allocated and initialise in the cipher context memory for the CMAC
     * context */
    cmac_ctx = mbedtls_calloc( 1, sizeof( mbedtls_cmac_context_t ) );
 c055556:	2124      	movs	r1, #36	@ 0x24
 c055558:	2001      	movs	r0, #1
 c05555a:	f7e5 ff23 	bl	c03b3a4 <mbedtls_calloc>
    if( cmac_ctx == NULL )
 c05555e:	b148      	cbz	r0, c055574 <mbedtls_cipher_cmac_starts+0x40>
        return( MBEDTLS_ERR_CIPHER_ALLOC_FAILED );

    ctx->cmac_ctx = cmac_ctx;

    mbedtls_platform_zeroize( cmac_ctx->state, sizeof( cmac_ctx->state ) );
 c055560:	2110      	movs	r1, #16
    ctx->cmac_ctx = cmac_ctx;
 c055562:	6428      	str	r0, [r5, #64]	@ 0x40
    mbedtls_platform_zeroize( cmac_ctx->state, sizeof( cmac_ctx->state ) );
 c055564:	f7e5 ff34 	bl	c03b3d0 <mbedtls_platform_zeroize>

    return 0;
 c055568:	e002      	b.n	c055570 <mbedtls_cipher_cmac_starts+0x3c>
    switch( type )
 c05556a:	2b24      	cmp	r3, #36	@ 0x24
 c05556c:	d0f3      	beq.n	c055556 <mbedtls_cipher_cmac_starts+0x22>
{
 c05556e:	4c02      	ldr	r4, [pc, #8]	@ (c055578 <mbedtls_cipher_cmac_starts+0x44>)
}
 c055570:	4620      	mov	r0, r4
 c055572:	bd38      	pop	{r3, r4, r5, pc}
        return( MBEDTLS_ERR_CIPHER_ALLOC_FAILED );
 c055574:	4c01      	ldr	r4, [pc, #4]	@ (c05557c <mbedtls_cipher_cmac_starts+0x48>)
 c055576:	e7fb      	b.n	c055570 <mbedtls_cipher_cmac_starts+0x3c>
 c055578:	ffff9f00 	.word	0xffff9f00
 c05557c:	ffff9e80 	.word	0xffff9e80

0c055580 <mbedtls_cipher_cmac_update>:

int mbedtls_cipher_cmac_update( mbedtls_cipher_context_t *ctx,
                                const unsigned char *input, size_t ilen )
{
 c055580:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c055584:	460f      	mov	r7, r1
 c055586:	4615      	mov	r5, r2
    mbedtls_cmac_context_t* cmac_ctx;
    unsigned char *state;
    int ret = 0;
    size_t n, j, olen, block_size;

    if( ctx == NULL || ctx->cipher_info == NULL || input == NULL ||
 c055588:	4680      	mov	r8, r0
{
 c05558a:	b085      	sub	sp, #20
    if( ctx == NULL || ctx->cipher_info == NULL || input == NULL ||
 c05558c:	2800      	cmp	r0, #0
 c05558e:	d056      	beq.n	c05563e <mbedtls_cipher_cmac_update+0xbe>
 c055590:	6803      	ldr	r3, [r0, #0]
 c055592:	2b00      	cmp	r3, #0
 c055594:	d053      	beq.n	c05563e <mbedtls_cipher_cmac_update+0xbe>
 c055596:	2900      	cmp	r1, #0
 c055598:	d051      	beq.n	c05563e <mbedtls_cipher_cmac_update+0xbe>
        ctx->cmac_ctx == NULL )
 c05559a:	6c04      	ldr	r4, [r0, #64]	@ 0x40
    if( ctx == NULL || ctx->cipher_info == NULL || input == NULL ||
 c05559c:	2c00      	cmp	r4, #0
 c05559e:	d04e      	beq.n	c05563e <mbedtls_cipher_cmac_update+0xbe>
    block_size = ctx->cipher_info->block_size;
    state = ctx->cmac_ctx->state;

    /* Is there data still to process from the last call, that's greater in
     * size than a block? */
    if( cmac_ctx->unprocessed_len > 0 &&
 c0555a0:	6a20      	ldr	r0, [r4, #32]
    block_size = ctx->cipher_info->block_size;
 c0555a2:	695e      	ldr	r6, [r3, #20]
    if( cmac_ctx->unprocessed_len > 0 &&
 c0555a4:	b1e0      	cbz	r0, c0555e0 <mbedtls_cipher_cmac_update+0x60>
        ilen > block_size - cmac_ctx->unprocessed_len )
 c0555a6:	1a32      	subs	r2, r6, r0
    if( cmac_ctx->unprocessed_len > 0 &&
 c0555a8:	42aa      	cmp	r2, r5
 c0555aa:	d219      	bcs.n	c0555e0 <mbedtls_cipher_cmac_update+0x60>
    {
        memcpy( &cmac_ctx->unprocessed_block[cmac_ctx->unprocessed_len],
 c0555ac:	3010      	adds	r0, #16
 c0555ae:	4420      	add	r0, r4
 c0555b0:	f006 f84c 	bl	c05b64c <memcpy>
                input,
                block_size - cmac_ctx->unprocessed_len );

        cmac_xor_block( state, cmac_ctx->unprocessed_block, state, block_size );
 c0555b4:	4633      	mov	r3, r6
 c0555b6:	4622      	mov	r2, r4
 c0555b8:	4620      	mov	r0, r4
 c0555ba:	f104 0110 	add.w	r1, r4, #16
 c0555be:	f7ff ffad 	bl	c05551c <cmac_xor_block>

        if( ( ret = mbedtls_cipher_update( ctx, state, block_size, state,
 c0555c2:	ab03      	add	r3, sp, #12
 c0555c4:	9300      	str	r3, [sp, #0]
 c0555c6:	4632      	mov	r2, r6
 c0555c8:	4623      	mov	r3, r4
 c0555ca:	4621      	mov	r1, r4
 c0555cc:	4640      	mov	r0, r8
 c0555ce:	f7ff fd7b 	bl	c0550c8 <mbedtls_cipher_update>
 c0555d2:	b9e0      	cbnz	r0, c05560e <mbedtls_cipher_cmac_update+0x8e>
                                           &olen ) ) != 0 )
        {
           goto exit;
        }

        input += block_size - cmac_ctx->unprocessed_len;
 c0555d4:	6a23      	ldr	r3, [r4, #32]
        ilen -= block_size - cmac_ctx->unprocessed_len;
        cmac_ctx->unprocessed_len = 0;
 c0555d6:	6220      	str	r0, [r4, #32]
        input += block_size - cmac_ctx->unprocessed_len;
 c0555d8:	1af2      	subs	r2, r6, r3
 c0555da:	442b      	add	r3, r5
 c0555dc:	4417      	add	r7, r2
        ilen -= block_size - cmac_ctx->unprocessed_len;
 c0555de:	1b9d      	subs	r5, r3, r6
    }

    /* n is the number of blocks including any final partial block */
    n = ( ilen + block_size - 1 ) / block_size;
 c0555e0:	f106 39ff 	add.w	r9, r6, #4294967295	@ 0xffffffff
 c0555e4:	44a9      	add	r9, r5
 c0555e6:	fbb9 f9f6 	udiv	r9, r9, r6

    /* Iterate across the input data in block sized chunks, excluding any
     * final partial or complete block */
    for( j = 1; j < n; j++ )
 c0555ea:	f04f 0a01 	mov.w	sl, #1
    {
        cmac_xor_block( state, input, state, block_size );

        if( ( ret = mbedtls_cipher_update( ctx, state, block_size, state,
 c0555ee:	f10d 0b0c 	add.w	fp, sp, #12
    for( j = 1; j < n; j++ )
 c0555f2:	45ca      	cmp	sl, r9
 c0555f4:	d30e      	bcc.n	c055614 <mbedtls_cipher_cmac_update+0x94>
        ilen -= block_size;
        input += block_size;
    }

    /* If there is data left over that wasn't aligned to a block */
    if( ilen > 0 )
 c0555f6:	b14d      	cbz	r5, c05560c <mbedtls_cipher_cmac_update+0x8c>
    {
        memcpy( &cmac_ctx->unprocessed_block[cmac_ctx->unprocessed_len],
 c0555f8:	6a20      	ldr	r0, [r4, #32]
 c0555fa:	462a      	mov	r2, r5
 c0555fc:	3010      	adds	r0, #16
 c0555fe:	4639      	mov	r1, r7
 c055600:	4420      	add	r0, r4
 c055602:	f006 f823 	bl	c05b64c <memcpy>
                input,
                ilen );
        cmac_ctx->unprocessed_len += ilen;
 c055606:	6a23      	ldr	r3, [r4, #32]
 c055608:	442b      	add	r3, r5
 c05560a:	6223      	str	r3, [r4, #32]
    for( j = 1; j < n; j++ )
 c05560c:	2000      	movs	r0, #0
    }

exit:
    return( ret );
}
 c05560e:	b005      	add	sp, #20
 c055610:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        cmac_xor_block( state, input, state, block_size );
 c055614:	4633      	mov	r3, r6
 c055616:	4622      	mov	r2, r4
 c055618:	4639      	mov	r1, r7
 c05561a:	4620      	mov	r0, r4
 c05561c:	f7ff ff7e 	bl	c05551c <cmac_xor_block>
        if( ( ret = mbedtls_cipher_update( ctx, state, block_size, state,
 c055620:	4623      	mov	r3, r4
 c055622:	4632      	mov	r2, r6
 c055624:	4621      	mov	r1, r4
 c055626:	4640      	mov	r0, r8
 c055628:	f8cd b000 	str.w	fp, [sp]
 c05562c:	f7ff fd4c 	bl	c0550c8 <mbedtls_cipher_update>
 c055630:	2800      	cmp	r0, #0
 c055632:	d1ec      	bne.n	c05560e <mbedtls_cipher_cmac_update+0x8e>
        ilen -= block_size;
 c055634:	1bad      	subs	r5, r5, r6
        input += block_size;
 c055636:	4437      	add	r7, r6
    for( j = 1; j < n; j++ )
 c055638:	f10a 0a01 	add.w	sl, sl, #1
 c05563c:	e7d9      	b.n	c0555f2 <mbedtls_cipher_cmac_update+0x72>
        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );
 c05563e:	4801      	ldr	r0, [pc, #4]	@ (c055644 <mbedtls_cipher_cmac_update+0xc4>)
 c055640:	e7e5      	b.n	c05560e <mbedtls_cipher_cmac_update+0x8e>
 c055642:	bf00      	nop
 c055644:	ffff9f00 	.word	0xffff9f00

0c055648 <mbedtls_cipher_cmac_finish>:

int mbedtls_cipher_cmac_finish( mbedtls_cipher_context_t *ctx,
                                unsigned char *output )
{
 c055648:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 c05564c:	4688      	mov	r8, r1
    unsigned char K2[MBEDTLS_CIPHER_BLKSIZE_MAX];
    unsigned char M_last[MBEDTLS_CIPHER_BLKSIZE_MAX];
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    size_t olen, block_size;

    if( ctx == NULL || ctx->cipher_info == NULL || ctx->cmac_ctx == NULL ||
 c05564e:	4605      	mov	r5, r0
{
 c055650:	b091      	sub	sp, #68	@ 0x44
    if( ctx == NULL || ctx->cipher_info == NULL || ctx->cmac_ctx == NULL ||
 c055652:	2800      	cmp	r0, #0
 c055654:	d07b      	beq.n	c05574e <mbedtls_cipher_cmac_finish+0x106>
 c055656:	6803      	ldr	r3, [r0, #0]
 c055658:	2b00      	cmp	r3, #0
 c05565a:	d078      	beq.n	c05574e <mbedtls_cipher_cmac_finish+0x106>
 c05565c:	6c04      	ldr	r4, [r0, #64]	@ 0x40
 c05565e:	2c00      	cmp	r4, #0
 c055660:	d075      	beq.n	c05574e <mbedtls_cipher_cmac_finish+0x106>
 c055662:	2900      	cmp	r1, #0
 c055664:	d073      	beq.n	c05574e <mbedtls_cipher_cmac_finish+0x106>

    cmac_ctx = ctx->cmac_ctx;
    block_size = ctx->cipher_info->block_size;
    state = cmac_ctx->state;

    mbedtls_platform_zeroize( K1, sizeof( K1 ) );
 c055666:	2110      	movs	r1, #16
 c055668:	eb0d 0001 	add.w	r0, sp, r1
    block_size = ctx->cipher_info->block_size;
 c05566c:	695e      	ldr	r6, [r3, #20]
    mbedtls_platform_zeroize( K1, sizeof( K1 ) );
 c05566e:	f7e5 feaf 	bl	c03b3d0 <mbedtls_platform_zeroize>
    mbedtls_platform_zeroize( K2, sizeof( K2 ) );
 c055672:	2110      	movs	r1, #16
 c055674:	a808      	add	r0, sp, #32
 c055676:	f7e5 feab 	bl	c03b3d0 <mbedtls_platform_zeroize>
    mbedtls_platform_zeroize( L, sizeof( L ) );
 c05567a:	2110      	movs	r1, #16
 c05567c:	a80c      	add	r0, sp, #48	@ 0x30
 c05567e:	f7e5 fea7 	bl	c03b3d0 <mbedtls_platform_zeroize>
    block_size = ctx->cipher_info->block_size;
 c055682:	682b      	ldr	r3, [r5, #0]
    if( ( ret = mbedtls_cipher_update( ctx, L, block_size, L, &olen ) ) != 0 )
 c055684:	af03      	add	r7, sp, #12
    block_size = ctx->cipher_info->block_size;
 c055686:	f8d3 9014 	ldr.w	r9, [r3, #20]
    if( ( ret = mbedtls_cipher_update( ctx, L, block_size, L, &olen ) ) != 0 )
 c05568a:	ab0c      	add	r3, sp, #48	@ 0x30
 c05568c:	464a      	mov	r2, r9
 c05568e:	4619      	mov	r1, r3
 c055690:	4628      	mov	r0, r5
 c055692:	9700      	str	r7, [sp, #0]
 c055694:	f7ff fd18 	bl	c0550c8 <mbedtls_cipher_update>
 c055698:	b950      	cbnz	r0, c0556b0 <mbedtls_cipher_cmac_finish+0x68>
    if( ( ret = cmac_multiply_by_u( K1, L , block_size ) ) != 0 )
 c05569a:	464a      	mov	r2, r9
 c05569c:	a90c      	add	r1, sp, #48	@ 0x30
 c05569e:	a804      	add	r0, sp, #16
 c0556a0:	f7ff ff18 	bl	c0554d4 <cmac_multiply_by_u>
 c0556a4:	b920      	cbnz	r0, c0556b0 <mbedtls_cipher_cmac_finish+0x68>
    if( ( ret = cmac_multiply_by_u( K2, K1 , block_size ) ) != 0 )
 c0556a6:	464a      	mov	r2, r9
 c0556a8:	a904      	add	r1, sp, #16
 c0556aa:	a808      	add	r0, sp, #32
 c0556ac:	f7ff ff12 	bl	c0554d4 <cmac_multiply_by_u>
    mbedtls_platform_zeroize( L, sizeof( L ) );
 c0556b0:	a80c      	add	r0, sp, #48	@ 0x30
 c0556b2:	2110      	movs	r1, #16
 c0556b4:	f7e5 fe8c 	bl	c03b3d0 <mbedtls_platform_zeroize>
    cmac_generate_subkeys( ctx, K1, K2 );

    last_block = cmac_ctx->unprocessed_block;

    /* Calculate last block */
    if( cmac_ctx->unprocessed_len < block_size )
 c0556b8:	6a20      	ldr	r0, [r4, #32]
    last_block = cmac_ctx->unprocessed_block;
 c0556ba:	f104 0910 	add.w	r9, r4, #16
    if( cmac_ctx->unprocessed_len < block_size )
 c0556be:	42b0      	cmp	r0, r6
 c0556c0:	d240      	bcs.n	c055744 <mbedtls_cipher_cmac_finish+0xfc>
    for( j = 0; j < padded_block_len; j++ )
 c0556c2:	2300      	movs	r3, #0
 c0556c4:	a90c      	add	r1, sp, #48	@ 0x30
        if( j < last_block_len )
 c0556c6:	4298      	cmp	r0, r3
 c0556c8:	d937      	bls.n	c05573a <mbedtls_cipher_cmac_finish+0xf2>
            padded_block[j] = last_block[j];
 c0556ca:	f819 2003 	ldrb.w	r2, [r9, r3]
    for( j = 0; j < padded_block_len; j++ )
 c0556ce:	3301      	adds	r3, #1
 c0556d0:	429e      	cmp	r6, r3
            padded_block[j] = last_block[j];
 c0556d2:	f801 2b01 	strb.w	r2, [r1], #1
    for( j = 0; j < padded_block_len; j++ )
 c0556d6:	d1f6      	bne.n	c0556c6 <mbedtls_cipher_cmac_finish+0x7e>
    {
        cmac_pad( M_last, block_size, last_block, cmac_ctx->unprocessed_len );
        cmac_xor_block( M_last, M_last, K2, block_size );
 c0556d8:	a90c      	add	r1, sp, #48	@ 0x30
 c0556da:	4633      	mov	r3, r6
 c0556dc:	4608      	mov	r0, r1
 c0556de:	aa08      	add	r2, sp, #32
    }
    else
    {
        /* Last block is complete block */
        cmac_xor_block( M_last, last_block, K1, block_size );
 c0556e0:	f7ff ff1c 	bl	c05551c <cmac_xor_block>
    }


    cmac_xor_block( state, M_last, state, block_size );
 c0556e4:	4633      	mov	r3, r6
 c0556e6:	4622      	mov	r2, r4
 c0556e8:	4620      	mov	r0, r4
 c0556ea:	a90c      	add	r1, sp, #48	@ 0x30
 c0556ec:	f7ff ff16 	bl	c05551c <cmac_xor_block>
    if( ( ret = mbedtls_cipher_update( ctx, state, block_size, state,
 c0556f0:	4628      	mov	r0, r5
 c0556f2:	4623      	mov	r3, r4
 c0556f4:	4632      	mov	r2, r6
 c0556f6:	4621      	mov	r1, r4
 c0556f8:	9700      	str	r7, [sp, #0]
 c0556fa:	f7ff fce5 	bl	c0550c8 <mbedtls_cipher_update>
 c0556fe:	4605      	mov	r5, r0
 c055700:	b920      	cbnz	r0, c05570c <mbedtls_cipher_cmac_finish+0xc4>
                                       &olen ) ) != 0 )
    {
        goto exit;
    }

    memcpy( output, state, block_size );
 c055702:	4632      	mov	r2, r6
 c055704:	4621      	mov	r1, r4
 c055706:	4640      	mov	r0, r8
 c055708:	f005 ffa0 	bl	c05b64c <memcpy>

exit:
    /* Wipe the generated keys on the stack, and any other transients to avoid
     * side channel leakage */
    mbedtls_platform_zeroize( K1, sizeof( K1 ) );
 c05570c:	2110      	movs	r1, #16
 c05570e:	eb0d 0001 	add.w	r0, sp, r1
 c055712:	f7e5 fe5d 	bl	c03b3d0 <mbedtls_platform_zeroize>
    mbedtls_platform_zeroize( K2, sizeof( K2 ) );
 c055716:	2110      	movs	r1, #16
 c055718:	a808      	add	r0, sp, #32
 c05571a:	f7e5 fe59 	bl	c03b3d0 <mbedtls_platform_zeroize>

    cmac_ctx->unprocessed_len = 0;
 c05571e:	2300      	movs	r3, #0
    mbedtls_platform_zeroize( cmac_ctx->unprocessed_block,
 c055720:	2110      	movs	r1, #16
 c055722:	4648      	mov	r0, r9
    cmac_ctx->unprocessed_len = 0;
 c055724:	6223      	str	r3, [r4, #32]
    mbedtls_platform_zeroize( cmac_ctx->unprocessed_block,
 c055726:	f7e5 fe53 	bl	c03b3d0 <mbedtls_platform_zeroize>
                              sizeof( cmac_ctx->unprocessed_block ) );

    mbedtls_platform_zeroize( state, MBEDTLS_CIPHER_BLKSIZE_MAX );
 c05572a:	2110      	movs	r1, #16
 c05572c:	4620      	mov	r0, r4
 c05572e:	f7e5 fe4f 	bl	c03b3d0 <mbedtls_platform_zeroize>
    return( ret );
}
 c055732:	4628      	mov	r0, r5
 c055734:	b011      	add	sp, #68	@ 0x44
 c055736:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        else if( j == last_block_len )
 c05573a:	bf0c      	ite	eq
 c05573c:	2201      	moveq	r2, #1
 c05573e:	2200      	movne	r2, #0
 c055740:	01d2      	lsls	r2, r2, #7
 c055742:	e7c4      	b.n	c0556ce <mbedtls_cipher_cmac_finish+0x86>
        cmac_xor_block( M_last, last_block, K1, block_size );
 c055744:	4633      	mov	r3, r6
 c055746:	4649      	mov	r1, r9
 c055748:	aa04      	add	r2, sp, #16
 c05574a:	a80c      	add	r0, sp, #48	@ 0x30
 c05574c:	e7c8      	b.n	c0556e0 <mbedtls_cipher_cmac_finish+0x98>
        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );
 c05574e:	4d01      	ldr	r5, [pc, #4]	@ (c055754 <mbedtls_cipher_cmac_finish+0x10c>)
 c055750:	e7ef      	b.n	c055732 <mbedtls_cipher_cmac_finish+0xea>
 c055752:	bf00      	nop
 c055754:	ffff9f00 	.word	0xffff9f00

0c055758 <mbedtls_ct_memcmp>:
                       size_t n )
{
    size_t i;
    volatile const unsigned char *A = (volatile const unsigned char *) a;
    volatile const unsigned char *B = (volatile const unsigned char *) b;
    volatile unsigned char diff = 0;
 c055758:	2300      	movs	r3, #0
{
 c05575a:	b573      	push	{r0, r1, r4, r5, r6, lr}
    volatile unsigned char diff = 0;
 c05575c:	f88d 3007 	strb.w	r3, [sp, #7]

    for( i = 0; i < n; i++ )
 c055760:	4293      	cmp	r3, r2
 c055762:	d103      	bne.n	c05576c <mbedtls_ct_memcmp+0x14>
         * 'the order of volatile accesses is undefined ..' */
        unsigned char x = A[i], y = B[i];
        diff |= x ^ y;
    }

    return( (int)diff );
 c055764:	f89d 0007 	ldrb.w	r0, [sp, #7]
}
 c055768:	b002      	add	sp, #8
 c05576a:	bd70      	pop	{r4, r5, r6, pc}
        unsigned char x = A[i], y = B[i];
 c05576c:	5cc5      	ldrb	r5, [r0, r3]
 c05576e:	5cce      	ldrb	r6, [r1, r3]
        diff |= x ^ y;
 c055770:	f89d 4007 	ldrb.w	r4, [sp, #7]
 c055774:	4075      	eors	r5, r6
 c055776:	432c      	orrs	r4, r5
 c055778:	f88d 4007 	strb.w	r4, [sp, #7]
    for( i = 0; i < n; i++ )
 c05577c:	3301      	adds	r3, #1
 c05577e:	e7ef      	b.n	c055760 <mbedtls_ct_memcmp+0x8>

0c055780 <mbedtls_ct_size_bool_eq>:

unsigned mbedtls_ct_size_bool_eq( size_t x,
                                  size_t y )
{
    /* diff = 0 if x == y, non-zero otherwise */
    const size_t diff = x ^ y;
 c055780:	4041      	eors	r1, r0
#pragma warning( push )
#pragma warning( disable : 4146 )
#endif

    /* diff_msb's most significant bit is equal to x != y */
    const size_t diff_msb = ( diff | (size_t) -diff );
 c055782:	4248      	negs	r0, r1
 c055784:	4308      	orrs	r0, r1

    /* diff1 = (x != y) ? 1 : 0 */
    const unsigned diff1 = diff_msb >> ( sizeof( diff_msb ) * 8 - 1 );

    return( 1 ^ diff1 );
}
 c055786:	43c0      	mvns	r0, r0
 c055788:	0fc0      	lsrs	r0, r0, #31
 c05578a:	4770      	bx	lr

0c05578c <mbedtls_ct_mpi_uint_lt>:
    cond = ( x ^ y );
    /*
     * If the MSB are the same then the difference x-y will be negative (and
     * have its MSB set to 1 during conversion to unsigned) if and only if x<y.
     */
    ret = ( x - y ) & ~cond;
 c05578c:	1a43      	subs	r3, r0, r1
    cond = ( x ^ y );
 c05578e:	4048      	eors	r0, r1
    /*
     * If the MSB are different, then the operand with the MSB of 1 is the
     * bigger. (That is if y has MSB of 1, then x<y is true and it is false if
     * the MSB of y is 0.)
     */
    ret |= y & cond;
 c055790:	4059      	eors	r1, r3
 c055792:	4008      	ands	r0, r1
 c055794:	4058      	eors	r0, r3


    ret = ret >> ( sizeof( mbedtls_mpi_uint ) * 8 - 1 );

    return (unsigned) ret;
}
 c055796:	0fc0      	lsrs	r0, r0, #31
 c055798:	4770      	bx	lr

0c05579a <mbedtls_ct_mpi_uint_cond_assign>:

void mbedtls_ct_mpi_uint_cond_assign( size_t n,
                                      mbedtls_mpi_uint *dest,
                                      const mbedtls_mpi_uint *src,
                                      unsigned char condition )
{
 c05579a:	b5f0      	push	{r4, r5, r6, r7, lr}

#if defined(_MSC_VER)
#pragma warning( pop )
#endif

    for( i = 0; i < n; i++ )
 c05579c:	2500      	movs	r5, #0
    const mbedtls_mpi_uint mask = -condition;
 c05579e:	425f      	negs	r7, r3
    for( i = 0; i < n; i++ )
 c0557a0:	3904      	subs	r1, #4
        dest[i] = ( src[i] & mask ) | ( dest[i] & ~mask );
 c0557a2:	3b01      	subs	r3, #1
    for( i = 0; i < n; i++ )
 c0557a4:	4285      	cmp	r5, r0
 c0557a6:	d100      	bne.n	c0557aa <mbedtls_ct_mpi_uint_cond_assign+0x10>
}
 c0557a8:	bdf0      	pop	{r4, r5, r6, r7, pc}
        dest[i] = ( src[i] & mask ) | ( dest[i] & ~mask );
 c0557aa:	f852 6025 	ldr.w	r6, [r2, r5, lsl #2]
 c0557ae:	f851 4f04 	ldr.w	r4, [r1, #4]!
 c0557b2:	403e      	ands	r6, r7
 c0557b4:	401c      	ands	r4, r3
 c0557b6:	4334      	orrs	r4, r6
 c0557b8:	600c      	str	r4, [r1, #0]
    for( i = 0; i < n; i++ )
 c0557ba:	3501      	adds	r5, #1
 c0557bc:	e7f2      	b.n	c0557a4 <mbedtls_ct_mpi_uint_cond_assign+0xa>

0c0557be <mbedtls_mpi_safe_cond_assign>:
 * (Leaking information about the respective sizes of X and Y is ok however.)
 */
int mbedtls_mpi_safe_cond_assign( mbedtls_mpi *X,
                                  const mbedtls_mpi *Y,
                                  unsigned char assign )
{
 c0557be:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 c0557c2:	460f      	mov	r7, r1
    MPI_VALIDATE_RET( Y != NULL );

    /* all-bits 1 if assign is 1, all-bits 0 if assign is 0 */
    limb_mask = mbedtls_ct_mpi_uint_mask( assign );;

    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, Y->n ) );
 c0557c4:	6849      	ldr	r1, [r1, #4]
{
 c0557c6:	4606      	mov	r6, r0
 c0557c8:	4691      	mov	r9, r2
    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, Y->n ) );
 c0557ca:	f7fd fdac 	bl	c053326 <mbedtls_mpi_grow>
 c0557ce:	4680      	mov	r8, r0
 c0557d0:	b9d8      	cbnz	r0, c05580a <mbedtls_mpi_safe_cond_assign+0x4c>
    return( - ( ( value | - value ) >> ( sizeof( value ) * 8 - 1 ) ) );
 c0557d2:	f1c9 0500 	rsb	r5, r9, #0
 c0557d6:	ea45 0509 	orr.w	r5, r5, r9
 c0557da:	17ed      	asrs	r5, r5, #31
    X->s = mbedtls_ct_cond_select_sign( assign, Y->s, X->s );

    mbedtls_ct_mpi_uint_cond_assign( Y->n, X->p, Y->p, assign );

    for( i = Y->n; i < X->n; i++ )
        X->p[i] &= ~limb_mask;
 c0557dc:	43ed      	mvns	r5, r5
    unsigned uif0 = if0 + 1;
 c0557de:	6833      	ldr	r3, [r6, #0]
    unsigned uif1 = if1 + 1;
 c0557e0:	683c      	ldr	r4, [r7, #0]
    unsigned uif0 = if0 + 1;
 c0557e2:	3301      	adds	r3, #1
    unsigned uif1 = if1 + 1;
 c0557e4:	3401      	adds	r4, #1
    return( (int) ur - 1 );
 c0557e6:	405c      	eors	r4, r3
 c0557e8:	ea04 0449 	and.w	r4, r4, r9, lsl #1
 c0557ec:	405c      	eors	r4, r3
 c0557ee:	3c01      	subs	r4, #1
    X->s = mbedtls_ct_cond_select_sign( assign, Y->s, X->s );
 c0557f0:	6034      	str	r4, [r6, #0]
    mbedtls_ct_mpi_uint_cond_assign( Y->n, X->p, Y->p, assign );
 c0557f2:	68b4      	ldr	r4, [r6, #8]
 c0557f4:	6878      	ldr	r0, [r7, #4]
 c0557f6:	4621      	mov	r1, r4
 c0557f8:	68ba      	ldr	r2, [r7, #8]
 c0557fa:	464b      	mov	r3, r9
 c0557fc:	f7ff ffcd 	bl	c05579a <mbedtls_ct_mpi_uint_cond_assign>
    for( i = Y->n; i < X->n; i++ )
 c055800:	6872      	ldr	r2, [r6, #4]
 c055802:	eb04 0180 	add.w	r1, r4, r0, lsl #2
 c055806:	4282      	cmp	r2, r0
 c055808:	d802      	bhi.n	c055810 <mbedtls_mpi_safe_cond_assign+0x52>

cleanup:
    return( ret );
}
 c05580a:	4640      	mov	r0, r8
 c05580c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        X->p[i] &= ~limb_mask;
 c055810:	680b      	ldr	r3, [r1, #0]
    for( i = Y->n; i < X->n; i++ )
 c055812:	3001      	adds	r0, #1
        X->p[i] &= ~limb_mask;
 c055814:	402b      	ands	r3, r5
 c055816:	f841 3b04 	str.w	r3, [r1], #4
    for( i = Y->n; i < X->n; i++ )
 c05581a:	e7f4      	b.n	c055806 <mbedtls_mpi_safe_cond_assign+0x48>

0c05581c <mbedtls_mpi_safe_cond_swap>:
    mbedtls_mpi_uint limb_mask;
    mbedtls_mpi_uint tmp;
    MPI_VALIDATE_RET( X != NULL );
    MPI_VALIDATE_RET( Y != NULL );

    if( X == Y )
 c05581c:	4288      	cmp	r0, r1
{
 c05581e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 c055820:	4605      	mov	r5, r0
 c055822:	460c      	mov	r4, r1
 c055824:	4616      	mov	r6, r2
    if( X == Y )
 c055826:	d101      	bne.n	c05582c <mbedtls_mpi_safe_cond_swap+0x10>
        return( 0 );
 c055828:	2000      	movs	r0, #0
        Y->p[i] = ( Y->p[i] & ~limb_mask ) | (     tmp & limb_mask );
    }

cleanup:
    return( ret );
}
 c05582a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, Y->n ) );
 c05582c:	6849      	ldr	r1, [r1, #4]
 c05582e:	f7fd fd7a 	bl	c053326 <mbedtls_mpi_grow>
 c055832:	2800      	cmp	r0, #0
 c055834:	d1f9      	bne.n	c05582a <mbedtls_mpi_safe_cond_swap+0xe>
    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( Y, X->n ) );
 c055836:	4620      	mov	r0, r4
 c055838:	6869      	ldr	r1, [r5, #4]
 c05583a:	f7fd fd74 	bl	c053326 <mbedtls_mpi_grow>
 c05583e:	2800      	cmp	r0, #0
 c055840:	d1f3      	bne.n	c05582a <mbedtls_mpi_safe_cond_swap+0xe>
    unsigned uif0 = if0 + 1;
 c055842:	682b      	ldr	r3, [r5, #0]
    unsigned uif1 = if1 + 1;
 c055844:	6821      	ldr	r1, [r4, #0]
    unsigned uif0 = if0 + 1;
 c055846:	3301      	adds	r3, #1
    unsigned uif1 = if1 + 1;
 c055848:	3101      	adds	r1, #1
    return( (int) ur - 1 );
 c05584a:	4059      	eors	r1, r3
 c05584c:	ea01 0146 	and.w	r1, r1, r6, lsl #1
 c055850:	4059      	eors	r1, r3
 c055852:	3901      	subs	r1, #1
    X->s = mbedtls_ct_cond_select_sign( swap, Y->s, X->s );
 c055854:	6029      	str	r1, [r5, #0]
    unsigned uif0 = if0 + 1;
 c055856:	6821      	ldr	r1, [r4, #0]
    return( - ( ( value | - value ) >> ( sizeof( value ) * 8 - 1 ) ) );
 c055858:	4272      	negs	r2, r6
    unsigned uif0 = if0 + 1;
 c05585a:	3101      	adds	r1, #1
    return( (int) ur - 1 );
 c05585c:	404b      	eors	r3, r1
 c05585e:	ea03 0346 	and.w	r3, r3, r6, lsl #1
 c055862:	404b      	eors	r3, r1
    return( - ( ( value | - value ) >> ( sizeof( value ) * 8 - 1 ) ) );
 c055864:	4332      	orrs	r2, r6
    return( (int) ur - 1 );
 c055866:	3b01      	subs	r3, #1
    for( i = 0; i < X->n; i++ )
 c055868:	686e      	ldr	r6, [r5, #4]
    return( - ( ( value | - value ) >> ( sizeof( value ) * 8 - 1 ) ) );
 c05586a:	17d2      	asrs	r2, r2, #31
    Y->s = mbedtls_ct_cond_select_sign( swap, s, Y->s );
 c05586c:	6023      	str	r3, [r4, #0]
    for( i = 0; i < X->n; i++ )
 c05586e:	4286      	cmp	r6, r0
 c055870:	d0da      	beq.n	c055828 <mbedtls_mpi_safe_cond_swap+0xc>
        X->p[i] = ( X->p[i] & ~limb_mask ) | ( Y->p[i] & limb_mask );
 c055872:	68a7      	ldr	r7, [r4, #8]
        tmp = X->p[i];
 c055874:	f8d5 c008 	ldr.w	ip, [r5, #8]
        X->p[i] = ( X->p[i] & ~limb_mask ) | ( Y->p[i] & limb_mask );
 c055878:	f857 1020 	ldr.w	r1, [r7, r0, lsl #2]
        tmp = X->p[i];
 c05587c:	f85c 3020 	ldr.w	r3, [ip, r0, lsl #2]
        X->p[i] = ( X->p[i] & ~limb_mask ) | ( Y->p[i] & limb_mask );
 c055880:	4059      	eors	r1, r3
 c055882:	4011      	ands	r1, r2
 c055884:	4059      	eors	r1, r3
 c055886:	f84c 1020 	str.w	r1, [ip, r0, lsl #2]
        Y->p[i] = ( Y->p[i] & ~limb_mask ) | (     tmp & limb_mask );
 c05588a:	f857 1020 	ldr.w	r1, [r7, r0, lsl #2]
 c05588e:	404b      	eors	r3, r1
 c055890:	4013      	ands	r3, r2
 c055892:	404b      	eors	r3, r1
 c055894:	f847 3020 	str.w	r3, [r7, r0, lsl #2]
    for( i = 0; i < X->n; i++ )
 c055898:	3001      	adds	r0, #1
 c05589a:	e7e8      	b.n	c05586e <mbedtls_mpi_safe_cond_swap+0x52>

0c05589c <mbedtls_mpi_lt_mpi_ct>:
 * Compare signed values in constant time
 */
int mbedtls_mpi_lt_mpi_ct( const mbedtls_mpi *X,
                           const mbedtls_mpi *Y,
                           unsigned *ret )
{
 c05589c:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c0558a0:	460f      	mov	r7, r1

    MPI_VALIDATE_RET( X != NULL );
    MPI_VALIDATE_RET( Y != NULL );
    MPI_VALIDATE_RET( ret != NULL );

    if( X->n != Y->n )
 c0558a2:	6841      	ldr	r1, [r0, #4]
 c0558a4:	687b      	ldr	r3, [r7, #4]
{
 c0558a6:	4606      	mov	r6, r0
    if( X->n != Y->n )
 c0558a8:	4299      	cmp	r1, r3
 c0558aa:	d138      	bne.n	c05591e <mbedtls_mpi_lt_mpi_ct+0x82>
    /*
     * Set sign_N to 1 if N >= 0, 0 if N < 0.
     * We know that N->s == 1 if N >= 0 and N->s == -1 if N < 0.
     */
    X_is_negative = ( X->s & 2 ) >> 1;
    Y_is_negative = ( Y->s & 2 ) >> 1;
 c0558ac:	683b      	ldr	r3, [r7, #0]
    X_is_negative = ( X->s & 2 ) >> 1;
 c0558ae:	6801      	ldr	r1, [r0, #0]
    Y_is_negative = ( Y->s & 2 ) >> 1;
 c0558b0:	105b      	asrs	r3, r3, #1
 c0558b2:	f3c1 0840 	ubfx	r8, r1, #1, #1
    /*
     * If the signs are different, then the positive operand is the bigger.
     * That is if X is negative (X_is_negative == 1), then X < Y is true and it
     * is false if X is positive (X_is_negative == 0).
     */
    cond = ( X_is_negative ^ Y_is_negative );
 c0558b6:	ea83 0361 	eor.w	r3, r3, r1, asr #1
 c0558ba:	f003 0401 	and.w	r4, r3, #1
    *ret = cond & X_is_negative;
 c0558be:	ea08 0303 	and.w	r3, r8, r3
 c0558c2:	6013      	str	r3, [r2, #0]
     * This is a constant-time function. We might have the result, but we still
     * need to go through the loop. Record if we have the result already.
     */
    done = cond;

    for( i = X->n; i > 0; i-- )
 c0558c4:	f8d0 9004 	ldr.w	r9, [r0, #4]
         *
         * Again even if we can make a decision, we just mark the result and
         * the fact that we are done and continue looping.
         */
        cond = mbedtls_ct_mpi_uint_lt( X->p[i - 1], Y->p[i - 1] );
        *ret |= cond & ( 1 - done ) & ( 1 - X_is_negative );
 c0558c8:	f1c8 0301 	rsb	r3, r8, #1
    for( i = X->n; i > 0; i-- )
 c0558cc:	f1b9 0901 	subs.w	r9, r9, #1
 c0558d0:	d203      	bcs.n	c0558da <mbedtls_mpi_lt_mpi_ct+0x3e>
        done |= cond;
    }

    return( 0 );
 c0558d2:	2000      	movs	r0, #0
}
 c0558d4:	b003      	add	sp, #12
 c0558d6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        cond = mbedtls_ct_mpi_uint_lt( Y->p[i - 1], X->p[i - 1] );
 c0558da:	68b9      	ldr	r1, [r7, #8]
 c0558dc:	9301      	str	r3, [sp, #4]
 c0558de:	f851 b029 	ldr.w	fp, [r1, r9, lsl #2]
 c0558e2:	68b1      	ldr	r1, [r6, #8]
 c0558e4:	4658      	mov	r0, fp
 c0558e6:	f851 a029 	ldr.w	sl, [r1, r9, lsl #2]
        *ret |= cond & ( 1 - done ) & X_is_negative;
 c0558ea:	f1c4 0501 	rsb	r5, r4, #1
        cond = mbedtls_ct_mpi_uint_lt( Y->p[i - 1], X->p[i - 1] );
 c0558ee:	4651      	mov	r1, sl
 c0558f0:	f7ff ff4c 	bl	c05578c <mbedtls_ct_mpi_uint_lt>
        *ret |= cond & ( 1 - done ) & X_is_negative;
 c0558f4:	ea05 0508 	and.w	r5, r5, r8
 c0558f8:	6811      	ldr	r1, [r2, #0]
 c0558fa:	4005      	ands	r5, r0
        done |= cond;
 c0558fc:	4304      	orrs	r4, r0
        *ret |= cond & ( 1 - done ) & X_is_negative;
 c0558fe:	430d      	orrs	r5, r1
        cond = mbedtls_ct_mpi_uint_lt( X->p[i - 1], Y->p[i - 1] );
 c055900:	4650      	mov	r0, sl
 c055902:	4659      	mov	r1, fp
 c055904:	f7ff ff42 	bl	c05578c <mbedtls_ct_mpi_uint_lt>
        *ret |= cond & ( 1 - done ) & ( 1 - X_is_negative );
 c055908:	9b01      	ldr	r3, [sp, #4]
 c05590a:	f1c4 0c01 	rsb	ip, r4, #1
 c05590e:	ea03 0100 	and.w	r1, r3, r0
 c055912:	ea01 010c 	and.w	r1, r1, ip
 c055916:	4329      	orrs	r1, r5
 c055918:	6011      	str	r1, [r2, #0]
        done |= cond;
 c05591a:	4304      	orrs	r4, r0
    for( i = X->n; i > 0; i-- )
 c05591c:	e7d6      	b.n	c0558cc <mbedtls_mpi_lt_mpi_ct+0x30>
        return MBEDTLS_ERR_MPI_BAD_INPUT_DATA;
 c05591e:	f06f 0003 	mvn.w	r0, #3
 c055922:	e7d7      	b.n	c0558d4 <mbedtls_mpi_lt_mpi_ct+0x38>

0c055924 <block_cipher_df>:
    ctx->reseed_interval = interval;
}

static int block_cipher_df( unsigned char *output,
                            const unsigned char *data, size_t data_len )
{
 c055924:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    int ret = 0;

    int i, j;
    size_t buf_len, use_len;

    if( data_len > MBEDTLS_CTR_DRBG_MAX_SEED_INPUT )
 c055928:	f5b2 7fc0 	cmp.w	r2, #384	@ 0x180
{
 c05592c:	4607      	mov	r7, r0
 c05592e:	4688      	mov	r8, r1
 c055930:	4615      	mov	r5, r2
 c055932:	f5ad 7d25 	sub.w	sp, sp, #660	@ 0x294
    if( data_len > MBEDTLS_CTR_DRBG_MAX_SEED_INPUT )
 c055936:	f200 80ab 	bhi.w	c055a90 <block_cipher_df+0x16c>
        return( MBEDTLS_ERR_CTR_DRBG_INPUT_TOO_BIG );

    memset( buf, 0, MBEDTLS_CTR_DRBG_MAX_SEED_INPUT +
 c05593a:	f44f 72d0 	mov.w	r2, #416	@ 0x1a0
 c05593e:	2100      	movs	r1, #0
 c055940:	a83c      	add	r0, sp, #240	@ 0xf0
            MBEDTLS_CTR_DRBG_BLOCKSIZE + 16 );
    mbedtls_aes_init( &aes_ctx );
 c055942:	ae18      	add	r6, sp, #96	@ 0x60
    memset( buf, 0, MBEDTLS_CTR_DRBG_MAX_SEED_INPUT +
 c055944:	f005 fef3 	bl	c05b72e <memset>
    mbedtls_aes_init( &aes_ctx );
 c055948:	4630      	mov	r0, r6
 c05594a:	f7f6 f8f9 	bl	c04bb40 <mbedtls_aes_init>
     * S = Length input string (in 32-bits) || Length of output (in 32-bits) ||
     *     data || 0x80
     *     (Total is padded to a multiple of 16-bytes with zeroes)
     */
    p = buf + MBEDTLS_CTR_DRBG_BLOCKSIZE;
    MBEDTLS_PUT_UINT32_BE( data_len, p, 0);
 c05594e:	ba6b      	rev16	r3, r5
 c055950:	f8ad 3102 	strh.w	r3, [sp, #258]	@ 0x102
    p += 4 + 3;
    *p++ = MBEDTLS_CTR_DRBG_SEEDLEN;
 c055954:	2330      	movs	r3, #48	@ 0x30
    MBEDTLS_PUT_UINT32_BE( data_len, p, 0);
 c055956:	2400      	movs	r4, #0
    *p++ = MBEDTLS_CTR_DRBG_SEEDLEN;
 c055958:	f88d 3107 	strb.w	r3, [sp, #263]	@ 0x107
    memcpy( p, data, data_len );
 c05595c:	ab42      	add	r3, sp, #264	@ 0x108
 c05595e:	462a      	mov	r2, r5
 c055960:	4618      	mov	r0, r3
 c055962:	4641      	mov	r1, r8
    MBEDTLS_PUT_UINT32_BE( data_len, p, 0);
 c055964:	f8ad 4100 	strh.w	r4, [sp, #256]	@ 0x100
    memcpy( p, data, data_len );
 c055968:	f005 fe70 	bl	c05b64c <memcpy>
    p[data_len] = 0x80;
 c05596c:	2280      	movs	r2, #128	@ 0x80
 c05596e:	5542      	strb	r2, [r0, r5]

    buf_len = MBEDTLS_CTR_DRBG_BLOCKSIZE + 8 + data_len + 1;

    for( i = 0; i < MBEDTLS_CTR_DRBG_KEYSIZE; i++ )
 c055970:	aa04      	add	r2, sp, #16
 c055972:	4623      	mov	r3, r4
 c055974:	4691      	mov	r9, r2
        key[i] = i;
 c055976:	f802 3b01 	strb.w	r3, [r2], #1
    for( i = 0; i < MBEDTLS_CTR_DRBG_KEYSIZE; i++ )
 c05597a:	3301      	adds	r3, #1
 c05597c:	2b20      	cmp	r3, #32
 c05597e:	d1fa      	bne.n	c055976 <block_cipher_df+0x52>

    if( ( ret = mbedtls_aes_setkey_enc( &aes_ctx, key,
 c055980:	f44f 7280 	mov.w	r2, #256	@ 0x100
 c055984:	4649      	mov	r1, r9
 c055986:	4630      	mov	r0, r6
 c055988:	f7f6 f8ee 	bl	c04bb68 <mbedtls_aes_setkey_enc>
 c05598c:	4604      	mov	r4, r0
 c05598e:	2800      	cmp	r0, #0
 c055990:	d15f      	bne.n	c055a52 <block_cipher_df+0x12e>
    }

    /*
     * Reduce data to MBEDTLS_CTR_DRBG_SEEDLEN bytes of data
     */
    for( j = 0; j < MBEDTLS_CTR_DRBG_SEEDLEN; j += MBEDTLS_CTR_DRBG_BLOCKSIZE )
 c055992:	4680      	mov	r8, r0
    buf_len = MBEDTLS_CTR_DRBG_BLOCKSIZE + 8 + data_len + 1;
 c055994:	3519      	adds	r5, #25
    {
        p = buf;
        memset( chain, 0, MBEDTLS_CTR_DRBG_BLOCKSIZE );
 c055996:	2210      	movs	r2, #16
 c055998:	2100      	movs	r1, #0
 c05599a:	4668      	mov	r0, sp
 c05599c:	f005 fec7 	bl	c05b72e <memset>
        use_len = buf_len;
 c0559a0:	46aa      	mov	sl, r5
        p = buf;
 c0559a2:	f10d 0bf0 	add.w	fp, sp, #240	@ 0xf0
 c0559a6:	466a      	mov	r2, sp
 c0559a8:	4613      	mov	r3, r2
 c0559aa:	f10b 31ff 	add.w	r1, fp, #4294967295	@ 0xffffffff

        while( use_len > 0 )
        {
            for( i = 0; i < MBEDTLS_CTR_DRBG_BLOCKSIZE; i++ )
 c0559ae:	f10b 040f 	add.w	r4, fp, #15
                chain[i] ^= p[i];
 c0559b2:	7810      	ldrb	r0, [r2, #0]
 c0559b4:	f811 cf01 	ldrb.w	ip, [r1, #1]!
 c0559b8:	ea80 000c 	eor.w	r0, r0, ip
            for( i = 0; i < MBEDTLS_CTR_DRBG_BLOCKSIZE; i++ )
 c0559bc:	42a1      	cmp	r1, r4
                chain[i] ^= p[i];
 c0559be:	f802 0b01 	strb.w	r0, [r2], #1
            for( i = 0; i < MBEDTLS_CTR_DRBG_BLOCKSIZE; i++ )
 c0559c2:	d1f6      	bne.n	c0559b2 <block_cipher_df+0x8e>
            p += MBEDTLS_CTR_DRBG_BLOCKSIZE;
            use_len -= ( use_len >= MBEDTLS_CTR_DRBG_BLOCKSIZE ) ?
 c0559c4:	f1ba 0f10 	cmp.w	sl, #16
                       MBEDTLS_CTR_DRBG_BLOCKSIZE : use_len;

            if( ( ret = mbedtls_aes_crypt_ecb( &aes_ctx, MBEDTLS_AES_ENCRYPT,
 c0559c8:	461a      	mov	r2, r3
 c0559ca:	f04f 0101 	mov.w	r1, #1
 c0559ce:	4630      	mov	r0, r6
            use_len -= ( use_len >= MBEDTLS_CTR_DRBG_BLOCKSIZE ) ?
 c0559d0:	bf94      	ite	ls
 c0559d2:	ebaa 0a0a 	subls.w	sl, sl, sl
 c0559d6:	f1aa 0a10 	subhi.w	sl, sl, #16
            if( ( ret = mbedtls_aes_crypt_ecb( &aes_ctx, MBEDTLS_AES_ENCRYPT,
 c0559da:	f7f6 f98b 	bl	c04bcf4 <mbedtls_aes_crypt_ecb>
            p += MBEDTLS_CTR_DRBG_BLOCKSIZE;
 c0559de:	f10b 0b10 	add.w	fp, fp, #16
            if( ( ret = mbedtls_aes_crypt_ecb( &aes_ctx, MBEDTLS_AES_ENCRYPT,
 c0559e2:	4604      	mov	r4, r0
 c0559e4:	bba8      	cbnz	r0, c055a52 <block_cipher_df+0x12e>
        while( use_len > 0 )
 c0559e6:	466b      	mov	r3, sp
 c0559e8:	f1ba 0f00 	cmp.w	sl, #0
 c0559ec:	d1db      	bne.n	c0559a6 <block_cipher_df+0x82>
            {
                goto exit;
            }
        }

        memcpy( tmp + j, chain, MBEDTLS_CTR_DRBG_BLOCKSIZE );
 c0559ee:	aa0c      	add	r2, sp, #48	@ 0x30
 c0559f0:	eb08 0402 	add.w	r4, r8, r2
 c0559f4:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 c0559f6:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}

        /*
         * Update IV
         */
        buf[3]++;
 c0559fa:	f89d 30f3 	ldrb.w	r3, [sp, #243]	@ 0xf3
    for( j = 0; j < MBEDTLS_CTR_DRBG_SEEDLEN; j += MBEDTLS_CTR_DRBG_BLOCKSIZE )
 c0559fe:	f108 0810 	add.w	r8, r8, #16
        buf[3]++;
 c055a02:	3301      	adds	r3, #1
    for( j = 0; j < MBEDTLS_CTR_DRBG_SEEDLEN; j += MBEDTLS_CTR_DRBG_BLOCKSIZE )
 c055a04:	f1b8 0f30 	cmp.w	r8, #48	@ 0x30
        buf[3]++;
 c055a08:	f88d 30f3 	strb.w	r3, [sp, #243]	@ 0xf3
    for( j = 0; j < MBEDTLS_CTR_DRBG_SEEDLEN; j += MBEDTLS_CTR_DRBG_BLOCKSIZE )
 c055a0c:	d1c3      	bne.n	c055996 <block_cipher_df+0x72>
    }

    /*
     * Do final encryption with reduced data
     */
    if( ( ret = mbedtls_aes_setkey_enc( &aes_ctx, tmp,
 c055a0e:	f44f 7280 	mov.w	r2, #256	@ 0x100
 c055a12:	4630      	mov	r0, r6
 c055a14:	a90c      	add	r1, sp, #48	@ 0x30
 c055a16:	f7f6 f8a7 	bl	c04bb68 <mbedtls_aes_setkey_enc>
 c055a1a:	4604      	mov	r4, r0
 c055a1c:	b9c8      	cbnz	r0, c055a52 <block_cipher_df+0x12e>
                                        MBEDTLS_CTR_DRBG_KEYBITS ) ) != 0 )
    {
        goto exit;
    }
    iv = tmp + MBEDTLS_CTR_DRBG_KEYSIZE;
    p = output;
 c055a1e:	463d      	mov	r5, r7
 c055a20:	f107 0830 	add.w	r8, r7, #48	@ 0x30

    for( j = 0; j < MBEDTLS_CTR_DRBG_SEEDLEN; j += MBEDTLS_CTR_DRBG_BLOCKSIZE )
    {
        if( ( ret = mbedtls_aes_crypt_ecb( &aes_ctx, MBEDTLS_AES_ENCRYPT,
 c055a24:	ab14      	add	r3, sp, #80	@ 0x50
 c055a26:	461a      	mov	r2, r3
 c055a28:	2101      	movs	r1, #1
 c055a2a:	4630      	mov	r0, r6
 c055a2c:	f7f6 f962 	bl	c04bcf4 <mbedtls_aes_crypt_ecb>
 c055a30:	4604      	mov	r4, r0
 c055a32:	b970      	cbnz	r0, c055a52 <block_cipher_df+0x12e>
                                           iv, iv ) ) != 0 )
        {
            goto exit;
        }
        memcpy( p, iv, MBEDTLS_CTR_DRBG_BLOCKSIZE );
 c055a34:	462a      	mov	r2, r5
 c055a36:	f10d 0c50 	add.w	ip, sp, #80	@ 0x50
 c055a3a:	4663      	mov	r3, ip
 c055a3c:	cb03      	ldmia	r3!, {r0, r1}
 c055a3e:	42b3      	cmp	r3, r6
 c055a40:	6010      	str	r0, [r2, #0]
 c055a42:	6051      	str	r1, [r2, #4]
 c055a44:	469c      	mov	ip, r3
 c055a46:	f102 0208 	add.w	r2, r2, #8
 c055a4a:	d1f6      	bne.n	c055a3a <block_cipher_df+0x116>
        p += MBEDTLS_CTR_DRBG_BLOCKSIZE;
 c055a4c:	3510      	adds	r5, #16
    for( j = 0; j < MBEDTLS_CTR_DRBG_SEEDLEN; j += MBEDTLS_CTR_DRBG_BLOCKSIZE )
 c055a4e:	45a8      	cmp	r8, r5
 c055a50:	d1e8      	bne.n	c055a24 <block_cipher_df+0x100>
    }
exit:
    mbedtls_aes_free( &aes_ctx );
 c055a52:	4630      	mov	r0, r6
 c055a54:	f7f6 f87e 	bl	c04bb54 <mbedtls_aes_free>
    /*
    * tidy up the stack
    */
    mbedtls_platform_zeroize( buf, sizeof( buf ) );
 c055a58:	f44f 71d0 	mov.w	r1, #416	@ 0x1a0
 c055a5c:	a83c      	add	r0, sp, #240	@ 0xf0
 c055a5e:	f7e5 fcb7 	bl	c03b3d0 <mbedtls_platform_zeroize>
    mbedtls_platform_zeroize( tmp, sizeof( tmp ) );
 c055a62:	2130      	movs	r1, #48	@ 0x30
 c055a64:	eb0d 0001 	add.w	r0, sp, r1
 c055a68:	f7e5 fcb2 	bl	c03b3d0 <mbedtls_platform_zeroize>
    mbedtls_platform_zeroize( key, sizeof( key ) );
 c055a6c:	2120      	movs	r1, #32
 c055a6e:	4648      	mov	r0, r9
 c055a70:	f7e5 fcae 	bl	c03b3d0 <mbedtls_platform_zeroize>
    mbedtls_platform_zeroize( chain, sizeof( chain ) );
 c055a74:	2110      	movs	r1, #16
 c055a76:	4668      	mov	r0, sp
 c055a78:	f7e5 fcaa 	bl	c03b3d0 <mbedtls_platform_zeroize>
    if( 0 != ret )
 c055a7c:	b11c      	cbz	r4, c055a86 <block_cipher_df+0x162>
    {
        /*
        * wipe partial seed from memory
        */
        mbedtls_platform_zeroize( output, MBEDTLS_CTR_DRBG_SEEDLEN );
 c055a7e:	2130      	movs	r1, #48	@ 0x30
 c055a80:	4638      	mov	r0, r7
 c055a82:	f7e5 fca5 	bl	c03b3d0 <mbedtls_platform_zeroize>
    }

    return( ret );
}
 c055a86:	4620      	mov	r0, r4
 c055a88:	f50d 7d25 	add.w	sp, sp, #660	@ 0x294
 c055a8c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        return( MBEDTLS_ERR_CTR_DRBG_INPUT_TOO_BIG );
 c055a90:	f06f 0437 	mvn.w	r4, #55	@ 0x37
 c055a94:	e7f7      	b.n	c055a86 <block_cipher_df+0x162>

0c055a96 <ctr_drbg_update_internal>:
 *   ctx->aes_ctx = Key
 *   ctx->counter = V
 */
static int ctr_drbg_update_internal( mbedtls_ctr_drbg_context *ctx,
                          const unsigned char data[MBEDTLS_CTR_DRBG_SEEDLEN] )
{
 c055a96:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 c055a9a:	b08d      	sub	sp, #52	@ 0x34
 c055a9c:	4604      	mov	r4, r0
 c055a9e:	460e      	mov	r6, r1
    unsigned char tmp[MBEDTLS_CTR_DRBG_SEEDLEN];
    unsigned char *p = tmp;
    int i, j;
    int ret = 0;

    memset( tmp, 0, MBEDTLS_CTR_DRBG_SEEDLEN );
 c055aa0:	2230      	movs	r2, #48	@ 0x30
 c055aa2:	2100      	movs	r1, #0
 c055aa4:	4668      	mov	r0, sp
 c055aa6:	f005 fe42 	bl	c05b72e <memset>

    for( j = 0; j < MBEDTLS_CTR_DRBG_SEEDLEN; j += MBEDTLS_CTR_DRBG_BLOCKSIZE )
 c055aaa:	2700      	movs	r7, #0
                break;

        /*
         * Crypt counter block
         */
        if( ( ret = mbedtls_aes_crypt_ecb( &ctx->aes_ctx, MBEDTLS_AES_ENCRYPT,
 c055aac:	f104 0920 	add.w	r9, r4, #32
 c055ab0:	46e8      	mov	r8, sp
 c055ab2:	eb0d 0307 	add.w	r3, sp, r7
 c055ab6:	f104 0110 	add.w	r1, r4, #16
        for( i = MBEDTLS_CTR_DRBG_BLOCKSIZE; i > 0; i-- )
 c055aba:	42a1      	cmp	r1, r4
 c055abc:	d006      	beq.n	c055acc <ctr_drbg_update_internal+0x36>
            if( ++ctx->counter[i - 1] != 0 )
 c055abe:	f811 2d01 	ldrb.w	r2, [r1, #-1]!
 c055ac2:	3201      	adds	r2, #1
 c055ac4:	b2d2      	uxtb	r2, r2
 c055ac6:	700a      	strb	r2, [r1, #0]
 c055ac8:	2a00      	cmp	r2, #0
 c055aca:	d0f6      	beq.n	c055aba <ctr_drbg_update_internal+0x24>
        if( ( ret = mbedtls_aes_crypt_ecb( &ctx->aes_ctx, MBEDTLS_AES_ENCRYPT,
 c055acc:	4622      	mov	r2, r4
 c055ace:	2101      	movs	r1, #1
 c055ad0:	4648      	mov	r0, r9
 c055ad2:	f7f6 f90f 	bl	c04bcf4 <mbedtls_aes_crypt_ecb>
 c055ad6:	4605      	mov	r5, r0
 c055ad8:	b138      	cbz	r0, c055aea <ctr_drbg_update_internal+0x54>
    }
    memcpy( ctx->counter, tmp + MBEDTLS_CTR_DRBG_KEYSIZE,
            MBEDTLS_CTR_DRBG_BLOCKSIZE );

exit:
    mbedtls_platform_zeroize( tmp, sizeof( tmp ) );
 c055ada:	4668      	mov	r0, sp
 c055adc:	2130      	movs	r1, #48	@ 0x30
 c055ade:	f7e5 fc77 	bl	c03b3d0 <mbedtls_platform_zeroize>
    return( ret );
}
 c055ae2:	4628      	mov	r0, r5
 c055ae4:	b00d      	add	sp, #52	@ 0x34
 c055ae6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    for( j = 0; j < MBEDTLS_CTR_DRBG_SEEDLEN; j += MBEDTLS_CTR_DRBG_BLOCKSIZE )
 c055aea:	3710      	adds	r7, #16
 c055aec:	2f30      	cmp	r7, #48	@ 0x30
 c055aee:	d1df      	bne.n	c055ab0 <ctr_drbg_update_internal+0x1a>
 c055af0:	1e73      	subs	r3, r6, #1
 c055af2:	362f      	adds	r6, #47	@ 0x2f
        tmp[i] ^= data[i];
 c055af4:	f898 2000 	ldrb.w	r2, [r8]
 c055af8:	f813 1f01 	ldrb.w	r1, [r3, #1]!
 c055afc:	404a      	eors	r2, r1
    for( i = 0; i < MBEDTLS_CTR_DRBG_SEEDLEN; i++ )
 c055afe:	42b3      	cmp	r3, r6
        tmp[i] ^= data[i];
 c055b00:	f808 2b01 	strb.w	r2, [r8], #1
    for( i = 0; i < MBEDTLS_CTR_DRBG_SEEDLEN; i++ )
 c055b04:	d1f6      	bne.n	c055af4 <ctr_drbg_update_internal+0x5e>
    if( ( ret = mbedtls_aes_setkey_enc( &ctx->aes_ctx, tmp,
 c055b06:	f44f 7280 	mov.w	r2, #256	@ 0x100
 c055b0a:	4669      	mov	r1, sp
 c055b0c:	4648      	mov	r0, r9
 c055b0e:	f7f6 f82b 	bl	c04bb68 <mbedtls_aes_setkey_enc>
 c055b12:	4605      	mov	r5, r0
 c055b14:	2800      	cmp	r0, #0
 c055b16:	d1e0      	bne.n	c055ada <ctr_drbg_update_internal+0x44>
    memcpy( ctx->counter, tmp + MBEDTLS_CTR_DRBG_KEYSIZE,
 c055b18:	aa08      	add	r2, sp, #32
 c055b1a:	ae0c      	add	r6, sp, #48	@ 0x30
 c055b1c:	4613      	mov	r3, r2
 c055b1e:	cb03      	ldmia	r3!, {r0, r1}
 c055b20:	42b3      	cmp	r3, r6
 c055b22:	6020      	str	r0, [r4, #0]
 c055b24:	6061      	str	r1, [r4, #4]
 c055b26:	461a      	mov	r2, r3
 c055b28:	f104 0408 	add.w	r4, r4, #8
 c055b2c:	d1f6      	bne.n	c055b1c <ctr_drbg_update_internal+0x86>
 c055b2e:	e7d4      	b.n	c055ada <ctr_drbg_update_internal+0x44>

0c055b30 <mbedtls_ctr_drbg_reseed_internal>:
 */
static int mbedtls_ctr_drbg_reseed_internal( mbedtls_ctr_drbg_context *ctx,
                                             const unsigned char *additional,
                                             size_t len,
                                             size_t nonce_len )
{
 c055b30:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    unsigned char seed[MBEDTLS_CTR_DRBG_MAX_SEED_INPUT];
    size_t seedlen = 0;
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;

    if( ctx->entropy_len > MBEDTLS_CTR_DRBG_MAX_SEED_INPUT )
 c055b34:	6984      	ldr	r4, [r0, #24]
{
 c055b36:	4605      	mov	r5, r0
    if( ctx->entropy_len > MBEDTLS_CTR_DRBG_MAX_SEED_INPUT )
 c055b38:	f5b4 7fc0 	cmp.w	r4, #384	@ 0x180
{
 c055b3c:	4688      	mov	r8, r1
 c055b3e:	4617      	mov	r7, r2
 c055b40:	461e      	mov	r6, r3
 c055b42:	b0e0      	sub	sp, #384	@ 0x180
    if( ctx->entropy_len > MBEDTLS_CTR_DRBG_MAX_SEED_INPUT )
 c055b44:	d849      	bhi.n	c055bda <mbedtls_ctr_drbg_reseed_internal+0xaa>
        return( MBEDTLS_ERR_CTR_DRBG_INPUT_TOO_BIG );
    if( nonce_len > MBEDTLS_CTR_DRBG_MAX_SEED_INPUT - ctx->entropy_len )
 c055b46:	f5c4 73c0 	rsb	r3, r4, #384	@ 0x180
 c055b4a:	42b3      	cmp	r3, r6
 c055b4c:	d345      	bcc.n	c055bda <mbedtls_ctr_drbg_reseed_internal+0xaa>
        return( MBEDTLS_ERR_CTR_DRBG_INPUT_TOO_BIG );
    if( len > MBEDTLS_CTR_DRBG_MAX_SEED_INPUT - ctx->entropy_len - nonce_len )
 c055b4e:	f5c6 73c0 	rsb	r3, r6, #384	@ 0x180
 c055b52:	1b1b      	subs	r3, r3, r4
 c055b54:	4293      	cmp	r3, r2
 c055b56:	d340      	bcc.n	c055bda <mbedtls_ctr_drbg_reseed_internal+0xaa>
        return( MBEDTLS_ERR_CTR_DRBG_INPUT_TOO_BIG );

    memset( seed, 0, MBEDTLS_CTR_DRBG_MAX_SEED_INPUT );
 c055b58:	f44f 72c0 	mov.w	r2, #384	@ 0x180
 c055b5c:	2100      	movs	r1, #0
 c055b5e:	4668      	mov	r0, sp
 c055b60:	f005 fde5 	bl	c05b72e <memset>

    /* Gather entropy_len bytes of entropy to seed state. */
    if( 0 != ctx->f_entropy( ctx->p_entropy, seed, ctx->entropy_len ) )
 c055b64:	4622      	mov	r2, r4
 c055b66:	4669      	mov	r1, sp
 c055b68:	f8d5 30b0 	ldr.w	r3, [r5, #176]	@ 0xb0
 c055b6c:	f8d5 00b4 	ldr.w	r0, [r5, #180]	@ 0xb4
 c055b70:	4798      	blx	r3
 c055b72:	b128      	cbz	r0, c055b80 <mbedtls_ctr_drbg_reseed_internal+0x50>
    {
        return( MBEDTLS_ERR_CTR_DRBG_ENTROPY_SOURCE_FAILED );
 c055b74:	f06f 0433 	mvn.w	r4, #51	@ 0x33
    ctx->reseed_counter = 1;

exit:
    mbedtls_platform_zeroize( seed, sizeof( seed ) );
    return( ret );
}
 c055b78:	4620      	mov	r0, r4
 c055b7a:	b060      	add	sp, #384	@ 0x180
 c055b7c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    seedlen += ctx->entropy_len;
 c055b80:	69ac      	ldr	r4, [r5, #24]
    if( nonce_len != 0 )
 c055b82:	b156      	cbz	r6, c055b9a <mbedtls_ctr_drbg_reseed_internal+0x6a>
        if( 0 != ctx->f_entropy( ctx->p_entropy, seed + seedlen, nonce_len ) )
 c055b84:	4632      	mov	r2, r6
 c055b86:	f8d5 30b0 	ldr.w	r3, [r5, #176]	@ 0xb0
 c055b8a:	f8d5 00b4 	ldr.w	r0, [r5, #180]	@ 0xb4
 c055b8e:	eb0d 0104 	add.w	r1, sp, r4
 c055b92:	4798      	blx	r3
 c055b94:	2800      	cmp	r0, #0
 c055b96:	d1ed      	bne.n	c055b74 <mbedtls_ctr_drbg_reseed_internal+0x44>
        seedlen += nonce_len;
 c055b98:	4434      	add	r4, r6
    if( additional != NULL && len != 0 )
 c055b9a:	f1b8 0f00 	cmp.w	r8, #0
 c055b9e:	d007      	beq.n	c055bb0 <mbedtls_ctr_drbg_reseed_internal+0x80>
 c055ba0:	b137      	cbz	r7, c055bb0 <mbedtls_ctr_drbg_reseed_internal+0x80>
        memcpy( seed + seedlen, additional, len );
 c055ba2:	eb0d 0004 	add.w	r0, sp, r4
 c055ba6:	463a      	mov	r2, r7
 c055ba8:	4641      	mov	r1, r8
 c055baa:	f005 fd4f 	bl	c05b64c <memcpy>
        seedlen += len;
 c055bae:	443c      	add	r4, r7
    if( ( ret = block_cipher_df( seed, seed, seedlen ) ) != 0 )
 c055bb0:	4622      	mov	r2, r4
 c055bb2:	4669      	mov	r1, sp
 c055bb4:	4668      	mov	r0, sp
 c055bb6:	f7ff feb5 	bl	c055924 <block_cipher_df>
 c055bba:	4604      	mov	r4, r0
 c055bbc:	b938      	cbnz	r0, c055bce <mbedtls_ctr_drbg_reseed_internal+0x9e>
    if( ( ret = ctr_drbg_update_internal( ctx, seed ) ) != 0 )
 c055bbe:	4669      	mov	r1, sp
 c055bc0:	4628      	mov	r0, r5
 c055bc2:	f7ff ff68 	bl	c055a96 <ctr_drbg_update_internal>
 c055bc6:	4604      	mov	r4, r0
 c055bc8:	b908      	cbnz	r0, c055bce <mbedtls_ctr_drbg_reseed_internal+0x9e>
    ctx->reseed_counter = 1;
 c055bca:	2301      	movs	r3, #1
 c055bcc:	612b      	str	r3, [r5, #16]
    mbedtls_platform_zeroize( seed, sizeof( seed ) );
 c055bce:	f44f 71c0 	mov.w	r1, #384	@ 0x180
 c055bd2:	4668      	mov	r0, sp
 c055bd4:	f7e5 fbfc 	bl	c03b3d0 <mbedtls_platform_zeroize>
    return( ret );
 c055bd8:	e7ce      	b.n	c055b78 <mbedtls_ctr_drbg_reseed_internal+0x48>
        return( MBEDTLS_ERR_CTR_DRBG_INPUT_TOO_BIG );
 c055bda:	f06f 0437 	mvn.w	r4, #55	@ 0x37
 c055bde:	e7cb      	b.n	c055b78 <mbedtls_ctr_drbg_reseed_internal+0x48>

0c055be0 <mbedtls_ctr_drbg_init>:
{
 c055be0:	b510      	push	{r4, lr}
    memset( ctx, 0, sizeof( mbedtls_ctr_drbg_context ) );
 c055be2:	22b8      	movs	r2, #184	@ 0xb8
 c055be4:	2100      	movs	r1, #0
{
 c055be6:	4604      	mov	r4, r0
    memset( ctx, 0, sizeof( mbedtls_ctr_drbg_context ) );
 c055be8:	f005 fda1 	bl	c05b72e <memset>
    ctx->reseed_counter = -1;
 c055bec:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 c055bf0:	6123      	str	r3, [r4, #16]
    ctx->reseed_interval = MBEDTLS_CTR_DRBG_RESEED_INTERVAL;
 c055bf2:	f242 7310 	movw	r3, #10000	@ 0x2710
 c055bf6:	61e3      	str	r3, [r4, #28]
}
 c055bf8:	bd10      	pop	{r4, pc}

0c055bfa <mbedtls_ctr_drbg_free>:
{
 c055bfa:	b510      	push	{r4, lr}
    if( ctx == NULL )
 c055bfc:	4604      	mov	r4, r0
 c055bfe:	b160      	cbz	r0, c055c1a <mbedtls_ctr_drbg_free+0x20>
    mbedtls_aes_free( &ctx->aes_ctx );
 c055c00:	3020      	adds	r0, #32
 c055c02:	f7f5 ffa7 	bl	c04bb54 <mbedtls_aes_free>
    mbedtls_platform_zeroize( ctx, sizeof( mbedtls_ctr_drbg_context ) );
 c055c06:	21b8      	movs	r1, #184	@ 0xb8
 c055c08:	4620      	mov	r0, r4
 c055c0a:	f7e5 fbe1 	bl	c03b3d0 <mbedtls_platform_zeroize>
    ctx->reseed_interval = MBEDTLS_CTR_DRBG_RESEED_INTERVAL;
 c055c0e:	f242 7310 	movw	r3, #10000	@ 0x2710
 c055c12:	61e3      	str	r3, [r4, #28]
    ctx->reseed_counter = -1;
 c055c14:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 c055c18:	6123      	str	r3, [r4, #16]
}
 c055c1a:	bd10      	pop	{r4, pc}

0c055c1c <mbedtls_ctr_drbg_reseed>:

int mbedtls_ctr_drbg_reseed( mbedtls_ctr_drbg_context *ctx,
                             const unsigned char *additional, size_t len )
{
    return( mbedtls_ctr_drbg_reseed_internal( ctx, additional, len, 0 ) );
 c055c1c:	2300      	movs	r3, #0
 c055c1e:	f7ff bf87 	b.w	c055b30 <mbedtls_ctr_drbg_reseed_internal>

0c055c22 <mbedtls_ctr_drbg_seed>:
int mbedtls_ctr_drbg_seed( mbedtls_ctr_drbg_context *ctx,
                           int (*f_entropy)(void *, unsigned char *, size_t),
                           void *p_entropy,
                           const unsigned char *custom,
                           size_t len )
{
 c055c22:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 c055c26:	4605      	mov	r5, r0
 c055c28:	460f      	mov	r7, r1
 c055c2a:	4614      	mov	r4, r2
 c055c2c:	b088      	sub	sp, #32
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    unsigned char key[MBEDTLS_CTR_DRBG_KEYSIZE];
    size_t nonce_len;

    memset( key, 0, MBEDTLS_CTR_DRBG_KEYSIZE );
 c055c2e:	2220      	movs	r2, #32
 c055c30:	2100      	movs	r1, #0
 c055c32:	4668      	mov	r0, sp
    /* The mutex is initialized iff f_entropy is set. */
#if defined(MBEDTLS_THREADING_C)
    mbedtls_mutex_init( &ctx->mutex );
#endif

    mbedtls_aes_init( &ctx->aes_ctx );
 c055c34:	f105 0820 	add.w	r8, r5, #32
{
 c055c38:	461e      	mov	r6, r3
    memset( key, 0, MBEDTLS_CTR_DRBG_KEYSIZE );
 c055c3a:	f005 fd78 	bl	c05b72e <memset>
    mbedtls_aes_init( &ctx->aes_ctx );
 c055c3e:	4640      	mov	r0, r8
 c055c40:	f7f5 ff7e 	bl	c04bb40 <mbedtls_aes_init>

    ctx->f_entropy = f_entropy;
    ctx->p_entropy = p_entropy;

    if( ctx->entropy_len == 0 )
 c055c44:	69ab      	ldr	r3, [r5, #24]
    ctx->p_entropy = p_entropy;
 c055c46:	e9c5 742c 	strd	r7, r4, [r5, #176]	@ 0xb0
    if( ctx->entropy_len == 0 )
 c055c4a:	b90b      	cbnz	r3, c055c50 <mbedtls_ctr_drbg_seed+0x2e>
        ctx->entropy_len = MBEDTLS_CTR_DRBG_ENTROPY_LEN;
 c055c4c:	2330      	movs	r3, #48	@ 0x30
 c055c4e:	61ab      	str	r3, [r5, #24]
    /* ctx->reseed_counter contains the desired amount of entropy to
     * grab for a nonce (see mbedtls_ctr_drbg_set_nonce_len()).
     * If it's -1, indicating that the entropy nonce length was not set
     * explicitly, use a sufficiently large nonce for security. */
    nonce_len = ( ctx->reseed_counter >= 0 ?
 c055c50:	692c      	ldr	r4, [r5, #16]
                  (size_t) ctx->reseed_counter :
 c055c52:	2c00      	cmp	r4, #0
 c055c54:	da05      	bge.n	c055c62 <mbedtls_ctr_drbg_seed+0x40>
                  good_nonce_len( ctx->entropy_len ) );
 c055c56:	69ac      	ldr	r4, [r5, #24]
    if( entropy_len >= MBEDTLS_CTR_DRBG_KEYSIZE * 3 / 2 )
 c055c58:	2c2f      	cmp	r4, #47	@ 0x2f
        return( 0 );
 c055c5a:	bf8e      	itee	hi
 c055c5c:	2400      	movhi	r4, #0
        return( ( entropy_len + 1 ) / 2 );
 c055c5e:	3401      	addls	r4, #1
 c055c60:	0864      	lsrls	r4, r4, #1

    /* Initialize with an empty key. */
    if( ( ret = mbedtls_aes_setkey_enc( &ctx->aes_ctx, key,
 c055c62:	f44f 7280 	mov.w	r2, #256	@ 0x100
 c055c66:	4669      	mov	r1, sp
 c055c68:	4640      	mov	r0, r8
 c055c6a:	f7f5 ff7d 	bl	c04bb68 <mbedtls_aes_setkey_enc>
 c055c6e:	b928      	cbnz	r0, c055c7c <mbedtls_ctr_drbg_seed+0x5a>
    {
        return( ret );
    }

    /* Do the initial seeding. */
    if( ( ret = mbedtls_ctr_drbg_reseed_internal( ctx, custom, len,
 c055c70:	4623      	mov	r3, r4
 c055c72:	4631      	mov	r1, r6
 c055c74:	4628      	mov	r0, r5
 c055c76:	9a0e      	ldr	r2, [sp, #56]	@ 0x38
 c055c78:	f7ff ff5a 	bl	c055b30 <mbedtls_ctr_drbg_reseed_internal>
                                                  nonce_len ) ) != 0 )
    {
        return( ret );
    }
    return( 0 );
}
 c055c7c:	b008      	add	sp, #32
 c055c7e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0c055c82 <mbedtls_ctr_drbg_random_with_add>:
 *   ctx contains new_working_state
 */
int mbedtls_ctr_drbg_random_with_add( void *p_rng,
                              unsigned char *output, size_t output_len,
                              const unsigned char *additional, size_t add_len )
{
 c055c82:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    unsigned char *p = output;
    unsigned char tmp[MBEDTLS_CTR_DRBG_BLOCKSIZE];
    int i;
    size_t use_len;

    if( output_len > MBEDTLS_CTR_DRBG_MAX_REQUEST )
 c055c86:	f5b2 6f80 	cmp.w	r2, #1024	@ 0x400
{
 c055c8a:	b090      	sub	sp, #64	@ 0x40
 c055c8c:	4605      	mov	r5, r0
 c055c8e:	460f      	mov	r7, r1
 c055c90:	4616      	mov	r6, r2
 c055c92:	461c      	mov	r4, r3
 c055c94:	f8dd 8058 	ldr.w	r8, [sp, #88]	@ 0x58
    if( output_len > MBEDTLS_CTR_DRBG_MAX_REQUEST )
 c055c98:	d85e      	bhi.n	c055d58 <mbedtls_ctr_drbg_random_with_add+0xd6>
        return( MBEDTLS_ERR_CTR_DRBG_REQUEST_TOO_BIG );

    if( add_len > MBEDTLS_CTR_DRBG_MAX_INPUT )
 c055c9a:	f5b8 7f80 	cmp.w	r8, #256	@ 0x100
 c055c9e:	d85e      	bhi.n	c055d5e <mbedtls_ctr_drbg_random_with_add+0xdc>
        return( MBEDTLS_ERR_CTR_DRBG_INPUT_TOO_BIG );

    memset( add_input, 0, MBEDTLS_CTR_DRBG_SEEDLEN );
 c055ca0:	2230      	movs	r2, #48	@ 0x30
 c055ca2:	2100      	movs	r1, #0
 c055ca4:	a804      	add	r0, sp, #16
 c055ca6:	f005 fd42 	bl	c05b72e <memset>

    if( ctx->reseed_counter > ctx->reseed_interval ||
 c055caa:	692a      	ldr	r2, [r5, #16]
 c055cac:	69eb      	ldr	r3, [r5, #28]
 c055cae:	429a      	cmp	r2, r3
 c055cb0:	dc01      	bgt.n	c055cb6 <mbedtls_ctr_drbg_random_with_add+0x34>
 c055cb2:	696b      	ldr	r3, [r5, #20]
 c055cb4:	b19b      	cbz	r3, c055cde <mbedtls_ctr_drbg_random_with_add+0x5c>
        ctx->prediction_resistance )
    {
        if( ( ret = mbedtls_ctr_drbg_reseed( ctx, additional, add_len ) ) != 0 )
 c055cb6:	4621      	mov	r1, r4
 c055cb8:	4642      	mov	r2, r8
 c055cba:	4628      	mov	r0, r5
 c055cbc:	f7ff ffae 	bl	c055c1c <mbedtls_ctr_drbg_reseed>
 c055cc0:	4604      	mov	r4, r0
 c055cc2:	bb28      	cbnz	r0, c055d10 <mbedtls_ctr_drbg_random_with_add+0x8e>
                break;

        /*
         * Crypt counter block
         */
        if( ( ret = mbedtls_aes_crypt_ecb( &ctx->aes_ctx, MBEDTLS_AES_ENCRYPT,
 c055cc4:	f105 0820 	add.w	r8, r5, #32
    while( output_len > 0 )
 c055cc8:	bb36      	cbnz	r6, c055d18 <mbedtls_ctr_drbg_random_with_add+0x96>
        memcpy( p, tmp, use_len );
        p += use_len;
        output_len -= use_len;
    }

    if( ( ret = ctr_drbg_update_internal( ctx, add_input ) ) != 0 )
 c055cca:	4628      	mov	r0, r5
 c055ccc:	a904      	add	r1, sp, #16
 c055cce:	f7ff fee2 	bl	c055a96 <ctr_drbg_update_internal>
 c055cd2:	4604      	mov	r4, r0
 c055cd4:	b9a0      	cbnz	r0, c055d00 <mbedtls_ctr_drbg_random_with_add+0x7e>
        goto exit;

    ctx->reseed_counter++;
 c055cd6:	692b      	ldr	r3, [r5, #16]
 c055cd8:	3301      	adds	r3, #1
 c055cda:	612b      	str	r3, [r5, #16]
 c055cdc:	e010      	b.n	c055d00 <mbedtls_ctr_drbg_random_with_add+0x7e>
    if( add_len > 0 )
 c055cde:	f1b8 0f00 	cmp.w	r8, #0
 c055ce2:	d0ef      	beq.n	c055cc4 <mbedtls_ctr_drbg_random_with_add+0x42>
        if( ( ret = block_cipher_df( add_input, additional, add_len ) ) != 0 )
 c055ce4:	4621      	mov	r1, r4
 c055ce6:	4642      	mov	r2, r8
 c055ce8:	a804      	add	r0, sp, #16
 c055cea:	f7ff fe1b 	bl	c055924 <block_cipher_df>
 c055cee:	4604      	mov	r4, r0
 c055cf0:	b930      	cbnz	r0, c055d00 <mbedtls_ctr_drbg_random_with_add+0x7e>
        if( ( ret = ctr_drbg_update_internal( ctx, add_input ) ) != 0 )
 c055cf2:	4628      	mov	r0, r5
 c055cf4:	a904      	add	r1, sp, #16
 c055cf6:	f7ff fece 	bl	c055a96 <ctr_drbg_update_internal>
 c055cfa:	4604      	mov	r4, r0
 c055cfc:	2800      	cmp	r0, #0
 c055cfe:	d0e1      	beq.n	c055cc4 <mbedtls_ctr_drbg_random_with_add+0x42>

exit:
    mbedtls_platform_zeroize( add_input, sizeof( add_input ) );
 c055d00:	2130      	movs	r1, #48	@ 0x30
 c055d02:	a804      	add	r0, sp, #16
 c055d04:	f7e5 fb64 	bl	c03b3d0 <mbedtls_platform_zeroize>
    mbedtls_platform_zeroize( tmp, sizeof( tmp ) );
 c055d08:	2110      	movs	r1, #16
 c055d0a:	4668      	mov	r0, sp
 c055d0c:	f7e5 fb60 	bl	c03b3d0 <mbedtls_platform_zeroize>
    return( ret );
}
 c055d10:	4620      	mov	r0, r4
 c055d12:	b010      	add	sp, #64	@ 0x40
 c055d14:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 c055d18:	f105 0210 	add.w	r2, r5, #16
        for( i = MBEDTLS_CTR_DRBG_BLOCKSIZE; i > 0; i-- )
 c055d1c:	42aa      	cmp	r2, r5
 c055d1e:	d006      	beq.n	c055d2e <mbedtls_ctr_drbg_random_with_add+0xac>
            if( ++ctx->counter[i - 1] != 0 )
 c055d20:	f812 3d01 	ldrb.w	r3, [r2, #-1]!
 c055d24:	3301      	adds	r3, #1
 c055d26:	b2db      	uxtb	r3, r3
 c055d28:	7013      	strb	r3, [r2, #0]
 c055d2a:	2b00      	cmp	r3, #0
 c055d2c:	d0f6      	beq.n	c055d1c <mbedtls_ctr_drbg_random_with_add+0x9a>
        if( ( ret = mbedtls_aes_crypt_ecb( &ctx->aes_ctx, MBEDTLS_AES_ENCRYPT,
 c055d2e:	466b      	mov	r3, sp
 c055d30:	462a      	mov	r2, r5
 c055d32:	2101      	movs	r1, #1
 c055d34:	4640      	mov	r0, r8
 c055d36:	f7f5 ffdd 	bl	c04bcf4 <mbedtls_aes_crypt_ecb>
 c055d3a:	4604      	mov	r4, r0
 c055d3c:	2800      	cmp	r0, #0
 c055d3e:	d1df      	bne.n	c055d00 <mbedtls_ctr_drbg_random_with_add+0x7e>
        use_len = ( output_len > MBEDTLS_CTR_DRBG_BLOCKSIZE )
 c055d40:	2e10      	cmp	r6, #16
 c055d42:	4634      	mov	r4, r6
 c055d44:	bf28      	it	cs
 c055d46:	2410      	movcs	r4, #16
        memcpy( p, tmp, use_len );
 c055d48:	4638      	mov	r0, r7
 c055d4a:	4622      	mov	r2, r4
 c055d4c:	4669      	mov	r1, sp
 c055d4e:	f005 fc7d 	bl	c05b64c <memcpy>
        p += use_len;
 c055d52:	4427      	add	r7, r4
        output_len -= use_len;
 c055d54:	1b36      	subs	r6, r6, r4
 c055d56:	e7b7      	b.n	c055cc8 <mbedtls_ctr_drbg_random_with_add+0x46>
        return( MBEDTLS_ERR_CTR_DRBG_REQUEST_TOO_BIG );
 c055d58:	f06f 0435 	mvn.w	r4, #53	@ 0x35
 c055d5c:	e7d8      	b.n	c055d10 <mbedtls_ctr_drbg_random_with_add+0x8e>
        return( MBEDTLS_ERR_CTR_DRBG_INPUT_TOO_BIG );
 c055d5e:	f06f 0437 	mvn.w	r4, #55	@ 0x37
 c055d62:	e7d5      	b.n	c055d10 <mbedtls_ctr_drbg_random_with_add+0x8e>

0c055d64 <mbedtls_ctr_drbg_random>:
#if defined(MBEDTLS_THREADING_C)
    if( ( ret = mbedtls_mutex_lock( &ctx->mutex ) ) != 0 )
        return( ret );
#endif

    ret = mbedtls_ctr_drbg_random_with_add( ctx, output, output_len, NULL, 0 );
 c055d64:	2300      	movs	r3, #0
{
 c055d66:	b507      	push	{r0, r1, r2, lr}
    ret = mbedtls_ctr_drbg_random_with_add( ctx, output, output_len, NULL, 0 );
 c055d68:	9300      	str	r3, [sp, #0]
 c055d6a:	f7ff ff8a 	bl	c055c82 <mbedtls_ctr_drbg_random_with_add>
    if( mbedtls_mutex_unlock( &ctx->mutex ) != 0 )
        return( MBEDTLS_ERR_THREADING_MUTEX_ERROR );
#endif

    return( ret );
}
 c055d6e:	b003      	add	sp, #12
 c055d70:	f85d fb04 	ldr.w	pc, [sp], #4

0c055d74 <mbedtls_ecdh_compute_shared>:
 */
int mbedtls_ecdh_compute_shared( mbedtls_ecp_group *grp, mbedtls_mpi *z,
                         const mbedtls_ecp_point *Q, const mbedtls_mpi *d,
                         int (*f_rng)(void *, unsigned char *, size_t),
                         void *p_rng )
{
 c055d74:	b5f0      	push	{r4, r5, r6, r7, lr}
 c055d76:	b08f      	sub	sp, #60	@ 0x3c
 c055d78:	4604      	mov	r4, r0
    mbedtls_ecp_point_init( &P );
 c055d7a:	a805      	add	r0, sp, #20
{
 c055d7c:	4617      	mov	r7, r2
 c055d7e:	461e      	mov	r6, r3
 c055d80:	460d      	mov	r5, r1
    mbedtls_ecp_point_init( &P );
 c055d82:	f7f6 fd32 	bl	c04c7ea <mbedtls_ecp_point_init>
    MBEDTLS_MPI_CHK( mbedtls_ecp_mul_restartable( grp, &P, d, Q,
 c055d86:	2300      	movs	r3, #0
 c055d88:	9302      	str	r3, [sp, #8]
 c055d8a:	9b15      	ldr	r3, [sp, #84]	@ 0x54
 c055d8c:	4620      	mov	r0, r4
 c055d8e:	9301      	str	r3, [sp, #4]
 c055d90:	9b14      	ldr	r3, [sp, #80]	@ 0x50
 c055d92:	4632      	mov	r2, r6
 c055d94:	9300      	str	r3, [sp, #0]
 c055d96:	a905      	add	r1, sp, #20
 c055d98:	463b      	mov	r3, r7
 c055d9a:	f7f6 fffd 	bl	c04cd98 <mbedtls_ecp_mul_restartable>
 c055d9e:	4604      	mov	r4, r0
 c055da0:	b940      	cbnz	r0, c055db4 <mbedtls_ecdh_compute_shared+0x40>
    if( mbedtls_ecp_is_zero( &P ) )
 c055da2:	a805      	add	r0, sp, #20
 c055da4:	f7f6 fe18 	bl	c04c9d8 <mbedtls_ecp_is_zero>
 c055da8:	b950      	cbnz	r0, c055dc0 <mbedtls_ecdh_compute_shared+0x4c>
    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( z, &P.X ) );
 c055daa:	4628      	mov	r0, r5
 c055dac:	a905      	add	r1, sp, #20
 c055dae:	f7fd fafc 	bl	c0533aa <mbedtls_mpi_copy>
 c055db2:	4604      	mov	r4, r0
    mbedtls_ecp_point_free( &P );
 c055db4:	a805      	add	r0, sp, #20
 c055db6:	f7f6 fd5e 	bl	c04c876 <mbedtls_ecp_point_free>
    ECDH_VALIDATE_RET( Q != NULL );
    ECDH_VALIDATE_RET( d != NULL );
    ECDH_VALIDATE_RET( z != NULL );
    return( ecdh_compute_shared_restartable( grp, z, Q, d,
                                             f_rng, p_rng, NULL ) );
}
 c055dba:	4620      	mov	r0, r4
 c055dbc:	b00f      	add	sp, #60	@ 0x3c
 c055dbe:	bdf0      	pop	{r4, r5, r6, r7, pc}
        ret = MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
 c055dc0:	4c00      	ldr	r4, [pc, #0]	@ (c055dc4 <mbedtls_ecdh_compute_shared+0x50>)
 c055dc2:	e7f7      	b.n	c055db4 <mbedtls_ecdh_compute_shared+0x40>
 c055dc4:	ffffb080 	.word	0xffffb080

0c055dc8 <mbedtls_ecdh_init>:
    ecdh_init_internal( ctx );
    mbedtls_ecp_point_init( &ctx->Vi  );
    mbedtls_ecp_point_init( &ctx->Vf  );
    mbedtls_mpi_init( &ctx->_d );
#else
    memset( ctx, 0, sizeof( mbedtls_ecdh_context ) );
 c055dc8:	f44f 7282 	mov.w	r2, #260	@ 0x104
 c055dcc:	2100      	movs	r1, #0
 c055dce:	f005 bcae 	b.w	c05b72e <memset>
	...

0c055dd4 <mbedtls_ecdh_setup>:
            ctx->var = MBEDTLS_ECDH_VARIANT_EVEREST;
            ctx->grp_id = grp_id;
            return( mbedtls_everest_setup( &ctx->ctx.everest_ecdh, grp_id ) );
#endif
        default:
            ctx->point_format = MBEDTLS_ECP_PF_UNCOMPRESSED;
 c055dd4:	2300      	movs	r3, #0
{
 c055dd6:	b570      	push	{r4, r5, r6, lr}
            ctx->point_format = MBEDTLS_ECP_PF_UNCOMPRESSED;
 c055dd8:	7003      	strb	r3, [r0, #0]
            ctx->var = MBEDTLS_ECDH_VARIANT_MBEDTLS_2_0;
 c055dda:	2301      	movs	r3, #1
{
 c055ddc:	4604      	mov	r4, r0
 c055dde:	460d      	mov	r5, r1
    mbedtls_ecp_group_init( &ctx->grp );
 c055de0:	1d06      	adds	r6, r0, #4
            ctx->var = MBEDTLS_ECDH_VARIANT_MBEDTLS_2_0;
 c055de2:	7083      	strb	r3, [r0, #2]
            ctx->grp_id = grp_id;
 c055de4:	7041      	strb	r1, [r0, #1]
    mbedtls_ecp_group_init( &ctx->grp );
 c055de6:	4630      	mov	r0, r6
 c055de8:	f7f6 fd0d 	bl	c04c806 <mbedtls_ecp_group_init>
    mbedtls_mpi_init( &ctx->d  );
 c055dec:	f104 00a4 	add.w	r0, r4, #164	@ 0xa4
 c055df0:	f7fd fa81 	bl	c0532f6 <mbedtls_mpi_init>
    mbedtls_ecp_point_init( &ctx->Q   );
 c055df4:	f104 00b0 	add.w	r0, r4, #176	@ 0xb0
 c055df8:	f7f6 fcf7 	bl	c04c7ea <mbedtls_ecp_point_init>
    mbedtls_ecp_point_init( &ctx->Qp  );
 c055dfc:	f104 00d4 	add.w	r0, r4, #212	@ 0xd4
 c055e00:	f7f6 fcf3 	bl	c04c7ea <mbedtls_ecp_point_init>
    mbedtls_mpi_init( &ctx->z  );
 c055e04:	f104 00f8 	add.w	r0, r4, #248	@ 0xf8
 c055e08:	f7fd fa75 	bl	c0532f6 <mbedtls_mpi_init>
    ret = mbedtls_ecp_group_load( &ctx->grp, grp_id );
 c055e0c:	4629      	mov	r1, r5
 c055e0e:	4630      	mov	r0, r6
 c055e10:	f7f7 fdee 	bl	c04d9f0 <mbedtls_ecp_group_load>
            ecdh_init_internal( &ctx->ctx.mbed_ecdh );
            return( ecdh_setup_internal( &ctx->ctx.mbed_ecdh, grp_id ) );
    }
#endif
}
 c055e14:	4b02      	ldr	r3, [pc, #8]	@ (c055e20 <mbedtls_ecdh_setup+0x4c>)
        return( MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE );
 c055e16:	2800      	cmp	r0, #0
}
 c055e18:	bf18      	it	ne
 c055e1a:	4618      	movne	r0, r3
 c055e1c:	bd70      	pop	{r4, r5, r6, pc}
 c055e1e:	bf00      	nop
 c055e20:	ffffb180 	.word	0xffffb180

0c055e24 <mbedtls_ecdh_free>:

/*
 * Free context
 */
void mbedtls_ecdh_free( mbedtls_ecdh_context *ctx )
{
 c055e24:	b510      	push	{r4, lr}
    if( ctx == NULL )
 c055e26:	4604      	mov	r4, r0
 c055e28:	b1c0      	cbz	r0, c055e5c <mbedtls_ecdh_free+0x38>
    mbedtls_ecp_point_free( &ctx->Vi );
    mbedtls_ecp_point_free( &ctx->Vf );
    mbedtls_mpi_free( &ctx->_d );
    ecdh_free_internal( ctx );
#else
    switch( ctx->var )
 c055e2a:	7883      	ldrb	r3, [r0, #2]
 c055e2c:	2b01      	cmp	r3, #1
 c055e2e:	d112      	bne.n	c055e56 <mbedtls_ecdh_free+0x32>
    mbedtls_ecp_group_free( &ctx->grp );
 c055e30:	3004      	adds	r0, #4
 c055e32:	f7f6 fd24 	bl	c04c87e <mbedtls_ecp_group_free>
    mbedtls_mpi_free( &ctx->d  );
 c055e36:	f104 00a4 	add.w	r0, r4, #164	@ 0xa4
 c055e3a:	f7fd fa62 	bl	c053302 <mbedtls_mpi_free>
    mbedtls_ecp_point_free( &ctx->Q   );
 c055e3e:	f104 00b0 	add.w	r0, r4, #176	@ 0xb0
 c055e42:	f7f6 fd18 	bl	c04c876 <mbedtls_ecp_point_free>
    mbedtls_ecp_point_free( &ctx->Qp  );
 c055e46:	f104 00d4 	add.w	r0, r4, #212	@ 0xd4
 c055e4a:	f7f6 fd14 	bl	c04c876 <mbedtls_ecp_point_free>
    mbedtls_mpi_free( &ctx->z  );
 c055e4e:	f104 00f8 	add.w	r0, r4, #248	@ 0xf8
 c055e52:	f7fd fa56 	bl	c053302 <mbedtls_mpi_free>
            break;
        default:
            break;
    }

    ctx->point_format = MBEDTLS_ECP_PF_UNCOMPRESSED;
 c055e56:	2300      	movs	r3, #0
 c055e58:	8023      	strh	r3, [r4, #0]
    ctx->var = MBEDTLS_ECDH_VARIANT_NONE;
 c055e5a:	70a3      	strb	r3, [r4, #2]
    ctx->grp_id = MBEDTLS_ECP_DP_NONE;
#endif
}
 c055e5c:	bd10      	pop	{r4, pc}
	...

0c055e60 <mbedtls_ecdh_get_params>:
 * Get parameters from a keypair
 */
int mbedtls_ecdh_get_params( mbedtls_ecdh_context *ctx,
                             const mbedtls_ecp_keypair *key,
                             mbedtls_ecdh_side side )
{
 c055e60:	b570      	push	{r4, r5, r6, lr}
    return( ctx->grp_id );
 c055e62:	7843      	ldrb	r3, [r0, #1]
{
 c055e64:	460d      	mov	r5, r1
 c055e66:	4604      	mov	r4, r0
 c055e68:	4616      	mov	r6, r2

    if( mbedtls_ecdh_grp_id( ctx ) == MBEDTLS_ECP_DP_NONE )
    {
        /* This is the first call to get_params(). Set up the context
         * for use with the group. */
        if( ( ret = mbedtls_ecdh_setup( ctx, key->grp.id ) ) != 0 )
 c055e6a:	7809      	ldrb	r1, [r1, #0]
    if( mbedtls_ecdh_grp_id( ctx ) == MBEDTLS_ECP_DP_NONE )
 c055e6c:	b93b      	cbnz	r3, c055e7e <mbedtls_ecdh_get_params+0x1e>
        if( ( ret = mbedtls_ecdh_setup( ctx, key->grp.id ) ) != 0 )
 c055e6e:	f7ff ffb1 	bl	c055dd4 <mbedtls_ecdh_setup>
 c055e72:	b918      	cbnz	r0, c055e7c <mbedtls_ecdh_get_params+0x1c>
    }

#if defined(MBEDTLS_ECDH_LEGACY_CONTEXT)
    return( ecdh_get_params_internal( ctx, key, side ) );
#else
    switch( ctx->var )
 c055e74:	78a3      	ldrb	r3, [r4, #2]
 c055e76:	2b01      	cmp	r3, #1
 c055e78:	d004      	beq.n	c055e84 <mbedtls_ecdh_get_params+0x24>
            return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );
 c055e7a:	4810      	ldr	r0, [pc, #64]	@ (c055ebc <mbedtls_ecdh_get_params+0x5c>)
                                              key, side ) );
        default:
            return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
    }
#endif
}
 c055e7c:	bd70      	pop	{r4, r5, r6, pc}
        if( mbedtls_ecdh_grp_id( ctx ) != key->grp.id )
 c055e7e:	428b      	cmp	r3, r1
 c055e80:	d0f8      	beq.n	c055e74 <mbedtls_ecdh_get_params+0x14>
 c055e82:	e7fa      	b.n	c055e7a <mbedtls_ecdh_get_params+0x1a>
    if( side == MBEDTLS_ECDH_THEIRS )
 c055e84:	2e01      	cmp	r6, #1
 c055e86:	d107      	bne.n	c055e98 <mbedtls_ecdh_get_params+0x38>
        return( mbedtls_ecp_copy( &ctx->Qp, &key->Q ) );
 c055e88:	f105 01ac 	add.w	r1, r5, #172	@ 0xac
 c055e8c:	f104 00d4 	add.w	r0, r4, #212	@ 0xd4
}
 c055e90:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        return( mbedtls_ecp_copy( &ctx->Qp, &key->Q ) );
 c055e94:	f7f6 bd73 	b.w	c04c97e <mbedtls_ecp_copy>
    if( side != MBEDTLS_ECDH_OURS )
 c055e98:	2e00      	cmp	r6, #0
 c055e9a:	d1ee      	bne.n	c055e7a <mbedtls_ecdh_get_params+0x1a>
    if( ( ret = mbedtls_ecp_copy( &ctx->Q, &key->Q ) ) != 0 ||
 c055e9c:	f105 01ac 	add.w	r1, r5, #172	@ 0xac
 c055ea0:	f104 00b0 	add.w	r0, r4, #176	@ 0xb0
 c055ea4:	f7f6 fd6b 	bl	c04c97e <mbedtls_ecp_copy>
 c055ea8:	2800      	cmp	r0, #0
 c055eaa:	d1e7      	bne.n	c055e7c <mbedtls_ecdh_get_params+0x1c>
        ( ret = mbedtls_mpi_copy( &ctx->d, &key->d ) ) != 0 )
 c055eac:	f105 01a0 	add.w	r1, r5, #160	@ 0xa0
 c055eb0:	f104 00a4 	add.w	r0, r4, #164	@ 0xa4
}
 c055eb4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        ( ret = mbedtls_mpi_copy( &ctx->d, &key->d ) ) != 0 )
 c055eb8:	f7fd ba77 	b.w	c0533aa <mbedtls_mpi_copy>
 c055ebc:	ffffb080 	.word	0xffffb080

0c055ec0 <mbedtls_ecdh_calc_secret>:
 */
int mbedtls_ecdh_calc_secret( mbedtls_ecdh_context *ctx, size_t *olen,
                              unsigned char *buf, size_t blen,
                              int (*f_rng)(void *, unsigned char *, size_t),
                              void *p_rng )
{
 c055ec0:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 c055ec4:	460d      	mov	r5, r1

#if defined(MBEDTLS_ECDH_LEGACY_CONTEXT)
    return( ecdh_calc_secret_internal( ctx, olen, buf, blen, f_rng, p_rng,
                                       restart_enabled ) );
#else
    switch( ctx->var )
 c055ec6:	7881      	ldrb	r1, [r0, #2]
{
 c055ec8:	4617      	mov	r7, r2
    switch( ctx->var )
 c055eca:	2901      	cmp	r1, #1
{
 c055ecc:	4699      	mov	r9, r3
 c055ece:	e9dd 320a 	ldrd	r3, r2, [sp, #40]	@ 0x28
 c055ed2:	4604      	mov	r4, r0
    switch( ctx->var )
 c055ed4:	d003      	beq.n	c055ede <mbedtls_ecdh_calc_secret+0x1e>
        case MBEDTLS_ECDH_VARIANT_MBEDTLS_2_0:
            return( ecdh_calc_secret_internal( &ctx->ctx.mbed_ecdh, olen, buf,
                                               blen, f_rng, p_rng,
                                               restart_enabled ) );
        default:
            return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );
 c055ed6:	481b      	ldr	r0, [pc, #108]	@ (c055f44 <mbedtls_ecdh_calc_secret+0x84>)
    }
#endif
}
 c055ed8:	b003      	add	sp, #12
 c055eda:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    if( ctx == NULL || ctx->grp.pbits == 0 )
 c055ede:	6dc1      	ldr	r1, [r0, #92]	@ 0x5c
            return( ecdh_calc_secret_internal( &ctx->ctx.mbed_ecdh, olen, buf,
 c055ee0:	f100 0804 	add.w	r8, r0, #4
    if( ctx == NULL || ctx->grp.pbits == 0 )
 c055ee4:	2900      	cmp	r1, #0
 c055ee6:	d0f6      	beq.n	c055ed6 <mbedtls_ecdh_calc_secret+0x16>
    if( ( ret = mbedtls_ecdh_compute_shared( &ctx->grp, &ctx->z, &ctx->Qp,
 c055ee8:	f100 06f8 	add.w	r6, r0, #248	@ 0xf8
 c055eec:	e9cd 3200 	strd	r3, r2, [sp]
 c055ef0:	4631      	mov	r1, r6
 c055ef2:	f100 03a4 	add.w	r3, r0, #164	@ 0xa4
 c055ef6:	f100 02d4 	add.w	r2, r0, #212	@ 0xd4
 c055efa:	4640      	mov	r0, r8
 c055efc:	f7ff ff3a 	bl	c055d74 <mbedtls_ecdh_compute_shared>
 c055f00:	2800      	cmp	r0, #0
 c055f02:	d1e9      	bne.n	c055ed8 <mbedtls_ecdh_calc_secret+0x18>
    if( mbedtls_mpi_size( &ctx->z ) > blen )
 c055f04:	4630      	mov	r0, r6
 c055f06:	f7fd fb28 	bl	c05355a <mbedtls_mpi_size>
 c055f0a:	4581      	cmp	r9, r0
 c055f0c:	d3e3      	bcc.n	c055ed6 <mbedtls_ecdh_calc_secret+0x16>
    *olen = ctx->grp.pbits / 8 + ( ( ctx->grp.pbits % 8 ) != 0 );
 c055f0e:	6de2      	ldr	r2, [r4, #92]	@ 0x5c
    if( mbedtls_ecp_get_type( &ctx->grp ) == MBEDTLS_ECP_TYPE_MONTGOMERY )
 c055f10:	4640      	mov	r0, r8
    *olen = ctx->grp.pbits / 8 + ( ( ctx->grp.pbits % 8 ) != 0 );
 c055f12:	f012 0307 	ands.w	r3, r2, #7
 c055f16:	bf18      	it	ne
 c055f18:	2301      	movne	r3, #1
 c055f1a:	eb03 03d2 	add.w	r3, r3, r2, lsr #3
 c055f1e:	602b      	str	r3, [r5, #0]
    if( mbedtls_ecp_get_type( &ctx->grp ) == MBEDTLS_ECP_TYPE_MONTGOMERY )
 c055f20:	f7f6 fc5a 	bl	c04c7d8 <mbedtls_ecp_get_type>
 c055f24:	2802      	cmp	r0, #2
        return mbedtls_mpi_write_binary_le( &ctx->z, buf, *olen );
 c055f26:	4639      	mov	r1, r7
 c055f28:	4630      	mov	r0, r6
 c055f2a:	682a      	ldr	r2, [r5, #0]
    if( mbedtls_ecp_get_type( &ctx->grp ) == MBEDTLS_ECP_TYPE_MONTGOMERY )
 c055f2c:	d104      	bne.n	c055f38 <mbedtls_ecdh_calc_secret+0x78>
}
 c055f2e:	b003      	add	sp, #12
 c055f30:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
        return mbedtls_mpi_write_binary_le( &ctx->z, buf, *olen );
 c055f34:	f7fd bb5a 	b.w	c0535ec <mbedtls_mpi_write_binary_le>
}
 c055f38:	b003      	add	sp, #12
 c055f3a:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
    return mbedtls_mpi_write_binary( &ctx->z, buf, *olen );
 c055f3e:	f7fd bb8b 	b.w	c053658 <mbedtls_mpi_write_binary>
 c055f42:	bf00      	nop
 c055f44:	ffffb080 	.word	0xffffb080

0c055f48 <ecdsa_sign_det_restartable.constprop.0>:

#if defined(MBEDTLS_ECDSA_DETERMINISTIC)
/*
 * Deterministic signature wrapper
 */
static int ecdsa_sign_det_restartable( mbedtls_ecp_group *grp,
 c055f48:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c055f4c:	b0c5      	sub	sp, #276	@ 0x114
{
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    mbedtls_hmac_drbg_context rng_ctx;
    mbedtls_hmac_drbg_context *p_rng = &rng_ctx;
    unsigned char data[2 * MBEDTLS_ECP_MAX_BYTES];
    size_t grp_len = ( grp->nbits + 7 ) / 8;
 c055f4e:	6dc4      	ldr	r4, [r0, #92]	@ 0x5c
static int ecdsa_sign_det_restartable( mbedtls_ecp_group *grp,
 c055f50:	4605      	mov	r5, r0
    const mbedtls_md_info_t *md_info;
    mbedtls_mpi h;

    if( ( md_info = mbedtls_md_info_from_type( md_alg ) ) == NULL )
 c055f52:	f89d 0140 	ldrb.w	r0, [sp, #320]	@ 0x140
static int ecdsa_sign_det_restartable( mbedtls_ecp_group *grp,
 c055f56:	4688      	mov	r8, r1
 c055f58:	4691      	mov	r9, r2
 c055f5a:	461e      	mov	r6, r3
    if( ( md_info = mbedtls_md_info_from_type( md_alg ) ) == NULL )
 c055f5c:	f000 fbf8 	bl	c056750 <mbedtls_md_info_from_type>
    size_t grp_len = ( grp->nbits + 7 ) / 8;
 c055f60:	3407      	adds	r4, #7
    if( ( md_info = mbedtls_md_info_from_type( md_alg ) ) == NULL )
 c055f62:	4607      	mov	r7, r0
    size_t grp_len = ( grp->nbits + 7 ) / 8;
 c055f64:	08e4      	lsrs	r4, r4, #3
    if( ( md_info = mbedtls_md_info_from_type( md_alg ) ) == NULL )
 c055f66:	2800      	cmp	r0, #0
 c055f68:	d062      	beq.n	c056030 <ecdsa_sign_det_restartable.constprop.0+0xe8>
        return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );

    mbedtls_mpi_init( &h );
 c055f6a:	a807      	add	r0, sp, #28
    mbedtls_hmac_drbg_init( &rng_ctx );
 c055f6c:	f10d 0a28 	add.w	sl, sp, #40	@ 0x28
    mbedtls_mpi_init( &h );
 c055f70:	f7fd f9c1 	bl	c0532f6 <mbedtls_mpi_init>
    mbedtls_hmac_drbg_init( &rng_ctx );
 c055f74:	4650      	mov	r0, sl
 c055f76:	f000 fa8a 	bl	c05648e <mbedtls_hmac_drbg_init>
            goto sign;
    }
#endif /* MBEDTLS_ECP_RESTARTABLE */

    /* Use private key and message hash (reduced) to initialize HMAC_DRBG */
    MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( d, data, grp_len ) );
 c055f7a:	4622      	mov	r2, r4
 c055f7c:	4630      	mov	r0, r6
 c055f7e:	a923      	add	r1, sp, #140	@ 0x8c
 c055f80:	f7fd fb6a 	bl	c053658 <mbedtls_mpi_write_binary>
 c055f84:	4683      	mov	fp, r0
 c055f86:	2800      	cmp	r0, #0
 c055f88:	d148      	bne.n	c05601c <ecdsa_sign_det_restartable.constprop.0+0xd4>
    size_t n_size = ( grp->nbits + 7 ) / 8;
 c055f8a:	6dea      	ldr	r2, [r5, #92]	@ 0x5c
    size_t use_size = blen > n_size ? n_size : blen;
 c055f8c:	9b4f      	ldr	r3, [sp, #316]	@ 0x13c
    size_t n_size = ( grp->nbits + 7 ) / 8;
 c055f8e:	3207      	adds	r2, #7
 c055f90:	08d2      	lsrs	r2, r2, #3
    size_t use_size = blen > n_size ? n_size : blen;
 c055f92:	429a      	cmp	r2, r3
 c055f94:	bf28      	it	cs
 c055f96:	461a      	movcs	r2, r3
    MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( x, buf, use_size ) );
 c055f98:	994e      	ldr	r1, [sp, #312]	@ 0x138
 c055f9a:	a807      	add	r0, sp, #28
 c055f9c:	9205      	str	r2, [sp, #20]
 c055f9e:	f7fd fb04 	bl	c0535aa <mbedtls_mpi_read_binary>
 c055fa2:	4683      	mov	fp, r0
 c055fa4:	2800      	cmp	r0, #0
 c055fa6:	d139      	bne.n	c05601c <ecdsa_sign_det_restartable.constprop.0+0xd4>
    if( use_size * 8 > grp->nbits )
 c055fa8:	9a05      	ldr	r2, [sp, #20]
 c055faa:	6deb      	ldr	r3, [r5, #92]	@ 0x5c
 c055fac:	00d1      	lsls	r1, r2, #3
 c055fae:	ebb3 0fc2 	cmp.w	r3, r2, lsl #3
 c055fb2:	d32c      	bcc.n	c05600e <ecdsa_sign_det_restartable.constprop.0+0xc6>
    if( mbedtls_mpi_cmp_mpi( x, &grp->N ) >= 0 )
 c055fb4:	f105 0b4c 	add.w	fp, r5, #76	@ 0x4c
 c055fb8:	4659      	mov	r1, fp
 c055fba:	a807      	add	r0, sp, #28
 c055fbc:	f7fd fc3e 	bl	c05383c <mbedtls_mpi_cmp_mpi>
 c055fc0:	2800      	cmp	r0, #0
 c055fc2:	db06      	blt.n	c055fd2 <ecdsa_sign_det_restartable.constprop.0+0x8a>
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( x, x, &grp->N ) );
 c055fc4:	a907      	add	r1, sp, #28
 c055fc6:	465a      	mov	r2, fp
 c055fc8:	4608      	mov	r0, r1
 c055fca:	f7fd fd79 	bl	c053ac0 <mbedtls_mpi_sub_mpi>
 c055fce:	4683      	mov	fp, r0
 c055fd0:	bb20      	cbnz	r0, c05601c <ecdsa_sign_det_restartable.constprop.0+0xd4>
    MBEDTLS_MPI_CHK( derive_mpi( grp, &h, buf, blen ) );
    MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( &h, data + grp_len, grp_len ) );
 c055fd2:	ab23      	add	r3, sp, #140	@ 0x8c
 c055fd4:	4622      	mov	r2, r4
 c055fd6:	1919      	adds	r1, r3, r4
 c055fd8:	a807      	add	r0, sp, #28
 c055fda:	f7fd fb3d 	bl	c053658 <mbedtls_mpi_write_binary>
 c055fde:	4683      	mov	fp, r0
 c055fe0:	b9e0      	cbnz	r0, c05601c <ecdsa_sign_det_restartable.constprop.0+0xd4>
    mbedtls_hmac_drbg_seed_buf( p_rng, md_info, data, 2 * grp_len );
 c055fe2:	4639      	mov	r1, r7
 c055fe4:	0063      	lsls	r3, r4, #1
 c055fe6:	aa23      	add	r2, sp, #140	@ 0x8c
 c055fe8:	4650      	mov	r0, sl
 c055fea:	f000 fb13 	bl	c056614 <mbedtls_hmac_drbg_seed_buf>
sign:
#endif
#if defined(MBEDTLS_ECDSA_SIGN_ALT)
    (void) f_rng_blind;
    (void) p_rng_blind;
    ret = mbedtls_ecdsa_sign( grp, r, s, d, buf, blen,
 c055fee:	4b12      	ldr	r3, [pc, #72]	@ (c056038 <ecdsa_sign_det_restartable.constprop.0+0xf0>)
 c055ff0:	464a      	mov	r2, r9
 c055ff2:	9302      	str	r3, [sp, #8]
 c055ff4:	9b4f      	ldr	r3, [sp, #316]	@ 0x13c
 c055ff6:	4641      	mov	r1, r8
 c055ff8:	9301      	str	r3, [sp, #4]
 c055ffa:	9b4e      	ldr	r3, [sp, #312]	@ 0x138
 c055ffc:	4628      	mov	r0, r5
 c055ffe:	9300      	str	r3, [sp, #0]
 c056000:	f8cd a00c 	str.w	sl, [sp, #12]
 c056004:	4633      	mov	r3, r6
 c056006:	f7f6 f953 	bl	c04c2b0 <mbedtls_ecdsa_sign>
 c05600a:	4683      	mov	fp, r0
 c05600c:	e006      	b.n	c05601c <ecdsa_sign_det_restartable.constprop.0+0xd4>
        MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( x, use_size * 8 - grp->nbits ) );
 c05600e:	1ac9      	subs	r1, r1, r3
 c056010:	a807      	add	r0, sp, #28
 c056012:	f7fd fba6 	bl	c053762 <mbedtls_mpi_shift_r>
 c056016:	4683      	mov	fp, r0
 c056018:	2800      	cmp	r0, #0
 c05601a:	d0cb      	beq.n	c055fb4 <ecdsa_sign_det_restartable.constprop.0+0x6c>
#endif
    }
#endif /* MBEDTLS_ECDSA_SIGN_ALT */

cleanup:
    mbedtls_hmac_drbg_free( &rng_ctx );
 c05601c:	a80a      	add	r0, sp, #40	@ 0x28
 c05601e:	f000 fb8a 	bl	c056736 <mbedtls_hmac_drbg_free>
    mbedtls_mpi_free( &h );
 c056022:	a807      	add	r0, sp, #28
 c056024:	f7fd f96d 	bl	c053302 <mbedtls_mpi_free>

    ECDSA_RS_LEAVE( det );

    return( ret );
}
 c056028:	4658      	mov	r0, fp
 c05602a:	b045      	add	sp, #276	@ 0x114
 c05602c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );
 c056030:	f8df b008 	ldr.w	fp, [pc, #8]	@ c05603c <ecdsa_sign_det_restartable.constprop.0+0xf4>
 c056034:	e7f8      	b.n	c056028 <ecdsa_sign_det_restartable.constprop.0+0xe0>
 c056036:	bf00      	nop
 c056038:	0c056727 	.word	0x0c056727
 c05603c:	ffffb080 	.word	0xffffb080

0c056040 <mbedtls_ecdsa_sign_det_ext>:
                                const unsigned char *buf, size_t blen,
                                mbedtls_md_type_t md_alg,
                                int (*f_rng_blind)(void *, unsigned char *,
                                                   size_t),
                                void *p_rng_blind )
{
 c056040:	b410      	push	{r4}
 c056042:	f89d 400c 	ldrb.w	r4, [sp, #12]
    ECDSA_VALIDATE_RET( s     != NULL );
    ECDSA_VALIDATE_RET( d     != NULL );
    ECDSA_VALIDATE_RET( buf   != NULL || blen == 0 );
    ECDSA_VALIDATE_RET( f_rng_blind != NULL );

    return( ecdsa_sign_det_restartable( grp, r, s, d, buf, blen, md_alg,
 c056046:	9403      	str	r4, [sp, #12]
                                        f_rng_blind, p_rng_blind, NULL ) );
}
 c056048:	bc10      	pop	{r4}
    return( ecdsa_sign_det_restartable( grp, r, s, d, buf, blen, md_alg,
 c05604a:	f7ff bf7d 	b.w	c055f48 <ecdsa_sign_det_restartable.constprop.0>

0c05604e <mbedtls_ecdsa_write_signature_restartable>:
                           const unsigned char *hash, size_t hlen,
                           unsigned char *sig, size_t *slen,
                           int (*f_rng)(void *, unsigned char *, size_t),
                           void *p_rng,
                           mbedtls_ecdsa_restart_ctx *rs_ctx )
{
 c05604e:	b5f0      	push	{r4, r5, r6, r7, lr}
 c056050:	4615      	mov	r5, r2
 c056052:	460f      	mov	r7, r1
 c056054:	461e      	mov	r6, r3
 c056056:	4604      	mov	r4, r0
 c056058:	b0af      	sub	sp, #188	@ 0xbc
    ECDSA_VALIDATE_RET( ctx  != NULL );
    ECDSA_VALIDATE_RET( hash != NULL );
    ECDSA_VALIDATE_RET( sig  != NULL );
    ECDSA_VALIDATE_RET( slen != NULL );

    mbedtls_mpi_init( &r );
 c05605a:	a805      	add	r0, sp, #20
 c05605c:	f7fd f94b 	bl	c0532f6 <mbedtls_mpi_init>
    mbedtls_mpi_init( &s );
 c056060:	a808      	add	r0, sp, #32
 c056062:	f7fd f948 	bl	c0532f6 <mbedtls_mpi_init>

#if defined(MBEDTLS_ECDSA_DETERMINISTIC)
    MBEDTLS_MPI_CHK( ecdsa_sign_det_restartable( &ctx->grp, &r, &s, &ctx->d,
 c056066:	9500      	str	r5, [sp, #0]
 c056068:	4620      	mov	r0, r4
 c05606a:	e9cd 6701 	strd	r6, r7, [sp, #4]
 c05606e:	f104 03a0 	add.w	r3, r4, #160	@ 0xa0
 c056072:	aa08      	add	r2, sp, #32
 c056074:	a905      	add	r1, sp, #20
 c056076:	f7ff ff67 	bl	c055f48 <ecdsa_sign_det_restartable.constprop.0>
 c05607a:	4605      	mov	r5, r0
 c05607c:	2800      	cmp	r0, #0
 c05607e:	d130      	bne.n	c0560e2 <mbedtls_ecdsa_write_signature_restartable+0x94>
    unsigned char buf[MBEDTLS_ECDSA_MAX_LEN] = {0};
 c056080:	4601      	mov	r1, r0
 c056082:	2287      	movs	r2, #135	@ 0x87
 c056084:	900b      	str	r0, [sp, #44]	@ 0x2c
 c056086:	a80c      	add	r0, sp, #48	@ 0x30
 c056088:	f005 fb51 	bl	c05b72e <memset>
    unsigned char *p = buf + sizeof( buf );
 c05608c:	f10d 03b7 	add.w	r3, sp, #183	@ 0xb7
    MBEDTLS_ASN1_CHK_ADD( len, mbedtls_asn1_write_mpi( &p, buf, s ) );
 c056090:	aa08      	add	r2, sp, #32
 c056092:	a90b      	add	r1, sp, #44	@ 0x2c
 c056094:	a804      	add	r0, sp, #16
    unsigned char *p = buf + sizeof( buf );
 c056096:	9304      	str	r3, [sp, #16]
    MBEDTLS_ASN1_CHK_ADD( len, mbedtls_asn1_write_mpi( &p, buf, s ) );
 c056098:	f7fc fe46 	bl	c052d28 <mbedtls_asn1_write_mpi>
 c05609c:	1e04      	subs	r4, r0, #0
 c05609e:	db1f      	blt.n	c0560e0 <mbedtls_ecdsa_write_signature_restartable+0x92>
    MBEDTLS_ASN1_CHK_ADD( len, mbedtls_asn1_write_mpi( &p, buf, r ) );
 c0560a0:	aa05      	add	r2, sp, #20
 c0560a2:	a90b      	add	r1, sp, #44	@ 0x2c
 c0560a4:	a804      	add	r0, sp, #16
 c0560a6:	f7fc fe3f 	bl	c052d28 <mbedtls_asn1_write_mpi>
 c0560aa:	1e06      	subs	r6, r0, #0
 c0560ac:	db22      	blt.n	c0560f4 <mbedtls_ecdsa_write_signature_restartable+0xa6>
 c0560ae:	4426      	add	r6, r4
    MBEDTLS_ASN1_CHK_ADD( len, mbedtls_asn1_write_len( &p, buf, len ) );
 c0560b0:	4632      	mov	r2, r6
 c0560b2:	a90b      	add	r1, sp, #44	@ 0x2c
 c0560b4:	a804      	add	r0, sp, #16
 c0560b6:	f7fc fd65 	bl	c052b84 <mbedtls_asn1_write_len>
 c0560ba:	1e04      	subs	r4, r0, #0
 c0560bc:	db10      	blt.n	c0560e0 <mbedtls_ecdsa_write_signature_restartable+0x92>
    MBEDTLS_ASN1_CHK_ADD( len, mbedtls_asn1_write_tag( &p, buf,
 c0560be:	2230      	movs	r2, #48	@ 0x30
 c0560c0:	a90b      	add	r1, sp, #44	@ 0x2c
 c0560c2:	a804      	add	r0, sp, #16
 c0560c4:	f7fc fdd2 	bl	c052c6c <mbedtls_asn1_write_tag>
 c0560c8:	2800      	cmp	r0, #0
 c0560ca:	db15      	blt.n	c0560f8 <mbedtls_ecdsa_write_signature_restartable+0xaa>
    MBEDTLS_ASN1_CHK_ADD( len, mbedtls_asn1_write_len( &p, buf, len ) );
 c0560cc:	4434      	add	r4, r6
    MBEDTLS_ASN1_CHK_ADD( len, mbedtls_asn1_write_tag( &p, buf,
 c0560ce:	4404      	add	r4, r0
    memcpy( sig, p, len );
 c0560d0:	4622      	mov	r2, r4
 c0560d2:	9904      	ldr	r1, [sp, #16]
 c0560d4:	9834      	ldr	r0, [sp, #208]	@ 0xd0
 c0560d6:	f005 fab9 	bl	c05b64c <memcpy>
    *slen = len;
 c0560da:	9b35      	ldr	r3, [sp, #212]	@ 0xd4
 c0560dc:	601c      	str	r4, [r3, #0]
    return( 0 );
 c0560de:	462c      	mov	r4, r5
                                             hash, hlen, f_rng, p_rng, f_rng,
                                             p_rng, rs_ctx ) );
#endif /* MBEDTLS_ECDSA_SIGN_ALT */
#endif /* MBEDTLS_ECDSA_DETERMINISTIC */

    MBEDTLS_MPI_CHK( ecdsa_signature_to_asn1( &r, &s, sig, slen ) );
 c0560e0:	4625      	mov	r5, r4

cleanup:
    mbedtls_mpi_free( &r );
 c0560e2:	a805      	add	r0, sp, #20
 c0560e4:	f7fd f90d 	bl	c053302 <mbedtls_mpi_free>
    mbedtls_mpi_free( &s );
 c0560e8:	a808      	add	r0, sp, #32
 c0560ea:	f7fd f90a 	bl	c053302 <mbedtls_mpi_free>

    return( ret );
}
 c0560ee:	4628      	mov	r0, r5
 c0560f0:	b02f      	add	sp, #188	@ 0xbc
 c0560f2:	bdf0      	pop	{r4, r5, r6, r7, pc}
 c0560f4:	4634      	mov	r4, r6
 c0560f6:	e7f3      	b.n	c0560e0 <mbedtls_ecdsa_write_signature_restartable+0x92>
 c0560f8:	4604      	mov	r4, r0
 c0560fa:	e7f1      	b.n	c0560e0 <mbedtls_ecdsa_write_signature_restartable+0x92>

0c0560fc <mbedtls_ecdsa_write_signature>:
                                 mbedtls_md_type_t md_alg,
                                 const unsigned char *hash, size_t hlen,
                                 unsigned char *sig, size_t *slen,
                                 int (*f_rng)(void *, unsigned char *, size_t),
                                 void *p_rng )
{
 c0560fc:	b510      	push	{r4, lr}
    ECDSA_VALIDATE_RET( ctx  != NULL );
    ECDSA_VALIDATE_RET( hash != NULL );
    ECDSA_VALIDATE_RET( sig  != NULL );
    ECDSA_VALIDATE_RET( slen != NULL );
    return( mbedtls_ecdsa_write_signature_restartable(
 c0560fe:	2400      	movs	r4, #0
{
 c056100:	b086      	sub	sp, #24
    return( mbedtls_ecdsa_write_signature_restartable(
 c056102:	9404      	str	r4, [sp, #16]
 c056104:	9c0b      	ldr	r4, [sp, #44]	@ 0x2c
 c056106:	9403      	str	r4, [sp, #12]
 c056108:	9c0a      	ldr	r4, [sp, #40]	@ 0x28
 c05610a:	9402      	str	r4, [sp, #8]
 c05610c:	9c09      	ldr	r4, [sp, #36]	@ 0x24
 c05610e:	9401      	str	r4, [sp, #4]
 c056110:	9c08      	ldr	r4, [sp, #32]
 c056112:	9400      	str	r4, [sp, #0]
 c056114:	f7ff ff9b 	bl	c05604e <mbedtls_ecdsa_write_signature_restartable>
                ctx, md_alg, hash, hlen, sig, slen, f_rng, p_rng, NULL ) );
}
 c056118:	b006      	add	sp, #24
 c05611a:	bd10      	pop	{r4, pc}

0c05611c <mbedtls_ecdsa_read_signature_restartable>:
 */
int mbedtls_ecdsa_read_signature_restartable( mbedtls_ecdsa_context *ctx,
                          const unsigned char *hash, size_t hlen,
                          const unsigned char *sig, size_t slen,
                          mbedtls_ecdsa_restart_ctx *rs_ctx )
{
 c05611c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 c056120:	b08a      	sub	sp, #40	@ 0x28
 c056122:	4692      	mov	sl, r2
    mbedtls_mpi r, s;
    ECDSA_VALIDATE_RET( ctx  != NULL );
    ECDSA_VALIDATE_RET( hash != NULL );
    ECDSA_VALIDATE_RET( sig  != NULL );

    mbedtls_mpi_init( &r );
 c056124:	af04      	add	r7, sp, #16
    const unsigned char *end = sig + slen;
 c056126:	9a12      	ldr	r2, [sp, #72]	@ 0x48
{
 c056128:	4680      	mov	r8, r0
    mbedtls_mpi_init( &s );
 c05612a:	ae07      	add	r6, sp, #28
    mbedtls_mpi_init( &r );
 c05612c:	4638      	mov	r0, r7
    const unsigned char *end = sig + slen;
 c05612e:	189d      	adds	r5, r3, r2
{
 c056130:	4689      	mov	r9, r1
    unsigned char *p = (unsigned char *) sig;
 c056132:	9302      	str	r3, [sp, #8]
    mbedtls_mpi_init( &r );
 c056134:	f7fd f8df 	bl	c0532f6 <mbedtls_mpi_init>
    mbedtls_mpi_init( &s );
 c056138:	4630      	mov	r0, r6
 c05613a:	f7fd f8dc 	bl	c0532f6 <mbedtls_mpi_init>

    if( ( ret = mbedtls_asn1_get_tag( &p, end, &len,
 c05613e:	2330      	movs	r3, #48	@ 0x30
 c056140:	4629      	mov	r1, r5
 c056142:	aa03      	add	r2, sp, #12
 c056144:	a802      	add	r0, sp, #8
 c056146:	f7fc fc5e 	bl	c052a06 <mbedtls_asn1_get_tag>
 c05614a:	b158      	cbz	r0, c056164 <mbedtls_ecdsa_read_signature_restartable+0x48>
    }

    if( ( ret = mbedtls_asn1_get_mpi( &p, end, &r ) ) != 0 ||
        ( ret = mbedtls_asn1_get_mpi( &p, end, &s ) ) != 0 )
    {
        ret += MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
 c05614c:	f5a0 449f 	sub.w	r4, r0, #20352	@ 0x4f80
     * error code if the valid signature is followed by more data. */
    if( p != end )
        ret = MBEDTLS_ERR_ECP_SIG_LEN_MISMATCH;

cleanup:
    mbedtls_mpi_free( &r );
 c056150:	4638      	mov	r0, r7
 c056152:	f7fd f8d6 	bl	c053302 <mbedtls_mpi_free>
    mbedtls_mpi_free( &s );
 c056156:	4630      	mov	r0, r6
 c056158:	f7fd f8d3 	bl	c053302 <mbedtls_mpi_free>

    return( ret );
}
 c05615c:	4620      	mov	r0, r4
 c05615e:	b00a      	add	sp, #40	@ 0x28
 c056160:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if( p + len != end )
 c056164:	e9dd 3202 	ldrd	r3, r2, [sp, #8]
 c056168:	4413      	add	r3, r2
 c05616a:	429d      	cmp	r5, r3
 c05616c:	d11f      	bne.n	c0561ae <mbedtls_ecdsa_read_signature_restartable+0x92>
    if( ( ret = mbedtls_asn1_get_mpi( &p, end, &r ) ) != 0 ||
 c05616e:	463a      	mov	r2, r7
 c056170:	4629      	mov	r1, r5
 c056172:	a802      	add	r0, sp, #8
 c056174:	f7fc fc95 	bl	c052aa2 <mbedtls_asn1_get_mpi>
 c056178:	2800      	cmp	r0, #0
 c05617a:	d1e7      	bne.n	c05614c <mbedtls_ecdsa_read_signature_restartable+0x30>
        ( ret = mbedtls_asn1_get_mpi( &p, end, &s ) ) != 0 )
 c05617c:	4632      	mov	r2, r6
 c05617e:	4629      	mov	r1, r5
 c056180:	a802      	add	r0, sp, #8
 c056182:	f7fc fc8e 	bl	c052aa2 <mbedtls_asn1_get_mpi>
    if( ( ret = mbedtls_asn1_get_mpi( &p, end, &r ) ) != 0 ||
 c056186:	2800      	cmp	r0, #0
 c056188:	d1e0      	bne.n	c05614c <mbedtls_ecdsa_read_signature_restartable+0x30>
    if( ( ret = mbedtls_ecdsa_verify( &ctx->grp, hash, hlen,
 c05618a:	4652      	mov	r2, sl
 c05618c:	4649      	mov	r1, r9
 c05618e:	4640      	mov	r0, r8
 c056190:	e9cd 7600 	strd	r7, r6, [sp]
 c056194:	f108 03ac 	add.w	r3, r8, #172	@ 0xac
 c056198:	f7f6 f988 	bl	c04c4ac <mbedtls_ecdsa_verify>
 c05619c:	4604      	mov	r4, r0
 c05619e:	2800      	cmp	r0, #0
 c0561a0:	d1d6      	bne.n	c056150 <mbedtls_ecdsa_read_signature_restartable+0x34>
        ret = MBEDTLS_ERR_ECP_SIG_LEN_MISMATCH;
 c0561a2:	9a02      	ldr	r2, [sp, #8]
 c0561a4:	4b03      	ldr	r3, [pc, #12]	@ (c0561b4 <mbedtls_ecdsa_read_signature_restartable+0x98>)
 c0561a6:	42aa      	cmp	r2, r5
 c0561a8:	bf18      	it	ne
 c0561aa:	461c      	movne	r4, r3
 c0561ac:	e7d0      	b.n	c056150 <mbedtls_ecdsa_read_signature_restartable+0x34>
        ret = MBEDTLS_ERROR_ADD( MBEDTLS_ERR_ECP_BAD_INPUT_DATA,
 c0561ae:	4c02      	ldr	r4, [pc, #8]	@ (c0561b8 <mbedtls_ecdsa_read_signature_restartable+0x9c>)
 c0561b0:	e7ce      	b.n	c056150 <mbedtls_ecdsa_read_signature_restartable+0x34>
 c0561b2:	bf00      	nop
 c0561b4:	ffffb400 	.word	0xffffb400
 c0561b8:	ffffb01a 	.word	0xffffb01a

0c0561bc <mbedtls_ecdsa_read_signature>:
{
 c0561bc:	b513      	push	{r0, r1, r4, lr}
    return( mbedtls_ecdsa_read_signature_restartable(
 c0561be:	2400      	movs	r4, #0
 c0561c0:	9401      	str	r4, [sp, #4]
 c0561c2:	9c04      	ldr	r4, [sp, #16]
 c0561c4:	9400      	str	r4, [sp, #0]
 c0561c6:	f7ff ffa9 	bl	c05611c <mbedtls_ecdsa_read_signature_restartable>
}
 c0561ca:	b002      	add	sp, #8
 c0561cc:	bd10      	pop	{r4, pc}

0c0561ce <mbedtls_ecdsa_init>:
 */
void mbedtls_ecdsa_init( mbedtls_ecdsa_context *ctx )
{
    ECDSA_VALIDATE( ctx != NULL );

    mbedtls_ecp_keypair_init( ctx );
 c0561ce:	f7f6 bb44 	b.w	c04c85a <mbedtls_ecp_keypair_init>

0c0561d2 <mbedtls_ecdsa_free>:
/*
 * Free context
 */
void mbedtls_ecdsa_free( mbedtls_ecdsa_context *ctx )
{
    if( ctx == NULL )
 c0561d2:	b108      	cbz	r0, c0561d8 <mbedtls_ecdsa_free+0x6>
        return;

    mbedtls_ecp_keypair_free( ctx );
 c0561d4:	f7f6 bbc3 	b.w	c04c95e <mbedtls_ecp_keypair_free>
}
 c0561d8:	4770      	bx	lr

0c0561da <mbedtls_ecdsa_from_keypair>:
{
 c0561da:	b570      	push	{r4, r5, r6, lr}
 c0561dc:	4605      	mov	r5, r0
 c0561de:	460e      	mov	r6, r1
    if( ( ret = mbedtls_ecp_group_copy( &ctx->grp, &key->grp ) ) != 0 ||
 c0561e0:	f7f6 fbe3 	bl	c04c9aa <mbedtls_ecp_group_copy>
 c0561e4:	4604      	mov	r4, r0
 c0561e6:	b978      	cbnz	r0, c056208 <mbedtls_ecdsa_from_keypair+0x2e>
        ( ret = mbedtls_mpi_copy( &ctx->d, &key->d ) ) != 0 ||
 c0561e8:	f106 01a0 	add.w	r1, r6, #160	@ 0xa0
 c0561ec:	f105 00a0 	add.w	r0, r5, #160	@ 0xa0
 c0561f0:	f7fd f8db 	bl	c0533aa <mbedtls_mpi_copy>
    if( ( ret = mbedtls_ecp_group_copy( &ctx->grp, &key->grp ) ) != 0 ||
 c0561f4:	4604      	mov	r4, r0
 c0561f6:	b938      	cbnz	r0, c056208 <mbedtls_ecdsa_from_keypair+0x2e>
        ( ret = mbedtls_ecp_copy( &ctx->Q, &key->Q ) ) != 0 )
 c0561f8:	f106 01ac 	add.w	r1, r6, #172	@ 0xac
 c0561fc:	f105 00ac 	add.w	r0, r5, #172	@ 0xac
 c056200:	f7f6 fbbd 	bl	c04c97e <mbedtls_ecp_copy>
        ( ret = mbedtls_mpi_copy( &ctx->d, &key->d ) ) != 0 ||
 c056204:	4604      	mov	r4, r0
 c056206:	b110      	cbz	r0, c05620e <mbedtls_ecdsa_from_keypair+0x34>
        mbedtls_ecdsa_free( ctx );
 c056208:	4628      	mov	r0, r5
 c05620a:	f7ff ffe2 	bl	c0561d2 <mbedtls_ecdsa_free>
}
 c05620e:	4620      	mov	r0, r4
 c056210:	bd70      	pop	{r4, r5, r6, pc}

0c056212 <entropy_update>:
/*
 * Entropy accumulator update
 */
static int entropy_update( mbedtls_entropy_context *ctx, unsigned char source_id,
                           const unsigned char *data, size_t len )
{
 c056212:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    unsigned char tmp[MBEDTLS_ENTROPY_BLOCK_SIZE];
    size_t use_len = len;
    const unsigned char *p = data;
    int ret = 0;

    if( use_len > MBEDTLS_ENTROPY_BLOCK_SIZE )
 c056216:	2b40      	cmp	r3, #64	@ 0x40
{
 c056218:	4680      	mov	r8, r0
 c05621a:	460e      	mov	r6, r1
 c05621c:	4617      	mov	r7, r2
 c05621e:	461d      	mov	r5, r3
 c056220:	b092      	sub	sp, #72	@ 0x48
    if( use_len > MBEDTLS_ENTROPY_BLOCK_SIZE )
 c056222:	d909      	bls.n	c056238 <entropy_update+0x26>
    {
#if defined(MBEDTLS_ENTROPY_SHA512_ACCUMULATOR)
        if( ( ret = mbedtls_sha512_ret( data, len, tmp, 0 ) ) != 0 )
 c056224:	2300      	movs	r3, #0
 c056226:	4629      	mov	r1, r5
 c056228:	4638      	mov	r0, r7
 c05622a:	aa02      	add	r2, sp, #8
 c05622c:	f002 ff14 	bl	c059058 <mbedtls_sha512_ret>
 c056230:	4604      	mov	r4, r0
 c056232:	bb00      	cbnz	r0, c056276 <entropy_update+0x64>
#else
        if( ( ret = mbedtls_sha256_ret( data, len, tmp, 0 ) ) != 0 )
            goto cleanup;
#endif
        p = tmp;
        use_len = MBEDTLS_ENTROPY_BLOCK_SIZE;
 c056234:	2540      	movs	r5, #64	@ 0x40
        p = tmp;
 c056236:	af02      	add	r7, sp, #8
    }

    header[0] = source_id;
 c056238:	f88d 6004 	strb.w	r6, [sp, #4]
     * it is sufficient to start the accumulator here only because all calls to
     * gather entropy eventually execute this code.
     */
#if defined(MBEDTLS_ENTROPY_SHA512_ACCUMULATOR)
    if( ctx->accumulator_started == 0 &&
        ( ret = mbedtls_sha512_starts_ret( &ctx->accumulator, 0 ) ) != 0 )
 c05623c:	4646      	mov	r6, r8
    if( ctx->accumulator_started == 0 &&
 c05623e:	f856 1b08 	ldr.w	r1, [r6], #8
    header[1] = use_len & 0xFF;
 c056242:	f88d 5005 	strb.w	r5, [sp, #5]
    if( ctx->accumulator_started == 0 &&
 c056246:	b181      	cbz	r1, c05626a <entropy_update+0x58>
        goto cleanup;
    else
        ctx->accumulator_started = 1;
 c056248:	2301      	movs	r3, #1
    if( ( ret = mbedtls_sha512_update_ret( &ctx->accumulator, header, 2 ) ) != 0 )
 c05624a:	2202      	movs	r2, #2
 c05624c:	4630      	mov	r0, r6
        ctx->accumulator_started = 1;
 c05624e:	f8c8 3000 	str.w	r3, [r8]
    if( ( ret = mbedtls_sha512_update_ret( &ctx->accumulator, header, 2 ) ) != 0 )
 c056252:	a901      	add	r1, sp, #4
 c056254:	f002 fd9e 	bl	c058d94 <mbedtls_sha512_update_ret>
 c056258:	4604      	mov	r4, r0
 c05625a:	b960      	cbnz	r0, c056276 <entropy_update+0x64>
        goto cleanup;
    ret = mbedtls_sha512_update_ret( &ctx->accumulator, p, use_len );
 c05625c:	462a      	mov	r2, r5
 c05625e:	4639      	mov	r1, r7
 c056260:	4630      	mov	r0, r6
 c056262:	f002 fd97 	bl	c058d94 <mbedtls_sha512_update_ret>
 c056266:	4604      	mov	r4, r0
 c056268:	e005      	b.n	c056276 <entropy_update+0x64>
        ( ret = mbedtls_sha512_starts_ret( &ctx->accumulator, 0 ) ) != 0 )
 c05626a:	4630      	mov	r0, r6
 c05626c:	f002 f81c 	bl	c0582a8 <mbedtls_sha512_starts_ret>
    if( ctx->accumulator_started == 0 &&
 c056270:	4604      	mov	r4, r0
 c056272:	2800      	cmp	r0, #0
 c056274:	d0e8      	beq.n	c056248 <entropy_update+0x36>
        goto cleanup;
    ret = mbedtls_sha256_update_ret( &ctx->accumulator, p, use_len );
#endif

cleanup:
    mbedtls_platform_zeroize( tmp, sizeof( tmp ) );
 c056276:	a802      	add	r0, sp, #8
 c056278:	2140      	movs	r1, #64	@ 0x40
 c05627a:	f7e5 f8a9 	bl	c03b3d0 <mbedtls_platform_zeroize>

    return( ret );
}
 c05627e:	4620      	mov	r0, r4
 c056280:	b012      	add	sp, #72	@ 0x48
 c056282:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0c056286 <entropy_gather_internal.part.0>:
 */
static int entropy_gather_internal( mbedtls_entropy_context *ctx )
{
    int ret = MBEDTLS_ERR_ENTROPY_SOURCE_FAILED;
    int i;
    int have_one_strong = 0;
 c056286:	2300      	movs	r3, #0
static int entropy_gather_internal( mbedtls_entropy_context *ctx )
 c056288:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 c05628c:	4606      	mov	r6, r0
 c05628e:	4605      	mov	r5, r0
        return( MBEDTLS_ERR_ENTROPY_NO_SOURCES_DEFINED );

    /*
     * Run through our entropy sources
     */
    for( i = 0; i < ctx->source_count; i++ )
 c056290:	461f      	mov	r7, r3
    int ret = MBEDTLS_ERR_ENTROPY_SOURCE_FAILED;
 c056292:	f06f 043b 	mvn.w	r4, #59	@ 0x3b
    {
        if( ctx->source[i].strong == MBEDTLS_ENTROPY_SOURCE_STRONG )
            have_one_strong = 1;

        olen = 0;
 c056296:	4699      	mov	r9, r3
static int entropy_gather_internal( mbedtls_entropy_context *ctx )
 c056298:	b0a3      	sub	sp, #140	@ 0x8c
    for( i = 0; i < ctx->source_count; i++ )
 c05629a:	f8d6 20e0 	ldr.w	r2, [r6, #224]	@ 0xe0
 c05629e:	4297      	cmp	r7, r2
 c0562a0:	db0b      	blt.n	c0562ba <entropy_gather_internal.part.0+0x34>
            ctx->source[i].size += olen;
        }
    }

    if( have_one_strong == 0 )
        ret = MBEDTLS_ERR_ENTROPY_NO_STRONG_SOURCE;
 c0562a2:	2b00      	cmp	r3, #0
 c0562a4:	bf08      	it	eq
 c0562a6:	f06f 043c 	mvneq.w	r4, #60	@ 0x3c

cleanup:
    mbedtls_platform_zeroize( buf, sizeof( buf ) );
 c0562aa:	a802      	add	r0, sp, #8
 c0562ac:	2180      	movs	r1, #128	@ 0x80
 c0562ae:	f7e5 f88f 	bl	c03b3d0 <mbedtls_platform_zeroize>

    return( ret );
 c0562b2:	4620      	mov	r0, r4
}
 c0562b4:	b023      	add	sp, #140	@ 0x8c
 c0562b6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        if( ctx->source[i].strong == MBEDTLS_ENTROPY_SOURCE_STRONG )
 c0562ba:	f8d5 80f4 	ldr.w	r8, [r5, #244]	@ 0xf4
        if( ( ret = ctx->source[i].f_source( ctx->source[i].p_source,
 c0562be:	f8d5 40e4 	ldr.w	r4, [r5, #228]	@ 0xe4
        if( ctx->source[i].strong == MBEDTLS_ENTROPY_SOURCE_STRONG )
 c0562c2:	f1b8 0f01 	cmp.w	r8, #1
 c0562c6:	bf18      	it	ne
 c0562c8:	4698      	movne	r8, r3
        if( ( ret = ctx->source[i].f_source( ctx->source[i].p_source,
 c0562ca:	2280      	movs	r2, #128	@ 0x80
 c0562cc:	f8d5 00e8 	ldr.w	r0, [r5, #232]	@ 0xe8
        olen = 0;
 c0562d0:	f8cd 9004 	str.w	r9, [sp, #4]
        if( ( ret = ctx->source[i].f_source( ctx->source[i].p_source,
 c0562d4:	ab01      	add	r3, sp, #4
 c0562d6:	a902      	add	r1, sp, #8
 c0562d8:	47a0      	blx	r4
 c0562da:	4604      	mov	r4, r0
 c0562dc:	2800      	cmp	r0, #0
 c0562de:	d1e4      	bne.n	c0562aa <entropy_gather_internal.part.0+0x24>
        if( olen > 0 )
 c0562e0:	9b01      	ldr	r3, [sp, #4]
 c0562e2:	b163      	cbz	r3, c0562fe <entropy_gather_internal.part.0+0x78>
            if( ( ret = entropy_update( ctx, (unsigned char) i,
 c0562e4:	4630      	mov	r0, r6
 c0562e6:	aa02      	add	r2, sp, #8
 c0562e8:	b2f9      	uxtb	r1, r7
 c0562ea:	f7ff ff92 	bl	c056212 <entropy_update>
 c0562ee:	2800      	cmp	r0, #0
 c0562f0:	d1e0      	bne.n	c0562b4 <entropy_gather_internal.part.0+0x2e>
            ctx->source[i].size += olen;
 c0562f2:	f8d5 30ec 	ldr.w	r3, [r5, #236]	@ 0xec
 c0562f6:	9a01      	ldr	r2, [sp, #4]
 c0562f8:	4413      	add	r3, r2
 c0562fa:	f8c5 30ec 	str.w	r3, [r5, #236]	@ 0xec
    for( i = 0; i < ctx->source_count; i++ )
 c0562fe:	4643      	mov	r3, r8
 c056300:	3701      	adds	r7, #1
 c056302:	3514      	adds	r5, #20
 c056304:	e7c9      	b.n	c05629a <entropy_gather_internal.part.0+0x14>

0c056306 <mbedtls_entropy_free>:
    if( ctx->accumulator_started == -1 )
 c056306:	6803      	ldr	r3, [r0, #0]
{
 c056308:	b510      	push	{r4, lr}
    if( ctx->accumulator_started == -1 )
 c05630a:	3301      	adds	r3, #1
{
 c05630c:	4604      	mov	r4, r0
    if( ctx->accumulator_started == -1 )
 c05630e:	d00e      	beq.n	c05632e <mbedtls_entropy_free+0x28>
    mbedtls_sha512_free( &ctx->accumulator );
 c056310:	3008      	adds	r0, #8
 c056312:	f001 ffbc 	bl	c05828e <mbedtls_sha512_free>
    ctx->source_count = 0;
 c056316:	2300      	movs	r3, #0
    mbedtls_platform_zeroize( ctx->source, sizeof( ctx->source ) );
 c056318:	f44f 71c8 	mov.w	r1, #400	@ 0x190
    ctx->source_count = 0;
 c05631c:	f8c4 30e0 	str.w	r3, [r4, #224]	@ 0xe0
    mbedtls_platform_zeroize( ctx->source, sizeof( ctx->source ) );
 c056320:	f104 00e4 	add.w	r0, r4, #228	@ 0xe4
 c056324:	f7e5 f854 	bl	c03b3d0 <mbedtls_platform_zeroize>
    ctx->accumulator_started = -1;
 c056328:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 c05632c:	6023      	str	r3, [r4, #0]
}
 c05632e:	bd10      	pop	{r4, pc}

0c056330 <mbedtls_entropy_add_source>:
{
 c056330:	b530      	push	{r4, r5, lr}
    idx = ctx->source_count;
 c056332:	f8d0 50e0 	ldr.w	r5, [r0, #224]	@ 0xe0
    if( idx >= MBEDTLS_ENTROPY_MAX_SOURCES )
 c056336:	2d13      	cmp	r5, #19
 c056338:	dc0e      	bgt.n	c056358 <mbedtls_entropy_add_source+0x28>
    ctx->source[idx].f_source  = f_source;
 c05633a:	2414      	movs	r4, #20
 c05633c:	fb04 0405 	mla	r4, r4, r5, r0
    ctx->source[idx].threshold = threshold;
 c056340:	f8c4 30f0 	str.w	r3, [r4, #240]	@ 0xf0
    ctx->source[idx].strong    = strong;
 c056344:	9b03      	ldr	r3, [sp, #12]
    ctx->source_count++;
 c056346:	3501      	adds	r5, #1
    ctx->source[idx].p_source  = p_source;
 c056348:	e9c4 1239 	strd	r1, r2, [r4, #228]	@ 0xe4
    ctx->source[idx].strong    = strong;
 c05634c:	f8c4 30f4 	str.w	r3, [r4, #244]	@ 0xf4
    ctx->source_count++;
 c056350:	f8c0 50e0 	str.w	r5, [r0, #224]	@ 0xe0
    int idx, ret = 0;
 c056354:	2000      	movs	r0, #0
}
 c056356:	bd30      	pop	{r4, r5, pc}
        ret = MBEDTLS_ERR_ENTROPY_MAX_SOURCES;
 c056358:	f06f 003d 	mvn.w	r0, #61	@ 0x3d
    return( ret );
 c05635c:	e7fb      	b.n	c056356 <mbedtls_entropy_add_source+0x26>
	...

0c056360 <mbedtls_entropy_init>:
{
 c056360:	b537      	push	{r0, r1, r2, r4, r5, lr}
    ctx->source_count = 0;
 c056362:	2500      	movs	r5, #0
{
 c056364:	4604      	mov	r4, r0
    memset( ctx->source, 0, sizeof( ctx->source ) );
 c056366:	4629      	mov	r1, r5
 c056368:	f44f 72c8 	mov.w	r2, #400	@ 0x190
    ctx->source_count = 0;
 c05636c:	f8c0 50e0 	str.w	r5, [r0, #224]	@ 0xe0
    memset( ctx->source, 0, sizeof( ctx->source ) );
 c056370:	30e4      	adds	r0, #228	@ 0xe4
 c056372:	f005 f9dc 	bl	c05b72e <memset>
    ctx->accumulator_started = 0;
 c056376:	4620      	mov	r0, r4
 c056378:	f840 5b08 	str.w	r5, [r0], #8
    mbedtls_sha512_init( &ctx->accumulator );
 c05637c:	f001 ff83 	bl	c058286 <mbedtls_sha512_init>
    mbedtls_entropy_add_source( ctx, mbedtls_hardware_poll, NULL,
 c056380:	2301      	movs	r3, #1
 c056382:	462a      	mov	r2, r5
 c056384:	9300      	str	r3, [sp, #0]
 c056386:	4620      	mov	r0, r4
 c056388:	2320      	movs	r3, #32
 c05638a:	4902      	ldr	r1, [pc, #8]	@ (c056394 <mbedtls_entropy_init+0x34>)
 c05638c:	f7ff ffd0 	bl	c056330 <mbedtls_entropy_add_source>
}
 c056390:	b003      	add	sp, #12
 c056392:	bd30      	pop	{r4, r5, pc}
 c056394:	0c04ea65 	.word	0x0c04ea65

0c056398 <mbedtls_entropy_func>:

    return( ret );
}

int mbedtls_entropy_func( void *data, unsigned char *output, size_t len )
{
 c056398:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    int ret, count = 0, i, thresholds_reached;
    size_t strong_size;
    mbedtls_entropy_context *ctx = (mbedtls_entropy_context *) data;
    unsigned char buf[MBEDTLS_ENTROPY_BLOCK_SIZE];

    if( len > MBEDTLS_ENTROPY_BLOCK_SIZE )
 c05639c:	2a40      	cmp	r2, #64	@ 0x40
{
 c05639e:	4680      	mov	r8, r0
 c0563a0:	460f      	mov	r7, r1
 c0563a2:	4616      	mov	r6, r2
 c0563a4:	b090      	sub	sp, #64	@ 0x40
    if( len > MBEDTLS_ENTROPY_BLOCK_SIZE )
 c0563a6:	d86f      	bhi.n	c056488 <mbedtls_entropy_func+0xf0>
 c0563a8:	f240 1501 	movw	r5, #257	@ 0x101
    if( ctx->source_count == 0 )
 c0563ac:	f8d8 30e0 	ldr.w	r3, [r8, #224]	@ 0xe0
 c0563b0:	2b00      	cmp	r3, #0
 c0563b2:	d066      	beq.n	c056482 <mbedtls_entropy_func+0xea>
 c0563b4:	4640      	mov	r0, r8
 c0563b6:	f7ff ff66 	bl	c056286 <entropy_gather_internal.part.0>
        {
            ret = MBEDTLS_ERR_ENTROPY_SOURCE_FAILED;
            goto exit;
        }

        if( ( ret = entropy_gather_internal( ctx ) ) != 0 )
 c0563ba:	4604      	mov	r4, r0
 c0563bc:	2800      	cmp	r0, #0
 c0563be:	d140      	bne.n	c056442 <mbedtls_entropy_func+0xaa>
            goto exit;

        thresholds_reached = 1;
        strong_size = 0;
 c0563c0:	4602      	mov	r2, r0
 c0563c2:	4643      	mov	r3, r8
        thresholds_reached = 1;
 c0563c4:	2001      	movs	r0, #1
        for( i = 0; i < ctx->source_count; i++ )
 c0563c6:	f8d8 e0e0 	ldr.w	lr, [r8, #224]	@ 0xe0
 c0563ca:	45a6      	cmp	lr, r4
 c0563cc:	dc46      	bgt.n	c05645c <mbedtls_entropy_func+0xc4>
                thresholds_reached = 0;
            if( ctx->source[i].strong == MBEDTLS_ENTROPY_SOURCE_STRONG )
                strong_size += ctx->source[i].size;
        }
    }
    while( ! thresholds_reached || strong_size < MBEDTLS_ENTROPY_BLOCK_SIZE );
 c0563ce:	2800      	cmp	r0, #0
 c0563d0:	d03f      	beq.n	c056452 <mbedtls_entropy_func+0xba>
 c0563d2:	2a3f      	cmp	r2, #63	@ 0x3f
 c0563d4:	d93d      	bls.n	c056452 <mbedtls_entropy_func+0xba>

    memset( buf, 0, MBEDTLS_ENTROPY_BLOCK_SIZE );
 c0563d6:	2240      	movs	r2, #64	@ 0x40
 c0563d8:	2100      	movs	r1, #0
 c0563da:	4668      	mov	r0, sp
    /*
     * Note that at this stage it is assumed that the accumulator was started
     * in a previous call to entropy_update(). If this is not guaranteed, the
     * code below will fail.
     */
    if( ( ret = mbedtls_sha512_finish_ret( &ctx->accumulator, buf ) ) != 0 )
 c0563dc:	f108 0508 	add.w	r5, r8, #8
    memset( buf, 0, MBEDTLS_ENTROPY_BLOCK_SIZE );
 c0563e0:	f005 f9a5 	bl	c05b72e <memset>
    if( ( ret = mbedtls_sha512_finish_ret( &ctx->accumulator, buf ) ) != 0 )
 c0563e4:	4669      	mov	r1, sp
 c0563e6:	4628      	mov	r0, r5
 c0563e8:	f002 fd1a 	bl	c058e20 <mbedtls_sha512_finish_ret>
 c0563ec:	4604      	mov	r4, r0
 c0563ee:	bb40      	cbnz	r0, c056442 <mbedtls_entropy_func+0xaa>
        goto exit;

    /*
     * Reset accumulator and counters and recycle existing entropy
     */
    mbedtls_sha512_free( &ctx->accumulator );
 c0563f0:	4628      	mov	r0, r5
 c0563f2:	f001 ff4c 	bl	c05828e <mbedtls_sha512_free>
    mbedtls_sha512_init( &ctx->accumulator );
 c0563f6:	4628      	mov	r0, r5
 c0563f8:	f001 ff45 	bl	c058286 <mbedtls_sha512_init>
    if( ( ret = mbedtls_sha512_starts_ret( &ctx->accumulator, 0 ) ) != 0 )
 c0563fc:	4621      	mov	r1, r4
 c0563fe:	4628      	mov	r0, r5
 c056400:	f001 ff52 	bl	c0582a8 <mbedtls_sha512_starts_ret>
 c056404:	4604      	mov	r4, r0
 c056406:	b9e0      	cbnz	r0, c056442 <mbedtls_entropy_func+0xaa>
        goto exit;
    if( ( ret = mbedtls_sha512_update_ret( &ctx->accumulator, buf,
 c056408:	2240      	movs	r2, #64	@ 0x40
 c05640a:	4669      	mov	r1, sp
 c05640c:	4628      	mov	r0, r5
 c05640e:	f002 fcc1 	bl	c058d94 <mbedtls_sha512_update_ret>
 c056412:	4604      	mov	r4, r0
 c056414:	b9a8      	cbnz	r0, c056442 <mbedtls_entropy_func+0xaa>
        goto exit;

    /*
     * Perform second SHA-512 on entropy
     */
    if( ( ret = mbedtls_sha512_ret( buf, MBEDTLS_ENTROPY_BLOCK_SIZE,
 c056416:	4603      	mov	r3, r0
 c056418:	466a      	mov	r2, sp
 c05641a:	2140      	movs	r1, #64	@ 0x40
 c05641c:	4668      	mov	r0, sp
 c05641e:	f002 fe1b 	bl	c059058 <mbedtls_sha512_ret>
 c056422:	4604      	mov	r4, r0
 c056424:	b968      	cbnz	r0, c056442 <mbedtls_entropy_func+0xaa>
                                    buf, 0 ) ) != 0 )
        goto exit;
#endif /* MBEDTLS_ENTROPY_SHA512_ACCUMULATOR */

    for( i = 0; i < ctx->source_count; i++ )
        ctx->source[i].size = 0;
 c056426:	2114      	movs	r1, #20
 c056428:	4625      	mov	r5, r4
    for( i = 0; i < ctx->source_count; i++ )
 c05642a:	f8d8 20e0 	ldr.w	r2, [r8, #224]	@ 0xe0
 c05642e:	4603      	mov	r3, r0
        ctx->source[i].size = 0;
 c056430:	f108 00ec 	add.w	r0, r8, #236	@ 0xec
    for( i = 0; i < ctx->source_count; i++ )
 c056434:	429a      	cmp	r2, r3
 c056436:	dc1e      	bgt.n	c056476 <mbedtls_entropy_func+0xde>

    memcpy( output, buf, len );
 c056438:	4632      	mov	r2, r6
 c05643a:	4669      	mov	r1, sp
 c05643c:	4638      	mov	r0, r7
 c05643e:	f005 f905 	bl	c05b64c <memcpy>

    ret = 0;

exit:
    mbedtls_platform_zeroize( buf, sizeof( buf ) );
 c056442:	2140      	movs	r1, #64	@ 0x40
 c056444:	4668      	mov	r0, sp
 c056446:	f7e4 ffc3 	bl	c03b3d0 <mbedtls_platform_zeroize>
    if( mbedtls_mutex_unlock( &ctx->mutex ) != 0 )
        return( MBEDTLS_ERR_THREADING_MUTEX_ERROR );
#endif

    return( ret );
}
 c05644a:	4620      	mov	r0, r4
 c05644c:	b010      	add	sp, #64	@ 0x40
 c05644e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        if( count++ > ENTROPY_MAX_LOOP )
 c056452:	3d01      	subs	r5, #1
 c056454:	d1aa      	bne.n	c0563ac <mbedtls_entropy_func+0x14>
            ret = MBEDTLS_ERR_ENTROPY_SOURCE_FAILED;
 c056456:	f06f 043b 	mvn.w	r4, #59	@ 0x3b
 c05645a:	e7f2      	b.n	c056442 <mbedtls_entropy_func+0xaa>
                thresholds_reached = 0;
 c05645c:	e9d3 c13b 	ldrd	ip, r1, [r3, #236]	@ 0xec
 c056460:	458c      	cmp	ip, r1
 c056462:	bf38      	it	cc
 c056464:	2000      	movcc	r0, #0
            if( ctx->source[i].strong == MBEDTLS_ENTROPY_SOURCE_STRONG )
 c056466:	f8d3 10f4 	ldr.w	r1, [r3, #244]	@ 0xf4
        for( i = 0; i < ctx->source_count; i++ )
 c05646a:	3401      	adds	r4, #1
            if( ctx->source[i].strong == MBEDTLS_ENTROPY_SOURCE_STRONG )
 c05646c:	2901      	cmp	r1, #1
                strong_size += ctx->source[i].size;
 c05646e:	bf08      	it	eq
 c056470:	4462      	addeq	r2, ip
        for( i = 0; i < ctx->source_count; i++ )
 c056472:	3314      	adds	r3, #20
 c056474:	e7a9      	b.n	c0563ca <mbedtls_entropy_func+0x32>
        ctx->source[i].size = 0;
 c056476:	fb01 fc03 	mul.w	ip, r1, r3
    for( i = 0; i < ctx->source_count; i++ )
 c05647a:	3301      	adds	r3, #1
        ctx->source[i].size = 0;
 c05647c:	f840 500c 	str.w	r5, [r0, ip]
    for( i = 0; i < ctx->source_count; i++ )
 c056480:	e7d8      	b.n	c056434 <mbedtls_entropy_func+0x9c>
        return( MBEDTLS_ERR_ENTROPY_NO_SOURCES_DEFINED );
 c056482:	f06f 043f 	mvn.w	r4, #63	@ 0x3f
 c056486:	e7dc      	b.n	c056442 <mbedtls_entropy_func+0xaa>
        return( MBEDTLS_ERR_ENTROPY_SOURCE_FAILED );
 c056488:	f06f 043b 	mvn.w	r4, #59	@ 0x3b
 c05648c:	e7dd      	b.n	c05644a <mbedtls_entropy_func+0xb2>

0c05648e <mbedtls_hmac_drbg_init>:

/*
 * HMAC_DRBG context initialization
 */
void mbedtls_hmac_drbg_init( mbedtls_hmac_drbg_context *ctx )
{
 c05648e:	b510      	push	{r4, lr}
    memset( ctx, 0, sizeof( mbedtls_hmac_drbg_context ) );
 c056490:	2264      	movs	r2, #100	@ 0x64
 c056492:	2100      	movs	r1, #0
{
 c056494:	4604      	mov	r4, r0
    memset( ctx, 0, sizeof( mbedtls_hmac_drbg_context ) );
 c056496:	f005 f94a 	bl	c05b72e <memset>

    ctx->reseed_interval = MBEDTLS_HMAC_DRBG_RESEED_INTERVAL;
 c05649a:	f242 7310 	movw	r3, #10000	@ 0x2710
 c05649e:	65a3      	str	r3, [r4, #88]	@ 0x58
}
 c0564a0:	bd10      	pop	{r4, pc}
	...

0c0564a4 <mbedtls_hmac_drbg_update_ret>:
 * HMAC_DRBG update, using optional additional data (10.1.2.2)
 */
int mbedtls_hmac_drbg_update_ret( mbedtls_hmac_drbg_context *ctx,
                                  const unsigned char *additional,
                                  size_t add_len )
{
 c0564a4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 c0564a8:	4605      	mov	r5, r0
 c0564aa:	b092      	sub	sp, #72	@ 0x48
    size_t md_len = mbedtls_md_get_size( ctx->md_ctx.md_info );
 c0564ac:	6800      	ldr	r0, [r0, #0]
{
 c0564ae:	460f      	mov	r7, r1
 c0564b0:	4690      	mov	r8, r2
    size_t md_len = mbedtls_md_get_size( ctx->md_ctx.md_info );
 c0564b2:	f000 fad9 	bl	c056a68 <mbedtls_md_get_size>
 c0564b6:	4606      	mov	r6, r0
    unsigned char rounds = ( additional != NULL && add_len != 0 ) ? 2 : 1;
 c0564b8:	b397      	cbz	r7, c056520 <mbedtls_hmac_drbg_update_ret+0x7c>
 c0564ba:	f1b8 0f00 	cmp.w	r8, #0
 c0564be:	bf0c      	ite	eq
 c0564c0:	f04f 0901 	moveq.w	r9, #1
 c0564c4:	f04f 0902 	movne.w	r9, #2
    unsigned char sep[1];
    unsigned char K[MBEDTLS_MD_MAX_SIZE];
    int ret = MBEDTLS_ERR_MD_BAD_INPUT_DATA;

    for( sep[0] = 0; sep[0] < rounds; sep[0]++ )
 c0564c8:	2300      	movs	r3, #0
    int ret = MBEDTLS_ERR_MD_BAD_INPUT_DATA;
 c0564ca:	4c29      	ldr	r4, [pc, #164]	@ (c056570 <mbedtls_hmac_drbg_update_ret+0xcc>)
    {
        /* Step 1 or 4 */
        if( ( ret = mbedtls_md_hmac_reset( &ctx->md_ctx ) ) != 0 )
            goto exit;
        if( ( ret = mbedtls_md_hmac_update( &ctx->md_ctx,
                                            ctx->V, md_len ) ) != 0 )
 c0564cc:	f105 0a0c 	add.w	sl, r5, #12
    for( sep[0] = 0; sep[0] < rounds; sep[0]++ )
 c0564d0:	4599      	cmp	r9, r3
 c0564d2:	f88d 3004 	strb.w	r3, [sp, #4]
 c0564d6:	d91b      	bls.n	c056510 <mbedtls_hmac_drbg_update_ret+0x6c>
        if( ( ret = mbedtls_md_hmac_reset( &ctx->md_ctx ) ) != 0 )
 c0564d8:	4628      	mov	r0, r5
 c0564da:	f000 faaf 	bl	c056a3c <mbedtls_md_hmac_reset>
 c0564de:	4604      	mov	r4, r0
 c0564e0:	b9b0      	cbnz	r0, c056510 <mbedtls_hmac_drbg_update_ret+0x6c>
        if( ( ret = mbedtls_md_hmac_update( &ctx->md_ctx,
 c0564e2:	4632      	mov	r2, r6
 c0564e4:	4651      	mov	r1, sl
 c0564e6:	4628      	mov	r0, r5
 c0564e8:	f000 fa70 	bl	c0569cc <mbedtls_md_hmac_update>
 c0564ec:	4604      	mov	r4, r0
 c0564ee:	b978      	cbnz	r0, c056510 <mbedtls_hmac_drbg_update_ret+0x6c>
            goto exit;
        if( ( ret = mbedtls_md_hmac_update( &ctx->md_ctx,
 c0564f0:	2201      	movs	r2, #1
 c0564f2:	4628      	mov	r0, r5
 c0564f4:	a901      	add	r1, sp, #4
 c0564f6:	f000 fa69 	bl	c0569cc <mbedtls_md_hmac_update>
 c0564fa:	4604      	mov	r4, r0
 c0564fc:	b940      	cbnz	r0, c056510 <mbedtls_hmac_drbg_update_ret+0x6c>
                                            sep, 1 ) ) != 0 )
            goto exit;
        if( rounds == 2 )
 c0564fe:	f1b9 0f02 	cmp.w	r9, #2
 c056502:	d010      	beq.n	c056526 <mbedtls_hmac_drbg_update_ret+0x82>
        {
            if( ( ret = mbedtls_md_hmac_update( &ctx->md_ctx,
                                                additional, add_len ) ) != 0 )
            goto exit;
        }
        if( ( ret = mbedtls_md_hmac_finish( &ctx->md_ctx, K ) ) != 0 )
 c056504:	4628      	mov	r0, r5
 c056506:	a902      	add	r1, sp, #8
 c056508:	f000 fa6e 	bl	c0569e8 <mbedtls_md_hmac_finish>
 c05650c:	4604      	mov	r4, r0
 c05650e:	b198      	cbz	r0, c056538 <mbedtls_hmac_drbg_update_ret+0x94>
        if( ( ret = mbedtls_md_hmac_finish( &ctx->md_ctx, ctx->V ) ) != 0 )
            goto exit;
    }

exit:
    mbedtls_platform_zeroize( K, sizeof( K ) );
 c056510:	a802      	add	r0, sp, #8
 c056512:	2140      	movs	r1, #64	@ 0x40
 c056514:	f7e4 ff5c 	bl	c03b3d0 <mbedtls_platform_zeroize>
    return( ret );
}
 c056518:	4620      	mov	r0, r4
 c05651a:	b012      	add	sp, #72	@ 0x48
 c05651c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    unsigned char rounds = ( additional != NULL && add_len != 0 ) ? 2 : 1;
 c056520:	f04f 0901 	mov.w	r9, #1
 c056524:	e7d0      	b.n	c0564c8 <mbedtls_hmac_drbg_update_ret+0x24>
            if( ( ret = mbedtls_md_hmac_update( &ctx->md_ctx,
 c056526:	4642      	mov	r2, r8
 c056528:	4639      	mov	r1, r7
 c05652a:	4628      	mov	r0, r5
 c05652c:	f000 fa4e 	bl	c0569cc <mbedtls_md_hmac_update>
 c056530:	4604      	mov	r4, r0
 c056532:	2800      	cmp	r0, #0
 c056534:	d0e6      	beq.n	c056504 <mbedtls_hmac_drbg_update_ret+0x60>
 c056536:	e7eb      	b.n	c056510 <mbedtls_hmac_drbg_update_ret+0x6c>
        if( ( ret = mbedtls_md_hmac_starts( &ctx->md_ctx, K, md_len ) ) != 0 )
 c056538:	4632      	mov	r2, r6
 c05653a:	4628      	mov	r0, r5
 c05653c:	a902      	add	r1, sp, #8
 c05653e:	f000 f9e5 	bl	c05690c <mbedtls_md_hmac_starts>
 c056542:	4604      	mov	r4, r0
 c056544:	2800      	cmp	r0, #0
 c056546:	d1e3      	bne.n	c056510 <mbedtls_hmac_drbg_update_ret+0x6c>
        if( ( ret = mbedtls_md_hmac_update( &ctx->md_ctx,
 c056548:	4632      	mov	r2, r6
 c05654a:	4651      	mov	r1, sl
 c05654c:	4628      	mov	r0, r5
 c05654e:	f000 fa3d 	bl	c0569cc <mbedtls_md_hmac_update>
 c056552:	4604      	mov	r4, r0
 c056554:	2800      	cmp	r0, #0
 c056556:	d1db      	bne.n	c056510 <mbedtls_hmac_drbg_update_ret+0x6c>
        if( ( ret = mbedtls_md_hmac_finish( &ctx->md_ctx, ctx->V ) ) != 0 )
 c056558:	4651      	mov	r1, sl
 c05655a:	4628      	mov	r0, r5
 c05655c:	f000 fa44 	bl	c0569e8 <mbedtls_md_hmac_finish>
 c056560:	4604      	mov	r4, r0
 c056562:	2800      	cmp	r0, #0
 c056564:	d1d4      	bne.n	c056510 <mbedtls_hmac_drbg_update_ret+0x6c>
    for( sep[0] = 0; sep[0] < rounds; sep[0]++ )
 c056566:	f89d 3004 	ldrb.w	r3, [sp, #4]
 c05656a:	3301      	adds	r3, #1
 c05656c:	b2db      	uxtb	r3, r3
 c05656e:	e7af      	b.n	c0564d0 <mbedtls_hmac_drbg_update_ret+0x2c>
 c056570:	ffffaf00 	.word	0xffffaf00

0c056574 <hmac_drbg_reseed_core>:
 * of SP800-90A, while roman numbers refer to section 9.2.
 */
static int hmac_drbg_reseed_core( mbedtls_hmac_drbg_context *ctx,
                                  const unsigned char *additional, size_t len,
                                  int use_nonce )
{
 c056574:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 c056578:	4604      	mov	r4, r0
 c05657a:	460f      	mov	r7, r1
 c05657c:	4616      	mov	r6, r2
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;

    {
        size_t total_entropy_len;

        if( use_nonce == 0 )
 c05657e:	4698      	mov	r8, r3
            total_entropy_len = ctx->entropy_len;
 c056580:	6d05      	ldr	r5, [r0, #80]	@ 0x50
{
 c056582:	b0e0      	sub	sp, #384	@ 0x180
        if( use_nonce == 0 )
 c056584:	b1db      	cbz	r3, c0565be <hmac_drbg_reseed_core+0x4a>
        else
            total_entropy_len = ctx->entropy_len * 3 / 2;
 c056586:	eb05 0245 	add.w	r2, r5, r5, lsl #1
 c05658a:	0852      	lsrs	r2, r2, #1

        /* III. Check input length */
        if( len > MBEDTLS_HMAC_DRBG_MAX_INPUT ||
 c05658c:	f5b6 7f80 	cmp.w	r6, #256	@ 0x100
 c056590:	d83d      	bhi.n	c05660e <hmac_drbg_reseed_core+0x9a>
            total_entropy_len + len > MBEDTLS_HMAC_DRBG_MAX_SEED_INPUT )
 c056592:	4432      	add	r2, r6
        if( len > MBEDTLS_HMAC_DRBG_MAX_INPUT ||
 c056594:	f5b2 7fc0 	cmp.w	r2, #384	@ 0x180
 c056598:	d839      	bhi.n	c05660e <hmac_drbg_reseed_core+0x9a>
        {
            return( MBEDTLS_ERR_HMAC_DRBG_INPUT_TOO_BIG );
        }
    }

    memset( seed, 0, MBEDTLS_HMAC_DRBG_MAX_SEED_INPUT );
 c05659a:	f44f 72c0 	mov.w	r2, #384	@ 0x180
 c05659e:	2100      	movs	r1, #0
 c0565a0:	4668      	mov	r0, sp
 c0565a2:	f005 f8c4 	bl	c05b72e <memset>

    /* IV. Gather entropy_len bytes of entropy for the seed */
    if( ( ret = ctx->f_entropy( ctx->p_entropy,
 c0565a6:	462a      	mov	r2, r5
 c0565a8:	4669      	mov	r1, sp
 c0565aa:	6de3      	ldr	r3, [r4, #92]	@ 0x5c
 c0565ac:	6e20      	ldr	r0, [r4, #96]	@ 0x60
 c0565ae:	4798      	blx	r3
 c0565b0:	b138      	cbz	r0, c0565c2 <hmac_drbg_reseed_core+0x4e>
                                seed, ctx->entropy_len ) ) != 0 )
    {
        return( MBEDTLS_ERR_HMAC_DRBG_ENTROPY_SOURCE_FAILED );
 c0565b2:	f06f 0608 	mvn.w	r6, #8

exit:
    /* 4. Done */
    mbedtls_platform_zeroize( seed, seedlen );
    return( ret );
}
 c0565b6:	4630      	mov	r0, r6
 c0565b8:	b060      	add	sp, #384	@ 0x180
 c0565ba:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
            total_entropy_len = ctx->entropy_len;
 c0565be:	462a      	mov	r2, r5
 c0565c0:	e7e4      	b.n	c05658c <hmac_drbg_reseed_core+0x18>
    seedlen += ctx->entropy_len;
 c0565c2:	6d25      	ldr	r5, [r4, #80]	@ 0x50
    if( use_nonce )
 c0565c4:	f1b8 0f00 	cmp.w	r8, #0
 c0565c8:	d00a      	beq.n	c0565e0 <hmac_drbg_reseed_core+0x6c>
        if( ( ret = ctx->f_entropy( ctx->p_entropy,
 c0565ca:	6de3      	ldr	r3, [r4, #92]	@ 0x5c
 c0565cc:	6e20      	ldr	r0, [r4, #96]	@ 0x60
 c0565ce:	086a      	lsrs	r2, r5, #1
 c0565d0:	eb0d 0105 	add.w	r1, sp, r5
 c0565d4:	4798      	blx	r3
 c0565d6:	2800      	cmp	r0, #0
 c0565d8:	d1eb      	bne.n	c0565b2 <hmac_drbg_reseed_core+0x3e>
        seedlen += ctx->entropy_len / 2;
 c0565da:	6d23      	ldr	r3, [r4, #80]	@ 0x50
 c0565dc:	eb05 0553 	add.w	r5, r5, r3, lsr #1
    if( additional != NULL && len != 0 )
 c0565e0:	b13f      	cbz	r7, c0565f2 <hmac_drbg_reseed_core+0x7e>
 c0565e2:	b136      	cbz	r6, c0565f2 <hmac_drbg_reseed_core+0x7e>
        memcpy( seed + seedlen, additional, len );
 c0565e4:	eb0d 0005 	add.w	r0, sp, r5
 c0565e8:	4632      	mov	r2, r6
 c0565ea:	4639      	mov	r1, r7
 c0565ec:	f005 f82e 	bl	c05b64c <memcpy>
        seedlen += len;
 c0565f0:	4435      	add	r5, r6
    if( ( ret = mbedtls_hmac_drbg_update_ret( ctx, seed, seedlen ) ) != 0 )
 c0565f2:	462a      	mov	r2, r5
 c0565f4:	4669      	mov	r1, sp
 c0565f6:	4620      	mov	r0, r4
 c0565f8:	f7ff ff54 	bl	c0564a4 <mbedtls_hmac_drbg_update_ret>
 c0565fc:	4606      	mov	r6, r0
 c0565fe:	b908      	cbnz	r0, c056604 <hmac_drbg_reseed_core+0x90>
    ctx->reseed_counter = 1;
 c056600:	2301      	movs	r3, #1
 c056602:	64e3      	str	r3, [r4, #76]	@ 0x4c
    mbedtls_platform_zeroize( seed, seedlen );
 c056604:	4629      	mov	r1, r5
 c056606:	4668      	mov	r0, sp
 c056608:	f7e4 fee2 	bl	c03b3d0 <mbedtls_platform_zeroize>
    return( ret );
 c05660c:	e7d3      	b.n	c0565b6 <hmac_drbg_reseed_core+0x42>
            return( MBEDTLS_ERR_HMAC_DRBG_INPUT_TOO_BIG );
 c05660e:	f06f 0604 	mvn.w	r6, #4
 c056612:	e7d0      	b.n	c0565b6 <hmac_drbg_reseed_core+0x42>

0c056614 <mbedtls_hmac_drbg_seed_buf>:
{
 c056614:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 c056618:	4616      	mov	r6, r2
    if( ( ret = mbedtls_md_setup( &ctx->md_ctx, md_info, 1 ) ) != 0 )
 c05661a:	2201      	movs	r2, #1
{
 c05661c:	4604      	mov	r4, r0
 c05661e:	460d      	mov	r5, r1
 c056620:	461f      	mov	r7, r3
    if( ( ret = mbedtls_md_setup( &ctx->md_ctx, md_info, 1 ) ) != 0 )
 c056622:	f000 f8cf 	bl	c0567c4 <mbedtls_md_setup>
 c056626:	b9c8      	cbnz	r0, c05665c <mbedtls_hmac_drbg_seed_buf+0x48>
                                        mbedtls_md_get_size( md_info ) ) ) != 0 )
 c056628:	4628      	mov	r0, r5
 c05662a:	f000 fa1d 	bl	c056a68 <mbedtls_md_get_size>
    if( ( ret = mbedtls_md_hmac_starts( &ctx->md_ctx, ctx->V,
 c05662e:	f104 080c 	add.w	r8, r4, #12
                                        mbedtls_md_get_size( md_info ) ) ) != 0 )
 c056632:	4602      	mov	r2, r0
    if( ( ret = mbedtls_md_hmac_starts( &ctx->md_ctx, ctx->V,
 c056634:	4641      	mov	r1, r8
 c056636:	4620      	mov	r0, r4
 c056638:	f000 f968 	bl	c05690c <mbedtls_md_hmac_starts>
 c05663c:	b970      	cbnz	r0, c05665c <mbedtls_hmac_drbg_seed_buf+0x48>
    memset( ctx->V, 0x01, mbedtls_md_get_size( md_info ) );
 c05663e:	4628      	mov	r0, r5
 c056640:	f000 fa12 	bl	c056a68 <mbedtls_md_get_size>
 c056644:	2101      	movs	r1, #1
 c056646:	4602      	mov	r2, r0
 c056648:	4640      	mov	r0, r8
 c05664a:	f005 f870 	bl	c05b72e <memset>
    if( ( ret = mbedtls_hmac_drbg_update_ret( ctx, data, data_len ) ) != 0 )
 c05664e:	463a      	mov	r2, r7
 c056650:	4631      	mov	r1, r6
 c056652:	4620      	mov	r0, r4
}
 c056654:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    if( ( ret = mbedtls_hmac_drbg_update_ret( ctx, data, data_len ) ) != 0 )
 c056658:	f7ff bf24 	b.w	c0564a4 <mbedtls_hmac_drbg_update_ret>
}
 c05665c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0c056660 <mbedtls_hmac_drbg_reseed>:
 * HMAC_DRBG reseeding: 10.1.2.4 + 9.2
 */
int mbedtls_hmac_drbg_reseed( mbedtls_hmac_drbg_context *ctx,
                      const unsigned char *additional, size_t len )
{
    return( hmac_drbg_reseed_core( ctx, additional, len, 0 ) );
 c056660:	2300      	movs	r3, #0
 c056662:	f7ff bf87 	b.w	c056574 <hmac_drbg_reseed_core>

0c056666 <mbedtls_hmac_drbg_random_with_add>:
 * 10.1.2.5 (arabic) + 9.3 (Roman)
 */
int mbedtls_hmac_drbg_random_with_add( void *p_rng,
                               unsigned char *output, size_t out_len,
                               const unsigned char *additional, size_t add_len )
{
 c056666:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c05666a:	4615      	mov	r5, r2
 c05666c:	4604      	mov	r4, r0
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    mbedtls_hmac_drbg_context *ctx = (mbedtls_hmac_drbg_context *) p_rng;
    size_t md_len = mbedtls_md_get_size( ctx->md_ctx.md_info );
 c05666e:	6800      	ldr	r0, [r0, #0]
{
 c056670:	4688      	mov	r8, r1
 c056672:	461e      	mov	r6, r3
 c056674:	9f0a      	ldr	r7, [sp, #40]	@ 0x28
    size_t md_len = mbedtls_md_get_size( ctx->md_ctx.md_info );
 c056676:	f000 f9f7 	bl	c056a68 <mbedtls_md_get_size>
    size_t left = out_len;
    unsigned char *out = output;

    /* II. Check request length */
    if( out_len > MBEDTLS_HMAC_DRBG_MAX_REQUEST )
 c05667a:	f5b5 6f80 	cmp.w	r5, #1024	@ 0x400
    size_t md_len = mbedtls_md_get_size( ctx->md_ctx.md_info );
 c05667e:	4681      	mov	r9, r0
    if( out_len > MBEDTLS_HMAC_DRBG_MAX_REQUEST )
 c056680:	d84b      	bhi.n	c05671a <mbedtls_hmac_drbg_random_with_add+0xb4>
        return( MBEDTLS_ERR_HMAC_DRBG_REQUEST_TOO_BIG );

    /* III. Check input length */
    if( add_len > MBEDTLS_HMAC_DRBG_MAX_INPUT )
 c056682:	f5b7 7f80 	cmp.w	r7, #256	@ 0x100
 c056686:	d84b      	bhi.n	c056720 <mbedtls_hmac_drbg_random_with_add+0xba>
        return( MBEDTLS_ERR_HMAC_DRBG_INPUT_TOO_BIG );

    /* 1. (aka VII and IX) Check reseed counter and PR */
    if( ctx->f_entropy != NULL && /* For no-reseeding instances */
 c056688:	6de3      	ldr	r3, [r4, #92]	@ 0x5c
 c05668a:	b1d3      	cbz	r3, c0566c2 <mbedtls_hmac_drbg_random_with_add+0x5c>
 c05668c:	6d63      	ldr	r3, [r4, #84]	@ 0x54
 c05668e:	2b01      	cmp	r3, #1
 c056690:	d003      	beq.n	c05669a <mbedtls_hmac_drbg_random_with_add+0x34>
        ( ctx->prediction_resistance == MBEDTLS_HMAC_DRBG_PR_ON ||
 c056692:	6ce2      	ldr	r2, [r4, #76]	@ 0x4c
 c056694:	6da3      	ldr	r3, [r4, #88]	@ 0x58
 c056696:	429a      	cmp	r2, r3
 c056698:	dd13      	ble.n	c0566c2 <mbedtls_hmac_drbg_random_with_add+0x5c>
          ctx->reseed_counter > ctx->reseed_interval ) )
    {
        if( ( ret = mbedtls_hmac_drbg_reseed( ctx, additional, add_len ) ) != 0 )
 c05669a:	463a      	mov	r2, r7
 c05669c:	4631      	mov	r1, r6
 c05669e:	4620      	mov	r0, r4
 c0566a0:	f7ff ffde 	bl	c056660 <mbedtls_hmac_drbg_reseed>
 c0566a4:	b9c0      	cbnz	r0, c0566d8 <mbedtls_hmac_drbg_random_with_add+0x72>
            return( ret );

        add_len = 0; /* VII.4 */
 c0566a6:	4607      	mov	r7, r0
        size_t use_len = left > md_len ? md_len : left;

        if( ( ret = mbedtls_md_hmac_reset( &ctx->md_ctx ) ) != 0 )
            goto exit;
        if( ( ret = mbedtls_md_hmac_update( &ctx->md_ctx,
                                            ctx->V, md_len ) ) != 0 )
 c0566a8:	f104 0a0c 	add.w	sl, r4, #12
    while( left != 0 )
 c0566ac:	b9b5      	cbnz	r5, c0566dc <mbedtls_hmac_drbg_random_with_add+0x76>
        out += use_len;
        left -= use_len;
    }

    /* 6. Update */
    if( ( ret = mbedtls_hmac_drbg_update_ret( ctx,
 c0566ae:	463a      	mov	r2, r7
 c0566b0:	4631      	mov	r1, r6
 c0566b2:	4620      	mov	r0, r4
 c0566b4:	f7ff fef6 	bl	c0564a4 <mbedtls_hmac_drbg_update_ret>
 c0566b8:	b970      	cbnz	r0, c0566d8 <mbedtls_hmac_drbg_random_with_add+0x72>
                                              additional, add_len ) ) != 0 )
        goto exit;

    /* 7. Update reseed counter */
    ctx->reseed_counter++;
 c0566ba:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
 c0566bc:	3301      	adds	r3, #1
 c0566be:	64e3      	str	r3, [r4, #76]	@ 0x4c
 c0566c0:	e00a      	b.n	c0566d8 <mbedtls_hmac_drbg_random_with_add+0x72>
    if( additional != NULL && add_len != 0 )
 c0566c2:	2e00      	cmp	r6, #0
 c0566c4:	d0f0      	beq.n	c0566a8 <mbedtls_hmac_drbg_random_with_add+0x42>
 c0566c6:	2f00      	cmp	r7, #0
 c0566c8:	d0ee      	beq.n	c0566a8 <mbedtls_hmac_drbg_random_with_add+0x42>
        if( ( ret = mbedtls_hmac_drbg_update_ret( ctx,
 c0566ca:	463a      	mov	r2, r7
 c0566cc:	4631      	mov	r1, r6
 c0566ce:	4620      	mov	r0, r4
 c0566d0:	f7ff fee8 	bl	c0564a4 <mbedtls_hmac_drbg_update_ret>
 c0566d4:	2800      	cmp	r0, #0
 c0566d6:	d0e7      	beq.n	c0566a8 <mbedtls_hmac_drbg_random_with_add+0x42>

exit:
    /* 8. Done */
    return( ret );
}
 c0566d8:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
        size_t use_len = left > md_len ? md_len : left;
 c0566dc:	454d      	cmp	r5, r9
        if( ( ret = mbedtls_md_hmac_reset( &ctx->md_ctx ) ) != 0 )
 c0566de:	4620      	mov	r0, r4
        size_t use_len = left > md_len ? md_len : left;
 c0566e0:	46ab      	mov	fp, r5
 c0566e2:	bf28      	it	cs
 c0566e4:	46cb      	movcs	fp, r9
        if( ( ret = mbedtls_md_hmac_reset( &ctx->md_ctx ) ) != 0 )
 c0566e6:	f000 f9a9 	bl	c056a3c <mbedtls_md_hmac_reset>
 c0566ea:	2800      	cmp	r0, #0
 c0566ec:	d1f4      	bne.n	c0566d8 <mbedtls_hmac_drbg_random_with_add+0x72>
        if( ( ret = mbedtls_md_hmac_update( &ctx->md_ctx,
 c0566ee:	464a      	mov	r2, r9
 c0566f0:	4651      	mov	r1, sl
 c0566f2:	4620      	mov	r0, r4
 c0566f4:	f000 f96a 	bl	c0569cc <mbedtls_md_hmac_update>
 c0566f8:	2800      	cmp	r0, #0
 c0566fa:	d1ed      	bne.n	c0566d8 <mbedtls_hmac_drbg_random_with_add+0x72>
        if( ( ret = mbedtls_md_hmac_finish( &ctx->md_ctx, ctx->V ) ) != 0 )
 c0566fc:	4651      	mov	r1, sl
 c0566fe:	4620      	mov	r0, r4
 c056700:	f000 f972 	bl	c0569e8 <mbedtls_md_hmac_finish>
 c056704:	2800      	cmp	r0, #0
 c056706:	d1e7      	bne.n	c0566d8 <mbedtls_hmac_drbg_random_with_add+0x72>
        memcpy( out, ctx->V, use_len );
 c056708:	4640      	mov	r0, r8
 c05670a:	465a      	mov	r2, fp
 c05670c:	4651      	mov	r1, sl
 c05670e:	f004 ff9d 	bl	c05b64c <memcpy>
        out += use_len;
 c056712:	44d8      	add	r8, fp
        left -= use_len;
 c056714:	eba5 050b 	sub.w	r5, r5, fp
 c056718:	e7c8      	b.n	c0566ac <mbedtls_hmac_drbg_random_with_add+0x46>
        return( MBEDTLS_ERR_HMAC_DRBG_REQUEST_TOO_BIG );
 c05671a:	f06f 0002 	mvn.w	r0, #2
 c05671e:	e7db      	b.n	c0566d8 <mbedtls_hmac_drbg_random_with_add+0x72>
        return( MBEDTLS_ERR_HMAC_DRBG_INPUT_TOO_BIG );
 c056720:	f06f 0004 	mvn.w	r0, #4
 c056724:	e7d8      	b.n	c0566d8 <mbedtls_hmac_drbg_random_with_add+0x72>

0c056726 <mbedtls_hmac_drbg_random>:
#if defined(MBEDTLS_THREADING_C)
    if( ( ret = mbedtls_mutex_lock( &ctx->mutex ) ) != 0 )
        return( ret );
#endif

    ret = mbedtls_hmac_drbg_random_with_add( ctx, output, out_len, NULL, 0 );
 c056726:	2300      	movs	r3, #0
{
 c056728:	b507      	push	{r0, r1, r2, lr}
    ret = mbedtls_hmac_drbg_random_with_add( ctx, output, out_len, NULL, 0 );
 c05672a:	9300      	str	r3, [sp, #0]
 c05672c:	f7ff ff9b 	bl	c056666 <mbedtls_hmac_drbg_random_with_add>
    if( mbedtls_mutex_unlock( &ctx->mutex ) != 0 )
        return( MBEDTLS_ERR_THREADING_MUTEX_ERROR );
#endif

    return( ret );
}
 c056730:	b003      	add	sp, #12
 c056732:	f85d fb04 	ldr.w	pc, [sp], #4

0c056736 <mbedtls_hmac_drbg_free>:
/*
 *  This function resets HMAC_DRBG context to the state immediately
 *  after initial call of mbedtls_hmac_drbg_init().
 */
void mbedtls_hmac_drbg_free( mbedtls_hmac_drbg_context *ctx )
{
 c056736:	b510      	push	{r4, lr}
    if( ctx == NULL )
 c056738:	4604      	mov	r4, r0
 c05673a:	b140      	cbz	r0, c05674e <mbedtls_hmac_drbg_free+0x18>
#if defined(MBEDTLS_THREADING_C)
    /* The mutex is initialized iff the md context is set up. */
    if( ctx->md_ctx.md_info != NULL )
        mbedtls_mutex_free( &ctx->mutex );
#endif
    mbedtls_md_free( &ctx->md_ctx );
 c05673c:	f000 f819 	bl	c056772 <mbedtls_md_free>
    mbedtls_platform_zeroize( ctx, sizeof( mbedtls_hmac_drbg_context ) );
 c056740:	2164      	movs	r1, #100	@ 0x64
 c056742:	4620      	mov	r0, r4
 c056744:	f7e4 fe44 	bl	c03b3d0 <mbedtls_platform_zeroize>
    ctx->reseed_interval = MBEDTLS_HMAC_DRBG_RESEED_INTERVAL;
 c056748:	f242 7310 	movw	r3, #10000	@ 0x2710
 c05674c:	65a3      	str	r3, [r4, #88]	@ 0x58
}
 c05674e:	bd10      	pop	{r4, pc}

0c056750 <mbedtls_md_info_from_type>:
    return( NULL );
}

const mbedtls_md_info_t *mbedtls_md_info_from_type( mbedtls_md_type_t md_type )
{
    switch( md_type )
 c056750:	3805      	subs	r0, #5
 c056752:	b2c0      	uxtb	r0, r0
 c056754:	2803      	cmp	r0, #3
 c056756:	bf9a      	itte	ls
 c056758:	4b02      	ldrls	r3, [pc, #8]	@ (c056764 <mbedtls_md_info_from_type+0x14>)
 c05675a:	f853 0020 	ldrls.w	r0, [r3, r0, lsl #2]
{
 c05675e:	2000      	movhi	r0, #0
            return( &mbedtls_sha512_info );
#endif
        default:
            return( NULL );
    }
}
 c056760:	4770      	bx	lr
 c056762:	bf00      	nop
 c056764:	0c0602d0 	.word	0x0c0602d0

0c056768 <mbedtls_md_init>:

void mbedtls_md_init( mbedtls_md_context_t *ctx )
{
    memset( ctx, 0, sizeof( mbedtls_md_context_t ) );
 c056768:	2300      	movs	r3, #0
 c05676a:	6003      	str	r3, [r0, #0]
 c05676c:	6043      	str	r3, [r0, #4]
 c05676e:	6083      	str	r3, [r0, #8]
}
 c056770:	4770      	bx	lr

0c056772 <mbedtls_md_free>:

void mbedtls_md_free( mbedtls_md_context_t *ctx )
{
 c056772:	b510      	push	{r4, lr}
    if( ctx == NULL || ctx->md_info == NULL )
 c056774:	4604      	mov	r4, r0
 c056776:	b320      	cbz	r0, c0567c2 <mbedtls_md_free+0x50>
 c056778:	6803      	ldr	r3, [r0, #0]
 c05677a:	b313      	cbz	r3, c0567c2 <mbedtls_md_free+0x50>
        return;

    if( ctx->md_ctx != NULL )
 c05677c:	6840      	ldr	r0, [r0, #4]
 c05677e:	b168      	cbz	r0, c05679c <mbedtls_md_free+0x2a>
    {
        switch( ctx->md_info->type )
 c056780:	791b      	ldrb	r3, [r3, #4]
 c056782:	2b06      	cmp	r3, #6
 c056784:	d804      	bhi.n	c056790 <mbedtls_md_free+0x1e>
 c056786:	2b04      	cmp	r3, #4
 c056788:	d905      	bls.n	c056796 <mbedtls_md_free+0x24>
                break;
#endif
#if defined(MBEDTLS_SHA256_C)
            case MBEDTLS_MD_SHA224:
            case MBEDTLS_MD_SHA256:
                mbedtls_sha256_free( ctx->md_ctx );
 c05678a:	f7fa f90d 	bl	c0509a8 <mbedtls_sha256_free>
                break;
 c05678e:	e002      	b.n	c056796 <mbedtls_md_free+0x24>
        switch( ctx->md_info->type )
 c056790:	3b07      	subs	r3, #7
 c056792:	2b01      	cmp	r3, #1
 c056794:	d912      	bls.n	c0567bc <mbedtls_md_free+0x4a>
#endif
            default:
                /* Shouldn't happen */
                break;
        }
        mbedtls_free( ctx->md_ctx );
 c056796:	6860      	ldr	r0, [r4, #4]
 c056798:	f7e4 fe0a 	bl	c03b3b0 <mbedtls_free>
    }

    if( ctx->hmac_ctx != NULL )
 c05679c:	68a0      	ldr	r0, [r4, #8]
 c05679e:	b138      	cbz	r0, c0567b0 <mbedtls_md_free+0x3e>
    {
        mbedtls_platform_zeroize( ctx->hmac_ctx,
                                  2 * ctx->md_info->block_size );
 c0567a0:	6823      	ldr	r3, [r4, #0]
 c0567a2:	7999      	ldrb	r1, [r3, #6]
        mbedtls_platform_zeroize( ctx->hmac_ctx,
 c0567a4:	0049      	lsls	r1, r1, #1
 c0567a6:	f7e4 fe13 	bl	c03b3d0 <mbedtls_platform_zeroize>
        mbedtls_free( ctx->hmac_ctx );
 c0567aa:	68a0      	ldr	r0, [r4, #8]
 c0567ac:	f7e4 fe00 	bl	c03b3b0 <mbedtls_free>
    }

    mbedtls_platform_zeroize( ctx, sizeof( mbedtls_md_context_t ) );
 c0567b0:	4620      	mov	r0, r4
}
 c0567b2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mbedtls_platform_zeroize( ctx, sizeof( mbedtls_md_context_t ) );
 c0567b6:	210c      	movs	r1, #12
 c0567b8:	f7e4 be0a 	b.w	c03b3d0 <mbedtls_platform_zeroize>
                mbedtls_sha512_free( ctx->md_ctx );
 c0567bc:	f001 fd67 	bl	c05828e <mbedtls_sha512_free>
                break;
 c0567c0:	e7e9      	b.n	c056796 <mbedtls_md_free+0x24>
}
 c0567c2:	bd10      	pop	{r4, pc}

0c0567c4 <mbedtls_md_setup>:
        mbedtls_##type##_init( ctx->md_ctx );                           \
    }                                                                   \
    while( 0 )

int mbedtls_md_setup( mbedtls_md_context_t *ctx, const mbedtls_md_info_t *md_info, int hmac )
{
 c0567c4:	b570      	push	{r4, r5, r6, lr}
 c0567c6:	4604      	mov	r4, r0
 c0567c8:	4616      	mov	r6, r2
    if( md_info == NULL || ctx == NULL )
 c0567ca:	460d      	mov	r5, r1
 c0567cc:	b1a9      	cbz	r1, c0567fa <mbedtls_md_setup+0x36>
 c0567ce:	b1a0      	cbz	r0, c0567fa <mbedtls_md_setup+0x36>
        return( MBEDTLS_ERR_MD_BAD_INPUT_DATA );

    ctx->md_info = md_info;
    ctx->md_ctx = NULL;
 c0567d0:	2300      	movs	r3, #0
    ctx->hmac_ctx = NULL;
 c0567d2:	e9c0 3301 	strd	r3, r3, [r0, #4]
    ctx->md_info = md_info;
 c0567d6:	6001      	str	r1, [r0, #0]

    switch( md_info->type )
 c0567d8:	790b      	ldrb	r3, [r1, #4]
 c0567da:	2b06      	cmp	r3, #6
 c0567dc:	d80a      	bhi.n	c0567f4 <mbedtls_md_setup+0x30>
 c0567de:	2b04      	cmp	r3, #4
 c0567e0:	d90b      	bls.n	c0567fa <mbedtls_md_setup+0x36>
            break;
#endif
#if defined(MBEDTLS_SHA256_C)
        case MBEDTLS_MD_SHA224:
        case MBEDTLS_MD_SHA256:
            ALLOC( sha256 );
 c0567e2:	f44f 71ba 	mov.w	r1, #372	@ 0x174
 c0567e6:	2001      	movs	r0, #1
 c0567e8:	f7e4 fddc 	bl	c03b3a4 <mbedtls_calloc>
 c0567ec:	6060      	str	r0, [r4, #4]
 c0567ee:	b930      	cbnz	r0, c0567fe <mbedtls_md_setup+0x3a>
 c0567f0:	4810      	ldr	r0, [pc, #64]	@ (c056834 <mbedtls_md_setup+0x70>)
            return( MBEDTLS_ERR_MD_ALLOC_FAILED );
        }
    }

    return( 0 );
}
 c0567f2:	bd70      	pop	{r4, r5, r6, pc}
    switch( md_info->type )
 c0567f4:	3b07      	subs	r3, #7
 c0567f6:	2b01      	cmp	r3, #1
 c0567f8:	d906      	bls.n	c056808 <mbedtls_md_setup+0x44>
{
 c0567fa:	480f      	ldr	r0, [pc, #60]	@ (c056838 <mbedtls_md_setup+0x74>)
 c0567fc:	e7f9      	b.n	c0567f2 <mbedtls_md_setup+0x2e>
            ALLOC( sha256 );
 c0567fe:	f7fa f8b9 	bl	c050974 <mbedtls_sha256_init>
    if( hmac != 0 )
 c056802:	b95e      	cbnz	r6, c05681c <mbedtls_md_setup+0x58>
    return( 0 );
 c056804:	2000      	movs	r0, #0
 c056806:	e7f4      	b.n	c0567f2 <mbedtls_md_setup+0x2e>
            ALLOC( sha512 );
 c056808:	21d8      	movs	r1, #216	@ 0xd8
 c05680a:	2001      	movs	r0, #1
 c05680c:	f7e4 fdca 	bl	c03b3a4 <mbedtls_calloc>
 c056810:	6060      	str	r0, [r4, #4]
 c056812:	2800      	cmp	r0, #0
 c056814:	d0ec      	beq.n	c0567f0 <mbedtls_md_setup+0x2c>
 c056816:	f001 fd36 	bl	c058286 <mbedtls_sha512_init>
            break;
 c05681a:	e7f2      	b.n	c056802 <mbedtls_md_setup+0x3e>
        ctx->hmac_ctx = mbedtls_calloc( 2, md_info->block_size );
 c05681c:	2002      	movs	r0, #2
 c05681e:	79a9      	ldrb	r1, [r5, #6]
 c056820:	f7e4 fdc0 	bl	c03b3a4 <mbedtls_calloc>
 c056824:	60a0      	str	r0, [r4, #8]
        if( ctx->hmac_ctx == NULL )
 c056826:	2800      	cmp	r0, #0
 c056828:	d1ec      	bne.n	c056804 <mbedtls_md_setup+0x40>
            mbedtls_md_free( ctx );
 c05682a:	4620      	mov	r0, r4
 c05682c:	f7ff ffa1 	bl	c056772 <mbedtls_md_free>
            return( MBEDTLS_ERR_MD_ALLOC_FAILED );
 c056830:	e7de      	b.n	c0567f0 <mbedtls_md_setup+0x2c>
 c056832:	bf00      	nop
 c056834:	ffffae80 	.word	0xffffae80
 c056838:	ffffaf00 	.word	0xffffaf00

0c05683c <mbedtls_md_starts>:
#undef ALLOC

int mbedtls_md_starts( mbedtls_md_context_t *ctx )
{
    if( ctx == NULL || ctx->md_info == NULL )
 c05683c:	b1a8      	cbz	r0, c05686a <mbedtls_md_starts+0x2e>
 c05683e:	6803      	ldr	r3, [r0, #0]
 c056840:	b19b      	cbz	r3, c05686a <mbedtls_md_starts+0x2e>
        return( MBEDTLS_ERR_MD_BAD_INPUT_DATA );

    switch( ctx->md_info->type )
 c056842:	791b      	ldrb	r3, [r3, #4]
 c056844:	3b05      	subs	r3, #5
 c056846:	2b03      	cmp	r3, #3
 c056848:	d80f      	bhi.n	c05686a <mbedtls_md_starts+0x2e>
 c05684a:	e8df f003 	tbb	[pc, r3]
 c05684e:	0602      	.short	0x0602
 c056850:	0c08      	.short	0x0c08
        case MBEDTLS_MD_SHA1:
            return( mbedtls_sha1_starts_ret( ctx->md_ctx ) );
#endif
#if defined(MBEDTLS_SHA256_C)
        case MBEDTLS_MD_SHA224:
            return( mbedtls_sha256_starts_ret( ctx->md_ctx, 1 ) );
 c056852:	2101      	movs	r1, #1
        case MBEDTLS_MD_SHA256:
            return( mbedtls_sha256_starts_ret( ctx->md_ctx, 0 ) );
 c056854:	6840      	ldr	r0, [r0, #4]
 c056856:	f7fa b8b7 	b.w	c0509c8 <mbedtls_sha256_starts_ret>
 c05685a:	2100      	movs	r1, #0
 c05685c:	e7fa      	b.n	c056854 <mbedtls_md_starts+0x18>
#endif
#if defined(MBEDTLS_SHA512_C)
#if !defined(MBEDTLS_SHA512_NO_SHA384)
        case MBEDTLS_MD_SHA384:
            return( mbedtls_sha512_starts_ret( ctx->md_ctx, 1 ) );
 c05685e:	2101      	movs	r1, #1
#endif
        case MBEDTLS_MD_SHA512:
            return( mbedtls_sha512_starts_ret( ctx->md_ctx, 0 ) );
 c056860:	6840      	ldr	r0, [r0, #4]
 c056862:	f001 bd21 	b.w	c0582a8 <mbedtls_sha512_starts_ret>
 c056866:	2100      	movs	r1, #0
 c056868:	e7fa      	b.n	c056860 <mbedtls_md_starts+0x24>
    switch( ctx->md_info->type )
 c05686a:	4801      	ldr	r0, [pc, #4]	@ (c056870 <mbedtls_md_starts+0x34>)
#endif
        default:
            return( MBEDTLS_ERR_MD_BAD_INPUT_DATA );
    }
}
 c05686c:	4770      	bx	lr
 c05686e:	bf00      	nop
 c056870:	ffffaf00 	.word	0xffffaf00

0c056874 <mbedtls_md_update>:

int mbedtls_md_update( mbedtls_md_context_t *ctx, const unsigned char *input, size_t ilen )
{
    if( ctx == NULL || ctx->md_info == NULL )
 c056874:	b130      	cbz	r0, c056884 <mbedtls_md_update+0x10>
 c056876:	6803      	ldr	r3, [r0, #0]
 c056878:	b123      	cbz	r3, c056884 <mbedtls_md_update+0x10>
        return( MBEDTLS_ERR_MD_BAD_INPUT_DATA );

    switch( ctx->md_info->type )
 c05687a:	791b      	ldrb	r3, [r3, #4]
 c05687c:	2b06      	cmp	r3, #6
 c05687e:	d803      	bhi.n	c056888 <mbedtls_md_update+0x14>
 c056880:	2b04      	cmp	r3, #4
 c056882:	d807      	bhi.n	c056894 <mbedtls_md_update+0x20>
 c056884:	4805      	ldr	r0, [pc, #20]	@ (c05689c <mbedtls_md_update+0x28>)
            return( mbedtls_sha512_update_ret( ctx->md_ctx, input, ilen ) );
#endif
        default:
            return( MBEDTLS_ERR_MD_BAD_INPUT_DATA );
    }
}
 c056886:	4770      	bx	lr
    switch( ctx->md_info->type )
 c056888:	3b07      	subs	r3, #7
 c05688a:	2b01      	cmp	r3, #1
 c05688c:	d8fa      	bhi.n	c056884 <mbedtls_md_update+0x10>
            return( mbedtls_sha512_update_ret( ctx->md_ctx, input, ilen ) );
 c05688e:	6840      	ldr	r0, [r0, #4]
 c056890:	f002 ba80 	b.w	c058d94 <mbedtls_sha512_update_ret>
            return( mbedtls_sha256_update_ret( ctx->md_ctx, input, ilen ) );
 c056894:	6840      	ldr	r0, [r0, #4]
 c056896:	f7fa b8b7 	b.w	c050a08 <mbedtls_sha256_update_ret>
 c05689a:	bf00      	nop
 c05689c:	ffffaf00 	.word	0xffffaf00

0c0568a0 <mbedtls_md_finish>:

int mbedtls_md_finish( mbedtls_md_context_t *ctx, unsigned char *output )
{
    if( ctx == NULL || ctx->md_info == NULL )
 c0568a0:	b130      	cbz	r0, c0568b0 <mbedtls_md_finish+0x10>
 c0568a2:	6803      	ldr	r3, [r0, #0]
 c0568a4:	b123      	cbz	r3, c0568b0 <mbedtls_md_finish+0x10>
        return( MBEDTLS_ERR_MD_BAD_INPUT_DATA );

    switch( ctx->md_info->type )
 c0568a6:	791b      	ldrb	r3, [r3, #4]
 c0568a8:	2b06      	cmp	r3, #6
 c0568aa:	d803      	bhi.n	c0568b4 <mbedtls_md_finish+0x14>
 c0568ac:	2b04      	cmp	r3, #4
 c0568ae:	d807      	bhi.n	c0568c0 <mbedtls_md_finish+0x20>
 c0568b0:	4805      	ldr	r0, [pc, #20]	@ (c0568c8 <mbedtls_md_finish+0x28>)
            return( mbedtls_sha512_finish_ret( ctx->md_ctx, output ) );
#endif
        default:
            return( MBEDTLS_ERR_MD_BAD_INPUT_DATA );
    }
}
 c0568b2:	4770      	bx	lr
    switch( ctx->md_info->type )
 c0568b4:	3b07      	subs	r3, #7
 c0568b6:	2b01      	cmp	r3, #1
 c0568b8:	d8fa      	bhi.n	c0568b0 <mbedtls_md_finish+0x10>
            return( mbedtls_sha512_finish_ret( ctx->md_ctx, output ) );
 c0568ba:	6840      	ldr	r0, [r0, #4]
 c0568bc:	f002 bab0 	b.w	c058e20 <mbedtls_sha512_finish_ret>
            return( mbedtls_sha256_finish_ret( ctx->md_ctx, output ) );
 c0568c0:	6840      	ldr	r0, [r0, #4]
 c0568c2:	f7fa b908 	b.w	c050ad6 <mbedtls_sha256_finish_ret>
 c0568c6:	bf00      	nop
 c0568c8:	ffffaf00 	.word	0xffffaf00

0c0568cc <mbedtls_md>:

int mbedtls_md( const mbedtls_md_info_t *md_info, const unsigned char *input, size_t ilen,
            unsigned char *output )
{
 c0568cc:	b410      	push	{r4}
 c0568ce:	4604      	mov	r4, r0
 c0568d0:	4608      	mov	r0, r1
 c0568d2:	4611      	mov	r1, r2
 c0568d4:	461a      	mov	r2, r3
    if( md_info == NULL )
 c0568d6:	b19c      	cbz	r4, c056900 <mbedtls_md+0x34>
        return( MBEDTLS_ERR_MD_BAD_INPUT_DATA );

    switch( md_info->type )
 c0568d8:	7923      	ldrb	r3, [r4, #4]
 c0568da:	3b05      	subs	r3, #5
 c0568dc:	2b03      	cmp	r3, #3
 c0568de:	d80f      	bhi.n	c056900 <mbedtls_md+0x34>
 c0568e0:	e8df f003 	tbb	[pc, r3]
 c0568e4:	0c080602 	.word	0x0c080602
        case MBEDTLS_MD_SHA1:
            return( mbedtls_sha1_ret( input, ilen, output ) );
#endif
#if defined(MBEDTLS_SHA256_C)
        case MBEDTLS_MD_SHA224:
            return( mbedtls_sha256_ret( input, ilen, output, 1 ) );
 c0568e8:	2301      	movs	r3, #1
            return( mbedtls_sha512_ret( input, ilen, output, 0 ) );
#endif
        default:
            return( MBEDTLS_ERR_MD_BAD_INPUT_DATA );
    }
}
 c0568ea:	bc10      	pop	{r4}
            return( mbedtls_sha256_ret( input, ilen, output, 0 ) );
 c0568ec:	f001 bcaa 	b.w	c058244 <mbedtls_sha256_ret>
 c0568f0:	2300      	movs	r3, #0
 c0568f2:	e7fa      	b.n	c0568ea <mbedtls_md+0x1e>
            return( mbedtls_sha512_ret( input, ilen, output, 1 ) );
 c0568f4:	2301      	movs	r3, #1
}
 c0568f6:	bc10      	pop	{r4}
            return( mbedtls_sha512_ret( input, ilen, output, 0 ) );
 c0568f8:	f002 bbae 	b.w	c059058 <mbedtls_sha512_ret>
 c0568fc:	2300      	movs	r3, #0
 c0568fe:	e7fa      	b.n	c0568f6 <mbedtls_md+0x2a>
    switch( md_info->type )
 c056900:	4801      	ldr	r0, [pc, #4]	@ (c056908 <mbedtls_md+0x3c>)
}
 c056902:	bc10      	pop	{r4}
 c056904:	4770      	bx	lr
 c056906:	bf00      	nop
 c056908:	ffffaf00 	.word	0xffffaf00

0c05690c <mbedtls_md_hmac_starts>:
    return( ret );
}
#endif /* MBEDTLS_FS_IO */

int mbedtls_md_hmac_starts( mbedtls_md_context_t *ctx, const unsigned char *key, size_t keylen )
{
 c05690c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 c056910:	460e      	mov	r6, r1
 c056912:	4617      	mov	r7, r2
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    unsigned char sum[MBEDTLS_MD_MAX_SIZE];
    unsigned char *ipad, *opad;
    size_t i;

    if( ctx == NULL || ctx->md_info == NULL || ctx->hmac_ctx == NULL )
 c056914:	4605      	mov	r5, r0
{
 c056916:	b090      	sub	sp, #64	@ 0x40
    if( ctx == NULL || ctx->md_info == NULL || ctx->hmac_ctx == NULL )
 c056918:	2800      	cmp	r0, #0
 c05691a:	d052      	beq.n	c0569c2 <mbedtls_md_hmac_starts+0xb6>
 c05691c:	6803      	ldr	r3, [r0, #0]
 c05691e:	2b00      	cmp	r3, #0
 c056920:	d04f      	beq.n	c0569c2 <mbedtls_md_hmac_starts+0xb6>
 c056922:	6882      	ldr	r2, [r0, #8]
 c056924:	2a00      	cmp	r2, #0
 c056926:	d04c      	beq.n	c0569c2 <mbedtls_md_hmac_starts+0xb6>
        return( MBEDTLS_ERR_MD_BAD_INPUT_DATA );

    if( keylen > (size_t) ctx->md_info->block_size )
 c056928:	799b      	ldrb	r3, [r3, #6]
 c05692a:	42bb      	cmp	r3, r7
 c05692c:	d213      	bcs.n	c056956 <mbedtls_md_hmac_starts+0x4a>
    {
        if( ( ret = mbedtls_md_starts( ctx ) ) != 0 )
 c05692e:	f7ff ff85 	bl	c05683c <mbedtls_md_starts>
 c056932:	4604      	mov	r4, r0
 c056934:	bb88      	cbnz	r0, c05699a <mbedtls_md_hmac_starts+0x8e>
            goto cleanup;
        if( ( ret = mbedtls_md_update( ctx, key, keylen ) ) != 0 )
 c056936:	463a      	mov	r2, r7
 c056938:	4631      	mov	r1, r6
 c05693a:	4628      	mov	r0, r5
 c05693c:	f7ff ff9a 	bl	c056874 <mbedtls_md_update>
 c056940:	4604      	mov	r4, r0
 c056942:	bb50      	cbnz	r0, c05699a <mbedtls_md_hmac_starts+0x8e>
            goto cleanup;
        if( ( ret = mbedtls_md_finish( ctx, sum ) ) != 0 )
 c056944:	4669      	mov	r1, sp
 c056946:	4628      	mov	r0, r5
 c056948:	f7ff ffaa 	bl	c0568a0 <mbedtls_md_finish>
 c05694c:	4604      	mov	r4, r0
 c05694e:	bb20      	cbnz	r0, c05699a <mbedtls_md_hmac_starts+0x8e>
            goto cleanup;

        keylen = ctx->md_info->size;
        key = sum;
 c056950:	466e      	mov	r6, sp
        keylen = ctx->md_info->size;
 c056952:	682b      	ldr	r3, [r5, #0]
 c056954:	795f      	ldrb	r7, [r3, #5]
    }

    ipad = (unsigned char *) ctx->hmac_ctx;
    opad = (unsigned char *) ctx->hmac_ctx + ctx->md_info->block_size;
 c056956:	682b      	ldr	r3, [r5, #0]
    ipad = (unsigned char *) ctx->hmac_ctx;
 c056958:	f8d5 8008 	ldr.w	r8, [r5, #8]
    opad = (unsigned char *) ctx->hmac_ctx + ctx->md_info->block_size;
 c05695c:	799a      	ldrb	r2, [r3, #6]

    memset( ipad, 0x36, ctx->md_info->block_size );
 c05695e:	2136      	movs	r1, #54	@ 0x36
 c056960:	4640      	mov	r0, r8
    opad = (unsigned char *) ctx->hmac_ctx + ctx->md_info->block_size;
 c056962:	eb08 0402 	add.w	r4, r8, r2
    memset( ipad, 0x36, ctx->md_info->block_size );
 c056966:	f004 fee2 	bl	c05b72e <memset>
    memset( opad, 0x5C, ctx->md_info->block_size );
 c05696a:	682b      	ldr	r3, [r5, #0]
 c05696c:	215c      	movs	r1, #92	@ 0x5c
 c05696e:	799a      	ldrb	r2, [r3, #6]
 c056970:	4620      	mov	r0, r4
 c056972:	f004 fedc 	bl	c05b72e <memset>

    for( i = 0; i < keylen; i++ )
 c056976:	4643      	mov	r3, r8
 c056978:	3e01      	subs	r6, #1
 c05697a:	1e60      	subs	r0, r4, #1
 c05697c:	4447      	add	r7, r8
 c05697e:	429f      	cmp	r7, r3
 c056980:	d113      	bne.n	c0569aa <mbedtls_md_hmac_starts+0x9e>
    {
        ipad[i] = (unsigned char)( ipad[i] ^ key[i] );
        opad[i] = (unsigned char)( opad[i] ^ key[i] );
    }

    if( ( ret = mbedtls_md_starts( ctx ) ) != 0 )
 c056982:	4628      	mov	r0, r5
 c056984:	f7ff ff5a 	bl	c05683c <mbedtls_md_starts>
 c056988:	4604      	mov	r4, r0
 c05698a:	b930      	cbnz	r0, c05699a <mbedtls_md_hmac_starts+0x8e>
        goto cleanup;
    if( ( ret = mbedtls_md_update( ctx, ipad,
                                   ctx->md_info->block_size ) ) != 0 )
 c05698c:	682b      	ldr	r3, [r5, #0]
    if( ( ret = mbedtls_md_update( ctx, ipad,
 c05698e:	4641      	mov	r1, r8
 c056990:	4628      	mov	r0, r5
 c056992:	799a      	ldrb	r2, [r3, #6]
 c056994:	f7ff ff6e 	bl	c056874 <mbedtls_md_update>
 c056998:	4604      	mov	r4, r0
        goto cleanup;

cleanup:
    mbedtls_platform_zeroize( sum, sizeof( sum ) );
 c05699a:	2140      	movs	r1, #64	@ 0x40
 c05699c:	4668      	mov	r0, sp
 c05699e:	f7e4 fd17 	bl	c03b3d0 <mbedtls_platform_zeroize>

    return( ret );
}
 c0569a2:	4620      	mov	r0, r4
 c0569a4:	b010      	add	sp, #64	@ 0x40
 c0569a6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        ipad[i] = (unsigned char)( ipad[i] ^ key[i] );
 c0569aa:	f816 1f01 	ldrb.w	r1, [r6, #1]!
 c0569ae:	781a      	ldrb	r2, [r3, #0]
 c0569b0:	404a      	eors	r2, r1
 c0569b2:	f803 2b01 	strb.w	r2, [r3], #1
        opad[i] = (unsigned char)( opad[i] ^ key[i] );
 c0569b6:	f810 2f01 	ldrb.w	r2, [r0, #1]!
 c0569ba:	7831      	ldrb	r1, [r6, #0]
 c0569bc:	404a      	eors	r2, r1
 c0569be:	7002      	strb	r2, [r0, #0]
    for( i = 0; i < keylen; i++ )
 c0569c0:	e7dd      	b.n	c05697e <mbedtls_md_hmac_starts+0x72>
        return( MBEDTLS_ERR_MD_BAD_INPUT_DATA );
 c0569c2:	4c01      	ldr	r4, [pc, #4]	@ (c0569c8 <mbedtls_md_hmac_starts+0xbc>)
 c0569c4:	e7ed      	b.n	c0569a2 <mbedtls_md_hmac_starts+0x96>
 c0569c6:	bf00      	nop
 c0569c8:	ffffaf00 	.word	0xffffaf00

0c0569cc <mbedtls_md_hmac_update>:

int mbedtls_md_hmac_update( mbedtls_md_context_t *ctx, const unsigned char *input, size_t ilen )
{
 c0569cc:	b410      	push	{r4}
    if( ctx == NULL || ctx->md_info == NULL || ctx->hmac_ctx == NULL )
 c0569ce:	b130      	cbz	r0, c0569de <mbedtls_md_hmac_update+0x12>
 c0569d0:	6804      	ldr	r4, [r0, #0]
 c0569d2:	b124      	cbz	r4, c0569de <mbedtls_md_hmac_update+0x12>
 c0569d4:	6883      	ldr	r3, [r0, #8]
 c0569d6:	b113      	cbz	r3, c0569de <mbedtls_md_hmac_update+0x12>
        return( MBEDTLS_ERR_MD_BAD_INPUT_DATA );

    return( mbedtls_md_update( ctx, input, ilen ) );
}
 c0569d8:	bc10      	pop	{r4}
    return( mbedtls_md_update( ctx, input, ilen ) );
 c0569da:	f7ff bf4b 	b.w	c056874 <mbedtls_md_update>
        return( MBEDTLS_ERR_MD_BAD_INPUT_DATA );
 c0569de:	4801      	ldr	r0, [pc, #4]	@ (c0569e4 <mbedtls_md_hmac_update+0x18>)
}
 c0569e0:	bc10      	pop	{r4}
 c0569e2:	4770      	bx	lr
 c0569e4:	ffffaf00 	.word	0xffffaf00

0c0569e8 <mbedtls_md_hmac_finish>:

int mbedtls_md_hmac_finish( mbedtls_md_context_t *ctx, unsigned char *output )
{
 c0569e8:	b5f0      	push	{r4, r5, r6, r7, lr}
 c0569ea:	460d      	mov	r5, r1
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    unsigned char tmp[MBEDTLS_MD_MAX_SIZE];
    unsigned char *opad;

    if( ctx == NULL || ctx->md_info == NULL || ctx->hmac_ctx == NULL )
 c0569ec:	4604      	mov	r4, r0
{
 c0569ee:	b091      	sub	sp, #68	@ 0x44
    if( ctx == NULL || ctx->md_info == NULL || ctx->hmac_ctx == NULL )
 c0569f0:	b300      	cbz	r0, c056a34 <mbedtls_md_hmac_finish+0x4c>
 c0569f2:	6803      	ldr	r3, [r0, #0]
 c0569f4:	b1f3      	cbz	r3, c056a34 <mbedtls_md_hmac_finish+0x4c>
 c0569f6:	6886      	ldr	r6, [r0, #8]
 c0569f8:	b1e6      	cbz	r6, c056a34 <mbedtls_md_hmac_finish+0x4c>
        return( MBEDTLS_ERR_MD_BAD_INPUT_DATA );

    opad = (unsigned char *) ctx->hmac_ctx + ctx->md_info->block_size;

    if( ( ret = mbedtls_md_finish( ctx, tmp ) ) != 0 )
 c0569fa:	4669      	mov	r1, sp
    opad = (unsigned char *) ctx->hmac_ctx + ctx->md_info->block_size;
 c0569fc:	799f      	ldrb	r7, [r3, #6]
    if( ( ret = mbedtls_md_finish( ctx, tmp ) ) != 0 )
 c0569fe:	f7ff ff4f 	bl	c0568a0 <mbedtls_md_finish>
 c056a02:	b9a8      	cbnz	r0, c056a30 <mbedtls_md_hmac_finish+0x48>
        return( ret );
    if( ( ret = mbedtls_md_starts( ctx ) ) != 0 )
 c056a04:	4620      	mov	r0, r4
 c056a06:	f7ff ff19 	bl	c05683c <mbedtls_md_starts>
 c056a0a:	b988      	cbnz	r0, c056a30 <mbedtls_md_hmac_finish+0x48>
        return( ret );
    if( ( ret = mbedtls_md_update( ctx, opad,
                                   ctx->md_info->block_size ) ) != 0 )
 c056a0c:	6823      	ldr	r3, [r4, #0]
    if( ( ret = mbedtls_md_update( ctx, opad,
 c056a0e:	4620      	mov	r0, r4
 c056a10:	799a      	ldrb	r2, [r3, #6]
 c056a12:	19f1      	adds	r1, r6, r7
 c056a14:	f7ff ff2e 	bl	c056874 <mbedtls_md_update>
 c056a18:	b950      	cbnz	r0, c056a30 <mbedtls_md_hmac_finish+0x48>
        return( ret );
    if( ( ret = mbedtls_md_update( ctx, tmp,
                                   ctx->md_info->size ) ) != 0 )
 c056a1a:	6823      	ldr	r3, [r4, #0]
    if( ( ret = mbedtls_md_update( ctx, tmp,
 c056a1c:	4669      	mov	r1, sp
 c056a1e:	4620      	mov	r0, r4
 c056a20:	795a      	ldrb	r2, [r3, #5]
 c056a22:	f7ff ff27 	bl	c056874 <mbedtls_md_update>
 c056a26:	b918      	cbnz	r0, c056a30 <mbedtls_md_hmac_finish+0x48>
        return( ret );
    return( mbedtls_md_finish( ctx, output ) );
 c056a28:	4629      	mov	r1, r5
 c056a2a:	4620      	mov	r0, r4
 c056a2c:	f7ff ff38 	bl	c0568a0 <mbedtls_md_finish>
}
 c056a30:	b011      	add	sp, #68	@ 0x44
 c056a32:	bdf0      	pop	{r4, r5, r6, r7, pc}
        return( MBEDTLS_ERR_MD_BAD_INPUT_DATA );
 c056a34:	4800      	ldr	r0, [pc, #0]	@ (c056a38 <mbedtls_md_hmac_finish+0x50>)
 c056a36:	e7fb      	b.n	c056a30 <mbedtls_md_hmac_finish+0x48>
 c056a38:	ffffaf00 	.word	0xffffaf00

0c056a3c <mbedtls_md_hmac_reset>:

int mbedtls_md_hmac_reset( mbedtls_md_context_t *ctx )
{
 c056a3c:	b538      	push	{r3, r4, r5, lr}
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    unsigned char *ipad;

    if( ctx == NULL || ctx->md_info == NULL || ctx->hmac_ctx == NULL )
 c056a3e:	4604      	mov	r4, r0
 c056a40:	b170      	cbz	r0, c056a60 <mbedtls_md_hmac_reset+0x24>
 c056a42:	6803      	ldr	r3, [r0, #0]
 c056a44:	b163      	cbz	r3, c056a60 <mbedtls_md_hmac_reset+0x24>
 c056a46:	6885      	ldr	r5, [r0, #8]
 c056a48:	b155      	cbz	r5, c056a60 <mbedtls_md_hmac_reset+0x24>
        return( MBEDTLS_ERR_MD_BAD_INPUT_DATA );

    ipad = (unsigned char *) ctx->hmac_ctx;

    if( ( ret = mbedtls_md_starts( ctx ) ) != 0 )
 c056a4a:	f7ff fef7 	bl	c05683c <mbedtls_md_starts>
 c056a4e:	b940      	cbnz	r0, c056a62 <mbedtls_md_hmac_reset+0x26>
        return( ret );
    return( mbedtls_md_update( ctx, ipad, ctx->md_info->block_size ) );
 c056a50:	6823      	ldr	r3, [r4, #0]
 c056a52:	4629      	mov	r1, r5
 c056a54:	4620      	mov	r0, r4
 c056a56:	799a      	ldrb	r2, [r3, #6]
}
 c056a58:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    return( mbedtls_md_update( ctx, ipad, ctx->md_info->block_size ) );
 c056a5c:	f7ff bf0a 	b.w	c056874 <mbedtls_md_update>
        return( MBEDTLS_ERR_MD_BAD_INPUT_DATA );
 c056a60:	4800      	ldr	r0, [pc, #0]	@ (c056a64 <mbedtls_md_hmac_reset+0x28>)
}
 c056a62:	bd38      	pop	{r3, r4, r5, pc}
 c056a64:	ffffaf00 	.word	0xffffaf00

0c056a68 <mbedtls_md_get_size>:
    }
}

unsigned char mbedtls_md_get_size( const mbedtls_md_info_t *md_info )
{
    if( md_info == NULL )
 c056a68:	b100      	cbz	r0, c056a6c <mbedtls_md_get_size+0x4>
        return( 0 );

    return md_info->size;
 c056a6a:	7940      	ldrb	r0, [r0, #5]
}
 c056a6c:	4770      	bx	lr

0c056a6e <mbedtls_md_get_type>:

mbedtls_md_type_t mbedtls_md_get_type( const mbedtls_md_info_t *md_info )
{
    if( md_info == NULL )
 c056a6e:	b100      	cbz	r0, c056a72 <mbedtls_md_get_type+0x4>
        return( MBEDTLS_MD_NONE );

    return md_info->type;
 c056a70:	7900      	ldrb	r0, [r0, #4]
}
 c056a72:	4770      	bx	lr

0c056a74 <verify_header>:
}
#endif /* MBEDTLS_MEMORY_DEBUG */

static int verify_header( memory_header *hdr )
{
    if( hdr->magic1 != MAGIC1 )
 c056a74:	6801      	ldr	r1, [r0, #0]
 c056a76:	4a0e      	ldr	r2, [pc, #56]	@ (c056ab0 <verify_header+0x3c>)
{
 c056a78:	4603      	mov	r3, r0
    if( hdr->magic1 != MAGIC1 )
 c056a7a:	4291      	cmp	r1, r2
 c056a7c:	d115      	bne.n	c056aaa <verify_header+0x36>
        mbedtls_fprintf( stderr, "FATAL: MAGIC1 mismatch\n" );
#endif
        return( 1 );
    }

    if( hdr->magic2 != MAGIC2 )
 c056a7e:	69c1      	ldr	r1, [r0, #28]
 c056a80:	f1a2 2210 	sub.w	r2, r2, #268439552	@ 0x10001000
 c056a84:	f1a2 12ef 	sub.w	r2, r2, #15663343	@ 0xef00ef
 c056a88:	4291      	cmp	r1, r2
 c056a8a:	d10e      	bne.n	c056aaa <verify_header+0x36>
        mbedtls_fprintf( stderr, "FATAL: MAGIC2 mismatch\n" );
#endif
        return( 1 );
    }

    if( hdr->alloc > 1 )
 c056a8c:	6882      	ldr	r2, [r0, #8]
 c056a8e:	2a01      	cmp	r2, #1
 c056a90:	d80b      	bhi.n	c056aaa <verify_header+0x36>
        mbedtls_fprintf( stderr, "FATAL: alloc has illegal value\n" );
#endif
        return( 1 );
    }

    if( hdr->prev != NULL && hdr->prev == hdr->next )
 c056a92:	68c2      	ldr	r2, [r0, #12]
 c056a94:	b112      	cbz	r2, c056a9c <verify_header+0x28>
 c056a96:	6901      	ldr	r1, [r0, #16]
 c056a98:	428a      	cmp	r2, r1
 c056a9a:	d006      	beq.n	c056aaa <verify_header+0x36>
        mbedtls_fprintf( stderr, "FATAL: prev == next\n" );
#endif
        return( 1 );
    }

    if( hdr->prev_free != NULL && hdr->prev_free == hdr->next_free )
 c056a9c:	6958      	ldr	r0, [r3, #20]
 c056a9e:	b128      	cbz	r0, c056aac <verify_header+0x38>
 c056aa0:	699b      	ldr	r3, [r3, #24]
 c056aa2:	1a1b      	subs	r3, r3, r0
 c056aa4:	4258      	negs	r0, r3
 c056aa6:	4158      	adcs	r0, r3
 c056aa8:	4770      	bx	lr
        return( 1 );
 c056aaa:	2001      	movs	r0, #1
#endif
        return( 1 );
    }

    return( 0 );
}
 c056aac:	4770      	bx	lr
 c056aae:	bf00      	nop
 c056ab0:	ff00aa55 	.word	0xff00aa55

0c056ab4 <verify_chain>:

static int verify_chain( void )
{
    memory_header *prv = heap.first, *cur;
 c056ab4:	4b0d      	ldr	r3, [pc, #52]	@ (c056aec <verify_chain+0x38>)
{
 c056ab6:	b570      	push	{r4, r5, r6, lr}
    memory_header *prv = heap.first, *cur;
 c056ab8:	689e      	ldr	r6, [r3, #8]

    if( prv == NULL || verify_header( prv ) != 0 )
 c056aba:	b1a6      	cbz	r6, c056ae6 <verify_chain+0x32>
 c056abc:	4630      	mov	r0, r6
 c056abe:	f7ff ffd9 	bl	c056a74 <verify_header>
 c056ac2:	4604      	mov	r4, r0
 c056ac4:	b978      	cbnz	r0, c056ae6 <verify_chain+0x32>
                                  "failed\n" );
#endif
        return( 1 );
    }

    if( heap.first->prev != NULL )
 c056ac6:	68f3      	ldr	r3, [r6, #12]
 c056ac8:	b96b      	cbnz	r3, c056ae6 <verify_chain+0x32>
                                  "first->prev != NULL\n" );
#endif
        return( 1 );
    }

    cur = heap.first->next;
 c056aca:	6935      	ldr	r5, [r6, #16]

    while( cur != NULL )
 c056acc:	b90d      	cbnz	r5, c056ad2 <verify_chain+0x1e>
        prv = cur;
        cur = cur->next;
    }

    return( 0 );
}
 c056ace:	4620      	mov	r0, r4
 c056ad0:	bd70      	pop	{r4, r5, r6, pc}
        if( verify_header( cur ) != 0 )
 c056ad2:	4628      	mov	r0, r5
 c056ad4:	f7ff ffce 	bl	c056a74 <verify_header>
 c056ad8:	b928      	cbnz	r0, c056ae6 <verify_chain+0x32>
        if( cur->prev != prv )
 c056ada:	68eb      	ldr	r3, [r5, #12]
 c056adc:	42b3      	cmp	r3, r6
 c056ade:	d102      	bne.n	c056ae6 <verify_chain+0x32>
        cur = cur->next;
 c056ae0:	462e      	mov	r6, r5
 c056ae2:	692d      	ldr	r5, [r5, #16]
 c056ae4:	e7f2      	b.n	c056acc <verify_chain+0x18>
        return( 1 );
 c056ae6:	2401      	movs	r4, #1
 c056ae8:	e7f1      	b.n	c056ace <verify_chain+0x1a>
 c056aea:	bf00      	nop
 c056aec:	30030ee8 	.word	0x30030ee8

0c056af0 <buffer_alloc_calloc>:

static void *buffer_alloc_calloc( size_t n, size_t size )
{
 c056af0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    memory_header *new, *cur = heap.first_free;
 c056af4:	4d39      	ldr	r5, [pc, #228]	@ (c056bdc <buffer_alloc_calloc+0xec>)
#if defined(MBEDTLS_MEMORY_BACKTRACE)
    void *trace_buffer[MAX_BT];
    size_t trace_cnt;
#endif

    if( heap.buf == NULL || heap.first == NULL )
 c056af6:	682b      	ldr	r3, [r5, #0]
    memory_header *new, *cur = heap.first_free;
 c056af8:	68ee      	ldr	r6, [r5, #12]
    if( heap.buf == NULL || heap.first == NULL )
 c056afa:	b1d3      	cbz	r3, c056b32 <buffer_alloc_calloc+0x42>
 c056afc:	68ab      	ldr	r3, [r5, #8]
 c056afe:	b1c3      	cbz	r3, c056b32 <buffer_alloc_calloc+0x42>
        return( NULL );

    original_len = len = n * size;

    if( n == 0 || size == 0 || len / n != size )
 c056b00:	2800      	cmp	r0, #0
 c056b02:	d061      	beq.n	c056bc8 <buffer_alloc_calloc+0xd8>
 c056b04:	2900      	cmp	r1, #0
 c056b06:	d05f      	beq.n	c056bc8 <buffer_alloc_calloc+0xd8>
    original_len = len = n * size;
 c056b08:	fb01 f400 	mul.w	r4, r1, r0
    if( n == 0 || size == 0 || len / n != size )
 c056b0c:	fbb4 f0f0 	udiv	r0, r4, r0
 c056b10:	4288      	cmp	r0, r1
 c056b12:	d159      	bne.n	c056bc8 <buffer_alloc_calloc+0xd8>
        return( NULL );
    else if( len > (size_t)-MBEDTLS_MEMORY_ALIGN_MULTIPLE )
 c056b14:	1d21      	adds	r1, r4, #4
 c056b16:	d857      	bhi.n	c056bc8 <buffer_alloc_calloc+0xd8>
        return( NULL );

    if( len % MBEDTLS_MEMORY_ALIGN_MULTIPLE )
 c056b18:	07a2      	lsls	r2, r4, #30
 c056b1a:	d00d      	beq.n	c056b38 <buffer_alloc_calloc+0x48>
    {
        len -= len % MBEDTLS_MEMORY_ALIGN_MULTIPLE;
 c056b1c:	f024 0203 	bic.w	r2, r4, #3
        len += MBEDTLS_MEMORY_ALIGN_MULTIPLE;
 c056b20:	3204      	adds	r2, #4
 c056b22:	4633      	mov	r3, r6
 c056b24:	e003      	b.n	c056b2e <buffer_alloc_calloc+0x3e>

    // Find block that fits
    //
    while( cur != NULL )
    {
        if( cur->size >= len )
 c056b26:	6858      	ldr	r0, [r3, #4]
 c056b28:	4290      	cmp	r0, r2
 c056b2a:	d24f      	bcs.n	c056bcc <buffer_alloc_calloc+0xdc>
            break;

        cur = cur->next_free;
 c056b2c:	699b      	ldr	r3, [r3, #24]
    while( cur != NULL )
 c056b2e:	2b00      	cmp	r3, #0
 c056b30:	d1f9      	bne.n	c056b26 <buffer_alloc_calloc+0x36>

    ret = (unsigned char *) cur + sizeof( memory_header );
    memset( ret, 0, original_len );

    return( ret );
}
 c056b32:	4618      	mov	r0, r3
 c056b34:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 c056b38:	4622      	mov	r2, r4
 c056b3a:	e7f2      	b.n	c056b22 <buffer_alloc_calloc+0x32>
    if( cur->size - len < sizeof(memory_header) +
 c056b3c:	1a80      	subs	r0, r0, r2
 c056b3e:	2823      	cmp	r0, #35	@ 0x23
 c056b40:	f103 0620 	add.w	r6, r3, #32
            cur->prev_free->next_free = cur->next_free;
 c056b44:	e9d3 7c05 	ldrd	r7, ip, [r3, #20]
    if( cur->size - len < sizeof(memory_header) +
 c056b48:	d81a      	bhi.n	c056b80 <buffer_alloc_calloc+0x90>
        cur->alloc = 1;
 c056b4a:	2201      	movs	r2, #1
 c056b4c:	609a      	str	r2, [r3, #8]
        if( cur->prev_free != NULL )
 c056b4e:	b1a7      	cbz	r7, c056b7a <buffer_alloc_calloc+0x8a>
            cur->prev_free->next_free = cur->next_free;
 c056b50:	f8c7 c018 	str.w	ip, [r7, #24]
        if( cur->next_free != NULL )
 c056b54:	699a      	ldr	r2, [r3, #24]
 c056b56:	b102      	cbz	r2, c056b5a <buffer_alloc_calloc+0x6a>
            cur->next_free->prev_free = cur->prev_free;
 c056b58:	6157      	str	r7, [r2, #20]
    cur->prev_free = NULL;
 c056b5a:	2200      	movs	r2, #0
    cur->next_free = NULL;
 c056b5c:	e9c3 2205 	strd	r2, r2, [r3, #20]
    if( ( heap.verify & MBEDTLS_MEMORY_VERIFY_ALLOC ) && verify_chain() != 0 )
 c056b60:	692b      	ldr	r3, [r5, #16]
 c056b62:	07db      	lsls	r3, r3, #31
 c056b64:	d502      	bpl.n	c056b6c <buffer_alloc_calloc+0x7c>
 c056b66:	f7ff ffa5 	bl	c056ab4 <verify_chain>
 c056b6a:	bba0      	cbnz	r0, c056bd6 <buffer_alloc_calloc+0xe6>
    memset( ret, 0, original_len );
 c056b6c:	4622      	mov	r2, r4
 c056b6e:	2100      	movs	r1, #0
 c056b70:	4630      	mov	r0, r6
 c056b72:	f004 fddc 	bl	c05b72e <memset>
 c056b76:	4603      	mov	r3, r0
    return( ret );
 c056b78:	e7db      	b.n	c056b32 <buffer_alloc_calloc+0x42>
            heap.first_free = cur->next_free;
 c056b7a:	f8c5 c00c 	str.w	ip, [r5, #12]
 c056b7e:	e7e9      	b.n	c056b54 <buffer_alloc_calloc+0x64>
    p = ( (unsigned char *) cur ) + sizeof(memory_header) + len;
 c056b80:	f102 0820 	add.w	r8, r2, #32
 c056b84:	eb03 0108 	add.w	r1, r3, r8
    new->size = cur->size - len - sizeof(memory_header);
 c056b88:	3820      	subs	r0, #32
    new->alloc = 0;
 c056b8a:	e9c1 0e01 	strd	r0, lr, [r1, #4]
    new->next = cur->next;
 c056b8e:	6918      	ldr	r0, [r3, #16]
    new->magic1 = MAGIC1;
 c056b90:	f8df e04c 	ldr.w	lr, [pc, #76]	@ c056be0 <buffer_alloc_calloc+0xf0>
    new->prev = cur;
 c056b94:	60cb      	str	r3, [r1, #12]
    new->next = cur->next;
 c056b96:	6108      	str	r0, [r1, #16]
    new->magic1 = MAGIC1;
 c056b98:	f843 e008 	str.w	lr, [r3, r8]
    new->magic2 = MAGIC2;
 c056b9c:	f1ae 2e10 	sub.w	lr, lr, #268439552	@ 0x10001000
 c056ba0:	f1ae 1eef 	sub.w	lr, lr, #15663343	@ 0xef00ef
 c056ba4:	f8c1 e01c 	str.w	lr, [r1, #28]
    if( new->next != NULL )
 c056ba8:	b100      	cbz	r0, c056bac <buffer_alloc_calloc+0xbc>
        new->next->prev = new;
 c056baa:	60c1      	str	r1, [r0, #12]
    new->next_free = cur->next_free;
 c056bac:	e9c1 7c05 	strd	r7, ip, [r1, #20]
    if( new->prev_free != NULL )
 c056bb0:	b147      	cbz	r7, c056bc4 <buffer_alloc_calloc+0xd4>
        new->prev_free->next_free = new;
 c056bb2:	61b9      	str	r1, [r7, #24]
    if( new->next_free != NULL )
 c056bb4:	6988      	ldr	r0, [r1, #24]
 c056bb6:	b100      	cbz	r0, c056bba <buffer_alloc_calloc+0xca>
        new->next_free->prev_free = new;
 c056bb8:	6141      	str	r1, [r0, #20]
    cur->alloc = 1;
 c056bba:	2001      	movs	r0, #1
    cur->next = new;
 c056bbc:	6119      	str	r1, [r3, #16]
    cur->size = len;
 c056bbe:	e9c3 2001 	strd	r2, r0, [r3, #4]
    cur->next = new;
 c056bc2:	e7ca      	b.n	c056b5a <buffer_alloc_calloc+0x6a>
        heap.first_free = new;
 c056bc4:	60e9      	str	r1, [r5, #12]
 c056bc6:	e7f5      	b.n	c056bb4 <buffer_alloc_calloc+0xc4>
        return( NULL );
 c056bc8:	2300      	movs	r3, #0
 c056bca:	e7b2      	b.n	c056b32 <buffer_alloc_calloc+0x42>
    if( cur->alloc != 0 )
 c056bcc:	f8d3 e008 	ldr.w	lr, [r3, #8]
 c056bd0:	f1be 0f00 	cmp.w	lr, #0
 c056bd4:	d0b2      	beq.n	c056b3c <buffer_alloc_calloc+0x4c>
        mbedtls_exit( 1 );
 c056bd6:	2001      	movs	r0, #1
 c056bd8:	f7eb fa7e 	bl	c0420d8 <exit>
 c056bdc:	30030ee8 	.word	0x30030ee8
 c056be0:	ff00aa55 	.word	0xff00aa55

0c056be4 <buffer_alloc_free>:

static void buffer_alloc_free( void *ptr )
{
 c056be4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    memory_header *hdr, *old = NULL;
    unsigned char *p = (unsigned char *) ptr;

    if( ptr == NULL || heap.buf == NULL || heap.first == NULL )
 c056be6:	4605      	mov	r5, r0
 c056be8:	2800      	cmp	r0, #0
 c056bea:	d05c      	beq.n	c056ca6 <buffer_alloc_free+0xc2>
 c056bec:	4f38      	ldr	r7, [pc, #224]	@ (c056cd0 <buffer_alloc_free+0xec>)
 c056bee:	683b      	ldr	r3, [r7, #0]
 c056bf0:	2b00      	cmp	r3, #0
 c056bf2:	d058      	beq.n	c056ca6 <buffer_alloc_free+0xc2>
 c056bf4:	68ba      	ldr	r2, [r7, #8]
 c056bf6:	2a00      	cmp	r2, #0
 c056bf8:	d055      	beq.n	c056ca6 <buffer_alloc_free+0xc2>
        return;

    if( p < heap.buf || p >= heap.buf + heap.len )
 c056bfa:	4283      	cmp	r3, r0
 c056bfc:	d803      	bhi.n	c056c06 <buffer_alloc_free+0x22>
 c056bfe:	687a      	ldr	r2, [r7, #4]
 c056c00:	4413      	add	r3, r2
 c056c02:	4298      	cmp	r0, r3
 c056c04:	d302      	bcc.n	c056c0c <buffer_alloc_free+0x28>
    {
#if defined(MBEDTLS_MEMORY_DEBUG)
        mbedtls_fprintf( stderr, "FATAL: mbedtls_free() outside of managed "
                                  "space\n" );
#endif
        mbedtls_exit( 1 );
 c056c06:	2001      	movs	r0, #1
 c056c08:	f7eb fa66 	bl	c0420d8 <exit>
    }

    p -= sizeof(memory_header);
 c056c0c:	f1a0 0420 	sub.w	r4, r0, #32
    hdr = (memory_header *) p;

    if( verify_header( hdr ) != 0 )
 c056c10:	4620      	mov	r0, r4
 c056c12:	f7ff ff2f 	bl	c056a74 <verify_header>
 c056c16:	2800      	cmp	r0, #0
 c056c18:	d1f5      	bne.n	c056c06 <buffer_alloc_free+0x22>
        mbedtls_exit( 1 );

    if( hdr->alloc != 1 )
 c056c1a:	f855 3c18 	ldr.w	r3, [r5, #-24]
 c056c1e:	2b01      	cmp	r3, #1
 c056c20:	d1f1      	bne.n	c056c06 <buffer_alloc_free+0x22>
    hdr->trace_count = 0;
#endif

    // Regroup with block before
    //
    if( hdr->prev != NULL && hdr->prev->alloc == 0 )
 c056c22:	f855 6c14 	ldr.w	r6, [r5, #-20]
    hdr->alloc = 0;
 c056c26:	f845 0c18 	str.w	r0, [r5, #-24]
    if( hdr->prev != NULL && hdr->prev->alloc == 0 )
 c056c2a:	b1ae      	cbz	r6, c056c58 <buffer_alloc_free+0x74>
 c056c2c:	68b3      	ldr	r3, [r6, #8]
 c056c2e:	2b00      	cmp	r3, #0
 c056c30:	d13a      	bne.n	c056ca8 <buffer_alloc_free+0xc4>
    {
#if defined(MBEDTLS_MEMORY_DEBUG)
        heap.header_count--;
#endif
        hdr->prev->size += sizeof(memory_header) + hdr->size;
 c056c32:	f855 3c1c 	ldr.w	r3, [r5, #-28]
 c056c36:	f103 0220 	add.w	r2, r3, #32
 c056c3a:	6873      	ldr	r3, [r6, #4]
 c056c3c:	4413      	add	r3, r2
 c056c3e:	6073      	str	r3, [r6, #4]
        hdr->prev->next = hdr->next;
 c056c40:	f855 3c10 	ldr.w	r3, [r5, #-16]
 c056c44:	6133      	str	r3, [r6, #16]
        old = hdr;
        hdr = hdr->prev;

        if( hdr->next != NULL )
 c056c46:	b103      	cbz	r3, c056c4a <buffer_alloc_free+0x66>
            hdr->next->prev = hdr;
 c056c48:	60de      	str	r6, [r3, #12]

        memset( old, 0, sizeof(memory_header) );
 c056c4a:	4620      	mov	r0, r4
 c056c4c:	2220      	movs	r2, #32
 c056c4e:	2100      	movs	r1, #0
 c056c50:	f004 fd6d 	bl	c05b72e <memset>
 c056c54:	4634      	mov	r4, r6
 c056c56:	4606      	mov	r6, r0
    }

    // Regroup with block after
    //
    if( hdr->next != NULL && hdr->next->alloc == 0 )
 c056c58:	6920      	ldr	r0, [r4, #16]
 c056c5a:	2800      	cmp	r0, #0
 c056c5c:	d030      	beq.n	c056cc0 <buffer_alloc_free+0xdc>
 c056c5e:	6883      	ldr	r3, [r0, #8]
 c056c60:	2b00      	cmp	r3, #0
 c056c62:	d12d      	bne.n	c056cc0 <buffer_alloc_free+0xdc>
    {
#if defined(MBEDTLS_MEMORY_DEBUG)
        heap.header_count--;
#endif
        hdr->size += sizeof(memory_header) + hdr->next->size;
 c056c64:	6863      	ldr	r3, [r4, #4]
 c056c66:	6842      	ldr	r2, [r0, #4]
 c056c68:	3320      	adds	r3, #32
 c056c6a:	4413      	add	r3, r2
 c056c6c:	6063      	str	r3, [r4, #4]
        old = hdr->next;
        hdr->next = hdr->next->next;
 c056c6e:	6903      	ldr	r3, [r0, #16]

        if( hdr->prev_free != NULL || hdr->next_free != NULL )
 c056c70:	e9d4 2105 	ldrd	r2, r1, [r4, #20]
        hdr->next = hdr->next->next;
 c056c74:	6123      	str	r3, [r4, #16]
        if( hdr->prev_free != NULL || hdr->next_free != NULL )
 c056c76:	b9ca      	cbnz	r2, c056cac <buffer_alloc_free+0xc8>
 c056c78:	b9f1      	cbnz	r1, c056cb8 <buffer_alloc_free+0xd4>

            if( hdr->next_free != NULL )
                hdr->next_free->prev_free = hdr->prev_free;
        }

        hdr->prev_free = old->prev_free;
 c056c7a:	6942      	ldr	r2, [r0, #20]
        hdr->next_free = old->next_free;
 c056c7c:	6981      	ldr	r1, [r0, #24]
        hdr->prev_free = old->prev_free;
 c056c7e:	6162      	str	r2, [r4, #20]
        hdr->next_free = old->next_free;
 c056c80:	61a1      	str	r1, [r4, #24]

        if( hdr->prev_free != NULL )
 c056c82:	b1da      	cbz	r2, c056cbc <buffer_alloc_free+0xd8>
            hdr->prev_free->next_free = hdr;
 c056c84:	6194      	str	r4, [r2, #24]
        else
            heap.first_free = hdr;

        if( hdr->next_free != NULL )
 c056c86:	69a2      	ldr	r2, [r4, #24]
 c056c88:	b102      	cbz	r2, c056c8c <buffer_alloc_free+0xa8>
            hdr->next_free->prev_free = hdr;
 c056c8a:	6154      	str	r4, [r2, #20]

        if( hdr->next != NULL )
 c056c8c:	b103      	cbz	r3, c056c90 <buffer_alloc_free+0xac>
            hdr->next->prev = hdr;
 c056c8e:	60dc      	str	r4, [r3, #12]

        memset( old, 0, sizeof(memory_header) );
 c056c90:	2220      	movs	r2, #32
 c056c92:	2100      	movs	r1, #0
 c056c94:	f004 fd4b 	bl	c05b72e <memset>
        if( heap.first_free != NULL )
            heap.first_free->prev_free = hdr;
        heap.first_free = hdr;
    }

    if( ( heap.verify & MBEDTLS_MEMORY_VERIFY_FREE ) && verify_chain() != 0 )
 c056c98:	693b      	ldr	r3, [r7, #16]
 c056c9a:	079b      	lsls	r3, r3, #30
 c056c9c:	d503      	bpl.n	c056ca6 <buffer_alloc_free+0xc2>
 c056c9e:	f7ff ff09 	bl	c056ab4 <verify_chain>
 c056ca2:	2800      	cmp	r0, #0
 c056ca4:	d1af      	bne.n	c056c06 <buffer_alloc_free+0x22>
        mbedtls_exit( 1 );
}
 c056ca6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    memory_header *hdr, *old = NULL;
 c056ca8:	4606      	mov	r6, r0
 c056caa:	e7d5      	b.n	c056c58 <buffer_alloc_free+0x74>
                hdr->prev_free->next_free = hdr->next_free;
 c056cac:	6191      	str	r1, [r2, #24]
            if( hdr->next_free != NULL )
 c056cae:	69a1      	ldr	r1, [r4, #24]
 c056cb0:	2900      	cmp	r1, #0
 c056cb2:	d0e2      	beq.n	c056c7a <buffer_alloc_free+0x96>
                hdr->next_free->prev_free = hdr->prev_free;
 c056cb4:	614a      	str	r2, [r1, #20]
 c056cb6:	e7e0      	b.n	c056c7a <buffer_alloc_free+0x96>
                heap.first_free = hdr->next_free;
 c056cb8:	60f9      	str	r1, [r7, #12]
 c056cba:	e7f8      	b.n	c056cae <buffer_alloc_free+0xca>
            heap.first_free = hdr;
 c056cbc:	60fc      	str	r4, [r7, #12]
 c056cbe:	e7e2      	b.n	c056c86 <buffer_alloc_free+0xa2>
    if( old == NULL )
 c056cc0:	2e00      	cmp	r6, #0
 c056cc2:	d1e9      	bne.n	c056c98 <buffer_alloc_free+0xb4>
        hdr->next_free = heap.first_free;
 c056cc4:	68fb      	ldr	r3, [r7, #12]
 c056cc6:	61a3      	str	r3, [r4, #24]
        if( heap.first_free != NULL )
 c056cc8:	b103      	cbz	r3, c056ccc <buffer_alloc_free+0xe8>
            heap.first_free->prev_free = hdr;
 c056cca:	615c      	str	r4, [r3, #20]
        heap.first_free = hdr;
 c056ccc:	60fc      	str	r4, [r7, #12]
 c056cce:	e7e3      	b.n	c056c98 <buffer_alloc_free+0xb4>
 c056cd0:	30030ee8 	.word	0x30030ee8

0c056cd4 <mbedtls_memory_buffer_alloc_init>:
    (void) mbedtls_mutex_unlock( &heap.mutex );
}
#endif /* MBEDTLS_THREADING_C */

void mbedtls_memory_buffer_alloc_init( unsigned char *buf, size_t len )
{
 c056cd4:	b538      	push	{r3, r4, r5, lr}
 c056cd6:	460d      	mov	r5, r1
    memset( &heap, 0, sizeof( buffer_alloc_ctx ) );
 c056cd8:	2214      	movs	r2, #20
 c056cda:	2100      	movs	r1, #0
{
 c056cdc:	4604      	mov	r4, r0
    memset( &heap, 0, sizeof( buffer_alloc_ctx ) );
 c056cde:	4812      	ldr	r0, [pc, #72]	@ (c056d28 <mbedtls_memory_buffer_alloc_init+0x54>)
 c056ce0:	f004 fd25 	bl	c05b72e <memset>
#if defined(MBEDTLS_THREADING_C)
    mbedtls_mutex_init( &heap.mutex );
    mbedtls_platform_set_calloc_free( buffer_alloc_calloc_mutexed,
                              buffer_alloc_free_mutexed );
#else
    mbedtls_platform_set_calloc_free( buffer_alloc_calloc, buffer_alloc_free );
 c056ce4:	4911      	ldr	r1, [pc, #68]	@ (c056d2c <mbedtls_memory_buffer_alloc_init+0x58>)
 c056ce6:	4812      	ldr	r0, [pc, #72]	@ (c056d30 <mbedtls_memory_buffer_alloc_init+0x5c>)
 c056ce8:	f7e4 fb68 	bl	c03b3bc <mbedtls_platform_set_calloc_free>
#endif

    if( len < sizeof( memory_header ) + MBEDTLS_MEMORY_ALIGN_MULTIPLE )
 c056cec:	2d23      	cmp	r5, #35	@ 0x23
 c056cee:	d91a      	bls.n	c056d26 <mbedtls_memory_buffer_alloc_init+0x52>
        return;
    else if( (size_t)buf % MBEDTLS_MEMORY_ALIGN_MULTIPLE )
 c056cf0:	f014 0303 	ands.w	r3, r4, #3
    {
        /* Adjust len first since buf is used in the computation */
        len -= MBEDTLS_MEMORY_ALIGN_MULTIPLE
 c056cf4:	bf1f      	itttt	ne
 c056cf6:	3d04      	subne	r5, #4
 c056cf8:	18ed      	addne	r5, r5, r3
             - (size_t)buf % MBEDTLS_MEMORY_ALIGN_MULTIPLE;
        buf += MBEDTLS_MEMORY_ALIGN_MULTIPLE
             - (size_t)buf % MBEDTLS_MEMORY_ALIGN_MULTIPLE;
 c056cfa:	f1c3 0304 	rsbne	r3, r3, #4
        buf += MBEDTLS_MEMORY_ALIGN_MULTIPLE
 c056cfe:	18e4      	addne	r4, r4, r3
    }

    memset( buf, 0, len );
 c056d00:	462a      	mov	r2, r5
 c056d02:	2100      	movs	r1, #0
 c056d04:	4620      	mov	r0, r4
 c056d06:	f004 fd12 	bl	c05b72e <memset>

    heap.buf = buf;
 c056d0a:	4b07      	ldr	r3, [pc, #28]	@ (c056d28 <mbedtls_memory_buffer_alloc_init+0x54>)
    heap.len = len;

    heap.first = (memory_header *)buf;
    heap.first->size = len - sizeof( memory_header );
    heap.first->magic1 = MAGIC1;
 c056d0c:	4a09      	ldr	r2, [pc, #36]	@ (c056d34 <mbedtls_memory_buffer_alloc_init+0x60>)
    heap.len = len;
 c056d0e:	e9c3 4500 	strd	r4, r5, [r3]
    heap.first = (memory_header *)buf;
 c056d12:	609c      	str	r4, [r3, #8]
    heap.first->magic1 = MAGIC1;
 c056d14:	6022      	str	r2, [r4, #0]
    heap.first->magic2 = MAGIC2;
 c056d16:	f1a2 2210 	sub.w	r2, r2, #268439552	@ 0x10001000
    heap.first->size = len - sizeof( memory_header );
 c056d1a:	3d20      	subs	r5, #32
    heap.first->magic2 = MAGIC2;
 c056d1c:	f1a2 12ef 	sub.w	r2, r2, #15663343	@ 0xef00ef
    heap.first->size = len - sizeof( memory_header );
 c056d20:	6065      	str	r5, [r4, #4]
    heap.first->magic2 = MAGIC2;
 c056d22:	61e2      	str	r2, [r4, #28]
    heap.first_free = heap.first;
 c056d24:	60dc      	str	r4, [r3, #12]
}
 c056d26:	bd38      	pop	{r3, r4, r5, pc}
 c056d28:	30030ee8 	.word	0x30030ee8
 c056d2c:	0c056be5 	.word	0x0c056be5
 c056d30:	0c056af1 	.word	0x0c056af1
 c056d34:	ff00aa55 	.word	0xff00aa55

0c056d38 <mbedtls_oid_get_pk_alg>:
        MBEDTLS_PK_NONE,
    },
};

FN_OID_TYPED_FROM_ASN1(oid_pk_alg_t, pk_alg, oid_pk_alg)
FN_OID_GET_ATTR1(mbedtls_oid_get_pk_alg, oid_pk_alg_t, pk_alg, mbedtls_pk_type_t, pk_alg)
 c056d38:	b570      	push	{r4, r5, r6, lr}
 c056d3a:	460e      	mov	r6, r1
FN_OID_TYPED_FROM_ASN1(oid_pk_alg_t, pk_alg, oid_pk_alg)
 c056d3c:	4605      	mov	r5, r0
 c056d3e:	b110      	cbz	r0, c056d46 <mbedtls_oid_get_pk_alg+0xe>
 c056d40:	4c09      	ldr	r4, [pc, #36]	@ (c056d68 <mbedtls_oid_get_pk_alg+0x30>)
 c056d42:	6820      	ldr	r0, [r4, #0]
 c056d44:	b910      	cbnz	r0, c056d4c <mbedtls_oid_get_pk_alg+0x14>
FN_OID_GET_ATTR1(mbedtls_oid_get_pk_alg, oid_pk_alg_t, pk_alg, mbedtls_pk_type_t, pk_alg)
 c056d46:	f06f 002d 	mvn.w	r0, #45	@ 0x2d
 c056d4a:	bd70      	pop	{r4, r5, r6, pc}
FN_OID_TYPED_FROM_ASN1(oid_pk_alg_t, pk_alg, oid_pk_alg)
 c056d4c:	686b      	ldr	r3, [r5, #4]
 c056d4e:	6862      	ldr	r2, [r4, #4]
 c056d50:	429a      	cmp	r2, r3
 c056d52:	d103      	bne.n	c056d5c <mbedtls_oid_get_pk_alg+0x24>
 c056d54:	68a9      	ldr	r1, [r5, #8]
 c056d56:	f004 fc69 	bl	c05b62c <memcmp>
 c056d5a:	b108      	cbz	r0, c056d60 <mbedtls_oid_get_pk_alg+0x28>
 c056d5c:	3414      	adds	r4, #20
 c056d5e:	e7f0      	b.n	c056d42 <mbedtls_oid_get_pk_alg+0xa>
FN_OID_GET_ATTR1(mbedtls_oid_get_pk_alg, oid_pk_alg_t, pk_alg, mbedtls_pk_type_t, pk_alg)
 c056d60:	7c23      	ldrb	r3, [r4, #16]
 c056d62:	7033      	strb	r3, [r6, #0]
 c056d64:	e7f1      	b.n	c056d4a <mbedtls_oid_get_pk_alg+0x12>
 c056d66:	bf00      	nop
 c056d68:	0c060ce0 	.word	0x0c060ce0

0c056d6c <mbedtls_oid_get_ec_grp>:
        MBEDTLS_ECP_DP_NONE,
    },
};

FN_OID_TYPED_FROM_ASN1(oid_ecp_grp_t, grp_id, oid_ecp_grp)
FN_OID_GET_ATTR1(mbedtls_oid_get_ec_grp, oid_ecp_grp_t, grp_id, mbedtls_ecp_group_id, grp_id)
 c056d6c:	b570      	push	{r4, r5, r6, lr}
 c056d6e:	460e      	mov	r6, r1
FN_OID_TYPED_FROM_ASN1(oid_ecp_grp_t, grp_id, oid_ecp_grp)
 c056d70:	4605      	mov	r5, r0
 c056d72:	b110      	cbz	r0, c056d7a <mbedtls_oid_get_ec_grp+0xe>
 c056d74:	4c09      	ldr	r4, [pc, #36]	@ (c056d9c <mbedtls_oid_get_ec_grp+0x30>)
 c056d76:	6820      	ldr	r0, [r4, #0]
 c056d78:	b910      	cbnz	r0, c056d80 <mbedtls_oid_get_ec_grp+0x14>
FN_OID_GET_ATTR1(mbedtls_oid_get_ec_grp, oid_ecp_grp_t, grp_id, mbedtls_ecp_group_id, grp_id)
 c056d7a:	f06f 002d 	mvn.w	r0, #45	@ 0x2d
 c056d7e:	bd70      	pop	{r4, r5, r6, pc}
FN_OID_TYPED_FROM_ASN1(oid_ecp_grp_t, grp_id, oid_ecp_grp)
 c056d80:	686b      	ldr	r3, [r5, #4]
 c056d82:	6862      	ldr	r2, [r4, #4]
 c056d84:	429a      	cmp	r2, r3
 c056d86:	d103      	bne.n	c056d90 <mbedtls_oid_get_ec_grp+0x24>
 c056d88:	68a9      	ldr	r1, [r5, #8]
 c056d8a:	f004 fc4f 	bl	c05b62c <memcmp>
 c056d8e:	b108      	cbz	r0, c056d94 <mbedtls_oid_get_ec_grp+0x28>
 c056d90:	3414      	adds	r4, #20
 c056d92:	e7f0      	b.n	c056d76 <mbedtls_oid_get_ec_grp+0xa>
FN_OID_GET_ATTR1(mbedtls_oid_get_ec_grp, oid_ecp_grp_t, grp_id, mbedtls_ecp_group_id, grp_id)
 c056d94:	7c23      	ldrb	r3, [r4, #16]
 c056d96:	7033      	strb	r3, [r6, #0]
 c056d98:	e7f1      	b.n	c056d7e <mbedtls_oid_get_ec_grp+0x12>
 c056d9a:	bf00      	nop
 c056d9c:	0c060bf0 	.word	0x0c060bf0

0c056da0 <mbedtls_oid_get_oid_by_ec_grp>:
FN_OID_GET_OID_BY_ATTR1(mbedtls_oid_get_oid_by_ec_grp, oid_ecp_grp_t, oid_ecp_grp, mbedtls_ecp_group_id, grp_id)
 c056da0:	b530      	push	{r4, r5, lr}
 c056da2:	4b08      	ldr	r3, [pc, #32]	@ (c056dc4 <mbedtls_oid_get_oid_by_ec_grp+0x24>)
 c056da4:	681c      	ldr	r4, [r3, #0]
 c056da6:	b914      	cbnz	r4, c056dae <mbedtls_oid_get_oid_by_ec_grp+0xe>
 c056da8:	f06f 002d 	mvn.w	r0, #45	@ 0x2d
 c056dac:	e006      	b.n	c056dbc <mbedtls_oid_get_oid_by_ec_grp+0x1c>
 c056dae:	7c1d      	ldrb	r5, [r3, #16]
 c056db0:	4285      	cmp	r5, r0
 c056db2:	d104      	bne.n	c056dbe <mbedtls_oid_get_oid_by_ec_grp+0x1e>
 c056db4:	2000      	movs	r0, #0
 c056db6:	685b      	ldr	r3, [r3, #4]
 c056db8:	600c      	str	r4, [r1, #0]
 c056dba:	6013      	str	r3, [r2, #0]
 c056dbc:	bd30      	pop	{r4, r5, pc}
 c056dbe:	3314      	adds	r3, #20
 c056dc0:	e7f0      	b.n	c056da4 <mbedtls_oid_get_oid_by_ec_grp+0x4>
 c056dc2:	bf00      	nop
 c056dc4:	0c060bf0 	.word	0x0c060bf0

0c056dc8 <mbedtls_oid_get_oid_by_md>:
    },
};

FN_OID_TYPED_FROM_ASN1(oid_md_alg_t, md_alg, oid_md_alg)
FN_OID_GET_ATTR1(mbedtls_oid_get_md_alg, oid_md_alg_t, md_alg, mbedtls_md_type_t, md_alg)
FN_OID_GET_OID_BY_ATTR1(mbedtls_oid_get_oid_by_md, oid_md_alg_t, oid_md_alg, mbedtls_md_type_t, md_alg)
 c056dc8:	b530      	push	{r4, r5, lr}
 c056dca:	4b08      	ldr	r3, [pc, #32]	@ (c056dec <mbedtls_oid_get_oid_by_md+0x24>)
 c056dcc:	681c      	ldr	r4, [r3, #0]
 c056dce:	b914      	cbnz	r4, c056dd6 <mbedtls_oid_get_oid_by_md+0xe>
 c056dd0:	f06f 002d 	mvn.w	r0, #45	@ 0x2d
 c056dd4:	e006      	b.n	c056de4 <mbedtls_oid_get_oid_by_md+0x1c>
 c056dd6:	7c1d      	ldrb	r5, [r3, #16]
 c056dd8:	4285      	cmp	r5, r0
 c056dda:	d104      	bne.n	c056de6 <mbedtls_oid_get_oid_by_md+0x1e>
 c056ddc:	2000      	movs	r0, #0
 c056dde:	685b      	ldr	r3, [r3, #4]
 c056de0:	600c      	str	r4, [r1, #0]
 c056de2:	6013      	str	r3, [r2, #0]
 c056de4:	bd30      	pop	{r4, r5, pc}
 c056de6:	3314      	adds	r3, #20
 c056de8:	e7f0      	b.n	c056dcc <mbedtls_oid_get_oid_by_md+0x4>
 c056dea:	bf00      	nop
 c056dec:	0c060b8c 	.word	0x0c060b8c

0c056df0 <mbedtls_pk_init>:
 */
void mbedtls_pk_init( mbedtls_pk_context *ctx )
{
    PK_VALIDATE( ctx != NULL );

    ctx->pk_info = NULL;
 c056df0:	2300      	movs	r3, #0
    ctx->pk_ctx = NULL;
 c056df2:	e9c0 3300 	strd	r3, r3, [r0]
}
 c056df6:	4770      	bx	lr

0c056df8 <mbedtls_pk_free>:

/*
 * Free (the components of) a mbedtls_pk_context
 */
void mbedtls_pk_free( mbedtls_pk_context *ctx )
{
 c056df8:	b510      	push	{r4, lr}
    if( ctx == NULL )
 c056dfa:	4604      	mov	r4, r0
 c056dfc:	b150      	cbz	r0, c056e14 <mbedtls_pk_free+0x1c>
        return;

    if ( ctx->pk_info != NULL )
 c056dfe:	6803      	ldr	r3, [r0, #0]
 c056e00:	b113      	cbz	r3, c056e08 <mbedtls_pk_free+0x10>
        ctx->pk_info->ctx_free_func( ctx->pk_ctx );
 c056e02:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 c056e04:	6840      	ldr	r0, [r0, #4]
 c056e06:	4798      	blx	r3

    mbedtls_platform_zeroize( ctx, sizeof( mbedtls_pk_context ) );
 c056e08:	4620      	mov	r0, r4
}
 c056e0a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mbedtls_platform_zeroize( ctx, sizeof( mbedtls_pk_context ) );
 c056e0e:	2108      	movs	r1, #8
 c056e10:	f7e4 bade 	b.w	c03b3d0 <mbedtls_platform_zeroize>
}
 c056e14:	bd10      	pop	{r4, pc}
	...

0c056e18 <mbedtls_pk_info_from_type>:
/*
 * Get pk_info structure from type
 */
const mbedtls_pk_info_t * mbedtls_pk_info_from_type( mbedtls_pk_type_t pk_type )
{
    switch( pk_type ) {
 c056e18:	3801      	subs	r0, #1
 c056e1a:	b2c0      	uxtb	r0, r0
 c056e1c:	2803      	cmp	r0, #3
 c056e1e:	bf9a      	itte	ls
 c056e20:	4b02      	ldrls	r3, [pc, #8]	@ (c056e2c <mbedtls_pk_info_from_type+0x14>)
 c056e22:	f853 0020 	ldrls.w	r0, [r3, r0, lsl #2]
{
 c056e26:	2000      	movhi	r0, #0
#endif
        /* MBEDTLS_PK_RSA_ALT omitted on purpose */
        default:
            return( NULL );
    }
}
 c056e28:	4770      	bx	lr
 c056e2a:	bf00      	nop
 c056e2c:	0c060d5c 	.word	0x0c060d5c

0c056e30 <mbedtls_pk_setup>:

/*
 * Initialise context
 */
int mbedtls_pk_setup( mbedtls_pk_context *ctx, const mbedtls_pk_info_t *info )
{
 c056e30:	b570      	push	{r4, r5, r6, lr}
 c056e32:	4605      	mov	r5, r0
    PK_VALIDATE_RET( ctx != NULL );
    if( info == NULL || ctx->pk_info != NULL )
 c056e34:	460e      	mov	r6, r1
 c056e36:	b141      	cbz	r1, c056e4a <mbedtls_pk_setup+0x1a>
 c056e38:	6804      	ldr	r4, [r0, #0]
 c056e3a:	b934      	cbnz	r4, c056e4a <mbedtls_pk_setup+0x1a>
        return( MBEDTLS_ERR_PK_BAD_INPUT_DATA );

    if( ( ctx->pk_ctx = info->ctx_alloc_func() ) == NULL )
 c056e3c:	6a4b      	ldr	r3, [r1, #36]	@ 0x24
 c056e3e:	4798      	blx	r3
 c056e40:	6068      	str	r0, [r5, #4]
 c056e42:	b120      	cbz	r0, c056e4e <mbedtls_pk_setup+0x1e>
        return( MBEDTLS_ERR_PK_ALLOC_FAILED );

    ctx->pk_info = info;

    return( 0 );
 c056e44:	4620      	mov	r0, r4
    ctx->pk_info = info;
 c056e46:	602e      	str	r6, [r5, #0]
}
 c056e48:	bd70      	pop	{r4, r5, r6, pc}
        return( MBEDTLS_ERR_PK_BAD_INPUT_DATA );
 c056e4a:	4802      	ldr	r0, [pc, #8]	@ (c056e54 <mbedtls_pk_setup+0x24>)
 c056e4c:	e7fc      	b.n	c056e48 <mbedtls_pk_setup+0x18>
        return( MBEDTLS_ERR_PK_ALLOC_FAILED );
 c056e4e:	4802      	ldr	r0, [pc, #8]	@ (c056e58 <mbedtls_pk_setup+0x28>)
 c056e50:	e7fa      	b.n	c056e48 <mbedtls_pk_setup+0x18>
 c056e52:	bf00      	nop
 c056e54:	ffffc180 	.word	0xffffc180
 c056e58:	ffffc080 	.word	0xffffc080

0c056e5c <mbedtls_pk_get_type>:
/*
 * Access the PK type
 */
mbedtls_pk_type_t mbedtls_pk_get_type( const mbedtls_pk_context *ctx )
{
    if( ctx == NULL || ctx->pk_info == NULL )
 c056e5c:	b110      	cbz	r0, c056e64 <mbedtls_pk_get_type+0x8>
 c056e5e:	6800      	ldr	r0, [r0, #0]
 c056e60:	b100      	cbz	r0, c056e64 <mbedtls_pk_get_type+0x8>
        return( MBEDTLS_PK_NONE );

    return( ctx->pk_info->type );
 c056e62:	7800      	ldrb	r0, [r0, #0]
}
 c056e64:	4770      	bx	lr

0c056e66 <rsa_can_do>:
#include <stdint.h>

#if defined(MBEDTLS_RSA_C)
static int rsa_can_do( mbedtls_pk_type_t type )
{
    return( type == MBEDTLS_PK_RSA ||
 c056e66:	2801      	cmp	r0, #1
 c056e68:	d002      	beq.n	c056e70 <rsa_can_do+0xa>
 c056e6a:	1f83      	subs	r3, r0, #6
 c056e6c:	4258      	negs	r0, r3
 c056e6e:	4158      	adcs	r0, r3
            type == MBEDTLS_PK_RSASSA_PSS );
}
 c056e70:	4770      	bx	lr
	...

0c056e74 <rsa_debug>:
    mbedtls_free( ctx );
}

static void rsa_debug( const void *ctx, mbedtls_pk_debug_item *items )
{
    items->type = MBEDTLS_PK_DEBUG_MPI;
 c056e74:	2301      	movs	r3, #1
    items->name = "rsa.N";
 c056e76:	4a06      	ldr	r2, [pc, #24]	@ (c056e90 <rsa_debug+0x1c>)
    items->type = MBEDTLS_PK_DEBUG_MPI;
 c056e78:	700b      	strb	r3, [r1, #0]
    items->value = &( ((mbedtls_rsa_context *) ctx)->N );

    items++;

    items->type = MBEDTLS_PK_DEBUG_MPI;
 c056e7a:	730b      	strb	r3, [r1, #12]
    items->name = "rsa.E";
 c056e7c:	4b05      	ldr	r3, [pc, #20]	@ (c056e94 <rsa_debug+0x20>)
    items->name = "rsa.N";
 c056e7e:	604a      	str	r2, [r1, #4]
    items->value = &( ((mbedtls_rsa_context *) ctx)->N );
 c056e80:	f100 0208 	add.w	r2, r0, #8
    items->value = &( ((mbedtls_rsa_context *) ctx)->E );
 c056e84:	3014      	adds	r0, #20
    items->value = &( ((mbedtls_rsa_context *) ctx)->N );
 c056e86:	608a      	str	r2, [r1, #8]
    items->name = "rsa.E";
 c056e88:	610b      	str	r3, [r1, #16]
    items->value = &( ((mbedtls_rsa_context *) ctx)->E );
 c056e8a:	6148      	str	r0, [r1, #20]
}
 c056e8c:	4770      	bx	lr
 c056e8e:	bf00      	nop
 c056e90:	0c060d6c 	.word	0x0c060d6c
 c056e94:	0c060d72 	.word	0x0c060d72

0c056e98 <eckey_can_do>:
 * Generic EC key
 */
static int eckey_can_do( mbedtls_pk_type_t type )
{
    return( type == MBEDTLS_PK_ECKEY ||
            type == MBEDTLS_PK_ECKEY_DH ||
 c056e98:	3802      	subs	r0, #2
            type == MBEDTLS_PK_ECDSA );
}
 c056e9a:	2802      	cmp	r0, #2
 c056e9c:	bf8c      	ite	hi
 c056e9e:	2000      	movhi	r0, #0
 c056ea0:	2001      	movls	r0, #1
 c056ea2:	4770      	bx	lr

0c056ea4 <eckey_get_bitlen>:

static size_t eckey_get_bitlen( const void *ctx )
{
    return( ((mbedtls_ecp_keypair *) ctx)->grp.pbits );
}
 c056ea4:	6d80      	ldr	r0, [r0, #88]	@ 0x58
 c056ea6:	4770      	bx	lr

0c056ea8 <eckey_debug>:
    mbedtls_free( ctx );
}

static void eckey_debug( const void *ctx, mbedtls_pk_debug_item *items )
{
    items->type = MBEDTLS_PK_DEBUG_ECP;
 c056ea8:	2302      	movs	r3, #2
 c056eaa:	700b      	strb	r3, [r1, #0]
    items->name = "eckey.Q";
 c056eac:	4b02      	ldr	r3, [pc, #8]	@ (c056eb8 <eckey_debug+0x10>)
    items->value = &( ((mbedtls_ecp_keypair *) ctx)->Q );
 c056eae:	30ac      	adds	r0, #172	@ 0xac
    items->name = "eckey.Q";
 c056eb0:	604b      	str	r3, [r1, #4]
    items->value = &( ((mbedtls_ecp_keypair *) ctx)->Q );
 c056eb2:	6088      	str	r0, [r1, #8]
}
 c056eb4:	4770      	bx	lr
 c056eb6:	bf00      	nop
 c056eb8:	0c060d78 	.word	0x0c060d78

0c056ebc <eckeydh_can_do>:
/*
 * EC key restricted to ECDH
 */
static int eckeydh_can_do( mbedtls_pk_type_t type )
{
    return( type == MBEDTLS_PK_ECKEY ||
 c056ebc:	3802      	subs	r0, #2
            type == MBEDTLS_PK_ECKEY_DH );
}
 c056ebe:	2801      	cmp	r0, #1
 c056ec0:	bf8c      	ite	hi
 c056ec2:	2000      	movhi	r0, #0
 c056ec4:	2001      	movls	r0, #1
 c056ec6:	4770      	bx	lr

0c056ec8 <ecdsa_can_do>:

#if defined(MBEDTLS_ECDSA_C)
static int ecdsa_can_do( mbedtls_pk_type_t type )
{
    return( type == MBEDTLS_PK_ECDSA );
}
 c056ec8:	1f03      	subs	r3, r0, #4
 c056eca:	4258      	negs	r0, r3
 c056ecc:	4158      	adcs	r0, r3
 c056ece:	4770      	bx	lr

0c056ed0 <rsa_free_wrap>:
{
 c056ed0:	b510      	push	{r4, lr}
 c056ed2:	4604      	mov	r4, r0
    mbedtls_rsa_free( (mbedtls_rsa_context *) ctx );
 c056ed4:	f7f9 fc18 	bl	c050708 <mbedtls_rsa_free>
    mbedtls_free( ctx );
 c056ed8:	4620      	mov	r0, r4
}
 c056eda:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mbedtls_free( ctx );
 c056ede:	f7e4 ba67 	b.w	c03b3b0 <mbedtls_free>

0c056ee2 <rsa_alloc_wrap>:
{
 c056ee2:	b510      	push	{r4, lr}
    void *ctx = mbedtls_calloc( 1, sizeof( mbedtls_rsa_context ) );
 c056ee4:	21b8      	movs	r1, #184	@ 0xb8
 c056ee6:	2001      	movs	r0, #1
 c056ee8:	f7e4 fa5c 	bl	c03b3a4 <mbedtls_calloc>
    if( ctx != NULL )
 c056eec:	4604      	mov	r4, r0
 c056eee:	b118      	cbz	r0, c056ef8 <rsa_alloc_wrap+0x16>
        mbedtls_rsa_init( (mbedtls_rsa_context *) ctx, 0, 0 );
 c056ef0:	2200      	movs	r2, #0
 c056ef2:	4611      	mov	r1, r2
 c056ef4:	f7f8 fbae 	bl	c04f654 <mbedtls_rsa_init>
}
 c056ef8:	4620      	mov	r0, r4
 c056efa:	bd10      	pop	{r4, pc}

0c056efc <rsa_check_pair_wrap>:
    return( mbedtls_rsa_check_pub_priv( (const mbedtls_rsa_context *) pub,
 c056efc:	f7f8 bc14 	b.w	c04f728 <mbedtls_rsa_check_pub_priv>

0c056f00 <rsa_get_bitlen>:
{
 c056f00:	b508      	push	{r3, lr}
    return( 8 * mbedtls_rsa_get_len( rsa ) );
 c056f02:	f7f8 fbb5 	bl	c04f670 <mbedtls_rsa_get_len>
}
 c056f06:	00c0      	lsls	r0, r0, #3
 c056f08:	bd08      	pop	{r3, pc}
	...

0c056f0c <rsa_encrypt_wrap>:
{
 c056f0c:	e92d 4ff1 	stmdb	sp!, {r0, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c056f10:	4604      	mov	r4, r0
 c056f12:	e9dd ba0a 	ldrd	fp, sl, [sp, #40]	@ 0x28
 c056f16:	e9dd 890c 	ldrd	r8, r9, [sp, #48]	@ 0x30
 c056f1a:	460e      	mov	r6, r1
 c056f1c:	4615      	mov	r5, r2
 c056f1e:	461f      	mov	r7, r3
    *olen = mbedtls_rsa_get_len( rsa );
 c056f20:	f7f8 fba6 	bl	c04f670 <mbedtls_rsa_get_len>
    if( *olen > osize )
 c056f24:	4550      	cmp	r0, sl
    *olen = mbedtls_rsa_get_len( rsa );
 c056f26:	f8cb 0000 	str.w	r0, [fp]
    if( *olen > osize )
 c056f2a:	d80b      	bhi.n	c056f44 <rsa_encrypt_wrap+0x38>
    return( mbedtls_rsa_pkcs1_encrypt( rsa, f_rng, p_rng, MBEDTLS_RSA_PUBLIC,
 c056f2c:	2300      	movs	r3, #0
 c056f2e:	464a      	mov	r2, r9
 c056f30:	4641      	mov	r1, r8
 c056f32:	4620      	mov	r0, r4
 c056f34:	e9cd 670b 	strd	r6, r7, [sp, #44]	@ 0x2c
 c056f38:	950a      	str	r5, [sp, #40]	@ 0x28
}
 c056f3a:	b001      	add	sp, #4
 c056f3c:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    return( mbedtls_rsa_pkcs1_encrypt( rsa, f_rng, p_rng, MBEDTLS_RSA_PUBLIC,
 c056f40:	f7f8 bfe8 	b.w	c04ff14 <mbedtls_rsa_pkcs1_encrypt>
}
 c056f44:	4801      	ldr	r0, [pc, #4]	@ (c056f4c <rsa_encrypt_wrap+0x40>)
 c056f46:	b001      	add	sp, #4
 c056f48:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 c056f4c:	ffffbc00 	.word	0xffffbc00

0c056f50 <rsa_decrypt_wrap>:
{
 c056f50:	e92d 4ff1 	stmdb	sp!, {r0, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c056f54:	4617      	mov	r7, r2
 c056f56:	e9dd ab0a 	ldrd	sl, fp, [sp, #40]	@ 0x28
 c056f5a:	e9dd 890c 	ldrd	r8, r9, [sp, #48]	@ 0x30
 c056f5e:	4604      	mov	r4, r0
 c056f60:	460d      	mov	r5, r1
 c056f62:	461e      	mov	r6, r3
    if( ilen != mbedtls_rsa_get_len( rsa ) )
 c056f64:	f7f8 fb84 	bl	c04f670 <mbedtls_rsa_get_len>
 c056f68:	42b8      	cmp	r0, r7
 c056f6a:	d10c      	bne.n	c056f86 <rsa_decrypt_wrap+0x36>
    return( mbedtls_rsa_pkcs1_decrypt( rsa, f_rng, p_rng,
 c056f6c:	2301      	movs	r3, #1
 c056f6e:	464a      	mov	r2, r9
 c056f70:	4641      	mov	r1, r8
 c056f72:	4620      	mov	r0, r4
 c056f74:	e9cd 6b0c 	strd	r6, fp, [sp, #48]	@ 0x30
 c056f78:	e9cd a50a 	strd	sl, r5, [sp, #40]	@ 0x28
}
 c056f7c:	b001      	add	sp, #4
 c056f7e:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    return( mbedtls_rsa_pkcs1_decrypt( rsa, f_rng, p_rng,
 c056f82:	f7f9 b987 	b.w	c050294 <mbedtls_rsa_pkcs1_decrypt>
}
 c056f86:	4802      	ldr	r0, [pc, #8]	@ (c056f90 <rsa_decrypt_wrap+0x40>)
 c056f88:	b001      	add	sp, #4
 c056f8a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 c056f8e:	bf00      	nop
 c056f90:	ffffbf80 	.word	0xffffbf80

0c056f94 <rsa_sign_wrap>:
{
 c056f94:	e92d 4ff1 	stmdb	sp!, {r0, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c056f98:	460d      	mov	r5, r1
 c056f9a:	e9dd ab0a 	ldrd	sl, fp, [sp, #40]	@ 0x28
 c056f9e:	e9dd 890c 	ldrd	r8, r9, [sp, #48]	@ 0x30
 c056fa2:	4617      	mov	r7, r2
 c056fa4:	461e      	mov	r6, r3
 c056fa6:	4604      	mov	r4, r0
    *sig_len = mbedtls_rsa_get_len( rsa );
 c056fa8:	f7f8 fb62 	bl	c04f670 <mbedtls_rsa_get_len>
    return( mbedtls_rsa_pkcs1_sign( rsa, f_rng, p_rng, MBEDTLS_RSA_PRIVATE,
 c056fac:	2301      	movs	r3, #1
    *sig_len = mbedtls_rsa_get_len( rsa );
 c056fae:	f8cb 0000 	str.w	r0, [fp]
    return( mbedtls_rsa_pkcs1_sign( rsa, f_rng, p_rng, MBEDTLS_RSA_PRIVATE,
 c056fb2:	464a      	mov	r2, r9
 c056fb4:	4641      	mov	r1, r8
 c056fb6:	4620      	mov	r0, r4
 c056fb8:	e9cd 7a0c 	strd	r7, sl, [sp, #48]	@ 0x30
 c056fbc:	e9cd 560a 	strd	r5, r6, [sp, #40]	@ 0x28
}
 c056fc0:	b001      	add	sp, #4
 c056fc2:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    return( mbedtls_rsa_pkcs1_sign( rsa, f_rng, p_rng, MBEDTLS_RSA_PRIVATE,
 c056fc6:	f7f9 ba0d 	b.w	c0503e4 <mbedtls_rsa_pkcs1_sign>
	...

0c056fcc <rsa_verify_wrap>:
{
 c056fcc:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 c056fd0:	b085      	sub	sp, #20
 c056fd2:	f8dd 9034 	ldr.w	r9, [sp, #52]	@ 0x34
 c056fd6:	4605      	mov	r5, r0
 c056fd8:	460e      	mov	r6, r1
 c056fda:	4690      	mov	r8, r2
 c056fdc:	461f      	mov	r7, r3
    size_t rsa_len = mbedtls_rsa_get_len( rsa );
 c056fde:	f7f8 fb47 	bl	c04f670 <mbedtls_rsa_get_len>
    if( sig_len < rsa_len )
 c056fe2:	4548      	cmp	r0, r9
    size_t rsa_len = mbedtls_rsa_get_len( rsa );
 c056fe4:	4604      	mov	r4, r0
    if( sig_len < rsa_len )
 c056fe6:	d812      	bhi.n	c05700e <rsa_verify_wrap+0x42>
    if( ( ret = mbedtls_rsa_pkcs1_verify( rsa, NULL, NULL,
 c056fe8:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
 c056fea:	4628      	mov	r0, r5
 c056fec:	e9cd 8302 	strd	r8, r3, [sp, #8]
 c056ff0:	2300      	movs	r3, #0
 c056ff2:	e9cd 6700 	strd	r6, r7, [sp]
 c056ff6:	461a      	mov	r2, r3
 c056ff8:	4619      	mov	r1, r3
 c056ffa:	f7f9 fb63 	bl	c0506c4 <mbedtls_rsa_pkcs1_verify>
 c056ffe:	b918      	cbnz	r0, c057008 <rsa_verify_wrap+0x3c>
        return( MBEDTLS_ERR_PK_SIG_LEN_MISMATCH );
 c057000:	4b04      	ldr	r3, [pc, #16]	@ (c057014 <rsa_verify_wrap+0x48>)
 c057002:	454c      	cmp	r4, r9
 c057004:	bf38      	it	cc
 c057006:	4618      	movcc	r0, r3
}
 c057008:	b005      	add	sp, #20
 c05700a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        return( MBEDTLS_ERR_RSA_VERIFY_FAILED );
 c05700e:	4802      	ldr	r0, [pc, #8]	@ (c057018 <rsa_verify_wrap+0x4c>)
 c057010:	e7fa      	b.n	c057008 <rsa_verify_wrap+0x3c>
 c057012:	bf00      	nop
 c057014:	ffffc700 	.word	0xffffc700
 c057018:	ffffbc80 	.word	0xffffbc80

0c05701c <eckey_free_wrap>:
{
 c05701c:	b510      	push	{r4, lr}
 c05701e:	4604      	mov	r4, r0
    mbedtls_ecp_keypair_free( (mbedtls_ecp_keypair *) ctx );
 c057020:	f7f5 fc9d 	bl	c04c95e <mbedtls_ecp_keypair_free>
    mbedtls_free( ctx );
 c057024:	4620      	mov	r0, r4
}
 c057026:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mbedtls_free( ctx );
 c05702a:	f7e4 b9c1 	b.w	c03b3b0 <mbedtls_free>

0c05702e <eckey_alloc_wrap>:
{
 c05702e:	b510      	push	{r4, lr}
    void *ctx = mbedtls_calloc( 1, sizeof( mbedtls_ecp_keypair ) );
 c057030:	21d0      	movs	r1, #208	@ 0xd0
 c057032:	2001      	movs	r0, #1
 c057034:	f7e4 f9b6 	bl	c03b3a4 <mbedtls_calloc>
    if( ctx != NULL )
 c057038:	4604      	mov	r4, r0
 c05703a:	b108      	cbz	r0, c057040 <eckey_alloc_wrap+0x12>
        mbedtls_ecp_keypair_init( ctx );
 c05703c:	f7f5 fc0d 	bl	c04c85a <mbedtls_ecp_keypair_init>
}
 c057040:	4620      	mov	r0, r4
 c057042:	bd10      	pop	{r4, pc}

0c057044 <eckey_check_pair>:
    return( mbedtls_ecp_check_pub_priv( (const mbedtls_ecp_keypair *) pub,
 c057044:	f7f6 ba98 	b.w	c04d578 <mbedtls_ecp_check_pub_priv>

0c057048 <ecdsa_alloc_wrap>:

}
#endif /* MBEDTLS_ECP_RESTARTABLE */

static void *ecdsa_alloc_wrap( void )
{
 c057048:	b510      	push	{r4, lr}
    void *ctx = mbedtls_calloc( 1, sizeof( mbedtls_ecdsa_context ) );
 c05704a:	21d0      	movs	r1, #208	@ 0xd0
 c05704c:	2001      	movs	r0, #1
 c05704e:	f7e4 f9a9 	bl	c03b3a4 <mbedtls_calloc>

    if( ctx != NULL )
 c057052:	4604      	mov	r4, r0
 c057054:	b108      	cbz	r0, c05705a <ecdsa_alloc_wrap+0x12>
        mbedtls_ecdsa_init( (mbedtls_ecdsa_context *) ctx );
 c057056:	f7ff f8ba 	bl	c0561ce <mbedtls_ecdsa_init>

    return( ctx );
}
 c05705a:	4620      	mov	r0, r4
 c05705c:	bd10      	pop	{r4, pc}

0c05705e <ecdsa_free_wrap>:

static void ecdsa_free_wrap( void *ctx )
{
 c05705e:	b510      	push	{r4, lr}
 c057060:	4604      	mov	r4, r0
    mbedtls_ecdsa_free( (mbedtls_ecdsa_context *) ctx );
 c057062:	f7ff f8b6 	bl	c0561d2 <mbedtls_ecdsa_free>
    mbedtls_free( ctx );
 c057066:	4620      	mov	r0, r4
}
 c057068:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mbedtls_free( ctx );
 c05706c:	f7e4 b9a0 	b.w	c03b3b0 <mbedtls_free>

0c057070 <ecdsa_sign_wrap>:
    return( mbedtls_ecdsa_write_signature( (mbedtls_ecdsa_context *) ctx,
 c057070:	f7ff b844 	b.w	c0560fc <mbedtls_ecdsa_write_signature>

0c057074 <eckey_sign_wrap>:
{
 c057074:	b5f0      	push	{r4, r5, r6, r7, lr}
 c057076:	4604      	mov	r4, r0
 c057078:	b0b9      	sub	sp, #228	@ 0xe4
    mbedtls_ecdsa_init( &ecdsa );
 c05707a:	a804      	add	r0, sp, #16
{
 c05707c:	460d      	mov	r5, r1
 c05707e:	4616      	mov	r6, r2
 c057080:	461f      	mov	r7, r3
    mbedtls_ecdsa_init( &ecdsa );
 c057082:	f7ff f8a4 	bl	c0561ce <mbedtls_ecdsa_init>
    if( ( ret = mbedtls_ecdsa_from_keypair( &ecdsa, ctx ) ) == 0 )
 c057086:	4621      	mov	r1, r4
 c057088:	a804      	add	r0, sp, #16
 c05708a:	f7ff f8a6 	bl	c0561da <mbedtls_ecdsa_from_keypair>
 c05708e:	4604      	mov	r4, r0
 c057090:	b970      	cbnz	r0, c0570b0 <eckey_sign_wrap+0x3c>
    return( mbedtls_ecdsa_write_signature( (mbedtls_ecdsa_context *) ctx,
 c057092:	9b41      	ldr	r3, [sp, #260]	@ 0x104
 c057094:	4632      	mov	r2, r6
 c057096:	9303      	str	r3, [sp, #12]
 c057098:	9b40      	ldr	r3, [sp, #256]	@ 0x100
 c05709a:	4629      	mov	r1, r5
 c05709c:	9302      	str	r3, [sp, #8]
 c05709e:	9b3f      	ldr	r3, [sp, #252]	@ 0xfc
 c0570a0:	a804      	add	r0, sp, #16
 c0570a2:	9301      	str	r3, [sp, #4]
 c0570a4:	9b3e      	ldr	r3, [sp, #248]	@ 0xf8
 c0570a6:	9300      	str	r3, [sp, #0]
 c0570a8:	463b      	mov	r3, r7
 c0570aa:	f7ff f827 	bl	c0560fc <mbedtls_ecdsa_write_signature>
 c0570ae:	4604      	mov	r4, r0
    mbedtls_ecdsa_free( &ecdsa );
 c0570b0:	a804      	add	r0, sp, #16
 c0570b2:	f7ff f88e 	bl	c0561d2 <mbedtls_ecdsa_free>
}
 c0570b6:	4620      	mov	r0, r4
 c0570b8:	b039      	add	sp, #228	@ 0xe4
 c0570ba:	bdf0      	pop	{r4, r5, r6, r7, pc}

0c0570bc <ecdsa_verify_wrap>:
{
 c0570bc:	b507      	push	{r0, r1, r2, lr}
 c0570be:	4611      	mov	r1, r2
 c0570c0:	461a      	mov	r2, r3
    ret = mbedtls_ecdsa_read_signature( (mbedtls_ecdsa_context *) ctx,
 c0570c2:	9b05      	ldr	r3, [sp, #20]
 c0570c4:	9300      	str	r3, [sp, #0]
 c0570c6:	9b04      	ldr	r3, [sp, #16]
 c0570c8:	f7ff f878 	bl	c0561bc <mbedtls_ecdsa_read_signature>
    if( ret == MBEDTLS_ERR_ECP_SIG_LEN_MISMATCH )
 c0570cc:	f510 4f98 	cmn.w	r0, #19456	@ 0x4c00
        return( MBEDTLS_ERR_PK_SIG_LEN_MISMATCH );
 c0570d0:	bf08      	it	eq
 c0570d2:	f500 5098 	addeq.w	r0, r0, #4864	@ 0x1300
}
 c0570d6:	b003      	add	sp, #12
 c0570d8:	f85d fb04 	ldr.w	pc, [sp], #4

0c0570dc <eckey_verify_wrap>:
{
 c0570dc:	b5f0      	push	{r4, r5, r6, r7, lr}
 c0570de:	4604      	mov	r4, r0
 c0570e0:	b0b7      	sub	sp, #220	@ 0xdc
    mbedtls_ecdsa_init( &ecdsa );
 c0570e2:	a802      	add	r0, sp, #8
{
 c0570e4:	460d      	mov	r5, r1
 c0570e6:	4616      	mov	r6, r2
 c0570e8:	461f      	mov	r7, r3
    mbedtls_ecdsa_init( &ecdsa );
 c0570ea:	f7ff f870 	bl	c0561ce <mbedtls_ecdsa_init>
    if( ( ret = mbedtls_ecdsa_from_keypair( &ecdsa, ctx ) ) == 0 )
 c0570ee:	4621      	mov	r1, r4
 c0570f0:	a802      	add	r0, sp, #8
 c0570f2:	f7ff f872 	bl	c0561da <mbedtls_ecdsa_from_keypair>
 c0570f6:	4604      	mov	r4, r0
 c0570f8:	b950      	cbnz	r0, c057110 <eckey_verify_wrap+0x34>
        ret = ecdsa_verify_wrap( &ecdsa, md_alg, hash, hash_len, sig, sig_len );
 c0570fa:	9b3d      	ldr	r3, [sp, #244]	@ 0xf4
 c0570fc:	4632      	mov	r2, r6
 c0570fe:	9301      	str	r3, [sp, #4]
 c057100:	9b3c      	ldr	r3, [sp, #240]	@ 0xf0
 c057102:	4629      	mov	r1, r5
 c057104:	9300      	str	r3, [sp, #0]
 c057106:	a802      	add	r0, sp, #8
 c057108:	463b      	mov	r3, r7
 c05710a:	f7ff ffd7 	bl	c0570bc <ecdsa_verify_wrap>
 c05710e:	4604      	mov	r4, r0
    mbedtls_ecdsa_free( &ecdsa );
 c057110:	a802      	add	r0, sp, #8
 c057112:	f7ff f85e 	bl	c0561d2 <mbedtls_ecdsa_free>
}
 c057116:	4620      	mov	r0, r4
 c057118:	b037      	add	sp, #220	@ 0xdc
 c05711a:	bdf0      	pop	{r4, r5, r6, r7, pc}

0c05711c <pk_get_rsapubkey>:
 *  }
 */
static int pk_get_rsapubkey( unsigned char **p,
                             const unsigned char *end,
                             mbedtls_rsa_context *rsa )
{
 c05711c:	b570      	push	{r4, r5, r6, lr}
 c05711e:	b08a      	sub	sp, #40	@ 0x28
 c057120:	4616      	mov	r6, r2
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    size_t len;

    if( ( ret = mbedtls_asn1_get_tag( p, end, &len,
 c057122:	2330      	movs	r3, #48	@ 0x30
 c057124:	aa09      	add	r2, sp, #36	@ 0x24
{
 c057126:	4604      	mov	r4, r0
 c057128:	460d      	mov	r5, r1
    if( ( ret = mbedtls_asn1_get_tag( p, end, &len,
 c05712a:	f7fb fc6c 	bl	c052a06 <mbedtls_asn1_get_tag>
 c05712e:	b118      	cbz	r0, c057138 <pk_get_rsapubkey+0x1c>
 c057130:	f5a0 506c 	sub.w	r0, r0, #15104	@ 0x3b00
    if( *p != end )
        return( MBEDTLS_ERROR_ADD( MBEDTLS_ERR_PK_INVALID_PUBKEY,
                MBEDTLS_ERR_ASN1_LENGTH_MISMATCH ) );

    return( 0 );
}
 c057134:	b00a      	add	sp, #40	@ 0x28
 c057136:	bd70      	pop	{r4, r5, r6, pc}
    if( *p + len != end )
 c057138:	6823      	ldr	r3, [r4, #0]
 c05713a:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 c05713c:	4413      	add	r3, r2
 c05713e:	429d      	cmp	r5, r3
 c057140:	d001      	beq.n	c057146 <pk_get_rsapubkey+0x2a>
        return( MBEDTLS_ERROR_ADD( MBEDTLS_ERR_PK_INVALID_PUBKEY,
 c057142:	4825      	ldr	r0, [pc, #148]	@ (c0571d8 <pk_get_rsapubkey+0xbc>)
 c057144:	e7f6      	b.n	c057134 <pk_get_rsapubkey+0x18>
    if( ( ret = mbedtls_asn1_get_tag( p, end, &len, MBEDTLS_ASN1_INTEGER ) ) != 0 )
 c057146:	2302      	movs	r3, #2
 c057148:	4629      	mov	r1, r5
 c05714a:	4620      	mov	r0, r4
 c05714c:	aa09      	add	r2, sp, #36	@ 0x24
 c05714e:	f7fb fc5a 	bl	c052a06 <mbedtls_asn1_get_tag>
 c057152:	4603      	mov	r3, r0
 c057154:	b110      	cbz	r0, c05715c <pk_get_rsapubkey+0x40>
 c057156:	f5a3 506c 	sub.w	r0, r3, #15104	@ 0x3b00
        return( MBEDTLS_ERROR_ADD( MBEDTLS_ERR_PK_INVALID_PUBKEY, ret ) );
 c05715a:	e7eb      	b.n	c057134 <pk_get_rsapubkey+0x18>
    if( ( ret = mbedtls_rsa_import_raw( rsa, *p, len, NULL, 0, NULL, 0,
 c05715c:	e9cd 0005 	strd	r0, r0, [sp, #20]
 c057160:	e9cd 0003 	strd	r0, r0, [sp, #12]
 c057164:	e9cd 0001 	strd	r0, r0, [sp, #4]
 c057168:	9000      	str	r0, [sp, #0]
 c05716a:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 c05716c:	4630      	mov	r0, r6
 c05716e:	6821      	ldr	r1, [r4, #0]
 c057170:	f7f8 f895 	bl	c04f29e <mbedtls_rsa_import_raw>
 c057174:	b108      	cbz	r0, c05717a <pk_get_rsapubkey+0x5e>
        return( MBEDTLS_ERR_PK_INVALID_PUBKEY );
 c057176:	4819      	ldr	r0, [pc, #100]	@ (c0571dc <pk_get_rsapubkey+0xc0>)
 c057178:	e7dc      	b.n	c057134 <pk_get_rsapubkey+0x18>
    *p += len;
 c05717a:	6823      	ldr	r3, [r4, #0]
 c05717c:	9a09      	ldr	r2, [sp, #36]	@ 0x24
    if( ( ret = mbedtls_asn1_get_tag( p, end, &len, MBEDTLS_ASN1_INTEGER ) ) != 0 )
 c05717e:	4629      	mov	r1, r5
    *p += len;
 c057180:	4413      	add	r3, r2
 c057182:	6023      	str	r3, [r4, #0]
    if( ( ret = mbedtls_asn1_get_tag( p, end, &len, MBEDTLS_ASN1_INTEGER ) ) != 0 )
 c057184:	4620      	mov	r0, r4
 c057186:	2302      	movs	r3, #2
 c057188:	aa09      	add	r2, sp, #36	@ 0x24
 c05718a:	f7fb fc3c 	bl	c052a06 <mbedtls_asn1_get_tag>
 c05718e:	4603      	mov	r3, r0
 c057190:	2800      	cmp	r0, #0
 c057192:	d1e0      	bne.n	c057156 <pk_get_rsapubkey+0x3a>
    if( ( ret = mbedtls_rsa_import_raw( rsa, NULL, 0, NULL, 0, NULL, 0,
 c057194:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 c057196:	4601      	mov	r1, r0
 c057198:	9206      	str	r2, [sp, #24]
 c05719a:	6822      	ldr	r2, [r4, #0]
 c05719c:	e9cd 0002 	strd	r0, r0, [sp, #8]
 c0571a0:	e9cd 0204 	strd	r0, r2, [sp, #16]
 c0571a4:	e9cd 0000 	strd	r0, r0, [sp]
 c0571a8:	4602      	mov	r2, r0
 c0571aa:	4630      	mov	r0, r6
 c0571ac:	f7f8 f877 	bl	c04f29e <mbedtls_rsa_import_raw>
 c0571b0:	2800      	cmp	r0, #0
 c0571b2:	d1e0      	bne.n	c057176 <pk_get_rsapubkey+0x5a>
    *p += len;
 c0571b4:	6823      	ldr	r3, [r4, #0]
 c0571b6:	9a09      	ldr	r2, [sp, #36]	@ 0x24
    if( mbedtls_rsa_complete( rsa ) != 0 ||
 c0571b8:	4630      	mov	r0, r6
    *p += len;
 c0571ba:	4413      	add	r3, r2
 c0571bc:	6023      	str	r3, [r4, #0]
    if( mbedtls_rsa_complete( rsa ) != 0 ||
 c0571be:	f7f8 f8b1 	bl	c04f324 <mbedtls_rsa_complete>
 c0571c2:	2800      	cmp	r0, #0
 c0571c4:	d1d7      	bne.n	c057176 <pk_get_rsapubkey+0x5a>
        mbedtls_rsa_check_pubkey( rsa ) != 0 )
 c0571c6:	4630      	mov	r0, r6
 c0571c8:	f7f8 fa54 	bl	c04f674 <mbedtls_rsa_check_pubkey>
    if( mbedtls_rsa_complete( rsa ) != 0 ||
 c0571cc:	2800      	cmp	r0, #0
 c0571ce:	d1d2      	bne.n	c057176 <pk_get_rsapubkey+0x5a>
    if( *p != end )
 c0571d0:	6823      	ldr	r3, [r4, #0]
 c0571d2:	42ab      	cmp	r3, r5
 c0571d4:	d0ae      	beq.n	c057134 <pk_get_rsapubkey+0x18>
 c0571d6:	e7b4      	b.n	c057142 <pk_get_rsapubkey+0x26>
 c0571d8:	ffffc49a 	.word	0xffffc49a
 c0571dc:	ffffc500 	.word	0xffffc500

0c0571e0 <pk_use_ecparams>:
    if( params->tag == MBEDTLS_ASN1_OID )
 c0571e0:	6803      	ldr	r3, [r0, #0]
{
 c0571e2:	b513      	push	{r0, r1, r4, lr}
    if( params->tag == MBEDTLS_ASN1_OID )
 c0571e4:	2b06      	cmp	r3, #6
{
 c0571e6:	460c      	mov	r4, r1
    if( params->tag == MBEDTLS_ASN1_OID )
 c0571e8:	d002      	beq.n	c0571f0 <pk_use_ecparams+0x10>
        return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT );
 c0571ea:	480a      	ldr	r0, [pc, #40]	@ (c057214 <pk_use_ecparams+0x34>)
}
 c0571ec:	b002      	add	sp, #8
 c0571ee:	bd10      	pop	{r4, pc}
        if( mbedtls_oid_get_ec_grp( params, &grp_id ) != 0 )
 c0571f0:	f10d 0107 	add.w	r1, sp, #7
 c0571f4:	f7ff fdba 	bl	c056d6c <mbedtls_oid_get_ec_grp>
 c0571f8:	b948      	cbnz	r0, c05720e <pk_use_ecparams+0x2e>
    if( grp->id != MBEDTLS_ECP_DP_NONE && grp->id != grp_id )
 c0571fa:	7823      	ldrb	r3, [r4, #0]
 c0571fc:	f89d 1007 	ldrb.w	r1, [sp, #7]
 c057200:	b10b      	cbz	r3, c057206 <pk_use_ecparams+0x26>
 c057202:	428b      	cmp	r3, r1
 c057204:	d1f1      	bne.n	c0571ea <pk_use_ecparams+0xa>
    if( ( ret = mbedtls_ecp_group_load( grp, grp_id ) ) != 0 )
 c057206:	4620      	mov	r0, r4
 c057208:	f7f6 fbf2 	bl	c04d9f0 <mbedtls_ecp_group_load>
 c05720c:	e7ee      	b.n	c0571ec <pk_use_ecparams+0xc>
            return( MBEDTLS_ERR_PK_UNKNOWN_NAMED_CURVE );
 c05720e:	4802      	ldr	r0, [pc, #8]	@ (c057218 <pk_use_ecparams+0x38>)
 c057210:	e7ec      	b.n	c0571ec <pk_use_ecparams+0xc>
 c057212:	bf00      	nop
 c057214:	ffffc300 	.word	0xffffc300
 c057218:	ffffc600 	.word	0xffffc600

0c05721c <pk_parse_key_sec1_der>:
 * Parse a SEC1 encoded private EC key
 */
static int pk_parse_key_sec1_der( mbedtls_ecp_keypair *eck,
                                  const unsigned char *key,
                                  size_t keylen )
{
 c05721c:	b5f0      	push	{r4, r5, r6, r7, lr}
 c05721e:	4605      	mov	r5, r0
 c057220:	4610      	mov	r0, r2
 c057222:	b089      	sub	sp, #36	@ 0x24
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    int version, pubkey_done;
    size_t len;
    mbedtls_asn1_buf params;
    unsigned char *p = (unsigned char *) key;
 c057224:	9104      	str	r1, [sp, #16]
     *      privateKey     OCTET STRING,
     *      parameters [0] ECParameters {{ NamedCurve }} OPTIONAL,
     *      publicKey  [1] BIT STRING OPTIONAL
     *    }
     */
    if( ( ret = mbedtls_asn1_get_tag( &p, end, &len,
 c057226:	2330      	movs	r3, #48	@ 0x30
 c057228:	4401      	add	r1, r0
 c05722a:	aa03      	add	r2, sp, #12
 c05722c:	a804      	add	r0, sp, #16
 c05722e:	f7fb fbea 	bl	c052a06 <mbedtls_asn1_get_tag>
 c057232:	b120      	cbz	r0, c05723e <pk_parse_key_sec1_der+0x22>
 c057234:	f5a0 5474 	sub.w	r4, r0, #15616	@ 0x3d00
        mbedtls_ecp_keypair_free( eck );
        return( ret );
    }

    return( 0 );
}
 c057238:	4620      	mov	r0, r4
 c05723a:	b009      	add	sp, #36	@ 0x24
 c05723c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    end = p + len;
 c05723e:	e9dd 3703 	ldrd	r3, r7, [sp, #12]
 c057242:	441f      	add	r7, r3
    if( ( ret = mbedtls_asn1_get_int( &p, end, &version ) ) != 0 )
 c057244:	4639      	mov	r1, r7
 c057246:	aa02      	add	r2, sp, #8
 c057248:	a804      	add	r0, sp, #16
 c05724a:	f7fb fc26 	bl	c052a9a <mbedtls_asn1_get_int>
 c05724e:	2800      	cmp	r0, #0
 c057250:	d1f0      	bne.n	c057234 <pk_parse_key_sec1_der+0x18>
    if( version != 1 )
 c057252:	9b02      	ldr	r3, [sp, #8]
 c057254:	2b01      	cmp	r3, #1
 c057256:	f040 809c 	bne.w	c057392 <pk_parse_key_sec1_der+0x176>
    if( ( ret = mbedtls_asn1_get_tag( &p, end, &len, MBEDTLS_ASN1_OCTET_STRING ) ) != 0 )
 c05725a:	2304      	movs	r3, #4
 c05725c:	4639      	mov	r1, r7
 c05725e:	aa03      	add	r2, sp, #12
 c057260:	a804      	add	r0, sp, #16
 c057262:	f7fb fbd0 	bl	c052a06 <mbedtls_asn1_get_tag>
 c057266:	2800      	cmp	r0, #0
 c057268:	d1e4      	bne.n	c057234 <pk_parse_key_sec1_der+0x18>
    if( ( ret = mbedtls_mpi_read_binary( &eck->d, p, len ) ) != 0 )
 c05726a:	e9dd 2103 	ldrd	r2, r1, [sp, #12]
 c05726e:	f105 06a0 	add.w	r6, r5, #160	@ 0xa0
 c057272:	4630      	mov	r0, r6
 c057274:	f7fc f999 	bl	c0535aa <mbedtls_mpi_read_binary>
 c057278:	4604      	mov	r4, r0
 c05727a:	b128      	cbz	r0, c057288 <pk_parse_key_sec1_der+0x6c>
        mbedtls_ecp_keypair_free( eck );
 c05727c:	4628      	mov	r0, r5
 c05727e:	f7f5 fb6e 	bl	c04c95e <mbedtls_ecp_keypair_free>
 c057282:	f5a4 5474 	sub.w	r4, r4, #15616	@ 0x3d00
        return( MBEDTLS_ERROR_ADD( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT, ret ) );
 c057286:	e7d7      	b.n	c057238 <pk_parse_key_sec1_der+0x1c>
    p += len;
 c057288:	e9dd 2303 	ldrd	r2, r3, [sp, #12]
 c05728c:	4413      	add	r3, r2
    if( p != end )
 c05728e:	42bb      	cmp	r3, r7
    p += len;
 c057290:	9304      	str	r3, [sp, #16]
    if( p != end )
 c057292:	d06f      	beq.n	c057374 <pk_parse_key_sec1_der+0x158>
        if( ( ret = mbedtls_asn1_get_tag( &p, end, &len,
 c057294:	23a0      	movs	r3, #160	@ 0xa0
 c057296:	4639      	mov	r1, r7
 c057298:	aa03      	add	r2, sp, #12
 c05729a:	a804      	add	r0, sp, #16
 c05729c:	f7fb fbb3 	bl	c052a06 <mbedtls_asn1_get_tag>
 c0572a0:	4604      	mov	r4, r0
 c0572a2:	bb48      	cbnz	r0, c0572f8 <pk_parse_key_sec1_der+0xdc>
            if( ( ret = pk_get_ecparams( &p, p + len, &params) ) != 0 ||
 c0572a4:	e9dd 2303 	ldrd	r2, r3, [sp, #12]
    if ( end - *p < 1 )
 c0572a8:	2a00      	cmp	r2, #0
            if( ( ret = pk_get_ecparams( &p, p + len, &params) ) != 0 ||
 c0572aa:	eb03 0402 	add.w	r4, r3, r2
    if ( end - *p < 1 )
 c0572ae:	dd1f      	ble.n	c0572f0 <pk_parse_key_sec1_der+0xd4>
    params->tag = **p;
 c0572b0:	781b      	ldrb	r3, [r3, #0]
    if( params->tag != MBEDTLS_ASN1_OID
 c0572b2:	2b06      	cmp	r3, #6
    params->tag = **p;
 c0572b4:	9305      	str	r3, [sp, #20]
    if( params->tag != MBEDTLS_ASN1_OID
 c0572b6:	d11d      	bne.n	c0572f4 <pk_parse_key_sec1_der+0xd8>
    if( ( ret = mbedtls_asn1_get_tag( p, end, &params->len, params->tag ) ) != 0 )
 c0572b8:	4621      	mov	r1, r4
 c0572ba:	aa06      	add	r2, sp, #24
 c0572bc:	a804      	add	r0, sp, #16
 c0572be:	f7fb fba2 	bl	c052a06 <mbedtls_asn1_get_tag>
 c0572c2:	b160      	cbz	r0, c0572de <pk_parse_key_sec1_der+0xc2>
            if( ( ret = pk_get_ecparams( &p, p + len, &params) ) != 0 ||
 c0572c4:	f5b0 5474 	subs.w	r4, r0, #15616	@ 0x3d00
 c0572c8:	d105      	bne.n	c0572d6 <pk_parse_key_sec1_der+0xba>
                ( ret = pk_use_ecparams( &params, &eck->grp )  ) != 0 )
 c0572ca:	4629      	mov	r1, r5
 c0572cc:	a805      	add	r0, sp, #20
 c0572ce:	f7ff ff87 	bl	c0571e0 <pk_use_ecparams>
            if( ( ret = pk_get_ecparams( &p, p + len, &params) ) != 0 ||
 c0572d2:	4604      	mov	r4, r0
 c0572d4:	b198      	cbz	r0, c0572fe <pk_parse_key_sec1_der+0xe2>
        mbedtls_ecp_keypair_free( eck );
 c0572d6:	4628      	mov	r0, r5
 c0572d8:	f7f5 fb41 	bl	c04c95e <mbedtls_ecp_keypair_free>
        return( ret );
 c0572dc:	e7ac      	b.n	c057238 <pk_parse_key_sec1_der+0x1c>
    params->p = *p;
 c0572de:	9b04      	ldr	r3, [sp, #16]
    *p += params->len;
 c0572e0:	9a06      	ldr	r2, [sp, #24]
    params->p = *p;
 c0572e2:	9307      	str	r3, [sp, #28]
    *p += params->len;
 c0572e4:	4413      	add	r3, r2
    if( *p != end )
 c0572e6:	429c      	cmp	r4, r3
    *p += params->len;
 c0572e8:	9304      	str	r3, [sp, #16]
    if( *p != end )
 c0572ea:	d0ee      	beq.n	c0572ca <pk_parse_key_sec1_der+0xae>
        return( MBEDTLS_ERROR_ADD( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT,
 c0572ec:	4c2b      	ldr	r4, [pc, #172]	@ (c05739c <pk_parse_key_sec1_der+0x180>)
 c0572ee:	e7f2      	b.n	c0572d6 <pk_parse_key_sec1_der+0xba>
        return( MBEDTLS_ERROR_ADD( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT,
 c0572f0:	4c2b      	ldr	r4, [pc, #172]	@ (c0573a0 <pk_parse_key_sec1_der+0x184>)
 c0572f2:	e7f0      	b.n	c0572d6 <pk_parse_key_sec1_der+0xba>
        return( MBEDTLS_ERROR_ADD( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT,
 c0572f4:	4c2b      	ldr	r4, [pc, #172]	@ (c0573a4 <pk_parse_key_sec1_der+0x188>)
                mbedtls_ecp_keypair_free( eck );
 c0572f6:	e7ee      	b.n	c0572d6 <pk_parse_key_sec1_der+0xba>
        else if( ret != MBEDTLS_ERR_ASN1_UNEXPECTED_TAG )
 c0572f8:	f110 0f62 	cmn.w	r0, #98	@ 0x62
 c0572fc:	d1be      	bne.n	c05727c <pk_parse_key_sec1_der+0x60>
    if( p != end )
 c0572fe:	9b04      	ldr	r3, [sp, #16]
 c057300:	42bb      	cmp	r3, r7
 c057302:	d037      	beq.n	c057374 <pk_parse_key_sec1_der+0x158>
        if( ( ret = mbedtls_asn1_get_tag( &p, end, &len,
 c057304:	23a1      	movs	r3, #161	@ 0xa1
 c057306:	4639      	mov	r1, r7
 c057308:	aa03      	add	r2, sp, #12
 c05730a:	a804      	add	r0, sp, #16
 c05730c:	f7fb fb7b 	bl	c052a06 <mbedtls_asn1_get_tag>
 c057310:	4604      	mov	r4, r0
 c057312:	bb60      	cbnz	r0, c05736e <pk_parse_key_sec1_der+0x152>
            end2 = p + len;
 c057314:	e9dd 3403 	ldrd	r3, r4, [sp, #12]
 c057318:	441c      	add	r4, r3
            if( ( ret = mbedtls_asn1_get_bitstring_null( &p, end2, &len ) ) != 0 )
 c05731a:	4621      	mov	r1, r4
 c05731c:	aa03      	add	r2, sp, #12
 c05731e:	a804      	add	r0, sp, #16
 c057320:	f7fb fbd2 	bl	c052ac8 <mbedtls_asn1_get_bitstring_null>
 c057324:	2800      	cmp	r0, #0
 c057326:	d185      	bne.n	c057234 <pk_parse_key_sec1_der+0x18>
            if( p + len != end2 )
 c057328:	e9dd 3203 	ldrd	r3, r2, [sp, #12]
 c05732c:	4413      	add	r3, r2
 c05732e:	429c      	cmp	r4, r3
 c057330:	d131      	bne.n	c057396 <pk_parse_key_sec1_der+0x17a>
    if( ( ret = mbedtls_ecp_point_read_binary( &key->grp, &key->Q,
 c057332:	f105 07ac 	add.w	r7, r5, #172	@ 0xac
 c057336:	4639      	mov	r1, r7
 c057338:	4628      	mov	r0, r5
 c05733a:	1aa3      	subs	r3, r4, r2
 c05733c:	f7f5 fbc2 	bl	c04cac4 <mbedtls_ecp_point_read_binary>
 c057340:	b128      	cbz	r0, c05734e <pk_parse_key_sec1_der+0x132>
    *p = (unsigned char *) end;
 c057342:	9404      	str	r4, [sp, #16]
                if( ret != MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE )
 c057344:	f510 4f9d 	cmn.w	r0, #20096	@ 0x4e80
 c057348:	d014      	beq.n	c057374 <pk_parse_key_sec1_der+0x158>
                    return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT );
 c05734a:	4c17      	ldr	r4, [pc, #92]	@ (c0573a8 <pk_parse_key_sec1_der+0x18c>)
 c05734c:	e774      	b.n	c057238 <pk_parse_key_sec1_der+0x1c>
        ret = mbedtls_ecp_check_pubkey( &key->grp, &key->Q );
 c05734e:	4639      	mov	r1, r7
 c057350:	4628      	mov	r0, r5
 c057352:	f7f5 fc27 	bl	c04cba4 <mbedtls_ecp_check_pubkey>
    *p = (unsigned char *) end;
 c057356:	9404      	str	r4, [sp, #16]
            if( ( ret = pk_get_ecpubkey( &p, end2, eck ) ) == 0 )
 c057358:	2800      	cmp	r0, #0
 c05735a:	d1f3      	bne.n	c057344 <pk_parse_key_sec1_der+0x128>
    if( ( ret = mbedtls_ecp_check_privkey( &eck->grp, &eck->d ) ) != 0 )
 c05735c:	4631      	mov	r1, r6
 c05735e:	4628      	mov	r0, r5
 c057360:	f7f5 fcde 	bl	c04cd20 <mbedtls_ecp_check_privkey>
 c057364:	4604      	mov	r4, r0
 c057366:	2800      	cmp	r0, #0
 c057368:	f43f af66 	beq.w	c057238 <pk_parse_key_sec1_der+0x1c>
 c05736c:	e7b3      	b.n	c0572d6 <pk_parse_key_sec1_der+0xba>
        else if( ret != MBEDTLS_ERR_ASN1_UNEXPECTED_TAG )
 c05736e:	f110 0f62 	cmn.w	r0, #98	@ 0x62
 c057372:	d183      	bne.n	c05727c <pk_parse_key_sec1_der+0x60>
        ( ret = mbedtls_ecp_mul( &eck->grp, &eck->Q, &eck->d, &eck->grp.G,
 c057374:	2300      	movs	r3, #0
 c057376:	4632      	mov	r2, r6
 c057378:	e9cd 3300 	strd	r3, r3, [sp]
 c05737c:	4628      	mov	r0, r5
 c05737e:	f105 0328 	add.w	r3, r5, #40	@ 0x28
 c057382:	f105 01ac 	add.w	r1, r5, #172	@ 0xac
 c057386:	f7f5 ff93 	bl	c04d2b0 <mbedtls_ecp_mul>
    if( ! pubkey_done &&
 c05738a:	4604      	mov	r4, r0
 c05738c:	2800      	cmp	r0, #0
 c05738e:	d0e5      	beq.n	c05735c <pk_parse_key_sec1_der+0x140>
 c057390:	e774      	b.n	c05727c <pk_parse_key_sec1_der+0x60>
        return( MBEDTLS_ERR_PK_KEY_INVALID_VERSION );
 c057392:	4c06      	ldr	r4, [pc, #24]	@ (c0573ac <pk_parse_key_sec1_der+0x190>)
 c057394:	e750      	b.n	c057238 <pk_parse_key_sec1_der+0x1c>
                return( MBEDTLS_ERROR_ADD( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT,
 c057396:	4c01      	ldr	r4, [pc, #4]	@ (c05739c <pk_parse_key_sec1_der+0x180>)
 c057398:	e74e      	b.n	c057238 <pk_parse_key_sec1_der+0x1c>
 c05739a:	bf00      	nop
 c05739c:	ffffc29a 	.word	0xffffc29a
 c0573a0:	ffffc2a0 	.word	0xffffc2a0
 c0573a4:	ffffc29e 	.word	0xffffc29e
 c0573a8:	ffffc300 	.word	0xffffc300
 c0573ac:	ffffc280 	.word	0xffffc280

0c0573b0 <asn1_get_nonzero_mpi>:
{
 c0573b0:	b538      	push	{r3, r4, r5, lr}
 c0573b2:	4615      	mov	r5, r2
    ret = mbedtls_asn1_get_mpi( p, end, X );
 c0573b4:	f7fb fb75 	bl	c052aa2 <mbedtls_asn1_get_mpi>
    if( ret != 0 )
 c0573b8:	4604      	mov	r4, r0
 c0573ba:	b938      	cbnz	r0, c0573cc <asn1_get_nonzero_mpi+0x1c>
    if( mbedtls_mpi_cmp_int( X, 0 ) == 0 )
 c0573bc:	4601      	mov	r1, r0
 c0573be:	4628      	mov	r0, r5
 c0573c0:	f7fc fa7f 	bl	c0538c2 <mbedtls_mpi_cmp_int>
        return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT );
 c0573c4:	4b02      	ldr	r3, [pc, #8]	@ (c0573d0 <asn1_get_nonzero_mpi+0x20>)
 c0573c6:	2800      	cmp	r0, #0
 c0573c8:	bf08      	it	eq
 c0573ca:	461c      	moveq	r4, r3
}
 c0573cc:	4620      	mov	r0, r4
 c0573ce:	bd38      	pop	{r3, r4, r5, pc}
 c0573d0:	ffffc300 	.word	0xffffc300

0c0573d4 <pk_parse_key_pkcs1_der>:
{
 c0573d4:	b570      	push	{r4, r5, r6, lr}
 c0573d6:	460c      	mov	r4, r1
 c0573d8:	4616      	mov	r6, r2
 c0573da:	b088      	sub	sp, #32
 c0573dc:	4605      	mov	r5, r0
    mbedtls_mpi_init( &T );
 c0573de:	a805      	add	r0, sp, #20
 c0573e0:	f7fb ff89 	bl	c0532f6 <mbedtls_mpi_init>
    if( ( ret = mbedtls_asn1_get_tag( &p, end, &len,
 c0573e4:	2330      	movs	r3, #48	@ 0x30
 c0573e6:	aa03      	add	r2, sp, #12
 c0573e8:	19a1      	adds	r1, r4, r6
 c0573ea:	a804      	add	r0, sp, #16
    p = (unsigned char *) key;
 c0573ec:	9404      	str	r4, [sp, #16]
    if( ( ret = mbedtls_asn1_get_tag( &p, end, &len,
 c0573ee:	f7fb fb0a 	bl	c052a06 <mbedtls_asn1_get_tag>
 c0573f2:	b120      	cbz	r0, c0573fe <pk_parse_key_pkcs1_der+0x2a>
 c0573f4:	f5a0 5474 	sub.w	r4, r0, #15616	@ 0x3d00
}
 c0573f8:	4620      	mov	r0, r4
 c0573fa:	b008      	add	sp, #32
 c0573fc:	bd70      	pop	{r4, r5, r6, pc}
    end = p + len;
 c0573fe:	e9dd 3603 	ldrd	r3, r6, [sp, #12]
 c057402:	441e      	add	r6, r3
    if( ( ret = mbedtls_asn1_get_int( &p, end, &version ) ) != 0 )
 c057404:	4631      	mov	r1, r6
 c057406:	aa02      	add	r2, sp, #8
 c057408:	a804      	add	r0, sp, #16
 c05740a:	f7fb fb46 	bl	c052a9a <mbedtls_asn1_get_int>
 c05740e:	2800      	cmp	r0, #0
 c057410:	d1f0      	bne.n	c0573f4 <pk_parse_key_pkcs1_der+0x20>
    if( version != 0 )
 c057412:	9b02      	ldr	r3, [sp, #8]
 c057414:	2b00      	cmp	r3, #0
 c057416:	f040 8094 	bne.w	c057542 <pk_parse_key_pkcs1_der+0x16e>
    if( ( ret = asn1_get_nonzero_mpi( &p, end, &T ) ) != 0 ||
 c05741a:	4631      	mov	r1, r6
 c05741c:	aa05      	add	r2, sp, #20
 c05741e:	a804      	add	r0, sp, #16
 c057420:	f7ff ffc6 	bl	c0573b0 <asn1_get_nonzero_mpi>
 c057424:	4604      	mov	r4, r0
 c057426:	2800      	cmp	r0, #0
 c057428:	d17a      	bne.n	c057520 <pk_parse_key_pkcs1_der+0x14c>
        ( ret = mbedtls_rsa_import( rsa, &T, NULL, NULL,
 c05742a:	4603      	mov	r3, r0
 c05742c:	4602      	mov	r2, r0
 c05742e:	e9cd 0000 	strd	r0, r0, [sp]
 c057432:	a905      	add	r1, sp, #20
 c057434:	4628      	mov	r0, r5
 c057436:	f7f7 feef 	bl	c04f218 <mbedtls_rsa_import>
    if( ( ret = asn1_get_nonzero_mpi( &p, end, &T ) ) != 0 ||
 c05743a:	4604      	mov	r4, r0
 c05743c:	2800      	cmp	r0, #0
 c05743e:	d16f      	bne.n	c057520 <pk_parse_key_pkcs1_der+0x14c>
    if( ( ret = asn1_get_nonzero_mpi( &p, end, &T ) ) != 0 ||
 c057440:	4631      	mov	r1, r6
 c057442:	aa05      	add	r2, sp, #20
 c057444:	a804      	add	r0, sp, #16
 c057446:	f7ff ffb3 	bl	c0573b0 <asn1_get_nonzero_mpi>
 c05744a:	4604      	mov	r4, r0
 c05744c:	2800      	cmp	r0, #0
 c05744e:	d167      	bne.n	c057520 <pk_parse_key_pkcs1_der+0x14c>
        ( ret = mbedtls_rsa_import( rsa, NULL, NULL, NULL,
 c057450:	ab05      	add	r3, sp, #20
 c057452:	e9cd 0300 	strd	r0, r3, [sp]
 c057456:	4602      	mov	r2, r0
 c057458:	4603      	mov	r3, r0
 c05745a:	4601      	mov	r1, r0
 c05745c:	4628      	mov	r0, r5
 c05745e:	f7f7 fedb 	bl	c04f218 <mbedtls_rsa_import>
    if( ( ret = asn1_get_nonzero_mpi( &p, end, &T ) ) != 0 ||
 c057462:	4604      	mov	r4, r0
 c057464:	2800      	cmp	r0, #0
 c057466:	d15b      	bne.n	c057520 <pk_parse_key_pkcs1_der+0x14c>
    if( ( ret = asn1_get_nonzero_mpi( &p, end, &T ) ) != 0 ||
 c057468:	4631      	mov	r1, r6
 c05746a:	aa05      	add	r2, sp, #20
 c05746c:	a804      	add	r0, sp, #16
 c05746e:	f7ff ff9f 	bl	c0573b0 <asn1_get_nonzero_mpi>
 c057472:	4604      	mov	r4, r0
 c057474:	2800      	cmp	r0, #0
 c057476:	d153      	bne.n	c057520 <pk_parse_key_pkcs1_der+0x14c>
        ( ret = mbedtls_rsa_import( rsa, NULL, NULL, NULL,
 c057478:	ab05      	add	r3, sp, #20
 c05747a:	4602      	mov	r2, r0
 c05747c:	4601      	mov	r1, r0
 c05747e:	9001      	str	r0, [sp, #4]
 c057480:	9300      	str	r3, [sp, #0]
 c057482:	4603      	mov	r3, r0
 c057484:	4628      	mov	r0, r5
 c057486:	f7f7 fec7 	bl	c04f218 <mbedtls_rsa_import>
    if( ( ret = asn1_get_nonzero_mpi( &p, end, &T ) ) != 0 ||
 c05748a:	4604      	mov	r4, r0
 c05748c:	2800      	cmp	r0, #0
 c05748e:	d147      	bne.n	c057520 <pk_parse_key_pkcs1_der+0x14c>
    if( ( ret = asn1_get_nonzero_mpi( &p, end, &T ) ) != 0 ||
 c057490:	4631      	mov	r1, r6
 c057492:	aa05      	add	r2, sp, #20
 c057494:	a804      	add	r0, sp, #16
 c057496:	f7ff ff8b 	bl	c0573b0 <asn1_get_nonzero_mpi>
 c05749a:	4604      	mov	r4, r0
 c05749c:	2800      	cmp	r0, #0
 c05749e:	d13f      	bne.n	c057520 <pk_parse_key_pkcs1_der+0x14c>
        ( ret = mbedtls_rsa_import( rsa, NULL, &T, NULL,
 c0574a0:	2300      	movs	r3, #0
 c0574a2:	4628      	mov	r0, r5
 c0574a4:	4619      	mov	r1, r3
 c0574a6:	e9cd 3300 	strd	r3, r3, [sp]
 c0574aa:	aa05      	add	r2, sp, #20
 c0574ac:	f7f7 feb4 	bl	c04f218 <mbedtls_rsa_import>
    if( ( ret = asn1_get_nonzero_mpi( &p, end, &T ) ) != 0 ||
 c0574b0:	4604      	mov	r4, r0
 c0574b2:	2800      	cmp	r0, #0
 c0574b4:	d134      	bne.n	c057520 <pk_parse_key_pkcs1_der+0x14c>
    if( ( ret = asn1_get_nonzero_mpi( &p, end, &T ) ) != 0 ||
 c0574b6:	4631      	mov	r1, r6
 c0574b8:	aa05      	add	r2, sp, #20
 c0574ba:	a804      	add	r0, sp, #16
 c0574bc:	f7ff ff78 	bl	c0573b0 <asn1_get_nonzero_mpi>
 c0574c0:	4604      	mov	r4, r0
 c0574c2:	bb68      	cbnz	r0, c057520 <pk_parse_key_pkcs1_der+0x14c>
        ( ret = mbedtls_rsa_import( rsa, NULL, NULL, &T,
 c0574c4:	4602      	mov	r2, r0
 c0574c6:	4601      	mov	r1, r0
 c0574c8:	e9cd 0000 	strd	r0, r0, [sp]
 c0574cc:	ab05      	add	r3, sp, #20
 c0574ce:	4628      	mov	r0, r5
 c0574d0:	f7f7 fea2 	bl	c04f218 <mbedtls_rsa_import>
    if( ( ret = asn1_get_nonzero_mpi( &p, end, &T ) ) != 0 ||
 c0574d4:	4604      	mov	r4, r0
 c0574d6:	bb18      	cbnz	r0, c057520 <pk_parse_key_pkcs1_der+0x14c>
    if( ( ret = asn1_get_nonzero_mpi( &p, end, &T ) ) != 0 ||
 c0574d8:	4631      	mov	r1, r6
 c0574da:	aa05      	add	r2, sp, #20
 c0574dc:	a804      	add	r0, sp, #16
 c0574de:	f7ff ff67 	bl	c0573b0 <asn1_get_nonzero_mpi>
 c0574e2:	4604      	mov	r4, r0
 c0574e4:	b9e0      	cbnz	r0, c057520 <pk_parse_key_pkcs1_der+0x14c>
        ( ret = asn1_get_nonzero_mpi( &p, end, &T ) ) != 0 ||
 c0574e6:	4631      	mov	r1, r6
 c0574e8:	aa05      	add	r2, sp, #20
 c0574ea:	a804      	add	r0, sp, #16
 c0574ec:	f7ff ff60 	bl	c0573b0 <asn1_get_nonzero_mpi>
    if( ( ret = asn1_get_nonzero_mpi( &p, end, &T ) ) != 0 ||
 c0574f0:	4604      	mov	r4, r0
 c0574f2:	b9a8      	cbnz	r0, c057520 <pk_parse_key_pkcs1_der+0x14c>
        ( ret = asn1_get_nonzero_mpi( &p, end, &T ) ) != 0 )
 c0574f4:	4631      	mov	r1, r6
 c0574f6:	aa05      	add	r2, sp, #20
 c0574f8:	a804      	add	r0, sp, #16
 c0574fa:	f7ff ff59 	bl	c0573b0 <asn1_get_nonzero_mpi>
        ( ret = asn1_get_nonzero_mpi( &p, end, &T ) ) != 0 ||
 c0574fe:	4604      	mov	r4, r0
 c057500:	b970      	cbnz	r0, c057520 <pk_parse_key_pkcs1_der+0x14c>
    if( ( ret = mbedtls_rsa_complete( rsa ) ) != 0 ||
 c057502:	4628      	mov	r0, r5
 c057504:	f7f7 ff0e 	bl	c04f324 <mbedtls_rsa_complete>
 c057508:	4604      	mov	r4, r0
 c05750a:	b948      	cbnz	r0, c057520 <pk_parse_key_pkcs1_der+0x14c>
        ( ret = mbedtls_rsa_check_pubkey( rsa ) ) != 0 )
 c05750c:	4628      	mov	r0, r5
 c05750e:	f7f8 f8b1 	bl	c04f674 <mbedtls_rsa_check_pubkey>
    if( ( ret = mbedtls_rsa_complete( rsa ) ) != 0 ||
 c057512:	4604      	mov	r4, r0
 c057514:	b920      	cbnz	r0, c057520 <pk_parse_key_pkcs1_der+0x14c>
        ret = MBEDTLS_ERROR_ADD( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT,
 c057516:	9a04      	ldr	r2, [sp, #16]
 c057518:	4b0b      	ldr	r3, [pc, #44]	@ (c057548 <pk_parse_key_pkcs1_der+0x174>)
 c05751a:	42b2      	cmp	r2, r6
 c05751c:	bf18      	it	ne
 c05751e:	461c      	movne	r4, r3
    mbedtls_mpi_free( &T );
 c057520:	a805      	add	r0, sp, #20
 c057522:	f7fb feee 	bl	c053302 <mbedtls_mpi_free>
    if( ret != 0 )
 c057526:	2c00      	cmp	r4, #0
 c057528:	f43f af66 	beq.w	c0573f8 <pk_parse_key_pkcs1_der+0x24>
        if( ( ret & 0xff80 ) == 0 )
 c05752c:	f64f 7380 	movw	r3, #65408	@ 0xff80
        mbedtls_rsa_free( rsa );
 c057530:	4628      	mov	r0, r5
        if( ( ret & 0xff80 ) == 0 )
 c057532:	421c      	tst	r4, r3
            ret = MBEDTLS_ERR_PK_KEY_INVALID_FORMAT;
 c057534:	bf14      	ite	ne
 c057536:	4c05      	ldrne	r4, [pc, #20]	@ (c05754c <pk_parse_key_pkcs1_der+0x178>)
 c057538:	f5a4 5474 	subeq.w	r4, r4, #15616	@ 0x3d00
        mbedtls_rsa_free( rsa );
 c05753c:	f7f9 f8e4 	bl	c050708 <mbedtls_rsa_free>
 c057540:	e75a      	b.n	c0573f8 <pk_parse_key_pkcs1_der+0x24>
        return( MBEDTLS_ERR_PK_KEY_INVALID_VERSION );
 c057542:	4c03      	ldr	r4, [pc, #12]	@ (c057550 <pk_parse_key_pkcs1_der+0x17c>)
 c057544:	e758      	b.n	c0573f8 <pk_parse_key_pkcs1_der+0x24>
 c057546:	bf00      	nop
 c057548:	ffffc29a 	.word	0xffffc29a
 c05754c:	ffffc300 	.word	0xffffc300
 c057550:	ffffc280 	.word	0xffffc280

0c057554 <pk_get_pk_alg>:
{
 c057554:	b530      	push	{r4, r5, lr}
 c057556:	4615      	mov	r5, r2
    memset( params, 0, sizeof(mbedtls_asn1_buf) );
 c057558:	2200      	movs	r2, #0
{
 c05755a:	b085      	sub	sp, #20
    memset( params, 0, sizeof(mbedtls_asn1_buf) );
 c05755c:	e9c3 2200 	strd	r2, r2, [r3]
 c057560:	609a      	str	r2, [r3, #8]
    if( ( ret = mbedtls_asn1_get_alg( p, end, &alg_oid, params ) ) != 0 )
 c057562:	aa01      	add	r2, sp, #4
{
 c057564:	461c      	mov	r4, r3
    if( ( ret = mbedtls_asn1_get_alg( p, end, &alg_oid, params ) ) != 0 )
 c057566:	f7fb fac3 	bl	c052af0 <mbedtls_asn1_get_alg>
 c05756a:	b118      	cbz	r0, c057574 <pk_get_pk_alg+0x20>
 c05756c:	f5a0 506a 	sub.w	r0, r0, #14976	@ 0x3a80
}
 c057570:	b005      	add	sp, #20
 c057572:	bd30      	pop	{r4, r5, pc}
    if( mbedtls_oid_get_pk_alg( &alg_oid, pk_alg ) != 0 )
 c057574:	4629      	mov	r1, r5
 c057576:	a801      	add	r0, sp, #4
 c057578:	f7ff fbde 	bl	c056d38 <mbedtls_oid_get_pk_alg>
 c05757c:	b960      	cbnz	r0, c057598 <pk_get_pk_alg+0x44>
    if( *pk_alg == MBEDTLS_PK_RSA &&
 c05757e:	782b      	ldrb	r3, [r5, #0]
 c057580:	2b01      	cmp	r3, #1
 c057582:	d1f5      	bne.n	c057570 <pk_get_pk_alg+0x1c>
            ( ( params->tag != MBEDTLS_ASN1_NULL && params->tag != 0 ) ||
 c057584:	6823      	ldr	r3, [r4, #0]
    if( *pk_alg == MBEDTLS_PK_RSA &&
 c057586:	2b05      	cmp	r3, #5
 c057588:	d000      	beq.n	c05758c <pk_get_pk_alg+0x38>
            ( ( params->tag != MBEDTLS_ASN1_NULL && params->tag != 0 ) ||
 c05758a:	b93b      	cbnz	r3, c05759c <pk_get_pk_alg+0x48>
 c05758c:	6862      	ldr	r2, [r4, #4]
        return( MBEDTLS_ERR_PK_INVALID_ALG );
 c05758e:	4b04      	ldr	r3, [pc, #16]	@ (c0575a0 <pk_get_pk_alg+0x4c>)
 c057590:	2a00      	cmp	r2, #0
 c057592:	bf18      	it	ne
 c057594:	4618      	movne	r0, r3
 c057596:	e7eb      	b.n	c057570 <pk_get_pk_alg+0x1c>
        return( MBEDTLS_ERR_PK_UNKNOWN_PK_ALG );
 c057598:	4802      	ldr	r0, [pc, #8]	@ (c0575a4 <pk_get_pk_alg+0x50>)
 c05759a:	e7e9      	b.n	c057570 <pk_get_pk_alg+0x1c>
        return( MBEDTLS_ERR_PK_INVALID_ALG );
 c05759c:	4800      	ldr	r0, [pc, #0]	@ (c0575a0 <pk_get_pk_alg+0x4c>)
 c05759e:	e7e7      	b.n	c057570 <pk_get_pk_alg+0x1c>
 c0575a0:	ffffc580 	.word	0xffffc580
 c0575a4:	ffffc380 	.word	0xffffc380

0c0575a8 <mbedtls_pk_parse_subpubkey>:
    mbedtls_pk_type_t pk_alg = MBEDTLS_PK_NONE;
 c0575a8:	2300      	movs	r3, #0
{
 c0575aa:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 c0575ae:	b086      	sub	sp, #24
 c0575b0:	4690      	mov	r8, r2
    mbedtls_pk_type_t pk_alg = MBEDTLS_PK_NONE;
 c0575b2:	f88d 3007 	strb.w	r3, [sp, #7]
    if( ( ret = mbedtls_asn1_get_tag( p, end, &len,
 c0575b6:	aa02      	add	r2, sp, #8
 c0575b8:	2330      	movs	r3, #48	@ 0x30
{
 c0575ba:	4606      	mov	r6, r0
    if( ( ret = mbedtls_asn1_get_tag( p, end, &len,
 c0575bc:	f7fb fa23 	bl	c052a06 <mbedtls_asn1_get_tag>
 c0575c0:	b128      	cbz	r0, c0575ce <mbedtls_pk_parse_subpubkey+0x26>
 c0575c2:	f5a0 5474 	sub.w	r4, r0, #15616	@ 0x3d00
}
 c0575c6:	4620      	mov	r0, r4
 c0575c8:	b006      	add	sp, #24
 c0575ca:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    end = *p + len;
 c0575ce:	9b02      	ldr	r3, [sp, #8]
 c0575d0:	6837      	ldr	r7, [r6, #0]
    if( ( ret = pk_get_pk_alg( p, end, &pk_alg, &alg_params ) ) != 0 )
 c0575d2:	4630      	mov	r0, r6
    end = *p + len;
 c0575d4:	441f      	add	r7, r3
    if( ( ret = pk_get_pk_alg( p, end, &pk_alg, &alg_params ) ) != 0 )
 c0575d6:	4639      	mov	r1, r7
 c0575d8:	ab03      	add	r3, sp, #12
 c0575da:	f10d 0207 	add.w	r2, sp, #7
 c0575de:	f7ff ffb9 	bl	c057554 <pk_get_pk_alg>
 c0575e2:	4604      	mov	r4, r0
 c0575e4:	2800      	cmp	r0, #0
 c0575e6:	d1ee      	bne.n	c0575c6 <mbedtls_pk_parse_subpubkey+0x1e>
    if( ( ret = mbedtls_asn1_get_bitstring_null( p, end, &len ) ) != 0 )
 c0575e8:	4639      	mov	r1, r7
 c0575ea:	4630      	mov	r0, r6
 c0575ec:	aa02      	add	r2, sp, #8
 c0575ee:	f7fb fa6b 	bl	c052ac8 <mbedtls_asn1_get_bitstring_null>
 c0575f2:	b110      	cbz	r0, c0575fa <mbedtls_pk_parse_subpubkey+0x52>
 c0575f4:	f5a0 546c 	sub.w	r4, r0, #15104	@ 0x3b00
        return( MBEDTLS_ERROR_ADD( MBEDTLS_ERR_PK_INVALID_PUBKEY, ret ) );
 c0575f8:	e7e5      	b.n	c0575c6 <mbedtls_pk_parse_subpubkey+0x1e>
    if( *p + len != end )
 c0575fa:	6833      	ldr	r3, [r6, #0]
 c0575fc:	9a02      	ldr	r2, [sp, #8]
 c0575fe:	4413      	add	r3, r2
 c057600:	429f      	cmp	r7, r3
 c057602:	d146      	bne.n	c057692 <mbedtls_pk_parse_subpubkey+0xea>
    if( ( pk_info = mbedtls_pk_info_from_type( pk_alg ) ) == NULL )
 c057604:	f89d 0007 	ldrb.w	r0, [sp, #7]
 c057608:	f7ff fc06 	bl	c056e18 <mbedtls_pk_info_from_type>
 c05760c:	4601      	mov	r1, r0
 c05760e:	2800      	cmp	r0, #0
 c057610:	d041      	beq.n	c057696 <mbedtls_pk_parse_subpubkey+0xee>
    if( ( ret = mbedtls_pk_setup( pk, pk_info ) ) != 0 )
 c057612:	4640      	mov	r0, r8
 c057614:	f7ff fc0c 	bl	c056e30 <mbedtls_pk_setup>
 c057618:	4604      	mov	r4, r0
 c05761a:	2800      	cmp	r0, #0
 c05761c:	d1d3      	bne.n	c0575c6 <mbedtls_pk_parse_subpubkey+0x1e>
    if( pk_alg == MBEDTLS_PK_RSA )
 c05761e:	f89d 3007 	ldrb.w	r3, [sp, #7]
 c057622:	2b01      	cmp	r3, #1
 c057624:	d10c      	bne.n	c057640 <mbedtls_pk_parse_subpubkey+0x98>
        ret = pk_get_rsapubkey( p, end, mbedtls_pk_rsa( *pk ) );
 c057626:	4639      	mov	r1, r7
 c057628:	4630      	mov	r0, r6
 c05762a:	f8d8 2004 	ldr.w	r2, [r8, #4]
 c05762e:	f7ff fd75 	bl	c05711c <pk_get_rsapubkey>
    if( ret == 0 && *p != end )
 c057632:	4605      	mov	r5, r0
 c057634:	b330      	cbz	r0, c057684 <mbedtls_pk_parse_subpubkey+0xdc>
        mbedtls_pk_free( pk );
 c057636:	4640      	mov	r0, r8
 c057638:	f7ff fbde 	bl	c056df8 <mbedtls_pk_free>
 c05763c:	462c      	mov	r4, r5
 c05763e:	e7c2      	b.n	c0575c6 <mbedtls_pk_parse_subpubkey+0x1e>
    if( pk_alg == MBEDTLS_PK_ECKEY_DH || pk_alg == MBEDTLS_PK_ECKEY )
 c057640:	3b02      	subs	r3, #2
 c057642:	2b01      	cmp	r3, #1
 c057644:	d823      	bhi.n	c05768e <mbedtls_pk_parse_subpubkey+0xe6>
        ret = pk_use_ecparams( &alg_params, &mbedtls_pk_ec( *pk )->grp );
 c057646:	f8d8 1004 	ldr.w	r1, [r8, #4]
 c05764a:	a803      	add	r0, sp, #12
 c05764c:	f7ff fdc8 	bl	c0571e0 <pk_use_ecparams>
        if( ret == 0 )
 c057650:	4605      	mov	r5, r0
 c057652:	2800      	cmp	r0, #0
 c057654:	d1ef      	bne.n	c057636 <mbedtls_pk_parse_subpubkey+0x8e>
            ret = pk_get_ecpubkey( p, end, mbedtls_pk_ec( *pk ) );
 c057656:	f8d8 9004 	ldr.w	r9, [r8, #4]
    if( ( ret = mbedtls_ecp_point_read_binary( &key->grp, &key->Q,
 c05765a:	6832      	ldr	r2, [r6, #0]
 c05765c:	f109 0aac 	add.w	sl, r9, #172	@ 0xac
 c057660:	4651      	mov	r1, sl
 c057662:	4648      	mov	r0, r9
 c057664:	1abb      	subs	r3, r7, r2
 c057666:	f7f5 fa2d 	bl	c04cac4 <mbedtls_ecp_point_read_binary>
 c05766a:	4605      	mov	r5, r0
 c05766c:	b108      	cbz	r0, c057672 <mbedtls_pk_parse_subpubkey+0xca>
    *p = (unsigned char *) end;
 c05766e:	6037      	str	r7, [r6, #0]
    if( ret == 0 && *p != end )
 c057670:	e7e1      	b.n	c057636 <mbedtls_pk_parse_subpubkey+0x8e>
        ret = mbedtls_ecp_check_pubkey( &key->grp, &key->Q );
 c057672:	4651      	mov	r1, sl
 c057674:	4648      	mov	r0, r9
 c057676:	f7f5 fa95 	bl	c04cba4 <mbedtls_ecp_check_pubkey>
    *p = (unsigned char *) end;
 c05767a:	6037      	str	r7, [r6, #0]
    if( ret == 0 && *p != end )
 c05767c:	4605      	mov	r5, r0
 c05767e:	2800      	cmp	r0, #0
 c057680:	d0a1      	beq.n	c0575c6 <mbedtls_pk_parse_subpubkey+0x1e>
 c057682:	e7d8      	b.n	c057636 <mbedtls_pk_parse_subpubkey+0x8e>
 c057684:	6833      	ldr	r3, [r6, #0]
 c057686:	42bb      	cmp	r3, r7
 c057688:	d09d      	beq.n	c0575c6 <mbedtls_pk_parse_subpubkey+0x1e>
        ret = MBEDTLS_ERROR_ADD( MBEDTLS_ERR_PK_INVALID_PUBKEY,
 c05768a:	4d04      	ldr	r5, [pc, #16]	@ (c05769c <mbedtls_pk_parse_subpubkey+0xf4>)
 c05768c:	e7d3      	b.n	c057636 <mbedtls_pk_parse_subpubkey+0x8e>
 c05768e:	4d04      	ldr	r5, [pc, #16]	@ (c0576a0 <mbedtls_pk_parse_subpubkey+0xf8>)
 c057690:	e7d1      	b.n	c057636 <mbedtls_pk_parse_subpubkey+0x8e>
        return( MBEDTLS_ERROR_ADD( MBEDTLS_ERR_PK_INVALID_PUBKEY,
 c057692:	4c02      	ldr	r4, [pc, #8]	@ (c05769c <mbedtls_pk_parse_subpubkey+0xf4>)
 c057694:	e797      	b.n	c0575c6 <mbedtls_pk_parse_subpubkey+0x1e>
        return( MBEDTLS_ERR_PK_UNKNOWN_PK_ALG );
 c057696:	4c02      	ldr	r4, [pc, #8]	@ (c0576a0 <mbedtls_pk_parse_subpubkey+0xf8>)
 c057698:	e795      	b.n	c0575c6 <mbedtls_pk_parse_subpubkey+0x1e>
 c05769a:	bf00      	nop
 c05769c:	ffffc49a 	.word	0xffffc49a
 c0576a0:	ffffc380 	.word	0xffffc380

0c0576a4 <mbedtls_pk_parse_key>:
 * Parse a private key
 */
int mbedtls_pk_parse_key( mbedtls_pk_context *pk,
                  const unsigned char *key, size_t keylen,
                  const unsigned char *pwd, size_t pwdlen )
{
 c0576a4:	b5f0      	push	{r4, r5, r6, r7, lr}
 c0576a6:	4604      	mov	r4, r0
 c0576a8:	460d      	mov	r5, r1
    size_t len;
    mbedtls_pem_context pem;
#endif

    PK_VALIDATE_RET( pk != NULL );
    if( keylen == 0 )
 c0576aa:	4616      	mov	r6, r2
{
 c0576ac:	b089      	sub	sp, #36	@ 0x24
    if( keylen == 0 )
 c0576ae:	b37a      	cbz	r2, c057710 <mbedtls_pk_parse_key+0x6c>
    mbedtls_pk_type_t pk_alg = MBEDTLS_PK_NONE;
 c0576b0:	2300      	movs	r3, #0
    unsigned char *p = (unsigned char *) key;
 c0576b2:	9104      	str	r1, [sp, #16]
    mbedtls_pk_type_t pk_alg = MBEDTLS_PK_NONE;
 c0576b4:	f88d 3007 	strb.w	r3, [sp, #7]
    if( ( ret = mbedtls_asn1_get_tag( &p, end, &len,
 c0576b8:	aa03      	add	r2, sp, #12
 c0576ba:	2330      	movs	r3, #48	@ 0x30
 c0576bc:	4431      	add	r1, r6
 c0576be:	a804      	add	r0, sp, #16
 c0576c0:	f7fb f9a1 	bl	c052a06 <mbedtls_asn1_get_tag>
 c0576c4:	b338      	cbz	r0, c057716 <mbedtls_pk_parse_key+0x72>
 c0576c6:	f5a0 5074 	sub.w	r0, r0, #15616	@ 0x3d00
        return( ret );
    }
#endif /* MBEDTLS_PKCS12_C || MBEDTLS_PKCS5_C */

    ret = pk_parse_key_pkcs8_unencrypted_der( pk, key, keylen );
    if( ret == 0 )
 c0576ca:	2800      	cmp	r0, #0
 c0576cc:	d074      	beq.n	c0577b8 <mbedtls_pk_parse_key+0x114>
    {
        return( 0 );
    }

    mbedtls_pk_free( pk );
 c0576ce:	4620      	mov	r0, r4
 c0576d0:	f7ff fb92 	bl	c056df8 <mbedtls_pk_free>
    mbedtls_pk_init( pk );
 c0576d4:	4620      	mov	r0, r4
 c0576d6:	f7ff fb8b 	bl	c056df0 <mbedtls_pk_init>

#if defined(MBEDTLS_RSA_C)

    pk_info = mbedtls_pk_info_from_type( MBEDTLS_PK_RSA );
 c0576da:	2001      	movs	r0, #1
 c0576dc:	f7ff fb9c 	bl	c056e18 <mbedtls_pk_info_from_type>
 c0576e0:	4601      	mov	r1, r0
    if( mbedtls_pk_setup( pk, pk_info ) == 0 &&
 c0576e2:	4620      	mov	r0, r4
 c0576e4:	f7ff fba4 	bl	c056e30 <mbedtls_pk_setup>
 c0576e8:	2800      	cmp	r0, #0
 c0576ea:	d05e      	beq.n	c0577aa <mbedtls_pk_parse_key+0x106>
        pk_parse_key_pkcs1_der( mbedtls_pk_rsa( *pk ), key, keylen ) == 0 )
    {
        return( 0 );
    }

    mbedtls_pk_free( pk );
 c0576ec:	4620      	mov	r0, r4
 c0576ee:	f7ff fb83 	bl	c056df8 <mbedtls_pk_free>
    mbedtls_pk_init( pk );
 c0576f2:	4620      	mov	r0, r4
 c0576f4:	f7ff fb7c 	bl	c056df0 <mbedtls_pk_init>
#endif /* MBEDTLS_RSA_C */

#if defined(MBEDTLS_ECP_C)
    pk_info = mbedtls_pk_info_from_type( MBEDTLS_PK_ECKEY );
 c0576f8:	2002      	movs	r0, #2
 c0576fa:	f7ff fb8d 	bl	c056e18 <mbedtls_pk_info_from_type>
 c0576fe:	4601      	mov	r1, r0
    if( mbedtls_pk_setup( pk, pk_info ) == 0 &&
 c057700:	4620      	mov	r0, r4
 c057702:	f7ff fb95 	bl	c056e30 <mbedtls_pk_setup>
 c057706:	2800      	cmp	r0, #0
 c057708:	d058      	beq.n	c0577bc <mbedtls_pk_parse_key+0x118>
        pk_parse_key_sec1_der( mbedtls_pk_ec( *pk ),
                               key, keylen ) == 0 )
    {
        return( 0 );
    }
    mbedtls_pk_free( pk );
 c05770a:	4620      	mov	r0, r4
 c05770c:	f7ff fb74 	bl	c056df8 <mbedtls_pk_free>
        return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT );
 c057710:	482e      	ldr	r0, [pc, #184]	@ (c0577cc <mbedtls_pk_parse_key+0x128>)
     * twice, once here and once by the caller, but this is
     * also ok and in line with the mbedtls_pk_free() calls
     * on failed PEM parsing attempts. */

    return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT );
}
 c057712:	b009      	add	sp, #36	@ 0x24
 c057714:	bdf0      	pop	{r4, r5, r6, r7, pc}
    end = p + len;
 c057716:	e9dd 3703 	ldrd	r3, r7, [sp, #12]
 c05771a:	441f      	add	r7, r3
    if( ( ret = mbedtls_asn1_get_int( &p, end, &version ) ) != 0 )
 c05771c:	4639      	mov	r1, r7
 c05771e:	aa02      	add	r2, sp, #8
 c057720:	a804      	add	r0, sp, #16
 c057722:	f7fb f9ba 	bl	c052a9a <mbedtls_asn1_get_int>
 c057726:	2800      	cmp	r0, #0
 c057728:	d1cd      	bne.n	c0576c6 <mbedtls_pk_parse_key+0x22>
    if( version != 0 )
 c05772a:	9b02      	ldr	r3, [sp, #8]
 c05772c:	2b00      	cmp	r3, #0
 c05772e:	d1ce      	bne.n	c0576ce <mbedtls_pk_parse_key+0x2a>
    if( ( ret = pk_get_pk_alg( &p, end, &pk_alg, &params ) ) != 0 )
 c057730:	4639      	mov	r1, r7
 c057732:	ab05      	add	r3, sp, #20
 c057734:	f10d 0207 	add.w	r2, sp, #7
 c057738:	a804      	add	r0, sp, #16
 c05773a:	f7ff ff0b 	bl	c057554 <pk_get_pk_alg>
 c05773e:	2800      	cmp	r0, #0
 c057740:	d1c5      	bne.n	c0576ce <mbedtls_pk_parse_key+0x2a>
    if( ( ret = mbedtls_asn1_get_tag( &p, end, &len, MBEDTLS_ASN1_OCTET_STRING ) ) != 0 )
 c057742:	2304      	movs	r3, #4
 c057744:	4639      	mov	r1, r7
 c057746:	aa03      	add	r2, sp, #12
 c057748:	a804      	add	r0, sp, #16
 c05774a:	f7fb f95c 	bl	c052a06 <mbedtls_asn1_get_tag>
 c05774e:	2800      	cmp	r0, #0
 c057750:	d1b9      	bne.n	c0576c6 <mbedtls_pk_parse_key+0x22>
    if( len < 1 )
 c057752:	9b03      	ldr	r3, [sp, #12]
 c057754:	2b00      	cmp	r3, #0
 c057756:	d0ba      	beq.n	c0576ce <mbedtls_pk_parse_key+0x2a>
    if( ( pk_info = mbedtls_pk_info_from_type( pk_alg ) ) == NULL )
 c057758:	f89d 0007 	ldrb.w	r0, [sp, #7]
 c05775c:	f7ff fb5c 	bl	c056e18 <mbedtls_pk_info_from_type>
 c057760:	4601      	mov	r1, r0
 c057762:	2800      	cmp	r0, #0
 c057764:	d0b3      	beq.n	c0576ce <mbedtls_pk_parse_key+0x2a>
    if( ( ret = mbedtls_pk_setup( pk, pk_info ) ) != 0 )
 c057766:	4620      	mov	r0, r4
 c057768:	f7ff fb62 	bl	c056e30 <mbedtls_pk_setup>
 c05776c:	2800      	cmp	r0, #0
 c05776e:	d1ae      	bne.n	c0576ce <mbedtls_pk_parse_key+0x2a>
    if( pk_alg == MBEDTLS_PK_RSA )
 c057770:	f89d 3007 	ldrb.w	r3, [sp, #7]
 c057774:	2b01      	cmp	r3, #1
 c057776:	d109      	bne.n	c05778c <mbedtls_pk_parse_key+0xe8>
        if( ( ret = pk_parse_key_pkcs1_der( mbedtls_pk_rsa( *pk ), p, len ) ) != 0 )
 c057778:	e9dd 2103 	ldrd	r2, r1, [sp, #12]
 c05777c:	6860      	ldr	r0, [r4, #4]
 c05777e:	f7ff fe29 	bl	c0573d4 <pk_parse_key_pkcs1_der>
 c057782:	b1c8      	cbz	r0, c0577b8 <mbedtls_pk_parse_key+0x114>
            mbedtls_pk_free( pk );
 c057784:	4620      	mov	r0, r4
 c057786:	f7ff fb37 	bl	c056df8 <mbedtls_pk_free>
    if( ret == 0 )
 c05778a:	e7a0      	b.n	c0576ce <mbedtls_pk_parse_key+0x2a>
    if( pk_alg == MBEDTLS_PK_ECKEY || pk_alg == MBEDTLS_PK_ECKEY_DH )
 c05778c:	3b02      	subs	r3, #2
 c05778e:	2b01      	cmp	r3, #1
 c057790:	d89d      	bhi.n	c0576ce <mbedtls_pk_parse_key+0x2a>
        if( ( ret = pk_use_ecparams( &params, &mbedtls_pk_ec( *pk )->grp ) ) != 0 ||
 c057792:	6861      	ldr	r1, [r4, #4]
 c057794:	a805      	add	r0, sp, #20
 c057796:	f7ff fd23 	bl	c0571e0 <pk_use_ecparams>
 c05779a:	2800      	cmp	r0, #0
 c05779c:	d1f2      	bne.n	c057784 <mbedtls_pk_parse_key+0xe0>
            ( ret = pk_parse_key_sec1_der( mbedtls_pk_ec( *pk ), p, len )  ) != 0 )
 c05779e:	e9dd 2103 	ldrd	r2, r1, [sp, #12]
 c0577a2:	6860      	ldr	r0, [r4, #4]
 c0577a4:	f7ff fd3a 	bl	c05721c <pk_parse_key_sec1_der>
 c0577a8:	e7eb      	b.n	c057782 <mbedtls_pk_parse_key+0xde>
        pk_parse_key_pkcs1_der( mbedtls_pk_rsa( *pk ), key, keylen ) == 0 )
 c0577aa:	4632      	mov	r2, r6
 c0577ac:	4629      	mov	r1, r5
 c0577ae:	6860      	ldr	r0, [r4, #4]
 c0577b0:	f7ff fe10 	bl	c0573d4 <pk_parse_key_pkcs1_der>
    if( mbedtls_pk_setup( pk, pk_info ) == 0 &&
 c0577b4:	2800      	cmp	r0, #0
 c0577b6:	d199      	bne.n	c0576ec <mbedtls_pk_parse_key+0x48>
        return( 0 );
 c0577b8:	2000      	movs	r0, #0
 c0577ba:	e7aa      	b.n	c057712 <mbedtls_pk_parse_key+0x6e>
        pk_parse_key_sec1_der( mbedtls_pk_ec( *pk ),
 c0577bc:	4632      	mov	r2, r6
 c0577be:	4629      	mov	r1, r5
 c0577c0:	6860      	ldr	r0, [r4, #4]
 c0577c2:	f7ff fd2b 	bl	c05721c <pk_parse_key_sec1_der>
    if( mbedtls_pk_setup( pk, pk_info ) == 0 &&
 c0577c6:	2800      	cmp	r0, #0
 c0577c8:	d0f6      	beq.n	c0577b8 <mbedtls_pk_parse_key+0x114>
 c0577ca:	e79e      	b.n	c05770a <mbedtls_pk_parse_key+0x66>
 c0577cc:	ffffc300 	.word	0xffffc300

0c0577d0 <mbedtls_pk_parse_public_key>:
/*
 * Parse a public key
 */
int mbedtls_pk_parse_public_key( mbedtls_pk_context *ctx,
                         const unsigned char *key, size_t keylen )
{
 c0577d0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 c0577d2:	4606      	mov	r6, r0
 c0577d4:	460f      	mov	r7, r1
    size_t len;
    mbedtls_pem_context pem;
#endif

    PK_VALIDATE_RET( ctx != NULL );
    if( keylen == 0 )
 c0577d6:	4615      	mov	r5, r2
 c0577d8:	b312      	cbz	r2, c057820 <mbedtls_pk_parse_public_key+0x50>
    }
    mbedtls_pem_free( &pem );
#endif /* MBEDTLS_PEM_PARSE_C */

#if defined(MBEDTLS_RSA_C)
    if( ( pk_info = mbedtls_pk_info_from_type( MBEDTLS_PK_RSA ) ) == NULL )
 c0577da:	2001      	movs	r0, #1
 c0577dc:	f7ff fb1c 	bl	c056e18 <mbedtls_pk_info_from_type>
 c0577e0:	4601      	mov	r1, r0
 c0577e2:	b1f8      	cbz	r0, c057824 <mbedtls_pk_parse_public_key+0x54>
        return( MBEDTLS_ERR_PK_UNKNOWN_PK_ALG );

    if( ( ret = mbedtls_pk_setup( ctx, pk_info ) ) != 0 )
 c0577e4:	4630      	mov	r0, r6
 c0577e6:	f7ff fb23 	bl	c056e30 <mbedtls_pk_setup>
 c0577ea:	4604      	mov	r4, r0
 c0577ec:	b9a8      	cbnz	r0, c05781a <mbedtls_pk_parse_public_key+0x4a>
        return( ret );

    p = (unsigned char *)key;
    ret = pk_get_rsapubkey( &p, p + keylen, mbedtls_pk_rsa( *ctx ) );
 c0577ee:	443d      	add	r5, r7
 c0577f0:	4629      	mov	r1, r5
 c0577f2:	6872      	ldr	r2, [r6, #4]
 c0577f4:	a801      	add	r0, sp, #4
    p = (unsigned char *)key;
 c0577f6:	9701      	str	r7, [sp, #4]
    ret = pk_get_rsapubkey( &p, p + keylen, mbedtls_pk_rsa( *ctx ) );
 c0577f8:	f7ff fc90 	bl	c05711c <pk_get_rsapubkey>
    if( ret == 0 )
 c0577fc:	4604      	mov	r4, r0
 c0577fe:	b160      	cbz	r0, c05781a <mbedtls_pk_parse_public_key+0x4a>
    {
        return( ret );
    }
    mbedtls_pk_free( ctx );
 c057800:	4630      	mov	r0, r6
 c057802:	f7ff faf9 	bl	c056df8 <mbedtls_pk_free>
    if( ret != ( MBEDTLS_ERROR_ADD( MBEDTLS_ERR_PK_INVALID_PUBKEY,
 c057806:	4b08      	ldr	r3, [pc, #32]	@ (c057828 <mbedtls_pk_parse_public_key+0x58>)
 c057808:	429c      	cmp	r4, r3
 c05780a:	d106      	bne.n	c05781a <mbedtls_pk_parse_public_key+0x4a>
        return( ret );
    }
#endif /* MBEDTLS_RSA_C */
    p = (unsigned char *) key;

    ret = mbedtls_pk_parse_subpubkey( &p, p + keylen, ctx );
 c05780c:	4632      	mov	r2, r6
 c05780e:	4629      	mov	r1, r5
 c057810:	a801      	add	r0, sp, #4
    p = (unsigned char *) key;
 c057812:	9701      	str	r7, [sp, #4]
    ret = mbedtls_pk_parse_subpubkey( &p, p + keylen, ctx );
 c057814:	f7ff fec8 	bl	c0575a8 <mbedtls_pk_parse_subpubkey>
 c057818:	4604      	mov	r4, r0

    return( ret );
}
 c05781a:	4620      	mov	r0, r4
 c05781c:	b003      	add	sp, #12
 c05781e:	bdf0      	pop	{r4, r5, r6, r7, pc}
        return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT );
 c057820:	4c02      	ldr	r4, [pc, #8]	@ (c05782c <mbedtls_pk_parse_public_key+0x5c>)
 c057822:	e7fa      	b.n	c05781a <mbedtls_pk_parse_public_key+0x4a>
        return( MBEDTLS_ERR_PK_UNKNOWN_PK_ALG );
 c057824:	4c02      	ldr	r4, [pc, #8]	@ (c057830 <mbedtls_pk_parse_public_key+0x60>)
 c057826:	e7f8      	b.n	c05781a <mbedtls_pk_parse_public_key+0x4a>
 c057828:	ffffc49e 	.word	0xffffc49e
 c05782c:	ffffc300 	.word	0xffffc300
 c057830:	ffffc380 	.word	0xffffc380

0c057834 <pk_write_ec_pubkey>:
/*
 * EC public key is an EC point
 */
static int pk_write_ec_pubkey( unsigned char **p, unsigned char *start,
                               mbedtls_ecp_keypair *ec )
{
 c057834:	b570      	push	{r4, r5, r6, lr}
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    size_t len = 0;
    unsigned char buf[MBEDTLS_ECP_MAX_PT_LEN];

    if( ( ret = mbedtls_ecp_point_write_binary( &ec->grp, &ec->Q,
 c057836:	2385      	movs	r3, #133	@ 0x85
{
 c057838:	4605      	mov	r5, r0
 c05783a:	4610      	mov	r0, r2
    size_t len = 0;
 c05783c:	2200      	movs	r2, #0
{
 c05783e:	b0a6      	sub	sp, #152	@ 0x98
    if( ( ret = mbedtls_ecp_point_write_binary( &ec->grp, &ec->Q,
 c057840:	ae04      	add	r6, sp, #16
{
 c057842:	460c      	mov	r4, r1
    if( ( ret = mbedtls_ecp_point_write_binary( &ec->grp, &ec->Q,
 c057844:	9301      	str	r3, [sp, #4]
 c057846:	9600      	str	r6, [sp, #0]
 c057848:	ab03      	add	r3, sp, #12
 c05784a:	f100 01ac 	add.w	r1, r0, #172	@ 0xac
    size_t len = 0;
 c05784e:	9203      	str	r2, [sp, #12]
    if( ( ret = mbedtls_ecp_point_write_binary( &ec->grp, &ec->Q,
 c057850:	f7f5 f8cc 	bl	c04c9ec <mbedtls_ecp_point_write_binary>
 c057854:	b960      	cbnz	r0, c057870 <pk_write_ec_pubkey+0x3c>
                                        &len, buf, sizeof( buf ) ) ) != 0 )
    {
        return( ret );
    }

    if( *p < start || (size_t)( *p - start ) < len )
 c057856:	6828      	ldr	r0, [r5, #0]
 c057858:	42a0      	cmp	r0, r4
 c05785a:	d30b      	bcc.n	c057874 <pk_write_ec_pubkey+0x40>
 c05785c:	9a03      	ldr	r2, [sp, #12]
 c05785e:	1b04      	subs	r4, r0, r4
 c057860:	4294      	cmp	r4, r2
 c057862:	d307      	bcc.n	c057874 <pk_write_ec_pubkey+0x40>
        return( MBEDTLS_ERR_ASN1_BUF_TOO_SMALL );

    *p -= len;
 c057864:	1a80      	subs	r0, r0, r2
    memcpy( *p, buf, len );
 c057866:	4631      	mov	r1, r6
    *p -= len;
 c057868:	6028      	str	r0, [r5, #0]
    memcpy( *p, buf, len );
 c05786a:	f003 feef 	bl	c05b64c <memcpy>

    return( (int) len );
 c05786e:	9803      	ldr	r0, [sp, #12]
}
 c057870:	b026      	add	sp, #152	@ 0x98
 c057872:	bd70      	pop	{r4, r5, r6, pc}
        return( MBEDTLS_ERR_ASN1_BUF_TOO_SMALL );
 c057874:	f06f 006b 	mvn.w	r0, #107	@ 0x6b
 c057878:	e7fa      	b.n	c057870 <pk_write_ec_pubkey+0x3c>

0c05787a <pk_write_ec_param.isra.0>:
/*
 * ECParameters ::= CHOICE {
 *   namedCurve         OBJECT IDENTIFIER
 * }
 */
static int pk_write_ec_param( unsigned char **p, unsigned char *start,
 c05787a:	b537      	push	{r0, r1, r2, r4, r5, lr}
 c05787c:	4604      	mov	r4, r0
 c05787e:	460d      	mov	r5, r1
 c057880:	4610      	mov	r0, r2
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    size_t len = 0;
    const char *oid;
    size_t oid_len;

    if( ( ret = mbedtls_oid_get_oid_by_ec_grp( ec->grp.id, &oid, &oid_len ) ) != 0 )
 c057882:	4669      	mov	r1, sp
 c057884:	aa01      	add	r2, sp, #4
 c057886:	f7ff fa8b 	bl	c056da0 <mbedtls_oid_get_oid_by_ec_grp>
 c05788a:	b928      	cbnz	r0, c057898 <pk_write_ec_param.isra.0+0x1e>
        return( ret );

    MBEDTLS_ASN1_CHK_ADD( len, mbedtls_asn1_write_oid( p, start, oid, oid_len ) );
 c05788c:	e9dd 2300 	ldrd	r2, r3, [sp]
 c057890:	4629      	mov	r1, r5
 c057892:	4620      	mov	r0, r4
 c057894:	f7fb fa8b 	bl	c052dae <mbedtls_asn1_write_oid>

    return( (int) len );
}
 c057898:	b003      	add	sp, #12
 c05789a:	bd30      	pop	{r4, r5, pc}

0c05789c <mbedtls_pk_write_pubkey>:
}
#endif /* MBEDTLS_ECP_C */

int mbedtls_pk_write_pubkey( unsigned char **p, unsigned char *start,
                             const mbedtls_pk_context *key )
{
 c05789c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 c0578a0:	4605      	mov	r5, r0
 c0578a2:	b086      	sub	sp, #24
    PK_VALIDATE_RET( *p != NULL );
    PK_VALIDATE_RET( start != NULL );
    PK_VALIDATE_RET( key != NULL );

#if defined(MBEDTLS_RSA_C)
    if( mbedtls_pk_get_type( key ) == MBEDTLS_PK_RSA )
 c0578a4:	4610      	mov	r0, r2
{
 c0578a6:	460e      	mov	r6, r1
 c0578a8:	4614      	mov	r4, r2
    if( mbedtls_pk_get_type( key ) == MBEDTLS_PK_RSA )
 c0578aa:	f7ff fad7 	bl	c056e5c <mbedtls_pk_get_type>
 c0578ae:	2801      	cmp	r0, #1
 c0578b0:	d149      	bne.n	c057946 <mbedtls_pk_write_pubkey+0xaa>
    if ( ( ret = mbedtls_rsa_export( rsa, NULL, NULL, NULL, NULL, &T ) ) != 0 ||
 c0578b2:	f04f 0a00 	mov.w	sl, #0
 c0578b6:	f8d4 9004 	ldr.w	r9, [r4, #4]
    mbedtls_mpi_init( &T );
 c0578ba:	af03      	add	r7, sp, #12
 c0578bc:	4638      	mov	r0, r7
 c0578be:	f7fb fd1a 	bl	c0532f6 <mbedtls_mpi_init>
    if ( ( ret = mbedtls_rsa_export( rsa, NULL, NULL, NULL, NULL, &T ) ) != 0 ||
 c0578c2:	4653      	mov	r3, sl
 c0578c4:	4652      	mov	r2, sl
 c0578c6:	4651      	mov	r1, sl
 c0578c8:	4648      	mov	r0, r9
 c0578ca:	9701      	str	r7, [sp, #4]
 c0578cc:	f8cd a000 	str.w	sl, [sp]
 c0578d0:	f7f7 fe0a 	bl	c04f4e8 <mbedtls_rsa_export>
 c0578d4:	4604      	mov	r4, r0
 c0578d6:	bb50      	cbnz	r0, c05792e <mbedtls_pk_write_pubkey+0x92>
         ( ret = mbedtls_asn1_write_mpi( p, start, &T ) ) < 0 )
 c0578d8:	463a      	mov	r2, r7
 c0578da:	4631      	mov	r1, r6
 c0578dc:	4628      	mov	r0, r5
 c0578de:	f7fb fa23 	bl	c052d28 <mbedtls_asn1_write_mpi>
    if ( ( ret = mbedtls_rsa_export( rsa, NULL, NULL, NULL, NULL, &T ) ) != 0 ||
 c0578e2:	1e04      	subs	r4, r0, #0
 c0578e4:	db23      	blt.n	c05792e <mbedtls_pk_write_pubkey+0x92>
    if ( ( ret = mbedtls_rsa_export( rsa, &T, NULL, NULL, NULL, NULL ) ) != 0 ||
 c0578e6:	4653      	mov	r3, sl
 c0578e8:	4652      	mov	r2, sl
 c0578ea:	4639      	mov	r1, r7
 c0578ec:	4648      	mov	r0, r9
 c0578ee:	e9cd aa00 	strd	sl, sl, [sp]
 c0578f2:	f7f7 fdf9 	bl	c04f4e8 <mbedtls_rsa_export>
    len += ret;
 c0578f6:	46a0      	mov	r8, r4
    if ( ( ret = mbedtls_rsa_export( rsa, &T, NULL, NULL, NULL, NULL ) ) != 0 ||
 c0578f8:	4604      	mov	r4, r0
 c0578fa:	b938      	cbnz	r0, c05790c <mbedtls_pk_write_pubkey+0x70>
         ( ret = mbedtls_asn1_write_mpi( p, start, &T ) ) < 0 )
 c0578fc:	463a      	mov	r2, r7
 c0578fe:	4631      	mov	r1, r6
 c057900:	4628      	mov	r0, r5
 c057902:	f7fb fa11 	bl	c052d28 <mbedtls_asn1_write_mpi>
    if ( ( ret = mbedtls_rsa_export( rsa, &T, NULL, NULL, NULL, NULL ) ) != 0 ||
 c057906:	1e04      	subs	r4, r0, #0
 c057908:	db00      	blt.n	c05790c <mbedtls_pk_write_pubkey+0x70>
    len += ret;
 c05790a:	44a0      	add	r8, r4
    mbedtls_mpi_free( &T );
 c05790c:	4638      	mov	r0, r7
 c05790e:	f7fb fcf8 	bl	c053302 <mbedtls_mpi_free>
    if( ret < 0 )
 c057912:	2c00      	cmp	r4, #0
 c057914:	db07      	blt.n	c057926 <mbedtls_pk_write_pubkey+0x8a>
    MBEDTLS_ASN1_CHK_ADD( len, mbedtls_asn1_write_len( p, start, len ) );
 c057916:	4642      	mov	r2, r8
 c057918:	4631      	mov	r1, r6
 c05791a:	4628      	mov	r0, r5
 c05791c:	f7fb f932 	bl	c052b84 <mbedtls_asn1_write_len>
 c057920:	1e07      	subs	r7, r0, #0
 c057922:	da06      	bge.n	c057932 <mbedtls_pk_write_pubkey+0x96>
 c057924:	463c      	mov	r4, r7
    else
#endif /* MBEDTLS_USE_PSA_CRYPTO */
        return( MBEDTLS_ERR_PK_FEATURE_UNAVAILABLE );

    return( (int) len );
}
 c057926:	4620      	mov	r0, r4
 c057928:	b006      	add	sp, #24
 c05792a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    size_t len = 0;
 c05792e:	46d0      	mov	r8, sl
 c057930:	e7ec      	b.n	c05790c <mbedtls_pk_write_pubkey+0x70>
    MBEDTLS_ASN1_CHK_ADD( len, mbedtls_asn1_write_tag( p, start, MBEDTLS_ASN1_CONSTRUCTED |
 c057932:	2230      	movs	r2, #48	@ 0x30
 c057934:	4631      	mov	r1, r6
 c057936:	4628      	mov	r0, r5
 c057938:	f7fb f998 	bl	c052c6c <mbedtls_asn1_write_tag>
 c05793c:	1e04      	subs	r4, r0, #0
 c05793e:	dbf2      	blt.n	c057926 <mbedtls_pk_write_pubkey+0x8a>
    MBEDTLS_ASN1_CHK_ADD( len, mbedtls_asn1_write_len( p, start, len ) );
 c057940:	4447      	add	r7, r8
    MBEDTLS_ASN1_CHK_ADD( len, mbedtls_asn1_write_tag( p, start, MBEDTLS_ASN1_CONSTRUCTED |
 c057942:	443c      	add	r4, r7
    return( (int) len );
 c057944:	e7ef      	b.n	c057926 <mbedtls_pk_write_pubkey+0x8a>
    if( mbedtls_pk_get_type( key ) == MBEDTLS_PK_ECKEY )
 c057946:	4620      	mov	r0, r4
 c057948:	f7ff fa88 	bl	c056e5c <mbedtls_pk_get_type>
 c05794c:	2802      	cmp	r0, #2
 c05794e:	d106      	bne.n	c05795e <mbedtls_pk_write_pubkey+0xc2>
        MBEDTLS_ASN1_CHK_ADD( len, pk_write_ec_pubkey( p, start, mbedtls_pk_ec( *key ) ) );
 c057950:	6862      	ldr	r2, [r4, #4]
 c057952:	4631      	mov	r1, r6
 c057954:	4628      	mov	r0, r5
 c057956:	f7ff ff6d 	bl	c057834 <pk_write_ec_pubkey>
 c05795a:	4604      	mov	r4, r0
 c05795c:	e7e3      	b.n	c057926 <mbedtls_pk_write_pubkey+0x8a>
        return( MBEDTLS_ERR_PK_FEATURE_UNAVAILABLE );
 c05795e:	4c01      	ldr	r4, [pc, #4]	@ (c057964 <mbedtls_pk_write_pubkey+0xc8>)
 c057960:	e7e1      	b.n	c057926 <mbedtls_pk_write_pubkey+0x8a>
 c057962:	bf00      	nop
 c057964:	ffffc680 	.word	0xffffc680

0c057968 <mbedtls_pk_write_key_der>:

    return( (int) len );
}

int mbedtls_pk_write_key_der( mbedtls_pk_context *key, unsigned char *buf, size_t size )
{
 c057968:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c05796c:	4605      	mov	r5, r0
 c05796e:	460c      	mov	r4, r1
 c057970:	b097      	sub	sp, #92	@ 0x5c
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    unsigned char *c;
    size_t len = 0;

    PK_VALIDATE_RET( key != NULL );
    if( size == 0 )
 c057972:	b92a      	cbnz	r2, c057980 <mbedtls_pk_write_key_der+0x18>
        return( MBEDTLS_ERR_ASN1_BUF_TOO_SMALL );
 c057974:	f06f 086b 	mvn.w	r8, #107	@ 0x6b
    else
#endif /* MBEDTLS_ECP_C */
        return( MBEDTLS_ERR_PK_FEATURE_UNAVAILABLE );

    return( (int) len );
}
 c057978:	4640      	mov	r0, r8
 c05797a:	b017      	add	sp, #92	@ 0x5c
 c05797c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    c = buf + size;
 c057980:	440a      	add	r2, r1
 c057982:	9204      	str	r2, [sp, #16]
    if( mbedtls_pk_get_type( key ) == MBEDTLS_PK_RSA )
 c057984:	f7ff fa6a 	bl	c056e5c <mbedtls_pk_get_type>
 c057988:	2801      	cmp	r0, #1
 c05798a:	f040 80c7 	bne.w	c057b1c <mbedtls_pk_write_key_der+0x1b4>
        mbedtls_mpi_init( &T );
 c05798e:	a805      	add	r0, sp, #20
 c057990:	686f      	ldr	r7, [r5, #4]
 c057992:	f7fb fcb0 	bl	c0532f6 <mbedtls_mpi_init>
        if( ( ret = mbedtls_rsa_export_crt( rsa, NULL, NULL, &T ) ) != 0 ||
 c057996:	2200      	movs	r2, #0
 c057998:	4638      	mov	r0, r7
 c05799a:	4611      	mov	r1, r2
 c05799c:	ab05      	add	r3, sp, #20
 c05799e:	f7f7 fe0f 	bl	c04f5c0 <mbedtls_rsa_export_crt>
 c0579a2:	4680      	mov	r8, r0
 c0579a4:	2800      	cmp	r0, #0
 c0579a6:	f040 80b7 	bne.w	c057b18 <mbedtls_pk_write_key_der+0x1b0>
            ( ret = mbedtls_asn1_write_mpi( &c, buf, &T ) ) < 0 )
 c0579aa:	4621      	mov	r1, r4
 c0579ac:	aa05      	add	r2, sp, #20
 c0579ae:	a804      	add	r0, sp, #16
 c0579b0:	f7fb f9ba 	bl	c052d28 <mbedtls_asn1_write_mpi>
        if( ( ret = mbedtls_rsa_export_crt( rsa, NULL, NULL, &T ) ) != 0 ||
 c0579b4:	f1b0 0800 	subs.w	r8, r0, #0
 c0579b8:	f2c0 80ae 	blt.w	c057b18 <mbedtls_pk_write_key_der+0x1b0>
        if( ( ret = mbedtls_rsa_export_crt( rsa, NULL, &T, NULL ) ) != 0 ||
 c0579bc:	2300      	movs	r3, #0
 c0579be:	4638      	mov	r0, r7
 c0579c0:	4619      	mov	r1, r3
 c0579c2:	aa05      	add	r2, sp, #20
 c0579c4:	f7f7 fdfc 	bl	c04f5c0 <mbedtls_rsa_export_crt>
        len += ret;
 c0579c8:	4645      	mov	r5, r8
        if( ( ret = mbedtls_rsa_export_crt( rsa, NULL, &T, NULL ) ) != 0 ||
 c0579ca:	4680      	mov	r8, r0
 c0579cc:	2800      	cmp	r0, #0
 c0579ce:	d17e      	bne.n	c057ace <mbedtls_pk_write_key_der+0x166>
            ( ret = mbedtls_asn1_write_mpi( &c, buf, &T ) ) < 0 )
 c0579d0:	4621      	mov	r1, r4
 c0579d2:	aa05      	add	r2, sp, #20
 c0579d4:	a804      	add	r0, sp, #16
 c0579d6:	f7fb f9a7 	bl	c052d28 <mbedtls_asn1_write_mpi>
        if( ( ret = mbedtls_rsa_export_crt( rsa, NULL, &T, NULL ) ) != 0 ||
 c0579da:	f1b0 0800 	subs.w	r8, r0, #0
 c0579de:	db76      	blt.n	c057ace <mbedtls_pk_write_key_der+0x166>
        if( ( ret = mbedtls_rsa_export_crt( rsa, &T, NULL, NULL ) ) != 0 ||
 c0579e0:	2300      	movs	r3, #0
 c0579e2:	4638      	mov	r0, r7
 c0579e4:	461a      	mov	r2, r3
 c0579e6:	a905      	add	r1, sp, #20
 c0579e8:	f7f7 fdea 	bl	c04f5c0 <mbedtls_rsa_export_crt>
        len += ret;
 c0579ec:	4445      	add	r5, r8
        if( ( ret = mbedtls_rsa_export_crt( rsa, &T, NULL, NULL ) ) != 0 ||
 c0579ee:	4680      	mov	r8, r0
 c0579f0:	2800      	cmp	r0, #0
 c0579f2:	d16c      	bne.n	c057ace <mbedtls_pk_write_key_der+0x166>
            ( ret = mbedtls_asn1_write_mpi( &c, buf, &T ) ) < 0 )
 c0579f4:	4621      	mov	r1, r4
 c0579f6:	aa05      	add	r2, sp, #20
 c0579f8:	a804      	add	r0, sp, #16
 c0579fa:	f7fb f995 	bl	c052d28 <mbedtls_asn1_write_mpi>
        if( ( ret = mbedtls_rsa_export_crt( rsa, &T, NULL, NULL ) ) != 0 ||
 c0579fe:	f1b0 0800 	subs.w	r8, r0, #0
 c057a02:	db64      	blt.n	c057ace <mbedtls_pk_write_key_der+0x166>
        if ( ( ret = mbedtls_rsa_export( rsa, NULL, NULL,
 c057a04:	2200      	movs	r2, #0
 c057a06:	4638      	mov	r0, r7
 c057a08:	4611      	mov	r1, r2
 c057a0a:	e9cd 2200 	strd	r2, r2, [sp]
 c057a0e:	ab05      	add	r3, sp, #20
 c057a10:	f7f7 fd6a 	bl	c04f4e8 <mbedtls_rsa_export>
        len += ret;
 c057a14:	4445      	add	r5, r8
        if ( ( ret = mbedtls_rsa_export( rsa, NULL, NULL,
 c057a16:	4680      	mov	r8, r0
 c057a18:	2800      	cmp	r0, #0
 c057a1a:	d158      	bne.n	c057ace <mbedtls_pk_write_key_der+0x166>
             ( ret = mbedtls_asn1_write_mpi( &c, buf, &T ) ) < 0 )
 c057a1c:	4621      	mov	r1, r4
 c057a1e:	aa05      	add	r2, sp, #20
 c057a20:	a804      	add	r0, sp, #16
 c057a22:	f7fb f981 	bl	c052d28 <mbedtls_asn1_write_mpi>
                                         &T, NULL, NULL ) ) != 0 ||
 c057a26:	f1b0 0800 	subs.w	r8, r0, #0
 c057a2a:	db50      	blt.n	c057ace <mbedtls_pk_write_key_der+0x166>
        if ( ( ret = mbedtls_rsa_export( rsa, NULL, &T,
 c057a2c:	2600      	movs	r6, #0
 c057a2e:	4638      	mov	r0, r7
 c057a30:	4633      	mov	r3, r6
 c057a32:	4631      	mov	r1, r6
 c057a34:	e9cd 6600 	strd	r6, r6, [sp]
 c057a38:	aa05      	add	r2, sp, #20
 c057a3a:	f7f7 fd55 	bl	c04f4e8 <mbedtls_rsa_export>
        len += ret;
 c057a3e:	4445      	add	r5, r8
        if ( ( ret = mbedtls_rsa_export( rsa, NULL, &T,
 c057a40:	4680      	mov	r8, r0
 c057a42:	2800      	cmp	r0, #0
 c057a44:	d143      	bne.n	c057ace <mbedtls_pk_write_key_der+0x166>
             ( ret = mbedtls_asn1_write_mpi( &c, buf, &T ) ) < 0 )
 c057a46:	4621      	mov	r1, r4
 c057a48:	aa05      	add	r2, sp, #20
 c057a4a:	a804      	add	r0, sp, #16
 c057a4c:	f7fb f96c 	bl	c052d28 <mbedtls_asn1_write_mpi>
                                         NULL, NULL, NULL ) ) != 0 ||
 c057a50:	f1b0 0800 	subs.w	r8, r0, #0
 c057a54:	db3b      	blt.n	c057ace <mbedtls_pk_write_key_der+0x166>
        if ( ( ret = mbedtls_rsa_export( rsa, NULL, NULL,
 c057a56:	ab05      	add	r3, sp, #20
 c057a58:	9300      	str	r3, [sp, #0]
 c057a5a:	4632      	mov	r2, r6
 c057a5c:	4633      	mov	r3, r6
 c057a5e:	4631      	mov	r1, r6
 c057a60:	4638      	mov	r0, r7
 c057a62:	9601      	str	r6, [sp, #4]
 c057a64:	f7f7 fd40 	bl	c04f4e8 <mbedtls_rsa_export>
        len += ret;
 c057a68:	4445      	add	r5, r8
        if ( ( ret = mbedtls_rsa_export( rsa, NULL, NULL,
 c057a6a:	4680      	mov	r8, r0
 c057a6c:	bb78      	cbnz	r0, c057ace <mbedtls_pk_write_key_der+0x166>
             ( ret = mbedtls_asn1_write_mpi( &c, buf, &T ) ) < 0 )
 c057a6e:	4621      	mov	r1, r4
 c057a70:	aa05      	add	r2, sp, #20
 c057a72:	a804      	add	r0, sp, #16
 c057a74:	f7fb f958 	bl	c052d28 <mbedtls_asn1_write_mpi>
                                         NULL, &T, NULL ) ) != 0 ||
 c057a78:	f1b0 0800 	subs.w	r8, r0, #0
 c057a7c:	db27      	blt.n	c057ace <mbedtls_pk_write_key_der+0x166>
        if ( ( ret = mbedtls_rsa_export( rsa, NULL, NULL,
 c057a7e:	ab05      	add	r3, sp, #20
 c057a80:	e9cd 6300 	strd	r6, r3, [sp]
 c057a84:	4632      	mov	r2, r6
 c057a86:	4633      	mov	r3, r6
 c057a88:	4631      	mov	r1, r6
 c057a8a:	4638      	mov	r0, r7
 c057a8c:	f7f7 fd2c 	bl	c04f4e8 <mbedtls_rsa_export>
        len += ret;
 c057a90:	4445      	add	r5, r8
        if ( ( ret = mbedtls_rsa_export( rsa, NULL, NULL,
 c057a92:	4680      	mov	r8, r0
 c057a94:	b9d8      	cbnz	r0, c057ace <mbedtls_pk_write_key_der+0x166>
             ( ret = mbedtls_asn1_write_mpi( &c, buf, &T ) ) < 0 )
 c057a96:	4621      	mov	r1, r4
 c057a98:	aa05      	add	r2, sp, #20
 c057a9a:	a804      	add	r0, sp, #16
 c057a9c:	f7fb f944 	bl	c052d28 <mbedtls_asn1_write_mpi>
                                         NULL, NULL, &T ) ) != 0 ||
 c057aa0:	f1b0 0800 	subs.w	r8, r0, #0
 c057aa4:	db13      	blt.n	c057ace <mbedtls_pk_write_key_der+0x166>
        if ( ( ret = mbedtls_rsa_export( rsa, &T, NULL,
 c057aa6:	4633      	mov	r3, r6
 c057aa8:	4632      	mov	r2, r6
 c057aaa:	4638      	mov	r0, r7
 c057aac:	e9cd 6600 	strd	r6, r6, [sp]
 c057ab0:	a905      	add	r1, sp, #20
 c057ab2:	f7f7 fd19 	bl	c04f4e8 <mbedtls_rsa_export>
        len += ret;
 c057ab6:	4445      	add	r5, r8
        if ( ( ret = mbedtls_rsa_export( rsa, &T, NULL,
 c057ab8:	4680      	mov	r8, r0
 c057aba:	b940      	cbnz	r0, c057ace <mbedtls_pk_write_key_der+0x166>
             ( ret = mbedtls_asn1_write_mpi( &c, buf, &T ) ) < 0 )
 c057abc:	4621      	mov	r1, r4
 c057abe:	aa05      	add	r2, sp, #20
 c057ac0:	a804      	add	r0, sp, #16
 c057ac2:	f7fb f931 	bl	c052d28 <mbedtls_asn1_write_mpi>
                                         NULL, NULL, NULL ) ) != 0 ||
 c057ac6:	f1b0 0800 	subs.w	r8, r0, #0
 c057aca:	db00      	blt.n	c057ace <mbedtls_pk_write_key_der+0x166>
        len += ret;
 c057acc:	4445      	add	r5, r8
        mbedtls_mpi_free( &T );
 c057ace:	a805      	add	r0, sp, #20
 c057ad0:	f7fb fc17 	bl	c053302 <mbedtls_mpi_free>
        if( ret < 0 )
 c057ad4:	f1b8 0f00 	cmp.w	r8, #0
 c057ad8:	f6ff af4e 	blt.w	c057978 <mbedtls_pk_write_key_der+0x10>
        MBEDTLS_ASN1_CHK_ADD( len, mbedtls_asn1_write_int( &c, buf, 0 ) );
 c057adc:	2200      	movs	r2, #0
 c057ade:	4621      	mov	r1, r4
 c057ae0:	a804      	add	r0, sp, #16
 c057ae2:	f7fb f97f 	bl	c052de4 <mbedtls_asn1_write_int>
 c057ae6:	f1b0 0800 	subs.w	r8, r0, #0
 c057aea:	f6ff af45 	blt.w	c057978 <mbedtls_pk_write_key_der+0x10>
 c057aee:	4445      	add	r5, r8
        MBEDTLS_ASN1_CHK_ADD( len, mbedtls_asn1_write_len( &c, buf, len ) );
 c057af0:	462a      	mov	r2, r5
 c057af2:	4621      	mov	r1, r4
 c057af4:	a804      	add	r0, sp, #16
 c057af6:	f7fb f845 	bl	c052b84 <mbedtls_asn1_write_len>
 c057afa:	f1b0 0800 	subs.w	r8, r0, #0
 c057afe:	f6ff af3b 	blt.w	c057978 <mbedtls_pk_write_key_der+0x10>
        MBEDTLS_ASN1_CHK_ADD( len, mbedtls_asn1_write_tag( &c, buf, MBEDTLS_ASN1_CONSTRUCTED |
 c057b02:	2230      	movs	r2, #48	@ 0x30
 c057b04:	4621      	mov	r1, r4
 c057b06:	a804      	add	r0, sp, #16
 c057b08:	f7fb f8b0 	bl	c052c6c <mbedtls_asn1_write_tag>
 c057b0c:	2800      	cmp	r0, #0
 c057b0e:	db01      	blt.n	c057b14 <mbedtls_pk_write_key_der+0x1ac>
        MBEDTLS_ASN1_CHK_ADD( len, mbedtls_asn1_write_len( &c, buf, len ) );
 c057b10:	4445      	add	r5, r8
        MBEDTLS_ASN1_CHK_ADD( len, mbedtls_asn1_write_tag( &c, buf, MBEDTLS_ASN1_CONSTRUCTED |
 c057b12:	4428      	add	r0, r5
    return( (int) len );
 c057b14:	4680      	mov	r8, r0
 c057b16:	e72f      	b.n	c057978 <mbedtls_pk_write_key_der+0x10>
    size_t len = 0;
 c057b18:	2500      	movs	r5, #0
 c057b1a:	e7d8      	b.n	c057ace <mbedtls_pk_write_key_der+0x166>
    if( mbedtls_pk_get_type( key ) == MBEDTLS_PK_ECKEY )
 c057b1c:	4628      	mov	r0, r5
 c057b1e:	f7ff f99d 	bl	c056e5c <mbedtls_pk_get_type>
 c057b22:	2802      	cmp	r0, #2
 c057b24:	d17e      	bne.n	c057c24 <mbedtls_pk_write_key_der+0x2bc>
        mbedtls_ecp_keypair *ec = mbedtls_pk_ec( *key );
 c057b26:	f8d5 b004 	ldr.w	fp, [r5, #4]
        MBEDTLS_ASN1_CHK_ADD( pub_len, pk_write_ec_pubkey( &c, buf, ec ) );
 c057b2a:	4621      	mov	r1, r4
 c057b2c:	465a      	mov	r2, fp
 c057b2e:	a804      	add	r0, sp, #16
 c057b30:	f7ff fe80 	bl	c057834 <pk_write_ec_pubkey>
 c057b34:	f1b0 0800 	subs.w	r8, r0, #0
 c057b38:	f6ff af1e 	blt.w	c057978 <mbedtls_pk_write_key_der+0x10>
        if( c - buf < 1 )
 c057b3c:	9a04      	ldr	r2, [sp, #16]
 c057b3e:	1b11      	subs	r1, r2, r4
 c057b40:	2900      	cmp	r1, #0
 c057b42:	f77f af17 	ble.w	c057974 <mbedtls_pk_write_key_der+0xc>
        *--c = 0;
 c057b46:	1e51      	subs	r1, r2, #1
 c057b48:	9104      	str	r1, [sp, #16]
 c057b4a:	2100      	movs	r1, #0
        pub_len += 1;
 c057b4c:	f108 0601 	add.w	r6, r8, #1
        *--c = 0;
 c057b50:	f802 1c01 	strb.w	r1, [r2, #-1]
        MBEDTLS_ASN1_CHK_ADD( pub_len, mbedtls_asn1_write_len( &c, buf, pub_len ) );
 c057b54:	a804      	add	r0, sp, #16
 c057b56:	4632      	mov	r2, r6
 c057b58:	4621      	mov	r1, r4
 c057b5a:	f7fb f813 	bl	c052b84 <mbedtls_asn1_write_len>
 c057b5e:	f1b0 0800 	subs.w	r8, r0, #0
 c057b62:	f6ff af09 	blt.w	c057978 <mbedtls_pk_write_key_der+0x10>
        MBEDTLS_ASN1_CHK_ADD( pub_len, mbedtls_asn1_write_tag( &c, buf, MBEDTLS_ASN1_BIT_STRING ) );
 c057b66:	2203      	movs	r2, #3
 c057b68:	4621      	mov	r1, r4
 c057b6a:	a804      	add	r0, sp, #16
 c057b6c:	f7fb f87e 	bl	c052c6c <mbedtls_asn1_write_tag>
 c057b70:	1e05      	subs	r5, r0, #0
 c057b72:	db5a      	blt.n	c057c2a <mbedtls_pk_write_key_der+0x2c2>
        MBEDTLS_ASN1_CHK_ADD( pub_len, mbedtls_asn1_write_len( &c, buf, pub_len ) );
 c057b74:	4446      	add	r6, r8
        MBEDTLS_ASN1_CHK_ADD( pub_len, mbedtls_asn1_write_tag( &c, buf, MBEDTLS_ASN1_BIT_STRING ) );
 c057b76:	4435      	add	r5, r6
        MBEDTLS_ASN1_CHK_ADD( pub_len, mbedtls_asn1_write_len( &c, buf, pub_len ) );
 c057b78:	462a      	mov	r2, r5
 c057b7a:	4621      	mov	r1, r4
 c057b7c:	a804      	add	r0, sp, #16
 c057b7e:	f7fb f801 	bl	c052b84 <mbedtls_asn1_write_len>
 c057b82:	f1b0 0a00 	subs.w	sl, r0, #0
 c057b86:	db52      	blt.n	c057c2e <mbedtls_pk_write_key_der+0x2c6>
        MBEDTLS_ASN1_CHK_ADD( pub_len, mbedtls_asn1_write_tag( &c, buf,
 c057b88:	22a1      	movs	r2, #161	@ 0xa1
 c057b8a:	4621      	mov	r1, r4
 c057b8c:	a804      	add	r0, sp, #16
 c057b8e:	f7fb f86d 	bl	c052c6c <mbedtls_asn1_write_tag>
 c057b92:	f1b0 0900 	subs.w	r9, r0, #0
 c057b96:	db4c      	blt.n	c057c32 <mbedtls_pk_write_key_der+0x2ca>
        MBEDTLS_ASN1_CHK_ADD( par_len, pk_write_ec_param( &c, buf, ec ) );
 c057b98:	4621      	mov	r1, r4
 c057b9a:	f89b 2000 	ldrb.w	r2, [fp]
 c057b9e:	a804      	add	r0, sp, #16
 c057ba0:	f7ff fe6b 	bl	c05787a <pk_write_ec_param.isra.0>
 c057ba4:	f1b0 0800 	subs.w	r8, r0, #0
 c057ba8:	f6ff aee6 	blt.w	c057978 <mbedtls_pk_write_key_der+0x10>
        MBEDTLS_ASN1_CHK_ADD( par_len, mbedtls_asn1_write_len( &c, buf, par_len ) );
 c057bac:	4642      	mov	r2, r8
 c057bae:	4621      	mov	r1, r4
 c057bb0:	a804      	add	r0, sp, #16
        MBEDTLS_ASN1_CHK_ADD( par_len, pk_write_ec_param( &c, buf, ec ) );
 c057bb2:	f8cd 8008 	str.w	r8, [sp, #8]
        MBEDTLS_ASN1_CHK_ADD( par_len, mbedtls_asn1_write_len( &c, buf, par_len ) );
 c057bb6:	f7fa ffe5 	bl	c052b84 <mbedtls_asn1_write_len>
 c057bba:	1e03      	subs	r3, r0, #0
 c057bbc:	9303      	str	r3, [sp, #12]
 c057bbe:	db3a      	blt.n	c057c36 <mbedtls_pk_write_key_der+0x2ce>
        MBEDTLS_ASN1_CHK_ADD( par_len, mbedtls_asn1_write_tag( &c, buf,
 c057bc0:	22a0      	movs	r2, #160	@ 0xa0
 c057bc2:	4621      	mov	r1, r4
 c057bc4:	a804      	add	r0, sp, #16
 c057bc6:	f7fb f851 	bl	c052c6c <mbedtls_asn1_write_tag>
 c057bca:	1e07      	subs	r7, r0, #0
 c057bcc:	db36      	blt.n	c057c3c <mbedtls_pk_write_key_der+0x2d4>
    size_t byte_length = ( ec->grp.pbits + 7 ) / 8;
 c057bce:	f8db 6058 	ldr.w	r6, [fp, #88]	@ 0x58
    ret = mbedtls_ecp_write_key( ec, tmp, byte_length );
 c057bd2:	4658      	mov	r0, fp
    size_t byte_length = ( ec->grp.pbits + 7 ) / 8;
 c057bd4:	3607      	adds	r6, #7
 c057bd6:	08f6      	lsrs	r6, r6, #3
    ret = mbedtls_ecp_write_key( ec, tmp, byte_length );
 c057bd8:	4632      	mov	r2, r6
 c057bda:	a905      	add	r1, sp, #20
 c057bdc:	f7f5 fca2 	bl	c04d524 <mbedtls_ecp_write_key>
    if( ret != 0 )
 c057be0:	4680      	mov	r8, r0
 c057be2:	b930      	cbnz	r0, c057bf2 <mbedtls_pk_write_key_der+0x28a>
    ret = mbedtls_asn1_write_octet_string( p, start, tmp, byte_length );
 c057be4:	4633      	mov	r3, r6
 c057be6:	4621      	mov	r1, r4
 c057be8:	aa05      	add	r2, sp, #20
 c057bea:	a804      	add	r0, sp, #16
 c057bec:	f7fb f8fd 	bl	c052dea <mbedtls_asn1_write_octet_string>
 c057bf0:	4680      	mov	r8, r0
    mbedtls_platform_zeroize( tmp, byte_length );
 c057bf2:	4631      	mov	r1, r6
 c057bf4:	a805      	add	r0, sp, #20
 c057bf6:	f7e3 fbeb 	bl	c03b3d0 <mbedtls_platform_zeroize>
        MBEDTLS_ASN1_CHK_ADD( len, pk_write_ec_private( &c, buf, ec ) );
 c057bfa:	f1b8 0f00 	cmp.w	r8, #0
 c057bfe:	f6ff aebb 	blt.w	c057978 <mbedtls_pk_write_key_der+0x10>
        MBEDTLS_ASN1_CHK_ADD( len, mbedtls_asn1_write_int( &c, buf, 1 ) );
 c057c02:	2201      	movs	r2, #1
 c057c04:	4621      	mov	r1, r4
 c057c06:	a804      	add	r0, sp, #16
 c057c08:	f7fb f8ec 	bl	c052de4 <mbedtls_asn1_write_int>
 c057c0c:	2800      	cmp	r0, #0
 c057c0e:	db81      	blt.n	c057b14 <mbedtls_pk_write_key_der+0x1ac>
        len += par_len;
 c057c10:	9b02      	ldr	r3, [sp, #8]
        MBEDTLS_ASN1_CHK_ADD( pub_len, mbedtls_asn1_write_len( &c, buf, pub_len ) );
 c057c12:	4455      	add	r5, sl
        MBEDTLS_ASN1_CHK_ADD( pub_len, mbedtls_asn1_write_tag( &c, buf,
 c057c14:	444d      	add	r5, r9
        len += par_len;
 c057c16:	441d      	add	r5, r3
 c057c18:	9b03      	ldr	r3, [sp, #12]
 c057c1a:	441d      	add	r5, r3
 c057c1c:	443d      	add	r5, r7
        MBEDTLS_ASN1_CHK_ADD( len, pk_write_ec_private( &c, buf, ec ) );
 c057c1e:	4445      	add	r5, r8
        MBEDTLS_ASN1_CHK_ADD( len, mbedtls_asn1_write_int( &c, buf, 1 ) );
 c057c20:	4405      	add	r5, r0
 c057c22:	e765      	b.n	c057af0 <mbedtls_pk_write_key_der+0x188>
        return( MBEDTLS_ERR_PK_FEATURE_UNAVAILABLE );
 c057c24:	f8df 8018 	ldr.w	r8, [pc, #24]	@ c057c40 <mbedtls_pk_write_key_der+0x2d8>
 c057c28:	e6a6      	b.n	c057978 <mbedtls_pk_write_key_der+0x10>
 c057c2a:	46a8      	mov	r8, r5
 c057c2c:	e6a4      	b.n	c057978 <mbedtls_pk_write_key_der+0x10>
 c057c2e:	46d0      	mov	r8, sl
 c057c30:	e6a2      	b.n	c057978 <mbedtls_pk_write_key_der+0x10>
 c057c32:	46c8      	mov	r8, r9
 c057c34:	e6a0      	b.n	c057978 <mbedtls_pk_write_key_der+0x10>
 c057c36:	f8dd 800c 	ldr.w	r8, [sp, #12]
 c057c3a:	e69d      	b.n	c057978 <mbedtls_pk_write_key_der+0x10>
 c057c3c:	46b8      	mov	r8, r7
 c057c3e:	e69b      	b.n	c057978 <mbedtls_pk_write_key_der+0x10>
 c057c40:	ffffc680 	.word	0xffffc680

0c057c44 <mbedtls_rsa_deduce_primes>:
 *
 */
int mbedtls_rsa_deduce_primes( mbedtls_mpi const *N,
                     mbedtls_mpi const *E, mbedtls_mpi const *D,
                     mbedtls_mpi *P, mbedtls_mpi *Q )
{
 c057c44:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c057c48:	b097      	sub	sp, #92	@ 0x5c
    uint16_t order;    /* Order of 2 in DE - 1 */

    mbedtls_mpi T;  /* Holds largest odd divisor of DE - 1     */
    mbedtls_mpi K;  /* Temporary holding the current candidate */

    const unsigned char primes[] = { 2,
 c057c4a:	ac08      	add	r4, sp, #32
{
 c057c4c:	4605      	mov	r5, r0
 c057c4e:	468a      	mov	sl, r1
 c057c50:	4617      	mov	r7, r2
 c057c52:	46a1      	mov	r9, r4
 c057c54:	461e      	mov	r6, r3
    const unsigned char primes[] = { 2,
 c057c56:	4b72      	ldr	r3, [pc, #456]	@ (c057e20 <mbedtls_rsa_deduce_primes+0x1dc>)
{
 c057c58:	f8dd 8080 	ldr.w	r8, [sp, #128]	@ 0x80
    const unsigned char primes[] = { 2,
 c057c5c:	f103 0c30 	add.w	ip, r3, #48	@ 0x30
 c057c60:	4622      	mov	r2, r4
 c057c62:	6818      	ldr	r0, [r3, #0]
 c057c64:	6859      	ldr	r1, [r3, #4]
 c057c66:	3308      	adds	r3, #8
 c057c68:	c203      	stmia	r2!, {r0, r1}
 c057c6a:	4563      	cmp	r3, ip
 c057c6c:	4614      	mov	r4, r2
 c057c6e:	d1f7      	bne.n	c057c60 <mbedtls_rsa_deduce_primes+0x1c>
 c057c70:	6818      	ldr	r0, [r3, #0]
 c057c72:	889b      	ldrh	r3, [r3, #4]
 c057c74:	6010      	str	r0, [r2, #0]
 c057c76:	8093      	strh	r3, [r2, #4]
         229,  233,  239,  241,  251
    };

    const size_t num_primes = sizeof( primes ) / sizeof( *primes );

    if( P == NULL || Q == NULL || P->p != NULL || Q->p != NULL )
 c057c78:	b92e      	cbnz	r6, c057c86 <mbedtls_rsa_deduce_primes+0x42>
        return( MBEDTLS_ERR_MPI_BAD_INPUT_DATA );
 c057c7a:	f06f 0403 	mvn.w	r4, #3
cleanup:

    mbedtls_mpi_free( &K );
    mbedtls_mpi_free( &T );
    return( ret );
}
 c057c7e:	4620      	mov	r0, r4
 c057c80:	b017      	add	sp, #92	@ 0x5c
 c057c82:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if( P == NULL || Q == NULL || P->p != NULL || Q->p != NULL )
 c057c86:	f1b8 0f00 	cmp.w	r8, #0
 c057c8a:	d0f6      	beq.n	c057c7a <mbedtls_rsa_deduce_primes+0x36>
 c057c8c:	68b3      	ldr	r3, [r6, #8]
 c057c8e:	2b00      	cmp	r3, #0
 c057c90:	d1f3      	bne.n	c057c7a <mbedtls_rsa_deduce_primes+0x36>
 c057c92:	f8d8 1008 	ldr.w	r1, [r8, #8]
 c057c96:	2900      	cmp	r1, #0
 c057c98:	d1ef      	bne.n	c057c7a <mbedtls_rsa_deduce_primes+0x36>
    if( mbedtls_mpi_cmp_int( N, 0 ) <= 0 ||
 c057c9a:	4628      	mov	r0, r5
 c057c9c:	f7fb fe11 	bl	c0538c2 <mbedtls_mpi_cmp_int>
 c057ca0:	2800      	cmp	r0, #0
 c057ca2:	ddea      	ble.n	c057c7a <mbedtls_rsa_deduce_primes+0x36>
        mbedtls_mpi_cmp_int( D, 1 ) <= 0 ||
 c057ca4:	2101      	movs	r1, #1
 c057ca6:	4638      	mov	r0, r7
 c057ca8:	f7fb fe0b 	bl	c0538c2 <mbedtls_mpi_cmp_int>
    if( mbedtls_mpi_cmp_int( N, 0 ) <= 0 ||
 c057cac:	2800      	cmp	r0, #0
 c057cae:	dde4      	ble.n	c057c7a <mbedtls_rsa_deduce_primes+0x36>
        mbedtls_mpi_cmp_mpi( D, N ) >= 0 ||
 c057cb0:	4629      	mov	r1, r5
 c057cb2:	4638      	mov	r0, r7
 c057cb4:	f7fb fdc2 	bl	c05383c <mbedtls_mpi_cmp_mpi>
        mbedtls_mpi_cmp_int( D, 1 ) <= 0 ||
 c057cb8:	2800      	cmp	r0, #0
 c057cba:	dade      	bge.n	c057c7a <mbedtls_rsa_deduce_primes+0x36>
        mbedtls_mpi_cmp_int( E, 1 ) <= 0 ||
 c057cbc:	2101      	movs	r1, #1
 c057cbe:	4650      	mov	r0, sl
 c057cc0:	f7fb fdff 	bl	c0538c2 <mbedtls_mpi_cmp_int>
        mbedtls_mpi_cmp_mpi( D, N ) >= 0 ||
 c057cc4:	2800      	cmp	r0, #0
 c057cc6:	ddd8      	ble.n	c057c7a <mbedtls_rsa_deduce_primes+0x36>
        mbedtls_mpi_cmp_mpi( E, N ) >= 0 )
 c057cc8:	4629      	mov	r1, r5
 c057cca:	4650      	mov	r0, sl
 c057ccc:	f7fb fdb6 	bl	c05383c <mbedtls_mpi_cmp_mpi>
        mbedtls_mpi_cmp_int( E, 1 ) <= 0 ||
 c057cd0:	2800      	cmp	r0, #0
 c057cd2:	dad2      	bge.n	c057c7a <mbedtls_rsa_deduce_primes+0x36>
    mbedtls_mpi_init( &K );
 c057cd4:	a805      	add	r0, sp, #20
 c057cd6:	f7fb fb0e 	bl	c0532f6 <mbedtls_mpi_init>
    mbedtls_mpi_init( &T );
 c057cda:	a802      	add	r0, sp, #8
 c057cdc:	f7fb fb0b 	bl	c0532f6 <mbedtls_mpi_init>
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T, D,  E ) );
 c057ce0:	4652      	mov	r2, sl
 c057ce2:	4639      	mov	r1, r7
 c057ce4:	a802      	add	r0, sp, #8
 c057ce6:	f7fb ff3b 	bl	c053b60 <mbedtls_mpi_mul_mpi>
 c057cea:	4604      	mov	r4, r0
 c057cec:	b980      	cbnz	r0, c057d10 <mbedtls_rsa_deduce_primes+0xcc>
    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( &T, &T, 1 ) );
 c057cee:	a902      	add	r1, sp, #8
 c057cf0:	2201      	movs	r2, #1
 c057cf2:	4608      	mov	r0, r1
 c057cf4:	f7fb ff1e 	bl	c053b34 <mbedtls_mpi_sub_int>
 c057cf8:	4604      	mov	r4, r0
 c057cfa:	b948      	cbnz	r0, c057d10 <mbedtls_rsa_deduce_primes+0xcc>
    if( ( order = (uint16_t) mbedtls_mpi_lsb( &T ) ) == 0 )
 c057cfc:	a802      	add	r0, sp, #8
 c057cfe:	f7fb fbf1 	bl	c0534e4 <mbedtls_mpi_lsb>
 c057d02:	fa1f fb80 	uxth.w	fp, r0
 c057d06:	f1bb 0f00 	cmp.w	fp, #0
 c057d0a:	d108      	bne.n	c057d1e <mbedtls_rsa_deduce_primes+0xda>
        ret = MBEDTLS_ERR_MPI_BAD_INPUT_DATA;
 c057d0c:	f06f 0403 	mvn.w	r4, #3
    mbedtls_mpi_free( &K );
 c057d10:	a805      	add	r0, sp, #20
 c057d12:	f7fb faf6 	bl	c053302 <mbedtls_mpi_free>
    mbedtls_mpi_free( &T );
 c057d16:	a802      	add	r0, sp, #8
 c057d18:	f7fb faf3 	bl	c053302 <mbedtls_mpi_free>
    return( ret );
 c057d1c:	e7af      	b.n	c057c7e <mbedtls_rsa_deduce_primes+0x3a>
    MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &T, order ) );
 c057d1e:	b281      	uxth	r1, r0
 c057d20:	a802      	add	r0, sp, #8
 c057d22:	f7fb fd1e 	bl	c053762 <mbedtls_mpi_shift_r>
 c057d26:	4604      	mov	r4, r0
 c057d28:	2800      	cmp	r0, #0
 c057d2a:	d1f1      	bne.n	c057d10 <mbedtls_rsa_deduce_primes+0xcc>
    if( N->p[0] % 8 == 1 )
 c057d2c:	68ab      	ldr	r3, [r5, #8]
 c057d2e:	681f      	ldr	r7, [r3, #0]
 c057d30:	f007 0707 	and.w	r7, r7, #7
 c057d34:	1e7b      	subs	r3, r7, #1
 c057d36:	425f      	negs	r7, r3
 c057d38:	415f      	adcs	r7, r3
        mbedtls_mpi_lset( &K, primes[attempt] );
 c057d3a:	f819 1007 	ldrb.w	r1, [r9, r7]
 c057d3e:	a805      	add	r0, sp, #20
 c057d40:	f7fb fb7d 	bl	c05343e <mbedtls_mpi_lset>
        MBEDTLS_MPI_CHK( mbedtls_mpi_gcd( P, &K, N ) );
 c057d44:	462a      	mov	r2, r5
 c057d46:	4630      	mov	r0, r6
 c057d48:	a905      	add	r1, sp, #20
 c057d4a:	f7fc fc7e 	bl	c05464a <mbedtls_mpi_gcd>
 c057d4e:	4604      	mov	r4, r0
 c057d50:	2800      	cmp	r0, #0
 c057d52:	d1dd      	bne.n	c057d10 <mbedtls_rsa_deduce_primes+0xcc>
        if( mbedtls_mpi_cmp_int( P, 1 ) != 0 )
 c057d54:	2101      	movs	r1, #1
 c057d56:	4630      	mov	r0, r6
 c057d58:	f7fb fdb3 	bl	c0538c2 <mbedtls_mpi_cmp_int>
 c057d5c:	b120      	cbz	r0, c057d68 <mbedtls_rsa_deduce_primes+0x124>
    for( ; attempt < num_primes; ++attempt )
 c057d5e:	3701      	adds	r7, #1
 c057d60:	b2bb      	uxth	r3, r7
 c057d62:	2b36      	cmp	r3, #54	@ 0x36
 c057d64:	d1e9      	bne.n	c057d3a <mbedtls_rsa_deduce_primes+0xf6>
 c057d66:	e7d1      	b.n	c057d0c <mbedtls_rsa_deduce_primes+0xc8>
        MBEDTLS_MPI_CHK( mbedtls_mpi_exp_mod( &K, &K, &T, N,
 c057d68:	a905      	add	r1, sp, #20
 c057d6a:	462b      	mov	r3, r5
 c057d6c:	4608      	mov	r0, r1
 c057d6e:	f8cd 8000 	str.w	r8, [sp]
 c057d72:	aa02      	add	r2, sp, #8
 c057d74:	f7fc fa3e 	bl	c0541f4 <mbedtls_mpi_exp_mod>
 c057d78:	4604      	mov	r4, r0
 c057d7a:	2800      	cmp	r0, #0
 c057d7c:	d1c8      	bne.n	c057d10 <mbedtls_rsa_deduce_primes+0xcc>
        for( iter = 1; iter <= order; ++iter )
 c057d7e:	f04f 0a01 	mov.w	sl, #1
            if( mbedtls_mpi_cmp_int( &K, 1 ) == 0 )
 c057d82:	2101      	movs	r1, #1
 c057d84:	a805      	add	r0, sp, #20
 c057d86:	f7fb fd9c 	bl	c0538c2 <mbedtls_mpi_cmp_int>
 c057d8a:	2800      	cmp	r0, #0
 c057d8c:	d041      	beq.n	c057e12 <mbedtls_rsa_deduce_primes+0x1ce>
            MBEDTLS_MPI_CHK( mbedtls_mpi_add_int( &K, &K, 1 ) );
 c057d8e:	a905      	add	r1, sp, #20
 c057d90:	2201      	movs	r2, #1
 c057d92:	4608      	mov	r0, r1
 c057d94:	f7fb feb8 	bl	c053b08 <mbedtls_mpi_add_int>
 c057d98:	4604      	mov	r4, r0
 c057d9a:	2800      	cmp	r0, #0
 c057d9c:	d1b8      	bne.n	c057d10 <mbedtls_rsa_deduce_primes+0xcc>
            MBEDTLS_MPI_CHK( mbedtls_mpi_gcd( P, &K, N ) );
 c057d9e:	462a      	mov	r2, r5
 c057da0:	4630      	mov	r0, r6
 c057da2:	a905      	add	r1, sp, #20
 c057da4:	f7fc fc51 	bl	c05464a <mbedtls_mpi_gcd>
 c057da8:	4604      	mov	r4, r0
 c057daa:	2800      	cmp	r0, #0
 c057dac:	d1b0      	bne.n	c057d10 <mbedtls_rsa_deduce_primes+0xcc>
            if( mbedtls_mpi_cmp_int( P, 1 ) ==  1 &&
 c057dae:	2101      	movs	r1, #1
 c057db0:	4630      	mov	r0, r6
 c057db2:	f7fb fd86 	bl	c0538c2 <mbedtls_mpi_cmp_int>
 c057db6:	2801      	cmp	r0, #1
 c057db8:	d10d      	bne.n	c057dd6 <mbedtls_rsa_deduce_primes+0x192>
                mbedtls_mpi_cmp_mpi( P, N ) == -1 )
 c057dba:	4629      	mov	r1, r5
 c057dbc:	4630      	mov	r0, r6
 c057dbe:	f7fb fd3d 	bl	c05383c <mbedtls_mpi_cmp_mpi>
            if( mbedtls_mpi_cmp_int( P, 1 ) ==  1 &&
 c057dc2:	3001      	adds	r0, #1
 c057dc4:	d107      	bne.n	c057dd6 <mbedtls_rsa_deduce_primes+0x192>
                MBEDTLS_MPI_CHK( mbedtls_mpi_div_mpi( Q, NULL, N, P ) );
 c057dc6:	4621      	mov	r1, r4
 c057dc8:	4633      	mov	r3, r6
 c057dca:	462a      	mov	r2, r5
 c057dcc:	4640      	mov	r0, r8
 c057dce:	f7fb ffec 	bl	c053daa <mbedtls_mpi_div_mpi>
 c057dd2:	4604      	mov	r4, r0
 c057dd4:	e79c      	b.n	c057d10 <mbedtls_rsa_deduce_primes+0xcc>
            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( &K, &K, 1 ) );
 c057dd6:	a905      	add	r1, sp, #20
 c057dd8:	2201      	movs	r2, #1
 c057dda:	4608      	mov	r0, r1
 c057ddc:	f7fb feaa 	bl	c053b34 <mbedtls_mpi_sub_int>
 c057de0:	4604      	mov	r4, r0
 c057de2:	2800      	cmp	r0, #0
 c057de4:	d194      	bne.n	c057d10 <mbedtls_rsa_deduce_primes+0xcc>
            MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &K, &K, &K ) );
 c057de6:	aa05      	add	r2, sp, #20
 c057de8:	4611      	mov	r1, r2
 c057dea:	4610      	mov	r0, r2
 c057dec:	f7fb feb8 	bl	c053b60 <mbedtls_mpi_mul_mpi>
 c057df0:	4604      	mov	r4, r0
 c057df2:	2800      	cmp	r0, #0
 c057df4:	d18c      	bne.n	c057d10 <mbedtls_rsa_deduce_primes+0xcc>
            MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( &K, &K, N ) );
 c057df6:	a905      	add	r1, sp, #20
 c057df8:	462a      	mov	r2, r5
 c057dfa:	4608      	mov	r0, r1
 c057dfc:	f7fc f96d 	bl	c0540da <mbedtls_mpi_mod_mpi>
 c057e00:	4604      	mov	r4, r0
 c057e02:	2800      	cmp	r0, #0
 c057e04:	d184      	bne.n	c057d10 <mbedtls_rsa_deduce_primes+0xcc>
        for( iter = 1; iter <= order; ++iter )
 c057e06:	f10a 0a01 	add.w	sl, sl, #1
 c057e0a:	fa1f fa8a 	uxth.w	sl, sl
 c057e0e:	45d3      	cmp	fp, sl
 c057e10:	d2b7      	bcs.n	c057d82 <mbedtls_rsa_deduce_primes+0x13e>
        if( mbedtls_mpi_cmp_int( &K, 1 ) != 0 )
 c057e12:	2101      	movs	r1, #1
 c057e14:	a805      	add	r0, sp, #20
 c057e16:	f7fb fd54 	bl	c0538c2 <mbedtls_mpi_cmp_int>
 c057e1a:	2800      	cmp	r0, #0
 c057e1c:	d09f      	beq.n	c057d5e <mbedtls_rsa_deduce_primes+0x11a>
 c057e1e:	e775      	b.n	c057d0c <mbedtls_rsa_deduce_primes+0xc8>
 c057e20:	0c060ec0 	.word	0x0c060ec0

0c057e24 <mbedtls_rsa_deduce_private_exponent>:
 */
int mbedtls_rsa_deduce_private_exponent( mbedtls_mpi const *P,
                                         mbedtls_mpi const *Q,
                                         mbedtls_mpi const *E,
                                         mbedtls_mpi *D )
{
 c057e24:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 c057e28:	4604      	mov	r4, r0
 c057e2a:	460f      	mov	r7, r1
 c057e2c:	4616      	mov	r6, r2
    int ret = 0;
    mbedtls_mpi K, L;

    if( D == NULL || mbedtls_mpi_cmp_int( D, 0 ) != 0 )
 c057e2e:	461d      	mov	r5, r3
{
 c057e30:	b086      	sub	sp, #24
    if( D == NULL || mbedtls_mpi_cmp_int( D, 0 ) != 0 )
 c057e32:	b92b      	cbnz	r3, c057e40 <mbedtls_rsa_deduce_private_exponent+0x1c>
        return( MBEDTLS_ERR_MPI_BAD_INPUT_DATA );
 c057e34:	f06f 0403 	mvn.w	r4, #3

    mbedtls_mpi_free( &K );
    mbedtls_mpi_free( &L );

    return( ret );
}
 c057e38:	4620      	mov	r0, r4
 c057e3a:	b006      	add	sp, #24
 c057e3c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if( D == NULL || mbedtls_mpi_cmp_int( D, 0 ) != 0 )
 c057e40:	2100      	movs	r1, #0
 c057e42:	4618      	mov	r0, r3
 c057e44:	f7fb fd3d 	bl	c0538c2 <mbedtls_mpi_cmp_int>
 c057e48:	4680      	mov	r8, r0
 c057e4a:	2800      	cmp	r0, #0
 c057e4c:	d1f2      	bne.n	c057e34 <mbedtls_rsa_deduce_private_exponent+0x10>
    if( mbedtls_mpi_cmp_int( P, 1 ) <= 0 ||
 c057e4e:	2101      	movs	r1, #1
 c057e50:	4620      	mov	r0, r4
 c057e52:	f7fb fd36 	bl	c0538c2 <mbedtls_mpi_cmp_int>
 c057e56:	2800      	cmp	r0, #0
 c057e58:	ddec      	ble.n	c057e34 <mbedtls_rsa_deduce_private_exponent+0x10>
        mbedtls_mpi_cmp_int( Q, 1 ) <= 0 ||
 c057e5a:	2101      	movs	r1, #1
 c057e5c:	4638      	mov	r0, r7
 c057e5e:	f7fb fd30 	bl	c0538c2 <mbedtls_mpi_cmp_int>
    if( mbedtls_mpi_cmp_int( P, 1 ) <= 0 ||
 c057e62:	2800      	cmp	r0, #0
 c057e64:	dde6      	ble.n	c057e34 <mbedtls_rsa_deduce_private_exponent+0x10>
        mbedtls_mpi_cmp_int( E, 0 ) == 0 )
 c057e66:	4641      	mov	r1, r8
 c057e68:	4630      	mov	r0, r6
 c057e6a:	f7fb fd2a 	bl	c0538c2 <mbedtls_mpi_cmp_int>
        mbedtls_mpi_cmp_int( Q, 1 ) <= 0 ||
 c057e6e:	2800      	cmp	r0, #0
 c057e70:	d0e0      	beq.n	c057e34 <mbedtls_rsa_deduce_private_exponent+0x10>
    mbedtls_mpi_init( &K );
 c057e72:	4668      	mov	r0, sp
 c057e74:	f7fb fa3f 	bl	c0532f6 <mbedtls_mpi_init>
    mbedtls_mpi_init( &L );
 c057e78:	a803      	add	r0, sp, #12
 c057e7a:	f7fb fa3c 	bl	c0532f6 <mbedtls_mpi_init>
    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( &K, P, 1 ) );
 c057e7e:	4621      	mov	r1, r4
 c057e80:	2201      	movs	r2, #1
 c057e82:	4668      	mov	r0, sp
 c057e84:	f7fb fe56 	bl	c053b34 <mbedtls_mpi_sub_int>
 c057e88:	4604      	mov	r4, r0
 c057e8a:	bb10      	cbnz	r0, c057ed2 <mbedtls_rsa_deduce_private_exponent+0xae>
    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( &L, Q, 1 ) );
 c057e8c:	2201      	movs	r2, #1
 c057e8e:	4639      	mov	r1, r7
 c057e90:	a803      	add	r0, sp, #12
 c057e92:	f7fb fe4f 	bl	c053b34 <mbedtls_mpi_sub_int>
 c057e96:	4604      	mov	r4, r0
 c057e98:	b9d8      	cbnz	r0, c057ed2 <mbedtls_rsa_deduce_private_exponent+0xae>
    MBEDTLS_MPI_CHK( mbedtls_mpi_gcd( D, &K, &L ) );
 c057e9a:	4669      	mov	r1, sp
 c057e9c:	4628      	mov	r0, r5
 c057e9e:	aa03      	add	r2, sp, #12
 c057ea0:	f7fc fbd3 	bl	c05464a <mbedtls_mpi_gcd>
 c057ea4:	4604      	mov	r4, r0
 c057ea6:	b9a0      	cbnz	r0, c057ed2 <mbedtls_rsa_deduce_private_exponent+0xae>
    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &K, &K, &L ) );
 c057ea8:	4669      	mov	r1, sp
 c057eaa:	4668      	mov	r0, sp
 c057eac:	aa03      	add	r2, sp, #12
 c057eae:	f7fb fe57 	bl	c053b60 <mbedtls_mpi_mul_mpi>
 c057eb2:	4604      	mov	r4, r0
 c057eb4:	b968      	cbnz	r0, c057ed2 <mbedtls_rsa_deduce_private_exponent+0xae>
    MBEDTLS_MPI_CHK( mbedtls_mpi_div_mpi( &K, NULL, &K, D ) );
 c057eb6:	4601      	mov	r1, r0
 c057eb8:	462b      	mov	r3, r5
 c057eba:	466a      	mov	r2, sp
 c057ebc:	4668      	mov	r0, sp
 c057ebe:	f7fb ff74 	bl	c053daa <mbedtls_mpi_div_mpi>
 c057ec2:	4604      	mov	r4, r0
 c057ec4:	b928      	cbnz	r0, c057ed2 <mbedtls_rsa_deduce_private_exponent+0xae>
    MBEDTLS_MPI_CHK( mbedtls_mpi_inv_mod( D, E, &K ) );
 c057ec6:	466a      	mov	r2, sp
 c057ec8:	4631      	mov	r1, r6
 c057eca:	4628      	mov	r0, r5
 c057ecc:	f7fc fd18 	bl	c054900 <mbedtls_mpi_inv_mod>
 c057ed0:	4604      	mov	r4, r0
    mbedtls_mpi_free( &K );
 c057ed2:	4668      	mov	r0, sp
 c057ed4:	f7fb fa15 	bl	c053302 <mbedtls_mpi_free>
    mbedtls_mpi_free( &L );
 c057ed8:	a803      	add	r0, sp, #12
 c057eda:	f7fb fa12 	bl	c053302 <mbedtls_mpi_free>
    return( ret );
 c057ede:	e7ab      	b.n	c057e38 <mbedtls_rsa_deduce_private_exponent+0x14>

0c057ee0 <mbedtls_rsa_validate_crt>:
 * Check that RSA CRT parameters are in accordance with core parameters.
 */
int mbedtls_rsa_validate_crt( const mbedtls_mpi *P,  const mbedtls_mpi *Q,
                              const mbedtls_mpi *D,  const mbedtls_mpi *DP,
                              const mbedtls_mpi *DQ, const mbedtls_mpi *QP )
{
 c057ee0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 c057ee4:	4699      	mov	r9, r3
 c057ee6:	b087      	sub	sp, #28
 c057ee8:	4604      	mov	r4, r0
 c057eea:	e9dd 860e 	ldrd	r8, r6, [sp, #56]	@ 0x38
    int ret = 0;

    mbedtls_mpi K, L;
    mbedtls_mpi_init( &K );
 c057eee:	4668      	mov	r0, sp
{
 c057ef0:	460d      	mov	r5, r1
 c057ef2:	4617      	mov	r7, r2
    mbedtls_mpi_init( &K );
 c057ef4:	f7fb f9ff 	bl	c0532f6 <mbedtls_mpi_init>
    mbedtls_mpi_init( &L );
 c057ef8:	a803      	add	r0, sp, #12
 c057efa:	f7fb f9fc 	bl	c0532f6 <mbedtls_mpi_init>

    /* Check that DP - D == 0 mod P - 1 */
    if( DP != NULL )
 c057efe:	f1b9 0f00 	cmp.w	r9, #0
 c057f02:	d106      	bne.n	c057f12 <mbedtls_rsa_validate_crt+0x32>
            goto cleanup;
        }
    }

    /* Check that DQ - D == 0 mod Q - 1 */
    if( DQ != NULL )
 c057f04:	f1b8 0f00 	cmp.w	r8, #0
 c057f08:	d12c      	bne.n	c057f64 <mbedtls_rsa_validate_crt+0x84>
            goto cleanup;
        }
    }

    /* Check that QP * Q - 1 == 0 mod P */
    if( QP != NULL )
 c057f0a:	2e00      	cmp	r6, #0
 c057f0c:	d145      	bne.n	c057f9a <mbedtls_rsa_validate_crt+0xba>
{
 c057f0e:	2400      	movs	r4, #0
 c057f10:	e001      	b.n	c057f16 <mbedtls_rsa_validate_crt+0x36>
        if( P == NULL )
 c057f12:	b954      	cbnz	r4, c057f2a <mbedtls_rsa_validate_crt+0x4a>
{
 c057f14:	4c34      	ldr	r4, [pc, #208]	@ (c057fe8 <mbedtls_rsa_validate_crt+0x108>)
        ret != MBEDTLS_ERR_RSA_BAD_INPUT_DATA )
    {
        ret += MBEDTLS_ERR_RSA_KEY_CHECK_FAILED;
    }

    mbedtls_mpi_free( &K );
 c057f16:	4668      	mov	r0, sp
 c057f18:	f7fb f9f3 	bl	c053302 <mbedtls_mpi_free>
    mbedtls_mpi_free( &L );
 c057f1c:	a803      	add	r0, sp, #12
 c057f1e:	f7fb f9f0 	bl	c053302 <mbedtls_mpi_free>

    return( ret );
}
 c057f22:	4620      	mov	r0, r4
 c057f24:	b007      	add	sp, #28
 c057f26:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( &K, P, 1 ) );
 c057f2a:	2201      	movs	r2, #1
 c057f2c:	4621      	mov	r1, r4
 c057f2e:	4668      	mov	r0, sp
 c057f30:	f7fb fe00 	bl	c053b34 <mbedtls_mpi_sub_int>
 c057f34:	2800      	cmp	r0, #0
 c057f36:	d14d      	bne.n	c057fd4 <mbedtls_rsa_validate_crt+0xf4>
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &L, DP, D ) );
 c057f38:	463a      	mov	r2, r7
 c057f3a:	4649      	mov	r1, r9
 c057f3c:	a803      	add	r0, sp, #12
 c057f3e:	f7fb fdbf 	bl	c053ac0 <mbedtls_mpi_sub_mpi>
 c057f42:	2800      	cmp	r0, #0
 c057f44:	d146      	bne.n	c057fd4 <mbedtls_rsa_validate_crt+0xf4>
        MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( &L, &L, &K ) );
 c057f46:	a903      	add	r1, sp, #12
 c057f48:	466a      	mov	r2, sp
 c057f4a:	4608      	mov	r0, r1
 c057f4c:	f7fc f8c5 	bl	c0540da <mbedtls_mpi_mod_mpi>
 c057f50:	2800      	cmp	r0, #0
 c057f52:	d13f      	bne.n	c057fd4 <mbedtls_rsa_validate_crt+0xf4>
        if( mbedtls_mpi_cmp_int( &L, 0 ) != 0 )
 c057f54:	4601      	mov	r1, r0
 c057f56:	a803      	add	r0, sp, #12
 c057f58:	f7fb fcb3 	bl	c0538c2 <mbedtls_mpi_cmp_int>
 c057f5c:	2800      	cmp	r0, #0
 c057f5e:	d0d1      	beq.n	c057f04 <mbedtls_rsa_validate_crt+0x24>
{
 c057f60:	4c22      	ldr	r4, [pc, #136]	@ (c057fec <mbedtls_rsa_validate_crt+0x10c>)
 c057f62:	e7d8      	b.n	c057f16 <mbedtls_rsa_validate_crt+0x36>
        if( Q == NULL )
 c057f64:	2d00      	cmp	r5, #0
 c057f66:	d0d5      	beq.n	c057f14 <mbedtls_rsa_validate_crt+0x34>
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( &K, Q, 1 ) );
 c057f68:	2201      	movs	r2, #1
 c057f6a:	4629      	mov	r1, r5
 c057f6c:	4668      	mov	r0, sp
 c057f6e:	f7fb fde1 	bl	c053b34 <mbedtls_mpi_sub_int>
 c057f72:	bb78      	cbnz	r0, c057fd4 <mbedtls_rsa_validate_crt+0xf4>
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &L, DQ, D ) );
 c057f74:	463a      	mov	r2, r7
 c057f76:	4641      	mov	r1, r8
 c057f78:	a803      	add	r0, sp, #12
 c057f7a:	f7fb fda1 	bl	c053ac0 <mbedtls_mpi_sub_mpi>
 c057f7e:	bb48      	cbnz	r0, c057fd4 <mbedtls_rsa_validate_crt+0xf4>
        MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( &L, &L, &K ) );
 c057f80:	a903      	add	r1, sp, #12
 c057f82:	466a      	mov	r2, sp
 c057f84:	4608      	mov	r0, r1
 c057f86:	f7fc f8a8 	bl	c0540da <mbedtls_mpi_mod_mpi>
 c057f8a:	bb18      	cbnz	r0, c057fd4 <mbedtls_rsa_validate_crt+0xf4>
        if( mbedtls_mpi_cmp_int( &L, 0 ) != 0 )
 c057f8c:	4601      	mov	r1, r0
 c057f8e:	a803      	add	r0, sp, #12
 c057f90:	f7fb fc97 	bl	c0538c2 <mbedtls_mpi_cmp_int>
 c057f94:	2800      	cmp	r0, #0
 c057f96:	d0b8      	beq.n	c057f0a <mbedtls_rsa_validate_crt+0x2a>
 c057f98:	e7e2      	b.n	c057f60 <mbedtls_rsa_validate_crt+0x80>
        if( P == NULL || Q == NULL )
 c057f9a:	2c00      	cmp	r4, #0
 c057f9c:	d0ba      	beq.n	c057f14 <mbedtls_rsa_validate_crt+0x34>
 c057f9e:	2d00      	cmp	r5, #0
 c057fa0:	d0b8      	beq.n	c057f14 <mbedtls_rsa_validate_crt+0x34>
        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &K, QP, Q ) );
 c057fa2:	462a      	mov	r2, r5
 c057fa4:	4631      	mov	r1, r6
 c057fa6:	4668      	mov	r0, sp
 c057fa8:	f7fb fdda 	bl	c053b60 <mbedtls_mpi_mul_mpi>
 c057fac:	b990      	cbnz	r0, c057fd4 <mbedtls_rsa_validate_crt+0xf4>
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( &K, &K, 1 ) );
 c057fae:	2201      	movs	r2, #1
 c057fb0:	4669      	mov	r1, sp
 c057fb2:	4668      	mov	r0, sp
 c057fb4:	f7fb fdbe 	bl	c053b34 <mbedtls_mpi_sub_int>
 c057fb8:	b960      	cbnz	r0, c057fd4 <mbedtls_rsa_validate_crt+0xf4>
        MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( &K, &K, P ) );
 c057fba:	4622      	mov	r2, r4
 c057fbc:	4669      	mov	r1, sp
 c057fbe:	4668      	mov	r0, sp
 c057fc0:	f7fc f88b 	bl	c0540da <mbedtls_mpi_mod_mpi>
 c057fc4:	b930      	cbnz	r0, c057fd4 <mbedtls_rsa_validate_crt+0xf4>
        if( mbedtls_mpi_cmp_int( &K, 0 ) != 0 )
 c057fc6:	4601      	mov	r1, r0
 c057fc8:	4668      	mov	r0, sp
 c057fca:	f7fb fc7a 	bl	c0538c2 <mbedtls_mpi_cmp_int>
 c057fce:	2800      	cmp	r0, #0
 c057fd0:	d09d      	beq.n	c057f0e <mbedtls_rsa_validate_crt+0x2e>
 c057fd2:	e7c5      	b.n	c057f60 <mbedtls_rsa_validate_crt+0x80>
    if( ret != 0 &&
 c057fd4:	f510 4f84 	cmn.w	r0, #16896	@ 0x4200
 c057fd8:	d0c2      	beq.n	c057f60 <mbedtls_rsa_validate_crt+0x80>
        ret != MBEDTLS_ERR_RSA_KEY_CHECK_FAILED &&
 c057fda:	f510 4f81 	cmn.w	r0, #16512	@ 0x4080
 c057fde:	d099      	beq.n	c057f14 <mbedtls_rsa_validate_crt+0x34>
        ret += MBEDTLS_ERR_RSA_KEY_CHECK_FAILED;
 c057fe0:	f5a0 4484 	sub.w	r4, r0, #16896	@ 0x4200
 c057fe4:	e797      	b.n	c057f16 <mbedtls_rsa_validate_crt+0x36>
 c057fe6:	bf00      	nop
 c057fe8:	ffffbf80 	.word	0xffffbf80
 c057fec:	ffffbe00 	.word	0xffffbe00

0c057ff0 <mbedtls_rsa_validate_params>:
int mbedtls_rsa_validate_params( const mbedtls_mpi *N, const mbedtls_mpi *P,
                                 const mbedtls_mpi *Q, const mbedtls_mpi *D,
                                 const mbedtls_mpi *E,
                                 int (*f_rng)(void *, unsigned char *, size_t),
                                 void *p_rng )
{
 c057ff0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 c057ff4:	b086      	sub	sp, #24
 c057ff6:	4681      	mov	r9, r0
 c057ff8:	e9dd 740e 	ldrd	r7, r4, [sp, #56]	@ 0x38
    int ret = 0;
    mbedtls_mpi K, L;

    mbedtls_mpi_init( &K );
 c057ffc:	4668      	mov	r0, sp
{
 c057ffe:	4688      	mov	r8, r1
 c058000:	4615      	mov	r5, r2
 c058002:	461e      	mov	r6, r3
 c058004:	f8dd a040 	ldr.w	sl, [sp, #64]	@ 0x40
    mbedtls_mpi_init( &K );
 c058008:	f7fb f975 	bl	c0532f6 <mbedtls_mpi_init>
    mbedtls_mpi_init( &L );
 c05800c:	a803      	add	r0, sp, #12
 c05800e:	f7fb f972 	bl	c0532f6 <mbedtls_mpi_init>
    /*
     * When generating keys, the strongest security we support aims for an error
     * rate of at most 2^-100 and we are aiming for the same certainty here as
     * well.
     */
    if( f_rng != NULL && P != NULL &&
 c058012:	b354      	cbz	r4, c05806a <mbedtls_rsa_validate_params+0x7a>
 c058014:	f1b8 0f00 	cmp.w	r8, #0
 c058018:	d017      	beq.n	c05804a <mbedtls_rsa_validate_params+0x5a>
        ( ret = mbedtls_mpi_is_prime_ext( P, 50, f_rng, p_rng ) ) != 0 )
 c05801a:	4653      	mov	r3, sl
 c05801c:	4622      	mov	r2, r4
 c05801e:	2132      	movs	r1, #50	@ 0x32
 c058020:	4640      	mov	r0, r8
 c058022:	f7fc fdc9 	bl	c054bb8 <mbedtls_mpi_is_prime_ext>
    if( f_rng != NULL && P != NULL &&
 c058026:	b180      	cbz	r0, c05804a <mbedtls_rsa_validate_params+0x5a>
    {
        ret = MBEDTLS_ERR_RSA_KEY_CHECK_FAILED;
 c058028:	4c63      	ldr	r4, [pc, #396]	@ (c0581b8 <mbedtls_rsa_validate_params+0x1c8>)
        }
    }

cleanup:

    mbedtls_mpi_free( &K );
 c05802a:	4668      	mov	r0, sp
 c05802c:	f7fb f969 	bl	c053302 <mbedtls_mpi_free>
    mbedtls_mpi_free( &L );
 c058030:	a803      	add	r0, sp, #12
 c058032:	f7fb f966 	bl	c053302 <mbedtls_mpi_free>

    /* Wrap MPI error codes by RSA check failure error code */
    if( ret != 0 && ret != MBEDTLS_ERR_RSA_KEY_CHECK_FAILED )
 c058036:	b124      	cbz	r4, c058042 <mbedtls_rsa_validate_params+0x52>
 c058038:	f514 4f84 	cmn.w	r4, #16896	@ 0x4200
 c05803c:	d001      	beq.n	c058042 <mbedtls_rsa_validate_params+0x52>
    {
        ret += MBEDTLS_ERR_RSA_KEY_CHECK_FAILED;
 c05803e:	f5a4 4484 	sub.w	r4, r4, #16896	@ 0x4200
    }

    return( ret );
}
 c058042:	4620      	mov	r0, r4
 c058044:	b006      	add	sp, #24
 c058046:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if( f_rng != NULL && Q != NULL &&
 c05804a:	b155      	cbz	r5, c058062 <mbedtls_rsa_validate_params+0x72>
        ( ret = mbedtls_mpi_is_prime_ext( Q, 50, f_rng, p_rng ) ) != 0 )
 c05804c:	4653      	mov	r3, sl
 c05804e:	4622      	mov	r2, r4
 c058050:	2132      	movs	r1, #50	@ 0x32
 c058052:	4628      	mov	r0, r5
 c058054:	f7fc fdb0 	bl	c054bb8 <mbedtls_mpi_is_prime_ext>
    if( f_rng != NULL && Q != NULL &&
 c058058:	2800      	cmp	r0, #0
 c05805a:	d1e5      	bne.n	c058028 <mbedtls_rsa_validate_params+0x38>
    if( P != NULL && Q != NULL && N != NULL )
 c05805c:	f1b8 0f00 	cmp.w	r8, #0
 c058060:	d108      	bne.n	c058074 <mbedtls_rsa_validate_params+0x84>
    if( N != NULL && D != NULL && E != NULL )
 c058062:	f1b9 0f00 	cmp.w	r9, #0
 c058066:	d120      	bne.n	c0580aa <mbedtls_rsa_validate_params+0xba>
 c058068:	e020      	b.n	c0580ac <mbedtls_rsa_validate_params+0xbc>
    if( P != NULL && Q != NULL && N != NULL )
 c05806a:	f1b8 0f00 	cmp.w	r8, #0
 c05806e:	d0f8      	beq.n	c058062 <mbedtls_rsa_validate_params+0x72>
 c058070:	2d00      	cmp	r5, #0
 c058072:	d0f6      	beq.n	c058062 <mbedtls_rsa_validate_params+0x72>
 c058074:	f1b9 0f00 	cmp.w	r9, #0
 c058078:	d103      	bne.n	c058082 <mbedtls_rsa_validate_params+0x92>
    if( P != NULL && Q != NULL && D != NULL && E != NULL )
 c05807a:	2e00      	cmp	r6, #0
 c05807c:	d137      	bne.n	c0580ee <mbedtls_rsa_validate_params+0xfe>
        ret = MBEDTLS_ERR_RSA_KEY_CHECK_FAILED;
 c05807e:	2400      	movs	r4, #0
 c058080:	e7d3      	b.n	c05802a <mbedtls_rsa_validate_params+0x3a>
        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &K, P, Q ) );
 c058082:	462a      	mov	r2, r5
 c058084:	4641      	mov	r1, r8
 c058086:	4668      	mov	r0, sp
 c058088:	f7fb fd6a 	bl	c053b60 <mbedtls_mpi_mul_mpi>
 c05808c:	4604      	mov	r4, r0
 c05808e:	2800      	cmp	r0, #0
 c058090:	d1cb      	bne.n	c05802a <mbedtls_rsa_validate_params+0x3a>
        if( mbedtls_mpi_cmp_int( N, 1 )  <= 0 ||
 c058092:	2101      	movs	r1, #1
 c058094:	4648      	mov	r0, r9
 c058096:	f7fb fc14 	bl	c0538c2 <mbedtls_mpi_cmp_int>
 c05809a:	2800      	cmp	r0, #0
 c05809c:	ddc4      	ble.n	c058028 <mbedtls_rsa_validate_params+0x38>
            mbedtls_mpi_cmp_mpi( &K, N ) != 0 )
 c05809e:	4649      	mov	r1, r9
 c0580a0:	4668      	mov	r0, sp
 c0580a2:	f7fb fbcb 	bl	c05383c <mbedtls_mpi_cmp_mpi>
        if( mbedtls_mpi_cmp_int( N, 1 )  <= 0 ||
 c0580a6:	2800      	cmp	r0, #0
 c0580a8:	d1be      	bne.n	c058028 <mbedtls_rsa_validate_params+0x38>
    if( N != NULL && D != NULL && E != NULL )
 c0580aa:	b92e      	cbnz	r6, c0580b8 <mbedtls_rsa_validate_params+0xc8>
    if( P != NULL && Q != NULL && D != NULL && E != NULL )
 c0580ac:	f1b8 0f00 	cmp.w	r8, #0
 c0580b0:	d0e5      	beq.n	c05807e <mbedtls_rsa_validate_params+0x8e>
 c0580b2:	2d00      	cmp	r5, #0
 c0580b4:	d0e3      	beq.n	c05807e <mbedtls_rsa_validate_params+0x8e>
 c0580b6:	e7e0      	b.n	c05807a <mbedtls_rsa_validate_params+0x8a>
    if( N != NULL && D != NULL && E != NULL )
 c0580b8:	2f00      	cmp	r7, #0
 c0580ba:	d0f7      	beq.n	c0580ac <mbedtls_rsa_validate_params+0xbc>
        if ( mbedtls_mpi_cmp_int( D, 1 ) <= 0 ||
 c0580bc:	2101      	movs	r1, #1
 c0580be:	4630      	mov	r0, r6
 c0580c0:	f7fb fbff 	bl	c0538c2 <mbedtls_mpi_cmp_int>
 c0580c4:	2800      	cmp	r0, #0
 c0580c6:	ddaf      	ble.n	c058028 <mbedtls_rsa_validate_params+0x38>
             mbedtls_mpi_cmp_int( E, 1 ) <= 0 ||
 c0580c8:	2101      	movs	r1, #1
 c0580ca:	4638      	mov	r0, r7
 c0580cc:	f7fb fbf9 	bl	c0538c2 <mbedtls_mpi_cmp_int>
        if ( mbedtls_mpi_cmp_int( D, 1 ) <= 0 ||
 c0580d0:	2800      	cmp	r0, #0
 c0580d2:	dda9      	ble.n	c058028 <mbedtls_rsa_validate_params+0x38>
             mbedtls_mpi_cmp_mpi( D, N ) >= 0 ||
 c0580d4:	4649      	mov	r1, r9
 c0580d6:	4630      	mov	r0, r6
 c0580d8:	f7fb fbb0 	bl	c05383c <mbedtls_mpi_cmp_mpi>
             mbedtls_mpi_cmp_int( E, 1 ) <= 0 ||
 c0580dc:	2800      	cmp	r0, #0
 c0580de:	daa3      	bge.n	c058028 <mbedtls_rsa_validate_params+0x38>
             mbedtls_mpi_cmp_mpi( E, N ) >= 0 )
 c0580e0:	4649      	mov	r1, r9
 c0580e2:	4638      	mov	r0, r7
 c0580e4:	f7fb fbaa 	bl	c05383c <mbedtls_mpi_cmp_mpi>
             mbedtls_mpi_cmp_mpi( D, N ) >= 0 ||
 c0580e8:	2800      	cmp	r0, #0
 c0580ea:	dbdf      	blt.n	c0580ac <mbedtls_rsa_validate_params+0xbc>
 c0580ec:	e79c      	b.n	c058028 <mbedtls_rsa_validate_params+0x38>
    if( P != NULL && Q != NULL && D != NULL && E != NULL )
 c0580ee:	2f00      	cmp	r7, #0
 c0580f0:	d0c5      	beq.n	c05807e <mbedtls_rsa_validate_params+0x8e>
        if( mbedtls_mpi_cmp_int( P, 1 ) <= 0 ||
 c0580f2:	2101      	movs	r1, #1
 c0580f4:	4640      	mov	r0, r8
 c0580f6:	f7fb fbe4 	bl	c0538c2 <mbedtls_mpi_cmp_int>
 c0580fa:	2800      	cmp	r0, #0
 c0580fc:	dd94      	ble.n	c058028 <mbedtls_rsa_validate_params+0x38>
            mbedtls_mpi_cmp_int( Q, 1 ) <= 0 )
 c0580fe:	2101      	movs	r1, #1
 c058100:	4628      	mov	r0, r5
 c058102:	f7fb fbde 	bl	c0538c2 <mbedtls_mpi_cmp_int>
        if( mbedtls_mpi_cmp_int( P, 1 ) <= 0 ||
 c058106:	2800      	cmp	r0, #0
 c058108:	dd8e      	ble.n	c058028 <mbedtls_rsa_validate_params+0x38>
        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &K, D, E ) );
 c05810a:	463a      	mov	r2, r7
 c05810c:	4631      	mov	r1, r6
 c05810e:	4668      	mov	r0, sp
 c058110:	f7fb fd26 	bl	c053b60 <mbedtls_mpi_mul_mpi>
 c058114:	4604      	mov	r4, r0
 c058116:	2800      	cmp	r0, #0
 c058118:	d187      	bne.n	c05802a <mbedtls_rsa_validate_params+0x3a>
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( &K, &K, 1 ) );
 c05811a:	2201      	movs	r2, #1
 c05811c:	4669      	mov	r1, sp
 c05811e:	4668      	mov	r0, sp
 c058120:	f7fb fd08 	bl	c053b34 <mbedtls_mpi_sub_int>
 c058124:	4604      	mov	r4, r0
 c058126:	2800      	cmp	r0, #0
 c058128:	f47f af7f 	bne.w	c05802a <mbedtls_rsa_validate_params+0x3a>
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( &L, P, 1 ) );
 c05812c:	2201      	movs	r2, #1
 c05812e:	4641      	mov	r1, r8
 c058130:	a803      	add	r0, sp, #12
 c058132:	f7fb fcff 	bl	c053b34 <mbedtls_mpi_sub_int>
 c058136:	4604      	mov	r4, r0
 c058138:	2800      	cmp	r0, #0
 c05813a:	f47f af76 	bne.w	c05802a <mbedtls_rsa_validate_params+0x3a>
        MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( &K, &K, &L ) );
 c05813e:	4669      	mov	r1, sp
 c058140:	4668      	mov	r0, sp
 c058142:	aa03      	add	r2, sp, #12
 c058144:	f7fb ffc9 	bl	c0540da <mbedtls_mpi_mod_mpi>
 c058148:	4604      	mov	r4, r0
 c05814a:	2800      	cmp	r0, #0
 c05814c:	f47f af6d 	bne.w	c05802a <mbedtls_rsa_validate_params+0x3a>
        if( mbedtls_mpi_cmp_int( &K, 0 ) != 0 )
 c058150:	4601      	mov	r1, r0
 c058152:	4668      	mov	r0, sp
 c058154:	f7fb fbb5 	bl	c0538c2 <mbedtls_mpi_cmp_int>
 c058158:	2800      	cmp	r0, #0
 c05815a:	f47f af65 	bne.w	c058028 <mbedtls_rsa_validate_params+0x38>
        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &K, D, E ) );
 c05815e:	463a      	mov	r2, r7
 c058160:	4631      	mov	r1, r6
 c058162:	4668      	mov	r0, sp
 c058164:	f7fb fcfc 	bl	c053b60 <mbedtls_mpi_mul_mpi>
 c058168:	4604      	mov	r4, r0
 c05816a:	2800      	cmp	r0, #0
 c05816c:	f47f af5d 	bne.w	c05802a <mbedtls_rsa_validate_params+0x3a>
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( &K, &K, 1 ) );
 c058170:	2201      	movs	r2, #1
 c058172:	4669      	mov	r1, sp
 c058174:	4668      	mov	r0, sp
 c058176:	f7fb fcdd 	bl	c053b34 <mbedtls_mpi_sub_int>
 c05817a:	4604      	mov	r4, r0
 c05817c:	2800      	cmp	r0, #0
 c05817e:	f47f af54 	bne.w	c05802a <mbedtls_rsa_validate_params+0x3a>
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( &L, Q, 1 ) );
 c058182:	2201      	movs	r2, #1
 c058184:	4629      	mov	r1, r5
 c058186:	a803      	add	r0, sp, #12
 c058188:	f7fb fcd4 	bl	c053b34 <mbedtls_mpi_sub_int>
 c05818c:	4604      	mov	r4, r0
 c05818e:	2800      	cmp	r0, #0
 c058190:	f47f af4b 	bne.w	c05802a <mbedtls_rsa_validate_params+0x3a>
        MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( &K, &K, &L ) );
 c058194:	4669      	mov	r1, sp
 c058196:	4668      	mov	r0, sp
 c058198:	aa03      	add	r2, sp, #12
 c05819a:	f7fb ff9e 	bl	c0540da <mbedtls_mpi_mod_mpi>
 c05819e:	4604      	mov	r4, r0
 c0581a0:	2800      	cmp	r0, #0
 c0581a2:	f47f af42 	bne.w	c05802a <mbedtls_rsa_validate_params+0x3a>
        if( mbedtls_mpi_cmp_int( &K, 0 ) != 0 )
 c0581a6:	4601      	mov	r1, r0
 c0581a8:	4668      	mov	r0, sp
 c0581aa:	f7fb fb8a 	bl	c0538c2 <mbedtls_mpi_cmp_int>
 c0581ae:	2800      	cmp	r0, #0
 c0581b0:	f43f af65 	beq.w	c05807e <mbedtls_rsa_validate_params+0x8e>
 c0581b4:	e738      	b.n	c058028 <mbedtls_rsa_validate_params+0x38>
 c0581b6:	bf00      	nop
 c0581b8:	ffffbe00 	.word	0xffffbe00

0c0581bc <mbedtls_rsa_deduce_crt>:

int mbedtls_rsa_deduce_crt( const mbedtls_mpi *P, const mbedtls_mpi *Q,
                            const mbedtls_mpi *D, mbedtls_mpi *DP,
                            mbedtls_mpi *DQ, mbedtls_mpi *QP )
{
 c0581bc:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 c0581c0:	469a      	mov	sl, r3
 c0581c2:	e9dd 980c 	ldrd	r9, r8, [sp, #48]	@ 0x30
 c0581c6:	4606      	mov	r6, r0
    int ret = 0;
    mbedtls_mpi K;
    mbedtls_mpi_init( &K );
 c0581c8:	a801      	add	r0, sp, #4
{
 c0581ca:	460d      	mov	r5, r1
 c0581cc:	4617      	mov	r7, r2
    mbedtls_mpi_init( &K );
 c0581ce:	f7fb f892 	bl	c0532f6 <mbedtls_mpi_init>

    /* DP = D mod P-1 */
    if( DP != NULL )
 c0581d2:	f1ba 0f00 	cmp.w	sl, #0
 c0581d6:	d107      	bne.n	c0581e8 <mbedtls_rsa_deduce_crt+0x2c>
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( &K, P, 1  ) );
        MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( DP, D, &K ) );
    }

    /* DQ = D mod Q-1 */
    if( DQ != NULL )
 c0581d8:	f1b9 0f00 	cmp.w	r9, #0
 c0581dc:	d11a      	bne.n	c058214 <mbedtls_rsa_deduce_crt+0x58>
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( &K, Q, 1  ) );
        MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( DQ, D, &K ) );
    }

    /* QP = Q^{-1} mod P */
    if( QP != NULL )
 c0581de:	f1b8 0f00 	cmp.w	r8, #0
 c0581e2:	d128      	bne.n	c058236 <mbedtls_rsa_deduce_crt+0x7a>
    {
        MBEDTLS_MPI_CHK( mbedtls_mpi_inv_mod( QP, Q, P ) );
    }

cleanup:
 c0581e4:	4644      	mov	r4, r8
 c0581e6:	e00e      	b.n	c058206 <mbedtls_rsa_deduce_crt+0x4a>
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( &K, P, 1  ) );
 c0581e8:	2201      	movs	r2, #1
 c0581ea:	4631      	mov	r1, r6
 c0581ec:	a801      	add	r0, sp, #4
 c0581ee:	f7fb fca1 	bl	c053b34 <mbedtls_mpi_sub_int>
 c0581f2:	4604      	mov	r4, r0
 c0581f4:	b938      	cbnz	r0, c058206 <mbedtls_rsa_deduce_crt+0x4a>
        MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( DP, D, &K ) );
 c0581f6:	4639      	mov	r1, r7
 c0581f8:	4650      	mov	r0, sl
 c0581fa:	aa01      	add	r2, sp, #4
 c0581fc:	f7fb ff6d 	bl	c0540da <mbedtls_mpi_mod_mpi>
 c058200:	4604      	mov	r4, r0
 c058202:	2800      	cmp	r0, #0
 c058204:	d0e8      	beq.n	c0581d8 <mbedtls_rsa_deduce_crt+0x1c>
    mbedtls_mpi_free( &K );
 c058206:	a801      	add	r0, sp, #4
 c058208:	f7fb f87b 	bl	c053302 <mbedtls_mpi_free>

    return( ret );
}
 c05820c:	4620      	mov	r0, r4
 c05820e:	b004      	add	sp, #16
 c058210:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( &K, Q, 1  ) );
 c058214:	2201      	movs	r2, #1
 c058216:	4629      	mov	r1, r5
 c058218:	a801      	add	r0, sp, #4
 c05821a:	f7fb fc8b 	bl	c053b34 <mbedtls_mpi_sub_int>
 c05821e:	4604      	mov	r4, r0
 c058220:	2800      	cmp	r0, #0
 c058222:	d1f0      	bne.n	c058206 <mbedtls_rsa_deduce_crt+0x4a>
        MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( DQ, D, &K ) );
 c058224:	4639      	mov	r1, r7
 c058226:	4648      	mov	r0, r9
 c058228:	aa01      	add	r2, sp, #4
 c05822a:	f7fb ff56 	bl	c0540da <mbedtls_mpi_mod_mpi>
 c05822e:	4604      	mov	r4, r0
 c058230:	2800      	cmp	r0, #0
 c058232:	d0d4      	beq.n	c0581de <mbedtls_rsa_deduce_crt+0x22>
 c058234:	e7e7      	b.n	c058206 <mbedtls_rsa_deduce_crt+0x4a>
        MBEDTLS_MPI_CHK( mbedtls_mpi_inv_mod( QP, Q, P ) );
 c058236:	4632      	mov	r2, r6
 c058238:	4629      	mov	r1, r5
 c05823a:	4640      	mov	r0, r8
 c05823c:	f7fc fb60 	bl	c054900 <mbedtls_mpi_inv_mod>
 c058240:	4604      	mov	r4, r0
cleanup:
 c058242:	e7e0      	b.n	c058206 <mbedtls_rsa_deduce_crt+0x4a>

0c058244 <mbedtls_sha256_ret>:
 */
int mbedtls_sha256_ret( const unsigned char *input,
                        size_t ilen,
                        unsigned char output[32],
                        int is224 )
{
 c058244:	b5f0      	push	{r4, r5, r6, r7, lr}
 c058246:	461c      	mov	r4, r3
 c058248:	b0df      	sub	sp, #380	@ 0x17c
 c05824a:	4606      	mov	r6, r0

    SHA256_VALIDATE_RET( is224 == 0 || is224 == 1 );
    SHA256_VALIDATE_RET( ilen == 0 || input != NULL );
    SHA256_VALIDATE_RET( (unsigned char *)output != NULL );

    mbedtls_sha256_init( &ctx );
 c05824c:	a801      	add	r0, sp, #4
{
 c05824e:	460f      	mov	r7, r1
 c058250:	4615      	mov	r5, r2
    mbedtls_sha256_init( &ctx );
 c058252:	f7f8 fb8f 	bl	c050974 <mbedtls_sha256_init>

    if( ( ret = mbedtls_sha256_starts_ret( &ctx, is224 ) ) != 0 )
 c058256:	4621      	mov	r1, r4
 c058258:	a801      	add	r0, sp, #4
 c05825a:	f7f8 fbb5 	bl	c0509c8 <mbedtls_sha256_starts_ret>
 c05825e:	4604      	mov	r4, r0
 c058260:	b958      	cbnz	r0, c05827a <mbedtls_sha256_ret+0x36>
        goto exit;

    if( ( ret = mbedtls_sha256_update_ret( &ctx, input, ilen ) ) != 0 )
 c058262:	463a      	mov	r2, r7
 c058264:	4631      	mov	r1, r6
 c058266:	a801      	add	r0, sp, #4
 c058268:	f7f8 fbce 	bl	c050a08 <mbedtls_sha256_update_ret>
 c05826c:	4604      	mov	r4, r0
 c05826e:	b920      	cbnz	r0, c05827a <mbedtls_sha256_ret+0x36>
        goto exit;

    if( ( ret = mbedtls_sha256_finish_ret( &ctx, output ) ) != 0 )
 c058270:	4629      	mov	r1, r5
 c058272:	a801      	add	r0, sp, #4
 c058274:	f7f8 fc2f 	bl	c050ad6 <mbedtls_sha256_finish_ret>
 c058278:	4604      	mov	r4, r0
        goto exit;

exit:
    mbedtls_sha256_free( &ctx );
 c05827a:	a801      	add	r0, sp, #4
 c05827c:	f7f8 fb94 	bl	c0509a8 <mbedtls_sha256_free>

    return( ret );
}
 c058280:	4620      	mov	r0, r4
 c058282:	b05f      	add	sp, #380	@ 0x17c
 c058284:	bdf0      	pop	{r4, r5, r6, r7, pc}

0c058286 <mbedtls_sha512_init>:

void mbedtls_sha512_init( mbedtls_sha512_context *ctx )
{
    SHA512_VALIDATE( ctx != NULL );

    memset( ctx, 0, sizeof( mbedtls_sha512_context ) );
 c058286:	22d8      	movs	r2, #216	@ 0xd8
 c058288:	2100      	movs	r1, #0
 c05828a:	f003 ba50 	b.w	c05b72e <memset>

0c05828e <mbedtls_sha512_free>:
}

void mbedtls_sha512_free( mbedtls_sha512_context *ctx )
{
    if( ctx == NULL )
 c05828e:	b110      	cbz	r0, c058296 <mbedtls_sha512_free+0x8>
        return;

    mbedtls_platform_zeroize( ctx, sizeof( mbedtls_sha512_context ) );
 c058290:	21d8      	movs	r1, #216	@ 0xd8
 c058292:	f7e3 b89d 	b.w	c03b3d0 <mbedtls_platform_zeroize>
}
 c058296:	4770      	bx	lr

0c058298 <mbedtls_sha512_clone>:

void mbedtls_sha512_clone( mbedtls_sha512_context *dst,
                           const mbedtls_sha512_context *src )
{
 c058298:	b508      	push	{r3, lr}
    SHA512_VALIDATE( dst != NULL );
    SHA512_VALIDATE( src != NULL );

    *dst = *src;
 c05829a:	22d8      	movs	r2, #216	@ 0xd8
 c05829c:	f003 f9d6 	bl	c05b64c <memcpy>
}
 c0582a0:	bd08      	pop	{r3, pc}
 c0582a2:	0000      	movs	r0, r0
 c0582a4:	0000      	movs	r0, r0
	...

0c0582a8 <mbedtls_sha512_starts_ret>:

/*
 * SHA-512 context setup
 */
int mbedtls_sha512_starts_ret( mbedtls_sha512_context *ctx, int is384 )
{
 c0582a8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c0582ac:	4684      	mov	ip, r0
#endif

    ctx->total[0] = 0;
    ctx->total[1] = 0;

    if( is384 == 0 )
 c0582ae:	468e      	mov	lr, r1
{
 c0582b0:	b087      	sub	sp, #28
    if( is384 == 0 )
 c0582b2:	2900      	cmp	r1, #0
 c0582b4:	d042      	beq.n	c05833c <mbedtls_sha512_starts_ret+0x94>
 c0582b6:	a332      	add	r3, pc, #200	@ (adr r3, c058380 <mbedtls_sha512_starts_ret+0xd8>)
 c0582b8:	e9d3 2300 	ldrd	r2, r3, [r3]
 c0582bc:	a732      	add	r7, pc, #200	@ (adr r7, c058388 <mbedtls_sha512_starts_ret+0xe0>)
 c0582be:	e9d7 6700 	ldrd	r6, r7, [r7]
 c0582c2:	a533      	add	r5, pc, #204	@ (adr r5, c058390 <mbedtls_sha512_starts_ret+0xe8>)
 c0582c4:	e9d5 4500 	ldrd	r4, r5, [r5]
 c0582c8:	f20f 0bcc 	addw	fp, pc, #204	@ 0xcc
 c0582cc:	e9db ab00 	ldrd	sl, fp, [fp]
 c0582d0:	a133      	add	r1, pc, #204	@ (adr r1, c0583a0 <mbedtls_sha512_starts_ret+0xf8>)
 c0582d2:	e9d1 0100 	ldrd	r0, r1, [r1]
 c0582d6:	e9cd 2304 	strd	r2, r3, [sp, #16]
 c0582da:	a333      	add	r3, pc, #204	@ (adr r3, c0583a8 <mbedtls_sha512_starts_ret+0x100>)
 c0582dc:	e9d3 2300 	ldrd	r2, r3, [r3]
 c0582e0:	e9cd 2302 	strd	r2, r3, [sp, #8]
 c0582e4:	a332      	add	r3, pc, #200	@ (adr r3, c0583b0 <mbedtls_sha512_starts_ret+0x108>)
 c0582e6:	e9d3 2300 	ldrd	r2, r3, [r3]
 c0582ea:	e9cd 2300 	strd	r2, r3, [sp]
 c0582ee:	a332      	add	r3, pc, #200	@ (adr r3, c0583b8 <mbedtls_sha512_starts_ret+0x110>)
 c0582f0:	e9d3 2300 	ldrd	r2, r3, [r3]
    ctx->total[0] = 0;
 c0582f4:	f04f 0800 	mov.w	r8, #0
 c0582f8:	f04f 0900 	mov.w	r9, #0
    {
        /* SHA-512 */
        ctx->state[0] = UL64(0x6A09E667F3BCC908);
        ctx->state[1] = UL64(0xBB67AE8584CAA73B);
        ctx->state[2] = UL64(0x3C6EF372FE94F82B);
        ctx->state[3] = UL64(0xA54FF53A5F1D36F1);
 c0582fc:	e9cc 010a 	strd	r0, r1, [ip, #40]	@ 0x28
        ctx->state[4] = UL64(0x510E527FADE682D1);
 c058300:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 c058304:	e9cc 010c 	strd	r0, r1, [ip, #48]	@ 0x30
        ctx->state[5] = UL64(0x9B05688C2B3E6C1F);
 c058308:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 c05830c:	e9cc 010e 	strd	r0, r1, [ip, #56]	@ 0x38
        ctx->state[6] = UL64(0x1F83D9ABFB41BD6B);
 c058310:	e9dd 0100 	ldrd	r0, r1, [sp]
 c058314:	e9cc 0110 	strd	r0, r1, [ip, #64]	@ 0x40
#if !defined(MBEDTLS_SHA512_NO_SHA384)
    ctx->is384 = is384;
#endif

    return( 0 );
}
 c058318:	2000      	movs	r0, #0
    ctx->total[0] = 0;
 c05831a:	e9cc 8900 	strd	r8, r9, [ip]
    ctx->total[1] = 0;
 c05831e:	e9cc 8902 	strd	r8, r9, [ip, #8]
        ctx->state[0] = UL64(0x6A09E667F3BCC908);
 c058322:	e9cc 6704 	strd	r6, r7, [ip, #16]
        ctx->state[1] = UL64(0xBB67AE8584CAA73B);
 c058326:	e9cc 4506 	strd	r4, r5, [ip, #24]
        ctx->state[2] = UL64(0x3C6EF372FE94F82B);
 c05832a:	e9cc ab08 	strd	sl, fp, [ip, #32]
        ctx->state[7] = UL64(0x5BE0CD19137E2179);
 c05832e:	e9cc 2312 	strd	r2, r3, [ip, #72]	@ 0x48
    ctx->is384 = is384;
 c058332:	f8cc e0d0 	str.w	lr, [ip, #208]	@ 0xd0
}
 c058336:	b007      	add	sp, #28
 c058338:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 c05833c:	a320      	add	r3, pc, #128	@ (adr r3, c0583c0 <mbedtls_sha512_starts_ret+0x118>)
 c05833e:	e9d3 2300 	ldrd	r2, r3, [r3]
 c058342:	a721      	add	r7, pc, #132	@ (adr r7, c0583c8 <mbedtls_sha512_starts_ret+0x120>)
 c058344:	e9d7 6700 	ldrd	r6, r7, [r7]
 c058348:	e9cd 2304 	strd	r2, r3, [sp, #16]
 c05834c:	a520      	add	r5, pc, #128	@ (adr r5, c0583d0 <mbedtls_sha512_starts_ret+0x128>)
 c05834e:	e9d5 4500 	ldrd	r4, r5, [r5]
 c058352:	a321      	add	r3, pc, #132	@ (adr r3, c0583d8 <mbedtls_sha512_starts_ret+0x130>)
 c058354:	e9d3 2300 	ldrd	r2, r3, [r3]
 c058358:	f20f 0b84 	addw	fp, pc, #132	@ 0x84
 c05835c:	e9db ab00 	ldrd	sl, fp, [fp]
 c058360:	e9cd 2302 	strd	r2, r3, [sp, #8]
 c058364:	a120      	add	r1, pc, #128	@ (adr r1, c0583e8 <mbedtls_sha512_starts_ret+0x140>)
 c058366:	e9d1 0100 	ldrd	r0, r1, [r1]
 c05836a:	a321      	add	r3, pc, #132	@ (adr r3, c0583f0 <mbedtls_sha512_starts_ret+0x148>)
 c05836c:	e9d3 2300 	ldrd	r2, r3, [r3]
 c058370:	e9cd 2300 	strd	r2, r3, [sp]
 c058374:	a320      	add	r3, pc, #128	@ (adr r3, c0583f8 <mbedtls_sha512_starts_ret+0x150>)
 c058376:	e9d3 2300 	ldrd	r2, r3, [r3]
 c05837a:	e7bb      	b.n	c0582f4 <mbedtls_sha512_starts_ret+0x4c>
 c05837c:	f3af 8000 	nop.w
 c058380:	ffc00b31 	.word	0xffc00b31
 c058384:	67332667 	.word	0x67332667
 c058388:	c1059ed8 	.word	0xc1059ed8
 c05838c:	cbbb9d5d 	.word	0xcbbb9d5d
 c058390:	367cd507 	.word	0x367cd507
 c058394:	629a292a 	.word	0x629a292a
 c058398:	3070dd17 	.word	0x3070dd17
 c05839c:	9159015a 	.word	0x9159015a
 c0583a0:	f70e5939 	.word	0xf70e5939
 c0583a4:	152fecd8 	.word	0x152fecd8
 c0583a8:	68581511 	.word	0x68581511
 c0583ac:	8eb44a87 	.word	0x8eb44a87
 c0583b0:	64f98fa7 	.word	0x64f98fa7
 c0583b4:	db0c2e0d 	.word	0xdb0c2e0d
 c0583b8:	befa4fa4 	.word	0xbefa4fa4
 c0583bc:	47b5481d 	.word	0x47b5481d
 c0583c0:	ade682d1 	.word	0xade682d1
 c0583c4:	510e527f 	.word	0x510e527f
 c0583c8:	f3bcc908 	.word	0xf3bcc908
 c0583cc:	6a09e667 	.word	0x6a09e667
 c0583d0:	84caa73b 	.word	0x84caa73b
 c0583d4:	bb67ae85 	.word	0xbb67ae85
 c0583d8:	2b3e6c1f 	.word	0x2b3e6c1f
 c0583dc:	9b05688c 	.word	0x9b05688c
 c0583e0:	fe94f82b 	.word	0xfe94f82b
 c0583e4:	3c6ef372 	.word	0x3c6ef372
 c0583e8:	5f1d36f1 	.word	0x5f1d36f1
 c0583ec:	a54ff53a 	.word	0xa54ff53a
 c0583f0:	fb41bd6b 	.word	0xfb41bd6b
 c0583f4:	1f83d9ab 	.word	0x1f83d9ab
 c0583f8:	137e2179 	.word	0x137e2179
 c0583fc:	5be0cd19 	.word	0x5be0cd19

0c058400 <mbedtls_internal_sha512_process>:
        local.temp2 = S2(a) + F0((a),(b),(c));                      \
        (d) += local.temp1; (h) = local.temp1 + local.temp2;        \
    } while( 0 )

    for( i = 0; i < 8; i++ )
        local.A[i] = ctx->state[i];
 c058400:	4603      	mov	r3, r0
{
 c058402:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c058406:	460c      	mov	r4, r1
 c058408:	f5ad 7d43 	sub.w	sp, sp, #780	@ 0x30c
 c05840c:	900d      	str	r0, [sp, #52]	@ 0x34
        local.A[i] = ctx->state[i];
 c05840e:	3310      	adds	r3, #16
 c058410:	adb2      	add	r5, sp, #712	@ 0x2c8
 c058412:	f100 0650 	add.w	r6, r0, #80	@ 0x50
 c058416:	462a      	mov	r2, r5
 c058418:	6818      	ldr	r0, [r3, #0]
 c05841a:	6859      	ldr	r1, [r3, #4]
 c05841c:	3308      	adds	r3, #8
 c05841e:	c203      	stmia	r2!, {r0, r1}
 c058420:	42b3      	cmp	r3, r6
 c058422:	4615      	mov	r5, r2
 c058424:	d1f7      	bne.n	c058416 <mbedtls_internal_sha512_process+0x16>
 c058426:	4621      	mov	r1, r4
 c058428:	a810      	add	r0, sp, #64	@ 0x40
 c05842a:	3480      	adds	r4, #128	@ 0x80
        local.A[0] = local.temp1;
    }
#else /* MBEDTLS_SHA512_SMALLER */
    for( i = 0; i < 16; i++ )
    {
        local.W[i] = MBEDTLS_GET_UINT64_BE( data, i << 3 );
 c05842c:	784b      	ldrb	r3, [r1, #1]
 c05842e:	780a      	ldrb	r2, [r1, #0]
 c058430:	041b      	lsls	r3, r3, #16
 c058432:	790e      	ldrb	r6, [r1, #4]
 c058434:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 c058438:	79ca      	ldrb	r2, [r1, #7]
 c05843a:	788d      	ldrb	r5, [r1, #2]
 c05843c:	ea42 6206 	orr.w	r2, r2, r6, lsl #24
 c058440:	794e      	ldrb	r6, [r1, #5]
 c058442:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
 c058446:	ea42 4206 	orr.w	r2, r2, r6, lsl #16
 c05844a:	798e      	ldrb	r6, [r1, #6]
 c05844c:	78cd      	ldrb	r5, [r1, #3]
 c05844e:	ea42 2206 	orr.w	r2, r2, r6, lsl #8
    for( i = 0; i < 16; i++ )
 c058452:	3108      	adds	r1, #8
        local.W[i] = MBEDTLS_GET_UINT64_BE( data, i << 3 );
 c058454:	432b      	orrs	r3, r5
 c058456:	f840 2f08 	str.w	r2, [r0, #8]!
    for( i = 0; i < 16; i++ )
 c05845a:	428c      	cmp	r4, r1
        local.W[i] = MBEDTLS_GET_UINT64_BE( data, i << 3 );
 c05845c:	6043      	str	r3, [r0, #4]
    for( i = 0; i < 16; i++ )
 c05845e:	d1e5      	bne.n	c05842c <mbedtls_internal_sha512_process+0x2c>
 c058460:	2610      	movs	r6, #16
 c058462:	a912      	add	r1, sp, #72	@ 0x48
    }

    for( ; i < 80; i++ )
    {
        local.W[i] = S1(local.W[i -  2]) + local.W[i -  7] +
 c058464:	468c      	mov	ip, r1
 c058466:	e9d1 481c 	ldrd	r4, r8, [r1, #112]	@ 0x70
               S0(local.W[i - 15]) + local.W[i - 16];
 c05846a:	e9d1 0702 	ldrd	r0, r7, [r1, #8]
        local.W[i] = S1(local.W[i -  2]) + local.W[i -  7] +
 c05846e:	0ce3      	lsrs	r3, r4, #19
 c058470:	ea4f 0ec4 	mov.w	lr, r4, lsl #3
 c058474:	ea4f 42d8 	mov.w	r2, r8, lsr #19
 c058478:	ea4f 05c8 	mov.w	r5, r8, lsl #3
 c05847c:	ea45 7554 	orr.w	r5, r5, r4, lsr #29
 c058480:	ea42 3244 	orr.w	r2, r2, r4, lsl #13
 c058484:	ea4e 7e58 	orr.w	lr, lr, r8, lsr #29
 c058488:	ea43 3348 	orr.w	r3, r3, r8, lsl #13
 c05848c:	09a4      	lsrs	r4, r4, #6
 c05848e:	ea83 030e 	eor.w	r3, r3, lr
 c058492:	ea44 6488 	orr.w	r4, r4, r8, lsl #26
 c058496:	406a      	eors	r2, r5
 c058498:	4063      	eors	r3, r4
               S0(local.W[i - 15]) + local.W[i - 16];
 c05849a:	e9dc 4512 	ldrd	r4, r5, [ip, #72]	@ 0x48
 c05849e:	e9dc ec00 	ldrd	lr, ip, [ip]
 c0584a2:	eb14 040e 	adds.w	r4, r4, lr
 c0584a6:	eb45 050c 	adc.w	r5, r5, ip
        local.W[i] = S1(local.W[i -  2]) + local.W[i -  7] +
 c0584aa:	ea82 1298 	eor.w	r2, r2, r8, lsr #6
               S0(local.W[i - 15]) + local.W[i - 16];
 c0584ae:	191b      	adds	r3, r3, r4
 c0584b0:	eb42 0205 	adc.w	r2, r2, r5
 c0584b4:	0844      	lsrs	r4, r0, #1
 c0584b6:	ea4f 2e10 	mov.w	lr, r0, lsr #8
 c0584ba:	087d      	lsrs	r5, r7, #1
 c0584bc:	ea4f 2c17 	mov.w	ip, r7, lsr #8
 c0584c0:	ea45 75c0 	orr.w	r5, r5, r0, lsl #31
 c0584c4:	ea4c 6c00 	orr.w	ip, ip, r0, lsl #24
 c0584c8:	ea44 74c7 	orr.w	r4, r4, r7, lsl #31
 c0584cc:	ea4e 6e07 	orr.w	lr, lr, r7, lsl #24
 c0584d0:	09c0      	lsrs	r0, r0, #7
 c0584d2:	ea84 040e 	eor.w	r4, r4, lr
 c0584d6:	ea40 6047 	orr.w	r0, r0, r7, lsl #25
 c0584da:	4060      	eors	r0, r4
 c0584dc:	ea85 050c 	eor.w	r5, r5, ip
 c0584e0:	181b      	adds	r3, r3, r0
 c0584e2:	ea85 14d7 	eor.w	r4, r5, r7, lsr #7
    for( ; i < 80; i++ )
 c0584e6:	f106 0601 	add.w	r6, r6, #1
               S0(local.W[i - 15]) + local.W[i - 16];
 c0584ea:	eb42 0204 	adc.w	r2, r2, r4
 c0584ee:	3108      	adds	r1, #8
    for( ; i < 80; i++ )
 c0584f0:	2e50      	cmp	r6, #80	@ 0x50
        local.W[i] = S1(local.W[i -  2]) + local.W[i -  7] +
 c0584f2:	e9c1 321e 	strd	r3, r2, [r1, #120]	@ 0x78
    for( ; i < 80; i++ )
 c0584f6:	d1b5      	bne.n	c058464 <mbedtls_internal_sha512_process+0x64>
 c0584f8:	9bbe      	ldr	r3, [sp, #760]	@ 0x2f8
 c0584fa:	f8dd c2e4 	ldr.w	ip, [sp, #740]	@ 0x2e4
 c0584fe:	9306      	str	r3, [sp, #24]
 c058500:	9bbf      	ldr	r3, [sp, #764]	@ 0x2fc
 c058502:	f8df e030 	ldr.w	lr, [pc, #48]	@ c058534 <mbedtls_internal_sha512_process+0x134>
 c058506:	9307      	str	r3, [sp, #28]
 c058508:	9bbc      	ldr	r3, [sp, #752]	@ 0x2f0
 c05850a:	e9dd abc0 	ldrd	sl, fp, [sp, #768]	@ 0x300
 c05850e:	9308      	str	r3, [sp, #32]
 c058510:	9bbd      	ldr	r3, [sp, #756]	@ 0x2f4
 c058512:	e9dd 20ba 	ldrd	r2, r0, [sp, #744]	@ 0x2e8
 c058516:	9309      	str	r3, [sp, #36]	@ 0x24
 c058518:	9bb2      	ldr	r3, [sp, #712]	@ 0x2c8
 c05851a:	e9dd 89b6 	ldrd	r8, r9, [sp, #728]	@ 0x2d8
 c05851e:	9301      	str	r3, [sp, #4]
 c058520:	9bb3      	ldr	r3, [sp, #716]	@ 0x2cc
 c058522:	9302      	str	r3, [sp, #8]
 c058524:	9bb4      	ldr	r3, [sp, #720]	@ 0x2d0
 c058526:	9303      	str	r3, [sp, #12]
 c058528:	9bb5      	ldr	r3, [sp, #724]	@ 0x2d4
 c05852a:	9304      	str	r3, [sp, #16]
 c05852c:	9bb8      	ldr	r3, [sp, #736]	@ 0x2e0
 c05852e:	9305      	str	r3, [sp, #20]
 c058530:	ab0e      	add	r3, sp, #56	@ 0x38
 c058532:	e001      	b.n	c058538 <mbedtls_internal_sha512_process+0x138>
 c058534:	0c060ef8 	.word	0x0c060ef8
    }

    i = 0;
    do
    {
        P( local.A[0], local.A[1], local.A[2], local.A[3], local.A[4],
 c058538:	0b94      	lsrs	r4, r2, #14
 c05853a:	0c95      	lsrs	r5, r2, #18
 c05853c:	ea44 4780 	orr.w	r7, r4, r0, lsl #18
 c058540:	ea45 3580 	orr.w	r5, r5, r0, lsl #14
 c058544:	0b84      	lsrs	r4, r0, #14
 c058546:	ea44 4682 	orr.w	r6, r4, r2, lsl #18
 c05854a:	406f      	eors	r7, r5
 c05854c:	0c84      	lsrs	r4, r0, #18
 c05854e:	05d5      	lsls	r5, r2, #23
 c058550:	ea44 3482 	orr.w	r4, r4, r2, lsl #14
 c058554:	ea45 2550 	orr.w	r5, r5, r0, lsr #9
 c058558:	406f      	eors	r7, r5
 c05855a:	4066      	eors	r6, r4
 c05855c:	f8de 5000 	ldr.w	r5, [lr]
 c058560:	05c4      	lsls	r4, r0, #23
 c058562:	ea44 2452 	orr.w	r4, r4, r2, lsr #9
 c058566:	4066      	eors	r6, r4
 c058568:	e9d3 1404 	ldrd	r1, r4, [r3, #16]
 c05856c:	186d      	adds	r5, r5, r1
 c05856e:	f8de 1004 	ldr.w	r1, [lr, #4]
 c058572:	eb41 0404 	adc.w	r4, r1, r4
 c058576:	197d      	adds	r5, r7, r5
 c058578:	9906      	ldr	r1, [sp, #24]
 c05857a:	eb46 0404 	adc.w	r4, r6, r4
 c05857e:	9e08      	ldr	r6, [sp, #32]
 c058580:	9f09      	ldr	r7, [sp, #36]	@ 0x24
 c058582:	404e      	eors	r6, r1
 c058584:	9907      	ldr	r1, [sp, #28]
 c058586:	4016      	ands	r6, r2
 c058588:	404f      	eors	r7, r1
 c05858a:	9906      	ldr	r1, [sp, #24]
 c05858c:	4007      	ands	r7, r0
 c05858e:	404e      	eors	r6, r1
 c058590:	9907      	ldr	r1, [sp, #28]
 c058592:	19ad      	adds	r5, r5, r6
 c058594:	ea87 0701 	eor.w	r7, r7, r1
 c058598:	9905      	ldr	r1, [sp, #20]
 c05859a:	eb44 0407 	adc.w	r4, r4, r7
 c05859e:	eb15 050a 	adds.w	r5, r5, sl
 c0585a2:	eb4b 0404 	adc.w	r4, fp, r4
 c0585a6:	1949      	adds	r1, r1, r5
 c0585a8:	9105      	str	r1, [sp, #20]
 c0585aa:	eb4c 0104 	adc.w	r1, ip, r4
 c0585ae:	910a      	str	r1, [sp, #40]	@ 0x28
 c0585b0:	9901      	ldr	r1, [sp, #4]
 c0585b2:	f8dd c004 	ldr.w	ip, [sp, #4]
 c0585b6:	0f0f      	lsrs	r7, r1, #28
 c0585b8:	9902      	ldr	r1, [sp, #8]
 c0585ba:	f8dd a008 	ldr.w	sl, [sp, #8]
 c0585be:	ea47 1701 	orr.w	r7, r7, r1, lsl #4
 c0585c2:	0f0e      	lsrs	r6, r1, #28
 c0585c4:	9901      	ldr	r1, [sp, #4]
 c0585c6:	ea46 1601 	orr.w	r6, r6, r1, lsl #4
 c0585ca:	9902      	ldr	r1, [sp, #8]
 c0585cc:	0789      	lsls	r1, r1, #30
 c0585ce:	ea41 019c 	orr.w	r1, r1, ip, lsr #2
 c0585d2:	ea4f 7c8c 	mov.w	ip, ip, lsl #30
 c0585d6:	ea4c 0c9a 	orr.w	ip, ip, sl, lsr #2
 c0585da:	404e      	eors	r6, r1
 c0585dc:	9901      	ldr	r1, [sp, #4]
 c0585de:	ea87 070c 	eor.w	r7, r7, ip
 c0585e2:	ea4f 6c4a 	mov.w	ip, sl, lsl #25
 c0585e6:	ea4c 1cd1 	orr.w	ip, ip, r1, lsr #7
 c0585ea:	0649      	lsls	r1, r1, #25
 c0585ec:	ea41 11da 	orr.w	r1, r1, sl, lsr #7
 c0585f0:	4079      	eors	r1, r7
 c0585f2:	1949      	adds	r1, r1, r5
 c0585f4:	ea86 060c 	eor.w	r6, r6, ip
 c0585f8:	eb44 0606 	adc.w	r6, r4, r6
 c0585fc:	9d03      	ldr	r5, [sp, #12]
 c0585fe:	9c01      	ldr	r4, [sp, #4]
 c058600:	9f04      	ldr	r7, [sp, #16]
 c058602:	432c      	orrs	r4, r5
 c058604:	4655      	mov	r5, sl
 c058606:	f8dd c00c 	ldr.w	ip, [sp, #12]
 c05860a:	433d      	orrs	r5, r7
 c05860c:	9f01      	ldr	r7, [sp, #4]
 c05860e:	ea04 0408 	and.w	r4, r4, r8
 c058612:	ea07 0c0c 	and.w	ip, r7, ip
 c058616:	4657      	mov	r7, sl
 c058618:	f8dd a010 	ldr.w	sl, [sp, #16]
 c05861c:	ea44 040c 	orr.w	r4, r4, ip
 c058620:	ea07 070a 	and.w	r7, r7, sl
 c058624:	ea05 0509 	and.w	r5, r5, r9
 c058628:	eb11 0a04 	adds.w	sl, r1, r4
 c05862c:	ea45 0507 	orr.w	r5, r5, r7
 c058630:	eb46 0b05 	adc.w	fp, r6, r5
           local.A[5], local.A[6], local.A[7], local.W[i], K[i] ); i++;
        P( local.A[7], local.A[0], local.A[1], local.A[2], local.A[3],
 c058634:	e9de 1602 	ldrd	r1, r6, [lr, #8]
 c058638:	e9d3 5406 	ldrd	r5, r4, [r3, #24]
 c05863c:	1949      	adds	r1, r1, r5
 c05863e:	9d06      	ldr	r5, [sp, #24]
 c058640:	eb46 0404 	adc.w	r4, r6, r4
 c058644:	1949      	adds	r1, r1, r5
 c058646:	9d07      	ldr	r5, [sp, #28]
 c058648:	eb45 0404 	adc.w	r4, r5, r4
 c05864c:	9d08      	ldr	r5, [sp, #32]
 c05864e:	9f05      	ldr	r7, [sp, #20]
 c058650:	ea82 0605 	eor.w	r6, r2, r5
 c058654:	9d09      	ldr	r5, [sp, #36]	@ 0x24
 c058656:	403e      	ands	r6, r7
 c058658:	9f0a      	ldr	r7, [sp, #40]	@ 0x28
 c05865a:	4045      	eors	r5, r0
 c05865c:	403d      	ands	r5, r7
 c05865e:	9f08      	ldr	r7, [sp, #32]
 c058660:	407e      	eors	r6, r7
 c058662:	9f09      	ldr	r7, [sp, #36]	@ 0x24
 c058664:	1989      	adds	r1, r1, r6
 c058666:	ea85 0507 	eor.w	r5, r5, r7
 c05866a:	eb44 0405 	adc.w	r4, r4, r5
 c05866e:	9d05      	ldr	r5, [sp, #20]
 c058670:	9e0a      	ldr	r6, [sp, #40]	@ 0x28
 c058672:	0bad      	lsrs	r5, r5, #14
 c058674:	ea45 4586 	orr.w	r5, r5, r6, lsl #18
 c058678:	0bb7      	lsrs	r7, r6, #14
 c05867a:	9e05      	ldr	r6, [sp, #20]
 c05867c:	9106      	str	r1, [sp, #24]
 c05867e:	ea47 4786 	orr.w	r7, r7, r6, lsl #18
 c058682:	ea4f 4c96 	mov.w	ip, r6, lsr #18
 c058686:	9e0a      	ldr	r6, [sp, #40]	@ 0x28
 c058688:	9905      	ldr	r1, [sp, #20]
 c05868a:	ea4c 3c86 	orr.w	ip, ip, r6, lsl #14
 c05868e:	0cb6      	lsrs	r6, r6, #18
 c058690:	ea46 3681 	orr.w	r6, r6, r1, lsl #14
 c058694:	4077      	eors	r7, r6
 c058696:	9e0a      	ldr	r6, [sp, #40]	@ 0x28
 c058698:	ea85 050c 	eor.w	r5, r5, ip
 c05869c:	05f6      	lsls	r6, r6, #23
 c05869e:	ea46 2651 	orr.w	r6, r6, r1, lsr #9
 c0586a2:	ea4f 5cc1 	mov.w	ip, r1, lsl #23
 c0586a6:	990a      	ldr	r1, [sp, #40]	@ 0x28
 c0586a8:	407e      	eors	r6, r7
 c0586aa:	ea4c 2c51 	orr.w	ip, ip, r1, lsr #9
 c0586ae:	9906      	ldr	r1, [sp, #24]
 c0586b0:	ea85 050c 	eor.w	r5, r5, ip
 c0586b4:	194d      	adds	r5, r1, r5
 c0586b6:	eb44 0606 	adc.w	r6, r4, r6
 c0586ba:	eb18 0105 	adds.w	r1, r8, r5
 c0586be:	9106      	str	r1, [sp, #24]
 c0586c0:	eb49 0106 	adc.w	r1, r9, r6
 c0586c4:	9107      	str	r1, [sp, #28]
 c0586c6:	ea4f 741b 	mov.w	r4, fp, lsr #28
 c0586ca:	ea4f 718b 	mov.w	r1, fp, lsl #30
 c0586ce:	ea41 019a 	orr.w	r1, r1, sl, lsr #2
 c0586d2:	ea4f 771a 	mov.w	r7, sl, lsr #28
 c0586d6:	ea44 140a 	orr.w	r4, r4, sl, lsl #4
 c0586da:	ea4f 7c8a 	mov.w	ip, sl, lsl #30
 c0586de:	ea4c 0c9b 	orr.w	ip, ip, fp, lsr #2
 c0586e2:	ea47 170b 	orr.w	r7, r7, fp, lsl #4
 c0586e6:	404c      	eors	r4, r1
 c0586e8:	ea4f 614a 	mov.w	r1, sl, lsl #25
 c0586ec:	ea87 070c 	eor.w	r7, r7, ip
 c0586f0:	ea41 11db 	orr.w	r1, r1, fp, lsr #7
 c0586f4:	4079      	eors	r1, r7
 c0586f6:	ea4f 6c4b 	mov.w	ip, fp, lsl #25
 c0586fa:	194d      	adds	r5, r1, r5
 c0586fc:	ea4c 1cda 	orr.w	ip, ip, sl, lsr #7
 c058700:	9901      	ldr	r1, [sp, #4]
 c058702:	9f03      	ldr	r7, [sp, #12]
 c058704:	ea84 040c 	eor.w	r4, r4, ip
 c058708:	eb46 0404 	adc.w	r4, r6, r4
 c05870c:	ea41 010a 	orr.w	r1, r1, sl
 c058710:	9e02      	ldr	r6, [sp, #8]
 c058712:	4039      	ands	r1, r7
 c058714:	9f04      	ldr	r7, [sp, #16]
 c058716:	ea46 060b 	orr.w	r6, r6, fp
 c05871a:	403e      	ands	r6, r7
 c05871c:	9f01      	ldr	r7, [sp, #4]
 c05871e:	ea07 0c0a 	and.w	ip, r7, sl
 c058722:	9f02      	ldr	r7, [sp, #8]
 c058724:	ea41 010c 	orr.w	r1, r1, ip
 c058728:	ea07 070b 	and.w	r7, r7, fp
 c05872c:	eb15 0801 	adds.w	r8, r5, r1
 c058730:	ea46 0607 	orr.w	r6, r6, r7
 c058734:	eb44 0906 	adc.w	r9, r4, r6
           local.A[4], local.A[5], local.A[6], local.W[i], K[i] ); i++;
        P( local.A[6], local.A[7], local.A[0], local.A[1], local.A[2],
 c058738:	e9d3 5608 	ldrd	r5, r6, [r3, #32]
 c05873c:	e9de 1404 	ldrd	r1, r4, [lr, #16]
 c058740:	1949      	adds	r1, r1, r5
 c058742:	9d08      	ldr	r5, [sp, #32]
 c058744:	eb44 0406 	adc.w	r4, r4, r6
 c058748:	1949      	adds	r1, r1, r5
 c05874a:	9d09      	ldr	r5, [sp, #36]	@ 0x24
 c05874c:	9f06      	ldr	r7, [sp, #24]
 c05874e:	eb45 0404 	adc.w	r4, r5, r4
 c058752:	9d05      	ldr	r5, [sp, #20]
 c058754:	ea82 0605 	eor.w	r6, r2, r5
 c058758:	9d0a      	ldr	r5, [sp, #40]	@ 0x28
 c05875a:	403e      	ands	r6, r7
 c05875c:	9f07      	ldr	r7, [sp, #28]
 c05875e:	4045      	eors	r5, r0
 c058760:	4056      	eors	r6, r2
 c058762:	403d      	ands	r5, r7
 c058764:	1989      	adds	r1, r1, r6
 c058766:	ea85 0500 	eor.w	r5, r5, r0
 c05876a:	eb44 0405 	adc.w	r4, r4, r5
 c05876e:	9d06      	ldr	r5, [sp, #24]
 c058770:	9e06      	ldr	r6, [sp, #24]
 c058772:	0bad      	lsrs	r5, r5, #14
 c058774:	ea45 4587 	orr.w	r5, r5, r7, lsl #18
 c058778:	0bbf      	lsrs	r7, r7, #14
 c05877a:	ea47 4786 	orr.w	r7, r7, r6, lsl #18
 c05877e:	ea4f 4c96 	mov.w	ip, r6, lsr #18
 c058782:	9e07      	ldr	r6, [sp, #28]
 c058784:	9108      	str	r1, [sp, #32]
 c058786:	9906      	ldr	r1, [sp, #24]
 c058788:	ea4c 3c86 	orr.w	ip, ip, r6, lsl #14
 c05878c:	0cb6      	lsrs	r6, r6, #18
 c05878e:	ea46 3681 	orr.w	r6, r6, r1, lsl #14
 c058792:	4077      	eors	r7, r6
 c058794:	9e07      	ldr	r6, [sp, #28]
 c058796:	ea85 050c 	eor.w	r5, r5, ip
 c05879a:	05f6      	lsls	r6, r6, #23
 c05879c:	ea46 2651 	orr.w	r6, r6, r1, lsr #9
 c0587a0:	ea4f 5cc1 	mov.w	ip, r1, lsl #23
 c0587a4:	9907      	ldr	r1, [sp, #28]
 c0587a6:	407e      	eors	r6, r7
 c0587a8:	ea4c 2c51 	orr.w	ip, ip, r1, lsr #9
 c0587ac:	9908      	ldr	r1, [sp, #32]
 c0587ae:	ea85 050c 	eor.w	r5, r5, ip
 c0587b2:	194d      	adds	r5, r1, r5
 c0587b4:	9903      	ldr	r1, [sp, #12]
 c0587b6:	eb44 0606 	adc.w	r6, r4, r6
 c0587ba:	1949      	adds	r1, r1, r5
 c0587bc:	9108      	str	r1, [sp, #32]
 c0587be:	9904      	ldr	r1, [sp, #16]
 c0587c0:	ea4f 7419 	mov.w	r4, r9, lsr #28
 c0587c4:	eb41 0106 	adc.w	r1, r1, r6
 c0587c8:	9109      	str	r1, [sp, #36]	@ 0x24
 c0587ca:	ea4f 7189 	mov.w	r1, r9, lsl #30
 c0587ce:	ea41 0198 	orr.w	r1, r1, r8, lsr #2
 c0587d2:	ea4f 7718 	mov.w	r7, r8, lsr #28
 c0587d6:	ea44 1408 	orr.w	r4, r4, r8, lsl #4
 c0587da:	ea4f 7c88 	mov.w	ip, r8, lsl #30
 c0587de:	ea4c 0c99 	orr.w	ip, ip, r9, lsr #2
 c0587e2:	ea47 1709 	orr.w	r7, r7, r9, lsl #4
 c0587e6:	404c      	eors	r4, r1
 c0587e8:	ea4f 6148 	mov.w	r1, r8, lsl #25
 c0587ec:	ea87 070c 	eor.w	r7, r7, ip
 c0587f0:	ea41 11d9 	orr.w	r1, r1, r9, lsr #7
 c0587f4:	4079      	eors	r1, r7
 c0587f6:	ea4f 6c49 	mov.w	ip, r9, lsl #25
 c0587fa:	9f01      	ldr	r7, [sp, #4]
 c0587fc:	194d      	adds	r5, r1, r5
 c0587fe:	ea4c 1cd8 	orr.w	ip, ip, r8, lsr #7
 c058802:	ea4a 0108 	orr.w	r1, sl, r8
 c058806:	ea84 040c 	eor.w	r4, r4, ip
 c05880a:	ea01 0107 	and.w	r1, r1, r7
 c05880e:	9f02      	ldr	r7, [sp, #8]
 c058810:	eb46 0404 	adc.w	r4, r6, r4
 c058814:	ea0a 0c08 	and.w	ip, sl, r8
 c058818:	ea4b 0609 	orr.w	r6, fp, r9
 c05881c:	403e      	ands	r6, r7
 c05881e:	ea41 010c 	orr.w	r1, r1, ip
 c058822:	ea0b 0709 	and.w	r7, fp, r9
 c058826:	1869      	adds	r1, r5, r1
 c058828:	ea46 0607 	orr.w	r6, r6, r7
 c05882c:	9103      	str	r1, [sp, #12]
 c05882e:	eb44 0106 	adc.w	r1, r4, r6
 c058832:	9104      	str	r1, [sp, #16]
           local.A[3], local.A[4], local.A[5], local.W[i], K[i] ); i++;
        P( local.A[5], local.A[6], local.A[7], local.A[0], local.A[1],
 c058834:	e9d3 540a 	ldrd	r5, r4, [r3, #40]	@ 0x28
 c058838:	e9de 1606 	ldrd	r1, r6, [lr, #24]
 c05883c:	1949      	adds	r1, r1, r5
 c05883e:	eb46 0404 	adc.w	r4, r6, r4
 c058842:	1889      	adds	r1, r1, r2
 c058844:	9d07      	ldr	r5, [sp, #28]
 c058846:	eb40 0404 	adc.w	r4, r0, r4
 c05884a:	e9dd 2005 	ldrd	r2, r0, [sp, #20]
 c05884e:	4050      	eors	r0, r2
 c058850:	9a0a      	ldr	r2, [sp, #40]	@ 0x28
 c058852:	406a      	eors	r2, r5
 c058854:	9d08      	ldr	r5, [sp, #32]
 c058856:	4028      	ands	r0, r5
 c058858:	9d09      	ldr	r5, [sp, #36]	@ 0x24
 c05885a:	402a      	ands	r2, r5
 c05885c:	9d05      	ldr	r5, [sp, #20]
 c05885e:	4068      	eors	r0, r5
 c058860:	9d0a      	ldr	r5, [sp, #40]	@ 0x28
 c058862:	1809      	adds	r1, r1, r0
 c058864:	ea82 0205 	eor.w	r2, r2, r5
 c058868:	eb44 0402 	adc.w	r4, r4, r2
 c05886c:	9a08      	ldr	r2, [sp, #32]
 c05886e:	9809      	ldr	r0, [sp, #36]	@ 0x24
 c058870:	0b92      	lsrs	r2, r2, #14
 c058872:	ea42 4280 	orr.w	r2, r2, r0, lsl #18
 c058876:	0b85      	lsrs	r5, r0, #14
 c058878:	9808      	ldr	r0, [sp, #32]
 c05887a:	ea45 4580 	orr.w	r5, r5, r0, lsl #18
 c05887e:	0c86      	lsrs	r6, r0, #18
 c058880:	9809      	ldr	r0, [sp, #36]	@ 0x24
 c058882:	9f08      	ldr	r7, [sp, #32]
 c058884:	ea46 3680 	orr.w	r6, r6, r0, lsl #14
 c058888:	0c80      	lsrs	r0, r0, #18
 c05888a:	ea40 3087 	orr.w	r0, r0, r7, lsl #14
 c05888e:	4045      	eors	r5, r0
 c058890:	9809      	ldr	r0, [sp, #36]	@ 0x24
 c058892:	4072      	eors	r2, r6
 c058894:	05c0      	lsls	r0, r0, #23
 c058896:	ea40 2057 	orr.w	r0, r0, r7, lsr #9
 c05889a:	05fe      	lsls	r6, r7, #23
 c05889c:	9f09      	ldr	r7, [sp, #36]	@ 0x24
 c05889e:	4068      	eors	r0, r5
 c0588a0:	ea46 2657 	orr.w	r6, r6, r7, lsr #9
 c0588a4:	4072      	eors	r2, r6
 c0588a6:	188a      	adds	r2, r1, r2
 c0588a8:	9901      	ldr	r1, [sp, #4]
 c0588aa:	eb44 0000 	adc.w	r0, r4, r0
 c0588ae:	1889      	adds	r1, r1, r2
 c0588b0:	910b      	str	r1, [sp, #44]	@ 0x2c
 c0588b2:	9902      	ldr	r1, [sp, #8]
 c0588b4:	9e03      	ldr	r6, [sp, #12]
 c0588b6:	eb41 0100 	adc.w	r1, r1, r0
 c0588ba:	910c      	str	r1, [sp, #48]	@ 0x30
 c0588bc:	9903      	ldr	r1, [sp, #12]
 c0588be:	9f04      	ldr	r7, [sp, #16]
 c0588c0:	0f0d      	lsrs	r5, r1, #28
 c0588c2:	9904      	ldr	r1, [sp, #16]
 c0588c4:	ea45 1501 	orr.w	r5, r5, r1, lsl #4
 c0588c8:	0f0c      	lsrs	r4, r1, #28
 c0588ca:	9903      	ldr	r1, [sp, #12]
 c0588cc:	ea44 1401 	orr.w	r4, r4, r1, lsl #4
 c0588d0:	9904      	ldr	r1, [sp, #16]
 c0588d2:	0789      	lsls	r1, r1, #30
 c0588d4:	ea41 0196 	orr.w	r1, r1, r6, lsr #2
 c0588d8:	07b6      	lsls	r6, r6, #30
 c0588da:	ea46 0697 	orr.w	r6, r6, r7, lsr #2
 c0588de:	404c      	eors	r4, r1
 c0588e0:	9903      	ldr	r1, [sp, #12]
 c0588e2:	4075      	eors	r5, r6
 c0588e4:	067e      	lsls	r6, r7, #25
 c0588e6:	ea46 16d1 	orr.w	r6, r6, r1, lsr #7
 c0588ea:	0649      	lsls	r1, r1, #25
 c0588ec:	ea41 11d7 	orr.w	r1, r1, r7, lsr #7
 c0588f0:	4069      	eors	r1, r5
 c0588f2:	188a      	adds	r2, r1, r2
 c0588f4:	9903      	ldr	r1, [sp, #12]
 c0588f6:	9d03      	ldr	r5, [sp, #12]
 c0588f8:	ea84 0406 	eor.w	r4, r4, r6
 c0588fc:	ea48 0101 	orr.w	r1, r8, r1
 c058900:	eb40 0404 	adc.w	r4, r0, r4
 c058904:	ea08 0605 	and.w	r6, r8, r5
 c058908:	ea49 0007 	orr.w	r0, r9, r7
 c05890c:	ea01 010a 	and.w	r1, r1, sl
 c058910:	ea09 0507 	and.w	r5, r9, r7
 c058914:	4331      	orrs	r1, r6
 c058916:	ea00 000b 	and.w	r0, r0, fp
 c05891a:	1852      	adds	r2, r2, r1
 c05891c:	ea40 0005 	orr.w	r0, r0, r5
 c058920:	9201      	str	r2, [sp, #4]
 c058922:	eb44 0200 	adc.w	r2, r4, r0
 c058926:	9202      	str	r2, [sp, #8]
           local.A[2], local.A[3], local.A[4], local.W[i], K[i] ); i++;
        P( local.A[4], local.A[5], local.A[6], local.A[7], local.A[0],
 c058928:	e9d3 010c 	ldrd	r0, r1, [r3, #48]	@ 0x30
 c05892c:	e9de 2408 	ldrd	r2, r4, [lr, #32]
 c058930:	1812      	adds	r2, r2, r0
 c058932:	9805      	ldr	r0, [sp, #20]
 c058934:	eb44 0101 	adc.w	r1, r4, r1
 c058938:	1812      	adds	r2, r2, r0
 c05893a:	980a      	ldr	r0, [sp, #40]	@ 0x28
 c05893c:	9c08      	ldr	r4, [sp, #32]
 c05893e:	eb40 0101 	adc.w	r1, r0, r1
 c058942:	9806      	ldr	r0, [sp, #24]
 c058944:	9d09      	ldr	r5, [sp, #36]	@ 0x24
 c058946:	4044      	eors	r4, r0
 c058948:	9807      	ldr	r0, [sp, #28]
 c05894a:	4068      	eors	r0, r5
 c05894c:	9d0b      	ldr	r5, [sp, #44]	@ 0x2c
 c05894e:	402c      	ands	r4, r5
 c058950:	9d0c      	ldr	r5, [sp, #48]	@ 0x30
 c058952:	4028      	ands	r0, r5
 c058954:	9d06      	ldr	r5, [sp, #24]
 c058956:	406c      	eors	r4, r5
 c058958:	9d07      	ldr	r5, [sp, #28]
 c05895a:	1912      	adds	r2, r2, r4
 c05895c:	ea80 0005 	eor.w	r0, r0, r5
 c058960:	eb41 0100 	adc.w	r1, r1, r0
 c058964:	980b      	ldr	r0, [sp, #44]	@ 0x2c
 c058966:	9f0b      	ldr	r7, [sp, #44]	@ 0x2c
 c058968:	0b85      	lsrs	r5, r0, #14
 c05896a:	980c      	ldr	r0, [sp, #48]	@ 0x30
 c05896c:	ea45 4580 	orr.w	r5, r5, r0, lsl #18
 c058970:	0b84      	lsrs	r4, r0, #14
 c058972:	980b      	ldr	r0, [sp, #44]	@ 0x2c
 c058974:	ea44 4480 	orr.w	r4, r4, r0, lsl #18
 c058978:	0c86      	lsrs	r6, r0, #18
 c05897a:	980c      	ldr	r0, [sp, #48]	@ 0x30
 c05897c:	ea46 3680 	orr.w	r6, r6, r0, lsl #14
 c058980:	0c80      	lsrs	r0, r0, #18
 c058982:	ea40 3087 	orr.w	r0, r0, r7, lsl #14
 c058986:	4044      	eors	r4, r0
 c058988:	980c      	ldr	r0, [sp, #48]	@ 0x30
 c05898a:	4075      	eors	r5, r6
 c05898c:	05c6      	lsls	r6, r0, #23
 c05898e:	ea46 2657 	orr.w	r6, r6, r7, lsr #9
 c058992:	05f8      	lsls	r0, r7, #23
 c058994:	9f0c      	ldr	r7, [sp, #48]	@ 0x30
 c058996:	4074      	eors	r4, r6
 c058998:	ea40 2057 	orr.w	r0, r0, r7, lsr #9
 c05899c:	4068      	eors	r0, r5
 c05899e:	1810      	adds	r0, r2, r0
 c0589a0:	9a01      	ldr	r2, [sp, #4]
 c0589a2:	eb41 0404 	adc.w	r4, r1, r4
 c0589a6:	9902      	ldr	r1, [sp, #8]
 c0589a8:	0f12      	lsrs	r2, r2, #28
 c0589aa:	ea42 1201 	orr.w	r2, r2, r1, lsl #4
 c0589ae:	ea4f 7c11 	mov.w	ip, r1, lsr #28
 c0589b2:	9901      	ldr	r1, [sp, #4]
 c0589b4:	9d01      	ldr	r5, [sp, #4]
 c0589b6:	ea4c 1c01 	orr.w	ip, ip, r1, lsl #4
 c0589ba:	9902      	ldr	r1, [sp, #8]
 c0589bc:	9e02      	ldr	r6, [sp, #8]
 c0589be:	0789      	lsls	r1, r1, #30
 c0589c0:	ea41 0195 	orr.w	r1, r1, r5, lsr #2
 c0589c4:	07ad      	lsls	r5, r5, #30
 c0589c6:	ea45 0596 	orr.w	r5, r5, r6, lsr #2
 c0589ca:	ea8c 0c01 	eor.w	ip, ip, r1
 c0589ce:	9901      	ldr	r1, [sp, #4]
 c0589d0:	406a      	eors	r2, r5
 c0589d2:	0675      	lsls	r5, r6, #25
 c0589d4:	ea45 15d1 	orr.w	r5, r5, r1, lsr #7
 c0589d8:	0649      	lsls	r1, r1, #25
 c0589da:	ea41 11d6 	orr.w	r1, r1, r6, lsr #7
 c0589de:	eb1a 0a00 	adds.w	sl, sl, r0
 c0589e2:	ea81 0102 	eor.w	r1, r1, r2
 c0589e6:	eb4b 0b04 	adc.w	fp, fp, r4
 c0589ea:	9a03      	ldr	r2, [sp, #12]
 c0589ec:	1809      	adds	r1, r1, r0
 c0589ee:	9801      	ldr	r0, [sp, #4]
 c0589f0:	ea8c 0c05 	eor.w	ip, ip, r5
 c0589f4:	eb44 0c0c 	adc.w	ip, r4, ip
 c0589f8:	9d01      	ldr	r5, [sp, #4]
 c0589fa:	ea42 0400 	orr.w	r4, r2, r0
 c0589fe:	9803      	ldr	r0, [sp, #12]
 c058a00:	9a04      	ldr	r2, [sp, #16]
 c058a02:	ea04 0408 	and.w	r4, r4, r8
 c058a06:	4028      	ands	r0, r5
 c058a08:	9d04      	ldr	r5, [sp, #16]
 c058a0a:	4332      	orrs	r2, r6
 c058a0c:	4320      	orrs	r0, r4
 c058a0e:	1809      	adds	r1, r1, r0
 c058a10:	ea05 0506 	and.w	r5, r5, r6
 c058a14:	ea02 0209 	and.w	r2, r2, r9
 c058a18:	ea42 0205 	orr.w	r2, r2, r5
 c058a1c:	9105      	str	r1, [sp, #20]
           local.A[1], local.A[2], local.A[3], local.W[i], K[i] ); i++;
        P( local.A[3], local.A[4], local.A[5], local.A[6], local.A[7],
 c058a1e:	9906      	ldr	r1, [sp, #24]
        P( local.A[4], local.A[5], local.A[6], local.A[7], local.A[0],
 c058a20:	eb4c 0c02 	adc.w	ip, ip, r2
        P( local.A[3], local.A[4], local.A[5], local.A[6], local.A[7],
 c058a24:	e9d3 400e 	ldrd	r4, r0, [r3, #56]	@ 0x38
 c058a28:	e9de 250a 	ldrd	r2, r5, [lr, #40]	@ 0x28
 c058a2c:	1912      	adds	r2, r2, r4
 c058a2e:	eb45 0000 	adc.w	r0, r5, r0
 c058a32:	1852      	adds	r2, r2, r1
 c058a34:	9907      	ldr	r1, [sp, #28]
 c058a36:	9c0b      	ldr	r4, [sp, #44]	@ 0x2c
 c058a38:	eb41 0000 	adc.w	r0, r1, r0
 c058a3c:	9908      	ldr	r1, [sp, #32]
 c058a3e:	ea4f 369a 	mov.w	r6, sl, lsr #14
 c058a42:	ea81 0504 	eor.w	r5, r1, r4
 c058a46:	9909      	ldr	r1, [sp, #36]	@ 0x24
 c058a48:	ea05 050a 	and.w	r5, r5, sl
 c058a4c:	ea81 0407 	eor.w	r4, r1, r7
 c058a50:	9908      	ldr	r1, [sp, #32]
 c058a52:	ea04 040b 	and.w	r4, r4, fp
 c058a56:	404d      	eors	r5, r1
 c058a58:	9909      	ldr	r1, [sp, #36]	@ 0x24
 c058a5a:	1952      	adds	r2, r2, r5
 c058a5c:	ea84 0401 	eor.w	r4, r4, r1
 c058a60:	eb40 0004 	adc.w	r0, r0, r4
 c058a64:	ea4f 459b 	mov.w	r5, fp, lsr #18
 c058a68:	ea4f 349b 	mov.w	r4, fp, lsr #14
 c058a6c:	ea45 358a 	orr.w	r5, r5, sl, lsl #14
 c058a70:	ea44 448a 	orr.w	r4, r4, sl, lsl #18
 c058a74:	ea4f 479a 	mov.w	r7, sl, lsr #18
 c058a78:	ea47 378b 	orr.w	r7, r7, fp, lsl #14
 c058a7c:	406c      	eors	r4, r5
 c058a7e:	ea46 468b 	orr.w	r6, r6, fp, lsl #18
 c058a82:	ea4f 55ca 	mov.w	r5, sl, lsl #23
 c058a86:	407e      	eors	r6, r7
 c058a88:	ea45 255b 	orr.w	r5, r5, fp, lsr #9
 c058a8c:	ea4f 57cb 	mov.w	r7, fp, lsl #23
 c058a90:	4075      	eors	r5, r6
 c058a92:	ea47 275a 	orr.w	r7, r7, sl, lsr #9
 c058a96:	1952      	adds	r2, r2, r5
 c058a98:	ea84 0407 	eor.w	r4, r4, r7
 c058a9c:	eb40 0004 	adc.w	r0, r0, r4
 c058aa0:	eb18 0102 	adds.w	r1, r8, r2
 c058aa4:	9106      	str	r1, [sp, #24]
 c058aa6:	eb49 0100 	adc.w	r1, r9, r0
 c058aaa:	9107      	str	r1, [sp, #28]
 c058aac:	9905      	ldr	r1, [sp, #20]
 c058aae:	ea4f 751c 	mov.w	r5, ip, lsr #28
 c058ab2:	ea4f 748c 	mov.w	r4, ip, lsl #30
 c058ab6:	ea44 0491 	orr.w	r4, r4, r1, lsr #2
 c058aba:	0f0e      	lsrs	r6, r1, #28
 c058abc:	ea45 1501 	orr.w	r5, r5, r1, lsl #4
 c058ac0:	078f      	lsls	r7, r1, #30
 c058ac2:	ea47 079c 	orr.w	r7, r7, ip, lsr #2
 c058ac6:	4065      	eors	r5, r4
 c058ac8:	ea46 160c 	orr.w	r6, r6, ip, lsl #4
 c058acc:	064c      	lsls	r4, r1, #25
 c058ace:	407e      	eors	r6, r7
 c058ad0:	ea44 14dc 	orr.w	r4, r4, ip, lsr #7
 c058ad4:	ea4f 674c 	mov.w	r7, ip, lsl #25
 c058ad8:	ea47 17d1 	orr.w	r7, r7, r1, lsr #7
 c058adc:	4074      	eors	r4, r6
 c058ade:	18a2      	adds	r2, r4, r2
 c058ae0:	ea85 0507 	eor.w	r5, r5, r7
 c058ae4:	eb40 0505 	adc.w	r5, r0, r5
 c058ae8:	9901      	ldr	r1, [sp, #4]
 c058aea:	9805      	ldr	r0, [sp, #20]
 c058aec:	9c05      	ldr	r4, [sp, #20]
 c058aee:	ea41 0600 	orr.w	r6, r1, r0
 c058af2:	9902      	ldr	r1, [sp, #8]
 c058af4:	ea41 000c 	orr.w	r0, r1, ip
 c058af8:	9903      	ldr	r1, [sp, #12]
 c058afa:	400e      	ands	r6, r1
 c058afc:	9904      	ldr	r1, [sp, #16]
 c058afe:	4008      	ands	r0, r1
 c058b00:	9901      	ldr	r1, [sp, #4]
 c058b02:	400c      	ands	r4, r1
 c058b04:	9902      	ldr	r1, [sp, #8]
 c058b06:	4334      	orrs	r4, r6
 c058b08:	ea01 070c 	and.w	r7, r1, ip
 c058b0c:	eb12 0804 	adds.w	r8, r2, r4
           local.A[0], local.A[1], local.A[2], local.W[i], K[i] ); i++;
        P( local.A[2], local.A[3], local.A[4], local.A[5], local.A[6],
 c058b10:	9908      	ldr	r1, [sp, #32]
        P( local.A[3], local.A[4], local.A[5], local.A[6], local.A[7],
 c058b12:	ea40 0007 	orr.w	r0, r0, r7
 c058b16:	eb45 0900 	adc.w	r9, r5, r0
        P( local.A[2], local.A[3], local.A[4], local.A[5], local.A[6],
 c058b1a:	e9d3 4510 	ldrd	r4, r5, [r3, #64]	@ 0x40
 c058b1e:	e9de 200c 	ldrd	r2, r0, [lr, #48]	@ 0x30
 c058b22:	1912      	adds	r2, r2, r4
 c058b24:	eb40 0005 	adc.w	r0, r0, r5
 c058b28:	1852      	adds	r2, r2, r1
 c058b2a:	9909      	ldr	r1, [sp, #36]	@ 0x24
 c058b2c:	eb41 0000 	adc.w	r0, r1, r0
 c058b30:	990b      	ldr	r1, [sp, #44]	@ 0x2c
 c058b32:	ea81 050a 	eor.w	r5, r1, sl
 c058b36:	990c      	ldr	r1, [sp, #48]	@ 0x30
 c058b38:	ea81 040b 	eor.w	r4, r1, fp
 c058b3c:	9906      	ldr	r1, [sp, #24]
 c058b3e:	400d      	ands	r5, r1
 c058b40:	9907      	ldr	r1, [sp, #28]
 c058b42:	400c      	ands	r4, r1
 c058b44:	990b      	ldr	r1, [sp, #44]	@ 0x2c
 c058b46:	404d      	eors	r5, r1
 c058b48:	990c      	ldr	r1, [sp, #48]	@ 0x30
 c058b4a:	1952      	adds	r2, r2, r5
 c058b4c:	ea84 0401 	eor.w	r4, r4, r1
 c058b50:	9906      	ldr	r1, [sp, #24]
 c058b52:	eb40 0004 	adc.w	r0, r0, r4
 c058b56:	0b8c      	lsrs	r4, r1, #14
 c058b58:	9907      	ldr	r1, [sp, #28]
 c058b5a:	ea44 4481 	orr.w	r4, r4, r1, lsl #18
 c058b5e:	0b8e      	lsrs	r6, r1, #14
 c058b60:	9906      	ldr	r1, [sp, #24]
 c058b62:	ea46 4681 	orr.w	r6, r6, r1, lsl #18
 c058b66:	0c8f      	lsrs	r7, r1, #18
 c058b68:	9907      	ldr	r1, [sp, #28]
 c058b6a:	ea47 3781 	orr.w	r7, r7, r1, lsl #14
 c058b6e:	0c8d      	lsrs	r5, r1, #18
 c058b70:	9906      	ldr	r1, [sp, #24]
 c058b72:	407c      	eors	r4, r7
 c058b74:	ea45 3581 	orr.w	r5, r5, r1, lsl #14
 c058b78:	9907      	ldr	r1, [sp, #28]
 c058b7a:	406e      	eors	r6, r5
 c058b7c:	05cd      	lsls	r5, r1, #23
 c058b7e:	9906      	ldr	r1, [sp, #24]
 c058b80:	ea45 2551 	orr.w	r5, r5, r1, lsr #9
 c058b84:	05cf      	lsls	r7, r1, #23
 c058b86:	9907      	ldr	r1, [sp, #28]
 c058b88:	4075      	eors	r5, r6
 c058b8a:	ea47 2751 	orr.w	r7, r7, r1, lsr #9
 c058b8e:	407c      	eors	r4, r7
 c058b90:	1914      	adds	r4, r2, r4
 c058b92:	9a03      	ldr	r2, [sp, #12]
 c058b94:	eb40 0505 	adc.w	r5, r0, r5
 c058b98:	1912      	adds	r2, r2, r4
 c058b9a:	9208      	str	r2, [sp, #32]
 c058b9c:	9a04      	ldr	r2, [sp, #16]
 c058b9e:	ea4f 7019 	mov.w	r0, r9, lsr #28
 c058ba2:	eb42 0205 	adc.w	r2, r2, r5
 c058ba6:	9209      	str	r2, [sp, #36]	@ 0x24
 c058ba8:	ea4f 7289 	mov.w	r2, r9, lsl #30
 c058bac:	ea42 0298 	orr.w	r2, r2, r8, lsr #2
 c058bb0:	ea4f 7618 	mov.w	r6, r8, lsr #28
 c058bb4:	ea40 1008 	orr.w	r0, r0, r8, lsl #4
 c058bb8:	ea4f 7788 	mov.w	r7, r8, lsl #30
 c058bbc:	ea47 0799 	orr.w	r7, r7, r9, lsr #2
 c058bc0:	4050      	eors	r0, r2
 c058bc2:	ea46 1609 	orr.w	r6, r6, r9, lsl #4
 c058bc6:	ea4f 6248 	mov.w	r2, r8, lsl #25
 c058bca:	407e      	eors	r6, r7
 c058bcc:	ea42 12d9 	orr.w	r2, r2, r9, lsr #7
 c058bd0:	4072      	eors	r2, r6
 c058bd2:	1914      	adds	r4, r2, r4
 c058bd4:	9a05      	ldr	r2, [sp, #20]
 c058bd6:	9901      	ldr	r1, [sp, #4]
 c058bd8:	ea42 0608 	orr.w	r6, r2, r8
 c058bdc:	ea06 0601 	and.w	r6, r6, r1
 c058be0:	9902      	ldr	r1, [sp, #8]
 c058be2:	ea4f 6749 	mov.w	r7, r9, lsl #25
 c058be6:	ea4c 0209 	orr.w	r2, ip, r9
 c058bea:	ea47 17d8 	orr.w	r7, r7, r8, lsr #7
 c058bee:	ea02 0201 	and.w	r2, r2, r1
 c058bf2:	9905      	ldr	r1, [sp, #20]
 c058bf4:	ea80 0007 	eor.w	r0, r0, r7
 c058bf8:	eb45 0000 	adc.w	r0, r5, r0
 c058bfc:	ea01 0508 	and.w	r5, r1, r8
 c058c00:	4335      	orrs	r5, r6
 c058c02:	ea0c 0709 	and.w	r7, ip, r9
 c058c06:	1961      	adds	r1, r4, r5
 c058c08:	ea42 0207 	orr.w	r2, r2, r7
 c058c0c:	eb40 0202 	adc.w	r2, r0, r2
 c058c10:	9204      	str	r2, [sp, #16]
           local.A[7], local.A[0], local.A[1], local.W[i], K[i] ); i++;
        P( local.A[1], local.A[2], local.A[3], local.A[4], local.A[5],
 c058c12:	e9d3 4512 	ldrd	r4, r5, [r3, #72]	@ 0x48
 c058c16:	e9de 200e 	ldrd	r2, r0, [lr, #56]	@ 0x38
 c058c1a:	1914      	adds	r4, r2, r4
 c058c1c:	9a0b      	ldr	r2, [sp, #44]	@ 0x2c
 c058c1e:	eb40 0505 	adc.w	r5, r0, r5
 c058c22:	18a4      	adds	r4, r4, r2
 c058c24:	9a0c      	ldr	r2, [sp, #48]	@ 0x30
        P( local.A[2], local.A[3], local.A[4], local.A[5], local.A[6],
 c058c26:	9103      	str	r1, [sp, #12]
        P( local.A[1], local.A[2], local.A[3], local.A[4], local.A[5],
 c058c28:	eb42 0505 	adc.w	r5, r2, r5
 c058c2c:	9a06      	ldr	r2, [sp, #24]
 c058c2e:	9908      	ldr	r1, [sp, #32]
 c058c30:	ea8a 0002 	eor.w	r0, sl, r2
 c058c34:	9a07      	ldr	r2, [sp, #28]
 c058c36:	4008      	ands	r0, r1
 c058c38:	9909      	ldr	r1, [sp, #36]	@ 0x24
 c058c3a:	ea8b 0202 	eor.w	r2, fp, r2
 c058c3e:	400a      	ands	r2, r1
 c058c40:	ea80 000a 	eor.w	r0, r0, sl
 c058c44:	1824      	adds	r4, r4, r0
 c058c46:	ea82 020b 	eor.w	r2, r2, fp
 c058c4a:	eb45 0502 	adc.w	r5, r5, r2
 c058c4e:	9a08      	ldr	r2, [sp, #32]
           local.A[6], local.A[7], local.A[0], local.W[i], K[i] ); i++;
    }
    while( i < 80 );
 c058c50:	3340      	adds	r3, #64	@ 0x40
        P( local.A[1], local.A[2], local.A[3], local.A[4], local.A[5],
 c058c52:	0b96      	lsrs	r6, r2, #14
 c058c54:	ea46 4681 	orr.w	r6, r6, r1, lsl #18
 c058c58:	0b8a      	lsrs	r2, r1, #14
 c058c5a:	9908      	ldr	r1, [sp, #32]
    while( i < 80 );
 c058c5c:	f10e 0e40 	add.w	lr, lr, #64	@ 0x40
        P( local.A[1], local.A[2], local.A[3], local.A[4], local.A[5],
 c058c60:	ea42 4281 	orr.w	r2, r2, r1, lsl #18
 c058c64:	0c8f      	lsrs	r7, r1, #18
 c058c66:	9909      	ldr	r1, [sp, #36]	@ 0x24
 c058c68:	ea47 3781 	orr.w	r7, r7, r1, lsl #14
 c058c6c:	0c88      	lsrs	r0, r1, #18
 c058c6e:	9908      	ldr	r1, [sp, #32]
 c058c70:	407e      	eors	r6, r7
 c058c72:	ea40 3081 	orr.w	r0, r0, r1, lsl #14
 c058c76:	9909      	ldr	r1, [sp, #36]	@ 0x24
 c058c78:	4042      	eors	r2, r0
 c058c7a:	05cf      	lsls	r7, r1, #23
 c058c7c:	9908      	ldr	r1, [sp, #32]
 c058c7e:	ea47 2751 	orr.w	r7, r7, r1, lsr #9
 c058c82:	05c8      	lsls	r0, r1, #23
 c058c84:	9909      	ldr	r1, [sp, #36]	@ 0x24
 c058c86:	407a      	eors	r2, r7
 c058c88:	ea40 2051 	orr.w	r0, r0, r1, lsr #9
 c058c8c:	4070      	eors	r0, r6
 c058c8e:	1824      	adds	r4, r4, r0
 c058c90:	eb45 0502 	adc.w	r5, r5, r2
 c058c94:	9a03      	ldr	r2, [sp, #12]
 c058c96:	9904      	ldr	r1, [sp, #16]
 c058c98:	0f12      	lsrs	r2, r2, #28
 c058c9a:	ea42 1201 	orr.w	r2, r2, r1, lsl #4
 c058c9e:	0f08      	lsrs	r0, r1, #28
 c058ca0:	9903      	ldr	r1, [sp, #12]
 c058ca2:	ea40 1001 	orr.w	r0, r0, r1, lsl #4
 c058ca6:	9904      	ldr	r1, [sp, #16]
 c058ca8:	078e      	lsls	r6, r1, #30
 c058caa:	9903      	ldr	r1, [sp, #12]
 c058cac:	ea46 0691 	orr.w	r6, r6, r1, lsr #2
 c058cb0:	078f      	lsls	r7, r1, #30
 c058cb2:	9904      	ldr	r1, [sp, #16]
 c058cb4:	4070      	eors	r0, r6
 c058cb6:	ea47 0791 	orr.w	r7, r7, r1, lsr #2
 c058cba:	064e      	lsls	r6, r1, #25
 c058cbc:	9903      	ldr	r1, [sp, #12]
 c058cbe:	407a      	eors	r2, r7
 c058cc0:	ea46 16d1 	orr.w	r6, r6, r1, lsr #7
 c058cc4:	064f      	lsls	r7, r1, #25
 c058cc6:	9904      	ldr	r1, [sp, #16]
 c058cc8:	4070      	eors	r0, r6
 c058cca:	ea47 17d1 	orr.w	r7, r7, r1, lsr #7
 c058cce:	9903      	ldr	r1, [sp, #12]
 c058cd0:	407a      	eors	r2, r7
 c058cd2:	ea48 0701 	orr.w	r7, r8, r1
 c058cd6:	9904      	ldr	r1, [sp, #16]
 c058cd8:	ea49 0601 	orr.w	r6, r9, r1
 c058cdc:	9905      	ldr	r1, [sp, #20]
 c058cde:	ea06 060c 	and.w	r6, r6, ip
 c058ce2:	4039      	ands	r1, r7
 c058ce4:	910a      	str	r1, [sp, #40]	@ 0x28
 c058ce6:	9903      	ldr	r1, [sp, #12]
 c058ce8:	ea08 0701 	and.w	r7, r8, r1
 c058cec:	9904      	ldr	r1, [sp, #16]
 c058cee:	ea09 0101 	and.w	r1, r9, r1
 c058cf2:	910b      	str	r1, [sp, #44]	@ 0x2c
 c058cf4:	990a      	ldr	r1, [sp, #40]	@ 0x28
 c058cf6:	430f      	orrs	r7, r1
 c058cf8:	990b      	ldr	r1, [sp, #44]	@ 0x2c
 c058cfa:	19d7      	adds	r7, r2, r7
 c058cfc:	9a01      	ldr	r2, [sp, #4]
 c058cfe:	ea46 0601 	orr.w	r6, r6, r1
 c058d02:	9902      	ldr	r1, [sp, #8]
 c058d04:	eb40 0606 	adc.w	r6, r0, r6
 c058d08:	1912      	adds	r2, r2, r4
 c058d0a:	eb41 0005 	adc.w	r0, r1, r5
 c058d0e:	19e1      	adds	r1, r4, r7
 c058d10:	9101      	str	r1, [sp, #4]
 c058d12:	eb45 0106 	adc.w	r1, r5, r6
 c058d16:	9102      	str	r1, [sp, #8]
    while( i < 80 );
 c058d18:	a9ae      	add	r1, sp, #696	@ 0x2b8
 c058d1a:	4299      	cmp	r1, r3
 c058d1c:	f47f ac0c 	bne.w	c058538 <mbedtls_internal_sha512_process+0x138>
 c058d20:	9b05      	ldr	r3, [sp, #20]
 c058d22:	e9cd abc0 	strd	sl, fp, [sp, #768]	@ 0x300
 c058d26:	e9cd 3cb8 	strd	r3, ip, [sp, #736]	@ 0x2e0
 c058d2a:	9b06      	ldr	r3, [sp, #24]
 c058d2c:	e9cd 89b6 	strd	r8, r9, [sp, #728]	@ 0x2d8
 c058d30:	93be      	str	r3, [sp, #760]	@ 0x2f8
 c058d32:	9b07      	ldr	r3, [sp, #28]
 c058d34:	e9cd 7610 	strd	r7, r6, [sp, #64]	@ 0x40
 c058d38:	93bf      	str	r3, [sp, #764]	@ 0x2fc
 c058d3a:	9b08      	ldr	r3, [sp, #32]
 c058d3c:	e9cd 450e 	strd	r4, r5, [sp, #56]	@ 0x38
 c058d40:	93bc      	str	r3, [sp, #752]	@ 0x2f0
 c058d42:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 c058d44:	e9cd 20ba 	strd	r2, r0, [sp, #744]	@ 0x2e8
 c058d48:	93bd      	str	r3, [sp, #756]	@ 0x2f4
 c058d4a:	9b03      	ldr	r3, [sp, #12]
 c058d4c:	acb0      	add	r4, sp, #704	@ 0x2c0
 c058d4e:	93b4      	str	r3, [sp, #720]	@ 0x2d0
 c058d50:	9b04      	ldr	r3, [sp, #16]
 c058d52:	93b5      	str	r3, [sp, #724]	@ 0x2d4
 c058d54:	9b01      	ldr	r3, [sp, #4]
 c058d56:	93b2      	str	r3, [sp, #712]	@ 0x2c8
 c058d58:	9b02      	ldr	r3, [sp, #8]
 c058d5a:	93b3      	str	r3, [sp, #716]	@ 0x2cc
 c058d5c:	9b0d      	ldr	r3, [sp, #52]	@ 0x34
 c058d5e:	f103 0208 	add.w	r2, r3, #8
 c058d62:	3348      	adds	r3, #72	@ 0x48
#endif /* MBEDTLS_SHA512_SMALLER */

    for( i = 0; i < 8; i++ )
        ctx->state[i] += local.A[i];
 c058d64:	f852 1f08 	ldr.w	r1, [r2, #8]!
 c058d68:	f854 5f08 	ldr.w	r5, [r4, #8]!
 c058d6c:	6850      	ldr	r0, [r2, #4]
 c058d6e:	6866      	ldr	r6, [r4, #4]
 c058d70:	1949      	adds	r1, r1, r5
 c058d72:	eb40 0006 	adc.w	r0, r0, r6
    for( i = 0; i < 8; i++ )
 c058d76:	429a      	cmp	r2, r3
        ctx->state[i] += local.A[i];
 c058d78:	e9c2 1000 	strd	r1, r0, [r2]
    for( i = 0; i < 8; i++ )
 c058d7c:	d1f2      	bne.n	c058d64 <mbedtls_internal_sha512_process+0x964>

    /* Zeroise buffers and variables to clear sensitive data from memory. */
    mbedtls_platform_zeroize( &local, sizeof( local ) );
 c058d7e:	a80e      	add	r0, sp, #56	@ 0x38
 c058d80:	f44f 7134 	mov.w	r1, #720	@ 0x2d0
 c058d84:	f7e2 fb24 	bl	c03b3d0 <mbedtls_platform_zeroize>

    return( 0 );
}
 c058d88:	2000      	movs	r0, #0
 c058d8a:	f50d 7d43 	add.w	sp, sp, #780	@ 0x30c
 c058d8e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 c058d92:	bf00      	nop

0c058d94 <mbedtls_sha512_update_ret>:
 * SHA-512 process buffer
 */
int mbedtls_sha512_update_ret( mbedtls_sha512_context *ctx,
                               const unsigned char *input,
                               size_t ilen )
{
 c058d94:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 c058d98:	4605      	mov	r5, r0
 c058d9a:	460e      	mov	r6, r1
    unsigned int left;

    SHA512_VALIDATE_RET( ctx != NULL );
    SHA512_VALIDATE_RET( ilen == 0 || input != NULL );

    if( ilen == 0 )
 c058d9c:	4614      	mov	r4, r2
 c058d9e:	b3e2      	cbz	r2, c058e1a <mbedtls_sha512_update_ret+0x86>
        return( 0 );

    left = (unsigned int) (ctx->total[0] & 0x7F);
 c058da0:	e9d0 3200 	ldrd	r3, r2, [r0]
 c058da4:	f003 077f 	and.w	r7, r3, #127	@ 0x7f
    fill = 128 - left;

    ctx->total[0] += (uint64_t) ilen;
 c058da8:	191b      	adds	r3, r3, r4
 c058daa:	f152 0200 	adcs.w	r2, r2, #0
 c058dae:	f04f 0100 	mov.w	r1, #0
 c058db2:	bf28      	it	cs
 c058db4:	2101      	movcs	r1, #1
 c058db6:	e9c0 3200 	strd	r3, r2, [r0]

    if( ctx->total[0] < (uint64_t) ilen )
 c058dba:	b131      	cbz	r1, c058dca <mbedtls_sha512_update_ret+0x36>
        ctx->total[1]++;
 c058dbc:	e9d0 3202 	ldrd	r3, r2, [r0, #8]
 c058dc0:	3301      	adds	r3, #1
 c058dc2:	f142 0200 	adc.w	r2, r2, #0
 c058dc6:	e9c0 3202 	strd	r3, r2, [r0, #8]

    if( left && ilen >= fill )
 c058dca:	b1a7      	cbz	r7, c058df6 <mbedtls_sha512_update_ret+0x62>
    fill = 128 - left;
 c058dcc:	f1c7 0980 	rsb	r9, r7, #128	@ 0x80
    if( left && ilen >= fill )
 c058dd0:	454c      	cmp	r4, r9
 c058dd2:	d310      	bcc.n	c058df6 <mbedtls_sha512_update_ret+0x62>
    {
        memcpy( (void *) (ctx->buffer + left), input, fill );
 c058dd4:	f105 0850 	add.w	r8, r5, #80	@ 0x50
 c058dd8:	4631      	mov	r1, r6
 c058dda:	464a      	mov	r2, r9
 c058ddc:	eb08 0007 	add.w	r0, r8, r7
 c058de0:	f002 fc34 	bl	c05b64c <memcpy>

        if( ( ret = mbedtls_internal_sha512_process( ctx, ctx->buffer ) ) != 0 )
 c058de4:	4641      	mov	r1, r8
 c058de6:	4628      	mov	r0, r5
 c058de8:	f7ff fb0a 	bl	c058400 <mbedtls_internal_sha512_process>
 c058dec:	b9b0      	cbnz	r0, c058e1c <mbedtls_sha512_update_ret+0x88>
            return( ret );

        input += fill;
 c058dee:	3c80      	subs	r4, #128	@ 0x80
        ilen  -= fill;
 c058df0:	443c      	add	r4, r7
        left = 0;
 c058df2:	4607      	mov	r7, r0
        input += fill;
 c058df4:	444e      	add	r6, r9
        left = 0;
 c058df6:	4426      	add	r6, r4
 c058df8:	e004      	b.n	c058e04 <mbedtls_sha512_update_ret+0x70>
    }

    while( ilen >= 128 )
    {
        if( ( ret = mbedtls_internal_sha512_process( ctx, input ) ) != 0 )
 c058dfa:	4628      	mov	r0, r5
 c058dfc:	f7ff fb00 	bl	c058400 <mbedtls_internal_sha512_process>
 c058e00:	b960      	cbnz	r0, c058e1c <mbedtls_sha512_update_ret+0x88>
            return( ret );

        input += 128;
        ilen  -= 128;
 c058e02:	3c80      	subs	r4, #128	@ 0x80
    while( ilen >= 128 )
 c058e04:	2c7f      	cmp	r4, #127	@ 0x7f
 c058e06:	eba6 0104 	sub.w	r1, r6, r4
 c058e0a:	d8f6      	bhi.n	c058dfa <mbedtls_sha512_update_ret+0x66>
    }

    if( ilen > 0 )
 c058e0c:	b12c      	cbz	r4, c058e1a <mbedtls_sha512_update_ret+0x86>
        memcpy( (void *) (ctx->buffer + left), input, ilen );
 c058e0e:	f105 0050 	add.w	r0, r5, #80	@ 0x50
 c058e12:	4622      	mov	r2, r4
 c058e14:	4438      	add	r0, r7
 c058e16:	f002 fc19 	bl	c05b64c <memcpy>
        return( 0 );
 c058e1a:	2000      	movs	r0, #0

    return( 0 );
}
 c058e1c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

0c058e20 <mbedtls_sha512_finish_ret>:
/*
 * SHA-512 final digest
 */
int mbedtls_sha512_finish_ret( mbedtls_sha512_context *ctx,
                               unsigned char output[64] )
{
 c058e20:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 c058e22:	460d      	mov	r5, r1
    /*
     * Add padding: 0x80 then 0x00 until 16 bytes remain for the length
     */
    used = ctx->total[0] & 0x7F;

    ctx->buffer[used++] = 0x80;
 c058e24:	2180      	movs	r1, #128	@ 0x80
    used = ctx->total[0] & 0x7F;
 c058e26:	6803      	ldr	r3, [r0, #0]

    if( used <= 112 )
    {
        /* Enough room for padding + length in current block */
        memset( ctx->buffer + used, 0, 112 - used );
 c058e28:	f100 0650 	add.w	r6, r0, #80	@ 0x50
    used = ctx->total[0] & 0x7F;
 c058e2c:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
    ctx->buffer[used++] = 0x80;
 c058e30:	1c5a      	adds	r2, r3, #1
    if( used <= 112 )
 c058e32:	2a70      	cmp	r2, #112	@ 0x70
    ctx->buffer[used++] = 0x80;
 c058e34:	4403      	add	r3, r0
{
 c058e36:	4604      	mov	r4, r0
    ctx->buffer[used++] = 0x80;
 c058e38:	f883 1050 	strb.w	r1, [r3, #80]	@ 0x50
        memset( ctx->buffer + used, 0, 112 - used );
 c058e3c:	eb06 0002 	add.w	r0, r6, r2
    if( used <= 112 )
 c058e40:	f200 80fb 	bhi.w	c05903a <mbedtls_sha512_finish_ret+0x21a>
        memset( ctx->buffer + used, 0, 112 - used );
 c058e44:	2100      	movs	r1, #0
 c058e46:	f1c2 0270 	rsb	r2, r2, #112	@ 0x70
        memset( ctx->buffer + used, 0, 128 - used );

        if( ( ret = mbedtls_internal_sha512_process( ctx, ctx->buffer ) ) != 0 )
            return( ret );

        memset( ctx->buffer, 0, 112 );
 c058e4a:	f002 fc70 	bl	c05b72e <memset>

    /*
     * Add message length
     */
    high = ( ctx->total[0] >> 61 )
         | ( ctx->total[1] <<  3 );
 c058e4e:	e9d4 7202 	ldrd	r7, r2, [r4, #8]
    high = ( ctx->total[0] >> 61 )
 c058e52:	e9d4 1300 	ldrd	r1, r3, [r4]
         | ( ctx->total[1] <<  3 );
 c058e56:	00d2      	lsls	r2, r2, #3
 c058e58:	ea42 7257 	orr.w	r2, r2, r7, lsr #29
    high = ( ctx->total[0] >> 61 )
 c058e5c:	0f58      	lsrs	r0, r3, #29
 c058e5e:	ea40 00c7 	orr.w	r0, r0, r7, lsl #3
    low  = ( ctx->total[0] <<  3 );
 c058e62:	00db      	lsls	r3, r3, #3

    sha512_put_uint64_be( high, ctx->buffer, 112 );
 c058e64:	0e17      	lsrs	r7, r2, #24
    low  = ( ctx->total[0] <<  3 );
 c058e66:	ea43 7351 	orr.w	r3, r3, r1, lsr #29
    sha512_put_uint64_be( high, ctx->buffer, 112 );
 c058e6a:	f884 70c0 	strb.w	r7, [r4, #192]	@ 0xc0
 c058e6e:	0c17      	lsrs	r7, r2, #16
 c058e70:	f884 70c1 	strb.w	r7, [r4, #193]	@ 0xc1
 c058e74:	f884 20c3 	strb.w	r2, [r4, #195]	@ 0xc3
 c058e78:	0a17      	lsrs	r7, r2, #8
    sha512_put_uint64_be( low,  ctx->buffer, 120 );
 c058e7a:	0e1a      	lsrs	r2, r3, #24
    low  = ( ctx->total[0] <<  3 );
 c058e7c:	00c9      	lsls	r1, r1, #3
    sha512_put_uint64_be( low,  ctx->buffer, 120 );
 c058e7e:	f884 20c8 	strb.w	r2, [r4, #200]	@ 0xc8
 c058e82:	0c1a      	lsrs	r2, r3, #16
 c058e84:	ba00      	rev	r0, r0
 c058e86:	ba09      	rev	r1, r1
 c058e88:	f884 20c9 	strb.w	r2, [r4, #201]	@ 0xc9
 c058e8c:	0a1a      	lsrs	r2, r3, #8
    sha512_put_uint64_be( high, ctx->buffer, 112 );
 c058e8e:	f8c4 00c4 	str.w	r0, [r4, #196]	@ 0xc4
    sha512_put_uint64_be( low,  ctx->buffer, 120 );
 c058e92:	f8c4 10cc 	str.w	r1, [r4, #204]	@ 0xcc

    if( ( ret = mbedtls_internal_sha512_process( ctx, ctx->buffer ) ) != 0 )
 c058e96:	4620      	mov	r0, r4
 c058e98:	4631      	mov	r1, r6
    sha512_put_uint64_be( high, ctx->buffer, 112 );
 c058e9a:	f884 70c2 	strb.w	r7, [r4, #194]	@ 0xc2
    sha512_put_uint64_be( low,  ctx->buffer, 120 );
 c058e9e:	f884 20ca 	strb.w	r2, [r4, #202]	@ 0xca
 c058ea2:	f884 30cb 	strb.w	r3, [r4, #203]	@ 0xcb
    if( ( ret = mbedtls_internal_sha512_process( ctx, ctx->buffer ) ) != 0 )
 c058ea6:	f7ff faab 	bl	c058400 <mbedtls_internal_sha512_process>
 c058eaa:	2800      	cmp	r0, #0
 c058eac:	f040 80c4 	bne.w	c059038 <mbedtls_sha512_finish_ret+0x218>
        return( ret );

    /*
     * Output final state
     */
    sha512_put_uint64_be( ctx->state[0], output,  0 );
 c058eb0:	7de3      	ldrb	r3, [r4, #23]
 c058eb2:	702b      	strb	r3, [r5, #0]
 c058eb4:	8ae3      	ldrh	r3, [r4, #22]
 c058eb6:	706b      	strb	r3, [r5, #1]
 c058eb8:	6963      	ldr	r3, [r4, #20]
 c058eba:	0a1b      	lsrs	r3, r3, #8
 c058ebc:	70ab      	strb	r3, [r5, #2]
 c058ebe:	6963      	ldr	r3, [r4, #20]
 c058ec0:	70eb      	strb	r3, [r5, #3]
 c058ec2:	7ce3      	ldrb	r3, [r4, #19]
 c058ec4:	712b      	strb	r3, [r5, #4]
 c058ec6:	8a63      	ldrh	r3, [r4, #18]
 c058ec8:	716b      	strb	r3, [r5, #5]
 c058eca:	6923      	ldr	r3, [r4, #16]
 c058ecc:	0a1b      	lsrs	r3, r3, #8
 c058ece:	71ab      	strb	r3, [r5, #6]
 c058ed0:	6923      	ldr	r3, [r4, #16]
 c058ed2:	71eb      	strb	r3, [r5, #7]
    sha512_put_uint64_be( ctx->state[1], output,  8 );
 c058ed4:	7fe3      	ldrb	r3, [r4, #31]
 c058ed6:	722b      	strb	r3, [r5, #8]
 c058ed8:	8be3      	ldrh	r3, [r4, #30]
 c058eda:	726b      	strb	r3, [r5, #9]
 c058edc:	69e3      	ldr	r3, [r4, #28]
 c058ede:	0a1b      	lsrs	r3, r3, #8
 c058ee0:	72ab      	strb	r3, [r5, #10]
 c058ee2:	69e3      	ldr	r3, [r4, #28]
 c058ee4:	72eb      	strb	r3, [r5, #11]
 c058ee6:	7ee3      	ldrb	r3, [r4, #27]
 c058ee8:	732b      	strb	r3, [r5, #12]
 c058eea:	8b63      	ldrh	r3, [r4, #26]
 c058eec:	736b      	strb	r3, [r5, #13]
 c058eee:	69a3      	ldr	r3, [r4, #24]
 c058ef0:	0a1b      	lsrs	r3, r3, #8
 c058ef2:	73ab      	strb	r3, [r5, #14]
 c058ef4:	69a3      	ldr	r3, [r4, #24]
 c058ef6:	73eb      	strb	r3, [r5, #15]
    sha512_put_uint64_be( ctx->state[2], output, 16 );
 c058ef8:	f894 3027 	ldrb.w	r3, [r4, #39]	@ 0x27
 c058efc:	742b      	strb	r3, [r5, #16]
 c058efe:	8ce3      	ldrh	r3, [r4, #38]	@ 0x26
 c058f00:	746b      	strb	r3, [r5, #17]
 c058f02:	6a63      	ldr	r3, [r4, #36]	@ 0x24
 c058f04:	0a1b      	lsrs	r3, r3, #8
 c058f06:	74ab      	strb	r3, [r5, #18]
 c058f08:	6a63      	ldr	r3, [r4, #36]	@ 0x24
 c058f0a:	74eb      	strb	r3, [r5, #19]
 c058f0c:	f894 3023 	ldrb.w	r3, [r4, #35]	@ 0x23
 c058f10:	752b      	strb	r3, [r5, #20]
 c058f12:	8c63      	ldrh	r3, [r4, #34]	@ 0x22
 c058f14:	756b      	strb	r3, [r5, #21]
 c058f16:	6a23      	ldr	r3, [r4, #32]
 c058f18:	0a1b      	lsrs	r3, r3, #8
 c058f1a:	75ab      	strb	r3, [r5, #22]
 c058f1c:	6a23      	ldr	r3, [r4, #32]
 c058f1e:	75eb      	strb	r3, [r5, #23]
    sha512_put_uint64_be( ctx->state[3], output, 24 );
 c058f20:	f894 302f 	ldrb.w	r3, [r4, #47]	@ 0x2f
 c058f24:	762b      	strb	r3, [r5, #24]
 c058f26:	8de3      	ldrh	r3, [r4, #46]	@ 0x2e
 c058f28:	766b      	strb	r3, [r5, #25]
 c058f2a:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
 c058f2c:	0a1b      	lsrs	r3, r3, #8
 c058f2e:	76ab      	strb	r3, [r5, #26]
 c058f30:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
 c058f32:	76eb      	strb	r3, [r5, #27]
 c058f34:	f894 302b 	ldrb.w	r3, [r4, #43]	@ 0x2b
 c058f38:	772b      	strb	r3, [r5, #28]
 c058f3a:	8d63      	ldrh	r3, [r4, #42]	@ 0x2a
 c058f3c:	776b      	strb	r3, [r5, #29]
 c058f3e:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
 c058f40:	0a1b      	lsrs	r3, r3, #8
 c058f42:	77ab      	strb	r3, [r5, #30]
 c058f44:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
 c058f46:	77eb      	strb	r3, [r5, #31]
    sha512_put_uint64_be( ctx->state[4], output, 32 );
 c058f48:	f894 3037 	ldrb.w	r3, [r4, #55]	@ 0x37
 c058f4c:	f885 3020 	strb.w	r3, [r5, #32]
 c058f50:	8ee3      	ldrh	r3, [r4, #54]	@ 0x36
 c058f52:	f885 3021 	strb.w	r3, [r5, #33]	@ 0x21
 c058f56:	6b63      	ldr	r3, [r4, #52]	@ 0x34
 c058f58:	0a1b      	lsrs	r3, r3, #8
 c058f5a:	f885 3022 	strb.w	r3, [r5, #34]	@ 0x22
 c058f5e:	6b63      	ldr	r3, [r4, #52]	@ 0x34
 c058f60:	f885 3023 	strb.w	r3, [r5, #35]	@ 0x23
 c058f64:	f894 3033 	ldrb.w	r3, [r4, #51]	@ 0x33
 c058f68:	f885 3024 	strb.w	r3, [r5, #36]	@ 0x24
 c058f6c:	8e63      	ldrh	r3, [r4, #50]	@ 0x32
 c058f6e:	f885 3025 	strb.w	r3, [r5, #37]	@ 0x25
 c058f72:	6b23      	ldr	r3, [r4, #48]	@ 0x30
 c058f74:	0a1b      	lsrs	r3, r3, #8
 c058f76:	f885 3026 	strb.w	r3, [r5, #38]	@ 0x26
 c058f7a:	6b23      	ldr	r3, [r4, #48]	@ 0x30
 c058f7c:	f885 3027 	strb.w	r3, [r5, #39]	@ 0x27
    sha512_put_uint64_be( ctx->state[5], output, 40 );
 c058f80:	f894 303f 	ldrb.w	r3, [r4, #63]	@ 0x3f
 c058f84:	f885 3028 	strb.w	r3, [r5, #40]	@ 0x28
 c058f88:	8fe3      	ldrh	r3, [r4, #62]	@ 0x3e
 c058f8a:	f885 3029 	strb.w	r3, [r5, #41]	@ 0x29
 c058f8e:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
 c058f90:	0a1b      	lsrs	r3, r3, #8
 c058f92:	f885 302a 	strb.w	r3, [r5, #42]	@ 0x2a
 c058f96:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
 c058f98:	f885 302b 	strb.w	r3, [r5, #43]	@ 0x2b
 c058f9c:	f894 303b 	ldrb.w	r3, [r4, #59]	@ 0x3b
 c058fa0:	f885 302c 	strb.w	r3, [r5, #44]	@ 0x2c
 c058fa4:	8f63      	ldrh	r3, [r4, #58]	@ 0x3a
 c058fa6:	f885 302d 	strb.w	r3, [r5, #45]	@ 0x2d
 c058faa:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
 c058fac:	0a1b      	lsrs	r3, r3, #8
 c058fae:	f885 302e 	strb.w	r3, [r5, #46]	@ 0x2e
 c058fb2:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
 c058fb4:	f885 302f 	strb.w	r3, [r5, #47]	@ 0x2f

#if !defined(MBEDTLS_SHA512_NO_SHA384)
    if( ctx->is384 == 0 )
 c058fb8:	f8d4 30d0 	ldr.w	r3, [r4, #208]	@ 0xd0
 c058fbc:	2b00      	cmp	r3, #0
 c058fbe:	d13b      	bne.n	c059038 <mbedtls_sha512_finish_ret+0x218>
#endif
    {
        sha512_put_uint64_be( ctx->state[6], output, 48 );
 c058fc0:	f894 3047 	ldrb.w	r3, [r4, #71]	@ 0x47
 c058fc4:	f885 3030 	strb.w	r3, [r5, #48]	@ 0x30
 c058fc8:	f8b4 3046 	ldrh.w	r3, [r4, #70]	@ 0x46
 c058fcc:	f885 3031 	strb.w	r3, [r5, #49]	@ 0x31
 c058fd0:	6c63      	ldr	r3, [r4, #68]	@ 0x44
 c058fd2:	0a1b      	lsrs	r3, r3, #8
 c058fd4:	f885 3032 	strb.w	r3, [r5, #50]	@ 0x32
 c058fd8:	6c63      	ldr	r3, [r4, #68]	@ 0x44
 c058fda:	f885 3033 	strb.w	r3, [r5, #51]	@ 0x33
 c058fde:	f894 3043 	ldrb.w	r3, [r4, #67]	@ 0x43
 c058fe2:	f885 3034 	strb.w	r3, [r5, #52]	@ 0x34
 c058fe6:	f8b4 3042 	ldrh.w	r3, [r4, #66]	@ 0x42
 c058fea:	f885 3035 	strb.w	r3, [r5, #53]	@ 0x35
 c058fee:	6c23      	ldr	r3, [r4, #64]	@ 0x40
 c058ff0:	0a1b      	lsrs	r3, r3, #8
 c058ff2:	f885 3036 	strb.w	r3, [r5, #54]	@ 0x36
 c058ff6:	6c23      	ldr	r3, [r4, #64]	@ 0x40
 c058ff8:	f885 3037 	strb.w	r3, [r5, #55]	@ 0x37
        sha512_put_uint64_be( ctx->state[7], output, 56 );
 c058ffc:	f894 304f 	ldrb.w	r3, [r4, #79]	@ 0x4f
 c059000:	f885 3038 	strb.w	r3, [r5, #56]	@ 0x38
 c059004:	f8b4 304e 	ldrh.w	r3, [r4, #78]	@ 0x4e
 c059008:	f885 3039 	strb.w	r3, [r5, #57]	@ 0x39
 c05900c:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
 c05900e:	0a1b      	lsrs	r3, r3, #8
 c059010:	f885 303a 	strb.w	r3, [r5, #58]	@ 0x3a
 c059014:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
 c059016:	f885 303b 	strb.w	r3, [r5, #59]	@ 0x3b
 c05901a:	f894 304b 	ldrb.w	r3, [r4, #75]	@ 0x4b
 c05901e:	f885 303c 	strb.w	r3, [r5, #60]	@ 0x3c
 c059022:	f8b4 304a 	ldrh.w	r3, [r4, #74]	@ 0x4a
 c059026:	f885 303d 	strb.w	r3, [r5, #61]	@ 0x3d
 c05902a:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
 c05902c:	0a1b      	lsrs	r3, r3, #8
 c05902e:	f885 303e 	strb.w	r3, [r5, #62]	@ 0x3e
 c059032:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
 c059034:	f885 303f 	strb.w	r3, [r5, #63]	@ 0x3f
    }

    return( 0 );
}
 c059038:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        memset( ctx->buffer + used, 0, 128 - used );
 c05903a:	2100      	movs	r1, #0
 c05903c:	f1c2 0280 	rsb	r2, r2, #128	@ 0x80
 c059040:	f002 fb75 	bl	c05b72e <memset>
        if( ( ret = mbedtls_internal_sha512_process( ctx, ctx->buffer ) ) != 0 )
 c059044:	4631      	mov	r1, r6
 c059046:	4620      	mov	r0, r4
 c059048:	f7ff f9da 	bl	c058400 <mbedtls_internal_sha512_process>
 c05904c:	2800      	cmp	r0, #0
 c05904e:	d1f3      	bne.n	c059038 <mbedtls_sha512_finish_ret+0x218>
        memset( ctx->buffer, 0, 112 );
 c059050:	4601      	mov	r1, r0
 c059052:	2270      	movs	r2, #112	@ 0x70
 c059054:	4630      	mov	r0, r6
 c059056:	e6f8      	b.n	c058e4a <mbedtls_sha512_finish_ret+0x2a>

0c059058 <mbedtls_sha512_ret>:
 */
int mbedtls_sha512_ret( const unsigned char *input,
                    size_t ilen,
                    unsigned char output[64],
                    int is384 )
{
 c059058:	b5f0      	push	{r4, r5, r6, r7, lr}
 c05905a:	461c      	mov	r4, r3
 c05905c:	b0b7      	sub	sp, #220	@ 0xdc
 c05905e:	4606      	mov	r6, r0
    SHA512_VALIDATE_RET( is384 == 0 );
#endif
    SHA512_VALIDATE_RET( ilen == 0 || input != NULL );
    SHA512_VALIDATE_RET( (unsigned char *)output != NULL );

    mbedtls_sha512_init( &ctx );
 c059060:	4668      	mov	r0, sp
{
 c059062:	460f      	mov	r7, r1
 c059064:	4615      	mov	r5, r2
    mbedtls_sha512_init( &ctx );
 c059066:	f7ff f90e 	bl	c058286 <mbedtls_sha512_init>

    if( ( ret = mbedtls_sha512_starts_ret( &ctx, is384 ) ) != 0 )
 c05906a:	4621      	mov	r1, r4
 c05906c:	4668      	mov	r0, sp
 c05906e:	f7ff f91b 	bl	c0582a8 <mbedtls_sha512_starts_ret>
 c059072:	4604      	mov	r4, r0
 c059074:	b958      	cbnz	r0, c05908e <mbedtls_sha512_ret+0x36>
        goto exit;

    if( ( ret = mbedtls_sha512_update_ret( &ctx, input, ilen ) ) != 0 )
 c059076:	463a      	mov	r2, r7
 c059078:	4631      	mov	r1, r6
 c05907a:	4668      	mov	r0, sp
 c05907c:	f7ff fe8a 	bl	c058d94 <mbedtls_sha512_update_ret>
 c059080:	4604      	mov	r4, r0
 c059082:	b920      	cbnz	r0, c05908e <mbedtls_sha512_ret+0x36>
        goto exit;

    if( ( ret = mbedtls_sha512_finish_ret( &ctx, output ) ) != 0 )
 c059084:	4629      	mov	r1, r5
 c059086:	4668      	mov	r0, sp
 c059088:	f7ff feca 	bl	c058e20 <mbedtls_sha512_finish_ret>
 c05908c:	4604      	mov	r4, r0
    mbedtls_platform_zeroize( ctx, sizeof( mbedtls_sha512_context ) );
 c05908e:	4668      	mov	r0, sp
 c059090:	21d8      	movs	r1, #216	@ 0xd8
 c059092:	f7e2 f99d 	bl	c03b3d0 <mbedtls_platform_zeroize>

exit:
    mbedtls_sha512_free( &ctx );

    return( ret );
}
 c059096:	4620      	mov	r0, r4
 c059098:	b037      	add	sp, #220	@ 0xdc
 c05909a:	bdf0      	pop	{r4, r5, r6, r7, pc}

0c05909c <boot_write_trailer>:
 * @returns 0 on success, != 0 on error.
 */
static int
boot_write_trailer(const struct flash_area *fap, uint32_t off,
        const uint8_t *inbuf, uint8_t inlen)
{
 c05909c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 c0590a0:	b085      	sub	sp, #20
 c0590a2:	4606      	mov	r6, r0
 c0590a4:	460f      	mov	r7, r1
 c0590a6:	4691      	mov	r9, r2
 c0590a8:	461d      	mov	r5, r3
    uint8_t buf[BOOT_MAX_ALIGN];
    uint8_t align;
    uint8_t erased_val;
    int rc;

    align = flash_area_align(fap);
 c0590aa:	f002 fd0f 	bl	c05bacc <flash_area_align>
 c0590ae:	b2c4      	uxtb	r4, r0
    if (inlen > BOOT_MAX_ALIGN || align > BOOT_MAX_ALIGN) {
 c0590b0:	2c10      	cmp	r4, #16
 c0590b2:	d81d      	bhi.n	c0590f0 <boot_write_trailer+0x54>
        return -1;
    }
    erased_val = flash_area_erased_val(fap);
 c0590b4:	4630      	mov	r0, r6
 c0590b6:	f002 fd0f 	bl	c05bad8 <flash_area_erased_val>
 c0590ba:	42ac      	cmp	r4, r5
 c0590bc:	bf38      	it	cc
 c0590be:	462c      	movcc	r4, r5
 c0590c0:	4680      	mov	r8, r0
    if (align < inlen) {
        align = inlen;
    }
    memcpy(buf, inbuf, inlen);
 c0590c2:	462a      	mov	r2, r5
 c0590c4:	4649      	mov	r1, r9
 c0590c6:	4668      	mov	r0, sp
 c0590c8:	f002 fac0 	bl	c05b64c <memcpy>
    memset(&buf[inlen], erased_val, align - inlen);
 c0590cc:	4641      	mov	r1, r8
 c0590ce:	1b62      	subs	r2, r4, r5
 c0590d0:	eb0d 0005 	add.w	r0, sp, r5
 c0590d4:	f002 fb2b 	bl	c05b72e <memset>

    rc = flash_area_write(fap, off, buf, align);
 c0590d8:	4623      	mov	r3, r4
 c0590da:	466a      	mov	r2, sp
 c0590dc:	4639      	mov	r1, r7
 c0590de:	4630      	mov	r0, r6
 c0590e0:	f002 fcbe 	bl	c05ba60 <flash_area_write>
    if (rc != 0) {
 c0590e4:	3800      	subs	r0, #0
 c0590e6:	bf18      	it	ne
 c0590e8:	2001      	movne	r0, #1
        return BOOT_EFLASH;
    }

    return 0;
}
 c0590ea:	b005      	add	sp, #20
 c0590ec:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        return -1;
 c0590f0:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 c0590f4:	e7f9      	b.n	c0590ea <boot_write_trailer+0x4e>

0c0590f6 <bootutil_buffer_is_erased>:
{
 c0590f6:	b538      	push	{r3, r4, r5, lr}
 c0590f8:	4615      	mov	r5, r2
    if (buffer == NULL || len == 0) {
 c0590fa:	460c      	mov	r4, r1
 c0590fc:	b161      	cbz	r1, c059118 <bootutil_buffer_is_erased+0x22>
 c0590fe:	b15a      	cbz	r2, c059118 <bootutil_buffer_is_erased+0x22>
    erased_val = flash_area_erased_val(area);
 c059100:	f002 fcea 	bl	c05bad8 <flash_area_erased_val>
    for (i = 0, u8b = (uint8_t *)buffer; i < len; i++) {
 c059104:	4621      	mov	r1, r4
 c059106:	4425      	add	r5, r4
        if (u8b[i] != erased_val) {
 c059108:	f811 3b01 	ldrb.w	r3, [r1], #1
 c05910c:	4283      	cmp	r3, r0
 c05910e:	d103      	bne.n	c059118 <bootutil_buffer_is_erased+0x22>
    for (i = 0, u8b = (uint8_t *)buffer; i < len; i++) {
 c059110:	42a9      	cmp	r1, r5
 c059112:	d1f9      	bne.n	c059108 <bootutil_buffer_is_erased+0x12>
    return true;
 c059114:	2001      	movs	r0, #1
}
 c059116:	bd38      	pop	{r3, r4, r5, pc}
        return false;
 c059118:	2000      	movs	r0, #0
 c05911a:	e7fc      	b.n	c059116 <bootutil_buffer_is_erased+0x20>

0c05911c <boot_read_swap_state>:
{
 c05911c:	b570      	push	{r4, r5, r6, lr}
 c05911e:	460c      	mov	r4, r1
    return fap->fa_size - BOOT_MAGIC_SZ;
 c059120:	68c1      	ldr	r1, [r0, #12]
{
 c059122:	b086      	sub	sp, #24
    rc = flash_area_read(fap, off, magic, BOOT_MAGIC_SZ);
 c059124:	2310      	movs	r3, #16
 c059126:	aa02      	add	r2, sp, #8
 c059128:	3910      	subs	r1, #16
{
 c05912a:	4605      	mov	r5, r0
    rc = flash_area_read(fap, off, magic, BOOT_MAGIC_SZ);
 c05912c:	f002 fc83 	bl	c05ba36 <flash_area_read>
    if (rc < 0) {
 c059130:	2800      	cmp	r0, #0
 c059132:	da02      	bge.n	c05913a <boot_read_swap_state+0x1e>
        return BOOT_EFLASH;
 c059134:	2001      	movs	r0, #1
}
 c059136:	b006      	add	sp, #24
 c059138:	bd70      	pop	{r4, r5, r6, pc}
    if (bootutil_buffer_is_erased(fap, magic, BOOT_MAGIC_SZ)) {
 c05913a:	2210      	movs	r2, #16
 c05913c:	4628      	mov	r0, r5
 c05913e:	a902      	add	r1, sp, #8
 c059140:	f7ff ffd9 	bl	c0590f6 <bootutil_buffer_is_erased>
 c059144:	2800      	cmp	r0, #0
 c059146:	d152      	bne.n	c0591ee <boot_read_swap_state+0xd2>
    if (memcmp(magic, boot_img_magic, BOOT_MAGIC_SZ) == 0) {
 c059148:	2210      	movs	r2, #16
 c05914a:	492e      	ldr	r1, [pc, #184]	@ (c059204 <boot_read_swap_state+0xe8>)
 c05914c:	a802      	add	r0, sp, #8
 c05914e:	f002 fa6d 	bl	c05b62c <memcmp>
    return BOOT_MAGIC_BAD;
 c059152:	2800      	cmp	r0, #0
        state->magic = boot_magic_decode(magic);
 c059154:	bf0c      	ite	eq
 c059156:	2301      	moveq	r3, #1
 c059158:	2302      	movne	r3, #2
        state->magic = BOOT_MAGIC_UNSET;
 c05915a:	7023      	strb	r3, [r4, #0]
    return boot_copy_done_off(fap) - BOOT_MAX_ALIGN;
 c05915c:	68e9      	ldr	r1, [r5, #12]
    rc = flash_area_read(fap, off, &swap_info, sizeof swap_info);
 c05915e:	2301      	movs	r3, #1
 c059160:	4628      	mov	r0, r5
 c059162:	f10d 0207 	add.w	r2, sp, #7
 c059166:	3940      	subs	r1, #64	@ 0x40
 c059168:	f002 fc65 	bl	c05ba36 <flash_area_read>
    if (rc < 0) {
 c05916c:	2800      	cmp	r0, #0
 c05916e:	dbe1      	blt.n	c059134 <boot_read_swap_state+0x18>
    state->swap_type = BOOT_GET_SWAP_TYPE(swap_info);
 c059170:	f89d 3007 	ldrb.w	r3, [sp, #7]
    if (bootutil_buffer_is_erased(fap, &swap_info, sizeof swap_info) ||
 c059174:	4628      	mov	r0, r5
    state->swap_type = BOOT_GET_SWAP_TYPE(swap_info);
 c059176:	f003 020f 	and.w	r2, r3, #15
    state->image_num = BOOT_GET_IMAGE_NUM(swap_info);
 c05917a:	091b      	lsrs	r3, r3, #4
    state->swap_type = BOOT_GET_SWAP_TYPE(swap_info);
 c05917c:	7062      	strb	r2, [r4, #1]
    state->image_num = BOOT_GET_IMAGE_NUM(swap_info);
 c05917e:	7123      	strb	r3, [r4, #4]
    if (bootutil_buffer_is_erased(fap, &swap_info, sizeof swap_info) ||
 c059180:	2201      	movs	r2, #1
 c059182:	f10d 0107 	add.w	r1, sp, #7
 c059186:	f7ff ffb6 	bl	c0590f6 <bootutil_buffer_is_erased>
 c05918a:	b910      	cbnz	r0, c059192 <boot_read_swap_state+0x76>
 c05918c:	7863      	ldrb	r3, [r4, #1]
 c05918e:	2b04      	cmp	r3, #4
 c059190:	d903      	bls.n	c05919a <boot_read_swap_state+0x7e>
        state->swap_type = BOOT_SWAP_TYPE_NONE;
 c059192:	2301      	movs	r3, #1
 c059194:	7063      	strb	r3, [r4, #1]
        state->image_num = 0;
 c059196:	2300      	movs	r3, #0
 c059198:	7123      	strb	r3, [r4, #4]
    return boot_image_ok_off(fap) - BOOT_MAX_ALIGN;
 c05919a:	68e9      	ldr	r1, [r5, #12]
    rc = flash_area_read(fap, off, &state->copy_done, sizeof state->copy_done);
 c05919c:	1ca6      	adds	r6, r4, #2
 c05919e:	2301      	movs	r3, #1
 c0591a0:	4632      	mov	r2, r6
 c0591a2:	4628      	mov	r0, r5
 c0591a4:	3930      	subs	r1, #48	@ 0x30
 c0591a6:	f002 fc46 	bl	c05ba36 <flash_area_read>
    if (rc < 0) {
 c0591aa:	2800      	cmp	r0, #0
 c0591ac:	dbc2      	blt.n	c059134 <boot_read_swap_state+0x18>
    if (bootutil_buffer_is_erased(fap, &state->copy_done,
 c0591ae:	2201      	movs	r2, #1
 c0591b0:	4631      	mov	r1, r6
 c0591b2:	4628      	mov	r0, r5
 c0591b4:	f7ff ff9f 	bl	c0590f6 <bootutil_buffer_is_erased>
 c0591b8:	b9d8      	cbnz	r0, c0591f2 <boot_read_swap_state+0xd6>
    if (flag != BOOT_FLAG_SET) {
 c0591ba:	78a3      	ldrb	r3, [r4, #2]
    return BOOT_FLAG_SET;
 c0591bc:	2b01      	cmp	r3, #1
        state->copy_done = boot_flag_decode(state->copy_done);
 c0591be:	bf14      	ite	ne
 c0591c0:	2302      	movne	r3, #2
 c0591c2:	2301      	moveq	r3, #1
        state->copy_done = BOOT_FLAG_UNSET;
 c0591c4:	70a3      	strb	r3, [r4, #2]
    return boot_magic_off(fap) - BOOT_MAX_ALIGN;
 c0591c6:	68e9      	ldr	r1, [r5, #12]
    rc = flash_area_read(fap, off, &state->image_ok, sizeof state->image_ok);
 c0591c8:	1ce6      	adds	r6, r4, #3
 c0591ca:	2301      	movs	r3, #1
 c0591cc:	4632      	mov	r2, r6
 c0591ce:	4628      	mov	r0, r5
 c0591d0:	3920      	subs	r1, #32
 c0591d2:	f002 fc30 	bl	c05ba36 <flash_area_read>
    if (rc < 0) {
 c0591d6:	2800      	cmp	r0, #0
 c0591d8:	dbac      	blt.n	c059134 <boot_read_swap_state+0x18>
    if (bootutil_buffer_is_erased(fap, &state->image_ok,
 c0591da:	2201      	movs	r2, #1
 c0591dc:	4631      	mov	r1, r6
 c0591de:	4628      	mov	r0, r5
 c0591e0:	f7ff ff89 	bl	c0590f6 <bootutil_buffer_is_erased>
 c0591e4:	b138      	cbz	r0, c0591f6 <boot_read_swap_state+0xda>
 c0591e6:	2303      	movs	r3, #3
    return 0;
 c0591e8:	2000      	movs	r0, #0
        state->image_ok = BOOT_FLAG_UNSET;
 c0591ea:	70e3      	strb	r3, [r4, #3]
 c0591ec:	e7a3      	b.n	c059136 <boot_read_swap_state+0x1a>
 c0591ee:	2303      	movs	r3, #3
 c0591f0:	e7b3      	b.n	c05915a <boot_read_swap_state+0x3e>
 c0591f2:	2303      	movs	r3, #3
 c0591f4:	e7e6      	b.n	c0591c4 <boot_read_swap_state+0xa8>
    if (flag != BOOT_FLAG_SET) {
 c0591f6:	78e3      	ldrb	r3, [r4, #3]
    return BOOT_FLAG_SET;
 c0591f8:	2b01      	cmp	r3, #1
        state->image_ok = boot_flag_decode(state->image_ok);
 c0591fa:	bf14      	ite	ne
 c0591fc:	2302      	movne	r3, #2
 c0591fe:	2301      	moveq	r3, #1
 c059200:	e7f2      	b.n	c0591e8 <boot_read_swap_state+0xcc>
 c059202:	bf00      	nop
 c059204:	0c06117c 	.word	0x0c06117c

0c059208 <boot_read_swap_state_by_id>:
{
 c059208:	b513      	push	{r0, r1, r4, lr}
 c05920a:	460c      	mov	r4, r1
    rc = flash_area_open(flash_area_id, &fap);
 c05920c:	b2c0      	uxtb	r0, r0
 c05920e:	a901      	add	r1, sp, #4
 c059210:	f002 fbfc 	bl	c05ba0c <flash_area_open>
    if (rc != 0) {
 c059214:	b950      	cbnz	r0, c05922c <boot_read_swap_state_by_id+0x24>
    rc = boot_read_swap_state(fap, state);
 c059216:	4621      	mov	r1, r4
 c059218:	9801      	ldr	r0, [sp, #4]
 c05921a:	f7ff ff7f 	bl	c05911c <boot_read_swap_state>
 c05921e:	4604      	mov	r4, r0
    flash_area_close(fap);
 c059220:	9801      	ldr	r0, [sp, #4]
 c059222:	f002 fc07 	bl	c05ba34 <flash_area_close>
}
 c059226:	4620      	mov	r0, r4
 c059228:	b002      	add	sp, #8
 c05922a:	bd10      	pop	{r4, pc}
        return BOOT_EFLASH;
 c05922c:	2401      	movs	r4, #1
 c05922e:	e7fa      	b.n	c059226 <boot_read_swap_state_by_id+0x1e>

0c059230 <boot_write_magic>:
    return fap->fa_size - BOOT_MAGIC_SZ;
 c059230:	68c1      	ldr	r1, [r0, #12]
{
 c059232:	b508      	push	{r3, lr}
    rc = flash_area_write(fap, off, boot_img_magic, BOOT_MAGIC_SZ);
 c059234:	4a04      	ldr	r2, [pc, #16]	@ (c059248 <boot_write_magic+0x18>)
 c059236:	2310      	movs	r3, #16
 c059238:	3910      	subs	r1, #16
 c05923a:	f002 fc11 	bl	c05ba60 <flash_area_write>
}
 c05923e:	3800      	subs	r0, #0
 c059240:	bf18      	it	ne
 c059242:	2001      	movne	r0, #1
 c059244:	bd08      	pop	{r3, pc}
 c059246:	bf00      	nop
 c059248:	0c06117c 	.word	0x0c06117c

0c05924c <boot_write_image_ok>:

static int
boot_write_trailer_flag(const struct flash_area *fap, uint32_t off,
        uint8_t flag_val)
{
    const uint8_t buf[1] = { flag_val };
 c05924c:	2301      	movs	r3, #1
    return boot_write_trailer_flag(fap, off, BOOT_FLAG_SET);
}

int
boot_write_image_ok(const struct flash_area *fap)
{
 c05924e:	b507      	push	{r0, r1, r2, lr}
    return boot_magic_off(fap) - BOOT_MAX_ALIGN;
 c059250:	68c1      	ldr	r1, [r0, #12]
    return boot_write_trailer(fap, off, buf, 1);
 c059252:	aa01      	add	r2, sp, #4
 c059254:	3920      	subs	r1, #32
    const uint8_t buf[1] = { flag_val };
 c059256:	f88d 3004 	strb.w	r3, [sp, #4]
    return boot_write_trailer(fap, off, buf, 1);
 c05925a:	f7ff ff1f 	bl	c05909c <boot_write_trailer>
    off = boot_image_ok_off(fap);
    BOOT_LOG_DBG("writing image_ok; fa_id=%d off=0x%lx (0x%lx)",
                 fap->fa_id, (unsigned long)off,
                 (unsigned long)(fap->fa_off + off));
    return boot_write_trailer_flag(fap, off, BOOT_FLAG_SET);
}
 c05925e:	b003      	add	sp, #12
 c059260:	f85d fb04 	ldr.w	pc, [sp], #4

0c059264 <boot_set_confirmed>:
 * @return                  0 on success; nonzero on failure.
 *                          if one image cannot be confirmed, failure is returned
 */
int
boot_set_confirmed(void)
{
 c059264:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    const struct flash_area *fap;
    struct boot_swap_state state_primary_slot;
    int rc;
    int image_index;
    for (image_index = 0; image_index < MCUBOOT_IMAGE_NUMBER; image_index++)
 c059266:	2500      	movs	r5, #0
 c059268:	4e1f      	ldr	r6, [pc, #124]	@ (c0592e8 <boot_set_confirmed+0x84>)
    {
        rc = boot_read_swap_state_by_id(FLASH_AREA_IMAGE_PRIMARY(image_index),
 c05926a:	2d03      	cmp	r5, #3
    for (image_index = 0; image_index < MCUBOOT_IMAGE_NUMBER; image_index++)
 c05926c:	bf0c      	ite	eq
 c05926e:	2006      	moveq	r0, #6
 c059270:	5770      	ldrsbne	r0, [r6, r5]
        rc = boot_read_swap_state_by_id(FLASH_AREA_IMAGE_PRIMARY(image_index),
 c059272:	a902      	add	r1, sp, #8
 c059274:	f7ff ffc8 	bl	c059208 <boot_read_swap_state_by_id>
                &state_primary_slot);
        if (rc != 0) {
 c059278:	bb68      	cbnz	r0, c0592d6 <boot_set_confirmed+0x72>
            return rc;
        }
        switch (state_primary_slot.magic) {
 c05927a:	f89d 0008 	ldrb.w	r0, [sp, #8]
 c05927e:	2801      	cmp	r0, #1
 c059280:	d006      	beq.n	c059290 <boot_set_confirmed+0x2c>
 c059282:	2802      	cmp	r0, #2
 c059284:	d02d      	beq.n	c0592e2 <boot_set_confirmed+0x7e>
    for (image_index = 0; image_index < MCUBOOT_IMAGE_NUMBER; image_index++)
 c059286:	3501      	adds	r5, #1
 c059288:	2d04      	cmp	r5, #4
 c05928a:	d1ee      	bne.n	c05926a <boot_set_confirmed+0x6>
        case BOOT_MAGIC_BAD:
            /* Unexpected state. */
            return BOOT_EBADVECT;
        }
    }
done:
 c05928c:	2400      	movs	r4, #0
 c05928e:	e01e      	b.n	c0592ce <boot_set_confirmed+0x6a>
            rc = flash_area_open(FLASH_AREA_IMAGE_PRIMARY(image_index), &fap);
 c059290:	b12d      	cbz	r5, c05929e <boot_set_confirmed+0x3a>
 c059292:	2d01      	cmp	r5, #1
 c059294:	d014      	beq.n	c0592c0 <boot_set_confirmed+0x5c>
 c059296:	2d02      	cmp	r5, #2
 c059298:	bf0c      	ite	eq
 c05929a:	2005      	moveq	r0, #5
 c05929c:	2006      	movne	r0, #6
 c05929e:	a901      	add	r1, sp, #4
 c0592a0:	f002 fbb4 	bl	c05ba0c <flash_area_open>
            if (rc) {
 c0592a4:	b9c8      	cbnz	r0, c0592da <boot_set_confirmed+0x76>
            if (state_primary_slot.copy_done == BOOT_FLAG_UNSET) {
 c0592a6:	f89d 300a 	ldrb.w	r3, [sp, #10]
                rc = boot_write_image_ok(fap);
 c0592aa:	9801      	ldr	r0, [sp, #4]
            if (state_primary_slot.copy_done == BOOT_FLAG_UNSET) {
 c0592ac:	2b03      	cmp	r3, #3
 c0592ae:	d016      	beq.n	c0592de <boot_set_confirmed+0x7a>
            if (state_primary_slot.image_ok == BOOT_FLAG_UNSET) {
 c0592b0:	f89d 300b 	ldrb.w	r3, [sp, #11]
 c0592b4:	2b03      	cmp	r3, #3
 c0592b6:	d005      	beq.n	c0592c4 <boot_set_confirmed+0x60>
            flash_area_close(fap);
 c0592b8:	9801      	ldr	r0, [sp, #4]
 c0592ba:	f002 fbbb 	bl	c05ba34 <flash_area_close>
            break;
 c0592be:	e7e2      	b.n	c059286 <boot_set_confirmed+0x22>
            rc = flash_area_open(FLASH_AREA_IMAGE_PRIMARY(image_index), &fap);
 c0592c0:	2002      	movs	r0, #2
 c0592c2:	e7ec      	b.n	c05929e <boot_set_confirmed+0x3a>
                rc = boot_write_image_ok(fap);
 c0592c4:	f7ff ffc2 	bl	c05924c <boot_write_image_ok>
                if (rc)
 c0592c8:	4604      	mov	r4, r0
 c0592ca:	2800      	cmp	r0, #0
 c0592cc:	d0f4      	beq.n	c0592b8 <boot_set_confirmed+0x54>
    flash_area_close(fap);
 c0592ce:	9801      	ldr	r0, [sp, #4]
 c0592d0:	f002 fbb0 	bl	c05ba34 <flash_area_close>
    return rc;
 c0592d4:	4620      	mov	r0, r4
}
 c0592d6:	b004      	add	sp, #16
 c0592d8:	bd70      	pop	{r4, r5, r6, pc}
                rc = BOOT_EFLASH;
 c0592da:	2401      	movs	r4, #1
 c0592dc:	e7f7      	b.n	c0592ce <boot_set_confirmed+0x6a>
                rc = BOOT_EBADVECT;
 c0592de:	2404      	movs	r4, #4
 c0592e0:	e7f5      	b.n	c0592ce <boot_set_confirmed+0x6a>
        switch (state_primary_slot.magic) {
 c0592e2:	2004      	movs	r0, #4
 c0592e4:	e7f7      	b.n	c0592d6 <boot_set_confirmed+0x72>
 c0592e6:	bf00      	nop
 c0592e8:	0c061178 	.word	0x0c061178

0c0592ec <se_GetKeySize>:
  uint8_t data[100];
  StSafeA_TLVBuffer_t outTLV;
  outTLV.LV.Data = data;
  outTLV.LV.Length = sizeof(data);

  inCmd.Header = 0x14;
 c0592ec:	2314      	movs	r3, #20
{
 c0592ee:	b530      	push	{r4, r5, lr}
 c0592f0:	b0a3      	sub	sp, #140	@ 0x8c
  inCmd.Header = 0x14;
 c0592f2:	f88d 300c 	strb.w	r3, [sp, #12]
  inCmd.LV.Data = data;
  data[0] = 0x14;
 c0592f6:	f88d 3024 	strb.w	r3, [sp, #36]	@ 0x24
  inCmd.LV.Length = 1;

  /* get slot 0 key size */
  status_code = StSafeA_RawCommand(SE_HDL, &inCmd, sizeof(data), &outTLV, 0, SE_SEC_LEVEL_NONE);
 c0592fa:	2300      	movs	r3, #0
  outTLV.LV.Length = sizeof(data);
 c0592fc:	2264      	movs	r2, #100	@ 0x64
  inCmd.LV.Length = 1;
 c0592fe:	2501      	movs	r5, #1
  status_code = StSafeA_RawCommand(SE_HDL, &inCmd, sizeof(data), &outTLV, 0, SE_SEC_LEVEL_NONE);
 c059300:	4c34      	ldr	r4, [pc, #208]	@ (c0593d4 <se_GetKeySize+0xe8>)
  outTLV.LV.Data = data;
 c059302:	a909      	add	r1, sp, #36	@ 0x24
  status_code = StSafeA_RawCommand(SE_HDL, &inCmd, sizeof(data), &outTLV, 0, SE_SEC_LEVEL_NONE);
 c059304:	e9cd 3300 	strd	r3, r3, [sp]
  outTLV.LV.Data = data;
 c059308:	9108      	str	r1, [sp, #32]
  inCmd.LV.Data = data;
 c05930a:	9105      	str	r1, [sp, #20]
  status_code = StSafeA_RawCommand(SE_HDL, &inCmd, sizeof(data), &outTLV, 0, SE_SEC_LEVEL_NONE);
 c05930c:	4620      	mov	r0, r4
 c05930e:	ab06      	add	r3, sp, #24
 c059310:	a903      	add	r1, sp, #12
  outTLV.LV.Length = sizeof(data);
 c059312:	f8ad 201c 	strh.w	r2, [sp, #28]
  inCmd.LV.Length = 1;
 c059316:	f8ad 5010 	strh.w	r5, [sp, #16]
  status_code = StSafeA_RawCommand(SE_HDL, &inCmd, sizeof(data), &outTLV, 0, SE_SEC_LEVEL_NONE);
 c05931a:	f001 fa4b 	bl	c05a7b4 <StSafeA_RawCommand>
  if (status_code == STSAFEA_OK)
 c05931e:	2800      	cmp	r0, #0
 c059320:	d152      	bne.n	c0593c8 <se_GetKeySize+0xdc>
  {
    if (outTLV.Header == 0x00)
 c059322:	f89d 3018 	ldrb.w	r3, [sp, #24]
 c059326:	2b00      	cmp	r3, #0
 c059328:	d142      	bne.n	c0593b0 <se_GetKeySize+0xc4>
    {
      uint8_t offset = 4;
      if (outTLV.LV.Data[offset + 1] & 0x1)
 c05932a:	9b08      	ldr	r3, [sp, #32]
 c05932c:	795a      	ldrb	r2, [r3, #5]
 c05932e:	07d1      	lsls	r1, r2, #31
 c059330:	d538      	bpl.n	c0593a4 <se_GetKeySize+0xb8>
      {
        switch (outTLV.LV.Data[offset + 5])
 c059332:	7a5a      	ldrb	r2, [r3, #9]
 c059334:	2a08      	cmp	r2, #8
 c059336:	d00a      	beq.n	c05934e <se_GetKeySize+0x62>
 c059338:	2a09      	cmp	r2, #9
 c05933a:	d01f      	beq.n	c05937c <se_GetKeySize+0x90>
 c05933c:	2a05      	cmp	r2, #5
 c05933e:	d12e      	bne.n	c05939e <se_GetKeySize+0xb2>
          case 8 :
            se_ctx.slot0_key_size = 256;
            se_ctx.fixed_pub_keys[0].public_key_curve = SE_KEY_TYPE_NIST_256;
            break;
          case 5 :
            se_ctx.slot0_key_size = 384;
 c059340:	f44f 72c0 	mov.w	r2, #384	@ 0x180
            se_ctx.fixed_pub_keys[0].public_key_curve = SE_KEY_TYPE_NIST_384;
 c059344:	f884 5494 	strb.w	r5, [r4, #1172]	@ 0x494
            se_ctx.slot0_key_size = 384;
 c059348:	f8a4 225c 	strh.w	r2, [r4, #604]	@ 0x25c
            break;
 c05934c:	e005      	b.n	c05935a <se_GetKeySize+0x6e>
            se_ctx.slot0_key_size = 256;
 c05934e:	f44f 7280 	mov.w	r2, #256	@ 0x100
            se_ctx.fixed_pub_keys[0].public_key_curve = SE_KEY_TYPE_NIST_256;
 c059352:	f884 0494 	strb.w	r0, [r4, #1172]	@ 0x494
            se_ctx.slot0_key_size = 256;
 c059356:	f8a4 225c 	strh.w	r2, [r4, #604]	@ 0x25c
            break;
          default :
            se_ctx.slot0_key_size = 0;
            break;
        }
        offset += outTLV.LV.Data[offset + 5] + 6;
 c05935a:	7a5a      	ldrb	r2, [r3, #9]
 c05935c:	320a      	adds	r2, #10
 c05935e:	b2d2      	uxtb	r2, r2
      }
      else
      {
        offset += 4;
      }
      if (outTLV.LV.Data[offset + 1] & 0x1)
 c059360:	4413      	add	r3, r2
 c059362:	785a      	ldrb	r2, [r3, #1]
 c059364:	07d2      	lsls	r2, r2, #31
 c059366:	d523      	bpl.n	c0593b0 <se_GetKeySize+0xc4>
      {
        switch (outTLV.LV.Data[offset + 5])
 c059368:	795a      	ldrb	r2, [r3, #5]
 c05936a:	2a08      	cmp	r2, #8
 c05936c:	d01c      	beq.n	c0593a8 <se_GetKeySize+0xbc>
 c05936e:	2a09      	cmp	r2, #9
 c059370:	d020      	beq.n	c0593b4 <se_GetKeySize+0xc8>
 c059372:	2a05      	cmp	r2, #5
 c059374:	d126      	bne.n	c0593c4 <se_GetKeySize+0xd8>
        {
          case 8 :
            se_ctx.slot1_key_size = 256;
            break;
          case 5 :
            se_ctx.slot1_key_size = 384;
 c059376:	f44f 73c0 	mov.w	r3, #384	@ 0x180
 c05937a:	e017      	b.n	c0593ac <se_GetKeySize+0xc0>
            if (outTLV.LV.Data[offset + 14] == 0x07)
 c05937c:	7c9a      	ldrb	r2, [r3, #18]
 c05937e:	2a07      	cmp	r2, #7
              se_ctx.slot0_key_size = 256;
 c059380:	bf0b      	itete	eq
 c059382:	f44f 7280 	moveq.w	r2, #256	@ 0x100
              se_ctx.slot0_key_size = 384;
 c059386:	f44f 72c0 	movne.w	r2, #384	@ 0x180
              se_ctx.slot0_key_size = 256;
 c05938a:	f8a4 225c 	strheq.w	r2, [r4, #604]	@ 0x25c
              se_ctx.slot0_key_size = 384;
 c05938e:	f8a4 225c 	strhne.w	r2, [r4, #604]	@ 0x25c
              se_ctx.fixed_pub_keys[0].public_key_curve = SE_KEY_TYPE_BP_256;
 c059392:	bf0c      	ite	eq
 c059394:	2202      	moveq	r2, #2
              se_ctx.fixed_pub_keys[0].public_key_curve = SE_KEY_TYPE_BP_384;
 c059396:	2203      	movne	r2, #3
 c059398:	f884 2494 	strb.w	r2, [r4, #1172]	@ 0x494
 c05939c:	e7dd      	b.n	c05935a <se_GetKeySize+0x6e>
            se_ctx.slot0_key_size = 0;
 c05939e:	f8a4 025c 	strh.w	r0, [r4, #604]	@ 0x25c
            break;
 c0593a2:	e7da      	b.n	c05935a <se_GetKeySize+0x6e>
        offset += 4;
 c0593a4:	2208      	movs	r2, #8
 c0593a6:	e7db      	b.n	c059360 <se_GetKeySize+0x74>
            se_ctx.slot1_key_size = 256;
 c0593a8:	f44f 7380 	mov.w	r3, #256	@ 0x100
            break;
          case 9 :
            se_ctx.slot1_key_size = (outTLV.LV.Data[offset + 14] == 0x07 ? 256 : 384);
            break;
          default :
            se_ctx.slot1_key_size = 0;
 c0593ac:	f8a4 325e 	strh.w	r3, [r4, #606]	@ 0x25e
  if (status_code == STSAFEA_INVALID_LIFE_CYCLE_STATE)
  {
    return SE_INVALID_STATE_ERROR;
  }
  return SE_COMMAND_ERROR;
}
 c0593b0:	b023      	add	sp, #140	@ 0x8c
 c0593b2:	bd30      	pop	{r4, r5, pc}
            se_ctx.slot1_key_size = (outTLV.LV.Data[offset + 14] == 0x07 ? 256 : 384);
 c0593b4:	7b9b      	ldrb	r3, [r3, #14]
 c0593b6:	2b07      	cmp	r3, #7
 c0593b8:	bf14      	ite	ne
 c0593ba:	f44f 73c0 	movne.w	r3, #384	@ 0x180
 c0593be:	f44f 7380 	moveq.w	r3, #256	@ 0x100
 c0593c2:	e7f3      	b.n	c0593ac <se_GetKeySize+0xc0>
            se_ctx.slot1_key_size = 0;
 c0593c4:	2300      	movs	r3, #0
 c0593c6:	e7f1      	b.n	c0593ac <se_GetKeySize+0xc0>
  return SE_COMMAND_ERROR;
 c0593c8:	280f      	cmp	r0, #15
 c0593ca:	bf0c      	ite	eq
 c0593cc:	2002      	moveq	r0, #2
 c0593ce:	2001      	movne	r0, #1
 c0593d0:	e7ee      	b.n	c0593b0 <se_GetKeySize+0xc4>
 c0593d2:	bf00      	nop
 c0593d4:	30031830 	.word	0x30031830

0c0593d8 <SE_Unwrap.part.0>:


/* reasonable max size to wrap */
#define SE_MAX_WRAP_SIZE 480
/* Use STSAFE-A to unwrap few data */
SE_API_Status_t SE_Unwrap(uint8_t slot, uint8_t *enc_data, uint16_t size, uint8_t *data)
 c0593d8:	b570      	push	{r4, r5, r6, lr}
  {
    return SE_INVALID_PARAMS_ERROR;
  }

  SE_API_LOCK;
  ret = StSafeA_UnwrapLocalEnvelope(SE_HDL, slot, enc_data, size, &out,
 c0593da:	4c11      	ldr	r4, [pc, #68]	@ (c059420 <SE_Unwrap.part.0+0x48>)
SE_API_Status_t SE_Unwrap(uint8_t slot, uint8_t *enc_data, uint16_t size, uint8_t *data)
 c0593dc:	461d      	mov	r5, r3
  ret = StSafeA_UnwrapLocalEnvelope(SE_HDL, slot, enc_data, size, &out,
 c0593de:	f894 3268 	ldrb.w	r3, [r4, #616]	@ 0x268
SE_API_Status_t SE_Unwrap(uint8_t slot, uint8_t *enc_data, uint16_t size, uint8_t *data)
 c0593e2:	b086      	sub	sp, #24
  ret = StSafeA_UnwrapLocalEnvelope(SE_HDL, slot, enc_data, size, &out,
 c0593e4:	9302      	str	r3, [sp, #8]
 c0593e6:	f894 3264 	ldrb.w	r3, [r4, #612]	@ 0x264
 c0593ea:	f894 6267 	ldrb.w	r6, [r4, #615]	@ 0x267
 c0593ee:	429e      	cmp	r6, r3
 c0593f0:	bf2c      	ite	cs
 c0593f2:	9601      	strcs	r6, [sp, #4]
 c0593f4:	9301      	strcc	r3, [sp, #4]
 c0593f6:	ab04      	add	r3, sp, #16
 c0593f8:	9300      	str	r3, [sp, #0]
 c0593fa:	4613      	mov	r3, r2
 c0593fc:	460a      	mov	r2, r1
 c0593fe:	4601      	mov	r1, r0
 c059400:	4620      	mov	r0, r4
 c059402:	f001 fa61 	bl	c05a8c8 <StSafeA_UnwrapLocalEnvelope>
                                    SE_AUTH_CMD(SE_CMD_UNWRAP), SE_ENC_CMD(SE_CMD_UNWRAP));
  SE_API_UNLOCK;

  if (ret == STSAFEA_OK)
 c059406:	4604      	mov	r4, r0
 c059408:	b940      	cbnz	r0, c05941c <SE_Unwrap.part.0+0x44>
  {
#if (STSAFEA_USE_OPTIMIZATION_SHARED_RAM)
    memcpy(data, out.Data, out.Length);
 c05940a:	4628      	mov	r0, r5
 c05940c:	f8bd 2010 	ldrh.w	r2, [sp, #16]
 c059410:	9905      	ldr	r1, [sp, #20]
 c059412:	f002 f91b 	bl	c05b64c <memcpy>
#endif /* STSAFEA_USE_OPTIMIZATION_SHARED_RAM */
    return SE_OK;
  }
  return SE_COMMAND_ERROR;
}
 c059416:	4620      	mov	r0, r4
 c059418:	b006      	add	sp, #24
 c05941a:	bd70      	pop	{r4, r5, r6, pc}
  return SE_COMMAND_ERROR;
 c05941c:	2401      	movs	r4, #1
 c05941e:	e7fa      	b.n	c059416 <SE_Unwrap.part.0+0x3e>
 c059420:	30031830 	.word	0x30031830

0c059424 <SE_Wrap.part.0>:

/* Use STSAFE-A to wrap few data */
SE_API_Status_t SE_Wrap(uint8_t slot, uint8_t *data, uint16_t size, uint8_t *enc_data)
 c059424:	b570      	push	{r4, r5, r6, lr}
  if (slot > 1)
  {
    return SE_INVALID_PARAMS_ERROR;
  }
  SE_API_LOCK;
  ret = StSafeA_WrapLocalEnvelope(SE_HDL, slot, data, size, &out, SE_AUTH_CMD(SE_CMD_WRAP), SE_ENC_CMD(SE_CMD_WRAP));
 c059426:	4c11      	ldr	r4, [pc, #68]	@ (c05946c <SE_Wrap.part.0+0x48>)
SE_API_Status_t SE_Wrap(uint8_t slot, uint8_t *data, uint16_t size, uint8_t *enc_data)
 c059428:	461d      	mov	r5, r3
  ret = StSafeA_WrapLocalEnvelope(SE_HDL, slot, data, size, &out, SE_AUTH_CMD(SE_CMD_WRAP), SE_ENC_CMD(SE_CMD_WRAP));
 c05942a:	f894 3266 	ldrb.w	r3, [r4, #614]	@ 0x266
SE_API_Status_t SE_Wrap(uint8_t slot, uint8_t *data, uint16_t size, uint8_t *enc_data)
 c05942e:	b086      	sub	sp, #24
  ret = StSafeA_WrapLocalEnvelope(SE_HDL, slot, data, size, &out, SE_AUTH_CMD(SE_CMD_WRAP), SE_ENC_CMD(SE_CMD_WRAP));
 c059430:	9302      	str	r3, [sp, #8]
 c059432:	f894 3264 	ldrb.w	r3, [r4, #612]	@ 0x264
 c059436:	f894 6265 	ldrb.w	r6, [r4, #613]	@ 0x265
 c05943a:	429e      	cmp	r6, r3
 c05943c:	bf2c      	ite	cs
 c05943e:	9601      	strcs	r6, [sp, #4]
 c059440:	9301      	strcc	r3, [sp, #4]
 c059442:	ab04      	add	r3, sp, #16
 c059444:	9300      	str	r3, [sp, #0]
 c059446:	4613      	mov	r3, r2
 c059448:	460a      	mov	r2, r1
 c05944a:	4601      	mov	r1, r0
 c05944c:	4620      	mov	r0, r4
 c05944e:	f001 f9ef 	bl	c05a830 <StSafeA_WrapLocalEnvelope>
  SE_API_UNLOCK;
  if (ret == STSAFEA_OK)
 c059452:	4604      	mov	r4, r0
 c059454:	b940      	cbnz	r0, c059468 <SE_Wrap.part.0+0x44>
  {
#if (STSAFEA_USE_OPTIMIZATION_SHARED_RAM)
    memcpy(enc_data, out.Data, out.Length);
 c059456:	4628      	mov	r0, r5
 c059458:	f8bd 2010 	ldrh.w	r2, [sp, #16]
 c05945c:	9905      	ldr	r1, [sp, #20]
 c05945e:	f002 f8f5 	bl	c05b64c <memcpy>
#endif /* STSAFEA_USE_OPTIMIZATION_SHARED_RAM */
    return SE_OK;
  }
  return SE_COMMAND_ERROR;
}
 c059462:	4620      	mov	r0, r4
 c059464:	b006      	add	sp, #24
 c059466:	bd70      	pop	{r4, r5, r6, pc}
  return SE_COMMAND_ERROR;
 c059468:	2401      	movs	r4, #1
 c05946a:	e7fa      	b.n	c059462 <SE_Wrap.part.0+0x3e>
 c05946c:	30031830 	.word	0x30031830

0c059470 <se_GetMapping.constprop.0>:
    return se_ctx.slotff_key_size;
  }
  return 0;
}

static SE_API_Status_t se_GetMapping(SE_Region_t *regions, uint32_t *nb_region)
 c059470:	b530      	push	{r4, r5, lr}
{
  StSafeA_ResponseCode_t status_code;
  StSafeA_DataPartitionBuffer_t outDataPartition;

  if (*nb_region != 0)
 c059472:	4d2a      	ldr	r5, [pc, #168]	@ (c05951c <se_GetMapping.constprop.0+0xac>)
static SE_API_Status_t se_GetMapping(SE_Region_t *regions, uint32_t *nb_region)
 c059474:	4604      	mov	r4, r0
  if (*nb_region != 0)
 c059476:	f8d5 1284 	ldr.w	r1, [r5, #644]	@ 0x284
static SE_API_Status_t se_GetMapping(SE_Region_t *regions, uint32_t *nb_region)
 c05947a:	b087      	sub	sp, #28
  if (*nb_region != 0)
 c05947c:	2900      	cmp	r1, #0
 c05947e:	d03c      	beq.n	c0594fa <se_GetMapping.constprop.0+0x8a>
    if (outDataPartition.pZoneInfoRecord == NULL)
    {
      return SE_COMMAND_ERROR;
    }
#endif /* STSAFEA_USE_OPTIMIZATION_SHARED_RAM */
    status_code = StSafeA_DataPartitionQuery(SE_HDL, *nb_region, &outDataPartition, SE_SEC_LEVEL_NONE);
 c059480:	2300      	movs	r3, #0
 c059482:	4628      	mov	r0, r5
 c059484:	aa01      	add	r2, sp, #4
 c059486:	b2c9      	uxtb	r1, r1
 c059488:	f000 fd9e 	bl	c059fc8 <StSafeA_DataPartitionQuery>
    if (status_code == STSAFEA_OK)
 c05948c:	2800      	cmp	r0, #0
 c05948e:	d143      	bne.n	c059518 <se_GetMapping.constprop.0+0xa8>
    {
      if (outDataPartition.NumberOfZones <= *nb_region)
 c059490:	f89d 3006 	ldrb.w	r3, [sp, #6]
 c059494:	f8d5 2284 	ldr.w	r2, [r5, #644]	@ 0x284
 c059498:	4620      	mov	r0, r4
 c05949a:	4293      	cmp	r3, r2
        *nb_region = outDataPartition.NumberOfZones;
      }

      for (uint32_t i = 0; i < *nb_region; i++)
      {
        regions[i].index = outDataPartition.pZoneInfoRecord[i].Index;
 c05949c:	f04f 0200 	mov.w	r2, #0
        *nb_region = outDataPartition.NumberOfZones;
 c0594a0:	bf98      	it	ls
 c0594a2:	f8c5 3284 	strls.w	r3, [r5, #644]	@ 0x284
 c0594a6:	9b02      	ldr	r3, [sp, #8]
      for (uint32_t i = 0; i < *nb_region; i++)
 c0594a8:	f8d5 1284 	ldr.w	r1, [r5, #644]	@ 0x284
 c0594ac:	428a      	cmp	r2, r1
 c0594ae:	d302      	bcc.n	c0594b6 <se_GetMapping.constprop.0+0x46>
        }
      }
#if ! (STSAFEA_USE_OPTIMIZATION_SHARED_RAM)
      free(outDataPartition.pZoneInfoRecord);
#endif /* STSAFEA_USE_OPTIMIZATION_SHARED_RAM */
      return SE_OK;
 c0594b0:	2000      	movs	r0, #0
      *nb_region = outDataPartition.NumberOfZones;
      return SE_OK;
    }
  }
  return SE_COMMAND_ERROR;
}
 c0594b2:	b007      	add	sp, #28
 c0594b4:	bd30      	pop	{r4, r5, pc}
        regions[i].index = outDataPartition.pZoneInfoRecord[i].Index;
 c0594b6:	7819      	ldrb	r1, [r3, #0]
      for (uint32_t i = 0; i < *nb_region; i++)
 c0594b8:	3201      	adds	r2, #1
        regions[i].index = outDataPartition.pZoneInfoRecord[i].Index;
 c0594ba:	7001      	strb	r1, [r0, #0]
        regions[i].size = outDataPartition.pZoneInfoRecord[i].DataSegmentLength;
 c0594bc:	88d9      	ldrh	r1, [r3, #6]
 c0594be:	3010      	adds	r0, #16
 c0594c0:	f820 1c0e 	strh.w	r1, [r0, #-14]
        regions[i].read_update = outDataPartition.pZoneInfoRecord[i].ReadAcChangeRight;
 c0594c4:	7899      	ldrb	r1, [r3, #2]
 c0594c6:	330c      	adds	r3, #12
 c0594c8:	f800 1c0b 	strb.w	r1, [r0, #-11]
        regions[i].write_update = outDataPartition.pZoneInfoRecord[i].UpdateAcChangeRight;
 c0594cc:	f813 1c08 	ldrb.w	r1, [r3, #-8]
 c0594d0:	f800 1c09 	strb.w	r1, [r0, #-9]
        regions[i].read_ac = outDataPartition.pZoneInfoRecord[i].ReadAccessCondition;
 c0594d4:	f813 1c09 	ldrb.w	r1, [r3, #-9]
 c0594d8:	f800 1c0c 	strb.w	r1, [r0, #-12]
        regions[i].write_ac = outDataPartition.pZoneInfoRecord[i].UpdateAccessCondition;
 c0594dc:	f813 1c07 	ldrb.w	r1, [r3, #-7]
 c0594e0:	f800 1c0a 	strb.w	r1, [r0, #-10]
        regions[i].type = outDataPartition.pZoneInfoRecord[i].ZoneType;
 c0594e4:	f813 1c0b 	ldrb.w	r1, [r3, #-11]
        if (outDataPartition.pZoneInfoRecord[i].ZoneType == 1)
 c0594e8:	2901      	cmp	r1, #1
        regions[i].type = outDataPartition.pZoneInfoRecord[i].ZoneType;
 c0594ea:	f800 1c04 	strb.w	r1, [r0, #-4]
          regions[i].OneWay = outDataPartition.pZoneInfoRecord[i].OneWayCounter;
 c0594ee:	bf04      	itt	eq
 c0594f0:	f853 1c04 	ldreq.w	r1, [r3, #-4]
 c0594f4:	f840 1c08 	streq.w	r1, [r0, #-8]
      for (uint32_t i = 0; i < *nb_region; i++)
 c0594f8:	e7d6      	b.n	c0594a8 <se_GetMapping.constprop.0+0x38>
    outDataPartition.pZoneInfoRecord = &tempZinfo;
 c0594fa:	ab03      	add	r3, sp, #12
 c0594fc:	9302      	str	r3, [sp, #8]
    status_code = StSafeA_DataPartitionQuery(SE_HDL, *nb_region, &outDataPartition, SE_SEC_LEVEL_NONE);
 c0594fe:	4628      	mov	r0, r5
 c059500:	460b      	mov	r3, r1
 c059502:	aa01      	add	r2, sp, #4
 c059504:	f000 fd60 	bl	c059fc8 <StSafeA_DataPartitionQuery>
    if ((status_code == STSAFEA_INVALID_RESP_LENGTH) || (status_code == STSAFEA_OK))
 c059508:	2831      	cmp	r0, #49	@ 0x31
 c05950a:	d000      	beq.n	c05950e <se_GetMapping.constprop.0+0x9e>
 c05950c:	b920      	cbnz	r0, c059518 <se_GetMapping.constprop.0+0xa8>
      *nb_region = outDataPartition.NumberOfZones;
 c05950e:	f89d 3006 	ldrb.w	r3, [sp, #6]
 c059512:	f8c5 3284 	str.w	r3, [r5, #644]	@ 0x284
      return SE_OK;
 c059516:	e7cb      	b.n	c0594b0 <se_GetMapping.constprop.0+0x40>
  return SE_COMMAND_ERROR;
 c059518:	2001      	movs	r0, #1
 c05951a:	e7ca      	b.n	c0594b2 <se_GetMapping.constprop.0+0x42>
 c05951c:	30031830 	.word	0x30031830

0c059520 <se_GetCommandConfig.isra.0>:
  int32_t i;
  StSafeA_TLVBuffer_t out;
  out.LV.Data = data;
  out.LV.Length = sizeof(data);

  inCmd.Header = 0x14;
 c059520:	2314      	movs	r3, #20
static SE_API_Status_t se_GetCommandConfig(void)
 c059522:	b530      	push	{r4, r5, lr}
 c059524:	b0a3      	sub	sp, #140	@ 0x8c
  inCmd.Header = 0x14;
 c059526:	f88d 300c 	strb.w	r3, [sp, #12]
  inCmd.LV.Data = data;
  data[0] = 0x24;
 c05952a:	2324      	movs	r3, #36	@ 0x24
 c05952c:	f88d 3024 	strb.w	r3, [sp, #36]	@ 0x24
  inCmd.LV.Length = 1;
 c059530:	2301      	movs	r3, #1
 c059532:	f8ad 3010 	strh.w	r3, [sp, #16]

  status_code = StSafeA_RawCommand(SE_HDL, &inCmd, sizeof(data), &out, 0, SE_SEC_LEVEL_NONE);
 c059536:	2300      	movs	r3, #0
  out.LV.Length = sizeof(data);
 c059538:	2264      	movs	r2, #100	@ 0x64
  out.LV.Data = data;
 c05953a:	ac09      	add	r4, sp, #36	@ 0x24
  status_code = StSafeA_RawCommand(SE_HDL, &inCmd, sizeof(data), &out, 0, SE_SEC_LEVEL_NONE);
 c05953c:	e9cd 3300 	strd	r3, r3, [sp]
 c059540:	481b      	ldr	r0, [pc, #108]	@ (c0595b0 <se_GetCommandConfig.isra.0+0x90>)
 c059542:	ab06      	add	r3, sp, #24
 c059544:	a903      	add	r1, sp, #12
  out.LV.Data = data;
 c059546:	9408      	str	r4, [sp, #32]
  out.LV.Length = sizeof(data);
 c059548:	f8ad 201c 	strh.w	r2, [sp, #28]
  inCmd.LV.Data = data;
 c05954c:	9405      	str	r4, [sp, #20]
  status_code = StSafeA_RawCommand(SE_HDL, &inCmd, sizeof(data), &out, 0, SE_SEC_LEVEL_NONE);
 c05954e:	f001 f931 	bl	c05a7b4 <StSafeA_RawCommand>
  if (status_code == STSAFEA_OK)
 c059552:	bb28      	cbnz	r0, c0595a0 <se_GetCommandConfig.isra.0+0x80>
 c059554:	2009      	movs	r0, #9
 c059556:	4623      	mov	r3, r4
          index = -1;
          break;
      }
      if (index != -1)
      {
        se_ctx.cmd_params[index][SE_AUTH_PARAM] = authvalue(data[2 + i * 3 + 1]);
 c059558:	4c15      	ldr	r4, [pc, #84]	@ (c0595b0 <se_GetCommandConfig.isra.0+0x90>)
      switch (data[2 + i * 3])
 c05955a:	789a      	ldrb	r2, [r3, #2]
 c05955c:	3a0e      	subs	r2, #14
 c05955e:	2a0a      	cmp	r2, #10
 c059560:	d81a      	bhi.n	c059598 <se_GetCommandConfig.isra.0+0x78>
 c059562:	e8df f002 	tbb	[pc, r2]
 c059566:	1f21      	.short	0x1f21
 c059568:	19191919 	.word	0x19191919
 c05956c:	19231919 	.word	0x19231919
 c059570:	06          	.byte	0x06
 c059571:	00          	.byte	0x00
          index = SE_CMD_SHARED_SECRET;
 c059572:	2202      	movs	r2, #2
  if (val == 3)
 c059574:	78d9      	ldrb	r1, [r3, #3]
  return STSAFEA_MAC_NONE;
 c059576:	2903      	cmp	r1, #3
 c059578:	bf0c      	ite	eq
 c05957a:	25a0      	moveq	r5, #160	@ 0xa0
 c05957c:	2500      	movne	r5, #0
        se_ctx.cmd_params[index][SE_AUTH_PARAM] = authvalue(data[2 + i * 3 + 1]);
 c05957e:	eb04 0142 	add.w	r1, r4, r2, lsl #1
 c059582:	f881 5265 	strb.w	r5, [r1, #613]	@ 0x265
        se_ctx.cmd_params[index][SE_ENC_PARAM] = encvalue(data[2 + i * 3 + 2]);
 c059586:	7919      	ldrb	r1, [r3, #4]
 c059588:	eb04 0242 	add.w	r2, r4, r2, lsl #1
 c05958c:	1e4d      	subs	r5, r1, #1
 c05958e:	2d02      	cmp	r5, #2
 c059590:	bf88      	it	hi
 c059592:	2100      	movhi	r1, #0
 c059594:	f882 1266 	strb.w	r1, [r2, #614]	@ 0x266
    for (i = 0; i < 9; i++)
 c059598:	3801      	subs	r0, #1
 c05959a:	f103 0303 	add.w	r3, r3, #3
 c05959e:	d1dc      	bne.n	c05955a <se_GetCommandConfig.isra.0+0x3a>
      }
    }
    return SE_OK;
  }
  return SE_COMMAND_ERROR;
}
 c0595a0:	b023      	add	sp, #140	@ 0x8c
 c0595a2:	bd30      	pop	{r4, r5, pc}
          index = SE_CMD_UNWRAP;
 c0595a4:	2201      	movs	r2, #1
 c0595a6:	e7e5      	b.n	c059574 <se_GetCommandConfig.isra.0+0x54>
          index = SE_CMD_WRAP;
 c0595a8:	2200      	movs	r2, #0
 c0595aa:	e7e3      	b.n	c059574 <se_GetCommandConfig.isra.0+0x54>
      switch (data[2 + i * 3])
 c0595ac:	2203      	movs	r2, #3
 c0595ae:	e7e1      	b.n	c059574 <se_GetCommandConfig.isra.0+0x54>
 c0595b0:	30031830 	.word	0x30031830

0c0595b4 <se_printf>:
{
 c0595b4:	b40e      	push	{r1, r2, r3}
 c0595b6:	b510      	push	{r4, lr}
 c0595b8:	b09b      	sub	sp, #108	@ 0x6c
 c0595ba:	ab1d      	add	r3, sp, #116	@ 0x74
 c0595bc:	f853 2b04 	ldr.w	r2, [r3], #4
  if (se_ctx.debug_print == NULL)
 c0595c0:	4c0d      	ldr	r4, [pc, #52]	@ (c0595f8 <se_printf+0x44>)
  va_start(args, fmt);
 c0595c2:	9300      	str	r3, [sp, #0]
  if (se_ctx.debug_print == NULL)
 c0595c4:	f8d4 3290 	ldr.w	r3, [r4, #656]	@ 0x290
 c0595c8:	b18b      	cbz	r3, c0595ee <se_printf+0x3a>
  if (status == 0)
 c0595ca:	b930      	cbnz	r0, c0595da <se_printf+0x26>
    snprintf(fmt_buf_data, 100, SE_TAG "%s", fmt);
 c0595cc:	4613      	mov	r3, r2
 c0595ce:	2164      	movs	r1, #100	@ 0x64
 c0595d0:	4a0a      	ldr	r2, [pc, #40]	@ (c0595fc <se_printf+0x48>)
 c0595d2:	a801      	add	r0, sp, #4
 c0595d4:	f7e8 ff24 	bl	c042420 <sniprintf>
    fmt_buf = fmt_buf_data;
 c0595d8:	aa01      	add	r2, sp, #4
  vsnprintf(se_ctx.trace_buff, SE_TRACE_BUFF_SIZE, fmt_buf, args);
 c0595da:	9b00      	ldr	r3, [sp, #0]
 c0595dc:	f44f 7100 	mov.w	r1, #512	@ 0x200
 c0595e0:	4807      	ldr	r0, [pc, #28]	@ (c059600 <se_printf+0x4c>)
 c0595e2:	f7e8 ffbf 	bl	c042564 <vsniprintf>
  se_ctx.debug_print(se_ctx.trace_buff);
 c0595e6:	f8d4 3290 	ldr.w	r3, [r4, #656]	@ 0x290
 c0595ea:	4805      	ldr	r0, [pc, #20]	@ (c059600 <se_printf+0x4c>)
 c0595ec:	4798      	blx	r3
}
 c0595ee:	b01b      	add	sp, #108	@ 0x6c
 c0595f0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 c0595f4:	b003      	add	sp, #12
 c0595f6:	4770      	bx	lr
 c0595f8:	30031830 	.word	0x30031830
 c0595fc:	0c06118c 	.word	0x0c06118c
 c059600:	30031ac4 	.word	0x30031ac4

0c059604 <SE_SetSecurity>:
  if (level > SE_SECURITY_LEVEL_R_PAIRING)
 c059604:	2802      	cmp	r0, #2
 c059606:	d80a      	bhi.n	c05961e <SE_SetSecurity+0x1a>
  if (level == SE_SECURITY_LEVEL_NONE)
 c059608:	b920      	cbnz	r0, c059614 <SE_SetSecurity+0x10>
    se_ctx.security_level = STSAFEA_MAC_NONE;
 c05960a:	4b06      	ldr	r3, [pc, #24]	@ (c059624 <SE_SetSecurity+0x20>)
 c05960c:	f883 0264 	strb.w	r0, [r3, #612]	@ 0x264
  return SE_OK;
 c059610:	2000      	movs	r0, #0
 c059612:	4770      	bx	lr
  if (level == SE_SECURITY_LEVEL_C_PAIRING)
 c059614:	2801      	cmp	r0, #1
 c059616:	bf14      	ite	ne
 c059618:	20e0      	movne	r0, #224	@ 0xe0
 c05961a:	20a0      	moveq	r0, #160	@ 0xa0
 c05961c:	e7f5      	b.n	c05960a <SE_SetSecurity+0x6>
    return SE_INVALID_PARAMS_ERROR;
 c05961e:	2003      	movs	r0, #3
}
 c059620:	4770      	bx	lr
 c059622:	bf00      	nop
 c059624:	30031830 	.word	0x30031830

0c059628 <SE_GetSerial>:
{
 c059628:	b5f0      	push	{r4, r5, r6, r7, lr}
  if (se_ctx.init == 0)
 c05962a:	4d1d      	ldr	r5, [pc, #116]	@ (c0596a0 <SE_GetSerial+0x78>)
{
 c05962c:	4604      	mov	r4, r0
  if (se_ctx.init == 0)
 c05962e:	f895 3050 	ldrb.w	r3, [r5, #80]	@ 0x50
{
 c059632:	460e      	mov	r6, r1
 c059634:	b093      	sub	sp, #76	@ 0x4c
  if (se_ctx.init == 0)
 c059636:	b37b      	cbz	r3, c059698 <SE_GetSerial+0x70>
  if (se_ctx.serial_loaded == 0)
 c059638:	f895 227d 	ldrb.w	r2, [r5, #637]	@ 0x27d
 c05963c:	b98a      	cbnz	r2, c059662 <SE_GetSerial+0x3a>
    status_code = StSafeA_ProductDataQuery(SE_HDL, &productData, SE_SEC_LEVEL_NONE);
 c05963e:	4628      	mov	r0, r5
 c059640:	a901      	add	r1, sp, #4
 c059642:	f000 ff6c 	bl	c05a51e <StSafeA_ProductDataQuery>
    if (status_code != STSAFEA_OK)
 c059646:	bb48      	cbnz	r0, c05969c <SE_GetSerial+0x74>
    memcpy(se_ctx.serial, productData.STNumber, STSAFEA_ST_NUMBER_LENGTH);
 c059648:	f8dd 000d 	ldr.w	r0, [sp, #13]
 c05964c:	f8dd 1011 	ldr.w	r1, [sp, #17]
 c059650:	f505 731d 	add.w	r3, r5, #628	@ 0x274
 c059654:	c303      	stmia	r3!, {r0, r1}
 c059656:	f89d 2015 	ldrb.w	r2, [sp, #21]
 c05965a:	701a      	strb	r2, [r3, #0]
    se_ctx.serial_loaded = 1;
 c05965c:	2301      	movs	r3, #1
 c05965e:	f885 327d 	strb.w	r3, [r5, #637]	@ 0x27d
  if (serial != NULL)
 c059662:	b914      	cbnz	r4, c05966a <SE_GetSerial+0x42>
  return SE_OK;
 c059664:	2000      	movs	r0, #0
}
 c059666:	b013      	add	sp, #76	@ 0x4c
 c059668:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if (format == SE_SERIAL_FORMAT_RAW)
 c05966a:	b936      	cbnz	r6, c05967a <SE_GetSerial+0x52>
      memcpy(serial, se_ctx.serial, STSAFEA_ST_NUMBER_LENGTH);
 c05966c:	4b0d      	ldr	r3, [pc, #52]	@ (c0596a4 <SE_GetSerial+0x7c>)
 c05966e:	cb03      	ldmia	r3!, {r0, r1}
 c059670:	6020      	str	r0, [r4, #0]
 c059672:	6061      	str	r1, [r4, #4]
 c059674:	781b      	ldrb	r3, [r3, #0]
 c059676:	7223      	strb	r3, [r4, #8]
 c059678:	e7f4      	b.n	c059664 <SE_GetSerial+0x3c>
 c05967a:	4d0b      	ldr	r5, [pc, #44]	@ (c0596a8 <SE_GetSerial+0x80>)
        snprintf((char *)&serial[2 * i], 3, "%02X", se_ctx.serial[i]);
 c05967c:	4f0b      	ldr	r7, [pc, #44]	@ (c0596ac <SE_GetSerial+0x84>)
 c05967e:	f104 0612 	add.w	r6, r4, #18
 c059682:	4620      	mov	r0, r4
 c059684:	463a      	mov	r2, r7
 c059686:	2103      	movs	r1, #3
 c059688:	f815 3f01 	ldrb.w	r3, [r5, #1]!
      for (i = 0; i < STSAFEA_ST_NUMBER_LENGTH; i++)
 c05968c:	3402      	adds	r4, #2
        snprintf((char *)&serial[2 * i], 3, "%02X", se_ctx.serial[i]);
 c05968e:	f7e8 fec7 	bl	c042420 <sniprintf>
      for (i = 0; i < STSAFEA_ST_NUMBER_LENGTH; i++)
 c059692:	42b4      	cmp	r4, r6
 c059694:	d1f5      	bne.n	c059682 <SE_GetSerial+0x5a>
 c059696:	e7e5      	b.n	c059664 <SE_GetSerial+0x3c>
    return SE_INVALID_STATE_ERROR;
 c059698:	2002      	movs	r0, #2
 c05969a:	e7e4      	b.n	c059666 <SE_GetSerial+0x3e>
      return SE_COMMAND_ERROR;
 c05969c:	2001      	movs	r0, #1
 c05969e:	e7e2      	b.n	c059666 <SE_GetSerial+0x3e>
 c0596a0:	30031830 	.word	0x30031830
 c0596a4:	30031aa4 	.word	0x30031aa4
 c0596a8:	30031aa3 	.word	0x30031aa3
 c0596ac:	0c0611d8 	.word	0x0c0611d8

0c0596b0 <se_GetSerial>:
  ret = SE_GetSerial(NULL, SE_SERIAL_FORMAT_RAW);
 c0596b0:	2100      	movs	r1, #0
{
 c0596b2:	b538      	push	{r3, r4, r5, lr}
  se_ctx.init = 1;
 c0596b4:	2301      	movs	r3, #1
  uint8_t old = se_ctx.init;
 c0596b6:	4c05      	ldr	r4, [pc, #20]	@ (c0596cc <se_GetSerial+0x1c>)
  ret = SE_GetSerial(NULL, SE_SERIAL_FORMAT_RAW);
 c0596b8:	4608      	mov	r0, r1
  uint8_t old = se_ctx.init;
 c0596ba:	f894 5050 	ldrb.w	r5, [r4, #80]	@ 0x50
  se_ctx.init = 1;
 c0596be:	f884 3050 	strb.w	r3, [r4, #80]	@ 0x50
  ret = SE_GetSerial(NULL, SE_SERIAL_FORMAT_RAW);
 c0596c2:	f7ff ffb1 	bl	c059628 <SE_GetSerial>
  se_ctx.init = old;
 c0596c6:	f884 5050 	strb.w	r5, [r4, #80]	@ 0x50
}
 c0596ca:	bd38      	pop	{r3, r4, r5, pc}
 c0596cc:	30031830 	.word	0x30031830

0c0596d0 <SE_MemoryCheck>:
{
 c0596d0:	b510      	push	{r4, lr}
  if (se_ctx.init == 0)
 c0596d2:	4b10      	ldr	r3, [pc, #64]	@ (c059714 <SE_MemoryCheck+0x44>)
 c0596d4:	f893 4050 	ldrb.w	r4, [r3, #80]	@ 0x50
 c0596d8:	b1b4      	cbz	r4, c059708 <SE_MemoryCheck+0x38>
  if (region >= se_ctx.mapping_size)
 c0596da:	f8d3 4284 	ldr.w	r4, [r3, #644]	@ 0x284
 c0596de:	42a0      	cmp	r0, r4
 c0596e0:	d214      	bcs.n	c05970c <SE_MemoryCheck+0x3c>
  if (*size + offset > se_ctx.mapping[region].size)
 c0596e2:	f8d3 3280 	ldr.w	r3, [r3, #640]	@ 0x280
 c0596e6:	8814      	ldrh	r4, [r2, #0]
 c0596e8:	eb03 1000 	add.w	r0, r3, r0, lsl #4
 c0596ec:	8843      	ldrh	r3, [r0, #2]
 c0596ee:	440c      	add	r4, r1
 c0596f0:	429c      	cmp	r4, r3
 c0596f2:	dd0d      	ble.n	c059710 <SE_MemoryCheck+0x40>
    *size = se_ctx.mapping[region].size - offset;
 c0596f4:	1a59      	subs	r1, r3, r1
 c0596f6:	b289      	uxth	r1, r1
 c0596f8:	8011      	strh	r1, [r2, #0]
    if (se_ctx.mapping[region].type == 1)
 c0596fa:	7b03      	ldrb	r3, [r0, #12]
    return SE_PARAMS_UPDATED_ERROR;
 c0596fc:	2006      	movs	r0, #6
    if (se_ctx.mapping[region].type == 1)
 c0596fe:	2b01      	cmp	r3, #1
      *size += 4;
 c059700:	bf04      	itt	eq
 c059702:	3104      	addeq	r1, #4
 c059704:	8011      	strheq	r1, [r2, #0]
}
 c059706:	bd10      	pop	{r4, pc}
    return SE_INVALID_STATE_ERROR;
 c059708:	2002      	movs	r0, #2
 c05970a:	e7fc      	b.n	c059706 <SE_MemoryCheck+0x36>
    return SE_INVALID_PARAMS_ERROR;
 c05970c:	2003      	movs	r0, #3
 c05970e:	e7fa      	b.n	c059706 <SE_MemoryCheck+0x36>
  return SE_OK;
 c059710:	2000      	movs	r0, #0
 c059712:	e7f8      	b.n	c059706 <SE_MemoryCheck+0x36>
 c059714:	30031830 	.word	0x30031830

0c059718 <SE_Read>:
{
 c059718:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  if (se_ctx.init == 0)
 c05971c:	f8df 9128 	ldr.w	r9, [pc, #296]	@ c059848 <SE_Read+0x130>
{
 c059720:	b08b      	sub	sp, #44	@ 0x2c
 c059722:	9306      	str	r3, [sp, #24]
  if (se_ctx.init == 0)
 c059724:	f899 3050 	ldrb.w	r3, [r9, #80]	@ 0x50
{
 c059728:	4607      	mov	r7, r0
 c05972a:	468a      	mov	sl, r1
 c05972c:	4616      	mov	r6, r2
  if (se_ctx.init == 0)
 c05972e:	2b00      	cmp	r3, #0
 c059730:	f000 8088 	beq.w	c059844 <SE_Read+0x12c>
  SE_MAPPING_READ_LEVEL(region, auth);
 c059734:	f8d9 3280 	ldr.w	r3, [r9, #640]	@ 0x280
  uint16_t chunk_size = se_ctx.max_buffer_size;
 c059738:	f8b9 8272 	ldrh.w	r8, [r9, #626]	@ 0x272
  SE_MAPPING_READ_LEVEL(region, auth);
 c05973c:	f899 b264 	ldrb.w	fp, [r9, #612]	@ 0x264
 c059740:	b14b      	cbz	r3, c059756 <SE_Read+0x3e>
 c059742:	f8d9 2284 	ldr.w	r2, [r9, #644]	@ 0x284
 c059746:	4290      	cmp	r0, r2
 c059748:	d205      	bcs.n	c059756 <SE_Read+0x3e>
 c05974a:	eb03 1300 	add.w	r3, r3, r0, lsl #4
 c05974e:	791b      	ldrb	r3, [r3, #4]
 c059750:	b10b      	cbz	r3, c059756 <SE_Read+0x3e>
 c059752:	f04b 0ba0 	orr.w	fp, fp, #160	@ 0xa0
  uint16_t local_offset = 0;
 c059756:	2500      	movs	r5, #0
  SE_PRINTF("%s : region  %d, auth %x\n", __func__, region, auth);
 c059758:	463b      	mov	r3, r7
 c05975a:	2000      	movs	r0, #0
 c05975c:	4a3b      	ldr	r2, [pc, #236]	@ (c05984c <SE_Read+0x134>)
 c05975e:	493c      	ldr	r1, [pc, #240]	@ (c059850 <SE_Read+0x138>)
 c059760:	f8cd b000 	str.w	fp, [sp]
 c059764:	f7ff ff26 	bl	c0595b4 <se_printf>
  StSafeA_ResponseCode_t status_code = STSAFEA_OK;
 c059768:	462c      	mov	r4, r5
  while ((size >= se_ctx.max_buffer_size) && (status_code == STSAFEA_OK))
 c05976a:	f8b9 3272 	ldrh.w	r3, [r9, #626]	@ 0x272
 c05976e:	42b3      	cmp	r3, r6
 c059770:	d845      	bhi.n	c0597fe <SE_Read+0xe6>
 c059772:	b19c      	cbz	r4, c05979c <SE_Read+0x84>
    SE_PRINTF("%s : region  %d, offset %d, size %d error = %d\n", __func__, region, local_offset + offset, size,
 c059774:	4455      	add	r5, sl
 c059776:	463b      	mov	r3, r7
 c059778:	2000      	movs	r0, #0
 c05977a:	e9cd 6401 	strd	r6, r4, [sp, #4]
 c05977e:	4a33      	ldr	r2, [pc, #204]	@ (c05984c <SE_Read+0x134>)
 c059780:	4934      	ldr	r1, [pc, #208]	@ (c059854 <SE_Read+0x13c>)
 c059782:	9500      	str	r5, [sp, #0]
 c059784:	f7ff ff16 	bl	c0595b4 <se_printf>
    SE_PRINTF("%s : region  %d, input buffer = %p \n\r", __func__, region, buf);
 c059788:	9b06      	ldr	r3, [sp, #24]
 c05978a:	2000      	movs	r0, #0
 c05978c:	9300      	str	r3, [sp, #0]
 c05978e:	4a2f      	ldr	r2, [pc, #188]	@ (c05984c <SE_Read+0x134>)
 c059790:	463b      	mov	r3, r7
 c059792:	4931      	ldr	r1, [pc, #196]	@ (c059858 <SE_Read+0x140>)
 c059794:	f7ff ff0e 	bl	c0595b4 <se_printf>
  return SE_COMMAND_ERROR;
 c059798:	2401      	movs	r4, #1
 c05979a:	e03a      	b.n	c059812 <SE_Read+0xfa>
    status_code = StSafeA_Read(SE_HDL, 0, 0, STSAFEA_AC_ALWAYS, region, (uint16_t)(local_offset + offset),
 c05979c:	ab08      	add	r3, sp, #32
 c05979e:	e9cd 8303 	strd	r8, r3, [sp, #12]
 c0597a2:	eb05 030a 	add.w	r3, r5, sl
 c0597a6:	b29b      	uxth	r3, r3
 c0597a8:	4622      	mov	r2, r4
 c0597aa:	4621      	mov	r1, r4
 c0597ac:	e9cd 7300 	strd	r7, r3, [sp]
 c0597b0:	4825      	ldr	r0, [pc, #148]	@ (c059848 <SE_Read+0x130>)
 c0597b2:	4623      	mov	r3, r4
 c0597b4:	f8cd b014 	str.w	fp, [sp, #20]
 c0597b8:	f8cd 8008 	str.w	r8, [sp, #8]
 c0597bc:	f000 fc94 	bl	c05a0e8 <StSafeA_Read>
    if (status_code == STSAFEA_OK)
 c0597c0:	4604      	mov	r4, r0
 c0597c2:	b990      	cbnz	r0, c0597ea <SE_Read+0xd2>
      memcpy(buf + local_offset, sts_read.Data, sts_read.Length);
 c0597c4:	9b06      	ldr	r3, [sp, #24]
 c0597c6:	9909      	ldr	r1, [sp, #36]	@ 0x24
 c0597c8:	1958      	adds	r0, r3, r5
 c0597ca:	f8bd 2020 	ldrh.w	r2, [sp, #32]
 c0597ce:	9107      	str	r1, [sp, #28]
 c0597d0:	f001 ff3c 	bl	c05b64c <memcpy>
      sts_read.Data += chunk_size;
 c0597d4:	9907      	ldr	r1, [sp, #28]
      size -= chunk_size;
 c0597d6:	eba6 0608 	sub.w	r6, r6, r8
 c0597da:	b2b6      	uxth	r6, r6
      sts_read.Data += chunk_size;
 c0597dc:	4441      	add	r1, r8
      local_offset += chunk_size;
 c0597de:	4445      	add	r5, r8
      sts_read.Data += chunk_size;
 c0597e0:	9109      	str	r1, [sp, #36]	@ 0x24
      sts_read.Length = size;
 c0597e2:	f8ad 6020 	strh.w	r6, [sp, #32]
      local_offset += chunk_size;
 c0597e6:	b2ad      	uxth	r5, r5
 c0597e8:	e7bf      	b.n	c05976a <SE_Read+0x52>
      SE_PRINTF("%s : region  %d, offset %d, size %d error = %d\n", __func__, region, local_offset,
 c0597ea:	e9cd 8001 	strd	r8, r0, [sp, #4]
 c0597ee:	463b      	mov	r3, r7
 c0597f0:	2000      	movs	r0, #0
 c0597f2:	4a16      	ldr	r2, [pc, #88]	@ (c05984c <SE_Read+0x134>)
 c0597f4:	4917      	ldr	r1, [pc, #92]	@ (c059854 <SE_Read+0x13c>)
 c0597f6:	9500      	str	r5, [sp, #0]
 c0597f8:	f7ff fedc 	bl	c0595b4 <se_printf>
 c0597fc:	e7b5      	b.n	c05976a <SE_Read+0x52>
  if ((status_code == STSAFEA_OK) && (size != 0))
 c0597fe:	2c00      	cmp	r4, #0
 c059800:	d1b8      	bne.n	c059774 <SE_Read+0x5c>
 c059802:	b956      	cbnz	r6, c05981a <SE_Read+0x102>
    memcpy(buf + local_offset, sts_read.Data, sts_read.Length);
 c059804:	9806      	ldr	r0, [sp, #24]
 c059806:	f8bd 2020 	ldrh.w	r2, [sp, #32]
 c05980a:	9909      	ldr	r1, [sp, #36]	@ 0x24
 c05980c:	4428      	add	r0, r5
 c05980e:	f001 ff1d 	bl	c05b64c <memcpy>
}
 c059812:	4620      	mov	r0, r4
 c059814:	b00b      	add	sp, #44	@ 0x2c
 c059816:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    status_code = StSafeA_Read(SE_HDL, 0, 0, 0, region, local_offset + offset, size, size, &sts_read, auth);
 c05981a:	ab08      	add	r3, sp, #32
 c05981c:	e9cd 6303 	strd	r6, r3, [sp, #12]
 c059820:	eb05 030a 	add.w	r3, r5, sl
 c059824:	b29b      	uxth	r3, r3
 c059826:	e9cd 7300 	strd	r7, r3, [sp]
 c05982a:	4622      	mov	r2, r4
 c05982c:	4623      	mov	r3, r4
 c05982e:	4621      	mov	r1, r4
 c059830:	4805      	ldr	r0, [pc, #20]	@ (c059848 <SE_Read+0x130>)
 c059832:	f8cd b014 	str.w	fp, [sp, #20]
 c059836:	9602      	str	r6, [sp, #8]
 c059838:	f000 fc56 	bl	c05a0e8 <StSafeA_Read>
  if (status_code == STSAFEA_OK)
 c05983c:	2800      	cmp	r0, #0
 c05983e:	d0e1      	beq.n	c059804 <SE_Read+0xec>
 c059840:	4604      	mov	r4, r0
 c059842:	e797      	b.n	c059774 <SE_Read+0x5c>
    return SE_INVALID_STATE_ERROR;
 c059844:	2402      	movs	r4, #2
 c059846:	e7e4      	b.n	c059812 <SE_Read+0xfa>
 c059848:	30031830 	.word	0x30031830
 c05984c:	0c06139a 	.word	0x0c06139a
 c059850:	0c0611dd 	.word	0x0c0611dd
 c059854:	0c0611f7 	.word	0x0c0611f7
 c059858:	0c061227 	.word	0x0c061227

0c05985c <se_GetAutoConfig.isra.0>:
static SE_API_Status_t se_GetAutoConfig(void)
 c05985c:	b510      	push	{r4, lr}
  ret = SE_Read(SE_AUTO.region, SE_AUTO.key_offset, 1, &se_ctx.active_key);
 c05985e:	4c0b      	ldr	r4, [pc, #44]	@ (c05988c <se_GetAutoConfig.isra.0+0x30>)
 c059860:	2201      	movs	r2, #1
 c059862:	f8b4 128a 	ldrh.w	r1, [r4, #650]	@ 0x28a
 c059866:	f894 0288 	ldrb.w	r0, [r4, #648]	@ 0x288
 c05986a:	f204 2362 	addw	r3, r4, #610	@ 0x262
 c05986e:	f7ff ff53 	bl	c059718 <SE_Read>
  if (ret != SE_OK)
 c059872:	b950      	cbnz	r0, c05988a <se_GetAutoConfig.isra.0+0x2e>
  ret = SE_Read(SE_AUTO.region, SE_AUTO.cert_offset, 1, &se_ctx.active_certificate);
 c059874:	f8b4 128c 	ldrh.w	r1, [r4, #652]	@ 0x28c
 c059878:	f894 0288 	ldrb.w	r0, [r4, #648]	@ 0x288
 c05987c:	f204 2363 	addw	r3, r4, #611	@ 0x263
 c059880:	2201      	movs	r2, #1
}
 c059882:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  ret = SE_Read(SE_AUTO.region, SE_AUTO.cert_offset, 1, &se_ctx.active_certificate);
 c059886:	f7ff bf47 	b.w	c059718 <SE_Read>
}
 c05988a:	bd10      	pop	{r4, pc}
 c05988c:	30031830 	.word	0x30031830

0c059890 <SE_Init>:
{
 c059890:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if (se_ctx.init == 1)
 c059894:	4d8b      	ldr	r5, [pc, #556]	@ (c059ac4 <SE_Init+0x234>)
{
 c059896:	4680      	mov	r8, r0
  if (se_ctx.init == 1)
 c059898:	f895 3050 	ldrb.w	r3, [r5, #80]	@ 0x50
{
 c05989c:	460f      	mov	r7, r1
  if (se_ctx.init == 1)
 c05989e:	2b01      	cmp	r3, #1
{
 c0598a0:	4614      	mov	r4, r2
 c0598a2:	b09c      	sub	sp, #112	@ 0x70
  if (se_ctx.init == 1)
 c0598a4:	f000 80f4 	beq.w	c059a90 <SE_Init+0x200>
  SE_AUTO.cert_offset = SE_AUTO_MANAGED_ACTIVE_CERTIFICATE_DEFAULT;
 c0598a8:	f240 23bb 	movw	r3, #699	@ 0x2bb
 c0598ac:	f8a5 328c 	strh.w	r3, [r5, #652]	@ 0x28c
  SE_AUTO.key_offset = SE_AUTO_MANAGED_ACTIVE_KEY_DEFAULT;
 c0598b0:	f240 23ba 	movw	r3, #698	@ 0x2ba
 c0598b4:	f8a5 328a 	strh.w	r3, [r5, #650]	@ 0x28a
  se_ctx.cmd_params[SE_CMD_WRAP][SE_AUTH_PARAM] = WRAP_CMD_MAC;
 c0598b8:	23a0      	movs	r3, #160	@ 0xa0
 c0598ba:	f885 3265 	strb.w	r3, [r5, #613]	@ 0x265
  se_ctx.cmd_params[SE_CMD_WRAP][SE_ENC_PARAM] = WRAP_CMD_ENC;
 c0598be:	f24a 0302 	movw	r3, #40962	@ 0xa002
  se_ctx.cmd_params[SE_CMD_SIG][SE_ENC_PARAM] = STSAFEA_ENCRYPTION_NONE;
 c0598c2:	2000      	movs	r0, #0
  se_ctx.cmd_params[SE_CMD_WRAP][SE_ENC_PARAM] = WRAP_CMD_ENC;
 c0598c4:	f8a5 3266 	strh.w	r3, [r5, #614]	@ 0x266
  SE_AUTO.region = SE_AUTO_MANAGEMENT_REGION_DEFAULT;
 c0598c8:	2601      	movs	r6, #1
  se_ctx.cmd_params[SE_CMD_SIG][SE_ENC_PARAM] = STSAFEA_ENCRYPTION_NONE;
 c0598ca:	f24a 0301 	movw	r3, #40961	@ 0xa001
  SE_PRINTF("Starting STSAFE-A110 : ");
 c0598ce:	497e      	ldr	r1, [pc, #504]	@ (c059ac8 <SE_Init+0x238>)
  se_ctx.cmd_params[SE_CMD_SIG][SE_ENC_PARAM] = STSAFEA_ENCRYPTION_NONE;
 c0598d0:	e9c5 309a 	strd	r3, r0, [r5, #616]	@ 0x268
  se_ctx.cmd_params[SE_CMD_GEN_KEY_EPHEMERAL][SE_ENC_PARAM] = STSAFEA_ENCRYPTION_NONE;
 c0598d4:	f885 0270 	strb.w	r0, [r5, #624]	@ 0x270
  se_ctx.serial_loaded = 0;
 c0598d8:	f885 027d 	strb.w	r0, [r5, #637]	@ 0x27d
  SE_AUTO.region = SE_AUTO_MANAGEMENT_REGION_DEFAULT;
 c0598dc:	f885 6288 	strb.w	r6, [r5, #648]	@ 0x288
  SE_PRINTF("Starting STSAFE-A110 : ");
 c0598e0:	f7ff fe68 	bl	c0595b4 <se_printf>
  status_code = StSafeA_Init(SE_HDL, se_ctx.a_rx_tx_se_data);
 c0598e4:	4628      	mov	r0, r5
 c0598e6:	f105 0151 	add.w	r1, r5, #81	@ 0x51
 c0598ea:	f000 faf8 	bl	c059ede <StSafeA_Init>
  if (status_code != STSAFEA_OK)
 c0598ee:	4602      	mov	r2, r0
 c0598f0:	b128      	cbz	r0, c0598fe <SE_Init+0x6e>
    SE_PRINTF_RES("KO *** Unable to start STSAFE-A110 0x%x"ENDL, status_code);
 c0598f2:	4976      	ldr	r1, [pc, #472]	@ (c059acc <SE_Init+0x23c>)
    SE_PRINTF_RES("KO *** Set pairing key 0x%x"ENDL, status_code);
 c0598f4:	2001      	movs	r0, #1
 c0598f6:	f7ff fe5d 	bl	c0595b4 <se_printf>
  SE_API_Status_t ret = SE_COMMAND_ERROR;
 c0598fa:	2401      	movs	r4, #1
 c0598fc:	e014      	b.n	c059928 <SE_Init+0x98>
  if (i2c_addr != 0)
 c0598fe:	b114      	cbz	r4, c059906 <SE_Init+0x76>
    StSafeA_Set_I2C_Address(i2c_addr);
 c059900:	b2e0      	uxtb	r0, r4
 c059902:	f7f7 fbd3 	bl	c0510ac <StSafeA_Set_I2C_Address>
  SE_PRINTF_RES("OK" ENDL);
 c059906:	2001      	movs	r0, #1
 c059908:	4971      	ldr	r1, [pc, #452]	@ (c059ad0 <SE_Init+0x240>)
 c05990a:	f7ff fe53 	bl	c0595b4 <se_printf>
  SE_PRINTF("Get Serial :");
 c05990e:	2000      	movs	r0, #0
 c059910:	4970      	ldr	r1, [pc, #448]	@ (c059ad4 <SE_Init+0x244>)
 c059912:	f7ff fe4f 	bl	c0595b4 <se_printf>
  ret = se_GetSerial();
 c059916:	f7ff fecb 	bl	c0596b0 <se_GetSerial>
  if (ret != SE_OK)
 c05991a:	4604      	mov	r4, r0
 c05991c:	b140      	cbz	r0, c059930 <SE_Init+0xa0>
    SE_PRINTF_RES("KO *** Unable to get serial 0x%x"ENDL, ret);
 c05991e:	4602      	mov	r2, r0
 c059920:	496d      	ldr	r1, [pc, #436]	@ (c059ad8 <SE_Init+0x248>)
 c059922:	2001      	movs	r0, #1
 c059924:	f7ff fe46 	bl	c0595b4 <se_printf>
}
 c059928:	4620      	mov	r0, r4
 c05992a:	b01c      	add	sp, #112	@ 0x70
 c05992c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  SE_PRINTF_RES("OK"ENDL);
 c059930:	2001      	movs	r0, #1
 c059932:	4967      	ldr	r1, [pc, #412]	@ (c059ad0 <SE_Init+0x240>)
 c059934:	f7ff fe3e 	bl	c0595b4 <se_printf>
  SE_PRINTF("Set Crypto Keys : ");
 c059938:	4620      	mov	r0, r4
 c05993a:	4968      	ldr	r1, [pc, #416]	@ (c059adc <SE_Init+0x24c>)
 c05993c:	f7ff fe3a 	bl	c0595b4 <se_printf>
  status_code = StSafeA_Crypto_GetKeys(se_ctx.serial, sizeof(se_ctx.serial));
 c059940:	2109      	movs	r1, #9
 c059942:	4867      	ldr	r0, [pc, #412]	@ (c059ae0 <SE_Init+0x250>)
 c059944:	f7f7 f980 	bl	c050c48 <StSafeA_Crypto_GetKeys>
  if (status_code != STSAFEA_OK)
 c059948:	4602      	mov	r2, r0
 c05994a:	b108      	cbz	r0, c059950 <SE_Init+0xc0>
    SE_PRINTF_RES("KO *** Set pairing key 0x%x"ENDL, status_code);
 c05994c:	4965      	ldr	r1, [pc, #404]	@ (c059ae4 <SE_Init+0x254>)
 c05994e:	e7d1      	b.n	c0598f4 <SE_Init+0x64>
  SE_PRINTF_RES("OK"ENDL);
 c059950:	2001      	movs	r0, #1
 c059952:	495f      	ldr	r1, [pc, #380]	@ (c059ad0 <SE_Init+0x240>)
 c059954:	f7ff fe2e 	bl	c0595b4 <se_printf>
  ret = se_GetKeySize();
 c059958:	f7ff fcc8 	bl	c0592ec <se_GetKeySize>
  if (ret != SE_OK)
 c05995c:	4604      	mov	r4, r0
 c05995e:	b110      	cbz	r0, c059966 <SE_Init+0xd6>
    if (ret == SE_INVALID_STATE_ERROR)
 c059960:	2802      	cmp	r0, #2
 c059962:	d1ca      	bne.n	c0598fa <SE_Init+0x6a>
      locked = 1;
 c059964:	2401      	movs	r4, #1
  se_ctx.max_buffer_size = (STSAFEA_BUFFER_DATA_CONTENT_SIZE == 500 ? 496 : STSAFEA_BUFFER_DATA_CONTENT_SIZE);
 c059966:	f44f 73fc 	mov.w	r3, #504	@ 0x1f8
  se_ctx.init = 1;
 c05996a:	2601      	movs	r6, #1
  se_ctx.max_buffer_size = (STSAFEA_BUFFER_DATA_CONTENT_SIZE == 500 ? 496 : STSAFEA_BUFFER_DATA_CONTENT_SIZE);
 c05996c:	f8a5 3272 	strh.w	r3, [r5, #626]	@ 0x272
  se_ctx.init = 1;
 c059970:	f885 6050 	strb.w	r6, [r5, #80]	@ 0x50
  if (locked == 0)
 c059974:	bb64      	cbnz	r4, c0599d0 <SE_Init+0x140>
    se_GetCommandConfig();
 c059976:	f7ff fdd3 	bl	c059520 <se_GetCommandConfig.isra.0>
    if (flag & SE_INIT_TEST_PAIRING)
 c05997a:	f018 0f02 	tst.w	r8, #2
 c05997e:	d010      	beq.n	c0599a2 <SE_Init+0x112>
      SE_PRINTF("Stsafe Testing pairing keys : ");
 c059980:	4620      	mov	r0, r4
 c059982:	4959      	ldr	r1, [pc, #356]	@ (c059ae8 <SE_Init+0x258>)
 c059984:	f7ff fe16 	bl	c0595b4 <se_printf>
  if (slot > 1)
 c059988:	2208      	movs	r2, #8
 c05998a:	4669      	mov	r1, sp
 c05998c:	4620      	mov	r0, r4
 c05998e:	ab04      	add	r3, sp, #16
 c059990:	f7ff fd48 	bl	c059424 <SE_Wrap.part.0>
      if (ret != SE_OK)
 c059994:	2800      	cmp	r0, #0
 c059996:	d07d      	beq.n	c059a94 <SE_Init+0x204>
        SE_PRINTF_RES("KO *** Unable to wrap envelop with STSAFE-A110 0x%x"ENDL, status_code);
 c059998:	4622      	mov	r2, r4
 c05999a:	4954      	ldr	r1, [pc, #336]	@ (c059aec <SE_Init+0x25c>)
        SE_PRINTF_RES("KO *** Unable to unwrap envelop with STSAFE-A110 0x%x"ENDL, status_code);
 c05999c:	4630      	mov	r0, r6
 c05999e:	f7ff fe09 	bl	c0595b4 <se_printf>
    ret = SE_SetSecurity(sec_level);
 c0599a2:	4638      	mov	r0, r7
 c0599a4:	f7ff fe2e 	bl	c059604 <SE_SetSecurity>
    if (ret != SE_OK)
 c0599a8:	4604      	mov	r4, r0
 c0599aa:	2800      	cmp	r0, #0
 c0599ac:	d1bc      	bne.n	c059928 <SE_Init+0x98>
    se_GetAutoConfig();
 c0599ae:	f7ff ff55 	bl	c05985c <se_GetAutoConfig.isra.0>
    ret = se_GetMapping(se_ctx.mapping, &se_ctx.mapping_size);
 c0599b2:	f8d5 0280 	ldr.w	r0, [r5, #640]	@ 0x280
 c0599b6:	f7ff fd5b 	bl	c059470 <se_GetMapping.constprop.0>
    if (ret == SE_OK)
 c0599ba:	b948      	cbnz	r0, c0599d0 <SE_Init+0x140>
      se_ctx.mapping = malloc(se_ctx.mapping_size * sizeof(SE_Region_t));
 c0599bc:	f8d5 0284 	ldr.w	r0, [r5, #644]	@ 0x284
 c0599c0:	0100      	lsls	r0, r0, #4
 c0599c2:	f7e8 fb9b 	bl	c0420fc <malloc>
 c0599c6:	f8c5 0280 	str.w	r0, [r5, #640]	@ 0x280
      if (se_ctx.mapping != NULL)
 c0599ca:	b108      	cbz	r0, c0599d0 <SE_Init+0x140>
        ret = se_GetMapping(se_ctx.mapping, &se_ctx.mapping_size);
 c0599cc:	f7ff fd50 	bl	c059470 <se_GetMapping.constprop.0>
  ret = SE_Read(0, offset, 2, header);
 c0599d0:	2202      	movs	r2, #2
 c0599d2:	211a      	movs	r1, #26
 c0599d4:	2000      	movs	r0, #0
 c0599d6:	ab02      	add	r3, sp, #8
 c0599d8:	f7ff fe9e 	bl	c059718 <SE_Read>
  if (ret != SE_OK)
 c0599dc:	4604      	mov	r4, r0
 c0599de:	2800      	cmp	r0, #0
 c0599e0:	d1a2      	bne.n	c059928 <SE_Init+0x98>
  offset += 2 + header[1];
 c0599e2:	f89d 6009 	ldrb.w	r6, [sp, #9]
  ret = SE_Read(0, offset, 2, header);
 c0599e6:	2202      	movs	r2, #2
  offset += 2 + header[1];
 c0599e8:	361c      	adds	r6, #28
  ret = SE_Read(0, offset, 2, header);
 c0599ea:	4631      	mov	r1, r6
 c0599ec:	ab02      	add	r3, sp, #8
 c0599ee:	f7ff fe93 	bl	c059718 <SE_Read>
  if (ret != SE_OK)
 c0599f2:	4604      	mov	r4, r0
 c0599f4:	2800      	cmp	r0, #0
 c0599f6:	d197      	bne.n	c059928 <SE_Init+0x98>
  offset += 2 + header[1];
 c0599f8:	f89d 3009 	ldrb.w	r3, [sp, #9]
  ret = SE_Read(0, offset, 2, header);
 c0599fc:	2202      	movs	r2, #2
  offset += 2 + header[1];
 c0599fe:	3302      	adds	r3, #2
 c059a00:	441e      	add	r6, r3
  ret = SE_Read(0, offset, 2, header);
 c059a02:	4631      	mov	r1, r6
 c059a04:	ab02      	add	r3, sp, #8
 c059a06:	f7ff fe87 	bl	c059718 <SE_Read>
  if (ret != SE_OK)
 c059a0a:	4604      	mov	r4, r0
 c059a0c:	2800      	cmp	r0, #0
 c059a0e:	d18b      	bne.n	c059928 <SE_Init+0x98>
  offset += 2 + header[1];
 c059a10:	f89d 3009 	ldrb.w	r3, [sp, #9]
  ret = SE_Read(0, offset, 2, header);
 c059a14:	2202      	movs	r2, #2
  offset += 2 + header[1];
 c059a16:	3302      	adds	r3, #2
 c059a18:	441e      	add	r6, r3
  ret = SE_Read(0, offset, 2, header);
 c059a1a:	4631      	mov	r1, r6
 c059a1c:	ab02      	add	r3, sp, #8
 c059a1e:	f7ff fe7b 	bl	c059718 <SE_Read>
  if (ret != SE_OK)
 c059a22:	4604      	mov	r4, r0
 c059a24:	2800      	cmp	r0, #0
 c059a26:	f47f af7f 	bne.w	c059928 <SE_Init+0x98>
  offset += 4 + header[1];
 c059a2a:	f89d 3009 	ldrb.w	r3, [sp, #9]
  ret = SE_Read(0, offset, 2, header);
 c059a2e:	2202      	movs	r2, #2
  offset += 4 + header[1];
 c059a30:	3304      	adds	r3, #4
 c059a32:	441e      	add	r6, r3
  ret = SE_Read(0, offset, 2, header);
 c059a34:	4631      	mov	r1, r6
 c059a36:	ab02      	add	r3, sp, #8
 c059a38:	f7ff fe6e 	bl	c059718 <SE_Read>
  if (ret != SE_OK)
 c059a3c:	4604      	mov	r4, r0
 c059a3e:	2800      	cmp	r0, #0
 c059a40:	f47f af72 	bne.w	c059928 <SE_Init+0x98>
  ret = SE_Read(0, offset, 2, header);
 c059a44:	2202      	movs	r2, #2
  offset += 2 + header[1];
 c059a46:	f89d 3009 	ldrb.w	r3, [sp, #9]
 c059a4a:	441e      	add	r6, r3
  ret = SE_Read(0, offset, 2, header);
 c059a4c:	18b1      	adds	r1, r6, r2
 c059a4e:	ab02      	add	r3, sp, #8
 c059a50:	f7ff fe62 	bl	c059718 <SE_Read>
  if (ret != SE_OK)
 c059a54:	4604      	mov	r4, r0
 c059a56:	2800      	cmp	r0, #0
 c059a58:	f47f af66 	bne.w	c059928 <SE_Init+0x98>
  ret = SE_Read(0, offset, header[1] - 2, pub_key);
 c059a5c:	f89d 2009 	ldrb.w	r2, [sp, #9]
 c059a60:	ab04      	add	r3, sp, #16
 c059a62:	3a02      	subs	r2, #2
 c059a64:	b292      	uxth	r2, r2
 c059a66:	1db1      	adds	r1, r6, #6
 c059a68:	f7ff fe56 	bl	c059718 <SE_Read>
  if (ret != SE_OK)
 c059a6c:	4604      	mov	r4, r0
 c059a6e:	2800      	cmp	r0, #0
 c059a70:	f47f af5a 	bne.w	c059928 <SE_Init+0x98>
  memcpy(se_ctx.fixed_pub_keys[0].public_key_x, pub_key, se_ctx.slot0_key_size / 8);
 c059a74:	f8b5 425c 	ldrh.w	r4, [r5, #604]	@ 0x25c
 c059a78:	a904      	add	r1, sp, #16
 c059a7a:	08e4      	lsrs	r4, r4, #3
 c059a7c:	4622      	mov	r2, r4
 c059a7e:	481c      	ldr	r0, [pc, #112]	@ (c059af0 <SE_Init+0x260>)
 c059a80:	f001 fde4 	bl	c05b64c <memcpy>
  memcpy(se_ctx.fixed_pub_keys[0].public_key_y, &pub_key[se_ctx.slot0_key_size / 8], se_ctx.slot0_key_size / 8);
 c059a84:	ab04      	add	r3, sp, #16
 c059a86:	4622      	mov	r2, r4
 c059a88:	481a      	ldr	r0, [pc, #104]	@ (c059af4 <SE_Init+0x264>)
 c059a8a:	1919      	adds	r1, r3, r4
 c059a8c:	f001 fdde 	bl	c05b64c <memcpy>
    return SE_OK;
 c059a90:	2400      	movs	r4, #0
 c059a92:	e749      	b.n	c059928 <SE_Init+0x98>
  if (slot > 1)
 c059a94:	2210      	movs	r2, #16
 c059a96:	ab02      	add	r3, sp, #8
 c059a98:	eb0d 0102 	add.w	r1, sp, r2
 c059a9c:	f7ff fc9c 	bl	c0593d8 <SE_Unwrap.part.0>
      if (ret != SE_OK)
 c059aa0:	b110      	cbz	r0, c059aa8 <SE_Init+0x218>
        SE_PRINTF_RES("KO *** Unable to unwrap envelop with STSAFE-A110 0x%x"ENDL, status_code);
 c059aa2:	4622      	mov	r2, r4
 c059aa4:	4914      	ldr	r1, [pc, #80]	@ (c059af8 <SE_Init+0x268>)
 c059aa6:	e779      	b.n	c05999c <SE_Init+0x10c>
      if (memcmp(data, clear_data, sizeof(data)) == 0)
 c059aa8:	2208      	movs	r2, #8
 c059aaa:	4668      	mov	r0, sp
 c059aac:	eb0d 0102 	add.w	r1, sp, r2
 c059ab0:	f001 fdbc 	bl	c05b62c <memcmp>
 c059ab4:	b920      	cbnz	r0, c059ac0 <SE_Init+0x230>
        SE_PRINTF_RES("OK"ENDL);
 c059ab6:	4906      	ldr	r1, [pc, #24]	@ (c059ad0 <SE_Init+0x240>)
        SE_PRINTF_RES("KO data does not match"ENDL);
 c059ab8:	4630      	mov	r0, r6
 c059aba:	f7ff fd7b 	bl	c0595b4 <se_printf>
 c059abe:	e770      	b.n	c0599a2 <SE_Init+0x112>
 c059ac0:	490e      	ldr	r1, [pc, #56]	@ (c059afc <SE_Init+0x26c>)
 c059ac2:	e7f9      	b.n	c059ab8 <SE_Init+0x228>
 c059ac4:	30031830 	.word	0x30031830
 c059ac8:	0c06124d 	.word	0x0c06124d
 c059acc:	0c061265 	.word	0x0c061265
 c059ad0:	0c0611c5 	.word	0x0c0611c5
 c059ad4:	0c06128f 	.word	0x0c06128f
 c059ad8:	0c06129c 	.word	0x0c06129c
 c059adc:	0c0612bf 	.word	0x0c0612bf
 c059ae0:	30031aa4 	.word	0x30031aa4
 c059ae4:	0c0612d2 	.word	0x0c0612d2
 c059ae8:	0c0612f0 	.word	0x0c0612f0
 c059aec:	0c06130f 	.word	0x0c06130f
 c059af0:	30031cc5 	.word	0x30031cc5
 c059af4:	30031cf5 	.word	0x30031cf5
 c059af8:	0c061345 	.word	0x0c061345
 c059afc:	0c06137d 	.word	0x0c06137d

0c059b00 <SE_Update>:
{
 c059b00:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c059b04:	4614      	mov	r4, r2
  SE_MAPPING_UPDATE_LEVEL(region, auth);
 c059b06:	4a2d      	ldr	r2, [pc, #180]	@ (c059bbc <SE_Update+0xbc>)
{
 c059b08:	4688      	mov	r8, r1
  SE_MAPPING_UPDATE_LEVEL(region, auth);
 c059b0a:	f8d2 1280 	ldr.w	r1, [r2, #640]	@ 0x280
{
 c059b0e:	4606      	mov	r6, r0
  SE_MAPPING_UPDATE_LEVEL(region, auth);
 c059b10:	f892 9264 	ldrb.w	r9, [r2, #612]	@ 0x264
{
 c059b14:	b089      	sub	sp, #36	@ 0x24
  SE_MAPPING_UPDATE_LEVEL(region, auth);
 c059b16:	b149      	cbz	r1, c059b2c <SE_Update+0x2c>
 c059b18:	f8d2 0284 	ldr.w	r0, [r2, #644]	@ 0x284
 c059b1c:	4286      	cmp	r6, r0
 c059b1e:	d205      	bcs.n	c059b2c <SE_Update+0x2c>
 c059b20:	eb01 1106 	add.w	r1, r1, r6, lsl #4
 c059b24:	7989      	ldrb	r1, [r1, #6]
 c059b26:	b109      	cbz	r1, c059b2c <SE_Update+0x2c>
 c059b28:	f049 09a0 	orr.w	r9, r9, #160	@ 0xa0
  if (se_ctx.init == 0)
 c059b2c:	f892 1050 	ldrb.w	r1, [r2, #80]	@ 0x50
 c059b30:	2900      	cmp	r1, #0
 c059b32:	d03e      	beq.n	c059bb2 <SE_Update+0xb2>
  uint16_t local_offset = 0;
 c059b34:	2500      	movs	r5, #0
  uint16_t chunk_size = se_ctx.max_buffer_size;
 c059b36:	f8b2 7272 	ldrh.w	r7, [r2, #626]	@ 0x272
    status_code = StSafeA_Update(SE_HDL, 0, 0, 0, 0, region, local_offset + offset, &in_data, auth);
 c059b3a:	f10d 0b18 	add.w	fp, sp, #24
      in_data.Data += chunk_size;
 c059b3e:	9307      	str	r3, [sp, #28]
 c059b40:	2300      	movs	r3, #0
    status_code = StSafeA_Update(SE_HDL, 0, 0, 0, 0, region, local_offset + offset, &in_data, auth);
 c059b42:	eb05 0a08 	add.w	sl, r5, r8
 c059b46:	fa1f fa8a 	uxth.w	sl, sl
  while ((size >= chunk_size) && (status_code == STSAFEA_OK))
 c059b4a:	42bc      	cmp	r4, r7
 c059b4c:	d318      	bcc.n	c059b80 <SE_Update+0x80>
 c059b4e:	b10b      	cbz	r3, c059b54 <SE_Update+0x54>
  return SE_COMMAND_ERROR;
 c059b50:	2001      	movs	r0, #1
 c059b52:	e02b      	b.n	c059bac <SE_Update+0xac>
    status_code = StSafeA_Update(SE_HDL, 0, 0, 0, 0, region, local_offset + offset, &in_data, auth);
 c059b54:	461a      	mov	r2, r3
 c059b56:	4619      	mov	r1, r3
 c059b58:	9300      	str	r3, [sp, #0]
 c059b5a:	e9cd b903 	strd	fp, r9, [sp, #12]
 c059b5e:	e9cd 6a01 	strd	r6, sl, [sp, #4]
 c059b62:	4816      	ldr	r0, [pc, #88]	@ (c059bbc <SE_Update+0xbc>)
    in_data.Length = chunk_size;
 c059b64:	f8ad 7018 	strh.w	r7, [sp, #24]
    status_code = StSafeA_Update(SE_HDL, 0, 0, 0, 0, region, local_offset + offset, &in_data, auth);
 c059b68:	f000 fb62 	bl	c05a230 <StSafeA_Update>
    if (status_code == STSAFEA_OK)
 c059b6c:	4603      	mov	r3, r0
 c059b6e:	2800      	cmp	r0, #0
 c059b70:	d1eb      	bne.n	c059b4a <SE_Update+0x4a>
      in_data.Data += chunk_size;
 c059b72:	9b07      	ldr	r3, [sp, #28]
      size -= chunk_size;
 c059b74:	1be4      	subs	r4, r4, r7
      local_offset += chunk_size;
 c059b76:	443d      	add	r5, r7
      size -= chunk_size;
 c059b78:	b2a4      	uxth	r4, r4
      local_offset += chunk_size;
 c059b7a:	b2ad      	uxth	r5, r5
      in_data.Data += chunk_size;
 c059b7c:	443b      	add	r3, r7
 c059b7e:	e7de      	b.n	c059b3e <SE_Update+0x3e>
  if ((status_code == STSAFEA_OK) && (size != 0))
 c059b80:	2b00      	cmp	r3, #0
 c059b82:	d1e5      	bne.n	c059b50 <SE_Update+0x50>
 c059b84:	b1bc      	cbz	r4, c059bb6 <SE_Update+0xb6>
    status_code = StSafeA_Update(SE_HDL, 0, 0, 0, 0, region, local_offset + offset, &in_data, auth);
 c059b86:	4445      	add	r5, r8
 c059b88:	aa06      	add	r2, sp, #24
 c059b8a:	b2ad      	uxth	r5, r5
 c059b8c:	9203      	str	r2, [sp, #12]
 c059b8e:	4619      	mov	r1, r3
 c059b90:	461a      	mov	r2, r3
 c059b92:	e9cd 6501 	strd	r6, r5, [sp, #4]
 c059b96:	4809      	ldr	r0, [pc, #36]	@ (c059bbc <SE_Update+0xbc>)
 c059b98:	f8cd 9010 	str.w	r9, [sp, #16]
 c059b9c:	9300      	str	r3, [sp, #0]
    in_data.Length = size;
 c059b9e:	f8ad 4018 	strh.w	r4, [sp, #24]
    status_code = StSafeA_Update(SE_HDL, 0, 0, 0, 0, region, local_offset + offset, &in_data, auth);
 c059ba2:	f000 fb45 	bl	c05a230 <StSafeA_Update>
  if (status_code == STSAFEA_OK)
 c059ba6:	3800      	subs	r0, #0
 c059ba8:	bf18      	it	ne
 c059baa:	2001      	movne	r0, #1
}
 c059bac:	b009      	add	sp, #36	@ 0x24
 c059bae:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    return SE_INVALID_STATE_ERROR;
 c059bb2:	2002      	movs	r0, #2
 c059bb4:	e7fa      	b.n	c059bac <SE_Update+0xac>
    return SE_OK;
 c059bb6:	4620      	mov	r0, r4
 c059bb8:	e7f8      	b.n	c059bac <SE_Update+0xac>
 c059bba:	bf00      	nop
 c059bbc:	30031830 	.word	0x30031830

0c059bc0 <SE_GenerateKeyPair>:
{
 c059bc0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 c059bc4:	2903      	cmp	r1, #3
 c059bc6:	4690      	mov	r8, r2
 c059bc8:	461f      	mov	r7, r3
 c059bca:	b08e      	sub	sp, #56	@ 0x38
 c059bcc:	d858      	bhi.n	c059c80 <SE_GenerateKeyPair+0xc0>
 c059bce:	4b2d      	ldr	r3, [pc, #180]	@ (c059c84 <SE_GenerateKeyPair+0xc4>)
 c059bd0:	5c5c      	ldrb	r4, [r3, r1]
  if (slot == SE_SLOT_PREPROVISIONNED)
 c059bd2:	2800      	cmp	r0, #0
 c059bd4:	d054      	beq.n	c059c80 <SE_GenerateKeyPair+0xc0>
  if (slot == SE_SLOT_PERMANENT)
 c059bd6:	2801      	cmp	r0, #1
 c059bd8:	d12c      	bne.n	c059c34 <SE_GenerateKeyPair+0x74>
    status_code = StSafeA_GenerateKeyPair(SE_HDL, STSAFEA_KEY_SLOT_1, 0xFFFF, STSAFEA_FLAG_FALSE,
 c059bda:	4e2b      	ldr	r6, [pc, #172]	@ (c059c88 <SE_GenerateKeyPair+0xc8>)
 c059bdc:	f896 226d 	ldrb.w	r2, [r6, #621]	@ 0x26d
 c059be0:	f896 3264 	ldrb.w	r3, [r6, #612]	@ 0x264
 c059be4:	9101      	str	r1, [sp, #4]
 c059be6:	429a      	cmp	r2, r3
 c059be8:	bf2c      	ite	cs
 c059bea:	9206      	strcs	r2, [sp, #24]
 c059bec:	9306      	strcc	r3, [sp, #24]
 c059bee:	ab0c      	add	r3, sp, #48	@ 0x30
 c059bf0:	9305      	str	r3, [sp, #20]
 c059bf2:	ab0a      	add	r3, sp, #40	@ 0x28
 c059bf4:	9304      	str	r3, [sp, #16]
 c059bf6:	f10d 0327 	add.w	r3, sp, #39	@ 0x27
 c059bfa:	e9cd 4302 	strd	r4, r3, [sp, #8]
 c059bfe:	2304      	movs	r3, #4
 c059c00:	4601      	mov	r1, r0
 c059c02:	9300      	str	r3, [sp, #0]
 c059c04:	f64f 72ff 	movw	r2, #65535	@ 0xffff
 c059c08:	2300      	movs	r3, #0
 c059c0a:	4630      	mov	r0, r6
 c059c0c:	f000 fb6a 	bl	c05a2e4 <StSafeA_GenerateKeyPair>
    if (status_code == STSAFEA_OK)
 c059c10:	bb90      	cbnz	r0, c059c78 <SE_GenerateKeyPair+0xb8>
      se_ctx.slot1_key_size = size * 8;
 c059c12:	00e4      	lsls	r4, r4, #3
 c059c14:	f8a6 425e 	strh.w	r4, [r6, #606]	@ 0x25e
    memcpy(pub_x, x.Data, x.Length);
 c059c18:	f8bd 2028 	ldrh.w	r2, [sp, #40]	@ 0x28
 c059c1c:	990b      	ldr	r1, [sp, #44]	@ 0x2c
 c059c1e:	4640      	mov	r0, r8
 c059c20:	f001 fd14 	bl	c05b64c <memcpy>
    memcpy(pub_y, y.Data, y.Length);
 c059c24:	4638      	mov	r0, r7
 c059c26:	f8bd 2030 	ldrh.w	r2, [sp, #48]	@ 0x30
 c059c2a:	990d      	ldr	r1, [sp, #52]	@ 0x34
 c059c2c:	f001 fd0e 	bl	c05b64c <memcpy>
    return SE_OK;
 c059c30:	2000      	movs	r0, #0
 c059c32:	e022      	b.n	c059c7a <SE_GenerateKeyPair+0xba>
  if (slot == SE_SLOT_EPHEMERAL)
 c059c34:	2802      	cmp	r0, #2
 c059c36:	d11f      	bne.n	c059c78 <SE_GenerateKeyPair+0xb8>
    status_code = StSafeA_GenerateKeyPair(SE_HDL, STSAFEA_KEY_SLOT_EPHEMERAL, 0xFFFF, STSAFEA_FLAG_FALSE,
 c059c38:	4d13      	ldr	r5, [pc, #76]	@ (c059c88 <SE_GenerateKeyPair+0xc8>)
 c059c3a:	f895 226f 	ldrb.w	r2, [r5, #623]	@ 0x26f
 c059c3e:	f895 3264 	ldrb.w	r3, [r5, #612]	@ 0x264
 c059c42:	4628      	mov	r0, r5
 c059c44:	429a      	cmp	r2, r3
 c059c46:	bf2c      	ite	cs
 c059c48:	9206      	strcs	r2, [sp, #24]
 c059c4a:	9306      	strcc	r3, [sp, #24]
 c059c4c:	ab0c      	add	r3, sp, #48	@ 0x30
 c059c4e:	9305      	str	r3, [sp, #20]
 c059c50:	ab0a      	add	r3, sp, #40	@ 0x28
 c059c52:	9304      	str	r3, [sp, #16]
 c059c54:	f10d 0327 	add.w	r3, sp, #39	@ 0x27
 c059c58:	e9cd 4302 	strd	r4, r3, [sp, #8]
 c059c5c:	2301      	movs	r3, #1
 c059c5e:	9101      	str	r1, [sp, #4]
 c059c60:	9300      	str	r3, [sp, #0]
 c059c62:	f64f 72ff 	movw	r2, #65535	@ 0xffff
 c059c66:	2300      	movs	r3, #0
 c059c68:	21ff      	movs	r1, #255	@ 0xff
 c059c6a:	f000 fb3b 	bl	c05a2e4 <StSafeA_GenerateKeyPair>
    if (status_code == STSAFEA_OK)
 c059c6e:	b918      	cbnz	r0, c059c78 <SE_GenerateKeyPair+0xb8>
      se_ctx.slotff_key_size = size * 8;
 c059c70:	00e4      	lsls	r4, r4, #3
 c059c72:	f8a5 4260 	strh.w	r4, [r5, #608]	@ 0x260
  if (status_code == STSAFEA_OK)
 c059c76:	e7cf      	b.n	c059c18 <SE_GenerateKeyPair+0x58>
  return SE_COMMAND_ERROR;
 c059c78:	2001      	movs	r0, #1
}
 c059c7a:	b00e      	add	sp, #56	@ 0x38
 c059c7c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      return SE_INVALID_PARAMS_ERROR;
 c059c80:	2003      	movs	r0, #3
 c059c82:	e7fa      	b.n	c059c7a <SE_GenerateKeyPair+0xba>
 c059c84:	0c061396 	.word	0x0c061396
 c059c88:	30031830 	.word	0x30031830

0c059c8c <SE_GenerateSignature>:
{
 c059c8c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 c059c90:	4617      	mov	r7, r2
  uint8_t l_hash[48] = {0};
 c059c92:	222c      	movs	r2, #44	@ 0x2c
{
 c059c94:	4605      	mov	r5, r0
 c059c96:	460e      	mov	r6, r1
  uint8_t l_hash[48] = {0};
 c059c98:	2100      	movs	r1, #0
{
 c059c9a:	b096      	sub	sp, #88	@ 0x58
  uint8_t l_hash[48] = {0};
 c059c9c:	eb0d 0002 	add.w	r0, sp, r2
{
 c059ca0:	4698      	mov	r8, r3
  uint8_t l_hash[48] = {0};
 c059ca2:	910a      	str	r1, [sp, #40]	@ 0x28
 c059ca4:	f001 fd43 	bl	c05b72e <memset>
  switch (slot)
 c059ca8:	2d00      	cmp	r5, #0
 c059caa:	d03c      	beq.n	c059d26 <SE_GenerateSignature+0x9a>
 c059cac:	2d01      	cmp	r5, #1
 c059cae:	d13e      	bne.n	c059d2e <SE_GenerateSignature+0xa2>
      key_size = se_ctx.slot1_key_size / 8;
 c059cb0:	4b21      	ldr	r3, [pc, #132]	@ (c059d38 <SE_GenerateSignature+0xac>)
 c059cb2:	f8b3 425e 	ldrh.w	r4, [r3, #606]	@ 0x25e
      key_size = se_ctx.slot0_key_size / 8;
 c059cb6:	08e4      	lsrs	r4, r4, #3
  if (key_size == 0)
 c059cb8:	2c00      	cmp	r4, #0
 c059cba:	d038      	beq.n	c059d2e <SE_GenerateSignature+0xa2>
    if (hash_size >= key_size)
 c059cbc:	42bc      	cmp	r4, r7
 c059cbe:	d907      	bls.n	c059cd0 <SE_GenerateSignature+0x44>
      memcpy(l_hash + (key_size - hash_size), hash, hash_size);
 c059cc0:	ab0a      	add	r3, sp, #40	@ 0x28
 c059cc2:	1be0      	subs	r0, r4, r7
 c059cc4:	4631      	mov	r1, r6
 c059cc6:	463a      	mov	r2, r7
 c059cc8:	4418      	add	r0, r3
 c059cca:	f001 fcbf 	bl	c05b64c <memcpy>
  const uint8_t *u_hash = l_hash;
 c059cce:	ae0a      	add	r6, sp, #40	@ 0x28
  status_code = StSafeA_GenerateSignature(SE_HDL, sslot, u_hash,
 c059cd0:	4819      	ldr	r0, [pc, #100]	@ (c059d38 <SE_GenerateSignature+0xac>)
 c059cd2:	4629      	mov	r1, r5
 c059cd4:	f890 326c 	ldrb.w	r3, [r0, #620]	@ 0x26c
 c059cd8:	9304      	str	r3, [sp, #16]
 c059cda:	f890 226b 	ldrb.w	r2, [r0, #619]	@ 0x26b
 c059cde:	f890 3264 	ldrb.w	r3, [r0, #612]	@ 0x264
 c059ce2:	429a      	cmp	r2, r3
 c059ce4:	bf2c      	ite	cs
 c059ce6:	9203      	strcs	r2, [sp, #12]
 c059ce8:	9303      	strcc	r3, [sp, #12]
 c059cea:	ab08      	add	r3, sp, #32
 c059cec:	9302      	str	r3, [sp, #8]
 c059cee:	ab06      	add	r3, sp, #24
 c059cf0:	e9cd 4300 	strd	r4, r3, [sp]
 c059cf4:	f1b4 0320 	subs.w	r3, r4, #32
 c059cf8:	bf18      	it	ne
 c059cfa:	2301      	movne	r3, #1
 c059cfc:	4632      	mov	r2, r6
 c059cfe:	f000 fba1 	bl	c05a444 <StSafeA_GenerateSignature>
  if (status_code == STSAFEA_OK)
 c059d02:	4604      	mov	r4, r0
 c059d04:	b9a8      	cbnz	r0, c059d32 <SE_GenerateSignature+0xa6>
    memcpy(R, pR.Data, pR.Length);
 c059d06:	f8bd 2018 	ldrh.w	r2, [sp, #24]
 c059d0a:	9907      	ldr	r1, [sp, #28]
 c059d0c:	4640      	mov	r0, r8
 c059d0e:	f001 fc9d 	bl	c05b64c <memcpy>
    memcpy(S, pS.Data, pS.Length);
 c059d12:	f8bd 2020 	ldrh.w	r2, [sp, #32]
 c059d16:	9909      	ldr	r1, [sp, #36]	@ 0x24
 c059d18:	981c      	ldr	r0, [sp, #112]	@ 0x70
 c059d1a:	f001 fc97 	bl	c05b64c <memcpy>
}
 c059d1e:	4620      	mov	r0, r4
 c059d20:	b016      	add	sp, #88	@ 0x58
 c059d22:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      key_size = se_ctx.slot0_key_size / 8;
 c059d26:	4b04      	ldr	r3, [pc, #16]	@ (c059d38 <SE_GenerateSignature+0xac>)
 c059d28:	f8b3 425c 	ldrh.w	r4, [r3, #604]	@ 0x25c
 c059d2c:	e7c3      	b.n	c059cb6 <SE_GenerateSignature+0x2a>
      return SE_INVALID_PARAMS_ERROR;
 c059d2e:	2403      	movs	r4, #3
 c059d30:	e7f5      	b.n	c059d1e <SE_GenerateSignature+0x92>
  return SE_COMMAND_ERROR;
 c059d32:	2401      	movs	r4, #1
 c059d34:	e7f3      	b.n	c059d1e <SE_GenerateSignature+0x92>
 c059d36:	bf00      	nop
 c059d38:	30031830 	.word	0x30031830

0c059d3c <SE_GetKeySize>:
  if (slot == SE_SLOT_PREPROVISIONNED)
 c059d3c:	b918      	cbnz	r0, c059d46 <SE_GetKeySize+0xa>
    return se_ctx.slot0_key_size;
 c059d3e:	4b08      	ldr	r3, [pc, #32]	@ (c059d60 <SE_GetKeySize+0x24>)
 c059d40:	f8b3 025c 	ldrh.w	r0, [r3, #604]	@ 0x25c
 c059d44:	4770      	bx	lr
  if (slot == SE_SLOT_PERMANENT)
 c059d46:	2801      	cmp	r0, #1
 c059d48:	d103      	bne.n	c059d52 <SE_GetKeySize+0x16>
    return se_ctx.slot1_key_size;
 c059d4a:	4b05      	ldr	r3, [pc, #20]	@ (c059d60 <SE_GetKeySize+0x24>)
 c059d4c:	f8b3 025e 	ldrh.w	r0, [r3, #606]	@ 0x25e
 c059d50:	4770      	bx	lr
  if (slot == SE_SLOT_EPHEMERAL)
 c059d52:	2802      	cmp	r0, #2
    return se_ctx.slotff_key_size;
 c059d54:	bf06      	itte	eq
 c059d56:	4b02      	ldreq	r3, [pc, #8]	@ (c059d60 <SE_GetKeySize+0x24>)
 c059d58:	f8b3 0260 	ldrheq.w	r0, [r3, #608]	@ 0x260
  return 0;
 c059d5c:	2000      	movne	r0, #0
}
 c059d5e:	4770      	bx	lr
 c059d60:	30031830 	.word	0x30031830

0c059d64 <SE_GetMapping>:
{
 c059d64:	b510      	push	{r4, lr}
  if (*nb_region != 0)
 c059d66:	680a      	ldr	r2, [r1, #0]
    if (se_ctx.mapping_size <= *nb_region)
 c059d68:	4c08      	ldr	r4, [pc, #32]	@ (c059d8c <SE_GetMapping+0x28>)
 c059d6a:	f8d4 3284 	ldr.w	r3, [r4, #644]	@ 0x284
  if (*nb_region != 0)
 c059d6e:	b152      	cbz	r2, c059d86 <SE_GetMapping+0x22>
    if (se_ctx.mapping_size <= *nb_region)
 c059d70:	429a      	cmp	r2, r3
      *nb_region = se_ctx.mapping_size;
 c059d72:	bf28      	it	cs
 c059d74:	600b      	strcs	r3, [r1, #0]
    memcpy(regions, se_ctx.mapping, *nb_region * sizeof(SE_Region_t));
 c059d76:	680a      	ldr	r2, [r1, #0]
 c059d78:	f8d4 1280 	ldr.w	r1, [r4, #640]	@ 0x280
 c059d7c:	0112      	lsls	r2, r2, #4
 c059d7e:	f001 fc65 	bl	c05b64c <memcpy>
}
 c059d82:	2000      	movs	r0, #0
 c059d84:	bd10      	pop	{r4, pc}
    *nb_region = se_ctx.mapping_size;
 c059d86:	600b      	str	r3, [r1, #0]
 c059d88:	e7fb      	b.n	c059d82 <SE_GetMapping+0x1e>
 c059d8a:	bf00      	nop
 c059d8c:	30031830 	.word	0x30031830

0c059d90 <SE_Init_PubKeys>:
}

/* check if copy is needed in case of PSA, this is not needed */
SE_API_Status_t SE_Init_PubKeys(SE_Public_Key_Entry_t *pub_keys, size_t nb_pub_keys)
{
  if ((pub_keys == NULL) && (nb_pub_keys != 0))
 c059d90:	b910      	cbnz	r0, c059d98 <SE_Init_PubKeys+0x8>
 c059d92:	b961      	cbnz	r1, c059dae <SE_Init_PubKeys+0x1e>
  }
  if (nb_pub_keys >= 2)
  {
    se_ctx.renewable_pub_keys[1] = &pub_keys[1];
  }
  return SE_OK;
 c059d94:	2000      	movs	r0, #0
 c059d96:	4770      	bx	lr
  if (nb_pub_keys >= 1)
 c059d98:	2900      	cmp	r1, #0
 c059d9a:	d0fb      	beq.n	c059d94 <SE_Init_PubKeys+0x4>
    se_ctx.renewable_pub_keys[0] = pub_keys;
 c059d9c:	4b05      	ldr	r3, [pc, #20]	@ (c059db4 <SE_Init_PubKeys+0x24>)
  if (nb_pub_keys >= 2)
 c059d9e:	2901      	cmp	r1, #1
    se_ctx.renewable_pub_keys[0] = pub_keys;
 c059da0:	f8c3 04fc 	str.w	r0, [r3, #1276]	@ 0x4fc
  if (nb_pub_keys >= 2)
 c059da4:	d0f6      	beq.n	c059d94 <SE_Init_PubKeys+0x4>
    se_ctx.renewable_pub_keys[1] = &pub_keys[1];
 c059da6:	3061      	adds	r0, #97	@ 0x61
 c059da8:	f8c3 0500 	str.w	r0, [r3, #1280]	@ 0x500
 c059dac:	e7f2      	b.n	c059d94 <SE_Init_PubKeys+0x4>
    return SE_INVALID_PARAMS_ERROR;
 c059dae:	2003      	movs	r0, #3
}
 c059db0:	4770      	bx	lr
 c059db2:	bf00      	nop
 c059db4:	30031830 	.word	0x30031830

0c059db8 <SE_Get_PubKey>:

SE_API_Status_t SE_Get_PubKey(SE_Slot_t slot, uint8_t *pub_x, uint8_t *pub_y, size_t *size, SE_Key_Type_t *type)
{
 c059db8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 c059dbc:	4617      	mov	r7, r2
 c059dbe:	9a06      	ldr	r2, [sp, #24]
 c059dc0:	4688      	mov	r8, r1
 c059dc2:	461d      	mov	r5, r3
  SE_Public_Key_Entry_t *key;
  size_t key_size = 0;
  uint32_t i;
  uint32_t zero_count = 0;

  if ((type == NULL) || (size == NULL))
 c059dc4:	b12a      	cbz	r2, c059dd2 <SE_Get_PubKey+0x1a>
 c059dc6:	b123      	cbz	r3, c059dd2 <SE_Get_PubKey+0x1a>
  {
    return SE_INVALID_PARAMS_ERROR;
  }

  switch (slot)
 c059dc8:	2801      	cmp	r0, #1
 c059dca:	d004      	beq.n	c059dd6 <SE_Get_PubKey+0x1e>
 c059dcc:	2802      	cmp	r0, #2
 c059dce:	d026      	beq.n	c059e1e <SE_Get_PubKey+0x66>
 c059dd0:	b348      	cbz	r0, c059e26 <SE_Get_PubKey+0x6e>
    return SE_INVALID_PARAMS_ERROR;
 c059dd2:	2003      	movs	r0, #3
 c059dd4:	e021      	b.n	c059e1a <SE_Get_PubKey+0x62>
  {
    case SE_SLOT_PREPROVISIONNED :
      key = &se_ctx.fixed_pub_keys[0];
      break;
    case SE_SLOT_PERMANENT :
      key = se_ctx.renewable_pub_keys[0];
 c059dd6:	4b20      	ldr	r3, [pc, #128]	@ (c059e58 <SE_Get_PubKey+0xa0>)
 c059dd8:	f8d3 44fc 	ldr.w	r4, [r3, #1276]	@ 0x4fc
      break;
    default :
      return SE_INVALID_PARAMS_ERROR;
  }

  key_size = SE_GetKeySize(slot) / 8;
 c059ddc:	f7ff ffae 	bl	c059d3c <SE_GetKeySize>
  /* parameters size */
  if (key_size == 0)
 c059de0:	2807      	cmp	r0, #7
 c059de2:	d922      	bls.n	c059e2a <SE_Get_PubKey+0x72>
 c059de4:	4623      	mov	r3, r4
  uint32_t zero_count = 0;
 c059de6:	2100      	movs	r1, #0
  key_size = SE_GetKeySize(slot) / 8;
 c059de8:	08c6      	lsrs	r6, r0, #3
    *size = 0;
    *type = SE_KEY_TYPE_NONE;
    return SE_OK;
  }

  for (i = 0; i < key_size; i++)
 c059dea:	eb04 00d0 	add.w	r0, r4, r0, lsr #3
  {
    if ((key->public_key_x[i] == 0) && (key->public_key_y[i] == 0))
 c059dee:	f813 cf01 	ldrb.w	ip, [r3, #1]!
 c059df2:	f1bc 0f00 	cmp.w	ip, #0
 c059df6:	d105      	bne.n	c059e04 <SE_Get_PubKey+0x4c>
 c059df8:	f893 c030 	ldrb.w	ip, [r3, #48]	@ 0x30
 c059dfc:	f1bc 0f00 	cmp.w	ip, #0
 c059e00:	d100      	bne.n	c059e04 <SE_Get_PubKey+0x4c>
    {
      zero_count++;
 c059e02:	3101      	adds	r1, #1
  for (i = 0; i < key_size; i++)
 c059e04:	4298      	cmp	r0, r3
 c059e06:	d1f2      	bne.n	c059dee <SE_Get_PubKey+0x36>
    }
  }

  if (zero_count == key_size)
 c059e08:	42b1      	cmp	r1, r6
 c059e0a:	d00e      	beq.n	c059e2a <SE_Get_PubKey+0x72>
    *size = 0;
    *type = SE_KEY_TYPE_NONE;
    return SE_OK;
  }

  *type = key->public_key_curve;
 c059e0c:	7823      	ldrb	r3, [r4, #0]
 c059e0e:	7013      	strb	r3, [r2, #0]

  if (*size < key_size)
 c059e10:	682b      	ldr	r3, [r5, #0]
  {
    *size = key_size;
 c059e12:	602e      	str	r6, [r5, #0]
  if (*size < key_size)
 c059e14:	42b3      	cmp	r3, r6
 c059e16:	d20e      	bcs.n	c059e36 <SE_Get_PubKey+0x7e>
    return SE_BUFFER_TOO_SHORT_ERROR;
 c059e18:	2005      	movs	r0, #5
  if (pub_y != NULL)
  {
    memcpy(pub_y, key->public_key_y, key_size);
  }
  return SE_OK;
}
 c059e1a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      key = se_ctx.renewable_pub_keys[1];
 c059e1e:	4b0e      	ldr	r3, [pc, #56]	@ (c059e58 <SE_Get_PubKey+0xa0>)
 c059e20:	f8d3 4500 	ldr.w	r4, [r3, #1280]	@ 0x500
      break;
 c059e24:	e7da      	b.n	c059ddc <SE_Get_PubKey+0x24>
  switch (slot)
 c059e26:	4c0d      	ldr	r4, [pc, #52]	@ (c059e5c <SE_Get_PubKey+0xa4>)
 c059e28:	e7d8      	b.n	c059ddc <SE_Get_PubKey+0x24>
    *size = 0;
 c059e2a:	2300      	movs	r3, #0
 c059e2c:	602b      	str	r3, [r5, #0]
    *type = SE_KEY_TYPE_NONE;
 c059e2e:	2304      	movs	r3, #4
 c059e30:	7013      	strb	r3, [r2, #0]
    return SE_OK;
 c059e32:	2000      	movs	r0, #0
 c059e34:	e7f1      	b.n	c059e1a <SE_Get_PubKey+0x62>
  if (pub_x != NULL)
 c059e36:	f1b8 0f00 	cmp.w	r8, #0
 c059e3a:	d004      	beq.n	c059e46 <SE_Get_PubKey+0x8e>
    memcpy(pub_x, key->public_key_x, key_size);
 c059e3c:	4632      	mov	r2, r6
 c059e3e:	4640      	mov	r0, r8
 c059e40:	1c61      	adds	r1, r4, #1
 c059e42:	f001 fc03 	bl	c05b64c <memcpy>
  if (pub_y != NULL)
 c059e46:	2f00      	cmp	r7, #0
 c059e48:	d0f3      	beq.n	c059e32 <SE_Get_PubKey+0x7a>
    memcpy(pub_y, key->public_key_y, key_size);
 c059e4a:	4632      	mov	r2, r6
 c059e4c:	4638      	mov	r0, r7
 c059e4e:	f104 0131 	add.w	r1, r4, #49	@ 0x31
 c059e52:	f001 fbfb 	bl	c05b64c <memcpy>
 c059e56:	e7ec      	b.n	c059e32 <SE_Get_PubKey+0x7a>
 c059e58:	30031830 	.word	0x30031830
 c059e5c:	30031cc4 	.word	0x30031cc4

0c059e60 <StSafeA_AssignLVResponse>:
static StSafeA_ResponseCode_t StSafeA_AssignLVResponse(StSafeA_LVBuffer_t *pDestLVBuffer,
                                                       StSafeA_LVBuffer_t *pSrcLVBuffer,
                                                       uint16_t ExpectedLen)
{
  StSafeA_ResponseCode_t status_code = STSAFEA_INVALID_PARAMETER;
  if ((pDestLVBuffer != NULL)  && (pSrcLVBuffer != NULL))
 c059e60:	b138      	cbz	r0, c059e72 <StSafeA_AssignLVResponse+0x12>
  {
    /* Check if the length value received by STSAFE is what it was expected */
    if (pSrcLVBuffer->Length > ExpectedLen)
 c059e62:	880b      	ldrh	r3, [r1, #0]
 c059e64:	429a      	cmp	r2, r3
 c059e66:	d306      	bcc.n	c059e76 <StSafeA_AssignLVResponse+0x16>

    status_code = STSAFEA_OK;

    /* The length value received by STSAFE is assigned anyway, to allow the application to re-try
       with the correct parameter */
    pDestLVBuffer->Length = pSrcLVBuffer->Length;
 c059e68:	8003      	strh	r3, [r0, #0]

    /* Set the Data of the LVBuffer according to the selected Shared Ram optimization */
    StSafeA_SetLVData(pDestLVBuffer, pSrcLVBuffer->Data, pDestLVBuffer->Length);
 c059e6a:	684b      	ldr	r3, [r1, #4]
{
#if (STSAFEA_USE_OPTIMIZATION_SHARED_RAM)
  STSAFEA_UNUSED_VAR(Length);
  /* In this case the direct pointer assignment allows the best memory optimization.
     But up to the caller to manage this memory content properly, copying it to a local buffer if needed */
  pDestLVBuffer->Data = pSrcLVData;
 c059e6c:	6043      	str	r3, [r0, #4]
    status_code = STSAFEA_OK;
 c059e6e:	2000      	movs	r0, #0
  if ((Length > 0U) && (pDestLVBuffer->Data != NULL))
  {
    (void)memcpy(pDestLVBuffer->Data, pSrcLVData, Length);
  }
#endif /* STSAFEA_USE_OPTIMIZATION_SHARED_RAM */
}
 c059e70:	4770      	bx	lr
  StSafeA_ResponseCode_t status_code = STSAFEA_INVALID_PARAMETER;
 c059e72:	2030      	movs	r0, #48	@ 0x30
 c059e74:	4770      	bx	lr
      return STSAFEA_INVALID_RESP_LENGTH;
 c059e76:	2031      	movs	r0, #49	@ 0x31
}
 c059e78:	4770      	bx	lr

0c059e7a <StSafeA_AssignLVBuffer>:
{
 c059e7a:	b510      	push	{r4, lr}
  if ((pDestLVBuffer != NULL)  && (pDataBuffer != NULL))
 c059e7c:	b150      	cbz	r0, c059e94 <StSafeA_AssignLVBuffer+0x1a>
 c059e7e:	b149      	cbz	r1, c059e94 <StSafeA_AssignLVBuffer+0x1a>
    pDestLVBuffer->Length = (((uint16_t)pDataBuffer[0U]) << 8) + pDataBuffer[1U];
 c059e80:	880b      	ldrh	r3, [r1, #0]
 c059e82:	ba5b      	rev16	r3, r3
 c059e84:	b29c      	uxth	r4, r3
    if (pDestLVBuffer->Length > ExpectedLen)
 c059e86:	42a2      	cmp	r2, r4
    pDestLVBuffer->Length = (((uint16_t)pDataBuffer[0U]) << 8) + pDataBuffer[1U];
 c059e88:	8003      	strh	r3, [r0, #0]
    if (pDestLVBuffer->Length > ExpectedLen)
 c059e8a:	d305      	bcc.n	c059e98 <StSafeA_AssignLVBuffer+0x1e>
    StSafeA_SetLVData(pDestLVBuffer, &pDataBuffer[2U], pDestLVBuffer->Length);
 c059e8c:	3102      	adds	r1, #2
  pDestLVBuffer->Data = pSrcLVData;
 c059e8e:	6041      	str	r1, [r0, #4]
      status_code = STSAFEA_OK;
 c059e90:	2000      	movs	r0, #0
}
 c059e92:	bd10      	pop	{r4, pc}
  StSafeA_ResponseCode_t status_code = STSAFEA_INVALID_PARAMETER;
 c059e94:	2030      	movs	r0, #48	@ 0x30
 c059e96:	e7fc      	b.n	c059e92 <StSafeA_AssignLVBuffer+0x18>
      return STSAFEA_INVALID_RESP_LENGTH;
 c059e98:	2031      	movs	r0, #49	@ 0x31
 c059e9a:	e7fa      	b.n	c059e92 <StSafeA_AssignLVBuffer+0x18>

0c059e9c <StSafeA_TransmitCommand>:
{
 c059e9c:	b510      	push	{r4, lr}
  if (pStSafeA != NULL)
 c059e9e:	4604      	mov	r4, r0
 c059ea0:	b148      	cbz	r0, c059eb6 <StSafeA_TransmitCommand+0x1a>
    status_code = StSafeA_MAC_SHA_PrePostProcess(pStSafeA, STSAFEA_MAC_SHA_PRE_PROCESS);
 c059ea2:	2100      	movs	r1, #0
 c059ea4:	f000 fe60 	bl	c05ab68 <StSafeA_MAC_SHA_PrePostProcess>
    if (status_code == STSAFEA_OK)
 c059ea8:	b930      	cbnz	r0, c059eb8 <StSafeA_TransmitCommand+0x1c>
      status_code = StSafeA_Transmit(&pStSafeA->InOutBuffer, pStSafeA->CrcSupport);
 c059eaa:	4620      	mov	r0, r4
 c059eac:	7b21      	ldrb	r1, [r4, #12]
}
 c059eae:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      status_code = StSafeA_Transmit(&pStSafeA->InOutBuffer, pStSafeA->CrcSupport);
 c059eb2:	f000 bf17 	b.w	c05ace4 <StSafeA_Transmit>
  StSafeA_ResponseCode_t status_code = STSAFEA_INVALID_PARAMETER;
 c059eb6:	2030      	movs	r0, #48	@ 0x30
}
 c059eb8:	bd10      	pop	{r4, pc}

0c059eba <StSafeA_ReceiveResponse>:
{
 c059eba:	b510      	push	{r4, lr}
  if (pStSafeA != NULL)
 c059ebc:	4604      	mov	r4, r0
 c059ebe:	b160      	cbz	r0, c059eda <StSafeA_ReceiveResponse+0x20>
    status_code = StSafeA_Receive(&pStSafeA->InOutBuffer, pStSafeA->CrcSupport);
 c059ec0:	7b01      	ldrb	r1, [r0, #12]
 c059ec2:	f000 ff57 	bl	c05ad74 <StSafeA_Receive>
    if (status_code == STSAFEA_OK)
 c059ec6:	b948      	cbnz	r0, c059edc <StSafeA_ReceiveResponse+0x22>
      pStSafeA->MacCounter ++;
 c059ec8:	7b63      	ldrb	r3, [r4, #13]
      status_code = StSafeA_MAC_SHA_PrePostProcess(pStSafeA, STSAFEA_MAC_SHA_POST_PROCESS);
 c059eca:	4620      	mov	r0, r4
      pStSafeA->MacCounter ++;
 c059ecc:	3301      	adds	r3, #1
 c059ece:	7363      	strb	r3, [r4, #13]
      status_code = StSafeA_MAC_SHA_PrePostProcess(pStSafeA, STSAFEA_MAC_SHA_POST_PROCESS);
 c059ed0:	2101      	movs	r1, #1
}
 c059ed2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      status_code = StSafeA_MAC_SHA_PrePostProcess(pStSafeA, STSAFEA_MAC_SHA_POST_PROCESS);
 c059ed6:	f000 be47 	b.w	c05ab68 <StSafeA_MAC_SHA_PrePostProcess>
  StSafeA_ResponseCode_t status_code = STSAFEA_INVALID_PARAMETER;
 c059eda:	2030      	movs	r0, #48	@ 0x30
}
 c059edc:	bd10      	pop	{r4, pc}

0c059ede <StSafeA_Init>:
{
 c059ede:	b508      	push	{r3, lr}
 c059ee0:	460b      	mov	r3, r1
  if ((pStSafeA != NULL) && (pAllocatedRxTxBufferData != NULL))
 c059ee2:	b1c0      	cbz	r0, c059f16 <StSafeA_Init+0x38>
 c059ee4:	b1b9      	cbz	r1, c059f16 <StSafeA_Init+0x38>
    pStSafeA->InOutBuffer.LV.Length = 0;
 c059ee6:	2100      	movs	r1, #0
    pStSafeA->CrcSupport    = STSAFEA_CRC_SUPPORT;
 c059ee8:	2201      	movs	r2, #1
    pStSafeA->InOutBuffer.LV.Data   = pAllocatedRxTxBufferData;
 c059eea:	6083      	str	r3, [r0, #8]
    pStSafeA->HostMacSequenceCounter = STSAFEA_HOST_CMAC_INVALID_COUNTER;
 c059eec:	f06f 437f 	mvn.w	r3, #4278190080	@ 0xff000000
    pStSafeA->CrcSupport    = STSAFEA_CRC_SUPPORT;
 c059ef0:	8182      	strh	r2, [r0, #12]
    pStSafeA->InOutBuffer.LV.Length = 0;
 c059ef2:	8081      	strh	r1, [r0, #4]
    pStSafeA->HostMacSequenceCounter = STSAFEA_HOST_CMAC_INVALID_COUNTER;
 c059ef4:	6103      	str	r3, [r0, #16]
    pStSafeA->HashObj.HashType = STSAFEA_SHA_256;
 c059ef6:	7501      	strb	r1, [r0, #20]
    pStSafeA->HashObj.HashCtx = NULL;
 c059ef8:	61c1      	str	r1, [r0, #28]
    (void)memset(pStSafeA->HashObj.HashRes, 0, sizeof(pStSafeA->HashObj.HashRes));
 c059efa:	2230      	movs	r2, #48	@ 0x30
 c059efc:	3020      	adds	r0, #32
 c059efe:	f001 fc16 	bl	c05b72e <memset>
    if (StSafeA_HW_Init() == 0)
 c059f02:	f000 ffd5 	bl	c05aeb0 <StSafeA_HW_Init>
 c059f06:	b108      	cbz	r0, c059f0c <StSafeA_Init+0x2e>
    status_code = STSAFEA_UNEXPECTED_ERROR;
 c059f08:	2005      	movs	r0, #5
}
 c059f0a:	bd08      	pop	{r3, pc}
      if (StSafeA_HostKeys_Init() == 0)
 c059f0c:	f7f6 fe9a 	bl	c050c44 <StSafeA_HostKeys_Init>
 c059f10:	2800      	cmp	r0, #0
 c059f12:	d0fa      	beq.n	c059f0a <StSafeA_Init+0x2c>
 c059f14:	e7f8      	b.n	c059f08 <StSafeA_Init+0x2a>
  StSafeA_ResponseCode_t status_code = STSAFEA_INVALID_PARAMETER;
 c059f16:	2030      	movs	r0, #48	@ 0x30
 c059f18:	e7f7      	b.n	c059f0a <StSafeA_Init+0x2c>

0c059f1a <StSafeA_HostKeySlotQuery>:
{
 c059f1a:	b573      	push	{r0, r1, r4, r5, r6, lr}
 c059f1c:	460d      	mov	r5, r1
  if (IS_STSAFEA_HANDLER_VALID_PTR(pStSafeA) &&
 c059f1e:	4604      	mov	r4, r0
{
 c059f20:	f88d 2007 	strb.w	r2, [sp, #7]
  if (IS_STSAFEA_HANDLER_VALID_PTR(pStSafeA) &&
 c059f24:	2800      	cmp	r0, #0
 c059f26:	d034      	beq.n	c059f92 <StSafeA_HostKeySlotQuery+0x78>
 c059f28:	6883      	ldr	r3, [r0, #8]
 c059f2a:	2b00      	cmp	r3, #0
 c059f2c:	d031      	beq.n	c059f92 <StSafeA_HostKeySlotQuery+0x78>
 c059f2e:	b381      	cbz	r1, c059f92 <StSafeA_HostKeySlotQuery+0x78>
    StSafeA_BuildCommandHeaderCMAC(pStSafeA, STSAFEA_CMD_QUERY, &InMAC);
 c059f30:	f10d 0207 	add.w	r2, sp, #7
 c059f34:	2114      	movs	r1, #20
 c059f36:	f000 f82e 	bl	c059f96 <StSafeA_BuildCommandHeaderCMAC>
    pStSafeA->InOutBuffer.LV.Length = 1U;
 c059f3a:	2601      	movs	r6, #1
    pStSafeA->InOutBuffer.LV.Data[0] = (uint8_t)STSAFEA_TAG_HOST_KEY_SLOT;
 c059f3c:	2217      	movs	r2, #23
 c059f3e:	68a3      	ldr	r3, [r4, #8]
    status_code = StSafeA_TransmitCommand(pStSafeA);
 c059f40:	4620      	mov	r0, r4
    pStSafeA->InOutBuffer.LV.Data[0] = (uint8_t)STSAFEA_TAG_HOST_KEY_SLOT;
 c059f42:	701a      	strb	r2, [r3, #0]
    pStSafeA->InOutBuffer.LV.Length = 1U;
 c059f44:	80a6      	strh	r6, [r4, #4]
    status_code = StSafeA_TransmitCommand(pStSafeA);
 c059f46:	f7ff ffa9 	bl	c059e9c <StSafeA_TransmitCommand>
    if (status_code == STSAFEA_OK)
 c059f4a:	bb00      	cbnz	r0, c059f8e <StSafeA_HostKeySlotQuery+0x74>
      pStSafeA->InOutBuffer.LV.Length = STSAFEA_HOST_KEY_SLOT_QUERY_RESPONSE_LENGTH + STSAFEA_R_MAC_LENGTH(InMAC);
 c059f4c:	f89d 3007 	ldrb.w	r3, [sp, #7]
      StSafeA_Delay(STSAFEA_MS_WAIT_TIME_CMD_QUERY);
 c059f50:	4630      	mov	r0, r6
      pStSafeA->InOutBuffer.LV.Length = STSAFEA_HOST_KEY_SLOT_QUERY_RESPONSE_LENGTH + STSAFEA_R_MAC_LENGTH(InMAC);
 c059f52:	091b      	lsrs	r3, r3, #4
 c059f54:	f003 0304 	and.w	r3, r3, #4
 c059f58:	3304      	adds	r3, #4
 c059f5a:	80a3      	strh	r3, [r4, #4]
      StSafeA_Delay(STSAFEA_MS_WAIT_TIME_CMD_QUERY);
 c059f5c:	f000 ffa0 	bl	c05aea0 <StSafeA_Delay>
      status_code = StSafeA_ReceiveResponse(pStSafeA);
 c059f60:	4620      	mov	r0, r4
 c059f62:	f7ff ffaa 	bl	c059eba <StSafeA_ReceiveResponse>
      if (status_code == STSAFEA_OK)
 c059f66:	b990      	cbnz	r0, c059f8e <StSafeA_HostKeySlotQuery+0x74>
        pOutHostKeySlot->HostCMacSequenceCounter = STSAFEA_HOST_CMAC_INVALID_COUNTER;
 c059f68:	f06f 417f 	mvn.w	r1, #4278190080	@ 0xff000000
        pOutHostKeySlot->Length = pStSafeA->InOutBuffer.LV.Length;
 c059f6c:	88a3      	ldrh	r3, [r4, #4]
        pOutHostKeySlot->HostKeyPresenceFlag = pStSafeA->InOutBuffer.LV.Data[0];
 c059f6e:	68a2      	ldr	r2, [r4, #8]
        pOutHostKeySlot->Length = pStSafeA->InOutBuffer.LV.Length;
 c059f70:	802b      	strh	r3, [r5, #0]
        pOutHostKeySlot->HostKeyPresenceFlag = pStSafeA->InOutBuffer.LV.Data[0];
 c059f72:	7813      	ldrb	r3, [r2, #0]
        pOutHostKeySlot->HostCMacSequenceCounter = STSAFEA_HOST_CMAC_INVALID_COUNTER;
 c059f74:	6069      	str	r1, [r5, #4]
        pOutHostKeySlot->HostKeyPresenceFlag = pStSafeA->InOutBuffer.LV.Data[0];
 c059f76:	70ab      	strb	r3, [r5, #2]
        if (pOutHostKeySlot->HostKeyPresenceFlag != 0U)
 c059f78:	b14b      	cbz	r3, c059f8e <StSafeA_HostKeySlotQuery+0x74>
          pOutHostKeySlot->HostCMacSequenceCounter  = ((uint32_t)pStSafeA->InOutBuffer.LV.Data[1]) << 16;
 c059f7a:	7853      	ldrb	r3, [r2, #1]
 c059f7c:	041b      	lsls	r3, r3, #16
 c059f7e:	606b      	str	r3, [r5, #4]
          pOutHostKeySlot->HostCMacSequenceCounter |= ((uint32_t)pStSafeA->InOutBuffer.LV.Data[2]) << 8;
 c059f80:	7891      	ldrb	r1, [r2, #2]
 c059f82:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 c059f86:	606b      	str	r3, [r5, #4]
          pOutHostKeySlot->HostCMacSequenceCounter |= pStSafeA->InOutBuffer.LV.Data[3];
 c059f88:	78d2      	ldrb	r2, [r2, #3]
 c059f8a:	4313      	orrs	r3, r2
 c059f8c:	606b      	str	r3, [r5, #4]
}
 c059f8e:	b002      	add	sp, #8
 c059f90:	bd70      	pop	{r4, r5, r6, pc}
  StSafeA_ResponseCode_t status_code = STSAFEA_INVALID_PARAMETER;
 c059f92:	2030      	movs	r0, #48	@ 0x30
 c059f94:	e7fb      	b.n	c059f8e <StSafeA_HostKeySlotQuery+0x74>

0c059f96 <StSafeA_BuildCommandHeaderCMAC>:
  * @param   CommandCode : Command code.
  * @param   pMAC        : Pointer to MAC authenticating command/response.
  * @retval  none
  */
static void StSafeA_BuildCommandHeaderCMAC(StSafeA_Handle_t *pStSafeA, uint8_t CommandCode, uint8_t *pMAC)
{
 c059f96:	b573      	push	{r0, r1, r4, r5, r6, lr}
 c059f98:	460d      	mov	r5, r1
 c059f9a:	4616      	mov	r6, r2
  if ((pStSafeA != NULL) && (pMAC != NULL))
 c059f9c:	4604      	mov	r4, r0
 c059f9e:	b188      	cbz	r0, c059fc4 <StSafeA_BuildCommandHeaderCMAC+0x2e>
  {
#if (STSAFEA_USE_OPTIMIZATION_NO_HOST_MAC_ENCRYPT)
    *pMAC = STSAFEA_MAC_NONE;
#else
    /* Get CMAC counter value */
    if ((*pMAC & STSAFEA_CMD_HEADER_SCHN_HOSTEN) != 0x00U)
 c059fa0:	7813      	ldrb	r3, [r2, #0]
 c059fa2:	069b      	lsls	r3, r3, #26
 c059fa4:	d509      	bpl.n	c059fba <StSafeA_BuildCommandHeaderCMAC+0x24>
{
  StSafeA_HostKeySlotBuffer_t host_key_slot;

  if (pStSafeA != NULL)
  {
    if ((StSafeA_HostKeySlotQuery(pStSafeA, &host_key_slot, STSAFEA_MAC_NONE) == STSAFEA_OK)
 c059fa6:	2200      	movs	r2, #0
 c059fa8:	4669      	mov	r1, sp
 c059faa:	f7ff ffb6 	bl	c059f1a <StSafeA_HostKeySlotQuery>
 c059fae:	b920      	cbnz	r0, c059fba <StSafeA_BuildCommandHeaderCMAC+0x24>
        && (host_key_slot.HostKeyPresenceFlag != 0U))
 c059fb0:	f89d 3002 	ldrb.w	r3, [sp, #2]
 c059fb4:	b10b      	cbz	r3, c059fba <StSafeA_BuildCommandHeaderCMAC+0x24>
    {
      pStSafeA->HostMacSequenceCounter = host_key_slot.HostCMacSequenceCounter;
 c059fb6:	9b01      	ldr	r3, [sp, #4]
 c059fb8:	6123      	str	r3, [r4, #16]
    pStSafeA->InOutBuffer.Header = (CommandCode | (*pMAC & STSAFEA_CMD_HEADER_MAC_MSK));
 c059fba:	7833      	ldrb	r3, [r6, #0]
 c059fbc:	f023 031f 	bic.w	r3, r3, #31
 c059fc0:	431d      	orrs	r5, r3
 c059fc2:	7025      	strb	r5, [r4, #0]
}
 c059fc4:	b002      	add	sp, #8
 c059fc6:	bd70      	pop	{r4, r5, r6, pc}

0c059fc8 <StSafeA_DataPartitionQuery>:
{
 c059fc8:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 c059fcc:	4614      	mov	r4, r2
  if (IS_STSAFEA_HANDLER_VALID_PTR(pStSafeA)         &&
 c059fce:	4606      	mov	r6, r0
{
 c059fd0:	f88d 3007 	strb.w	r3, [sp, #7]
  if (IS_STSAFEA_HANDLER_VALID_PTR(pStSafeA)         &&
 c059fd4:	2800      	cmp	r0, #0
 c059fd6:	f000 8085 	beq.w	c05a0e4 <StSafeA_DataPartitionQuery+0x11c>
 c059fda:	6883      	ldr	r3, [r0, #8]
 c059fdc:	2b00      	cmp	r3, #0
 c059fde:	f000 8081 	beq.w	c05a0e4 <StSafeA_DataPartitionQuery+0x11c>
      (pOutDataPartition != NULL)                    &&
 c059fe2:	2a00      	cmp	r2, #0
 c059fe4:	d07e      	beq.n	c05a0e4 <StSafeA_DataPartitionQuery+0x11c>
    StSafeA_BuildCommandHeaderCMAC(pStSafeA, STSAFEA_CMD_QUERY, &InMAC);
 c059fe6:	2114      	movs	r1, #20
 c059fe8:	f10d 0207 	add.w	r2, sp, #7
 c059fec:	f7ff ffd3 	bl	c059f96 <StSafeA_BuildCommandHeaderCMAC>
    pStSafeA->InOutBuffer.LV.Length = 1U;
 c059ff0:	2701      	movs	r7, #1
    pStSafeA->InOutBuffer.LV.Data[0] = (uint8_t)STSAFEA_TAG_DATA_PARTITION_CONFIGURATION;
 c059ff2:	2212      	movs	r2, #18
 c059ff4:	68b3      	ldr	r3, [r6, #8]
    status_code = StSafeA_TransmitCommand(pStSafeA);
 c059ff6:	4630      	mov	r0, r6
    pStSafeA->InOutBuffer.LV.Data[0] = (uint8_t)STSAFEA_TAG_DATA_PARTITION_CONFIGURATION;
 c059ff8:	701a      	strb	r2, [r3, #0]
    pStSafeA->InOutBuffer.LV.Length = 1U;
 c059ffa:	80b7      	strh	r7, [r6, #4]
    status_code = StSafeA_TransmitCommand(pStSafeA);
 c059ffc:	f7ff ff4e 	bl	c059e9c <StSafeA_TransmitCommand>
    if (status_code == STSAFEA_OK)
 c05a000:	4605      	mov	r5, r0
 c05a002:	b9e8      	cbnz	r0, c05a040 <StSafeA_DataPartitionQuery+0x78>
      pStSafeA->InOutBuffer.LV.Length = STSAFEA_DATA_PARTITION_QUERY_MIN_RESPONSE_LENGTH + STSAFEA_R_MAC_LENGTH(InMAC);
 c05a004:	f89d 3007 	ldrb.w	r3, [sp, #7]
      StSafeA_Delay(STSAFEA_MS_WAIT_TIME_CMD_QUERY);
 c05a008:	4638      	mov	r0, r7
      pStSafeA->InOutBuffer.LV.Length = STSAFEA_DATA_PARTITION_QUERY_MIN_RESPONSE_LENGTH + STSAFEA_R_MAC_LENGTH(InMAC);
 c05a00a:	091b      	lsrs	r3, r3, #4
 c05a00c:	f003 0304 	and.w	r3, r3, #4
 c05a010:	443b      	add	r3, r7
 c05a012:	80b3      	strh	r3, [r6, #4]
      StSafeA_Delay(STSAFEA_MS_WAIT_TIME_CMD_QUERY);
 c05a014:	f000 ff44 	bl	c05aea0 <StSafeA_Delay>
      status_code = StSafeA_ReceiveResponse(pStSafeA);
 c05a018:	4630      	mov	r0, r6
 c05a01a:	f7ff ff4e 	bl	c059eba <StSafeA_ReceiveResponse>
      if (status_code == STSAFEA_OK)
 c05a01e:	4605      	mov	r5, r0
 c05a020:	b970      	cbnz	r0, c05a040 <StSafeA_DataPartitionQuery+0x78>
        pOutDataPartition->Length = pStSafeA->InOutBuffer.LV.Length;
 c05a022:	88b3      	ldrh	r3, [r6, #4]
        for (uint8_t i = 0; i < pOutDataPartition->NumberOfZones; i++)
 c05a024:	4680      	mov	r8, r0
        pOutDataPartition->Length = pStSafeA->InOutBuffer.LV.Length;
 c05a026:	8023      	strh	r3, [r4, #0]
          if (pOutDataPartition->pZoneInfoRecord[i].ZoneType == STSAFEA_ONE_WAY_COUNTER_PRESENCE)
 c05a028:	270c      	movs	r7, #12
        pOutDataPartition->NumberOfZones = pStSafeA->InOutBuffer.LV.Data[0];
 c05a02a:	68b3      	ldr	r3, [r6, #8]
            pOutDataPartition->pZoneInfoRecord[i].OneWayCounter = 0;
 c05a02c:	4606      	mov	r6, r0
        pOutDataPartition->NumberOfZones = pStSafeA->InOutBuffer.LV.Data[0];
 c05a02e:	f813 2b01 	ldrb.w	r2, [r3], #1
 c05a032:	70a2      	strb	r2, [r4, #2]
        pOutDataPartition->pZoneInfoRecord = (StSafeA_ZoneInformationRecordBuffer_t *)&pStSafeA->InOutBuffer.LV.Data[1];
 c05a034:	6063      	str	r3, [r4, #4]
        for (uint8_t i = 0; i < pOutDataPartition->NumberOfZones; i++)
 c05a036:	78a0      	ldrb	r0, [r4, #2]
 c05a038:	fa5f f288 	uxtb.w	r2, r8
 c05a03c:	4282      	cmp	r2, r0
 c05a03e:	d303      	bcc.n	c05a048 <StSafeA_DataPartitionQuery+0x80>
}
 c05a040:	4628      	mov	r0, r5
 c05a042:	b003      	add	sp, #12
 c05a044:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
          if (pOutDataPartition->pZoneInfoRecord[i].ZoneType == STSAFEA_ONE_WAY_COUNTER_PRESENCE)
 c05a048:	fb07 f902 	mul.w	r9, r7, r2
 c05a04c:	f8d4 c004 	ldr.w	ip, [r4, #4]
          uIdx = (uint16_t)(i * sizeof(StSafeA_ZoneInformationRecordBuffer_t)) + 1U;
 c05a050:	eb02 0342 	add.w	r3, r2, r2, lsl #1
          if (pOutDataPartition->pZoneInfoRecord[i].ZoneType == STSAFEA_ONE_WAY_COUNTER_PRESENCE)
 c05a054:	eb0c 0109 	add.w	r1, ip, r9
 c05a058:	f891 e001 	ldrb.w	lr, [r1, #1]
          uIdx = (uint16_t)(i * sizeof(StSafeA_ZoneInformationRecordBuffer_t)) + 1U;
 c05a05c:	009b      	lsls	r3, r3, #2
 c05a05e:	3301      	adds	r3, #1
          if (pOutDataPartition->pZoneInfoRecord[i].ZoneType == STSAFEA_ONE_WAY_COUNTER_PRESENCE)
 c05a060:	f1be 0f01 	cmp.w	lr, #1
          uIdx = (uint16_t)(i * sizeof(StSafeA_ZoneInformationRecordBuffer_t)) + 1U;
 c05a064:	b29b      	uxth	r3, r3
          if (pOutDataPartition->pZoneInfoRecord[i].ZoneType == STSAFEA_ONE_WAY_COUNTER_PRESENCE)
 c05a066:	d124      	bne.n	c05a0b2 <StSafeA_DataPartitionQuery+0xea>
                          (uint32_t)pOutDataPartition->Length - uIdx - 3U);
 c05a068:	8822      	ldrh	r2, [r4, #0]
            (void)memmove(&pOutDataPartition->pZoneInfoRecord[i].ReadAccessCondition + 3U,
 c05a06a:	f109 0006 	add.w	r0, r9, #6
                          (uint32_t)pOutDataPartition->Length - uIdx - 3U);
 c05a06e:	3a03      	subs	r2, #3
            (void)memmove(&pOutDataPartition->pZoneInfoRecord[i].ReadAccessCondition + 3U,
 c05a070:	1ad2      	subs	r2, r2, r3
 c05a072:	3103      	adds	r1, #3
 c05a074:	4460      	add	r0, ip
 c05a076:	f001 fb1a 	bl	c05b6ae <memmove>
            pOutDataPartition->Length += 3U;
 c05a07a:	8823      	ldrh	r3, [r4, #0]
 c05a07c:	3303      	adds	r3, #3
 c05a07e:	8023      	strh	r3, [r4, #0]
              SWAP4BYTES(pOutDataPartition->pZoneInfoRecord[i].OneWayCounter);
 c05a080:	6863      	ldr	r3, [r4, #4]
 c05a082:	444b      	add	r3, r9
 c05a084:	689a      	ldr	r2, [r3, #8]
 c05a086:	ba12      	rev	r2, r2
            pOutDataPartition->pZoneInfoRecord[i].OneWayCounter =
 c05a088:	609a      	str	r2, [r3, #8]
            (uint16_t)SWAP2BYTES(pOutDataPartition->pZoneInfoRecord[i].DataSegmentLength);
 c05a08a:	6863      	ldr	r3, [r4, #4]
 c05a08c:	f108 0801 	add.w	r8, r8, #1
 c05a090:	444b      	add	r3, r9
 c05a092:	88da      	ldrh	r2, [r3, #6]
 c05a094:	ba52      	rev16	r2, r2
          pOutDataPartition->pZoneInfoRecord[i].DataSegmentLength =
 c05a096:	80da      	strh	r2, [r3, #6]
            pOutDataPartition->pZoneInfoRecord[i].ReadAcChangeRight & 0X07U;
 c05a098:	789a      	ldrb	r2, [r3, #2]
 c05a09a:	f002 0107 	and.w	r1, r2, #7
          pOutDataPartition->pZoneInfoRecord[i].UpdateAccessCondition =
 c05a09e:	7159      	strb	r1, [r3, #5]
            (pOutDataPartition->pZoneInfoRecord[i].ReadAcChangeRight & 0X08U) >> 3;
 c05a0a0:	f3c2 01c0 	ubfx	r1, r2, #3, #1
          pOutDataPartition->pZoneInfoRecord[i].UpdateAcChangeRight   =
 c05a0a4:	7119      	strb	r1, [r3, #4]
            (pOutDataPartition->pZoneInfoRecord[i].ReadAcChangeRight & 0X70U) >> 4;
 c05a0a6:	f3c2 1102 	ubfx	r1, r2, #4, #3
            (pOutDataPartition->pZoneInfoRecord[i].ReadAcChangeRight & 0X80U) >> 7;
 c05a0aa:	09d2      	lsrs	r2, r2, #7
          pOutDataPartition->pZoneInfoRecord[i].ReadAccessCondition   =
 c05a0ac:	70d9      	strb	r1, [r3, #3]
          pOutDataPartition->pZoneInfoRecord[i].ReadAcChangeRight     =
 c05a0ae:	709a      	strb	r2, [r3, #2]
        for (uint8_t i = 0; i < pOutDataPartition->NumberOfZones; i++)
 c05a0b0:	e7c1      	b.n	c05a036 <StSafeA_DataPartitionQuery+0x6e>
            if ((i + 1U) < pOutDataPartition->NumberOfZones)
 c05a0b2:	3201      	adds	r2, #1
 c05a0b4:	4282      	cmp	r2, r0
 c05a0b6:	d20b      	bcs.n	c05a0d0 <StSafeA_DataPartitionQuery+0x108>
                            (uint32_t)pOutDataPartition->Length - uIdx - 5U);
 c05a0b8:	8822      	ldrh	r2, [r4, #0]
              (void)memmove(&pOutDataPartition->pZoneInfoRecord[i + 1U].Index,
 c05a0ba:	f109 000c 	add.w	r0, r9, #12
                            (uint32_t)pOutDataPartition->Length - uIdx - 5U);
 c05a0be:	3a05      	subs	r2, #5
              (void)memmove(&pOutDataPartition->pZoneInfoRecord[i + 1U].Index,
 c05a0c0:	1ad2      	subs	r2, r2, r3
 c05a0c2:	3105      	adds	r1, #5
 c05a0c4:	4460      	add	r0, ip
 c05a0c6:	f001 faf2 	bl	c05b6ae <memmove>
              pOutDataPartition->Length += 7U;
 c05a0ca:	8823      	ldrh	r3, [r4, #0]
 c05a0cc:	3307      	adds	r3, #7
 c05a0ce:	8023      	strh	r3, [r4, #0]
            pOutDataPartition->pZoneInfoRecord[i].OneWayCounter = 0;
 c05a0d0:	6863      	ldr	r3, [r4, #4]
 c05a0d2:	444b      	add	r3, r9
              pOutDataPartition->pZoneInfoRecord[i].ReadAccessCondition +
 c05a0d4:	f8b3 2003 	ldrh.w	r2, [r3, #3]
            pOutDataPartition->pZoneInfoRecord[i].OneWayCounter = 0;
 c05a0d8:	721e      	strb	r6, [r3, #8]
 c05a0da:	725e      	strb	r6, [r3, #9]
 c05a0dc:	729e      	strb	r6, [r3, #10]
 c05a0de:	72de      	strb	r6, [r3, #11]
            pOutDataPartition->pZoneInfoRecord[i].DataSegmentLength =
 c05a0e0:	80da      	strh	r2, [r3, #6]
 c05a0e2:	e7d2      	b.n	c05a08a <StSafeA_DataPartitionQuery+0xc2>
  StSafeA_ResponseCode_t status_code = STSAFEA_INVALID_PARAMETER;
 c05a0e4:	2530      	movs	r5, #48	@ 0x30
 c05a0e6:	e7ab      	b.n	c05a040 <StSafeA_DataPartitionQuery+0x78>

0c05a0e8 <StSafeA_Read>:
{
 c05a0e8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 c05a0ec:	460e      	mov	r6, r1
 c05a0ee:	4690      	mov	r8, r2
 c05a0f0:	461f      	mov	r7, r3
  if (IS_STSAFEA_HANDLER_VALID_PTR(pStSafeA))
 c05a0f2:	4604      	mov	r4, r0
{
 c05a0f4:	f8bd 5024 	ldrh.w	r5, [sp, #36]	@ 0x24
  if (IS_STSAFEA_HANDLER_VALID_PTR(pStSafeA))
 c05a0f8:	2800      	cmp	r0, #0
 c05a0fa:	d03e      	beq.n	c05a17a <StSafeA_Read+0x92>
 c05a0fc:	6883      	ldr	r3, [r0, #8]
 c05a0fe:	2b00      	cmp	r3, #0
 c05a100:	d03b      	beq.n	c05a17a <StSafeA_Read+0x92>
    STSAFEA_CHECK_SIZE(STSAFEA_MAC_NONE, 0U, InRespDataLen);
 c05a102:	f5b5 7ffc 	cmp.w	r5, #504	@ 0x1f8
 c05a106:	d83a      	bhi.n	c05a17e <StSafeA_Read+0x96>
    StSafeA_BuildCommandHeaderCMAC(pStSafeA, STSAFEA_CMD_READ, &InMAC);
 c05a108:	2105      	movs	r1, #5
 c05a10a:	aa0b      	add	r2, sp, #44	@ 0x2c
 c05a10c:	f7ff ff43 	bl	c059f96 <StSafeA_BuildCommandHeaderCMAC>
    pStSafeA->InOutBuffer.LV.Data[0] = (InChangeACIndicator == 0U) ? 0x00U :
 c05a110:	b12e      	cbz	r6, c05a11e <StSafeA_Read+0x36>
                                       ((uint8_t)((InNewReadACRight == 0U) ? 0x10U : 0x18U) | (uint8_t)InNewReadAC);
 c05a112:	f1b8 0f00 	cmp.w	r8, #0
 c05a116:	bf14      	ite	ne
 c05a118:	2618      	movne	r6, #24
 c05a11a:	2610      	moveq	r6, #16
    pStSafeA->InOutBuffer.LV.Data[0] = (InChangeACIndicator == 0U) ? 0x00U :
 c05a11c:	433e      	orrs	r6, r7
 c05a11e:	68a3      	ldr	r3, [r4, #8]
    pStSafeA->InOutBuffer.LV.Data[1] = InZoneIndex;
 c05a120:	f89d 2018 	ldrb.w	r2, [sp, #24]
    pStSafeA->InOutBuffer.LV.Data[0] = (InChangeACIndicator == 0U) ? 0x00U :
 c05a124:	701e      	strb	r6, [r3, #0]
    pStSafeA->InOutBuffer.LV.Data[1] = InZoneIndex;
 c05a126:	68a3      	ldr	r3, [r4, #8]
    status_code = StSafeA_TransmitCommand(pStSafeA);
 c05a128:	4620      	mov	r0, r4
    pStSafeA->InOutBuffer.LV.Data[1] = InZoneIndex;
 c05a12a:	705a      	strb	r2, [r3, #1]
    uint16_t offset = (uint16_t)SWAP2BYTES(InOffset);
 c05a12c:	f8bd 301c 	ldrh.w	r3, [sp, #28]
    (void)memcpy(&pStSafeA->InOutBuffer.LV.Data[2], &offset, sizeof(offset));
 c05a130:	68a2      	ldr	r2, [r4, #8]
    uint16_t offset = (uint16_t)SWAP2BYTES(InOffset);
 c05a132:	ba5b      	rev16	r3, r3
    (void)memcpy(&pStSafeA->InOutBuffer.LV.Data[2], &offset, sizeof(offset));
 c05a134:	8053      	strh	r3, [r2, #2]
    length = (uint16_t)SWAP2BYTES(InAmount);
 c05a136:	f8bd 3020 	ldrh.w	r3, [sp, #32]
    (void)memcpy(&pStSafeA->InOutBuffer.LV.Data[4], &length, sizeof(InAmount));
 c05a13a:	68a2      	ldr	r2, [r4, #8]
    length = (uint16_t)SWAP2BYTES(InAmount);
 c05a13c:	ba5b      	rev16	r3, r3
    (void)memcpy(&pStSafeA->InOutBuffer.LV.Data[4], &length, sizeof(InAmount));
 c05a13e:	8093      	strh	r3, [r2, #4]
    pStSafeA->InOutBuffer.LV.Length = 6U;
 c05a140:	2306      	movs	r3, #6
 c05a142:	80a3      	strh	r3, [r4, #4]
    status_code = StSafeA_TransmitCommand(pStSafeA);
 c05a144:	f7ff feaa 	bl	c059e9c <StSafeA_TransmitCommand>
    if (status_code == STSAFEA_OK)
 c05a148:	4603      	mov	r3, r0
 c05a14a:	b998      	cbnz	r0, c05a174 <StSafeA_Read+0x8c>
      pStSafeA->InOutBuffer.LV.Length = InRespDataLen + STSAFEA_R_MAC_LENGTH(InMAC);
 c05a14c:	f89d 302c 	ldrb.w	r3, [sp, #44]	@ 0x2c
 c05a150:	091b      	lsrs	r3, r3, #4
 c05a152:	f003 0304 	and.w	r3, r3, #4
 c05a156:	442b      	add	r3, r5
 c05a158:	80a3      	strh	r3, [r4, #4]
      StSafeA_Delay(STSAFEA_MS_WAIT_TIME_CMD_READ);
 c05a15a:	f000 fea1 	bl	c05aea0 <StSafeA_Delay>
      status_code = StSafeA_ReceiveResponse(pStSafeA);
 c05a15e:	4620      	mov	r0, r4
 c05a160:	f7ff feab 	bl	c059eba <StSafeA_ReceiveResponse>
      if (status_code == STSAFEA_OK)
 c05a164:	4603      	mov	r3, r0
 c05a166:	b928      	cbnz	r0, c05a174 <StSafeA_Read+0x8c>
        status_code = StSafeA_AssignLVResponse(pOutLVResponse, &pStSafeA->InOutBuffer.LV, InRespDataLen);
 c05a168:	462a      	mov	r2, r5
 c05a16a:	980a      	ldr	r0, [sp, #40]	@ 0x28
 c05a16c:	1d21      	adds	r1, r4, #4
 c05a16e:	f7ff fe77 	bl	c059e60 <StSafeA_AssignLVResponse>
 c05a172:	4603      	mov	r3, r0
}
 c05a174:	4618      	mov	r0, r3
 c05a176:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  StSafeA_ResponseCode_t status_code = STSAFEA_INVALID_PARAMETER;
 c05a17a:	2330      	movs	r3, #48	@ 0x30
 c05a17c:	e7fa      	b.n	c05a174 <StSafeA_Read+0x8c>
    STSAFEA_CHECK_SIZE(STSAFEA_MAC_NONE, 0U, InRespDataLen);
 c05a17e:	2306      	movs	r3, #6
 c05a180:	e7f8      	b.n	c05a174 <StSafeA_Read+0x8c>

0c05a182 <StSafeA_Process_Update>:
{
 c05a182:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 c05a186:	9f09      	ldr	r7, [sp, #36]	@ 0x24
 c05a188:	4688      	mov	r8, r1
 c05a18a:	4616      	mov	r6, r2
 c05a18c:	461d      	mov	r5, r3
  if (IS_STSAFEA_HANDLER_VALID_PTR(pStSafeA))
 c05a18e:	4604      	mov	r4, r0
 c05a190:	2800      	cmp	r0, #0
 c05a192:	d049      	beq.n	c05a228 <StSafeA_Process_Update+0xa6>
 c05a194:	6883      	ldr	r3, [r0, #8]
 c05a196:	2b00      	cmp	r3, #0
 c05a198:	d046      	beq.n	c05a228 <StSafeA_Process_Update+0xa6>
    StSafeA_BuildCommandHeaderCMAC(pStSafeA, STSAFEA_CMD_UPDATE, &InMAC);
 c05a19a:	2106      	movs	r1, #6
 c05a19c:	aa0a      	add	r2, sp, #40	@ 0x28
 c05a19e:	f7ff fefa 	bl	c059f96 <StSafeA_BuildCommandHeaderCMAC>
    tmp |= (InNewUpdateAC & STSAFEA_AC_MSK) << STSAFEA_CMD_UPDATE_HEADER_NEWUPDAC_POS;
 c05a1a2:	f89d 3018 	ldrb.w	r3, [sp, #24]
    tmp |= (InNewUpdateACRight & 0x01U) << STSAFEA_CMD_UPDATE_HEADER_NEWUPDRIGHT_POS;
 c05a1a6:	00ed      	lsls	r5, r5, #3
    tmp |= (InNewUpdateAC & STSAFEA_AC_MSK) << STSAFEA_CMD_UPDATE_HEADER_NEWUPDAC_POS;
 c05a1a8:	f003 0307 	and.w	r3, r3, #7
    tmp |= (InNewUpdateACRight & 0x01U) << STSAFEA_CMD_UPDATE_HEADER_NEWUPDRIGHT_POS;
 c05a1ac:	f005 0508 	and.w	r5, r5, #8
 c05a1b0:	431d      	orrs	r5, r3
    tmp |= (InChangeACIndicator & 0x01U) << STSAFEA_CMD_UPDATE_HEADER_CHAC_POS;
 c05a1b2:	0136      	lsls	r6, r6, #4
    pStSafeA->InOutBuffer.LV.Data[0] = tmp;
 c05a1b4:	68a3      	ldr	r3, [r4, #8]
 c05a1b6:	ea45 11c8 	orr.w	r1, r5, r8, lsl #7
    tmp |= (InChangeACIndicator & 0x01U) << STSAFEA_CMD_UPDATE_HEADER_CHAC_POS;
 c05a1ba:	f006 0610 	and.w	r6, r6, #16
    tmp |= (InNewUpdateAC & STSAFEA_AC_MSK) << STSAFEA_CMD_UPDATE_HEADER_NEWUPDAC_POS;
 c05a1be:	ea41 0206 	orr.w	r2, r1, r6
    pStSafeA->InOutBuffer.LV.Data[0] = tmp;
 c05a1c2:	701a      	strb	r2, [r3, #0]
    pStSafeA->InOutBuffer.LV.Data[1] = InZoneIndex;
 c05a1c4:	68a3      	ldr	r3, [r4, #8]
 c05a1c6:	f89d 201c 	ldrb.w	r2, [sp, #28]
 c05a1ca:	705a      	strb	r2, [r3, #1]
    uint16_t offset = (uint16_t)SWAP2BYTES(InOffset);
 c05a1cc:	f8bd 3020 	ldrh.w	r3, [sp, #32]
    (void)memcpy(&pStSafeA->InOutBuffer.LV.Data[2], &offset, sizeof(offset));
 c05a1d0:	68a2      	ldr	r2, [r4, #8]
    uint16_t offset = (uint16_t)SWAP2BYTES(InOffset);
 c05a1d2:	ba5b      	rev16	r3, r3
    (void)memcpy(&pStSafeA->InOutBuffer.LV.Data[2], &offset, sizeof(offset));
 c05a1d4:	8053      	strh	r3, [r2, #2]
    pStSafeA->InOutBuffer.LV.Length = 4U;
 c05a1d6:	2304      	movs	r3, #4
 c05a1d8:	80a3      	strh	r3, [r4, #4]
    if ((pInLVData != NULL) && (pInLVData->Length > 0U))
 c05a1da:	b187      	cbz	r7, c05a1fe <StSafeA_Process_Update+0x7c>
 c05a1dc:	883a      	ldrh	r2, [r7, #0]
 c05a1de:	b172      	cbz	r2, c05a1fe <StSafeA_Process_Update+0x7c>
      STSAFEA_CHECK_SIZE(InMAC, pStSafeA->InOutBuffer.LV.Length, pInLVData->Length);
 c05a1e0:	f89d 3028 	ldrb.w	r3, [sp, #40]	@ 0x28
 c05a1e4:	b9eb      	cbnz	r3, c05a222 <StSafeA_Process_Update+0xa0>
 c05a1e6:	f5b2 7ffa 	cmp.w	r2, #500	@ 0x1f4
 c05a1ea:	d81f      	bhi.n	c05a22c <StSafeA_Process_Update+0xaa>
      (void)memcpy(&pStSafeA->InOutBuffer.LV.Data[pStSafeA->InOutBuffer.LV.Length],
 c05a1ec:	68a0      	ldr	r0, [r4, #8]
 c05a1ee:	6879      	ldr	r1, [r7, #4]
 c05a1f0:	3004      	adds	r0, #4
 c05a1f2:	f001 fa2b 	bl	c05b64c <memcpy>
      pStSafeA->InOutBuffer.LV.Length += pInLVData->Length;
 c05a1f6:	88a3      	ldrh	r3, [r4, #4]
 c05a1f8:	883a      	ldrh	r2, [r7, #0]
 c05a1fa:	4413      	add	r3, r2
 c05a1fc:	80a3      	strh	r3, [r4, #4]
    status_code = StSafeA_TransmitCommand(pStSafeA);
 c05a1fe:	4620      	mov	r0, r4
 c05a200:	f7ff fe4c 	bl	c059e9c <StSafeA_TransmitCommand>
    if (status_code == STSAFEA_OK)
 c05a204:	b958      	cbnz	r0, c05a21e <StSafeA_Process_Update+0x9c>
      pStSafeA->InOutBuffer.LV.Length = STSAFEA_R_MAC_LENGTH(InMAC);
 c05a206:	f89d 3028 	ldrb.w	r3, [sp, #40]	@ 0x28
      StSafeA_Delay(STSAFEA_MS_WAIT_TIME_CMD_UPDATE);
 c05a20a:	200f      	movs	r0, #15
      pStSafeA->InOutBuffer.LV.Length = STSAFEA_R_MAC_LENGTH(InMAC);
 c05a20c:	091b      	lsrs	r3, r3, #4
 c05a20e:	f003 0304 	and.w	r3, r3, #4
 c05a212:	80a3      	strh	r3, [r4, #4]
      StSafeA_Delay(STSAFEA_MS_WAIT_TIME_CMD_UPDATE);
 c05a214:	f000 fe44 	bl	c05aea0 <StSafeA_Delay>
      status_code = StSafeA_ReceiveResponse(pStSafeA);
 c05a218:	4620      	mov	r0, r4
 c05a21a:	f7ff fe4e 	bl	c059eba <StSafeA_ReceiveResponse>
}
 c05a21e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      STSAFEA_CHECK_SIZE(InMAC, pStSafeA->InOutBuffer.LV.Length, pInLVData->Length);
 c05a222:	f5b2 7ff8 	cmp.w	r2, #496	@ 0x1f0
 c05a226:	e7e0      	b.n	c05a1ea <StSafeA_Process_Update+0x68>
  StSafeA_ResponseCode_t status_code = STSAFEA_INVALID_PARAMETER;
 c05a228:	2030      	movs	r0, #48	@ 0x30
 c05a22a:	e7f8      	b.n	c05a21e <StSafeA_Process_Update+0x9c>
 c05a22c:	2006      	movs	r0, #6
 c05a22e:	e7f6      	b.n	c05a21e <StSafeA_Process_Update+0x9c>

0c05a230 <StSafeA_Update>:
{
 c05a230:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  if ((InAtomicity == STSAFEA_FLAG_TRUE) && (pInLVData->Length > STSAFEA_ATOMICITY_BUFFER_SIZE))
 c05a234:	2901      	cmp	r1, #1
{
 c05a236:	b08b      	sub	sp, #44	@ 0x2c
 c05a238:	4605      	mov	r5, r0
 c05a23a:	f89d 7050 	ldrb.w	r7, [sp, #80]	@ 0x50
 c05a23e:	f89d 8054 	ldrb.w	r8, [sp, #84]	@ 0x54
 c05a242:	f8bd 4058 	ldrh.w	r4, [sp, #88]	@ 0x58
 c05a246:	9e17      	ldr	r6, [sp, #92]	@ 0x5c
 c05a248:	f89d 9060 	ldrb.w	r9, [sp, #96]	@ 0x60
  if ((InAtomicity == STSAFEA_FLAG_TRUE) && (pInLVData->Length > STSAFEA_ATOMICITY_BUFFER_SIZE))
 c05a24c:	d13f      	bne.n	c05a2ce <StSafeA_Update+0x9e>
 c05a24e:	8830      	ldrh	r0, [r6, #0]
 c05a250:	2840      	cmp	r0, #64	@ 0x40
 c05a252:	d93c      	bls.n	c05a2ce <StSafeA_Update+0x9e>
    pLVData.Length = STSAFEA_ATOMICITY_BUFFER_SIZE;
 c05a254:	2140      	movs	r1, #64	@ 0x40
    for (i = 0; i < (pInLVData->Length / STSAFEA_ATOMICITY_BUFFER_SIZE); i++)
 c05a256:	f04f 0a00 	mov.w	sl, #0
  StSafeA_ResponseCode_t status_code = STSAFEA_INVALID_PARAMETER;
 c05a25a:	2030      	movs	r0, #48	@ 0x30
    pLVData.Length = STSAFEA_ATOMICITY_BUFFER_SIZE;
 c05a25c:	f8ad 1020 	strh.w	r1, [sp, #32]
    pLVData.Data = pInLVData->Data;
 c05a260:	6871      	ldr	r1, [r6, #4]
      status_code = StSafeA_Process_Update(pStSafeA, InAtomicity, InChangeACIndicator, InNewUpdateACRight,
 c05a262:	f10d 0b20 	add.w	fp, sp, #32
    pLVData.Data = pInLVData->Data;
 c05a266:	9109      	str	r1, [sp, #36]	@ 0x24
    for (i = 0; i < (pInLVData->Length / STSAFEA_ATOMICITY_BUFFER_SIZE); i++)
 c05a268:	8831      	ldrh	r1, [r6, #0]
 c05a26a:	fa5f fc8a 	uxtb.w	ip, sl
 c05a26e:	ebbc 1f91 	cmp.w	ip, r1, lsr #6
 c05a272:	d311      	bcc.n	c05a298 <StSafeA_Update+0x68>
    if (status_code == STSAFEA_OK)
 c05a274:	bb48      	cbnz	r0, c05a2ca <StSafeA_Update+0x9a>
      pLVData.Length = pInLVData->Length % STSAFEA_ATOMICITY_BUFFER_SIZE;
 c05a276:	f001 013f 	and.w	r1, r1, #63	@ 0x3f
 c05a27a:	f8ad 1020 	strh.w	r1, [sp, #32]
      if (pLVData.Length != 0U)
 c05a27e:	b309      	cbz	r1, c05a2c4 <StSafeA_Update+0x94>
        status_code = StSafeA_Process_Update(pStSafeA, InAtomicity, InChangeACIndicator, InNewUpdateACRight,
 c05a280:	a908      	add	r1, sp, #32
 c05a282:	e9cd 4102 	strd	r4, r1, [sp, #8]
 c05a286:	4628      	mov	r0, r5
 c05a288:	2101      	movs	r1, #1
 c05a28a:	e9cd 7800 	strd	r7, r8, [sp]
 c05a28e:	f8cd 9010 	str.w	r9, [sp, #16]
 c05a292:	f7ff ff76 	bl	c05a182 <StSafeA_Process_Update>
 c05a296:	e015      	b.n	c05a2c4 <StSafeA_Update+0x94>
      status_code = StSafeA_Process_Update(pStSafeA, InAtomicity, InChangeACIndicator, InNewUpdateACRight,
 c05a298:	2101      	movs	r1, #1
 c05a29a:	e9cd 8401 	strd	r8, r4, [sp, #4]
 c05a29e:	4628      	mov	r0, r5
 c05a2a0:	e9cd b903 	strd	fp, r9, [sp, #12]
 c05a2a4:	9700      	str	r7, [sp, #0]
 c05a2a6:	e9cd 2306 	strd	r2, r3, [sp, #24]
 c05a2aa:	f7ff ff6a 	bl	c05a182 <StSafeA_Process_Update>
      if (status_code != STSAFEA_OK)
 c05a2ae:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
      pLVData.Data += STSAFEA_ATOMICITY_BUFFER_SIZE;
 c05a2b2:	9909      	ldr	r1, [sp, #36]	@ 0x24
      InOffset += STSAFEA_ATOMICITY_BUFFER_SIZE;
 c05a2b4:	3440      	adds	r4, #64	@ 0x40
      pLVData.Data += STSAFEA_ATOMICITY_BUFFER_SIZE;
 c05a2b6:	3140      	adds	r1, #64	@ 0x40
      InOffset += STSAFEA_ATOMICITY_BUFFER_SIZE;
 c05a2b8:	b2a4      	uxth	r4, r4
      pLVData.Data += STSAFEA_ATOMICITY_BUFFER_SIZE;
 c05a2ba:	9109      	str	r1, [sp, #36]	@ 0x24
      if (status_code != STSAFEA_OK)
 c05a2bc:	f10a 0a01 	add.w	sl, sl, #1
 c05a2c0:	2800      	cmp	r0, #0
 c05a2c2:	d0d1      	beq.n	c05a268 <StSafeA_Update+0x38>
}
 c05a2c4:	b00b      	add	sp, #44	@ 0x2c
 c05a2c6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 c05a2ca:	2030      	movs	r0, #48	@ 0x30
  {
 c05a2cc:	e7fa      	b.n	c05a2c4 <StSafeA_Update+0x94>
    status_code = StSafeA_Process_Update(pStSafeA, InAtomicity, InChangeACIndicator, InNewUpdateACRight,
 c05a2ce:	4628      	mov	r0, r5
 c05a2d0:	e9cd 6917 	strd	r6, r9, [sp, #92]	@ 0x5c
 c05a2d4:	e9cd 8415 	strd	r8, r4, [sp, #84]	@ 0x54
 c05a2d8:	9714      	str	r7, [sp, #80]	@ 0x50
}
 c05a2da:	b00b      	add	sp, #44	@ 0x2c
 c05a2dc:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    status_code = StSafeA_Process_Update(pStSafeA, InAtomicity, InChangeACIndicator, InNewUpdateACRight,
 c05a2e0:	f7ff bf4f 	b.w	c05a182 <StSafeA_Process_Update>

0c05a2e4 <StSafeA_GenerateKeyPair>:
{
 c05a2e4:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c05a2e8:	468b      	mov	fp, r1
 c05a2ea:	e9dd 870d 	ldrd	r8, r7, [sp, #52]	@ 0x34
 c05a2ee:	4691      	mov	r9, r2
 c05a2f0:	469a      	mov	sl, r3
  if (IS_STSAFEA_HANDLER_VALID_PTR(pStSafeA)              &&
 c05a2f2:	4604      	mov	r4, r0
{
 c05a2f4:	f89d 502c 	ldrb.w	r5, [sp, #44]	@ 0x2c
 c05a2f8:	f8bd 6030 	ldrh.w	r6, [sp, #48]	@ 0x30
  if (IS_STSAFEA_HANDLER_VALID_PTR(pStSafeA)              &&
 c05a2fc:	2800      	cmp	r0, #0
 c05a2fe:	f000 8092 	beq.w	c05a426 <StSafeA_GenerateKeyPair+0x142>
      IS_STSAFEA_CONDITIONAL_LVBUFFER_VALID_PTR(pOutPubX) &&
 c05a302:	6883      	ldr	r3, [r0, #8]
 c05a304:	2b00      	cmp	r3, #0
 c05a306:	f000 808e 	beq.w	c05a426 <StSafeA_GenerateKeyPair+0x142>
      IS_STSAFEA_CONDITIONAL_LVBUFFER_VALID_PTR(pOutPubY) &&
 c05a30a:	f1b8 0f00 	cmp.w	r8, #0
 c05a30e:	f000 808a 	beq.w	c05a426 <StSafeA_GenerateKeyPair+0x142>
    StSafeA_BuildCommandHeaderCMAC(pStSafeA, STSAFEA_CMD_GENERATE_KEY, &InMAC);
 c05a312:	aa10      	add	r2, sp, #64	@ 0x40
 c05a314:	2111      	movs	r1, #17
 c05a316:	f7ff fe3e 	bl	c059f96 <StSafeA_BuildCommandHeaderCMAC>
    pStSafeA->InOutBuffer.LV.Data[0] = (uint8_t)STSAFEA_TAG_PRIVATE_KEY_SLOT;
 c05a31a:	2213      	movs	r2, #19
      tmp_use_limit = 1;
 c05a31c:	f1bb 0fff 	cmp.w	fp, #255	@ 0xff
 c05a320:	bf08      	it	eq
 c05a322:	f04f 0901 	moveq.w	r9, #1
    tmp_use_limit = (InChangeAuthFlagsRight == 0x0U) ?
 c05a326:	f1ba 0a00 	subs.w	sl, sl, #0
 c05a32a:	bf18      	it	ne
 c05a32c:	f04f 0a01 	movne.w	sl, #1
    pStSafeA->InOutBuffer.LV.Data[0] = (uint8_t)STSAFEA_TAG_PRIVATE_KEY_SLOT;
 c05a330:	68a3      	ldr	r3, [r4, #8]
    tmp_use_limit = (uint16_t)SWAP2BYTES(tmp_use_limit);
 c05a332:	fa99 f999 	rev16.w	r9, r9
    pStSafeA->InOutBuffer.LV.Data[0] = (uint8_t)STSAFEA_TAG_PRIVATE_KEY_SLOT;
 c05a336:	701a      	strb	r2, [r3, #0]
    pStSafeA->InOutBuffer.LV.Data[1] = (uint8_t)InKeySlotNum;
 c05a338:	68a3      	ldr	r3, [r4, #8]
 c05a33a:	f883 b001 	strb.w	fp, [r3, #1]
    (void)memcpy(&pStSafeA->InOutBuffer.LV.Data[2], &tmp_use_limit, sizeof(uint16_t));
 c05a33e:	68a3      	ldr	r3, [r4, #8]
 c05a340:	f8a3 9002 	strh.w	r9, [r3, #2]
    tmp_use_limit |= InAuthorizationFlags & STSAFEA_PRIVATE_KEY_MODE_OF_OPERATION_AUTHORIZATION_FLAGS_MASK;
 c05a344:	f89d 3028 	ldrb.w	r3, [sp, #40]	@ 0x28
    (void)memcpy(&pStSafeA->InOutBuffer.LV.Data[4], &tmp_use_limit, sizeof(tmp_use_limit));
 c05a348:	68a2      	ldr	r2, [r4, #8]
    tmp_use_limit |= InAuthorizationFlags & STSAFEA_PRIVATE_KEY_MODE_OF_OPERATION_AUTHORIZATION_FLAGS_MASK;
 c05a34a:	f003 030d 	and.w	r3, r3, #13
 c05a34e:	ea43 33ca 	orr.w	r3, r3, sl, lsl #15
    tmp_use_limit = (uint16_t)SWAP2BYTES(tmp_use_limit);
 c05a352:	ba5b      	rev16	r3, r3
    (void)memcpy(&pStSafeA->InOutBuffer.LV.Data[4], &tmp_use_limit, sizeof(tmp_use_limit));
 c05a354:	8093      	strh	r3, [r2, #4]
    uint16_t tmp_curve_len = STSAFEA_GET_ECC_CURVE_OID_LEN(InCurveId);
 c05a356:	2d00      	cmp	r5, #0
 c05a358:	d04c      	beq.n	c05a3f4 <StSafeA_GenerateKeyPair+0x110>
 c05a35a:	2d01      	cmp	r5, #1
 c05a35c:	d04c      	beq.n	c05a3f8 <StSafeA_GenerateKeyPair+0x114>
 c05a35e:	1eab      	subs	r3, r5, #2
 c05a360:	2b01      	cmp	r3, #1
 c05a362:	bf8c      	ite	hi
 c05a364:	2200      	movhi	r2, #0
 c05a366:	2209      	movls	r2, #9
    (void)memcpy(&pStSafeA->InOutBuffer.LV.Data[8], STSAFEA_GET_ECC_CURVE_OID(InCurveId), tmp_curve_len);
 c05a368:	68a0      	ldr	r0, [r4, #8]
    tmp_use_limit = (uint16_t)SWAP2BYTES(tmp_curve_len);
 c05a36a:	fa92 fa92 	rev16.w	sl, r2
    tmp_len = 8U + tmp_curve_len;
 c05a36e:	f102 0908 	add.w	r9, r2, #8
    (void)memcpy(&pStSafeA->InOutBuffer.LV.Data[8], STSAFEA_GET_ECC_CURVE_OID(InCurveId), tmp_curve_len);
 c05a372:	3008      	adds	r0, #8
 c05a374:	2d00      	cmp	r5, #0
 c05a376:	d041      	beq.n	c05a3fc <StSafeA_GenerateKeyPair+0x118>
 c05a378:	1e6b      	subs	r3, r5, #1
 c05a37a:	b2db      	uxtb	r3, r3
 c05a37c:	2b02      	cmp	r3, #2
 c05a37e:	d83f      	bhi.n	c05a400 <StSafeA_GenerateKeyPair+0x11c>
 c05a380:	492b      	ldr	r1, [pc, #172]	@ (c05a430 <StSafeA_GenerateKeyPair+0x14c>)
 c05a382:	f851 1023 	ldr.w	r1, [r1, r3, lsl #2]
 c05a386:	f001 f961 	bl	c05b64c <memcpy>
    (void)memcpy(&pStSafeA->InOutBuffer.LV.Data[6], &tmp_use_limit, sizeof(uint16_t));
 c05a38a:	68a3      	ldr	r3, [r4, #8]
    status_code = StSafeA_TransmitCommand(pStSafeA);
 c05a38c:	4620      	mov	r0, r4
    (void)memcpy(&pStSafeA->InOutBuffer.LV.Data[6], &tmp_use_limit, sizeof(uint16_t));
 c05a38e:	f8a3 a006 	strh.w	sl, [r3, #6]
    pStSafeA->InOutBuffer.LV.Length = tmp_len;
 c05a392:	f8a4 9004 	strh.w	r9, [r4, #4]
    status_code = StSafeA_TransmitCommand(pStSafeA);
 c05a396:	f7ff fd81 	bl	c059e9c <StSafeA_TransmitCommand>
    if (status_code == STSAFEA_OK)
 c05a39a:	bb48      	cbnz	r0, c05a3f0 <StSafeA_GenerateKeyPair+0x10c>
      pStSafeA->InOutBuffer.LV.Length = STSAFEA_POINT_REPRESENTATION_ID_LEN +
 c05a39c:	2d03      	cmp	r5, #3
    if (status_code == STSAFEA_OK)
 c05a39e:	bf8c      	ite	hi
 c05a3a0:	2205      	movhi	r2, #5
 c05a3a2:	4b24      	ldrls	r3, [pc, #144]	@ (c05a434 <StSafeA_GenerateKeyPair+0x150>)
      StSafeA_Delay(STSAFEA_MS_WAIT_TIME_CMD_GENERATE_KEY);
 c05a3a4:	f04f 00a0 	mov.w	r0, #160	@ 0xa0
 c05a3a8:	bf98      	it	ls
 c05a3aa:	5d5a      	ldrbls	r2, [r3, r5]
                                        STSAFEA_R_MAC_LENGTH(InMAC);
 c05a3ac:	f89d 3040 	ldrb.w	r3, [sp, #64]	@ 0x40
 c05a3b0:	091b      	lsrs	r3, r3, #4
 c05a3b2:	f003 0304 	and.w	r3, r3, #4
                                              (uint16_t)STSAFEA_GET_XYRS_LEN_FROM_CURVE(InCurveId)) +
 c05a3b6:	441a      	add	r2, r3
      pStSafeA->InOutBuffer.LV.Length = STSAFEA_POINT_REPRESENTATION_ID_LEN +
 c05a3b8:	80a2      	strh	r2, [r4, #4]
      StSafeA_Delay(STSAFEA_MS_WAIT_TIME_CMD_GENERATE_KEY);
 c05a3ba:	f000 fd71 	bl	c05aea0 <StSafeA_Delay>
      status_code = StSafeA_ReceiveResponse(pStSafeA);
 c05a3be:	4620      	mov	r0, r4
 c05a3c0:	f7ff fd7b 	bl	c059eba <StSafeA_ReceiveResponse>
      if (status_code == STSAFEA_OK)
 c05a3c4:	b9a0      	cbnz	r0, c05a3f0 <StSafeA_GenerateKeyPair+0x10c>
        if (STSAFEA_GET_XYRS_LEN_FROM_CURVE(InCurveId) <= InPubXYLen)
 c05a3c6:	2d03      	cmp	r5, #3
 c05a3c8:	d803      	bhi.n	c05a3d2 <StSafeA_GenerateKeyPair+0xee>
 c05a3ca:	4b1b      	ldr	r3, [pc, #108]	@ (c05a438 <StSafeA_GenerateKeyPair+0x154>)
 c05a3cc:	5d5b      	ldrb	r3, [r3, r5]
 c05a3ce:	42b3      	cmp	r3, r6
 c05a3d0:	d82b      	bhi.n	c05a42a <StSafeA_GenerateKeyPair+0x146>
          if (pStSafeA->InOutBuffer.LV.Length >= uIdx)
 c05a3d2:	88a3      	ldrh	r3, [r4, #4]
 c05a3d4:	b9b3      	cbnz	r3, c05a404 <StSafeA_GenerateKeyPair+0x120>
          uint16_t uIdx = 1U;
 c05a3d6:	2301      	movs	r3, #1
        status_code = STSAFEA_INVALID_RESP_LENGTH;
 c05a3d8:	2031      	movs	r0, #49	@ 0x31
          if ((pStSafeA->InOutBuffer.LV.Length > (uIdx + sizeof(pOutPubY->Length))) && (status_code == STSAFEA_OK))
 c05a3da:	88a1      	ldrh	r1, [r4, #4]
 c05a3dc:	1c9a      	adds	r2, r3, #2
 c05a3de:	4291      	cmp	r1, r2
 c05a3e0:	d906      	bls.n	c05a3f0 <StSafeA_GenerateKeyPair+0x10c>
 c05a3e2:	b928      	cbnz	r0, c05a3f0 <StSafeA_GenerateKeyPair+0x10c>
            status_code = StSafeA_AssignLVBuffer(pOutPubY, &pStSafeA->InOutBuffer.LV.Data[uIdx], InPubXYLen);
 c05a3e4:	68a1      	ldr	r1, [r4, #8]
 c05a3e6:	4632      	mov	r2, r6
 c05a3e8:	980f      	ldr	r0, [sp, #60]	@ 0x3c
 c05a3ea:	4419      	add	r1, r3
 c05a3ec:	f7ff fd45 	bl	c059e7a <StSafeA_AssignLVBuffer>
}
 c05a3f0:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    uint16_t tmp_curve_len = STSAFEA_GET_ECC_CURVE_OID_LEN(InCurveId);
 c05a3f4:	2208      	movs	r2, #8
 c05a3f6:	e7b7      	b.n	c05a368 <StSafeA_GenerateKeyPair+0x84>
 c05a3f8:	2205      	movs	r2, #5
 c05a3fa:	e7b5      	b.n	c05a368 <StSafeA_GenerateKeyPair+0x84>
    (void)memcpy(&pStSafeA->InOutBuffer.LV.Data[8], STSAFEA_GET_ECC_CURVE_OID(InCurveId), tmp_curve_len);
 c05a3fc:	490f      	ldr	r1, [pc, #60]	@ (c05a43c <StSafeA_GenerateKeyPair+0x158>)
 c05a3fe:	e7c2      	b.n	c05a386 <StSafeA_GenerateKeyPair+0xa2>
 c05a400:	490f      	ldr	r1, [pc, #60]	@ (c05a440 <StSafeA_GenerateKeyPair+0x15c>)
 c05a402:	e7c0      	b.n	c05a386 <StSafeA_GenerateKeyPair+0xa2>
            *pOutPointReprensentationId = pStSafeA->InOutBuffer.LV.Data[0];
 c05a404:	68a3      	ldr	r3, [r4, #8]
 c05a406:	781b      	ldrb	r3, [r3, #0]
 c05a408:	f888 3000 	strb.w	r3, [r8]
          if (pStSafeA->InOutBuffer.LV.Length > (uIdx + sizeof(pOutPubX->Length)))
 c05a40c:	88a3      	ldrh	r3, [r4, #4]
 c05a40e:	2b03      	cmp	r3, #3
 c05a410:	d9e1      	bls.n	c05a3d6 <StSafeA_GenerateKeyPair+0xf2>
            status_code = StSafeA_AssignLVBuffer(pOutPubX, &pStSafeA->InOutBuffer.LV.Data[uIdx], InPubXYLen);
 c05a412:	68a1      	ldr	r1, [r4, #8]
 c05a414:	4632      	mov	r2, r6
 c05a416:	4638      	mov	r0, r7
 c05a418:	3101      	adds	r1, #1
 c05a41a:	f7ff fd2e 	bl	c059e7a <StSafeA_AssignLVBuffer>
            uIdx += (uint16_t)sizeof(pOutPubX->Length) + pOutPubX->Length ;
 c05a41e:	883b      	ldrh	r3, [r7, #0]
 c05a420:	3303      	adds	r3, #3
 c05a422:	b29b      	uxth	r3, r3
 c05a424:	e7d9      	b.n	c05a3da <StSafeA_GenerateKeyPair+0xf6>
  StSafeA_ResponseCode_t status_code = STSAFEA_INVALID_PARAMETER;
 c05a426:	2030      	movs	r0, #48	@ 0x30
 c05a428:	e7e2      	b.n	c05a3f0 <StSafeA_GenerateKeyPair+0x10c>
        status_code = STSAFEA_INVALID_RESP_LENGTH;
 c05a42a:	2031      	movs	r0, #49	@ 0x31
 c05a42c:	e7e0      	b.n	c05a3f0 <StSafeA_GenerateKeyPair+0x10c>
 c05a42e:	bf00      	nop
 c05a430:	0c0613ac 	.word	0x0c0613ac
 c05a434:	0c0613a6 	.word	0x0c0613a6
 c05a438:	0c0613a2 	.word	0x0c0613a2
 c05a43c:	0c060415 	.word	0x0c060415
 c05a440:	0c0613b8 	.word	0x0c0613b8

0c05a444 <StSafeA_GenerateSignature>:
{
 c05a444:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 c05a448:	9d09      	ldr	r5, [sp, #36]	@ 0x24
 c05a44a:	4689      	mov	r9, r1
 c05a44c:	4690      	mov	r8, r2
 c05a44e:	461f      	mov	r7, r3
  if (IS_STSAFEA_HANDLER_VALID_PTR(pStSafeA)                &&
 c05a450:	4604      	mov	r4, r0
{
 c05a452:	f89d 6030 	ldrb.w	r6, [sp, #48]	@ 0x30
  if (IS_STSAFEA_HANDLER_VALID_PTR(pStSafeA)                &&
 c05a456:	b910      	cbnz	r0, c05a45e <StSafeA_GenerateSignature+0x1a>
      return STSAFEA_INVALID_PARAMETER;
 c05a458:	2030      	movs	r0, #48	@ 0x30
}
 c05a45a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      IS_STSAFEA_CONDITIONAL_LVBUFFER_VALID_PTR(pOutSignR)  &&
 c05a45e:	6883      	ldr	r3, [r0, #8]
 c05a460:	2b00      	cmp	r3, #0
 c05a462:	d0f9      	beq.n	c05a458 <StSafeA_GenerateSignature+0x14>
    StSafeA_BuildCommandHeaderCMAC(pStSafeA, STSAFEA_CMD_GENERATE_SIGNATURE, &InMAC);
 c05a464:	aa0b      	add	r2, sp, #44	@ 0x2c
 c05a466:	2116      	movs	r1, #22
 c05a468:	f7ff fd95 	bl	c059f96 <StSafeA_BuildCommandHeaderCMAC>
    pStSafeA->InOutBuffer.LV.Data[1] = (uint8_t)((((InDigestType == STSAFEA_SHA_384) ?
 c05a46c:	2000      	movs	r0, #0
    pStSafeA->InOutBuffer.LV.Data[2] = ((InDigestType == STSAFEA_SHA_384) ?
 c05a46e:	2f01      	cmp	r7, #1
 c05a470:	bf0c      	ite	eq
 c05a472:	2230      	moveq	r2, #48	@ 0x30
 c05a474:	2220      	movne	r2, #32
    pStSafeA->InOutBuffer.LV.Data[0] = (uint8_t)InKeySlotNum;
 c05a476:	68a3      	ldr	r3, [r4, #8]
 c05a478:	eb08 0102 	add.w	r1, r8, r2
 c05a47c:	f883 9000 	strb.w	r9, [r3]
    pStSafeA->InOutBuffer.LV.Data[1] = (uint8_t)((((InDigestType == STSAFEA_SHA_384) ?
 c05a480:	68a3      	ldr	r3, [r4, #8]
 c05a482:	7058      	strb	r0, [r3, #1]
    pStSafeA->InOutBuffer.LV.Data[2] = ((InDigestType == STSAFEA_SHA_384) ?
 c05a484:	68a3      	ldr	r3, [r4, #8]
 c05a486:	709a      	strb	r2, [r3, #2]
    for (i = 0; i < DigestLength; i++)
 c05a488:	4643      	mov	r3, r8
      sum |= pInDigest[i];
 c05a48a:	f813 cb01 	ldrb.w	ip, [r3], #1
    for (i = 0; i < DigestLength; i++)
 c05a48e:	4299      	cmp	r1, r3
      sum |= pInDigest[i];
 c05a490:	ea4c 0000 	orr.w	r0, ip, r0
    for (i = 0; i < DigestLength; i++)
 c05a494:	d1f9      	bne.n	c05a48a <StSafeA_GenerateSignature+0x46>
    if (sum == 0U)
 c05a496:	2800      	cmp	r0, #0
 c05a498:	d0de      	beq.n	c05a458 <StSafeA_GenerateSignature+0x14>
    (void)memcpy(&pStSafeA->InOutBuffer.LV.Data[3],
 c05a49a:	68a0      	ldr	r0, [r4, #8]
 c05a49c:	4641      	mov	r1, r8
 c05a49e:	3003      	adds	r0, #3
 c05a4a0:	f001 f8d4 	bl	c05b64c <memcpy>
    pStSafeA->InOutBuffer.LV.Length = (uint16_t)((InDigestType == STSAFEA_SHA_384) ?
 c05a4a4:	2f01      	cmp	r7, #1
 c05a4a6:	bf0c      	ite	eq
 c05a4a8:	2333      	moveq	r3, #51	@ 0x33
 c05a4aa:	2323      	movne	r3, #35	@ 0x23
    if (((uint8_t)InHostEncryption & (uint8_t)STSAFEA_ENCRYPTION_COMMAND) == (uint8_t)STSAFEA_ENCRYPTION_COMMAND)
 c05a4ac:	07b2      	lsls	r2, r6, #30
    pStSafeA->InOutBuffer.LV.Length = (uint16_t)((InDigestType == STSAFEA_SHA_384) ?
 c05a4ae:	80a3      	strh	r3, [r4, #4]
    if (((uint8_t)InHostEncryption & (uint8_t)STSAFEA_ENCRYPTION_COMMAND) == (uint8_t)STSAFEA_ENCRYPTION_COMMAND)
 c05a4b0:	d429      	bmi.n	c05a506 <StSafeA_GenerateSignature+0xc2>
      status_code = StSafeA_TransmitCommand(pStSafeA);
 c05a4b2:	4620      	mov	r0, r4
 c05a4b4:	f7ff fcf2 	bl	c059e9c <StSafeA_TransmitCommand>
      if (status_code == STSAFEA_OK)
 c05a4b8:	2800      	cmp	r0, #0
 c05a4ba:	d1ce      	bne.n	c05a45a <StSafeA_GenerateSignature+0x16>
        uint16_t tmp_len = (InDigestType == STSAFEA_SHA_384) ? STSAFEA_LENGTH_CMD_RESP_GENERATE_SIGNATURE_SHA_384 :
 c05a4bc:	2f01      	cmp	r7, #1
 c05a4be:	bf14      	ite	ne
 c05a4c0:	2244      	movne	r2, #68	@ 0x44
 c05a4c2:	2264      	moveq	r2, #100	@ 0x64
        pStSafeA->InOutBuffer.LV.Length = tmp_len + STSAFEA_R_MAC_LENGTH(InMAC); ;
 c05a4c4:	f89d 302c 	ldrb.w	r3, [sp, #44]	@ 0x2c
        StSafeA_Delay(STSAFEA_MS_WAIT_TIME_CMD_GENERATE_SIGNATURE);
 c05a4c8:	2050      	movs	r0, #80	@ 0x50
        pStSafeA->InOutBuffer.LV.Length = tmp_len + STSAFEA_R_MAC_LENGTH(InMAC); ;
 c05a4ca:	091b      	lsrs	r3, r3, #4
 c05a4cc:	f003 0304 	and.w	r3, r3, #4
 c05a4d0:	4413      	add	r3, r2
 c05a4d2:	80a3      	strh	r3, [r4, #4]
        StSafeA_Delay(STSAFEA_MS_WAIT_TIME_CMD_GENERATE_SIGNATURE);
 c05a4d4:	f000 fce4 	bl	c05aea0 <StSafeA_Delay>
        status_code = StSafeA_ReceiveResponse(pStSafeA);
 c05a4d8:	4620      	mov	r0, r4
 c05a4da:	f7ff fcee 	bl	c059eba <StSafeA_ReceiveResponse>
        if (status_code == STSAFEA_OK)
 c05a4de:	2800      	cmp	r0, #0
 c05a4e0:	d1bb      	bne.n	c05a45a <StSafeA_GenerateSignature+0x16>
          if (((uint8_t)InHostEncryption & (uint8_t)STSAFEA_ENCRYPTION_RESPONSE) ==
 c05a4e2:	07f3      	lsls	r3, r6, #31
 c05a4e4:	d415      	bmi.n	c05a512 <StSafeA_GenerateSignature+0xce>
            status_code = StSafeA_AssignLVBuffer(pOutSignR, &pStSafeA->InOutBuffer.LV.Data[0], InSignRSLen);
 c05a4e6:	4628      	mov	r0, r5
 c05a4e8:	f8bd 2020 	ldrh.w	r2, [sp, #32]
 c05a4ec:	68a1      	ldr	r1, [r4, #8]
 c05a4ee:	f7ff fcc4 	bl	c059e7a <StSafeA_AssignLVBuffer>
            if (status_code == STSAFEA_OK)
 c05a4f2:	2800      	cmp	r0, #0
 c05a4f4:	d1b1      	bne.n	c05a45a <StSafeA_GenerateSignature+0x16>
                              &pStSafeA->InOutBuffer.LV.Data[STSAFEA_LENGTH_SIZE + pOutSignR->Length],
 c05a4f6:	882b      	ldrh	r3, [r5, #0]
              status_code = StSafeA_AssignLVBuffer(
 c05a4f8:	68a1      	ldr	r1, [r4, #8]
                              &pStSafeA->InOutBuffer.LV.Data[STSAFEA_LENGTH_SIZE + pOutSignR->Length],
 c05a4fa:	3302      	adds	r3, #2
              status_code = StSafeA_AssignLVBuffer(
 c05a4fc:	980a      	ldr	r0, [sp, #40]	@ 0x28
 c05a4fe:	4419      	add	r1, r3
 c05a500:	f7ff fcbb 	bl	c059e7a <StSafeA_AssignLVBuffer>
 c05a504:	e7a9      	b.n	c05a45a <StSafeA_GenerateSignature+0x16>
      status_code = StSafeA_DataEncryption(pStSafeA);
 c05a506:	4620      	mov	r0, r4
 c05a508:	f000 fb5c 	bl	c05abc4 <StSafeA_DataEncryption>
    if (status_code == STSAFEA_OK)
 c05a50c:	2800      	cmp	r0, #0
 c05a50e:	d0d0      	beq.n	c05a4b2 <StSafeA_GenerateSignature+0x6e>
 c05a510:	e7a3      	b.n	c05a45a <StSafeA_GenerateSignature+0x16>
            status_code = StSafeA_DataDecryption(pStSafeA);
 c05a512:	4620      	mov	r0, r4
 c05a514:	f000 fb91 	bl	c05ac3a <StSafeA_DataDecryption>
          if (status_code == STSAFEA_OK)
 c05a518:	2800      	cmp	r0, #0
 c05a51a:	d19e      	bne.n	c05a45a <StSafeA_GenerateSignature+0x16>
 c05a51c:	e7e3      	b.n	c05a4e6 <StSafeA_GenerateSignature+0xa2>

0c05a51e <StSafeA_ProductDataQuery>:
{
 c05a51e:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 c05a522:	460c      	mov	r4, r1
  if (IS_STSAFEA_HANDLER_VALID_PTR(pStSafeA)  &&
 c05a524:	4606      	mov	r6, r0
{
 c05a526:	f88d 2007 	strb.w	r2, [sp, #7]
  if (IS_STSAFEA_HANDLER_VALID_PTR(pStSafeA)  &&
 c05a52a:	2800      	cmp	r0, #0
 c05a52c:	f000 8140 	beq.w	c05a7b0 <StSafeA_ProductDataQuery+0x292>
 c05a530:	6883      	ldr	r3, [r0, #8]
 c05a532:	2b00      	cmp	r3, #0
 c05a534:	f000 813c 	beq.w	c05a7b0 <StSafeA_ProductDataQuery+0x292>
 c05a538:	2900      	cmp	r1, #0
 c05a53a:	f000 8139 	beq.w	c05a7b0 <StSafeA_ProductDataQuery+0x292>
    StSafeA_BuildCommandHeaderCMAC(pStSafeA, STSAFEA_CMD_QUERY, &InMAC);
 c05a53e:	2114      	movs	r1, #20
 c05a540:	f10d 0207 	add.w	r2, sp, #7
 c05a544:	f7ff fd27 	bl	c059f96 <StSafeA_BuildCommandHeaderCMAC>
    pStSafeA->InOutBuffer.LV.Length = 1U;
 c05a548:	2501      	movs	r5, #1
    pStSafeA->InOutBuffer.LV.Data[0] = (uint8_t)STSAFEA_TAG_PRODUCT_DATA;
 c05a54a:	2211      	movs	r2, #17
 c05a54c:	68b3      	ldr	r3, [r6, #8]
    status_code = StSafeA_TransmitCommand(pStSafeA);
 c05a54e:	4630      	mov	r0, r6
    pStSafeA->InOutBuffer.LV.Data[0] = (uint8_t)STSAFEA_TAG_PRODUCT_DATA;
 c05a550:	701a      	strb	r2, [r3, #0]
    pStSafeA->InOutBuffer.LV.Length = 1U;
 c05a552:	80b5      	strh	r5, [r6, #4]
    status_code = StSafeA_TransmitCommand(pStSafeA);
 c05a554:	f7ff fca2 	bl	c059e9c <StSafeA_TransmitCommand>
    if (status_code == STSAFEA_OK)
 c05a558:	4607      	mov	r7, r0
 c05a55a:	2800      	cmp	r0, #0
 c05a55c:	f040 8124 	bne.w	c05a7a8 <StSafeA_ProductDataQuery+0x28a>
      pStSafeA->InOutBuffer.LV.Length = STSAFEA_PRODUCT_DATA_QUERY_RESPONSE_LENGTH + STSAFEA_R_MAC_LENGTH(InMAC);
 c05a560:	f89d 3007 	ldrb.w	r3, [sp, #7]
      StSafeA_Delay(STSAFEA_MS_WAIT_TIME_CMD_QUERY);
 c05a564:	4628      	mov	r0, r5
      pStSafeA->InOutBuffer.LV.Length = STSAFEA_PRODUCT_DATA_QUERY_RESPONSE_LENGTH + STSAFEA_R_MAC_LENGTH(InMAC);
 c05a566:	091b      	lsrs	r3, r3, #4
 c05a568:	f003 0304 	and.w	r3, r3, #4
 c05a56c:	3327      	adds	r3, #39	@ 0x27
 c05a56e:	80b3      	strh	r3, [r6, #4]
      StSafeA_Delay(STSAFEA_MS_WAIT_TIME_CMD_QUERY);
 c05a570:	f000 fc96 	bl	c05aea0 <StSafeA_Delay>
      status_code = StSafeA_ReceiveResponse(pStSafeA);
 c05a574:	4630      	mov	r0, r6
 c05a576:	f7ff fca0 	bl	c059eba <StSafeA_ReceiveResponse>
      if (status_code == STSAFEA_OK)
 c05a57a:	4607      	mov	r7, r0
 c05a57c:	2800      	cmp	r0, #0
 c05a57e:	f040 8113 	bne.w	c05a7a8 <StSafeA_ProductDataQuery+0x28a>
        pOutProductData->Length = pStSafeA->InOutBuffer.LV.Length;
 c05a582:	88b3      	ldrh	r3, [r6, #4]
        pOutProductData->MaskIdentificationTag    = pStSafeA->InOutBuffer.LV.Data[i];
 c05a584:	68b1      	ldr	r1, [r6, #8]
        pOutProductData->Length = pStSafeA->InOutBuffer.LV.Length;
 c05a586:	8023      	strh	r3, [r4, #0]
        pOutProductData->MaskIdentificationTag    = pStSafeA->InOutBuffer.LV.Data[i];
 c05a588:	780b      	ldrb	r3, [r1, #0]
        (void)memcpy(pOutProductData->MaskIdentification,
 c05a58a:	1d20      	adds	r0, r4, #4
        pOutProductData->MaskIdentificationTag    = pStSafeA->InOutBuffer.LV.Data[i];
 c05a58c:	70a3      	strb	r3, [r4, #2]
        pOutProductData->MaskIdentificationLength = pStSafeA->InOutBuffer.LV.Data[++i];
 c05a58e:	f891 8001 	ldrb.w	r8, [r1, #1]
        (void)memcpy(pOutProductData->MaskIdentification,
 c05a592:	3102      	adds	r1, #2
 c05a594:	4642      	mov	r2, r8
        pOutProductData->MaskIdentificationLength = pStSafeA->InOutBuffer.LV.Data[++i];
 c05a596:	f884 8003 	strb.w	r8, [r4, #3]
        (void)memcpy(pOutProductData->MaskIdentification,
 c05a59a:	f001 f857 	bl	c05b64c <memcpy>
        pOutProductData->STNumberTag = pStSafeA->InOutBuffer.LV.Data[i];
 c05a59e:	68b1      	ldr	r1, [r6, #8]
        i += pOutProductData->MaskIdentificationLength;
 c05a5a0:	f108 0302 	add.w	r3, r8, #2
        pOutProductData->STNumberTag = pStSafeA->InOutBuffer.LV.Data[i];
 c05a5a4:	b2db      	uxtb	r3, r3
 c05a5a6:	5ccb      	ldrb	r3, [r1, r3]
        (void)memcpy(pOutProductData->STNumber,
 c05a5a8:	f104 0009 	add.w	r0, r4, #9
        pOutProductData->STNumberTag = pStSafeA->InOutBuffer.LV.Data[i];
 c05a5ac:	71e3      	strb	r3, [r4, #7]
        pOutProductData->STNumberLength = pStSafeA->InOutBuffer.LV.Data[++i];
 c05a5ae:	f108 0303 	add.w	r3, r8, #3
 c05a5b2:	b2db      	uxtb	r3, r3
 c05a5b4:	5ccd      	ldrb	r5, [r1, r3]
        (void)memcpy(pOutProductData->STNumber,
 c05a5b6:	f108 0804 	add.w	r8, r8, #4
 c05a5ba:	462a      	mov	r2, r5
 c05a5bc:	fa5f f988 	uxtb.w	r9, r8
 c05a5c0:	fa51 f188 	uxtab	r1, r1, r8
        pOutProductData->STNumberLength = pStSafeA->InOutBuffer.LV.Data[++i];
 c05a5c4:	7225      	strb	r5, [r4, #8]
        (void)memcpy(pOutProductData->STNumber,
 c05a5c6:	f001 f841 	bl	c05b64c <memcpy>
        i += pOutProductData->STNumberLength;
 c05a5ca:	444d      	add	r5, r9
        pOutProductData->InputOutputBufferSizeTag = pStSafeA->InOutBuffer.LV.Data[i];
 c05a5cc:	68b3      	ldr	r3, [r6, #8]
        i += pOutProductData->STNumberLength;
 c05a5ce:	b2ed      	uxtb	r5, r5
        pOutProductData->InputOutputBufferSizeTag = pStSafeA->InOutBuffer.LV.Data[i];
 c05a5d0:	5d5a      	ldrb	r2, [r3, r5]
        (void)memcpy(&pOutProductData->InputOutputBufferSize,
 c05a5d2:	1ca9      	adds	r1, r5, #2
        pOutProductData->InputOutputBufferSizeTag = pStSafeA->InOutBuffer.LV.Data[i];
 c05a5d4:	74a2      	strb	r2, [r4, #18]
        pOutProductData->InputOutputBufferSizeLength = pStSafeA->InOutBuffer.LV.Data[++i];
 c05a5d6:	1c6a      	adds	r2, r5, #1
 c05a5d8:	b2d2      	uxtb	r2, r2
 c05a5da:	5c9a      	ldrb	r2, [r3, r2]
        (void)memcpy(&pOutProductData->InputOutputBufferSize,
 c05a5dc:	fa53 f181 	uxtab	r1, r3, r1
        pOutProductData->InputOutputBufferSizeLength = pStSafeA->InOutBuffer.LV.Data[++i];
 c05a5e0:	74e2      	strb	r2, [r4, #19]
        (void)memcpy(&pOutProductData->InputOutputBufferSize,
 c05a5e2:	f104 0014 	add.w	r0, r4, #20
 c05a5e6:	f001 f831 	bl	c05b64c <memcpy>
        pOutProductData->InputOutputBufferSize = (uint16_t)SWAP2BYTES(pOutProductData->InputOutputBufferSize);
 c05a5ea:	8aa3      	ldrh	r3, [r4, #20]
        i += 2U;
 c05a5ec:	1d2a      	adds	r2, r5, #4
        pOutProductData->InputOutputBufferSize = (uint16_t)SWAP2BYTES(pOutProductData->InputOutputBufferSize);
 c05a5ee:	ba5b      	rev16	r3, r3
 c05a5f0:	82a3      	strh	r3, [r4, #20]
        pOutProductData->AtomicityBufferSizeTag = pStSafeA->InOutBuffer.LV.Data[i];
 c05a5f2:	68b3      	ldr	r3, [r6, #8]
 c05a5f4:	b2d2      	uxtb	r2, r2
 c05a5f6:	5c9a      	ldrb	r2, [r3, r2]
        (void)memcpy(&pOutProductData->AtomicityBufferSize,
 c05a5f8:	1da9      	adds	r1, r5, #6
        pOutProductData->AtomicityBufferSizeTag = pStSafeA->InOutBuffer.LV.Data[i];
 c05a5fa:	75a2      	strb	r2, [r4, #22]
        pOutProductData->AtomicityBufferSizeLength = pStSafeA->InOutBuffer.LV.Data[++i];
 c05a5fc:	1d6a      	adds	r2, r5, #5
 c05a5fe:	b2d2      	uxtb	r2, r2
 c05a600:	5c9a      	ldrb	r2, [r3, r2]
        (void)memcpy(&pOutProductData->AtomicityBufferSize,
 c05a602:	fa53 f181 	uxtab	r1, r3, r1
        pOutProductData->AtomicityBufferSizeLength = pStSafeA->InOutBuffer.LV.Data[++i];
 c05a606:	75e2      	strb	r2, [r4, #23]
        (void)memcpy(&pOutProductData->AtomicityBufferSize,
 c05a608:	f104 0018 	add.w	r0, r4, #24
 c05a60c:	f001 f81e 	bl	c05b64c <memcpy>
        pOutProductData->AtomicityBufferSize = (uint16_t)SWAP2BYTES(pOutProductData->AtomicityBufferSize);
 c05a610:	8b23      	ldrh	r3, [r4, #24]
        i += 2U;
 c05a612:	f105 0208 	add.w	r2, r5, #8
        pOutProductData->AtomicityBufferSize = (uint16_t)SWAP2BYTES(pOutProductData->AtomicityBufferSize);
 c05a616:	ba5b      	rev16	r3, r3
 c05a618:	8323      	strh	r3, [r4, #24]
        pOutProductData->NonVolatileMemorySizeTag = pStSafeA->InOutBuffer.LV.Data[i];
 c05a61a:	68b3      	ldr	r3, [r6, #8]
 c05a61c:	b2d2      	uxtb	r2, r2
 c05a61e:	5c9a      	ldrb	r2, [r3, r2]
        (void)memcpy(&pOutProductData->NonVolatileMemorySize,
 c05a620:	f105 010a 	add.w	r1, r5, #10
        pOutProductData->NonVolatileMemorySizeTag = pStSafeA->InOutBuffer.LV.Data[i];
 c05a624:	76a2      	strb	r2, [r4, #26]
        pOutProductData->NonVolatileMemorySizeLength = pStSafeA->InOutBuffer.LV.Data[++i];
 c05a626:	f105 0209 	add.w	r2, r5, #9
 c05a62a:	b2d2      	uxtb	r2, r2
 c05a62c:	5c9a      	ldrb	r2, [r3, r2]
        (void)memcpy(&pOutProductData->NonVolatileMemorySize,
 c05a62e:	fa53 f181 	uxtab	r1, r3, r1
        pOutProductData->NonVolatileMemorySizeLength = pStSafeA->InOutBuffer.LV.Data[++i];
 c05a632:	76e2      	strb	r2, [r4, #27]
        (void)memcpy(&pOutProductData->NonVolatileMemorySize,
 c05a634:	f104 001c 	add.w	r0, r4, #28
 c05a638:	f001 f808 	bl	c05b64c <memcpy>
        pOutProductData->NonVolatileMemorySize = (uint16_t)SWAP2BYTES(pOutProductData->NonVolatileMemorySize);
 c05a63c:	8ba3      	ldrh	r3, [r4, #28]
        i += 2U;
 c05a63e:	f105 020c 	add.w	r2, r5, #12
        pOutProductData->NonVolatileMemorySize = (uint16_t)SWAP2BYTES(pOutProductData->NonVolatileMemorySize);
 c05a642:	ba5b      	rev16	r3, r3
 c05a644:	83a3      	strh	r3, [r4, #28]
        pOutProductData->TestDateTag = pStSafeA->InOutBuffer.LV.Data[i];
 c05a646:	68b3      	ldr	r3, [r6, #8]
 c05a648:	b2d2      	uxtb	r2, r2
 c05a64a:	5c9a      	ldrb	r2, [r3, r2]
        (void)memcpy(&pOutProductData->TestDateSize,
 c05a64c:	f105 010e 	add.w	r1, r5, #14
        pOutProductData->TestDateTag = pStSafeA->InOutBuffer.LV.Data[i];
 c05a650:	77a2      	strb	r2, [r4, #30]
        pOutProductData->TestDateLength = pStSafeA->InOutBuffer.LV.Data[++i];
 c05a652:	f105 020d 	add.w	r2, r5, #13
 c05a656:	b2d2      	uxtb	r2, r2
 c05a658:	5c9a      	ldrb	r2, [r3, r2]
        (void)memcpy(&pOutProductData->TestDateSize,
 c05a65a:	fa53 f181 	uxtab	r1, r3, r1
        pOutProductData->TestDateLength = pStSafeA->InOutBuffer.LV.Data[++i];
 c05a65e:	77e2      	strb	r2, [r4, #31]
        (void)memcpy(&pOutProductData->TestDateSize,
 c05a660:	f104 0020 	add.w	r0, r4, #32
 c05a664:	f000 fff2 	bl	c05b64c <memcpy>
        pOutProductData->TestDateSize = (uint16_t)SWAP2BYTES(pOutProductData->TestDateSize);
 c05a668:	8c23      	ldrh	r3, [r4, #32]
        i += 2U;
 c05a66a:	f105 0210 	add.w	r2, r5, #16
        pOutProductData->TestDateSize = (uint16_t)SWAP2BYTES(pOutProductData->TestDateSize);
 c05a66e:	ba5b      	rev16	r3, r3
 c05a670:	8423      	strh	r3, [r4, #32]
        pOutProductData->InternalProductVersionTag = pStSafeA->InOutBuffer.LV.Data[i];
 c05a672:	68b3      	ldr	r3, [r6, #8]
 c05a674:	b2d2      	uxtb	r2, r2
 c05a676:	5c9a      	ldrb	r2, [r3, r2]
        (void)memcpy(&pOutProductData->ModuleDateSize,
 c05a678:	f105 0115 	add.w	r1, r5, #21
        pOutProductData->InternalProductVersionTag = pStSafeA->InOutBuffer.LV.Data[i];
 c05a67c:	f884 2022 	strb.w	r2, [r4, #34]	@ 0x22
        pOutProductData->InternalProductVersionLength = pStSafeA->InOutBuffer.LV.Data[++i];
 c05a680:	f105 0211 	add.w	r2, r5, #17
 c05a684:	b2d2      	uxtb	r2, r2
 c05a686:	5c9a      	ldrb	r2, [r3, r2]
        (void)memcpy(&pOutProductData->ModuleDateSize,
 c05a688:	fa53 f181 	uxtab	r1, r3, r1
        pOutProductData->InternalProductVersionLength = pStSafeA->InOutBuffer.LV.Data[++i];
 c05a68c:	f884 2023 	strb.w	r2, [r4, #35]	@ 0x23
        pOutProductData->InternalProductVersionSize = pStSafeA->InOutBuffer.LV.Data[++i];
 c05a690:	f105 0212 	add.w	r2, r5, #18
 c05a694:	b2d2      	uxtb	r2, r2
 c05a696:	5c9a      	ldrb	r2, [r3, r2]
        (void)memcpy(&pOutProductData->ModuleDateSize,
 c05a698:	f104 0028 	add.w	r0, r4, #40	@ 0x28
        pOutProductData->InternalProductVersionSize = pStSafeA->InOutBuffer.LV.Data[++i];
 c05a69c:	f884 2024 	strb.w	r2, [r4, #36]	@ 0x24
        pOutProductData->ModuleDateTag = pStSafeA->InOutBuffer.LV.Data[++i];
 c05a6a0:	f105 0213 	add.w	r2, r5, #19
 c05a6a4:	b2d2      	uxtb	r2, r2
 c05a6a6:	5c9a      	ldrb	r2, [r3, r2]
 c05a6a8:	f884 2025 	strb.w	r2, [r4, #37]	@ 0x25
        pOutProductData->ModuleDateLength = pStSafeA->InOutBuffer.LV.Data[++i];
 c05a6ac:	f105 0214 	add.w	r2, r5, #20
 c05a6b0:	b2d2      	uxtb	r2, r2
 c05a6b2:	5c9a      	ldrb	r2, [r3, r2]
 c05a6b4:	f884 2026 	strb.w	r2, [r4, #38]	@ 0x26
        (void)memcpy(&pOutProductData->ModuleDateSize,
 c05a6b8:	f000 ffc8 	bl	c05b64c <memcpy>
        pOutProductData->ModuleDateSize = (uint16_t)SWAP2BYTES(pOutProductData->ModuleDateSize);
 c05a6bc:	8d23      	ldrh	r3, [r4, #40]	@ 0x28
        pOutProductData->FirmwareDeliveryTraceabilityTag = pStSafeA->InOutBuffer.LV.Data[i];
 c05a6be:	68b1      	ldr	r1, [r6, #8]
        pOutProductData->ModuleDateSize = (uint16_t)SWAP2BYTES(pOutProductData->ModuleDateSize);
 c05a6c0:	ba5b      	rev16	r3, r3
 c05a6c2:	8523      	strh	r3, [r4, #40]	@ 0x28
        i += 2U;
 c05a6c4:	f105 0317 	add.w	r3, r5, #23
        pOutProductData->FirmwareDeliveryTraceabilityTag = pStSafeA->InOutBuffer.LV.Data[i];
 c05a6c8:	b2db      	uxtb	r3, r3
 c05a6ca:	5ccb      	ldrb	r3, [r1, r3]
        (void)memcpy(pOutProductData->FirmwareDeliveryTraceability,
 c05a6cc:	f104 002c 	add.w	r0, r4, #44	@ 0x2c
        pOutProductData->FirmwareDeliveryTraceabilityTag = pStSafeA->InOutBuffer.LV.Data[i];
 c05a6d0:	f884 302a 	strb.w	r3, [r4, #42]	@ 0x2a
        pOutProductData->FirmwareDeliveryTraceabilityLength = pStSafeA->InOutBuffer.LV.Data[++i];
 c05a6d4:	f105 0318 	add.w	r3, r5, #24
 c05a6d8:	b2db      	uxtb	r3, r3
 c05a6da:	f811 8003 	ldrb.w	r8, [r1, r3]
        (void)memcpy(pOutProductData->FirmwareDeliveryTraceability,
 c05a6de:	3519      	adds	r5, #25
 c05a6e0:	4642      	mov	r2, r8
 c05a6e2:	fa5f f985 	uxtb.w	r9, r5
 c05a6e6:	fa51 f185 	uxtab	r1, r1, r5
        pOutProductData->FirmwareDeliveryTraceabilityLength = pStSafeA->InOutBuffer.LV.Data[++i];
 c05a6ea:	f884 802b 	strb.w	r8, [r4, #43]	@ 0x2b
        (void)memcpy(pOutProductData->FirmwareDeliveryTraceability,
 c05a6ee:	f000 ffad 	bl	c05b64c <memcpy>
        i += pOutProductData->FirmwareDeliveryTraceabilityLength;
 c05a6f2:	44c8      	add	r8, r9
        pOutProductData->BlackboxDeliveryTraceabilityTag = pStSafeA->InOutBuffer.LV.Data[i];
 c05a6f4:	68b1      	ldr	r1, [r6, #8]
        i += pOutProductData->FirmwareDeliveryTraceabilityLength;
 c05a6f6:	fa5f f888 	uxtb.w	r8, r8
        pOutProductData->BlackboxDeliveryTraceabilityTag = pStSafeA->InOutBuffer.LV.Data[i];
 c05a6fa:	f811 3008 	ldrb.w	r3, [r1, r8]
        (void)memcpy(pOutProductData->BlackboxDeliveryTraceability,
 c05a6fe:	f104 0031 	add.w	r0, r4, #49	@ 0x31
        pOutProductData->BlackboxDeliveryTraceabilityTag = pStSafeA->InOutBuffer.LV.Data[i];
 c05a702:	f884 302f 	strb.w	r3, [r4, #47]	@ 0x2f
        pOutProductData->BlackboxDeliveryTraceabilityLength = pStSafeA->InOutBuffer.LV.Data[++i];
 c05a706:	f108 0301 	add.w	r3, r8, #1
 c05a70a:	b2db      	uxtb	r3, r3
 c05a70c:	5ccd      	ldrb	r5, [r1, r3]
        (void)memcpy(pOutProductData->BlackboxDeliveryTraceability,
 c05a70e:	f108 0802 	add.w	r8, r8, #2
 c05a712:	462a      	mov	r2, r5
 c05a714:	fa5f f988 	uxtb.w	r9, r8
 c05a718:	fa51 f188 	uxtab	r1, r1, r8
        pOutProductData->BlackboxDeliveryTraceabilityLength = pStSafeA->InOutBuffer.LV.Data[++i];
 c05a71c:	f884 5030 	strb.w	r5, [r4, #48]	@ 0x30
        (void)memcpy(pOutProductData->BlackboxDeliveryTraceability,
 c05a720:	f000 ff94 	bl	c05b64c <memcpy>
        pOutProductData->PersoIdTag = pStSafeA->InOutBuffer.LV.Data[i];
 c05a724:	68b3      	ldr	r3, [r6, #8]
        i += pOutProductData->BlackboxDeliveryTraceabilityLength;
 c05a726:	eb05 0209 	add.w	r2, r5, r9
 c05a72a:	b2d2      	uxtb	r2, r2
        pOutProductData->PersoIdTag = pStSafeA->InOutBuffer.LV.Data[i];
 c05a72c:	5c99      	ldrb	r1, [r3, r2]
        (void)memcpy(pOutProductData->PersoId,
 c05a72e:	f104 0036 	add.w	r0, r4, #54	@ 0x36
        pOutProductData->PersoIdTag = pStSafeA->InOutBuffer.LV.Data[i];
 c05a732:	f884 1034 	strb.w	r1, [r4, #52]	@ 0x34
        pOutProductData->PersoIdLength = pStSafeA->InOutBuffer.LV.Data[++i];
 c05a736:	1c51      	adds	r1, r2, #1
 c05a738:	b2c9      	uxtb	r1, r1
 c05a73a:	5c5d      	ldrb	r5, [r3, r1]
        (void)memcpy(pOutProductData->PersoId,
 c05a73c:	1c91      	adds	r1, r2, #2
 c05a73e:	fa5f f881 	uxtb.w	r8, r1
 c05a742:	462a      	mov	r2, r5
 c05a744:	fa53 f181 	uxtab	r1, r3, r1
        pOutProductData->PersoIdLength = pStSafeA->InOutBuffer.LV.Data[++i];
 c05a748:	f884 5035 	strb.w	r5, [r4, #53]	@ 0x35
        (void)memcpy(pOutProductData->PersoId,
 c05a74c:	f000 ff7e 	bl	c05b64c <memcpy>
        i += pOutProductData->PersoIdLength;
 c05a750:	4445      	add	r5, r8
        pOutProductData->PersoGenerationBatchIdTag = pStSafeA->InOutBuffer.LV.Data[i];
 c05a752:	68b1      	ldr	r1, [r6, #8]
        i += pOutProductData->PersoIdLength;
 c05a754:	b2ed      	uxtb	r5, r5
        pOutProductData->PersoGenerationBatchIdTag = pStSafeA->InOutBuffer.LV.Data[i];
 c05a756:	5d4b      	ldrb	r3, [r1, r5]
        (void)memcpy(pOutProductData->PersoGenerationBatchId,
 c05a758:	f104 003b 	add.w	r0, r4, #59	@ 0x3b
        pOutProductData->PersoGenerationBatchIdTag = pStSafeA->InOutBuffer.LV.Data[i];
 c05a75c:	f884 3039 	strb.w	r3, [r4, #57]	@ 0x39
        pOutProductData->PersoGenerationBatchIdLength = pStSafeA->InOutBuffer.LV.Data[++i];
 c05a760:	1c6b      	adds	r3, r5, #1
 c05a762:	b2db      	uxtb	r3, r3
 c05a764:	f811 8003 	ldrb.w	r8, [r1, r3]
        (void)memcpy(pOutProductData->PersoGenerationBatchId,
 c05a768:	3502      	adds	r5, #2
 c05a76a:	4642      	mov	r2, r8
        pOutProductData->PersoGenerationBatchIdLength = pStSafeA->InOutBuffer.LV.Data[++i];
 c05a76c:	f884 803a 	strb.w	r8, [r4, #58]	@ 0x3a
        (void)memcpy(pOutProductData->PersoGenerationBatchId,
 c05a770:	fa51 f185 	uxtab	r1, r1, r5
 c05a774:	fa5f f985 	uxtb.w	r9, r5
 c05a778:	f000 ff68 	bl	c05b64c <memcpy>
        i += pOutProductData->PersoGenerationBatchIdLength;
 c05a77c:	44c8      	add	r8, r9
        pOutProductData->PersoDateTag = pStSafeA->InOutBuffer.LV.Data[i];
 c05a77e:	68b1      	ldr	r1, [r6, #8]
        i += pOutProductData->PersoGenerationBatchIdLength;
 c05a780:	fa5f f888 	uxtb.w	r8, r8
        pOutProductData->PersoDateTag = pStSafeA->InOutBuffer.LV.Data[i];
 c05a784:	f811 3008 	ldrb.w	r3, [r1, r8]
        (void)memcpy(pOutProductData->PersoDate,
 c05a788:	f104 0040 	add.w	r0, r4, #64	@ 0x40
        pOutProductData->PersoDateTag = pStSafeA->InOutBuffer.LV.Data[i];
 c05a78c:	f884 303e 	strb.w	r3, [r4, #62]	@ 0x3e
        pOutProductData->PersoDateLength = pStSafeA->InOutBuffer.LV.Data[++i];
 c05a790:	f108 0301 	add.w	r3, r8, #1
 c05a794:	b2db      	uxtb	r3, r3
 c05a796:	5cca      	ldrb	r2, [r1, r3]
        (void)memcpy(pOutProductData->PersoDate,
 c05a798:	f108 0802 	add.w	r8, r8, #2
        pOutProductData->PersoDateLength = pStSafeA->InOutBuffer.LV.Data[++i];
 c05a79c:	f884 203f 	strb.w	r2, [r4, #63]	@ 0x3f
        (void)memcpy(pOutProductData->PersoDate,
 c05a7a0:	fa51 f188 	uxtab	r1, r1, r8
 c05a7a4:	f000 ff52 	bl	c05b64c <memcpy>
}
 c05a7a8:	4638      	mov	r0, r7
 c05a7aa:	b003      	add	sp, #12
 c05a7ac:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  StSafeA_ResponseCode_t status_code = STSAFEA_INVALID_PARAMETER;
 c05a7b0:	2730      	movs	r7, #48	@ 0x30
 c05a7b2:	e7f9      	b.n	c05a7a8 <StSafeA_ProductDataQuery+0x28a>

0c05a7b4 <StSafeA_RawCommand>:
{
 c05a7b4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 c05a7b8:	4688      	mov	r8, r1
 c05a7ba:	4616      	mov	r6, r2
 c05a7bc:	461d      	mov	r5, r3
  if (IS_STSAFEA_HANDLER_VALID_PTR(pStSafeA)                  &&
 c05a7be:	4604      	mov	r4, r0
 c05a7c0:	b390      	cbz	r0, c05a828 <StSafeA_RawCommand+0x74>
 c05a7c2:	6883      	ldr	r3, [r0, #8]
 c05a7c4:	b383      	cbz	r3, c05a828 <StSafeA_RawCommand+0x74>
 c05a7c6:	b379      	cbz	r1, c05a828 <StSafeA_RawCommand+0x74>
      (pOutTLVResponse != NULL)                               &&
 c05a7c8:	b375      	cbz	r5, c05a828 <StSafeA_RawCommand+0x74>
    StSafeA_BuildCommandHeaderCMAC(pStSafeA, pInRawCommand->Header, &InMAC);
 c05a7ca:	aa07      	add	r2, sp, #28
 c05a7cc:	7809      	ldrb	r1, [r1, #0]
 c05a7ce:	f7ff fbe2 	bl	c059f96 <StSafeA_BuildCommandHeaderCMAC>
    STSAFEA_CHECK_SIZE(InMAC, 0U, pInRawCommand->LV.Length);
 c05a7d2:	f89d 701c 	ldrb.w	r7, [sp, #28]
 c05a7d6:	f8b8 2004 	ldrh.w	r2, [r8, #4]
 c05a7da:	bb17      	cbnz	r7, c05a822 <StSafeA_RawCommand+0x6e>
 c05a7dc:	f5b2 7ffc 	cmp.w	r2, #504	@ 0x1f8
 c05a7e0:	d824      	bhi.n	c05a82c <StSafeA_RawCommand+0x78>
    (void)memcpy(pStSafeA->InOutBuffer.LV.Data, pInRawCommand->LV.Data, pInRawCommand->LV.Length);
 c05a7e2:	f8d8 1008 	ldr.w	r1, [r8, #8]
 c05a7e6:	68a0      	ldr	r0, [r4, #8]
    pStSafeA->InOutBuffer.LV.Length = pInRawCommand->LV.Length;
 c05a7e8:	80a2      	strh	r2, [r4, #4]
    (void)memcpy(pStSafeA->InOutBuffer.LV.Data, pInRawCommand->LV.Data, pInRawCommand->LV.Length);
 c05a7ea:	f000 ff2f 	bl	c05b64c <memcpy>
    status_code = StSafeA_TransmitCommand(pStSafeA);
 c05a7ee:	4620      	mov	r0, r4
 c05a7f0:	f7ff fb54 	bl	c059e9c <StSafeA_TransmitCommand>
    if (status_code == STSAFEA_OK)
 c05a7f4:	b998      	cbnz	r0, c05a81e <StSafeA_RawCommand+0x6a>
      pStSafeA->InOutBuffer.LV.Length = STSAFEA_R_MAC_LENGTH(InMAC);
 c05a7f6:	093f      	lsrs	r7, r7, #4
 c05a7f8:	f007 0704 	and.w	r7, r7, #4
      StSafeA_Delay(DelayMs);
 c05a7fc:	9806      	ldr	r0, [sp, #24]
      pStSafeA->InOutBuffer.LV.Length = STSAFEA_R_MAC_LENGTH(InMAC);
 c05a7fe:	80a7      	strh	r7, [r4, #4]
      StSafeA_Delay(DelayMs);
 c05a800:	f000 fb4e 	bl	c05aea0 <StSafeA_Delay>
      status_code = StSafeA_ReceiveResponse(pStSafeA);
 c05a804:	4620      	mov	r0, r4
 c05a806:	f7ff fb58 	bl	c059eba <StSafeA_ReceiveResponse>
      if (status_code == STSAFEA_OK)
 c05a80a:	b940      	cbnz	r0, c05a81e <StSafeA_RawCommand+0x6a>
        pOutTLVResponse->Header = pStSafeA->InOutBuffer.Header;
 c05a80c:	4621      	mov	r1, r4
 c05a80e:	4628      	mov	r0, r5
 c05a810:	f811 3b04 	ldrb.w	r3, [r1], #4
        status_code = StSafeA_AssignLVResponse(&pOutTLVResponse->LV, &pStSafeA->InOutBuffer.LV,  InRespDataLen);
 c05a814:	4632      	mov	r2, r6
        pOutTLVResponse->Header = pStSafeA->InOutBuffer.Header;
 c05a816:	f800 3b04 	strb.w	r3, [r0], #4
        status_code = StSafeA_AssignLVResponse(&pOutTLVResponse->LV, &pStSafeA->InOutBuffer.LV,  InRespDataLen);
 c05a81a:	f7ff fb21 	bl	c059e60 <StSafeA_AssignLVResponse>
}
 c05a81e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    STSAFEA_CHECK_SIZE(InMAC, 0U, pInRawCommand->LV.Length);
 c05a822:	f5b2 7ffa 	cmp.w	r2, #500	@ 0x1f4
 c05a826:	e7db      	b.n	c05a7e0 <StSafeA_RawCommand+0x2c>
  StSafeA_ResponseCode_t status_code = STSAFEA_INVALID_PARAMETER;
 c05a828:	2030      	movs	r0, #48	@ 0x30
 c05a82a:	e7f8      	b.n	c05a81e <StSafeA_RawCommand+0x6a>
    STSAFEA_CHECK_SIZE(InMAC, 0U, pInRawCommand->LV.Length);
 c05a82c:	2006      	movs	r0, #6
 c05a82e:	e7f6      	b.n	c05a81e <StSafeA_RawCommand+0x6a>

0c05a830 <StSafeA_WrapLocalEnvelope>:
{
 c05a830:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 c05a832:	460f      	mov	r7, r1
 c05a834:	4616      	mov	r6, r2
 c05a836:	461d      	mov	r5, r3
  if (IS_STSAFEA_HANDLER_VALID_PTR(pStSafeA))
 c05a838:	4604      	mov	r4, r0
 c05a83a:	2800      	cmp	r0, #0
 c05a83c:	d040      	beq.n	c05a8c0 <StSafeA_WrapLocalEnvelope+0x90>
 c05a83e:	6883      	ldr	r3, [r0, #8]
 c05a840:	2b00      	cmp	r3, #0
 c05a842:	d03d      	beq.n	c05a8c0 <StSafeA_WrapLocalEnvelope+0x90>
    StSafeA_BuildCommandHeaderCMAC(pStSafeA, STSAFEA_CMD_WRAP_LOCAL_ENVELOPE, &InMAC);
 c05a844:	210e      	movs	r1, #14
 c05a846:	aa07      	add	r2, sp, #28
 c05a848:	f7ff fba5 	bl	c059f96 <StSafeA_BuildCommandHeaderCMAC>
    pStSafeA->InOutBuffer.LV.Data[0] = (uint8_t)InKeySlotNum;
 c05a84c:	68a3      	ldr	r3, [r4, #8]
 c05a84e:	701f      	strb	r7, [r3, #0]
    if ((pInData != NULL) && (InDataSize > 0U))
 c05a850:	1c6f      	adds	r7, r5, #1
 c05a852:	b166      	cbz	r6, c05a86e <StSafeA_WrapLocalEnvelope+0x3e>
 c05a854:	b15d      	cbz	r5, c05a86e <StSafeA_WrapLocalEnvelope+0x3e>
      STSAFEA_CHECK_SIZE(InMAC, 1U, InDataSize);
 c05a856:	f89d 301c 	ldrb.w	r3, [sp, #28]
 c05a85a:	bb43      	cbnz	r3, c05a8ae <StSafeA_WrapLocalEnvelope+0x7e>
 c05a85c:	f5b7 7ffc 	cmp.w	r7, #504	@ 0x1f8
 c05a860:	d830      	bhi.n	c05a8c4 <StSafeA_WrapLocalEnvelope+0x94>
      (void)memcpy(&pStSafeA->InOutBuffer.LV.Data[1], pInData, InDataSize);
 c05a862:	68a0      	ldr	r0, [r4, #8]
 c05a864:	462a      	mov	r2, r5
 c05a866:	4631      	mov	r1, r6
 c05a868:	3001      	adds	r0, #1
 c05a86a:	f000 feef 	bl	c05b64c <memcpy>
    if (((uint8_t)InHostEncryption & (uint8_t)STSAFEA_ENCRYPTION_COMMAND) == (uint8_t)STSAFEA_ENCRYPTION_COMMAND)
 c05a86e:	f89d 3020 	ldrb.w	r3, [sp, #32]
    pStSafeA->InOutBuffer.LV.Length = InDataSize + 1U;
 c05a872:	80a7      	strh	r7, [r4, #4]
    if (((uint8_t)InHostEncryption & (uint8_t)STSAFEA_ENCRYPTION_COMMAND) == (uint8_t)STSAFEA_ENCRYPTION_COMMAND)
 c05a874:	079b      	lsls	r3, r3, #30
 c05a876:	d41d      	bmi.n	c05a8b4 <StSafeA_WrapLocalEnvelope+0x84>
      status_code = StSafeA_TransmitCommand(pStSafeA);
 c05a878:	4620      	mov	r0, r4
 c05a87a:	f7ff fb0f 	bl	c059e9c <StSafeA_TransmitCommand>
      if (status_code == STSAFEA_OK)
 c05a87e:	b9f0      	cbnz	r0, c05a8be <StSafeA_WrapLocalEnvelope+0x8e>
                                          STSAFEA_R_MAC_LENGTH(InMAC);
 c05a880:	f89d 301c 	ldrb.w	r3, [sp, #28]
        StSafeA_Delay(STSAFEA_MS_WAIT_TIME_CMD_WRAP_LOCAL_ENVELOPE);
 c05a884:	207d      	movs	r0, #125	@ 0x7d
                                          STSAFEA_R_MAC_LENGTH(InMAC);
 c05a886:	091b      	lsrs	r3, r3, #4
 c05a888:	f003 0304 	and.w	r3, r3, #4
                                          STSAFEA_WRAP_UNWRAP_ENVELOPE_ADDITIONAL_RESPONSE_LENGTH +
 c05a88c:	442b      	add	r3, r5
 c05a88e:	3308      	adds	r3, #8
        pStSafeA->InOutBuffer.LV.Length = InDataSize +
 c05a890:	80a3      	strh	r3, [r4, #4]
        StSafeA_Delay(STSAFEA_MS_WAIT_TIME_CMD_WRAP_LOCAL_ENVELOPE);
 c05a892:	f000 fb05 	bl	c05aea0 <StSafeA_Delay>
        status_code = StSafeA_ReceiveResponse(pStSafeA);
 c05a896:	4620      	mov	r0, r4
 c05a898:	f7ff fb0f 	bl	c059eba <StSafeA_ReceiveResponse>
        if (status_code == STSAFEA_OK)
 c05a89c:	b978      	cbnz	r0, c05a8be <StSafeA_WrapLocalEnvelope+0x8e>
          status_code = StSafeA_AssignLVResponse(pOutLVResponse, &pStSafeA->InOutBuffer.LV, InDataSize + 8U);
 c05a89e:	f105 0208 	add.w	r2, r5, #8
 c05a8a2:	9806      	ldr	r0, [sp, #24]
 c05a8a4:	b292      	uxth	r2, r2
 c05a8a6:	1d21      	adds	r1, r4, #4
 c05a8a8:	f7ff fada 	bl	c059e60 <StSafeA_AssignLVResponse>
 c05a8ac:	e007      	b.n	c05a8be <StSafeA_WrapLocalEnvelope+0x8e>
      STSAFEA_CHECK_SIZE(InMAC, 1U, InDataSize);
 c05a8ae:	f5b7 7ffa 	cmp.w	r7, #500	@ 0x1f4
 c05a8b2:	e7d5      	b.n	c05a860 <StSafeA_WrapLocalEnvelope+0x30>
      status_code = StSafeA_DataEncryption(pStSafeA);
 c05a8b4:	4620      	mov	r0, r4
 c05a8b6:	f000 f985 	bl	c05abc4 <StSafeA_DataEncryption>
    if (status_code == STSAFEA_OK)
 c05a8ba:	2800      	cmp	r0, #0
 c05a8bc:	d0dc      	beq.n	c05a878 <StSafeA_WrapLocalEnvelope+0x48>
}
 c05a8be:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  StSafeA_ResponseCode_t status_code = STSAFEA_INVALID_PARAMETER;
 c05a8c0:	2030      	movs	r0, #48	@ 0x30
 c05a8c2:	e7fc      	b.n	c05a8be <StSafeA_WrapLocalEnvelope+0x8e>
      STSAFEA_CHECK_SIZE(InMAC, 1U, InDataSize);
 c05a8c4:	2006      	movs	r0, #6
 c05a8c6:	e7fa      	b.n	c05a8be <StSafeA_WrapLocalEnvelope+0x8e>

0c05a8c8 <StSafeA_UnwrapLocalEnvelope>:
{
 c05a8c8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 c05a8ca:	460f      	mov	r7, r1
 c05a8cc:	4616      	mov	r6, r2
 c05a8ce:	461d      	mov	r5, r3
  if (IS_STSAFEA_HANDLER_VALID_PTR(pStSafeA))
 c05a8d0:	4604      	mov	r4, r0
 c05a8d2:	2800      	cmp	r0, #0
 c05a8d4:	d03e      	beq.n	c05a954 <StSafeA_UnwrapLocalEnvelope+0x8c>
 c05a8d6:	6883      	ldr	r3, [r0, #8]
 c05a8d8:	2b00      	cmp	r3, #0
 c05a8da:	d03b      	beq.n	c05a954 <StSafeA_UnwrapLocalEnvelope+0x8c>
    StSafeA_BuildCommandHeaderCMAC(pStSafeA, STSAFEA_CMD_UNWRAP_LOCAL_ENVELOPE, &InMAC);
 c05a8dc:	210f      	movs	r1, #15
 c05a8de:	aa07      	add	r2, sp, #28
 c05a8e0:	f7ff fb59 	bl	c059f96 <StSafeA_BuildCommandHeaderCMAC>
    pStSafeA->InOutBuffer.LV.Data[0] = (uint8_t)InKeySlotNum;
 c05a8e4:	68a3      	ldr	r3, [r4, #8]
 c05a8e6:	701f      	strb	r7, [r3, #0]
    if ((pInLocalEnvelope != NULL) && (InLocalEnvelopeSize > 0U))
 c05a8e8:	1c6f      	adds	r7, r5, #1
 c05a8ea:	b166      	cbz	r6, c05a906 <StSafeA_UnwrapLocalEnvelope+0x3e>
 c05a8ec:	b15d      	cbz	r5, c05a906 <StSafeA_UnwrapLocalEnvelope+0x3e>
      STSAFEA_CHECK_SIZE(InMAC, 1U, InLocalEnvelopeSize);
 c05a8ee:	f89d 301c 	ldrb.w	r3, [sp, #28]
 c05a8f2:	bb33      	cbnz	r3, c05a942 <StSafeA_UnwrapLocalEnvelope+0x7a>
 c05a8f4:	f5b7 7ffc 	cmp.w	r7, #504	@ 0x1f8
 c05a8f8:	d82e      	bhi.n	c05a958 <StSafeA_UnwrapLocalEnvelope+0x90>
      (void)memcpy(&pStSafeA->InOutBuffer.LV.Data[1], pInLocalEnvelope, InLocalEnvelopeSize);
 c05a8fa:	68a0      	ldr	r0, [r4, #8]
 c05a8fc:	462a      	mov	r2, r5
 c05a8fe:	4631      	mov	r1, r6
 c05a900:	3001      	adds	r0, #1
 c05a902:	f000 fea3 	bl	c05b64c <memcpy>
    status_code = StSafeA_TransmitCommand(pStSafeA);
 c05a906:	4620      	mov	r0, r4
    pStSafeA->InOutBuffer.LV.Length = InLocalEnvelopeSize + 1U;
 c05a908:	80a7      	strh	r7, [r4, #4]
    status_code = StSafeA_TransmitCommand(pStSafeA);
 c05a90a:	f7ff fac7 	bl	c059e9c <StSafeA_TransmitCommand>
    if (status_code == STSAFEA_OK)
 c05a90e:	b9b8      	cbnz	r0, c05a940 <StSafeA_UnwrapLocalEnvelope+0x78>
                                        STSAFEA_R_MAC_LENGTH(InMAC);
 c05a910:	f89d 101c 	ldrb.w	r1, [sp, #28]
      StSafeA_Delay(STSAFEA_MS_WAIT_TIME_CMD_UNWRAP_LOCAL_ENVELOPE);
 c05a914:	2096      	movs	r0, #150	@ 0x96
                                        STSAFEA_R_MAC_LENGTH(InMAC);
 c05a916:	0909      	lsrs	r1, r1, #4
 c05a918:	f001 0104 	and.w	r1, r1, #4
                                        STSAFEA_WRAP_UNWRAP_ENVELOPE_ADDITIONAL_RESPONSE_LENGTH +
 c05a91c:	4429      	add	r1, r5
 c05a91e:	3108      	adds	r1, #8
      pStSafeA->InOutBuffer.LV.Length = InLocalEnvelopeSize +
 c05a920:	80a1      	strh	r1, [r4, #4]
      StSafeA_Delay(STSAFEA_MS_WAIT_TIME_CMD_UNWRAP_LOCAL_ENVELOPE);
 c05a922:	f000 fabd 	bl	c05aea0 <StSafeA_Delay>
      status_code = StSafeA_ReceiveResponse(pStSafeA);
 c05a926:	4620      	mov	r0, r4
 c05a928:	f7ff fac7 	bl	c059eba <StSafeA_ReceiveResponse>
      if (status_code == STSAFEA_OK)
 c05a92c:	b940      	cbnz	r0, c05a940 <StSafeA_UnwrapLocalEnvelope+0x78>
        if (((uint8_t)InHostEncryption & (uint8_t)STSAFEA_ENCRYPTION_RESPONSE) == (uint8_t)STSAFEA_ENCRYPTION_RESPONSE)
 c05a92e:	f89d 3020 	ldrb.w	r3, [sp, #32]
 c05a932:	07db      	lsls	r3, r3, #31
 c05a934:	d408      	bmi.n	c05a948 <StSafeA_UnwrapLocalEnvelope+0x80>
        status_code = StSafeA_AssignLVResponse(pOutLVResponse, &pStSafeA->InOutBuffer.LV,  InLocalEnvelopeSize);
 c05a936:	462a      	mov	r2, r5
 c05a938:	9806      	ldr	r0, [sp, #24]
 c05a93a:	1d21      	adds	r1, r4, #4
 c05a93c:	f7ff fa90 	bl	c059e60 <StSafeA_AssignLVResponse>
}
 c05a940:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      STSAFEA_CHECK_SIZE(InMAC, 1U, InLocalEnvelopeSize);
 c05a942:	f5b7 7ffa 	cmp.w	r7, #500	@ 0x1f4
 c05a946:	e7d7      	b.n	c05a8f8 <StSafeA_UnwrapLocalEnvelope+0x30>
          status_code = StSafeA_DataDecryption(pStSafeA);
 c05a948:	4620      	mov	r0, r4
 c05a94a:	f000 f976 	bl	c05ac3a <StSafeA_DataDecryption>
      if (status_code == STSAFEA_OK)
 c05a94e:	2800      	cmp	r0, #0
 c05a950:	d1f6      	bne.n	c05a940 <StSafeA_UnwrapLocalEnvelope+0x78>
 c05a952:	e7f0      	b.n	c05a936 <StSafeA_UnwrapLocalEnvelope+0x6e>
  StSafeA_ResponseCode_t status_code = STSAFEA_INVALID_PARAMETER;
 c05a954:	2030      	movs	r0, #48	@ 0x30
 c05a956:	e7f3      	b.n	c05a940 <StSafeA_UnwrapLocalEnvelope+0x78>
      STSAFEA_CHECK_SIZE(InMAC, 1U, InLocalEnvelopeSize);
 c05a958:	2006      	movs	r0, #6
 c05a95a:	e7f1      	b.n	c05a940 <StSafeA_UnwrapLocalEnvelope+0x78>

0c05a95c <StSafeA_Copy_TLVBuffer>:
  * @param   Size : size of data to copy in bytes.
  * @retval  None
  */
static void StSafeA_Copy_TLVBuffer(uint8_t *pDest, StSafeA_TLVBuffer_t *pSrcTLV, uint16_t Size)
{
  if ((pDest != NULL) && (pSrcTLV != NULL)  && (Size > 3U))
 c05a95c:	b180      	cbz	r0, c05a980 <StSafeA_Copy_TLVBuffer+0x24>
 c05a95e:	b179      	cbz	r1, c05a980 <StSafeA_Copy_TLVBuffer+0x24>
 c05a960:	2a03      	cmp	r2, #3
 c05a962:	d90d      	bls.n	c05a980 <StSafeA_Copy_TLVBuffer+0x24>
  {
    pDest[0] = pSrcTLV->Header;
 c05a964:	780b      	ldrb	r3, [r1, #0]
    pDest[1] = (uint8_t)((pSrcTLV->LV.Length >> 8) & 0xFFU);
    pDest[2] = (uint8_t)pSrcTLV->LV.Length & 0xFFU;
    (void)memcpy(&pDest[3], pSrcTLV->LV.Data, (uint32_t)(Size) - 3U);
 c05a966:	3a03      	subs	r2, #3
    pDest[0] = pSrcTLV->Header;
 c05a968:	7003      	strb	r3, [r0, #0]
    pDest[1] = (uint8_t)((pSrcTLV->LV.Length >> 8) & 0xFFU);
 c05a96a:	888b      	ldrh	r3, [r1, #4]
    (void)memcpy(&pDest[3], pSrcTLV->LV.Data, (uint32_t)(Size) - 3U);
 c05a96c:	3003      	adds	r0, #3
    pDest[1] = (uint8_t)((pSrcTLV->LV.Length >> 8) & 0xFFU);
 c05a96e:	0a1b      	lsrs	r3, r3, #8
 c05a970:	f800 3c02 	strb.w	r3, [r0, #-2]
    pDest[2] = (uint8_t)pSrcTLV->LV.Length & 0xFFU;
 c05a974:	888b      	ldrh	r3, [r1, #4]
 c05a976:	f800 3c01 	strb.w	r3, [r0, #-1]
    (void)memcpy(&pDest[3], pSrcTLV->LV.Data, (uint32_t)(Size) - 3U);
 c05a97a:	6889      	ldr	r1, [r1, #8]
 c05a97c:	f000 be66 	b.w	c05b64c <memcpy>
  }
}
 c05a980:	4770      	bx	lr

0c05a982 <ComputeInitialValue.isra.0>:
  if (InSubject != CMAC_COMPUTATION)
 c05a982:	b101      	cbz	r1, c05a986 <ComputeInitialValue.isra.0+0x4>
    host_cmac_sequence_counter++;
 c05a984:	3001      	adds	r0, #1
  pOutInitialValue[0] = (uint8_t)(host_cmac_sequence_counter >> 16) & 0xFFU;
 c05a986:	0c03      	lsrs	r3, r0, #16
 c05a988:	7013      	strb	r3, [r2, #0]
  pOutInitialValue[1] = (uint8_t)(host_cmac_sequence_counter >> 8) & 0xFFU;
 c05a98a:	0a03      	lsrs	r3, r0, #8
 c05a98c:	7053      	strb	r3, [r2, #1]
  pOutInitialValue[4] = 0x80U;
 c05a98e:	2380      	movs	r3, #128	@ 0x80
 c05a990:	7113      	strb	r3, [r2, #4]
  (void)memset(&pOutInitialValue[5], 0x00, (STSAFEA_INITIAL_VALUE_SIZE) - 5U);
 c05a992:	2300      	movs	r3, #0
  pOutInitialValue[3] = (uint8_t)(((uint8_t)InSubject << 6) & 0xC0U);
 c05a994:	0189      	lsls	r1, r1, #6
  (void)memset(&pOutInitialValue[5], 0x00, (STSAFEA_INITIAL_VALUE_SIZE) - 5U);
 c05a996:	f8c2 3009 	str.w	r3, [r2, #9]
  pOutInitialValue[2] = (uint8_t)(host_cmac_sequence_counter & 0xFFU);
 c05a99a:	7090      	strb	r0, [r2, #2]
  pOutInitialValue[3] = (uint8_t)(((uint8_t)InSubject << 6) & 0xC0U);
 c05a99c:	70d1      	strb	r1, [r2, #3]
  (void)memset(&pOutInitialValue[5], 0x00, (STSAFEA_INITIAL_VALUE_SIZE) - 5U);
 c05a99e:	f8c2 3005 	str.w	r3, [r2, #5]
 c05a9a2:	60d3      	str	r3, [r2, #12]
}
 c05a9a4:	4770      	bx	lr
	...

0c05a9a8 <StSafeA_ComputeCMAC>:
{
 c05a9a8:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
  if (IS_STSAFEA_HANDLER_VALID_PTR(pStSafeA))
 c05a9ac:	4604      	mov	r4, r0
 c05a9ae:	2800      	cmp	r0, #0
 c05a9b0:	d06b      	beq.n	c05aa8a <StSafeA_ComputeCMAC+0xe2>
 c05a9b2:	6883      	ldr	r3, [r0, #8]
 c05a9b4:	2b00      	cmp	r3, #0
 c05a9b6:	d068      	beq.n	c05aa8a <StSafeA_ComputeCMAC+0xe2>
    void *p_aes_cmac_ctx = NULL;
 c05a9b8:	2600      	movs	r6, #0
    uint8_t host_mac_computation = pStSafeA->InOutBuffer.Header & (uint8_t)STSAFEA_CMD_HEADER_SCHN_HOSTEN;
 c05a9ba:	f890 9000 	ldrb.w	r9, [r0]
    StSafeA_AES_MAC_Start(&p_aes_cmac_ctx);
 c05a9be:	a801      	add	r0, sp, #4
    uint8_t host_mac_computation = pStSafeA->InOutBuffer.Header & (uint8_t)STSAFEA_CMD_HEADER_SCHN_HOSTEN;
 c05a9c0:	f009 0920 	and.w	r9, r9, #32
    void *p_aes_cmac_ctx = NULL;
 c05a9c4:	9601      	str	r6, [sp, #4]
    StSafeA_AES_MAC_Start(&p_aes_cmac_ctx);
 c05a9c6:	f7f6 f941 	bl	c050c4c <StSafeA_AES_MAC_Start>
    if (host_mac_computation != 0U)
 c05a9ca:	f1b9 0f00 	cmp.w	r9, #0
 c05a9ce:	d15f      	bne.n	c05aa90 <StSafeA_ComputeCMAC+0xe8>
    aRMacBuffer[0] = (host_mac_computation == 0U) ? ((uint8_t)pStSafeA->MacCounter & 0x7FU) : 0x00U;
 c05a9d0:	7b66      	ldrb	r6, [r4, #13]
    length = pStSafeA->InOutBuffer.LV.Length;
 c05a9d2:	88a5      	ldrh	r5, [r4, #4]
    aRMacBuffer[0] = (host_mac_computation == 0U) ? ((uint8_t)pStSafeA->MacCounter & 0x7FU) : 0x00U;
 c05a9d4:	f006 037f 	and.w	r3, r6, #127	@ 0x7f
 c05a9d8:	4e3e      	ldr	r6, [pc, #248]	@ (c05aad4 <StSafeA_ComputeCMAC+0x12c>)
    StSafeA_Copy_TLVBuffer(&aRMacBuffer[1], &pStSafeA->InOutBuffer, STSAFEA_MAC_PACKET_SIZE - 1U);
 c05a9da:	220f      	movs	r2, #15
    aRMacBuffer[0] = (host_mac_computation == 0U) ? ((uint8_t)pStSafeA->MacCounter & 0x7FU) : 0x00U;
 c05a9dc:	4630      	mov	r0, r6
    StSafeA_Copy_TLVBuffer(&aRMacBuffer[1], &pStSafeA->InOutBuffer, STSAFEA_MAC_PACKET_SIZE - 1U);
 c05a9de:	4621      	mov	r1, r4
    aRMacBuffer[0] = (host_mac_computation == 0U) ? ((uint8_t)pStSafeA->MacCounter & 0x7FU) : 0x00U;
 c05a9e0:	f800 3b01 	strb.w	r3, [r0], #1
    StSafeA_Copy_TLVBuffer(&aRMacBuffer[1], &pStSafeA->InOutBuffer, STSAFEA_MAC_PACKET_SIZE - 1U);
 c05a9e4:	f7ff ffba 	bl	c05a95c <StSafeA_Copy_TLVBuffer>
    if (length > (STSAFEA_MAC_PACKET_SIZE - (uint16_t)STSAFEA_KNOWN_INPUT_TO_CMAC_COMPUTATION_SIZE))
 c05a9e8:	2d0c      	cmp	r5, #12
      StSafeA_AES_MAC_Update(aRMacBuffer, STSAFEA_MAC_PACKET_SIZE, p_aes_cmac_ctx);
 c05a9ea:	9a01      	ldr	r2, [sp, #4]
    if (length > (STSAFEA_MAC_PACKET_SIZE - (uint16_t)STSAFEA_KNOWN_INPUT_TO_CMAC_COMPUTATION_SIZE))
 c05a9ec:	d95d      	bls.n	c05aaaa <StSafeA_ComputeCMAC+0x102>
      StSafeA_AES_MAC_Update(aRMacBuffer, STSAFEA_MAC_PACKET_SIZE, p_aes_cmac_ctx);
 c05a9ee:	2110      	movs	r1, #16
 c05a9f0:	4630      	mov	r0, r6
 c05a9f2:	f7f6 f945 	bl	c050c80 <StSafeA_AES_MAC_Update>
      StSafeA_AES_MAC_LastUpdate(&pStSafeA->InOutBuffer.LV.Data[STSAFEA_MAC_PACKET_SIZE -
 c05a9f6:	68a0      	ldr	r0, [r4, #8]
 c05a9f8:	f1a5 010c 	sub.w	r1, r5, #12
 c05a9fc:	9a01      	ldr	r2, [sp, #4]
 c05a9fe:	b289      	uxth	r1, r1
 c05aa00:	300c      	adds	r0, #12
      StSafeA_AES_MAC_LastUpdate(aRMacBuffer, length + (uint16_t)STSAFEA_KNOWN_INPUT_TO_CMAC_COMPUTATION_SIZE,
 c05aa02:	f7f6 f943 	bl	c050c8c <StSafeA_AES_MAC_LastUpdate>
    StSafeA_AES_MAC_Final(&pStSafeA->InOutBuffer.LV.Data[length], &p_aes_cmac_ctx);
 c05aa06:	68a0      	ldr	r0, [r4, #8]
 c05aa08:	a901      	add	r1, sp, #4
 c05aa0a:	4428      	add	r0, r5
 c05aa0c:	f7f6 f944 	bl	c050c98 <StSafeA_AES_MAC_Final>
    if ((pStSafeA->InOutBuffer.Header & (uint8_t)STSAFEA_CMD_HEADER_RMACEN) == (uint8_t)STSAFEA_CMD_HEADER_RMACEN)
 c05aa10:	7823      	ldrb	r3, [r4, #0]
 c05aa12:	065b      	lsls	r3, r3, #25
 c05aa14:	d536      	bpl.n	c05aa84 <StSafeA_ComputeCMAC+0xdc>
      pAesRMacCtx = NULL;
 c05aa16:	2300      	movs	r3, #0
 c05aa18:	f8df 80bc 	ldr.w	r8, [pc, #188]	@ c05aad8 <StSafeA_ComputeCMAC+0x130>
      RMacBufferSize = 0;
 c05aa1c:	4f2f      	ldr	r7, [pc, #188]	@ (c05aadc <StSafeA_ComputeCMAC+0x134>)
      StSafeA_AES_MAC_Start(&pAesRMacCtx);
 c05aa1e:	4640      	mov	r0, r8
      pAesRMacCtx = NULL;
 c05aa20:	f8c8 3000 	str.w	r3, [r8]
      RMacBufferSize = 0;
 c05aa24:	703b      	strb	r3, [r7, #0]
      StSafeA_AES_MAC_Start(&pAesRMacCtx);
 c05aa26:	f7f6 f911 	bl	c050c4c <StSafeA_AES_MAC_Start>
      if (host_mac_computation != 0U)
 c05aa2a:	f1b9 0f00 	cmp.w	r9, #0
 c05aa2e:	d140      	bne.n	c05aab2 <StSafeA_ComputeCMAC+0x10a>
      aRMacBuffer[0] = (host_mac_computation == 0U) ? ((pStSafeA->MacCounter + 1U) | 0x80U) : 0x80U;
 c05aa30:	7b63      	ldrb	r3, [r4, #13]
 c05aa32:	3301      	adds	r3, #1
 c05aa34:	f063 037f 	orn	r3, r3, #127	@ 0x7f
 c05aa38:	b2db      	uxtb	r3, r3
      StSafeA_Copy_TLVBuffer(&aRMacBuffer[1], &pStSafeA->InOutBuffer, STSAFEA_MAC_PACKET_SIZE - 1U);
 c05aa3a:	220f      	movs	r2, #15
 c05aa3c:	4621      	mov	r1, r4
 c05aa3e:	4828      	ldr	r0, [pc, #160]	@ (c05aae0 <StSafeA_ComputeCMAC+0x138>)
      aRMacBuffer[0] = (host_mac_computation == 0U) ? ((pStSafeA->MacCounter + 1U) | 0x80U) : 0x80U;
 c05aa40:	7033      	strb	r3, [r6, #0]
      StSafeA_Copy_TLVBuffer(&aRMacBuffer[1], &pStSafeA->InOutBuffer, STSAFEA_MAC_PACKET_SIZE - 1U);
 c05aa42:	f7ff ff8b 	bl	c05a95c <StSafeA_Copy_TLVBuffer>
      if (length > (STSAFEA_MAC_PACKET_SIZE - STSAFEA_KNOWN_INPUT_TO_CMAC_COMPUTATION_SIZE))
 c05aa46:	2d0c      	cmp	r5, #12
        RMacBufferSize = (uint8_t)((uint32_t)length - STSAFEA_MAC_PACKET_SIZE +
 c05aa48:	b2ee      	uxtb	r6, r5
      if (length > (STSAFEA_MAC_PACKET_SIZE - STSAFEA_KNOWN_INPUT_TO_CMAC_COMPUTATION_SIZE))
 c05aa4a:	d93f      	bls.n	c05aacc <StSafeA_ComputeCMAC+0x124>
        StSafeA_AES_MAC_Update(aRMacBuffer, STSAFEA_MAC_PACKET_SIZE, pAesRMacCtx);
 c05aa4c:	2110      	movs	r1, #16
 c05aa4e:	f8d8 2000 	ldr.w	r2, [r8]
 c05aa52:	4820      	ldr	r0, [pc, #128]	@ (c05aad4 <StSafeA_ComputeCMAC+0x12c>)
 c05aa54:	f7f6 f914 	bl	c050c80 <StSafeA_AES_MAC_Update>
        StSafeA_AES_MAC_Update(&pStSafeA->InOutBuffer.LV.Data[STSAFEA_MAC_PACKET_SIZE -
 c05aa58:	68a0      	ldr	r0, [r4, #8]
                               ((uint16_t)(((uint32_t)length - STSAFEA_MAC_PACKET_SIZE +
 c05aa5a:	f1a5 010c 	sub.w	r1, r5, #12
        StSafeA_AES_MAC_Update(&pStSafeA->InOutBuffer.LV.Data[STSAFEA_MAC_PACKET_SIZE -
 c05aa5e:	f021 010f 	bic.w	r1, r1, #15
 c05aa62:	f8d8 2000 	ldr.w	r2, [r8]
 c05aa66:	b289      	uxth	r1, r1
 c05aa68:	300c      	adds	r0, #12
 c05aa6a:	f7f6 f909 	bl	c050c80 <StSafeA_AES_MAC_Update>
        RMacBufferSize = (uint8_t)((uint32_t)length - STSAFEA_MAC_PACKET_SIZE +
 c05aa6e:	f1a6 020c 	sub.w	r2, r6, #12
                                   STSAFEA_KNOWN_INPUT_TO_CMAC_COMPUTATION_SIZE) %
 c05aa72:	f002 020f 	and.w	r2, r2, #15
        (void)memcpy(aRMacBuffer, &pStSafeA->InOutBuffer.LV.Data[length - RMacBufferSize], RMacBufferSize);
 c05aa76:	68a1      	ldr	r1, [r4, #8]
 c05aa78:	1aad      	subs	r5, r5, r2
 c05aa7a:	4816      	ldr	r0, [pc, #88]	@ (c05aad4 <StSafeA_ComputeCMAC+0x12c>)
 c05aa7c:	4429      	add	r1, r5
        RMacBufferSize = (uint8_t)((uint32_t)length - STSAFEA_MAC_PACKET_SIZE +
 c05aa7e:	703a      	strb	r2, [r7, #0]
        (void)memcpy(aRMacBuffer, &pStSafeA->InOutBuffer.LV.Data[length - RMacBufferSize], RMacBufferSize);
 c05aa80:	f000 fde4 	bl	c05b64c <memcpy>
    pStSafeA->InOutBuffer.LV.Length += STSAFEA_MAC_LENGTH;
 c05aa84:	88a3      	ldrh	r3, [r4, #4]
 c05aa86:	3304      	adds	r3, #4
 c05aa88:	80a3      	strh	r3, [r4, #4]
}
 c05aa8a:	b003      	add	sp, #12
 c05aa8c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      ComputeInitialValue(pStSafeA, CMAC_COMPUTATION, aRMacBuffer);
 c05aa90:	4631      	mov	r1, r6
 c05aa92:	4a10      	ldr	r2, [pc, #64]	@ (c05aad4 <StSafeA_ComputeCMAC+0x12c>)
 c05aa94:	6920      	ldr	r0, [r4, #16]
 c05aa96:	f7ff ff74 	bl	c05a982 <ComputeInitialValue.isra.0>
      StSafeA_AES_MAC_Update(aRMacBuffer, STSAFEA_MAC_PACKET_SIZE, p_aes_cmac_ctx);
 c05aa9a:	2110      	movs	r1, #16
 c05aa9c:	9a01      	ldr	r2, [sp, #4]
 c05aa9e:	480d      	ldr	r0, [pc, #52]	@ (c05aad4 <StSafeA_ComputeCMAC+0x12c>)
 c05aaa0:	f7f6 f8ee 	bl	c050c80 <StSafeA_AES_MAC_Update>
    aRMacBuffer[0] = (host_mac_computation == 0U) ? ((uint8_t)pStSafeA->MacCounter & 0x7FU) : 0x00U;
 c05aaa4:	4633      	mov	r3, r6
    length = pStSafeA->InOutBuffer.LV.Length;
 c05aaa6:	88a5      	ldrh	r5, [r4, #4]
    aRMacBuffer[0] = (host_mac_computation == 0U) ? ((uint8_t)pStSafeA->MacCounter & 0x7FU) : 0x00U;
 c05aaa8:	e796      	b.n	c05a9d8 <StSafeA_ComputeCMAC+0x30>
      StSafeA_AES_MAC_LastUpdate(aRMacBuffer, length + (uint16_t)STSAFEA_KNOWN_INPUT_TO_CMAC_COMPUTATION_SIZE,
 c05aaaa:	1d29      	adds	r1, r5, #4
 c05aaac:	4630      	mov	r0, r6
 c05aaae:	b289      	uxth	r1, r1
 c05aab0:	e7a7      	b.n	c05aa02 <StSafeA_ComputeCMAC+0x5a>
        ComputeInitialValue(pStSafeA, RMAC_COMPUTATION, aRMacBuffer);
 c05aab2:	2101      	movs	r1, #1
 c05aab4:	4a07      	ldr	r2, [pc, #28]	@ (c05aad4 <StSafeA_ComputeCMAC+0x12c>)
 c05aab6:	6920      	ldr	r0, [r4, #16]
 c05aab8:	f7ff ff63 	bl	c05a982 <ComputeInitialValue.isra.0>
        StSafeA_AES_MAC_Update(aRMacBuffer, STSAFEA_MAC_PACKET_SIZE, pAesRMacCtx);
 c05aabc:	2110      	movs	r1, #16
 c05aabe:	f8d8 2000 	ldr.w	r2, [r8]
 c05aac2:	4804      	ldr	r0, [pc, #16]	@ (c05aad4 <StSafeA_ComputeCMAC+0x12c>)
 c05aac4:	f7f6 f8dc 	bl	c050c80 <StSafeA_AES_MAC_Update>
      aRMacBuffer[0] = (host_mac_computation == 0U) ? ((pStSafeA->MacCounter + 1U) | 0x80U) : 0x80U;
 c05aac8:	2380      	movs	r3, #128	@ 0x80
 c05aaca:	e7b6      	b.n	c05aa3a <StSafeA_ComputeCMAC+0x92>
        RMacBufferSize = (uint8_t)(length + STSAFEA_KNOWN_INPUT_TO_CMAC_COMPUTATION_SIZE);
 c05aacc:	3604      	adds	r6, #4
 c05aace:	703e      	strb	r6, [r7, #0]
 c05aad0:	e7d8      	b.n	c05aa84 <StSafeA_ComputeCMAC+0xdc>
 c05aad2:	bf00      	nop
 c05aad4:	30031d35 	.word	0x30031d35
 c05aad8:	30031d48 	.word	0x30031d48
 c05aadc:	30031d34 	.word	0x30031d34
 c05aae0:	30031d36 	.word	0x30031d36

0c05aae4 <StSafeA_ComputeRMAC>:
{
 c05aae4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  if (IS_STSAFEA_HANDLER_VALID_PTR(pStSafeA))
 c05aae8:	4604      	mov	r4, r0
 c05aaea:	b378      	cbz	r0, c05ab4c <StSafeA_ComputeRMAC+0x68>
 c05aaec:	6883      	ldr	r3, [r0, #8]
 c05aaee:	b36b      	cbz	r3, c05ab4c <StSafeA_ComputeRMAC+0x68>
    StSafeA_Copy_TLVBuffer(&aRMacBuffer[RMacBufferSize], &pStSafeA->InOutBuffer,
 c05aaf0:	f8df 9068 	ldr.w	r9, [pc, #104]	@ c05ab5c <StSafeA_ComputeRMAC+0x78>
 c05aaf4:	4f1a      	ldr	r7, [pc, #104]	@ (c05ab60 <StSafeA_ComputeRMAC+0x7c>)
 c05aaf6:	f899 5000 	ldrb.w	r5, [r9]
    uint16_t length = pStSafeA->InOutBuffer.LV.Length;
 c05aafa:	8886      	ldrh	r6, [r0, #4]
    StSafeA_Copy_TLVBuffer(&aRMacBuffer[RMacBufferSize], &pStSafeA->InOutBuffer,
 c05aafc:	f1c5 0210 	rsb	r2, r5, #16
 c05ab00:	4601      	mov	r1, r0
 c05ab02:	b292      	uxth	r2, r2
 c05ab04:	1978      	adds	r0, r7, r5
 c05ab06:	f7ff ff29 	bl	c05a95c <StSafeA_Copy_TLVBuffer>
      StSafeA_AES_MAC_Update(aRMacBuffer, STSAFEA_MAC_PACKET_SIZE, pAesRMacCtx);
 c05ab0a:	f8df 8058 	ldr.w	r8, [pc, #88]	@ c05ab64 <StSafeA_ComputeRMAC+0x80>
    if ((length + RMacBufferSize) > (uint16_t)(STSAFEA_MAC_PACKET_SIZE - STSAFEA_KNOWN_INPUT_TO_RMAC_COMPUTATION_SIZE))
 c05ab0e:	19ab      	adds	r3, r5, r6
 c05ab10:	2b0d      	cmp	r3, #13
      StSafeA_AES_MAC_Update(aRMacBuffer, STSAFEA_MAC_PACKET_SIZE, pAesRMacCtx);
 c05ab12:	f8d8 2000 	ldr.w	r2, [r8]
    if ((length + RMacBufferSize) > (uint16_t)(STSAFEA_MAC_PACKET_SIZE - STSAFEA_KNOWN_INPUT_TO_RMAC_COMPUTATION_SIZE))
 c05ab16:	dd1b      	ble.n	c05ab50 <StSafeA_ComputeRMAC+0x6c>
      StSafeA_AES_MAC_Update(aRMacBuffer, STSAFEA_MAC_PACKET_SIZE, pAesRMacCtx);
 c05ab18:	2110      	movs	r1, #16
 c05ab1a:	4638      	mov	r0, r7
 c05ab1c:	f7f6 f8b0 	bl	c050c80 <StSafeA_AES_MAC_Update>
      StSafeA_AES_MAC_LastUpdate(&pStSafeA->InOutBuffer.LV.Data[(uint32_t)STSAFEA_MAC_PACKET_SIZE - RMacBufferSize -
 c05ab20:	f899 0000 	ldrb.w	r0, [r9]
 c05ab24:	68a3      	ldr	r3, [r4, #8]
 c05ab26:	f1a0 010d 	sub.w	r1, r0, #13
 c05ab2a:	4431      	add	r1, r6
 c05ab2c:	f1c0 000d 	rsb	r0, r0, #13
 c05ab30:	f8d8 2000 	ldr.w	r2, [r8]
 c05ab34:	b289      	uxth	r1, r1
 c05ab36:	4418      	add	r0, r3
      StSafeA_AES_MAC_LastUpdate(aRMacBuffer,
 c05ab38:	f7f6 f8a8 	bl	c050c8c <StSafeA_AES_MAC_LastUpdate>
    StSafeA_AES_MAC_Final(&pStSafeA->InOutBuffer.LV.Data[length], &pAesRMacCtx);
 c05ab3c:	68a0      	ldr	r0, [r4, #8]
 c05ab3e:	4909      	ldr	r1, [pc, #36]	@ (c05ab64 <StSafeA_ComputeRMAC+0x80>)
 c05ab40:	4430      	add	r0, r6
 c05ab42:	f7f6 f8a9 	bl	c050c98 <StSafeA_AES_MAC_Final>
    pStSafeA->InOutBuffer.LV.Length += STSAFEA_MAC_LENGTH;
 c05ab46:	88a3      	ldrh	r3, [r4, #4]
 c05ab48:	3304      	adds	r3, #4
 c05ab4a:	80a3      	strh	r3, [r4, #4]
}
 c05ab4c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      StSafeA_AES_MAC_LastUpdate(aRMacBuffer,
 c05ab50:	1ce9      	adds	r1, r5, #3
 c05ab52:	4431      	add	r1, r6
 c05ab54:	4638      	mov	r0, r7
 c05ab56:	b289      	uxth	r1, r1
 c05ab58:	e7ee      	b.n	c05ab38 <StSafeA_ComputeRMAC+0x54>
 c05ab5a:	bf00      	nop
 c05ab5c:	30031d34 	.word	0x30031d34
 c05ab60:	30031d35 	.word	0x30031d35
 c05ab64:	30031d48 	.word	0x30031d48

0c05ab68 <StSafeA_MAC_SHA_PrePostProcess>:
{
 c05ab68:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  if (IS_STSAFEA_HANDLER_VALID_PTR(pStSafeA))
 c05ab6a:	4604      	mov	r4, r0
 c05ab6c:	b120      	cbz	r0, c05ab78 <StSafeA_MAC_SHA_PrePostProcess+0x10>
 c05ab6e:	6882      	ldr	r2, [r0, #8]
 c05ab70:	b112      	cbz	r2, c05ab78 <StSafeA_MAC_SHA_PrePostProcess+0x10>
    switch (MacShaProcessType)
 c05ab72:	b119      	cbz	r1, c05ab7c <StSafeA_MAC_SHA_PrePostProcess+0x14>
 c05ab74:	2901      	cmp	r1, #1
 c05ab76:	d00b      	beq.n	c05ab90 <StSafeA_MAC_SHA_PrePostProcess+0x28>
  StSafeA_ResponseCode_t status_code = STSAFEA_INVALID_PARAMETER;
 c05ab78:	2030      	movs	r0, #48	@ 0x30
 c05ab7a:	e007      	b.n	c05ab8c <StSafeA_MAC_SHA_PrePostProcess+0x24>
  if ((pStSafeA->InOutBuffer.Header & (uint8_t)STSAFEA_MAC_HOST_CMAC) == (uint8_t)STSAFEA_MAC_HOST_CMAC)
 c05ab7c:	7803      	ldrb	r3, [r0, #0]
 c05ab7e:	f003 03a0 	and.w	r3, r3, #160	@ 0xa0
 c05ab82:	2ba0      	cmp	r3, #160	@ 0xa0
 c05ab84:	d101      	bne.n	c05ab8a <StSafeA_MAC_SHA_PrePostProcess+0x22>
    StSafeA_ComputeCMAC(pStSafeA);
 c05ab86:	f7ff ff0f 	bl	c05a9a8 <StSafeA_ComputeCMAC>
        status_code = StSafeA_MAC_SHA_PreProcess(pStSafeA);
 c05ab8a:	2000      	movs	r0, #0
}
 c05ab8c:	b003      	add	sp, #12
 c05ab8e:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if (((uint8_t)pStSafeA->InOutBuffer.Header & (uint8_t)STSAFEA_CMD_HEADER_RMACEN) ==
 c05ab90:	7803      	ldrb	r3, [r0, #0]
 c05ab92:	065b      	lsls	r3, r3, #25
 c05ab94:	d5f9      	bpl.n	c05ab8a <StSafeA_MAC_SHA_PrePostProcess+0x22>
    pStSafeA->InOutBuffer.LV.Length -= STSAFEA_MAC_LENGTH;
 c05ab96:	8883      	ldrh	r3, [r0, #4]
 c05ab98:	3b04      	subs	r3, #4
 c05ab9a:	b29b      	uxth	r3, r3
 c05ab9c:	8083      	strh	r3, [r0, #4]
    (void)memcpy(a_rmac,
 c05ab9e:	58d7      	ldr	r7, [r2, r3]
 c05aba0:	9701      	str	r7, [sp, #4]
    StSafeA_ComputeRMAC(pStSafeA);
 c05aba2:	f7ff ff9f 	bl	c05aae4 <StSafeA_ComputeRMAC>
    if (memcmp(a_rmac,
 c05aba6:	2204      	movs	r2, #4
               &pStSafeA->InOutBuffer.LV.Data[pStSafeA->InOutBuffer.LV.Length - STSAFEA_MAC_LENGTH],
 c05aba8:	88a5      	ldrh	r5, [r4, #4]
 c05abaa:	68a6      	ldr	r6, [r4, #8]
 c05abac:	3d04      	subs	r5, #4
    if (memcmp(a_rmac,
 c05abae:	1971      	adds	r1, r6, r5
 c05abb0:	eb0d 0002 	add.w	r0, sp, r2
 c05abb4:	f000 fd3a 	bl	c05b62c <memcmp>
 c05abb8:	b110      	cbz	r0, c05abc0 <StSafeA_MAC_SHA_PrePostProcess+0x58>
      status_code = STSAFEA_INVALID_RMAC;
 c05abba:	2021      	movs	r0, #33	@ 0x21
      (void)memcpy(&pStSafeA->InOutBuffer.LV.Data[pStSafeA->InOutBuffer.LV.Length - STSAFEA_MAC_LENGTH],
 c05abbc:	5177      	str	r7, [r6, r5]
      status_code = STSAFEA_INVALID_RMAC;
 c05abbe:	e7e5      	b.n	c05ab8c <StSafeA_MAC_SHA_PrePostProcess+0x24>
      pStSafeA->InOutBuffer.LV.Length -= STSAFEA_MAC_LENGTH;
 c05abc0:	80a5      	strh	r5, [r4, #4]
 c05abc2:	e7e3      	b.n	c05ab8c <StSafeA_MAC_SHA_PrePostProcess+0x24>

0c05abc4 <StSafeA_DataEncryption>:
{
 c05abc4:	b570      	push	{r4, r5, r6, lr}
  if (IS_STSAFEA_HANDLER_VALID_PTR(pStSafeA))
 c05abc6:	4604      	mov	r4, r0
{
 c05abc8:	b086      	sub	sp, #24
  if (IS_STSAFEA_HANDLER_VALID_PTR(pStSafeA))
 c05abca:	2800      	cmp	r0, #0
 c05abcc:	d033      	beq.n	c05ac36 <StSafeA_DataEncryption+0x72>
 c05abce:	6883      	ldr	r3, [r0, #8]
 c05abd0:	2b00      	cmp	r3, #0
 c05abd2:	d030      	beq.n	c05ac36 <StSafeA_DataEncryption+0x72>
    ComputeInitialValue(pStSafeA, C_ENCRYPTION, initial_value);
 c05abd4:	2102      	movs	r1, #2
 c05abd6:	6900      	ldr	r0, [r0, #16]
 c05abd8:	aa02      	add	r2, sp, #8
 c05abda:	f7ff fed2 	bl	c05a982 <ComputeInitialValue.isra.0>
    status_code = ((StSafeA_AES_ECB_Encrypt(initial_value, initial_value,
 c05abde:	a902      	add	r1, sp, #8
 c05abe0:	2200      	movs	r2, #0
 c05abe2:	4608      	mov	r0, r1
 c05abe4:	f7f6 f864 	bl	c050cb0 <StSafeA_AES_ECB_Encrypt>
                                            STSAFEA_KEY_TYPE_AES_128) == 0) ? STSAFEA_OK : STSAFEA_CRYPTO_LIB_ISSUE);
 c05abe8:	4606      	mov	r6, r0
 c05abea:	bb10      	cbnz	r0, c05ac32 <StSafeA_DataEncryption+0x6e>
      pStSafeA->InOutBuffer.LV.Data[pStSafeA->InOutBuffer.LV.Length] = 0x80;
 c05abec:	2180      	movs	r1, #128	@ 0x80
 c05abee:	88a3      	ldrh	r3, [r4, #4]
 c05abf0:	68a2      	ldr	r2, [r4, #8]
 c05abf2:	54d1      	strb	r1, [r2, r3]
      pStSafeA->InOutBuffer.LV.Length++;
 c05abf4:	88a3      	ldrh	r3, [r4, #4]
      (void)memset(&pStSafeA->InOutBuffer.LV.Data[pStSafeA->InOutBuffer.LV.Length],
 c05abf6:	68a0      	ldr	r0, [r4, #8]
      pStSafeA->InOutBuffer.LV.Length++;
 c05abf8:	3301      	adds	r3, #1
 c05abfa:	b29b      	uxth	r3, r3
                       (uint8_t)(pStSafeA->InOutBuffer.LV.Length % (STSAFEA_HOST_SECURE_CHANNEL_MODULUS));
 c05abfc:	f003 050f 	and.w	r5, r3, #15
      padding_length = STSAFEA_HOST_SECURE_CHANNEL_MODULUS -
 c05ac00:	f1c5 0510 	rsb	r5, r5, #16
 c05ac04:	b2ed      	uxtb	r5, r5
      (void)memset(&pStSafeA->InOutBuffer.LV.Data[pStSafeA->InOutBuffer.LV.Length],
 c05ac06:	462a      	mov	r2, r5
 c05ac08:	4631      	mov	r1, r6
      pStSafeA->InOutBuffer.LV.Length++;
 c05ac0a:	80a3      	strh	r3, [r4, #4]
      (void)memset(&pStSafeA->InOutBuffer.LV.Data[pStSafeA->InOutBuffer.LV.Length],
 c05ac0c:	4418      	add	r0, r3
 c05ac0e:	f000 fd8e 	bl	c05b72e <memset>
      pStSafeA->InOutBuffer.LV.Length += padding_length;
 c05ac12:	88a3      	ldrh	r3, [r4, #4]
      status_code = (StSafeA_AES_CBC_Encrypt(&pStSafeA->InOutBuffer.LV.Data[0],
 c05ac14:	68a2      	ldr	r2, [r4, #8]
      pStSafeA->InOutBuffer.LV.Length += padding_length;
 c05ac16:	441d      	add	r5, r3
 c05ac18:	b2a9      	uxth	r1, r5
 c05ac1a:	80a1      	strh	r1, [r4, #4]
      status_code = (StSafeA_AES_CBC_Encrypt(&pStSafeA->InOutBuffer.LV.Data[0],
 c05ac1c:	4610      	mov	r0, r2
 c05ac1e:	9600      	str	r6, [sp, #0]
 c05ac20:	ab02      	add	r3, sp, #8
 c05ac22:	f7f6 f86b 	bl	c050cfc <StSafeA_AES_CBC_Encrypt>
                                             STSAFEA_KEY_TYPE_AES_128) == 0) ? STSAFEA_OK : STSAFEA_CRYPTO_LIB_ISSUE;
 c05ac26:	3800      	subs	r0, #0
 c05ac28:	bf18      	it	ne
 c05ac2a:	2001      	movne	r0, #1
 c05ac2c:	0140      	lsls	r0, r0, #5
}
 c05ac2e:	b006      	add	sp, #24
 c05ac30:	bd70      	pop	{r4, r5, r6, pc}
                                            STSAFEA_KEY_TYPE_AES_128) == 0) ? STSAFEA_OK : STSAFEA_CRYPTO_LIB_ISSUE);
 c05ac32:	2020      	movs	r0, #32
 c05ac34:	e7fb      	b.n	c05ac2e <StSafeA_DataEncryption+0x6a>
  StSafeA_ResponseCode_t status_code = STSAFEA_INVALID_PARAMETER;
 c05ac36:	2030      	movs	r0, #48	@ 0x30
 c05ac38:	e7f9      	b.n	c05ac2e <StSafeA_DataEncryption+0x6a>

0c05ac3a <StSafeA_DataDecryption>:
{
 c05ac3a:	b5f0      	push	{r4, r5, r6, r7, lr}
  if (IS_STSAFEA_HANDLER_VALID_PTR(pStSafeA))
 c05ac3c:	4604      	mov	r4, r0
{
 c05ac3e:	b087      	sub	sp, #28
  if (IS_STSAFEA_HANDLER_VALID_PTR(pStSafeA))
 c05ac40:	2800      	cmp	r0, #0
 c05ac42:	d03b      	beq.n	c05acbc <StSafeA_DataDecryption+0x82>
 c05ac44:	6883      	ldr	r3, [r0, #8]
 c05ac46:	2b00      	cmp	r3, #0
 c05ac48:	d038      	beq.n	c05acbc <StSafeA_DataDecryption+0x82>
    ComputeInitialValue(pStSafeA, R_ENCRYPTION, initial_value);
 c05ac4a:	2103      	movs	r1, #3
 c05ac4c:	6900      	ldr	r0, [r0, #16]
 c05ac4e:	aa02      	add	r2, sp, #8
 c05ac50:	f7ff fe97 	bl	c05a982 <ComputeInitialValue.isra.0>
    status_code = ((StSafeA_AES_ECB_Encrypt(initial_value, initial_value,
 c05ac54:	a902      	add	r1, sp, #8
 c05ac56:	2200      	movs	r2, #0
 c05ac58:	4608      	mov	r0, r1
 c05ac5a:	f7f6 f829 	bl	c050cb0 <StSafeA_AES_ECB_Encrypt>
                                            STSAFEA_KEY_TYPE_AES_128) == 0) ? STSAFEA_OK : STSAFEA_CRYPTO_LIB_ISSUE);
 c05ac5e:	b110      	cbz	r0, c05ac66 <StSafeA_DataDecryption+0x2c>
 c05ac60:	2020      	movs	r0, #32
}
 c05ac62:	b007      	add	sp, #28
 c05ac64:	bdf0      	pop	{r4, r5, r6, r7, pc}
      status_code = (StSafeA_AES_CBC_Decrypt(&pStSafeA->InOutBuffer.LV.Data[0],
 c05ac66:	9000      	str	r0, [sp, #0]
 c05ac68:	68a2      	ldr	r2, [r4, #8]
 c05ac6a:	88a1      	ldrh	r1, [r4, #4]
 c05ac6c:	4610      	mov	r0, r2
 c05ac6e:	ab02      	add	r3, sp, #8
 c05ac70:	f7f6 f872 	bl	c050d58 <StSafeA_AES_CBC_Decrypt>
                                             STSAFEA_KEY_TYPE_AES_128) == 0) ? STSAFEA_OK : STSAFEA_CRYPTO_LIB_ISSUE;
 c05ac74:	2800      	cmp	r0, #0
 c05ac76:	d1f3      	bne.n	c05ac60 <StSafeA_DataDecryption+0x26>
        p_padding = StSafeA_Memrchr(&pStSafeA->InOutBuffer.LV.Data[0], 0x80,
 c05ac78:	68a1      	ldr	r1, [r4, #8]
                                    pStSafeA->InOutBuffer.LV.Length);
 c05ac7a:	88a2      	ldrh	r2, [r4, #4]
static const uint8_t *StSafeA_Memrchr(void *pSource, uint8_t CharToFind, size_t Size)
{
  const uint8_t *pRet = NULL;
  uint8_t CharFound = 0U;
  /* Check input parameter */
  if (pSource != NULL)
 c05ac7c:	2900      	cmp	r1, #0
 c05ac7e:	d0ef      	beq.n	c05ac60 <StSafeA_DataDecryption+0x26>
  {
    uint8_t *p = (uint8_t *)pSource;
    uint32_t i = Size - 1U;
 c05ac80:	1e55      	subs	r5, r2, #1
 c05ac82:	440d      	add	r5, r1

    while ((&p[i] != pSource) && (CharFound == 0U))
 c05ac84:	462e      	mov	r6, r5
  const uint8_t *pRet = NULL;
 c05ac86:	4603      	mov	r3, r0
    while ((&p[i] != pSource) && (CharFound == 0U))
 c05ac88:	42b1      	cmp	r1, r6
 c05ac8a:	4637      	mov	r7, r6
 c05ac8c:	d10b      	bne.n	c05aca6 <StSafeA_DataDecryption+0x6c>
        if ((p_padding == NULL) ||
 c05ac8e:	2b00      	cmp	r3, #0
 c05ac90:	d0e6      	beq.n	c05ac60 <StSafeA_DataDecryption+0x26>
 c05ac92:	429d      	cmp	r5, r3
 c05ac94:	d3e4      	bcc.n	c05ac60 <StSafeA_DataDecryption+0x26>
        uint16_t new_length  = (uint16_t)(padding_pos - buffer_pos);
 c05ac96:	1a5b      	subs	r3, r3, r1
 c05ac98:	b29b      	uxth	r3, r3
            (new_length < (pStSafeA->InOutBuffer.LV.Length - (uint16_t)(STSAFEA_HOST_SECURE_CHANNEL_MODULUS))))
 c05ac9a:	3a10      	subs	r2, #16
            (padding_pos > (uint32_t)(&pStSafeA->InOutBuffer.LV.Data[pStSafeA->InOutBuffer.LV.Length - 1U])) ||
 c05ac9c:	4293      	cmp	r3, r2
 c05ac9e:	dbdf      	blt.n	c05ac60 <StSafeA_DataDecryption+0x26>
                                             STSAFEA_KEY_TYPE_AES_128) == 0) ? STSAFEA_OK : STSAFEA_CRYPTO_LIB_ISSUE;
 c05aca0:	2000      	movs	r0, #0
          pStSafeA->InOutBuffer.LV.Length = new_length;
 c05aca2:	80a3      	strh	r3, [r4, #4]
 c05aca4:	e7dd      	b.n	c05ac62 <StSafeA_DataDecryption+0x28>
    while ((&p[i] != pSource) && (CharFound == 0U))
 c05aca6:	2800      	cmp	r0, #0
 c05aca8:	d1f1      	bne.n	c05ac8e <StSafeA_DataDecryption+0x54>
    {
      if (p[i] == CharToFind)
 c05acaa:	f897 c000 	ldrb.w	ip, [r7]
 c05acae:	3e01      	subs	r6, #1
 c05acb0:	f1bc 0f80 	cmp.w	ip, #128	@ 0x80
 c05acb4:	bf04      	itt	eq
 c05acb6:	2001      	moveq	r0, #1
  const uint8_t *pRet = NULL;
 c05acb8:	463b      	moveq	r3, r7
 c05acba:	e7e5      	b.n	c05ac88 <StSafeA_DataDecryption+0x4e>
  StSafeA_ResponseCode_t status_code = STSAFEA_INVALID_PARAMETER;
 c05acbc:	2030      	movs	r0, #48	@ 0x30
 c05acbe:	e7d0      	b.n	c05ac62 <StSafeA_DataDecryption+0x28>

0c05acc0 <StSafeA_Crc16>:
  *
  * @param   pTLV_Buffer : TLV Structure pointer containing the data to calculate the CRC on.
  * @retval  None
  */
void StSafeA_Crc16(StSafeA_TLVBuffer_t *pTLV_Buffer)
{
 c05acc0:	b538      	push	{r3, r4, r5, lr}
  if ((pTLV_Buffer != NULL))
 c05acc2:	4604      	mov	r4, r0
 c05acc4:	b158      	cbz	r0, c05acde <StSafeA_Crc16+0x1e>
  {
    uint16_t crc16;

    crc16 = (uint16_t)HwCtx.CrcCompute(&(pTLV_Buffer->Header),
 c05acc6:	4b06      	ldr	r3, [pc, #24]	@ (c05ace0 <StSafeA_Crc16+0x20>)
 c05acc8:	6882      	ldr	r2, [r0, #8]
 c05acca:	69dd      	ldr	r5, [r3, #28]
 c05accc:	2101      	movs	r1, #1
 c05acce:	8883      	ldrh	r3, [r0, #4]
 c05acd0:	47a8      	blx	r5
                                       1U,
                                       pTLV_Buffer->LV.Data,
                                       pTLV_Buffer->LV.Length);

    (void)memcpy(&pTLV_Buffer->LV.Data[pTLV_Buffer->LV.Length], &crc16, sizeof(crc16));
 c05acd2:	88a3      	ldrh	r3, [r4, #4]
 c05acd4:	68a2      	ldr	r2, [r4, #8]
 c05acd6:	52d0      	strh	r0, [r2, r3]
    pTLV_Buffer->LV.Length += STSAFEA_CRC_LENGTH;
 c05acd8:	88a3      	ldrh	r3, [r4, #4]
 c05acda:	3302      	adds	r3, #2
 c05acdc:	80a3      	strh	r3, [r4, #4]
  }
}
 c05acde:	bd38      	pop	{r3, r4, r5, pc}
 c05ace0:	30031d4c 	.word	0x30031d4c

0c05ace4 <StSafeA_Transmit>:
{
 c05ace4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if (pTLV_Buffer != NULL)
 c05ace8:	4605      	mov	r5, r0
 c05acea:	2800      	cmp	r0, #0
 c05acec:	d03c      	beq.n	c05ad68 <StSafeA_Transmit+0x84>
    if (CrcSupport != 0U)
 c05acee:	b109      	cbz	r1, c05acf4 <StSafeA_Transmit+0x10>
      StSafeA_Crc16(pTLV_Buffer);
 c05acf0:	f7ff ffe6 	bl	c05acc0 <StSafeA_Crc16>
  uint16_t i2c_length = pInBuffer->LV.Length + STSAFEA_HEADER_LENGTH;
 c05acf4:	88aa      	ldrh	r2, [r5, #4]
 c05acf6:	1c57      	adds	r7, r2, #1
 c05acf8:	b2bf      	uxth	r7, r7
  if (i2c_length > STSAFEA_BUFFER_DATA_PACKET_SIZE)
 c05acfa:	f5b7 7ffe 	cmp.w	r7, #508	@ 0x1fc
 c05acfe:	d302      	bcc.n	c05ad06 <StSafeA_Transmit+0x22>
    status_code = (StSafeA_ResponseCode_t)StSafeA_SendBytes(pTLV_Buffer);
 c05ad00:	2006      	movs	r0, #6
}
 c05ad02:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if (pInBuffer->LV.Data != NULL)
 c05ad06:	68a9      	ldr	r1, [r5, #8]
 c05ad08:	b361      	cbz	r1, c05ad64 <StSafeA_Transmit+0x80>
    pInBuffer->LV.Data[0] = pInBuffer->Header;
 c05ad0a:	f44f 768b 	mov.w	r6, #278	@ 0x116
    (void)memmove((uint8_t *)&pInBuffer->LV.Data[1], (uint8_t *)&pInBuffer->LV.Data[0], pInBuffer->LV.Length);
 c05ad0e:	1c48      	adds	r0, r1, #1
 c05ad10:	f000 fccd 	bl	c05b6ae <memmove>
    pInBuffer->LV.Data[0] = pInBuffer->Header;
 c05ad14:	68ab      	ldr	r3, [r5, #8]
 c05ad16:	782a      	ldrb	r2, [r5, #0]
      status_code = HwCtx.BusSend(((uint16_t)HwCtx.DevAddr) << 1,
 c05ad18:	f8df 8054 	ldr.w	r8, [pc, #84]	@ c05ad70 <StSafeA_Transmit+0x8c>
    pInBuffer->LV.Data[0] = pInBuffer->Header;
 c05ad1c:	701a      	strb	r2, [r3, #0]
      status_code = HwCtx.BusSend(((uint16_t)HwCtx.DevAddr) << 1,
 c05ad1e:	f8b8 0020 	ldrh.w	r0, [r8, #32]
 c05ad22:	463a      	mov	r2, r7
 c05ad24:	0040      	lsls	r0, r0, #1
 c05ad26:	f8d8 3010 	ldr.w	r3, [r8, #16]
 c05ad2a:	68a9      	ldr	r1, [r5, #8]
 c05ad2c:	b280      	uxth	r0, r0
 c05ad2e:	4798      	blx	r3
 c05ad30:	b244      	sxtb	r4, r0
      if (status_code == STSAFEA_BUS_NACK)
 c05ad32:	2c01      	cmp	r4, #1
 c05ad34:	d108      	bne.n	c05ad48 <StSafeA_Transmit+0x64>
        HwCtx.TimeDelay(STSAFEA_I2C_POLLING_STEP);
 c05ad36:	2003      	movs	r0, #3
 c05ad38:	f8d8 3014 	ldr.w	r3, [r8, #20]
 c05ad3c:	4798      	blx	r3
    while ((status_code != STSAFEA_BUS_OK) && (loop <= (STSAFEA_I2C_POLLING_MAX / STSAFEA_I2C_POLLING_STEP)))
 c05ad3e:	3e01      	subs	r6, #1
 c05ad40:	b2b6      	uxth	r6, r6
 c05ad42:	2e00      	cmp	r6, #0
 c05ad44:	d1eb      	bne.n	c05ad1e <StSafeA_Transmit+0x3a>
 c05ad46:	e001      	b.n	c05ad4c <StSafeA_Transmit+0x68>
 c05ad48:	2c00      	cmp	r4, #0
 c05ad4a:	d1f8      	bne.n	c05ad3e <StSafeA_Transmit+0x5a>
    (void)memmove((uint8_t *)&pInBuffer->LV.Data[0], (uint8_t *)&pInBuffer->LV.Data[1], pInBuffer->LV.Length);
 c05ad4c:	68a8      	ldr	r0, [r5, #8]
 c05ad4e:	88aa      	ldrh	r2, [r5, #4]
 c05ad50:	1c41      	adds	r1, r0, #1
 c05ad52:	f000 fcac 	bl	c05b6ae <memmove>
    status_code = (StSafeA_ResponseCode_t)StSafeA_SendBytes(pTLV_Buffer);
 c05ad56:	b2e0      	uxtb	r0, r4
    if (status_code != STSAFEA_BUFFER_LENGTH_EXCEEDED)
 c05ad58:	2806      	cmp	r0, #6
 c05ad5a:	d0d1      	beq.n	c05ad00 <StSafeA_Transmit+0x1c>
      if (status_code == (StSafeA_ResponseCode_t)STSAFEA_BUS_OK)
 c05ad5c:	2800      	cmp	r0, #0
 c05ad5e:	d0d0      	beq.n	c05ad02 <StSafeA_Transmit+0x1e>
      else if (status_code == (StSafeA_ResponseCode_t)STSAFEA_BUS_NACK)
 c05ad60:	2801      	cmp	r0, #1
 c05ad62:	d003      	beq.n	c05ad6c <StSafeA_Transmit+0x88>
        status_code = STSAFEA_COMMUNICATION_ERROR;
 c05ad64:	2001      	movs	r0, #1
 c05ad66:	e7cc      	b.n	c05ad02 <StSafeA_Transmit+0x1e>
  StSafeA_ResponseCode_t status_code = STSAFEA_INVALID_PARAMETER;
 c05ad68:	2030      	movs	r0, #48	@ 0x30
 c05ad6a:	e7ca      	b.n	c05ad02 <StSafeA_Transmit+0x1e>
        status_code = STSAFEA_COMMUNICATION_NACK;
 c05ad6c:	2032      	movs	r0, #50	@ 0x32
 c05ad6e:	e7c8      	b.n	c05ad02 <StSafeA_Transmit+0x1e>
 c05ad70:	30031d4c 	.word	0x30031d4c

0c05ad74 <StSafeA_Receive>:
{
 c05ad74:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
 c05ad78:	4688      	mov	r8, r1
  if (pTLV_Buffer != NULL)
 c05ad7a:	4604      	mov	r4, r0
 c05ad7c:	2800      	cmp	r0, #0
 c05ad7e:	f000 8088 	beq.w	c05ae92 <StSafeA_Receive+0x11e>
    if (CrcSupport != 0U)
 c05ad82:	b111      	cbz	r1, c05ad8a <StSafeA_Receive+0x16>
      pTLV_Buffer->LV.Length += STSAFEA_CRC_LENGTH;
 c05ad84:	8883      	ldrh	r3, [r0, #4]
 c05ad86:	3302      	adds	r3, #2
 c05ad88:	8083      	strh	r3, [r0, #4]
  uint16_t response_length = pOutBuffer->LV.Length;
 c05ad8a:	f8b4 9004 	ldrh.w	r9, [r4, #4]
  if ((response_length + STSAFEA_HEADER_LENGTH) > STSAFEA_BUFFER_DATA_PACKET_SIZE)
 c05ad8e:	f109 0301 	add.w	r3, r9, #1
 c05ad92:	f5b3 7ffe 	cmp.w	r3, #508	@ 0x1fc
 c05ad96:	d27e      	bcs.n	c05ae96 <StSafeA_Receive+0x122>
  if (pOutBuffer->LV.Data != NULL)
 c05ad98:	68a3      	ldr	r3, [r4, #8]
 c05ad9a:	b923      	cbnz	r3, c05ada6 <StSafeA_Receive+0x32>
        status_code = STSAFEA_COMMUNICATION_ERROR;
 c05ad9c:	2501      	movs	r5, #1
}
 c05ad9e:	4628      	mov	r0, r5
 c05ada0:	b002      	add	sp, #8
 c05ada2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 c05ada6:	f44f 778b 	mov.w	r7, #278	@ 0x116
      status_code = HwCtx.BusRecv(((uint16_t)HwCtx.DevAddr) << 1,
 c05adaa:	f109 0a03 	add.w	sl, r9, #3
 c05adae:	4e3b      	ldr	r6, [pc, #236]	@ (c05ae9c <StSafeA_Receive+0x128>)
 c05adb0:	fa1f fa8a 	uxth.w	sl, sl
 c05adb4:	8c30      	ldrh	r0, [r6, #32]
 c05adb6:	4652      	mov	r2, sl
 c05adb8:	0040      	lsls	r0, r0, #1
 c05adba:	68f3      	ldr	r3, [r6, #12]
 c05adbc:	68a1      	ldr	r1, [r4, #8]
 c05adbe:	b280      	uxth	r0, r0
 c05adc0:	4798      	blx	r3
 c05adc2:	b245      	sxtb	r5, r0
      if (status_code == STSAFEA_BUS_NACK)
 c05adc4:	2d01      	cmp	r5, #1
 c05adc6:	d107      	bne.n	c05add8 <StSafeA_Receive+0x64>
        HwCtx.TimeDelay(STSAFEA_I2C_POLLING_STEP);
 c05adc8:	2003      	movs	r0, #3
 c05adca:	6973      	ldr	r3, [r6, #20]
 c05adcc:	4798      	blx	r3
    while ((status_code != STSAFEA_BUS_OK) && (loop <= (STSAFEA_I2C_POLLING_MAX / STSAFEA_I2C_POLLING_STEP)))
 c05adce:	3f01      	subs	r7, #1
 c05add0:	b2bf      	uxth	r7, r7
 c05add2:	2f00      	cmp	r7, #0
 c05add4:	d1ee      	bne.n	c05adb4 <StSafeA_Receive+0x40>
 c05add6:	e001      	b.n	c05addc <StSafeA_Receive+0x68>
 c05add8:	2d00      	cmp	r5, #0
 c05adda:	d1f8      	bne.n	c05adce <StSafeA_Receive+0x5a>
    pOutBuffer->Header = pOutBuffer->LV.Data[0];
 c05addc:	68a0      	ldr	r0, [r4, #8]
    (void)memcpy(pOutBuffer->LV.Data, &pOutBuffer->LV.Data[3], response_length);
 c05adde:	464a      	mov	r2, r9
    pOutBuffer->Header = pOutBuffer->LV.Data[0];
 c05ade0:	7803      	ldrb	r3, [r0, #0]
    (void)memcpy(pOutBuffer->LV.Data, &pOutBuffer->LV.Data[3], response_length);
 c05ade2:	1cc1      	adds	r1, r0, #3
    pOutBuffer->Header = pOutBuffer->LV.Data[0];
 c05ade4:	7023      	strb	r3, [r4, #0]
    pOutBuffer->LV.Length = ((uint16_t)pOutBuffer->LV.Data[1] << 8) + pOutBuffer->LV.Data[2];
 c05ade6:	f8b0 3001 	ldrh.w	r3, [r0, #1]
 c05adea:	ba5b      	rev16	r3, r3
 c05adec:	80a3      	strh	r3, [r4, #4]
    (void)memcpy(pOutBuffer->LV.Data, &pOutBuffer->LV.Data[3], response_length);
 c05adee:	f000 fc2d 	bl	c05b64c <memcpy>
    if ((pOutBuffer->LV.Length > response_length) && (status_code == 0))
 c05adf2:	88a3      	ldrh	r3, [r4, #4]
 c05adf4:	454b      	cmp	r3, r9
 c05adf6:	d923      	bls.n	c05ae40 <StSafeA_Receive+0xcc>
 c05adf8:	bb15      	cbnz	r5, c05ae40 <StSafeA_Receive+0xcc>
 c05adfa:	f44f 778b 	mov.w	r7, #278	@ 0x116
        status_code = HwCtx.BusRecv(((uint16_t)HwCtx.DevAddr) << 1,
 c05adfe:	88a2      	ldrh	r2, [r4, #4]
 c05ae00:	8c30      	ldrh	r0, [r6, #32]
 c05ae02:	3203      	adds	r2, #3
 c05ae04:	0040      	lsls	r0, r0, #1
 c05ae06:	68f3      	ldr	r3, [r6, #12]
 c05ae08:	68a1      	ldr	r1, [r4, #8]
 c05ae0a:	b280      	uxth	r0, r0
 c05ae0c:	b292      	uxth	r2, r2
 c05ae0e:	4798      	blx	r3
 c05ae10:	b245      	sxtb	r5, r0
        if (status_code == STSAFEA_BUS_NACK)
 c05ae12:	2d01      	cmp	r5, #1
 c05ae14:	d107      	bne.n	c05ae26 <StSafeA_Receive+0xb2>
          HwCtx.TimeDelay(STSAFEA_I2C_POLLING_STEP);
 c05ae16:	2003      	movs	r0, #3
 c05ae18:	6973      	ldr	r3, [r6, #20]
 c05ae1a:	4798      	blx	r3
      while ((status_code != STSAFEA_BUS_OK) && (loop <= (STSAFEA_I2C_POLLING_MAX / STSAFEA_I2C_POLLING_STEP)))
 c05ae1c:	3f01      	subs	r7, #1
 c05ae1e:	b2bf      	uxth	r7, r7
 c05ae20:	2f00      	cmp	r7, #0
 c05ae22:	d1ec      	bne.n	c05adfe <StSafeA_Receive+0x8a>
 c05ae24:	e001      	b.n	c05ae2a <StSafeA_Receive+0xb6>
 c05ae26:	2d00      	cmp	r5, #0
 c05ae28:	d1f8      	bne.n	c05ae1c <StSafeA_Receive+0xa8>
      pOutBuffer->Header = pOutBuffer->LV.Data[0];
 c05ae2a:	68a0      	ldr	r0, [r4, #8]
 c05ae2c:	7803      	ldrb	r3, [r0, #0]
      (void)memcpy(pOutBuffer->LV.Data, &pOutBuffer->LV.Data[3], pOutBuffer->LV.Length);
 c05ae2e:	1cc1      	adds	r1, r0, #3
      pOutBuffer->Header = pOutBuffer->LV.Data[0];
 c05ae30:	7023      	strb	r3, [r4, #0]
      pOutBuffer->LV.Length = ((uint16_t)pOutBuffer->LV.Data[1] << 8) + pOutBuffer->LV.Data[2];
 c05ae32:	f8b0 2001 	ldrh.w	r2, [r0, #1]
 c05ae36:	ba52      	rev16	r2, r2
 c05ae38:	80a2      	strh	r2, [r4, #4]
      (void)memcpy(pOutBuffer->LV.Data, &pOutBuffer->LV.Data[3], pOutBuffer->LV.Length);
 c05ae3a:	b292      	uxth	r2, r2
 c05ae3c:	f000 fc06 	bl	c05b64c <memcpy>
    status_code = (StSafeA_ResponseCode_t)StSafeA_ReceiveBytes(pTLV_Buffer);
 c05ae40:	b2ed      	uxtb	r5, r5
    if (status_code != STSAFEA_BUFFER_LENGTH_EXCEEDED)
 c05ae42:	2d06      	cmp	r5, #6
 c05ae44:	d027      	beq.n	c05ae96 <StSafeA_Receive+0x122>
      if (status_code == (StSafeA_ResponseCode_t)STSAFEA_BUS_OK)
 c05ae46:	b9f5      	cbnz	r5, c05ae86 <StSafeA_Receive+0x112>
        status_code = (StSafeA_ResponseCode_t)(uint8_t)((uint8_t)pTLV_Buffer->Header &
 c05ae48:	7825      	ldrb	r5, [r4, #0]
 c05ae4a:	f005 05bf 	and.w	r5, r5, #191	@ 0xbf
    if ((CrcSupport != 0U) && (status_code == STSAFEA_OK))
 c05ae4e:	f1b8 0f00 	cmp.w	r8, #0
 c05ae52:	d0a4      	beq.n	c05ad9e <StSafeA_Receive+0x2a>
 c05ae54:	2d00      	cmp	r5, #0
 c05ae56:	d1a2      	bne.n	c05ad9e <StSafeA_Receive+0x2a>
      pTLV_Buffer->LV.Length -= STSAFEA_CRC_LENGTH;
 c05ae58:	88a3      	ldrh	r3, [r4, #4]
      (void)memcpy(&crc, &pTLV_Buffer->LV.Data[pTLV_Buffer->LV.Length], sizeof(crc));
 c05ae5a:	68a2      	ldr	r2, [r4, #8]
      pTLV_Buffer->LV.Length -= STSAFEA_CRC_LENGTH;
 c05ae5c:	3b02      	subs	r3, #2
 c05ae5e:	b29b      	uxth	r3, r3
 c05ae60:	80a3      	strh	r3, [r4, #4]
      (void)memcpy(&crc, &pTLV_Buffer->LV.Data[pTLV_Buffer->LV.Length], sizeof(crc));
 c05ae62:	5ad3      	ldrh	r3, [r2, r3]
      StSafeA_Crc16(pTLV_Buffer);
 c05ae64:	4620      	mov	r0, r4
      (void)memcpy(&crc, &pTLV_Buffer->LV.Data[pTLV_Buffer->LV.Length], sizeof(crc));
 c05ae66:	f8ad 3006 	strh.w	r3, [sp, #6]
      StSafeA_Crc16(pTLV_Buffer);
 c05ae6a:	f7ff ff29 	bl	c05acc0 <StSafeA_Crc16>
      if (memcmp(&crc, &pTLV_Buffer->LV.Data[pTLV_Buffer->LV.Length - (uint16_t)2],
 c05ae6e:	88a6      	ldrh	r6, [r4, #4]
 c05ae70:	68a1      	ldr	r1, [r4, #8]
 c05ae72:	3e02      	subs	r6, #2
 c05ae74:	2202      	movs	r2, #2
 c05ae76:	4431      	add	r1, r6
 c05ae78:	f10d 0006 	add.w	r0, sp, #6
 c05ae7c:	f000 fbd6 	bl	c05b62c <memcmp>
 c05ae80:	b928      	cbnz	r0, c05ae8e <StSafeA_Receive+0x11a>
        pTLV_Buffer->LV.Length -= STSAFEA_CRC_LENGTH;
 c05ae82:	80a6      	strh	r6, [r4, #4]
 c05ae84:	e78b      	b.n	c05ad9e <StSafeA_Receive+0x2a>
      else if (status_code == (StSafeA_ResponseCode_t)STSAFEA_BUS_NACK)
 c05ae86:	2d01      	cmp	r5, #1
 c05ae88:	d188      	bne.n	c05ad9c <StSafeA_Receive+0x28>
        status_code = STSAFEA_COMMUNICATION_NACK;
 c05ae8a:	2532      	movs	r5, #50	@ 0x32
  return status_code;
 c05ae8c:	e787      	b.n	c05ad9e <StSafeA_Receive+0x2a>
        status_code = STSAFEA_INVALID_CRC;
 c05ae8e:	2522      	movs	r5, #34	@ 0x22
 c05ae90:	e785      	b.n	c05ad9e <StSafeA_Receive+0x2a>
  StSafeA_ResponseCode_t status_code = STSAFEA_INVALID_PARAMETER;
 c05ae92:	2530      	movs	r5, #48	@ 0x30
 c05ae94:	e783      	b.n	c05ad9e <StSafeA_Receive+0x2a>
    status_code = (StSafeA_ResponseCode_t)StSafeA_ReceiveBytes(pTLV_Buffer);
 c05ae96:	2506      	movs	r5, #6
 c05ae98:	e781      	b.n	c05ad9e <StSafeA_Receive+0x2a>
 c05ae9a:	bf00      	nop
 c05ae9c:	30031d4c 	.word	0x30031d4c

0c05aea0 <StSafeA_Delay>:
  if (HwCtx.TimeDelay != NULL)
 c05aea0:	4b02      	ldr	r3, [pc, #8]	@ (c05aeac <StSafeA_Delay+0xc>)
 c05aea2:	695b      	ldr	r3, [r3, #20]
 c05aea4:	b103      	cbz	r3, c05aea8 <StSafeA_Delay+0x8>
    HwCtx.TimeDelay(msDelay);
 c05aea6:	4718      	bx	r3
}
 c05aea8:	4770      	bx	lr
 c05aeaa:	bf00      	nop
 c05aeac:	30031d4c 	.word	0x30031d4c

0c05aeb0 <StSafeA_HW_Init>:
{
 c05aeb0:	b510      	push	{r4, lr}
  int8_t ret = StSafeA_HW_Probe(&HwCtx);
 c05aeb2:	4c10      	ldr	r4, [pc, #64]	@ (c05aef4 <StSafeA_HW_Init+0x44>)
 c05aeb4:	4620      	mov	r0, r4
 c05aeb6:	f7f6 f849 	bl	c050f4c <StSafeA_HW_Probe>
  if ((HwCtx.IOInit == NULL) ||
 c05aeba:	6823      	ldr	r3, [r4, #0]
 c05aebc:	b1bb      	cbz	r3, c05aeee <StSafeA_HW_Init+0x3e>
 c05aebe:	6862      	ldr	r2, [r4, #4]
 c05aec0:	b1aa      	cbz	r2, c05aeee <StSafeA_HW_Init+0x3e>
      (HwCtx.BusInit == NULL) ||
 c05aec2:	6922      	ldr	r2, [r4, #16]
 c05aec4:	b19a      	cbz	r2, c05aeee <StSafeA_HW_Init+0x3e>
      (HwCtx.BusSend == NULL) ||
 c05aec6:	68e2      	ldr	r2, [r4, #12]
 c05aec8:	b18a      	cbz	r2, c05aeee <StSafeA_HW_Init+0x3e>
      (HwCtx.BusRecv == NULL) ||
 c05aeca:	69a2      	ldr	r2, [r4, #24]
 c05aecc:	b17a      	cbz	r2, c05aeee <StSafeA_HW_Init+0x3e>
      (HwCtx.CrcInit == NULL) ||
 c05aece:	69e2      	ldr	r2, [r4, #28]
 c05aed0:	b16a      	cbz	r2, c05aeee <StSafeA_HW_Init+0x3e>
      (HwCtx.CrcCompute == NULL) ||
 c05aed2:	6962      	ldr	r2, [r4, #20]
 c05aed4:	b15a      	cbz	r2, c05aeee <StSafeA_HW_Init+0x3e>
  if (STSAFEA_BUS_OK == ret)
 c05aed6:	b948      	cbnz	r0, c05aeec <StSafeA_HW_Init+0x3c>
    ret = HwCtx.IOInit();
 c05aed8:	4798      	blx	r3
 c05aeda:	b240      	sxtb	r0, r0
  if (STSAFEA_BUS_OK == ret)
 c05aedc:	b930      	cbnz	r0, c05aeec <StSafeA_HW_Init+0x3c>
    ret = HwCtx.BusInit();
 c05aede:	6863      	ldr	r3, [r4, #4]
 c05aee0:	4798      	blx	r3
 c05aee2:	b240      	sxtb	r0, r0
  if (STSAFEA_BUS_OK == ret)
 c05aee4:	b910      	cbnz	r0, c05aeec <StSafeA_HW_Init+0x3c>
    ret = HwCtx.CrcInit();
 c05aee6:	69a3      	ldr	r3, [r4, #24]
 c05aee8:	4798      	blx	r3
 c05aeea:	b240      	sxtb	r0, r0
}
 c05aeec:	bd10      	pop	{r4, pc}
    return STSAFEA_BUS_ERR;
 c05aeee:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 c05aef2:	e7fb      	b.n	c05aeec <StSafeA_HW_Init+0x3c>
 c05aef4:	30031d4c 	.word	0x30031d4c

0c05aef8 <UsefulOutBuf_Init>:
 Public function -- see UsefulBuf.h

 Code Reviewers: THIS FUNCTION DOES POINTER MATH
 */
void UsefulOutBuf_Init(UsefulOutBuf *pMe, UsefulBuf Storage)
{
 c05aef8:	b082      	sub	sp, #8
 c05aefa:	4603      	mov	r3, r0
 c05aefc:	4668      	mov	r0, sp
 c05aefe:	e880 0006 	stmia.w	r0, {r1, r2}
    pMe->magic  = USEFUL_OUT_BUF_MAGIC;
 c05af02:	f640 310f 	movw	r1, #2831	@ 0xb0f
 c05af06:	8199      	strh	r1, [r3, #12]



static inline void UsefulOutBuf_Reset(UsefulOutBuf *pMe)
{
   pMe->data_len = 0;
 c05af08:	2100      	movs	r1, #0
 c05af0a:	6099      	str	r1, [r3, #8]
   pMe->err      = 0;
 c05af0c:	7399      	strb	r1, [r3, #14]
    UsefulOutBuf_Reset(pMe);
    pMe->UB     = Storage;
 c05af0e:	c803      	ldmia	r0, {r0, r1}
 c05af10:	e883 0005 	stmia.w	r3, {r0, r2}
    // based off of pStorage in the rest of this code.
    const uintptr_t ptrM = UINTPTR_MAX - Storage.len;
    if(Storage.ptr && (uintptr_t)Storage.ptr > ptrM) // Check #0
        me->err = 1;
#endif
}
 c05af14:	b002      	add	sp, #8
 c05af16:	4770      	bx	lr

0c05af18 <UsefulOutBuf_InsertUsefulBuf>:

 4. Put the new data in at the insertion position.

 */
void UsefulOutBuf_InsertUsefulBuf(UsefulOutBuf *pMe, UsefulBufC NewData, size_t uInsertionPos)
{
 c05af18:	b573      	push	{r0, r1, r4, r5, r6, lr}
 c05af1a:	4604      	mov	r4, r0
 c05af1c:	461d      	mov	r5, r3
   if(pMe->err) {
 c05af1e:	7ba3      	ldrb	r3, [r4, #14]
{
 c05af20:	a802      	add	r0, sp, #8
 c05af22:	e900 0006 	stmdb	r0, {r1, r2}
   if(pMe->err) {
 c05af26:	b93b      	cbnz	r3, c05af38 <UsefulOutBuf_InsertUsefulBuf+0x20>
   /* 0. Sanity check the UsefulOutBuf structure */
   // A "counter measure". If magic number is not the right number it
   // probably means me was not initialized or it was corrupted. Attackers
   // can defeat this, but it is a hurdle and does good with very
   // little code.
   if(pMe->magic != USEFUL_OUT_BUF_MAGIC) {
 c05af28:	f640 330f 	movw	r3, #2831	@ 0xb0f
 c05af2c:	4616      	mov	r6, r2
 c05af2e:	89a2      	ldrh	r2, [r4, #12]
 c05af30:	429a      	cmp	r2, r3
 c05af32:	d003      	beq.n	c05af3c <UsefulOutBuf_InsertUsefulBuf+0x24>
      pMe->err = 1;
 c05af34:	2301      	movs	r3, #1
 c05af36:	73a3      	strb	r3, [r4, #14]
   if(pMe->UB.ptr) {
      // To know memmove won't go off end of destination, see PtrMath #6
      memmove(pInsertionPoint, NewData.ptr, NewData.len);
   }
   pMe->data_len += NewData.len;
}
 c05af38:	b002      	add	sp, #8
 c05af3a:	bd70      	pop	{r4, r5, r6, pc}
   if(pMe->data_len > pMe->UB.len) {  // Check #1
 c05af3c:	e9d4 3201 	ldrd	r3, r2, [r4, #4]
 c05af40:	429a      	cmp	r2, r3
 c05af42:	d8f7      	bhi.n	c05af34 <UsefulOutBuf_InsertUsefulBuf+0x1c>
}


static inline size_t UsefulOutBuf_RoomLeft(UsefulOutBuf *pMe)
{
   return pMe->UB.len - pMe->data_len;
 c05af44:	1a9b      	subs	r3, r3, r2
   if(! UsefulOutBuf_WillItFit(pMe, NewData.len)) { // Check #2
 c05af46:	42b3      	cmp	r3, r6
 c05af48:	d3f4      	bcc.n	c05af34 <UsefulOutBuf_InsertUsefulBuf+0x1c>
   if(uInsertionPos > pMe->data_len) { // Check #3
 c05af4a:	42aa      	cmp	r2, r5
 c05af4c:	d3f2      	bcc.n	c05af34 <UsefulOutBuf_InsertUsefulBuf+0x1c>
   if(uNumBytesToMove && pMe->UB.ptr) {
 c05af4e:	1b52      	subs	r2, r2, r5
 c05af50:	d005      	beq.n	c05af5e <UsefulOutBuf_InsertUsefulBuf+0x46>
   uint8_t *pSourceOfMove       = ((uint8_t *)pMe->UB.ptr) + uInsertionPos; // PtrMath #1
 c05af52:	6821      	ldr	r1, [r4, #0]
   if(uNumBytesToMove && pMe->UB.ptr) {
 c05af54:	b119      	cbz	r1, c05af5e <UsefulOutBuf_InsertUsefulBuf+0x46>
   uint8_t *pSourceOfMove       = ((uint8_t *)pMe->UB.ptr) + uInsertionPos; // PtrMath #1
 c05af56:	4429      	add	r1, r5
      memmove(pDestinationOfMove, pSourceOfMove, uNumBytesToMove);
 c05af58:	1988      	adds	r0, r1, r6
 c05af5a:	f000 fba8 	bl	c05b6ae <memmove>
   uint8_t *pInsertionPoint = ((uint8_t *)pMe->UB.ptr) + uInsertionPos; // PtrMath #5
 c05af5e:	6820      	ldr	r0, [r4, #0]
   if(pMe->UB.ptr) {
 c05af60:	b120      	cbz	r0, c05af6c <UsefulOutBuf_InsertUsefulBuf+0x54>
      memmove(pInsertionPoint, NewData.ptr, NewData.len);
 c05af62:	4632      	mov	r2, r6
 c05af64:	9900      	ldr	r1, [sp, #0]
 c05af66:	4428      	add	r0, r5
 c05af68:	f000 fba1 	bl	c05b6ae <memmove>
   pMe->data_len += NewData.len;
 c05af6c:	68a3      	ldr	r3, [r4, #8]
 c05af6e:	4433      	add	r3, r6
 c05af70:	60a3      	str	r3, [r4, #8]
 c05af72:	e7e1      	b.n	c05af38 <UsefulOutBuf_InsertUsefulBuf+0x20>

0c05af74 <UsefulOutBuf_OutUBuf>:
/*
 Public function -- see UsefulBuf.h
 */
UsefulBufC UsefulOutBuf_OutUBuf(UsefulOutBuf *pMe)
{
   if(pMe->err) {
 c05af74:	7b8b      	ldrb	r3, [r1, #14]
 c05af76:	b123      	cbz	r3, c05af82 <UsefulOutBuf_OutUBuf+0xe>
{
 c05af78:	2300      	movs	r3, #0
 c05af7a:	461a      	mov	r2, r3
      return NULLUsefulBufC;
 c05af7c:	e9c0 3200 	strd	r3, r2, [r0]
      pMe->err = 1;
      return NULLUsefulBufC;
   }

   return (UsefulBufC){pMe->UB.ptr, pMe->data_len};
}
 c05af80:	4770      	bx	lr
   if(pMe->magic != USEFUL_OUT_BUF_MAGIC) {
 c05af82:	f640 330f 	movw	r3, #2831	@ 0xb0f
 c05af86:	898a      	ldrh	r2, [r1, #12]
 c05af88:	429a      	cmp	r2, r3
 c05af8a:	d002      	beq.n	c05af92 <UsefulOutBuf_OutUBuf+0x1e>
      pMe->err = 1;
 c05af8c:	2301      	movs	r3, #1
 c05af8e:	738b      	strb	r3, [r1, #14]
      return NULLUsefulBufC;
 c05af90:	e7f2      	b.n	c05af78 <UsefulOutBuf_OutUBuf+0x4>
   return (UsefulBufC){pMe->UB.ptr, pMe->data_len};
 c05af92:	680b      	ldr	r3, [r1, #0]
 c05af94:	688a      	ldr	r2, [r1, #8]
 c05af96:	e7f1      	b.n	c05af7c <UsefulOutBuf_OutUBuf+0x8>

0c05af98 <attest_register_initial_attestation_key>:
static uint8_t instance_id_buf[INSTANCE_ID_MAX_SIZE];
static size_t instance_id_len = 0U;

enum psa_attest_err_t
attest_register_initial_attestation_key()
{
 c05af98:	b530      	push	{r4, r5, lr}
    psa_status_t crypto_res;
    psa_key_attributes_t key_attributes = psa_key_attributes_init();
#ifdef PSA_USE_SE_ST

    if (attestation_key_handle != ATTEST_KEY_HANDLE_NOT_LOADED) {
 c05af9a:	4d18      	ldr	r5, [pc, #96]	@ (c05affc <attest_register_initial_attestation_key+0x64>)
{
 c05af9c:	b087      	sub	sp, #28
    return( v );
 c05af9e:	2218      	movs	r2, #24
 c05afa0:	2100      	movs	r1, #0
 c05afa2:	4668      	mov	r0, sp
 c05afa4:	f000 fbc3 	bl	c05b72e <memset>
    if (attestation_key_handle != ATTEST_KEY_HANDLE_NOT_LOADED) {
 c05afa8:	682c      	ldr	r4, [r5, #0]
 c05afaa:	b934      	cbnz	r4, c05afba <attest_register_initial_attestation_key+0x22>
        return PSA_ATTEST_ERR_GENERAL;
    }

    crypto_res = psa_open_key(SE_ST_ID_TO_PSA_ID(SE_ST_PRIV_SLOT_0), &attestation_key_handle);
 c05afac:	4629      	mov	r1, r5
 c05afae:	f04f 4080 	mov.w	r0, #1073741824	@ 0x40000000
 c05afb2:	f7e1 f825 	bl	c03c000 <psa_open_key>
    if (crypto_res != PSA_SUCCESS) {
 c05afb6:	b110      	cbz	r0, c05afbe <attest_register_initial_attestation_key+0x26>
        attestation_key_handle = ATTEST_KEY_HANDLE_NOT_LOADED;
 c05afb8:	602c      	str	r4, [r5, #0]
        return PSA_ATTEST_ERR_GENERAL;
 c05afba:	2405      	movs	r4, #5
 c05afbc:	e01a      	b.n	c05aff4 <attest_register_initial_attestation_key+0x5c>
        return PSA_ATTEST_ERR_GENERAL;
    }
    crypto_res = psa_get_key_attributes(SE_ST_ID_TO_PSA_ID(SE_ST_PRIV_SLOT_0),&key_attributes);
 c05afbe:	4669      	mov	r1, sp
 c05afc0:	f04f 4080 	mov.w	r0, #1073741824	@ 0x40000000
 c05afc4:	f7e1 f896 	bl	c03c0f4 <psa_get_key_attributes>
    if (crypto_res != PSA_SUCCESS) {
 c05afc8:	2800      	cmp	r0, #0
 c05afca:	d1f6      	bne.n	c05afba <attest_register_initial_attestation_key+0x22>
    return( attributes->type );
 c05afcc:	f8bd 3014 	ldrh.w	r3, [sp, #20]
        return PSA_ATTEST_ERR_GENERAL;
    }
    attestation_key_curve = PSA_KEY_TYPE_ECC_GET_FAMILY(psa_get_key_type(&key_attributes));
 c05afd0:	f403 424f 	and.w	r2, r3, #52992	@ 0xcf00
 c05afd4:	f5b2 4f82 	cmp.w	r2, #16640	@ 0x4100
 c05afd8:	bf18      	it	ne
 c05afda:	2300      	movne	r3, #0
 c05afdc:	4a08      	ldr	r2, [pc, #32]	@ (c05b000 <attest_register_initial_attestation_key+0x68>)
 c05afde:	7013      	strb	r3, [r2, #0]
    attestation_key_handle = key_handle;
    attestation_key_curve = psa_curve;
#endif

    /* If the public key length is 0 then it hasn't been loaded */
    if (attestation_public_key_len == 0) {
 c05afe0:	4b08      	ldr	r3, [pc, #32]	@ (c05b004 <attest_register_initial_attestation_key+0x6c>)
 c05afe2:	681a      	ldr	r2, [r3, #0]
 c05afe4:	b932      	cbnz	r2, c05aff4 <attest_register_initial_attestation_key+0x5c>
        crypto_res = psa_export_public_key(attestation_key_handle, attestation_public_key,
 c05afe6:	2241      	movs	r2, #65	@ 0x41
 c05afe8:	4907      	ldr	r1, [pc, #28]	@ (c05b008 <attest_register_initial_attestation_key+0x70>)
 c05afea:	6828      	ldr	r0, [r5, #0]
 c05afec:	f7e1 f8d9 	bl	c03c1a2 <psa_export_public_key>
                                           ECC_P256_PUBLIC_KEY_SIZE,
                                           &attestation_public_key_len);
        if (crypto_res != PSA_SUCCESS) {
 c05aff0:	2800      	cmp	r0, #0
 c05aff2:	d1e2      	bne.n	c05afba <attest_register_initial_attestation_key+0x22>
            return PSA_ATTEST_ERR_GENERAL;
        }
    }

    return PSA_ATTEST_ERR_SUCCESS;
}
 c05aff4:	4620      	mov	r0, r4
 c05aff6:	b007      	add	sp, #28
 c05aff8:	bd30      	pop	{r4, r5, pc}
 c05affa:	bf00      	nop
 c05affc:	30031de0 	.word	0x30031de0
 c05b000:	30031d95 	.word	0x30031d95
 c05b004:	30031d98 	.word	0x30031d98
 c05b008:	30031d9c 	.word	0x30031d9c

0c05b00c <attest_unregister_initial_attestation_key>:

enum psa_attest_err_t
attest_unregister_initial_attestation_key()
{
 c05b00c:	b510      	push	{r4, lr}
    psa_status_t crypto_res;

    if (attestation_key_handle == ATTEST_KEY_HANDLE_NOT_LOADED) {
 c05b00e:	4c05      	ldr	r4, [pc, #20]	@ (c05b024 <attest_unregister_initial_attestation_key+0x18>)
 c05b010:	6820      	ldr	r0, [r4, #0]
 c05b012:	b908      	cbnz	r0, c05b018 <attest_unregister_initial_attestation_key+0xc>
        return PSA_ATTEST_ERR_GENERAL;
 c05b014:	2005      	movs	r0, #5
    }
#endif
    attestation_key_handle = ATTEST_KEY_HANDLE_NOT_LOADED;

    return PSA_ATTEST_ERR_SUCCESS;
}
 c05b016:	bd10      	pop	{r4, pc}
    crypto_res = psa_close_key(attestation_key_handle);
 c05b018:	f7e1 f820 	bl	c03c05c <psa_close_key>
    if (crypto_res != PSA_SUCCESS) {
 c05b01c:	2800      	cmp	r0, #0
 c05b01e:	d1f9      	bne.n	c05b014 <attest_unregister_initial_attestation_key+0x8>
    attestation_key_handle = ATTEST_KEY_HANDLE_NOT_LOADED;
 c05b020:	6020      	str	r0, [r4, #0]
    return PSA_ATTEST_ERR_SUCCESS;
 c05b022:	e7f8      	b.n	c05b016 <attest_unregister_initial_attestation_key+0xa>
 c05b024:	30031de0 	.word	0x30031de0

0c05b028 <attest_get_signing_key_handle>:

enum psa_attest_err_t
attest_get_signing_key_handle(psa_key_handle_t *handle)
{
    if (attestation_key_handle == ATTEST_KEY_HANDLE_NOT_LOADED) {
 c05b028:	4b03      	ldr	r3, [pc, #12]	@ (c05b038 <attest_get_signing_key_handle+0x10>)
 c05b02a:	681b      	ldr	r3, [r3, #0]
 c05b02c:	b113      	cbz	r3, c05b034 <attest_get_signing_key_handle+0xc>
        return PSA_ATTEST_ERR_GENERAL;
    }

    *handle = attestation_key_handle;
 c05b02e:	6003      	str	r3, [r0, #0]

    return PSA_ATTEST_ERR_SUCCESS;
 c05b030:	2000      	movs	r0, #0
 c05b032:	4770      	bx	lr
        return PSA_ATTEST_ERR_GENERAL;
 c05b034:	2005      	movs	r0, #5
}
 c05b036:	4770      	bx	lr
 c05b038:	30031de0 	.word	0x30031de0

0c05b03c <attest_get_initial_attestation_public_key>:
                                          size_t *public_key_len,
                                          psa_ecc_family_t *public_key_curve)
{

    /* If the public key length is 0 then it hasn't been loaded */
    if (attestation_public_key_len == 0) {
 c05b03c:	4b06      	ldr	r3, [pc, #24]	@ (c05b058 <attest_get_initial_attestation_public_key+0x1c>)
{
 c05b03e:	b510      	push	{r4, lr}
    if (attestation_public_key_len == 0) {
 c05b040:	681b      	ldr	r3, [r3, #0]
 c05b042:	b13b      	cbz	r3, c05b054 <attest_get_initial_attestation_public_key+0x18>
        return PSA_ATTEST_ERR_GENERAL;
    }

    *public_key       = attestation_public_key;
 c05b044:	4c05      	ldr	r4, [pc, #20]	@ (c05b05c <attest_get_initial_attestation_public_key+0x20>)
 c05b046:	6004      	str	r4, [r0, #0]
    *public_key_len   = attestation_public_key_len;
    *public_key_curve = attestation_key_curve;

    return PSA_ATTEST_ERR_SUCCESS;
 c05b048:	2000      	movs	r0, #0
    *public_key_len   = attestation_public_key_len;
 c05b04a:	600b      	str	r3, [r1, #0]
    *public_key_curve = attestation_key_curve;
 c05b04c:	4b04      	ldr	r3, [pc, #16]	@ (c05b060 <attest_get_initial_attestation_public_key+0x24>)
 c05b04e:	781b      	ldrb	r3, [r3, #0]
 c05b050:	7013      	strb	r3, [r2, #0]
}
 c05b052:	bd10      	pop	{r4, pc}
        return PSA_ATTEST_ERR_GENERAL;
 c05b054:	2005      	movs	r0, #5
 c05b056:	e7fc      	b.n	c05b052 <attest_get_initial_attestation_public_key+0x16>
 c05b058:	30031d98 	.word	0x30031d98
 c05b05c:	30031d9c 	.word	0x30031d9c
 c05b060:	30031d95 	.word	0x30031d95

0c05b064 <attest_get_instance_id>:
    return PSA_ATTEST_ERR_SUCCESS;
}

enum psa_attest_err_t
attest_get_instance_id(struct q_useful_buf_c *id_buf)
{
 c05b064:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    if (instance_id_len == 0U) {
 c05b066:	4d1a      	ldr	r5, [pc, #104]	@ (c05b0d0 <attest_get_instance_id+0x6c>)
{
 c05b068:	4604      	mov	r4, r0
    if (instance_id_len == 0U) {
 c05b06a:	682b      	ldr	r3, [r5, #0]
 c05b06c:	bb33      	cbnz	r3, c05b0bc <attest_get_instance_id+0x58>
    attest_res = attest_get_initial_attestation_public_key(&public_key,
 c05b06e:	f10d 0203 	add.w	r2, sp, #3
 c05b072:	a902      	add	r1, sp, #8
 c05b074:	a801      	add	r0, sp, #4
    psa_hash_operation_t hash = psa_hash_operation_init();
 c05b076:	9303      	str	r3, [sp, #12]
    attest_res = attest_get_initial_attestation_public_key(&public_key,
 c05b078:	f7ff ffe0 	bl	c05b03c <attest_get_initial_attestation_public_key>
    if (attest_res != PSA_ATTEST_ERR_SUCCESS) {
 c05b07c:	b110      	cbz	r0, c05b084 <attest_get_instance_id+0x20>
        if (attest_calc_instance_id() != PSA_ATTEST_ERR_SUCCESS) {
            return PSA_ATTEST_ERR_CLAIM_UNAVAILABLE;
 c05b07e:	2003      	movs	r0, #3

    id_buf->ptr = instance_id_buf;
    id_buf->len = instance_id_len;

    return PSA_ATTEST_ERR_SUCCESS;
}
 c05b080:	b004      	add	sp, #16
 c05b082:	bd70      	pop	{r4, r5, r6, pc}
    crypto_res = psa_hash_setup(&hash, PSA_ALG_SHA_256);
 c05b084:	4913      	ldr	r1, [pc, #76]	@ (c05b0d4 <attest_get_instance_id+0x70>)
 c05b086:	a803      	add	r0, sp, #12
 c05b088:	f7e1 f8b9 	bl	c03c1fe <psa_hash_setup>
    if (crypto_res != PSA_SUCCESS) {
 c05b08c:	2800      	cmp	r0, #0
 c05b08e:	d1f6      	bne.n	c05b07e <attest_get_instance_id+0x1a>
    crypto_res = psa_hash_update(&hash, public_key, key_len);
 c05b090:	e9dd 1201 	ldrd	r1, r2, [sp, #4]
 c05b094:	a803      	add	r0, sp, #12
 c05b096:	f7e1 f8df 	bl	c03c258 <psa_hash_update>
    if (crypto_res != PSA_SUCCESS) {
 c05b09a:	2800      	cmp	r0, #0
 c05b09c:	d1ef      	bne.n	c05b07e <attest_get_instance_id+0x1a>
    crypto_res = psa_hash_finish(&hash, instance_id_buf + 1,
 c05b09e:	4e0e      	ldr	r6, [pc, #56]	@ (c05b0d8 <attest_get_instance_id+0x74>)
 c05b0a0:	462b      	mov	r3, r5
 c05b0a2:	2220      	movs	r2, #32
 c05b0a4:	4631      	mov	r1, r6
 c05b0a6:	a803      	add	r0, sp, #12
 c05b0a8:	f7e1 f907 	bl	c03c2ba <psa_hash_finish>
    if (crypto_res != PSA_SUCCESS) {
 c05b0ac:	2800      	cmp	r0, #0
 c05b0ae:	d1e6      	bne.n	c05b07e <attest_get_instance_id+0x1a>
    instance_id_buf[0] = 0x01;
 c05b0b0:	2301      	movs	r3, #1
 c05b0b2:	f806 3c01 	strb.w	r3, [r6, #-1]
    instance_id_len = instance_id_len + 1;
 c05b0b6:	682b      	ldr	r3, [r5, #0]
 c05b0b8:	3301      	adds	r3, #1
 c05b0ba:	602b      	str	r3, [r5, #0]
    if (id_buf == NULL) {
 c05b0bc:	b12c      	cbz	r4, c05b0ca <attest_get_instance_id+0x66>
    id_buf->ptr = instance_id_buf;
 c05b0be:	4b07      	ldr	r3, [pc, #28]	@ (c05b0dc <attest_get_instance_id+0x78>)
    return PSA_ATTEST_ERR_SUCCESS;
 c05b0c0:	2000      	movs	r0, #0
    id_buf->ptr = instance_id_buf;
 c05b0c2:	6023      	str	r3, [r4, #0]
    id_buf->len = instance_id_len;
 c05b0c4:	682b      	ldr	r3, [r5, #0]
 c05b0c6:	6063      	str	r3, [r4, #4]
    return PSA_ATTEST_ERR_SUCCESS;
 c05b0c8:	e7da      	b.n	c05b080 <attest_get_instance_id+0x1c>
        return PSA_ATTEST_ERR_GENERAL;
 c05b0ca:	2005      	movs	r0, #5
 c05b0cc:	e7d8      	b.n	c05b080 <attest_get_instance_id+0x1c>
 c05b0ce:	bf00      	nop
 c05b0d0:	30031d70 	.word	0x30031d70
 c05b0d4:	02000009 	.word	0x02000009
 c05b0d8:	30031d75 	.word	0x30031d75
 c05b0dc:	30031d74 	.word	0x30031d74

0c05b0e0 <attest_get_tlv_by_id.constprop.0>:
    uint8_t tlv_id;
    uint8_t module = SW_GENERAL;
    int32_t found;

    /* Ensure that look up starting from the beginning of the boot status */
    *tlv_ptr = NULL;
 c05b0e0:	2300      	movs	r3, #0
    if (boot_data.header.tlv_magic != SHARED_DATA_TLV_INFO_MAGIC) {
 c05b0e2:	f242 0c16 	movw	ip, #8214	@ 0x2016
static int32_t attest_get_tlv_by_id(uint8_t    claim,
 c05b0e6:	b5f0      	push	{r4, r5, r6, r7, lr}
    if (boot_data.header.tlv_magic != SHARED_DATA_TLV_INFO_MAGIC) {
 c05b0e8:	4e13      	ldr	r6, [pc, #76]	@ (c05b138 <attest_get_tlv_by_id.constprop.0+0x58>)
    *tlv_ptr = NULL;
 c05b0ea:	6013      	str	r3, [r2, #0]
    if (boot_data.header.tlv_magic != SHARED_DATA_TLV_INFO_MAGIC) {
 c05b0ec:	8833      	ldrh	r3, [r6, #0]
 c05b0ee:	4563      	cmp	r3, ip
 c05b0f0:	d11f      	bne.n	c05b132 <attest_get_tlv_by_id.constprop.0+0x52>
    tlv_end = (uint8_t *)&boot_data + boot_data.header.tlv_tot_len;
 c05b0f2:	8875      	ldrh	r5, [r6, #2]
    if (*tlv_ptr == NULL) {
 c05b0f4:	6813      	ldr	r3, [r2, #0]
    tlv_end = (uint8_t *)&boot_data + boot_data.header.tlv_tot_len;
 c05b0f6:	4435      	add	r5, r6
    if (*tlv_ptr == NULL) {
 c05b0f8:	b11b      	cbz	r3, c05b102 <attest_get_tlv_by_id.constprop.0+0x22>
                    + tlv_entry.tlv_len;
 c05b0fa:	885c      	ldrh	r4, [r3, #2]
 c05b0fc:	3404      	adds	r4, #4
        tlv_curr += (SHARED_DATA_ENTRY_HEADER_SIZE + tlv_entry.tlv_len);
 c05b0fe:	4423      	add	r3, r4
 c05b100:	e000      	b.n	c05b104 <attest_get_tlv_by_id.constprop.0+0x24>
        tlv_curr = boot_data.data;
 c05b102:	4b0e      	ldr	r3, [pc, #56]	@ (c05b13c <attest_get_tlv_by_id.constprop.0+0x5c>)
    while (tlv_curr < tlv_end) {
 c05b104:	429d      	cmp	r5, r3
 c05b106:	d801      	bhi.n	c05b10c <attest_get_tlv_by_id.constprop.0+0x2c>
 c05b108:	2000      	movs	r0, #0
            break;
        }
    } while (found == 1);

    return found;
}
 c05b10a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 c05b10c:	681c      	ldr	r4, [r3, #0]
        if (GET_IAS_MODULE(tlv_entry.tlv_type) == module) {
 c05b10e:	f414 6f7c 	tst.w	r4, #4032	@ 0xfc0
 c05b112:	f3c4 4e0f 	ubfx	lr, r4, #16, #16
 c05b116:	ea4f 4714 	mov.w	r7, r4, lsr #16
 c05b11a:	d108      	bne.n	c05b12e <attest_get_tlv_by_id.constprop.0+0x4e>
        if (claim == tlv_id) {
 c05b11c:	f004 043f 	and.w	r4, r4, #63	@ 0x3f
 c05b120:	42a0      	cmp	r0, r4
            *tlv_ptr = tlv_curr;
 c05b122:	6013      	str	r3, [r2, #0]
            *tlv_len = tlv_entry.tlv_len;
 c05b124:	f8a1 e000 	strh.w	lr, [r1]
        if (claim == tlv_id) {
 c05b128:	d1e0      	bne.n	c05b0ec <attest_get_tlv_by_id.constprop.0+0xc>
        found = attest_get_tlv_by_module(module, &tlv_id,
 c05b12a:	2001      	movs	r0, #1
    return found;
 c05b12c:	e7ed      	b.n	c05b10a <attest_get_tlv_by_id.constprop.0+0x2a>
        tlv_curr += (SHARED_DATA_ENTRY_HEADER_SIZE + tlv_entry.tlv_len);
 c05b12e:	1d3c      	adds	r4, r7, #4
 c05b130:	e7e5      	b.n	c05b0fe <attest_get_tlv_by_id.constprop.0+0x1e>
        return -1;
 c05b132:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 c05b136:	e7e8      	b.n	c05b10a <attest_get_tlv_by_id.constprop.0+0x2a>
 c05b138:	30031de4 	.word	0x30031de4
 c05b13c:	30031de8 	.word	0x30031de8

0c05b140 <attest_create_token>:
 */
static enum psa_attest_err_t
attest_create_token(struct q_useful_buf_c *challenge,
                    struct q_useful_buf   *token,
                    struct q_useful_buf_c *completed_token)
{
 c05b140:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c05b144:	b0cd      	sub	sp, #308	@ 0x134
 c05b146:	4605      	mov	r5, r0
 c05b148:	460e      	mov	r6, r1
 c05b14a:	9203      	str	r2, [sp, #12]
    enum attest_token_err_t token_err;
    struct attest_token_encode_ctx attest_token_ctx;
    int32_t key_select = 0;
    uint32_t option_flags = 0;

    attest_err = attest_register_initial_attestation_key();
 c05b14c:	f7ff ff24 	bl	c05af98 <attest_register_initial_attestation_key>
    if (attest_err != PSA_ATTEST_ERR_SUCCESS) {
 c05b150:	4604      	mov	r4, r0
 c05b152:	b968      	cbnz	r0, c05b170 <attest_create_token+0x30>
#endif

    /* Get started creating the token. This sets up the CBOR and COSE contexts
     * which causes the COSE headers to be constructed.
     */
    token_err = attest_token_encode_start(&attest_token_ctx,
 c05b154:	4602      	mov	r2, r0
 c05b156:	4601      	mov	r1, r0
 c05b158:	f06f 0306 	mvn.w	r3, #6
 c05b15c:	9600      	str	r6, [sp, #0]
 c05b15e:	a812      	add	r0, sp, #72	@ 0x48
 c05b160:	f000 f9c6 	bl	c05b4f0 <attest_token_encode_start>
                                          option_flags,     /* option_flags */
                                          key_select,       /* key_select   */
                                          T_COSE_ALGORITHM, /* alg_select   */
                                          token);

    if (token_err != ATTEST_TOKEN_ERR_SUCCESS) {
 c05b164:	4604      	mov	r4, r0
 c05b166:	b130      	cbz	r0, c05b176 <attest_create_token+0x36>
    switch (token_err) {
 c05b168:	2801      	cmp	r0, #1
 c05b16a:	f040 80c7 	bne.w	c05b2fc <attest_create_token+0x1bc>
        return PSA_ATTEST_ERR_BUFFER_OVERFLOW;
 c05b16e:	2402      	movs	r4, #2
        /* We got here normally and therefore care about error codes. */
        attest_err = attest_unregister_initial_attestation_key();
    }
    else {
        /* Error handler: just remove they key and preserve error. */
        (void)attest_unregister_initial_attestation_key();
 c05b170:	f7ff ff4c 	bl	c05b00c <attest_unregister_initial_attestation_key>
    }
    return attest_err;
 c05b174:	e0fe      	b.n	c05b374 <attest_create_token+0x234>
    attest_token_encode_add_bstr(token_ctx,
 c05b176:	462a      	mov	r2, r5
 c05b178:	4981      	ldr	r1, [pc, #516]	@ (c05b380 <attest_create_token+0x240>)
 c05b17a:	a812      	add	r0, sp, #72	@ 0x48
 c05b17c:	f000 fa2e 	bl	c05b5dc <attest_token_encode_add_bstr>
    found = attest_get_tlv_by_id(BOOT_SEED, &tlv_len, &tlv_ptr);
 c05b180:	4620      	mov	r0, r4
 c05b182:	aa07      	add	r2, sp, #28
 c05b184:	a906      	add	r1, sp, #24
    struct q_useful_buf_c claim_value = {0};
 c05b186:	e9cd 4408 	strd	r4, r4, [sp, #32]
    uint8_t *tlv_ptr = NULL;
 c05b18a:	9407      	str	r4, [sp, #28]
    found = attest_get_tlv_by_id(BOOT_SEED, &tlv_len, &tlv_ptr);
 c05b18c:	f7ff ffa8 	bl	c05b0e0 <attest_get_tlv_by_id.constprop.0>
    if (found == 1) {
 c05b190:	2801      	cmp	r0, #1
 c05b192:	ad0a      	add	r5, sp, #40	@ 0x28
 c05b194:	f040 80a4 	bne.w	c05b2e0 <attest_create_token+0x1a0>
        claim_value.ptr = tlv_ptr + SHARED_DATA_ENTRY_HEADER_SIZE;
 c05b198:	9b07      	ldr	r3, [sp, #28]
 c05b19a:	3304      	adds	r3, #4
 c05b19c:	9308      	str	r3, [sp, #32]
        claim_value.len = tlv_len;
 c05b19e:	f8bd 3018 	ldrh.w	r3, [sp, #24]
    attest_token_encode_add_bstr(token_ctx,
 c05b1a2:	4978      	ldr	r1, [pc, #480]	@ (c05b384 <attest_create_token+0x244>)
 c05b1a4:	aa08      	add	r2, sp, #32
 c05b1a6:	a812      	add	r0, sp, #72	@ 0x48
        claim_value.len = tlv_len;
 c05b1a8:	9309      	str	r3, [sp, #36]	@ 0x24
    attest_token_encode_add_bstr(token_ctx,
 c05b1aa:	f000 fa17 	bl	c05b5dc <attest_token_encode_add_bstr>
    err = attest_get_instance_id(&claim_value);
 c05b1ae:	4628      	mov	r0, r5
 c05b1b0:	f7ff ff58 	bl	c05b064 <attest_get_instance_id>
    if (err != PSA_ATTEST_ERR_SUCCESS) {
 c05b1b4:	4604      	mov	r4, r0
 c05b1b6:	2800      	cmp	r0, #0
 c05b1b8:	d1da      	bne.n	c05b170 <attest_create_token+0x30>
    attest_token_encode_add_bstr(token_ctx,
 c05b1ba:	4973      	ldr	r1, [pc, #460]	@ (c05b388 <attest_create_token+0x248>)
 c05b1bc:	a812      	add	r0, sp, #72	@ 0x48
 c05b1be:	462a      	mov	r2, r5
 c05b1c0:	f000 fa0c 	bl	c05b5dc <attest_token_encode_add_bstr>
    uint32_t size = sizeof(implementation_id);
 c05b1c4:	2320      	movs	r3, #32
    res_plat = tfm_plat_get_implementation_id(&size, implementation_id);
 c05b1c6:	4629      	mov	r1, r5
 c05b1c8:	a807      	add	r0, sp, #28
    uint32_t size = sizeof(implementation_id);
 c05b1ca:	9307      	str	r3, [sp, #28]
    res_plat = tfm_plat_get_implementation_id(&size, implementation_id);
 c05b1cc:	f7f1 f82b 	bl	c04c226 <tfm_plat_get_implementation_id>
    if (res_plat != TFM_PLAT_ERR_SUCCESS) {
 c05b1d0:	2800      	cmp	r0, #0
 c05b1d2:	f040 80d3 	bne.w	c05b37c <attest_create_token+0x23c>
    claim_value.len  = size;
 c05b1d6:	9b07      	ldr	r3, [sp, #28]
    attest_token_encode_add_bstr(token_ctx,
 c05b1d8:	496c      	ldr	r1, [pc, #432]	@ (c05b38c <attest_create_token+0x24c>)
 c05b1da:	aa08      	add	r2, sp, #32
 c05b1dc:	a812      	add	r0, sp, #72	@ 0x48
    claim_value.len  = size;
 c05b1de:	9309      	str	r3, [sp, #36]	@ 0x24
    claim_value.ptr = implementation_id;
 c05b1e0:	9508      	str	r5, [sp, #32]
    attest_token_encode_add_bstr(token_ctx,
 c05b1e2:	f000 f9fb 	bl	c05b5dc <attest_token_encode_add_bstr>
    res = attest_get_caller_client_id(&caller_id);
 c05b1e6:	4628      	mov	r0, r5
 c05b1e8:	f002 f96c 	bl	c05d4c4 <attest_get_caller_client_id>
    if (res != PSA_ATTEST_ERR_SUCCESS) {
 c05b1ec:	4604      	mov	r4, r0
 c05b1ee:	2800      	cmp	r0, #0
 c05b1f0:	d1be      	bne.n	c05b170 <attest_create_token+0x30>
    attest_token_encode_add_integer(token_ctx,
 c05b1f2:	682a      	ldr	r2, [r5, #0]
 c05b1f4:	4966      	ldr	r1, [pc, #408]	@ (c05b390 <attest_create_token+0x250>)
 c05b1f6:	17d3      	asrs	r3, r2, #31
 c05b1f8:	a812      	add	r0, sp, #72	@ 0x48
 c05b1fa:	f000 f9e0 	bl	c05b5be <attest_token_encode_add_integer>
    found = attest_get_tlv_by_id(SECURITY_LIFECYCLE, &tlv_len, &tlv_ptr);
 c05b1fe:	462a      	mov	r2, r5
 c05b200:	2002      	movs	r0, #2
    uint8_t *tlv_ptr = NULL;
 c05b202:	602c      	str	r4, [r5, #0]
    found = attest_get_tlv_by_id(SECURITY_LIFECYCLE, &tlv_len, &tlv_ptr);
 c05b204:	a908      	add	r1, sp, #32
 c05b206:	f7ff ff6b 	bl	c05b0e0 <attest_get_tlv_by_id.constprop.0>
    if (found == 1) {
 c05b20a:	2801      	cmp	r0, #1
 c05b20c:	d17a      	bne.n	c05b304 <attest_create_token+0x1c4>
        claim_value.len = tlv_len;
 c05b20e:	f8bd 2020 	ldrh.w	r2, [sp, #32]
        claim_value.ptr = tlv_ptr + SHARED_DATA_ENTRY_HEADER_SIZE;
 c05b212:	682b      	ldr	r3, [r5, #0]
    switch (len) {
 c05b214:	2a02      	cmp	r2, #2
 c05b216:	d06c      	beq.n	c05b2f2 <attest_create_token+0x1b2>
 c05b218:	2a04      	cmp	r2, #4
 c05b21a:	d071      	beq.n	c05b300 <attest_create_token+0x1c0>
 c05b21c:	2a01      	cmp	r2, #1
 c05b21e:	d16d      	bne.n	c05b2fc <attest_create_token+0x1bc>
        security_lifecycle = (enum tfm_security_lifecycle_t)slc_value;
 c05b220:	791a      	ldrb	r2, [r3, #4]
    attest_token_encode_add_integer(token_ctx,
 c05b222:	2300      	movs	r3, #0
 c05b224:	495b      	ldr	r1, [pc, #364]	@ (c05b394 <attest_create_token+0x254>)
 c05b226:	a812      	add	r0, sp, #72	@ 0x48
 c05b228:	f000 f9c9 	bl	c05b5be <attest_token_encode_add_integer>
    cbor_encode_ctx = attest_token_encode_borrow_cbor_cntxt(token_ctx);
 c05b22c:	a812      	add	r0, sp, #72	@ 0x48
 c05b22e:	f000 f9c5 	bl	c05b5bc <attest_token_encode_borrow_cbor_cntxt>
 c05b232:	f04f 0800 	mov.w	r8, #0
 c05b236:	4607      	mov	r7, r0
    if (boot_data.header.tlv_magic != SHARED_DATA_TLV_INFO_MAGIC) {
 c05b238:	f242 0a16 	movw	sl, #8214	@ 0x2016
 c05b23c:	f8df b158 	ldr.w	fp, [pc, #344]	@ c05b398 <attest_create_token+0x258>
 c05b240:	f8bb 3000 	ldrh.w	r3, [fp]
 c05b244:	4553      	cmp	r3, sl
 c05b246:	f040 8099 	bne.w	c05b37c <attest_create_token+0x23c>
    tlv_end = (uint8_t *)&boot_data + boot_data.header.tlv_tot_len;
 c05b24a:	f8bb 2002 	ldrh.w	r2, [fp, #2]
 c05b24e:	4e53      	ldr	r6, [pc, #332]	@ (c05b39c <attest_create_token+0x25c>)
 c05b250:	445a      	add	r2, fp
    while (tlv_curr < tlv_end) {
 c05b252:	42b2      	cmp	r2, r6
 c05b254:	d85a      	bhi.n	c05b30c <attest_create_token+0x1cc>
    for (module = 0; module < SW_MAX; ++module) {
 c05b256:	f108 0801 	add.w	r8, r8, #1
 c05b25a:	f1b8 0f07 	cmp.w	r8, #7
 c05b25e:	d1ef      	bne.n	c05b240 <attest_create_token+0x100>
    if (cnt != 0) {
 c05b260:	2c00      	cmp	r4, #0
 c05b262:	d075      	beq.n	c05b350 <attest_create_token+0x210>
   QCBOREncode_OpenArray(pCtx);
}

static inline void QCBOREncode_CloseArray(QCBOREncodeContext *pCtx)
{
   QCBOREncode_CloseMapOrArray(pCtx, CBOR_MAJOR_TYPE_ARRAY, NULL);
 c05b264:	2200      	movs	r2, #0
 c05b266:	2104      	movs	r1, #4
 c05b268:	4638      	mov	r0, r7
 c05b26a:	f001 f955 	bl	c05c518 <QCBOREncode_CloseMapOrArray>
    service.ptr = tfm_attest_hal_get_verification_service(&size);
 c05b26e:	a808      	add	r0, sp, #32
 c05b270:	f7f0 fe06 	bl	c04be80 <tfm_attest_hal_get_verification_service>
 c05b274:	6028      	str	r0, [r5, #0]
    if (service.ptr) {
 c05b276:	b130      	cbz	r0, c05b286 <attest_create_token+0x146>
        service.len = size;
 c05b278:	9b08      	ldr	r3, [sp, #32]
        attest_token_encode_add_tstr(token_ctx,
 c05b27a:	462a      	mov	r2, r5
 c05b27c:	4948      	ldr	r1, [pc, #288]	@ (c05b3a0 <attest_create_token+0x260>)
        service.len = size;
 c05b27e:	606b      	str	r3, [r5, #4]
        attest_token_encode_add_tstr(token_ctx,
 c05b280:	a812      	add	r0, sp, #72	@ 0x48
 c05b282:	f000 f9bf 	bl	c05b604 <attest_token_encode_add_tstr>
    profile.ptr = tfm_attest_hal_get_profile_definition(&size);
 c05b286:	a808      	add	r0, sp, #32
 c05b288:	f7f0 fe00 	bl	c04be8c <tfm_attest_hal_get_profile_definition>
 c05b28c:	6028      	str	r0, [r5, #0]
    if (profile.ptr) {
 c05b28e:	b130      	cbz	r0, c05b29e <attest_create_token+0x15e>
        profile.len = size;
 c05b290:	9b08      	ldr	r3, [sp, #32]
        attest_token_encode_add_tstr(token_ctx,
 c05b292:	462a      	mov	r2, r5
 c05b294:	4943      	ldr	r1, [pc, #268]	@ (c05b3a4 <attest_create_token+0x264>)
        profile.len = size;
 c05b296:	606b      	str	r3, [r5, #4]
        attest_token_encode_add_tstr(token_ctx,
 c05b298:	a812      	add	r0, sp, #72	@ 0x48
 c05b29a:	f000 f9b3 	bl	c05b604 <attest_token_encode_add_tstr>
    uint32_t size = sizeof(hw_version);
 c05b29e:	2312      	movs	r3, #18
 c05b2a0:	9306      	str	r3, [sp, #24]
    struct q_useful_buf_c claim_value = {0};
 c05b2a2:	2300      	movs	r3, #0
    found = attest_get_tlv_by_id(HW_VERSION, &tlv_len, &tlv_ptr);
 c05b2a4:	2001      	movs	r0, #1
 c05b2a6:	aa07      	add	r2, sp, #28
 c05b2a8:	f10d 0116 	add.w	r1, sp, #22
    struct q_useful_buf_c claim_value = {0};
 c05b2ac:	e9cd 3308 	strd	r3, r3, [sp, #32]
    uint8_t *tlv_ptr = NULL;
 c05b2b0:	9307      	str	r3, [sp, #28]
    found = attest_get_tlv_by_id(HW_VERSION, &tlv_len, &tlv_ptr);
 c05b2b2:	f7ff ff15 	bl	c05b0e0 <attest_get_tlv_by_id.constprop.0>
    if (found == 1) {
 c05b2b6:	2801      	cmp	r0, #1
 c05b2b8:	d151      	bne.n	c05b35e <attest_create_token+0x21e>
        claim_value.ptr = tlv_ptr + SHARED_DATA_ENTRY_HEADER_SIZE;
 c05b2ba:	9b07      	ldr	r3, [sp, #28]
 c05b2bc:	3304      	adds	r3, #4
 c05b2be:	9308      	str	r3, [sp, #32]
        claim_value.len = tlv_len;
 c05b2c0:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    attest_token_encode_add_tstr(token_ctx,
 c05b2c4:	4938      	ldr	r1, [pc, #224]	@ (c05b3a8 <attest_create_token+0x268>)
 c05b2c6:	a812      	add	r0, sp, #72	@ 0x48
 c05b2c8:	aa08      	add	r2, sp, #32
        claim_value.len = tlv_len;
 c05b2ca:	9309      	str	r3, [sp, #36]	@ 0x24
    attest_token_encode_add_tstr(token_ctx,
 c05b2cc:	f000 f99a 	bl	c05b604 <attest_token_encode_add_tstr>
    token_err = attest_token_encode_finish(&attest_token_ctx, completed_token);
 c05b2d0:	9903      	ldr	r1, [sp, #12]
 c05b2d2:	a812      	add	r0, sp, #72	@ 0x48
 c05b2d4:	f000 f949 	bl	c05b56a <attest_token_encode_finish>
    if (token_err) {
 c05b2d8:	2800      	cmp	r0, #0
 c05b2da:	d048      	beq.n	c05b36e <attest_create_token+0x22e>
    switch (token_err) {
 c05b2dc:	2801      	cmp	r0, #1
 c05b2de:	e744      	b.n	c05b16a <attest_create_token+0x2a>
        res = tfm_plat_get_boot_seed(sizeof(boot_seed), boot_seed);
 c05b2e0:	4629      	mov	r1, r5
 c05b2e2:	2020      	movs	r0, #32
 c05b2e4:	f7f0 ff9c 	bl	c04c220 <tfm_plat_get_boot_seed>
        if (res != TFM_PLAT_ERR_SUCCESS) {
 c05b2e8:	2800      	cmp	r0, #0
 c05b2ea:	d147      	bne.n	c05b37c <attest_create_token+0x23c>
        claim_value.ptr = boot_seed;
 c05b2ec:	2320      	movs	r3, #32
 c05b2ee:	9508      	str	r5, [sp, #32]
        claim_value.len = BOOT_SEED_SIZE;
 c05b2f0:	e757      	b.n	c05b1a2 <attest_create_token+0x62>
        *value = (uint32_t)uint16;
 c05b2f2:	889a      	ldrh	r2, [r3, #4]
        security_lifecycle = (enum tfm_security_lifecycle_t)slc_value;
 c05b2f4:	b292      	uxth	r2, r2
    if (security_lifecycle > TFM_SLC_MAX_VALUE) {
 c05b2f6:	f5b2 4fc2 	cmp.w	r2, #24832	@ 0x6100
 c05b2fa:	d392      	bcc.n	c05b222 <attest_create_token+0xe2>
            return PSA_ATTEST_ERR_GENERAL;
 c05b2fc:	2405      	movs	r4, #5
 c05b2fe:	e737      	b.n	c05b170 <attest_create_token+0x30>
 c05b300:	685a      	ldr	r2, [r3, #4]
        if (res) {
 c05b302:	e7f7      	b.n	c05b2f4 <attest_create_token+0x1b4>
        security_lifecycle = tfm_attest_hal_get_security_lifecycle();
 c05b304:	f7f0 fdba 	bl	c04be7c <tfm_attest_hal_get_security_lifecycle>
 c05b308:	4602      	mov	r2, r0
 c05b30a:	e7f4      	b.n	c05b2f6 <attest_create_token+0x1b6>
 c05b30c:	6833      	ldr	r3, [r6, #0]
        tlv_curr += (SHARED_DATA_ENTRY_HEADER_SIZE + tlv_entry.tlv_len);
 c05b30e:	ea4f 4913 	mov.w	r9, r3, lsr #16
        if (GET_IAS_MODULE(tlv_entry.tlv_type) == module) {
 c05b312:	f3c3 1385 	ubfx	r3, r3, #6, #6
 c05b316:	4543      	cmp	r3, r8
 c05b318:	d003      	beq.n	c05b322 <attest_create_token+0x1e2>
        tlv_curr += (SHARED_DATA_ENTRY_HEADER_SIZE + tlv_entry.tlv_len);
 c05b31a:	f109 0904 	add.w	r9, r9, #4
 c05b31e:	444e      	add	r6, r9
 c05b320:	e797      	b.n	c05b252 <attest_create_token+0x112>
            cnt++;
 c05b322:	3401      	adds	r4, #1
            if (cnt == 1) {
 c05b324:	2c01      	cmp	r4, #1
 c05b326:	d109      	bne.n	c05b33c <attest_create_token+0x1fc>
   QCBOREncode_AddInt64(pCtx, nLabel);
 c05b328:	4638      	mov	r0, r7
 c05b32a:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 c05b32e:	4a1f      	ldr	r2, [pc, #124]	@ (c05b3ac <attest_create_token+0x26c>)
 c05b330:	f001 f89b 	bl	c05c46a <QCBOREncode_AddInt64>
   QCBOREncode_OpenMapOrArray(pCtx, CBOR_MAJOR_TYPE_ARRAY);
 c05b334:	2104      	movs	r1, #4
 c05b336:	4638      	mov	r0, r7
 c05b338:	f001 f8cf 	bl	c05c4da <QCBOREncode_OpenMapOrArray>
            encoded.ptr = tlv_ptr + SHARED_DATA_ENTRY_HEADER_SIZE;
 c05b33c:	3604      	adds	r6, #4
 c05b33e:	e9c5 6900 	strd	r6, r9, [r5]
}


static inline void QCBOREncode_AddEncoded(QCBOREncodeContext *pCtx, UsefulBufC Encoded)
{
   QCBOREncode_AddBuffer(pCtx, CBOR_MAJOR_NONE_TYPE_RAW, Encoded);
 c05b342:	2109      	movs	r1, #9
 c05b344:	e895 000c 	ldmia.w	r5, {r2, r3}
 c05b348:	4638      	mov	r0, r7
 c05b34a:	f001 f89f 	bl	c05c48c <QCBOREncode_AddBuffer>
 c05b34e:	e782      	b.n	c05b256 <attest_create_token+0x116>
        attest_token_encode_add_integer(token_ctx,
 c05b350:	2201      	movs	r2, #1
 c05b352:	2300      	movs	r3, #0
 c05b354:	4916      	ldr	r1, [pc, #88]	@ (c05b3b0 <attest_create_token+0x270>)
 c05b356:	a812      	add	r0, sp, #72	@ 0x48
 c05b358:	f000 f931 	bl	c05b5be <attest_token_encode_add_integer>
        if (attest_err != PSA_ATTEST_ERR_SUCCESS) {
 c05b35c:	e787      	b.n	c05b26e <attest_create_token+0x12e>
        res_plat = tfm_plat_get_hw_version(&size, hw_version);
 c05b35e:	4629      	mov	r1, r5
 c05b360:	a806      	add	r0, sp, #24
 c05b362:	f7f0 ff71 	bl	c04c248 <tfm_plat_get_hw_version>
        if (res_plat != TFM_PLAT_ERR_SUCCESS) {
 c05b366:	b948      	cbnz	r0, c05b37c <attest_create_token+0x23c>
        claim_value.len = size;
 c05b368:	9b06      	ldr	r3, [sp, #24]
        claim_value.ptr = hw_version;
 c05b36a:	9508      	str	r5, [sp, #32]
        claim_value.len = size;
 c05b36c:	e7aa      	b.n	c05b2c4 <attest_create_token+0x184>
        attest_err = attest_unregister_initial_attestation_key();
 c05b36e:	f7ff fe4d 	bl	c05b00c <attest_unregister_initial_attestation_key>
 c05b372:	4604      	mov	r4, r0
}
 c05b374:	4620      	mov	r0, r4
 c05b376:	b04d      	add	sp, #308	@ 0x134
 c05b378:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            return PSA_ATTEST_ERR_CLAIM_UNAVAILABLE;
 c05b37c:	2403      	movs	r4, #3
 c05b37e:	e6f7      	b.n	c05b170 <attest_create_token+0x30>
 c05b380:	fffedb00 	.word	0xfffedb00
 c05b384:	fffedb04 	.word	0xfffedb04
 c05b388:	fffedaff 	.word	0xfffedaff
 c05b38c:	fffedb05 	.word	0xfffedb05
 c05b390:	fffedb07 	.word	0xfffedb07
 c05b394:	fffedb06 	.word	0xfffedb06
 c05b398:	30031de4 	.word	0x30031de4
 c05b39c:	30031de8 	.word	0x30031de8
 c05b3a0:	fffedafe 	.word	0xfffedafe
 c05b3a4:	fffedb08 	.word	0xfffedb08
 c05b3a8:	fffedb03 	.word	0xfffedb03
 c05b3ac:	fffedb02 	.word	0xfffedb02
 c05b3b0:	fffedb01 	.word	0xfffedb01

0c05b3b4 <attest_init>:
{
 c05b3b4:	b508      	push	{r3, lr}
    res = attest_get_boot_data(TLV_MAJOR_IAS,
 c05b3b6:	f44f 7200 	mov.w	r2, #512	@ 0x200
 c05b3ba:	4906      	ldr	r1, [pc, #24]	@ (c05b3d4 <attest_init+0x20>)
 c05b3bc:	2001      	movs	r0, #1
 c05b3be:	f002 f889 	bl	c05d4d4 <attest_get_boot_data>
    switch (attest_err) {
 c05b3c2:	2804      	cmp	r0, #4
 c05b3c4:	bf96      	itet	ls
 c05b3c6:	4b04      	ldrls	r3, [pc, #16]	@ (c05b3d8 <attest_init+0x24>)
    res = attest_get_boot_data(TLV_MAJOR_IAS,
 c05b3c8:	f06f 0083 	mvnhi.w	r0, #131	@ 0x83
 c05b3cc:	f933 0010 	ldrshls.w	r0, [r3, r0, lsl #1]
}
 c05b3d0:	bd08      	pop	{r3, pc}
 c05b3d2:	bf00      	nop
 c05b3d4:	30031de4 	.word	0x30031de4
 c05b3d8:	0c0613c0 	.word	0x0c0613c0

0c05b3dc <initial_attest_get_token>:

psa_status_t
initial_attest_get_token(const psa_invec  *in_vec,  uint32_t num_invec,
                               psa_outvec *out_vec, uint32_t num_outvec)
{
 c05b3dc:	b510      	push	{r4, lr}
 c05b3de:	4614      	mov	r4, r2
    enum psa_attest_err_t attest_err = PSA_ATTEST_ERR_SUCCESS;
    struct q_useful_buf_c challenge;
    struct q_useful_buf token;
    struct q_useful_buf_c completed_token;

    challenge.ptr = in_vec[0].base;
 c05b3e0:	6803      	ldr	r3, [r0, #0]
{
 c05b3e2:	b086      	sub	sp, #24
    challenge.len = in_vec[0].len;
    token.ptr = out_vec[0].base;
 c05b3e4:	6812      	ldr	r2, [r2, #0]
    challenge.ptr = in_vec[0].base;
 c05b3e6:	9300      	str	r3, [sp, #0]
    challenge.len = in_vec[0].len;
 c05b3e8:	6843      	ldr	r3, [r0, #4]
    token.ptr = out_vec[0].base;
 c05b3ea:	9202      	str	r2, [sp, #8]
    switch (challenge_size) {
 c05b3ec:	f023 0110 	bic.w	r1, r3, #16
    token.len = out_vec[0].len;
 c05b3f0:	6862      	ldr	r2, [r4, #4]
    switch (challenge_size) {
 c05b3f2:	2920      	cmp	r1, #32
    challenge.len = in_vec[0].len;
 c05b3f4:	9301      	str	r3, [sp, #4]
    token.len = out_vec[0].len;
 c05b3f6:	9203      	str	r2, [sp, #12]
    switch (challenge_size) {
 c05b3f8:	d001      	beq.n	c05b3fe <initial_attest_get_token+0x22>
 c05b3fa:	2b40      	cmp	r3, #64	@ 0x40
 c05b3fc:	d114      	bne.n	c05b428 <initial_attest_get_token+0x4c>
    attest_err = attest_verify_challenge_size(challenge.len);
    if (attest_err != PSA_ATTEST_ERR_SUCCESS) {
        goto error;
    }

    if (token.len == 0) {
 c05b3fe:	b19a      	cbz	r2, c05b428 <initial_attest_get_token+0x4c>
        attest_err = PSA_ATTEST_ERR_INVALID_INPUT;
        goto error;
    }

    attest_err = attest_create_token(&challenge, &token, &completed_token);
 c05b400:	4668      	mov	r0, sp
 c05b402:	aa04      	add	r2, sp, #16
 c05b404:	a902      	add	r1, sp, #8
 c05b406:	f7ff fe9b 	bl	c05b140 <attest_create_token>
    if (attest_err != PSA_ATTEST_ERR_SUCCESS) {
 c05b40a:	b940      	cbnz	r0, c05b41e <initial_attest_get_token+0x42>
        goto error;
    }

    out_vec[0].base = (void *)completed_token.ptr;
 c05b40c:	9b04      	ldr	r3, [sp, #16]
 c05b40e:	6023      	str	r3, [r4, #0]
    out_vec[0].len  = completed_token.len;
 c05b410:	9b05      	ldr	r3, [sp, #20]
 c05b412:	6063      	str	r3, [r4, #4]
    switch (attest_err) {
 c05b414:	4b05      	ldr	r3, [pc, #20]	@ (c05b42c <initial_attest_get_token+0x50>)
 c05b416:	f933 0010 	ldrsh.w	r0, [r3, r0, lsl #1]

error:
    return error_mapping_to_psa_status_t(attest_err);
}
 c05b41a:	b006      	add	sp, #24
 c05b41c:	bd10      	pop	{r4, pc}
    switch (attest_err) {
 c05b41e:	2804      	cmp	r0, #4
 c05b420:	d9f8      	bls.n	c05b414 <initial_attest_get_token+0x38>
error:
 c05b422:	f06f 0083 	mvn.w	r0, #131	@ 0x83
    return error_mapping_to_psa_status_t(attest_err);
 c05b426:	e7f8      	b.n	c05b41a <initial_attest_get_token+0x3e>
        attest_err = PSA_ATTEST_ERR_INVALID_INPUT;
 c05b428:	2004      	movs	r0, #4
 c05b42a:	e7f3      	b.n	c05b414 <initial_attest_get_token+0x38>
 c05b42c:	0c0613c0 	.word	0x0c0613c0

0c05b430 <initial_attest_get_token_size>:
    struct q_useful_buf_c challenge;
    struct q_useful_buf token;
    struct q_useful_buf_c completed_token;

    /* Only the size of the challenge is needed */
    challenge.ptr = NULL;
 c05b430:	2100      	movs	r1, #0
{
 c05b432:	b510      	push	{r4, lr}
    uint32_t  challenge_size = *(uint32_t *)in_vec[0].base;
 c05b434:	6803      	ldr	r3, [r0, #0]
{
 c05b436:	b086      	sub	sp, #24
    uint32_t  challenge_size = *(uint32_t *)in_vec[0].base;
 c05b438:	681b      	ldr	r3, [r3, #0]
    challenge.len = challenge_size;

    /* Special value to get the size of the token, but token is not created */
    token.ptr = NULL;
 c05b43a:	9102      	str	r1, [sp, #8]
    challenge.len = challenge_size;
 c05b43c:	e9cd 1300 	strd	r1, r3, [sp]
    token.len = INT32_MAX;
 c05b440:	f06f 4100 	mvn.w	r1, #2147483648	@ 0x80000000
    uint32_t *token_buf_size = (uint32_t *)out_vec[0].base;
 c05b444:	6814      	ldr	r4, [r2, #0]

    if (out_vec[0].len < sizeof(uint32_t)) {
 c05b446:	6852      	ldr	r2, [r2, #4]
    token.len = INT32_MAX;
 c05b448:	9103      	str	r1, [sp, #12]
    if (out_vec[0].len < sizeof(uint32_t)) {
 c05b44a:	2a03      	cmp	r2, #3
 c05b44c:	d917      	bls.n	c05b47e <initial_attest_get_token_size+0x4e>
    switch (challenge_size) {
 c05b44e:	f023 0210 	bic.w	r2, r3, #16
 c05b452:	2a20      	cmp	r2, #32
 c05b454:	d001      	beq.n	c05b45a <initial_attest_get_token_size+0x2a>
 c05b456:	2b40      	cmp	r3, #64	@ 0x40
 c05b458:	d111      	bne.n	c05b47e <initial_attest_get_token_size+0x4e>
    attest_err = attest_verify_challenge_size(challenge_size);
    if (attest_err != PSA_ATTEST_ERR_SUCCESS) {
        goto error;
    }

    attest_err = attest_create_token(&challenge, &token, &completed_token);
 c05b45a:	4668      	mov	r0, sp
 c05b45c:	aa04      	add	r2, sp, #16
 c05b45e:	a902      	add	r1, sp, #8
 c05b460:	f7ff fe6e 	bl	c05b140 <attest_create_token>
    if (attest_err != PSA_ATTEST_ERR_SUCCESS) {
 c05b464:	b930      	cbnz	r0, c05b474 <initial_attest_get_token_size+0x44>
        goto error;
    }

    *token_buf_size = completed_token.len;
 c05b466:	9b05      	ldr	r3, [sp, #20]
 c05b468:	6023      	str	r3, [r4, #0]
    switch (attest_err) {
 c05b46a:	4b06      	ldr	r3, [pc, #24]	@ (c05b484 <initial_attest_get_token_size+0x54>)
 c05b46c:	f933 0010 	ldrsh.w	r0, [r3, r0, lsl #1]

error:
    return error_mapping_to_psa_status_t(attest_err);
}
 c05b470:	b006      	add	sp, #24
 c05b472:	bd10      	pop	{r4, pc}
    switch (attest_err) {
 c05b474:	2804      	cmp	r0, #4
 c05b476:	d9f8      	bls.n	c05b46a <initial_attest_get_token_size+0x3a>
error:
 c05b478:	f06f 0083 	mvn.w	r0, #131	@ 0x83
    return error_mapping_to_psa_status_t(attest_err);
 c05b47c:	e7f8      	b.n	c05b470 <initial_attest_get_token_size+0x40>
    switch (challenge_size) {
 c05b47e:	2004      	movs	r0, #4
 c05b480:	e7f3      	b.n	c05b46a <initial_attest_get_token_size+0x3a>
 c05b482:	bf00      	nop
 c05b484:	0c0613c0 	.word	0x0c0613c0

0c05b488 <initial_attest_get_public_key>:
}
#else /* SYMMETRIC_INITIAL_ATTESTATION */
psa_status_t
initial_attest_get_public_key(const psa_invec  *in_vec,  uint32_t num_invec,
                                    psa_outvec *out_vec, uint32_t num_outvec)
{
 c05b488:	b5f0      	push	{r4, r5, r6, r7, lr}
 c05b48a:	4615      	mov	r5, r2
 c05b48c:	b085      	sub	sp, #20
    size_t key_len;
    psa_ecc_family_t curve_type;

    (void)in_vec;

    if (num_invec != 0 || num_outvec != 3) {
 c05b48e:	bb49      	cbnz	r1, c05b4e4 <initial_attest_get_public_key+0x5c>
 c05b490:	2b03      	cmp	r3, #3
 c05b492:	d127      	bne.n	c05b4e4 <initial_attest_get_public_key+0x5c>
    }

    key_buffer.ptr = out_vec[0].base;
    key_buffer.len = out_vec[0].len;

    if (out_vec[1].len != sizeof(curve_type) ||
 c05b494:	68d3      	ldr	r3, [r2, #12]
 c05b496:	2b01      	cmp	r3, #1
 c05b498:	d124      	bne.n	c05b4e4 <initial_attest_get_public_key+0x5c>
 c05b49a:	6953      	ldr	r3, [r2, #20]
 c05b49c:	2b04      	cmp	r3, #4
 c05b49e:	d121      	bne.n	c05b4e4 <initial_attest_get_public_key+0x5c>
    key_buffer.len = out_vec[0].len;
 c05b4a0:	e9d2 6700 	ldrd	r6, r7, [r2]
        out_vec[2].len != sizeof(key_len)) {
        attest_err = PSA_ATTEST_ERR_INVALID_INPUT;
        goto error;
    }

    attest_err = attest_get_initial_attestation_public_key(&key_source,
 c05b4a4:	a903      	add	r1, sp, #12
 c05b4a6:	f10d 0207 	add.w	r2, sp, #7
 c05b4aa:	a802      	add	r0, sp, #8
 c05b4ac:	f7ff fdc6 	bl	c05b03c <attest_get_initial_attestation_public_key>
                                                           &key_len,
                                                           &curve_type);
    if (attest_err != PSA_ATTEST_ERR_SUCCESS) {
 c05b4b0:	4604      	mov	r4, r0
 c05b4b2:	b990      	cbnz	r0, c05b4da <initial_attest_get_public_key+0x52>
        goto error;
    }

    if (key_buffer.len < key_len) {
 c05b4b4:	9a03      	ldr	r2, [sp, #12]
 c05b4b6:	4297      	cmp	r7, r2
 c05b4b8:	d316      	bcc.n	c05b4e8 <initial_attest_get_public_key+0x60>
 c05b4ba:	4630      	mov	r0, r6
 c05b4bc:	9902      	ldr	r1, [sp, #8]
 c05b4be:	f000 f8c5 	bl	c05b64c <memcpy>
        goto error;
    }

    (void)tfm_memcpy(key_buffer.ptr, key_source, key_len);

    *(psa_ecc_family_t *)out_vec[1].base = curve_type;
 c05b4c2:	68ab      	ldr	r3, [r5, #8]
 c05b4c4:	f89d 2007 	ldrb.w	r2, [sp, #7]
 c05b4c8:	701a      	strb	r2, [r3, #0]

    *(size_t *)out_vec[2].base = key_len;
 c05b4ca:	692b      	ldr	r3, [r5, #16]
 c05b4cc:	9a03      	ldr	r2, [sp, #12]
 c05b4ce:	601a      	str	r2, [r3, #0]
    switch (attest_err) {
 c05b4d0:	4b06      	ldr	r3, [pc, #24]	@ (c05b4ec <initial_attest_get_public_key+0x64>)
 c05b4d2:	f933 0014 	ldrsh.w	r0, [r3, r4, lsl #1]

error:
    return error_mapping_to_psa_status_t(attest_err);
}
 c05b4d6:	b005      	add	sp, #20
 c05b4d8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    switch (attest_err) {
 c05b4da:	2804      	cmp	r0, #4
 c05b4dc:	d9f8      	bls.n	c05b4d0 <initial_attest_get_public_key+0x48>
error:
 c05b4de:	f06f 0083 	mvn.w	r0, #131	@ 0x83
    return error_mapping_to_psa_status_t(attest_err);
 c05b4e2:	e7f8      	b.n	c05b4d6 <initial_attest_get_public_key+0x4e>
        attest_err = PSA_ATTEST_ERR_INVALID_INPUT;
 c05b4e4:	2404      	movs	r4, #4
 c05b4e6:	e7f3      	b.n	c05b4d0 <initial_attest_get_public_key+0x48>
        attest_err = PSA_ATTEST_ERR_BUFFER_OVERFLOW;
 c05b4e8:	2402      	movs	r4, #2
 c05b4ea:	e7f1      	b.n	c05b4d0 <initial_attest_get_public_key+0x48>
 c05b4ec:	0c0613c0 	.word	0x0c0613c0

0c05b4f0 <attest_token_encode_start>:
attest_token_encode_start(struct attest_token_encode_ctx *me,
                          uint32_t opt_flags,
                          int32_t key_select,
                          int32_t cose_alg_id,
                          const struct q_useful_buf *out_buf)
{
 c05b4f0:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
 c05b4f4:	460e      	mov	r6, r1
 c05b4f6:	4604      	mov	r4, r0
 c05b4f8:	461f      	mov	r7, r3
            return ATTEST_TOKEN_ERR_GENERAL;
        }
#endif /* INCLUDE_COSE_KEY_ID */
    }

    t_cose_sign1_sign_init(&(me->signer_ctx), t_cose_options, cose_alg_id);
 c05b4fa:	f100 08a0 	add.w	r8, r0, #160	@ 0xa0
    me->key_select = key_select;
 c05b4fe:	e9c0 1226 	strd	r1, r2, [r0, #152]	@ 0x98
    if (opt_flags & TOKEN_OPT_SHORT_CIRCUIT_SIGN) {
 c05b502:	0ff6      	lsrs	r6, r6, #31
static inline void
t_cose_sign1_sign_init(struct t_cose_sign1_sign_ctx *me,
                       int32_t                       option_flags,
                       int32_t                       cose_algorithm_id)
{
    memset(me, 0, sizeof(*me));
 c05b504:	2248      	movs	r2, #72	@ 0x48
 c05b506:	2100      	movs	r1, #0
 c05b508:	4640      	mov	r0, r8
{
 c05b50a:	9d08      	ldr	r5, [sp, #32]
 c05b50c:	f000 f90f 	bl	c05b72e <memset>
#ifndef T_COSE_DISABLE_CONTENT_TYPE
    /* Only member for which 0 is not the empty state */
    me->content_type_uint = T_COSE_EMPTY_UINT_CONTENT_TYPE;
#endif

    me->cose_algorithm_id = cose_algorithm_id;
 c05b510:	f8c4 70c0 	str.w	r7, [r4, #192]	@ 0xc0
    me->option_flags      = option_flags;
 c05b514:	f8c4 60d8 	str.w	r6, [r4, #216]	@ 0xd8

    attest_ret = attest_get_signing_key_handle(&private_key);
 c05b518:	a801      	add	r0, sp, #4
 c05b51a:	f7ff fd85 	bl	c05b028 <attest_get_signing_key_handle>
    if (attest_ret != PSA_ATTEST_ERR_SUCCESS) {
 c05b51e:	bb10      	cbnz	r0, c05b566 <attest_token_encode_start+0x76>
    t_cose_sign1_set_signing_key(&(me->signer_ctx),
                                 attest_key,
                                 attest_key_id);

    /* Spin up the CBOR encoder */
    QCBOREncode_Init(&(me->cbor_enc_ctx), *out_buf);
 c05b520:	e895 0006 	ldmia.w	r5, {r1, r2}
t_cose_sign1_set_signing_key(struct t_cose_sign1_sign_ctx *me,
                             struct t_cose_key             signing_key,
                             struct q_useful_buf_c         kid)
{
    me->kid         = kid;
    me->signing_key = signing_key;
 c05b524:	2302      	movs	r3, #2
 c05b526:	f884 30c8 	strb.w	r3, [r4, #200]	@ 0xc8
 c05b52a:	9b01      	ldr	r3, [sp, #4]
    me->kid         = kid;
 c05b52c:	e9c4 0037 	strd	r0, r0, [r4, #220]	@ 0xdc
    me->signing_key = signing_key;
 c05b530:	e9c4 3034 	strd	r3, r0, [r4, #208]	@ 0xd0
 c05b534:	4620      	mov	r0, r4
 c05b536:	f000 ff82 	bl	c05c43e <QCBOREncode_Init>

    /* This will cause the cose headers to be encoded and written into
     *  out_buf using me->cbor_enc_ctx
     */
    cose_ret = t_cose_sign1_encode_parameters(&(me->signer_ctx),
 c05b53a:	4621      	mov	r1, r4
 c05b53c:	4640      	mov	r0, r8
 c05b53e:	f001 fd7d 	bl	c05d03c <t_cose_sign1_encode_parameters>
                                              &(me->cbor_enc_ctx));
    if (cose_ret) {
 c05b542:	4605      	mov	r5, r0
 c05b544:	b128      	cbz	r0, c05b552 <attest_token_encode_start+0x62>
    switch(err) {
 c05b546:	2803      	cmp	r0, #3
 c05b548:	d00b      	beq.n	c05b562 <attest_token_encode_start+0x72>
        return ATTEST_TOKEN_ERR_GENERAL;
 c05b54a:	2819      	cmp	r0, #25
 c05b54c:	bf0c      	ite	eq
 c05b54e:	2501      	moveq	r5, #1
 c05b550:	2503      	movne	r5, #3
   QCBOREncode_OpenMapOrArray(pCtx, CBOR_MAJOR_TYPE_MAP);
 c05b552:	2105      	movs	r1, #5
 c05b554:	4620      	mov	r0, r4
 c05b556:	f000 ffc0 	bl	c05c4da <QCBOREncode_OpenMapOrArray>
    }

    QCBOREncode_OpenMap(&(me->cbor_enc_ctx));

    return return_value;
}
 c05b55a:	4628      	mov	r0, r5
 c05b55c:	b002      	add	sp, #8
 c05b55e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        return ATTEST_TOKEN_ERR_HASH_UNAVAILABLE;
 c05b562:	2504      	movs	r5, #4
 c05b564:	e7f5      	b.n	c05b552 <attest_token_encode_start+0x62>
        return ATTEST_TOKEN_ERR_SIGNING_KEY;
 c05b566:	250e      	movs	r5, #14
 c05b568:	e7f7      	b.n	c05b55a <attest_token_encode_start+0x6a>

0c05b56a <attest_token_encode_finish>:
 * Public function. See attest_token.h
 */
enum attest_token_err_t
attest_token_encode_finish(struct attest_token_encode_ctx *me,
                           struct q_useful_buf_c *completed_token)
{
 c05b56a:	b573      	push	{r0, r1, r4, r5, r6, lr}
 c05b56c:	4604      	mov	r4, r0
 c05b56e:	460d      	mov	r5, r1
   QCBOREncode_CloseMapOrArray(pCtx, CBOR_MAJOR_TYPE_MAP, NULL);
 c05b570:	2200      	movs	r2, #0
 c05b572:	2105      	movs	r1, #5
 c05b574:	f000 ffd0 	bl	c05c518 <QCBOREncode_CloseMapOrArray>
    enum t_cose_err_t       cose_return_value;

    QCBOREncode_CloseMap(&(me->cbor_enc_ctx));

    /* -- Finish up the COSE_Sign1. This is where the signing happens -- */
    cose_return_value = t_cose_sign1_encode_signature(&(me->signer_ctx),
 c05b578:	4621      	mov	r1, r4
 c05b57a:	f104 00a0 	add.w	r0, r4, #160	@ 0xa0
 c05b57e:	f001 fddd 	bl	c05d13c <t_cose_sign1_encode_signature>
                                                      &(me->cbor_enc_ctx));
    if (cose_return_value) {
 c05b582:	b138      	cbz	r0, c05b594 <attest_token_encode_finish+0x2a>
    switch(err) {
 c05b584:	2803      	cmp	r0, #3
 c05b586:	d015      	beq.n	c05b5b4 <attest_token_encode_finish+0x4a>
 c05b588:	2819      	cmp	r0, #25
 c05b58a:	d00b      	beq.n	c05b5a4 <attest_token_encode_finish+0x3a>
        return ATTEST_TOKEN_ERR_GENERAL;
 c05b58c:	2303      	movs	r3, #3
           *completed_token = completed_token_ub;
       }

Done:
        return return_value;
}
 c05b58e:	4618      	mov	r0, r3
 c05b590:	b002      	add	sp, #8
 c05b592:	bd70      	pop	{r4, r5, r6, pc}
    qcbor_result = QCBOREncode_Finish(&(me->cbor_enc_ctx), &completed_token_ub);
 c05b594:	466e      	mov	r6, sp
 c05b596:	4620      	mov	r0, r4
 c05b598:	4631      	mov	r1, r6
 c05b59a:	f000 fffb 	bl	c05c594 <QCBOREncode_Finish>
    if (qcbor_result == QCBOR_ERR_BUFFER_TOO_SMALL) {
 c05b59e:	2801      	cmp	r0, #1
    qcbor_result = QCBOREncode_Finish(&(me->cbor_enc_ctx), &completed_token_ub);
 c05b5a0:	4603      	mov	r3, r0
    if (qcbor_result == QCBOR_ERR_BUFFER_TOO_SMALL) {
 c05b5a2:	d101      	bne.n	c05b5a8 <attest_token_encode_finish+0x3e>
           return_value = ATTEST_TOKEN_ERR_TOO_SMALL;
 c05b5a4:	2301      	movs	r3, #1
 c05b5a6:	e7f2      	b.n	c05b58e <attest_token_encode_finish+0x24>
       } else if (qcbor_result != QCBOR_SUCCESS) {
 c05b5a8:	b930      	cbnz	r0, c05b5b8 <attest_token_encode_finish+0x4e>
           *completed_token = completed_token_ub;
 c05b5aa:	e896 0003 	ldmia.w	r6, {r0, r1}
 c05b5ae:	e885 0003 	stmia.w	r5, {r0, r1}
 c05b5b2:	e7ec      	b.n	c05b58e <attest_token_encode_finish+0x24>
        return ATTEST_TOKEN_ERR_HASH_UNAVAILABLE;
 c05b5b4:	2304      	movs	r3, #4
 c05b5b6:	e7ea      	b.n	c05b58e <attest_token_encode_finish+0x24>
           return_value = ATTEST_TOKEN_ERR_CBOR_FORMATTING;
 c05b5b8:	2302      	movs	r3, #2
 c05b5ba:	e7e8      	b.n	c05b58e <attest_token_encode_finish+0x24>

0c05b5bc <attest_token_encode_borrow_cbor_cntxt>:
 */
QCBOREncodeContext *
attest_token_encode_borrow_cbor_cntxt(struct attest_token_encode_ctx *me)
{
    return &(me->cbor_enc_ctx);
}
 c05b5bc:	4770      	bx	lr

0c05b5be <attest_token_encode_add_integer>:
 * Public function. See attest_token.h
 */
void attest_token_encode_add_integer(struct attest_token_encode_ctx *me,
                                     int32_t label,
                                     int64_t Value)
{
 c05b5be:	b570      	push	{r4, r5, r6, lr}
 c05b5c0:	4604      	mov	r4, r0
 c05b5c2:	4616      	mov	r6, r2
 c05b5c4:	461d      	mov	r5, r3
   QCBOREncode_AddInt64(pCtx, nLabel);
 c05b5c6:	460a      	mov	r2, r1
 c05b5c8:	17cb      	asrs	r3, r1, #31
 c05b5ca:	f000 ff4e 	bl	c05c46a <QCBOREncode_AddInt64>
   QCBOREncode_AddInt64(pCtx, uNum);
 c05b5ce:	4632      	mov	r2, r6
 c05b5d0:	462b      	mov	r3, r5
 c05b5d2:	4620      	mov	r0, r4
    QCBOREncode_AddInt64ToMapN(&(me->cbor_enc_ctx), label, Value);
}
 c05b5d4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 c05b5d8:	f000 bf47 	b.w	c05c46a <QCBOREncode_AddInt64>

0c05b5dc <attest_token_encode_add_bstr>:
 * Public function. See attest_token.h
 */
void attest_token_encode_add_bstr(struct attest_token_encode_ctx *me,
                                  int32_t label,
                                  const struct q_useful_buf_c *bstr)
{
 c05b5dc:	b573      	push	{r0, r1, r4, r5, r6, lr}
 c05b5de:	e9d2 6500 	ldrd	r6, r5, [r2]
 c05b5e2:	4604      	mov	r4, r0
   QCBOREncode_AddInt64(pCtx, nLabel);
 c05b5e4:	460a      	mov	r2, r1
 c05b5e6:	17cb      	asrs	r3, r1, #31
 c05b5e8:	f000 ff3f 	bl	c05c46a <QCBOREncode_AddInt64>
   QCBOREncode_AddBuffer(pCtx, CBOR_MAJOR_TYPE_BYTE_STRING, Bytes);
 c05b5ec:	2102      	movs	r1, #2
 c05b5ee:	4620      	mov	r0, r4
 c05b5f0:	e9cd 6500 	strd	r6, r5, [sp]
 c05b5f4:	ab02      	add	r3, sp, #8
 c05b5f6:	e913 000c 	ldmdb	r3, {r2, r3}
    QCBOREncode_AddBytesToMapN(&(me->cbor_enc_ctx),
                               label,
                               *bstr);
}
 c05b5fa:	b002      	add	sp, #8
 c05b5fc:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 c05b600:	f000 bf44 	b.w	c05c48c <QCBOREncode_AddBuffer>

0c05b604 <attest_token_encode_add_tstr>:
 * Public function. See attest_token.h
 */
void attest_token_encode_add_tstr(struct attest_token_encode_ctx *me,
                                  int32_t label,
                                  const struct q_useful_buf_c *tstr)
{
 c05b604:	b573      	push	{r0, r1, r4, r5, r6, lr}
 c05b606:	e9d2 6500 	ldrd	r6, r5, [r2]
 c05b60a:	4604      	mov	r4, r0
   QCBOREncode_AddInt64(pCtx, nLabel);
 c05b60c:	460a      	mov	r2, r1
 c05b60e:	17cb      	asrs	r3, r1, #31
 c05b610:	f000 ff2b 	bl	c05c46a <QCBOREncode_AddInt64>
   QCBOREncode_AddBuffer(pCtx, CBOR_MAJOR_TYPE_TEXT_STRING, Text);
 c05b614:	2103      	movs	r1, #3
 c05b616:	4620      	mov	r0, r4
 c05b618:	e9cd 6500 	strd	r6, r5, [sp]
 c05b61c:	ab02      	add	r3, sp, #8
 c05b61e:	e913 000c 	ldmdb	r3, {r2, r3}
    QCBOREncode_AddTextToMapN(&(me->cbor_enc_ctx), label, *tstr);
}
 c05b622:	b002      	add	sp, #8
 c05b624:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 c05b628:	f000 bf30 	b.w	c05c48c <QCBOREncode_AddBuffer>

0c05b62c <memcmp>:

#include <stddef.h>
#include <stdint.h>

int memcmp(const void *s1, const void *s2, size_t n)
{
 c05b62c:	4603      	mov	r3, r0
    int result = 0;
 c05b62e:	2000      	movs	r0, #0
{
 c05b630:	b530      	push	{r4, r5, lr}
    const uint8_t *p1 = (const uint8_t *)s1;
    const uint8_t *p2 = (const uint8_t *)s2;
    while (n--) {
 c05b632:	3a01      	subs	r2, #1
 c05b634:	d200      	bcs.n	c05b638 <memcmp+0xc>
            p1++;
            p2++;
        }
    }
    return result;
}
 c05b636:	bd30      	pop	{r4, r5, pc}
        if ((*p1 != *p2) && (result == 0)) {
 c05b638:	781d      	ldrb	r5, [r3, #0]
 c05b63a:	780c      	ldrb	r4, [r1, #0]
 c05b63c:	42a5      	cmp	r5, r4
 c05b63e:	d002      	beq.n	c05b646 <memcmp+0x1a>
 c05b640:	b908      	cbnz	r0, c05b646 <memcmp+0x1a>
            result = *p1 - *p2;
 c05b642:	1b28      	subs	r0, r5, r4
 c05b644:	e7f5      	b.n	c05b632 <memcmp+0x6>
            p1++;
 c05b646:	3301      	adds	r3, #1
            p2++;
 c05b648:	3101      	adds	r1, #1
 c05b64a:	e7f2      	b.n	c05b632 <memcmp+0x6>

0c05b64c <memcpy>:

void *memcpy(void *dest, const void *src, size_t n)
{
    union tfm_mem_addr_t p_dest, p_src;

    p_dest.uint_addr = (uintptr_t)dest;
 c05b64c:	4603      	mov	r3, r0
{
 c05b64e:	b570      	push	{r4, r5, r6, lr}
    p_src.uint_addr = (uintptr_t)src;

    /* Byte copy for unaligned address. check the last bit of address. */
    while (n && (GET_MEM_ADDR_BIT0(p_dest.uint_addr) ||
 c05b650:	b14a      	cbz	r2, c05b666 <memcpy+0x1a>
 c05b652:	ea41 0403 	orr.w	r4, r1, r3
 c05b656:	07e5      	lsls	r5, r4, #31
 c05b658:	d413      	bmi.n	c05b682 <memcpy+0x36>

    /*
     * Double byte copy for aligned address.
     * Check the 2nd last bit of address.
     */
    while (n >= sizeof(uint16_t) && (GET_MEM_ADDR_BIT1(p_dest.uint_addr) ||
 c05b65a:	2a01      	cmp	r2, #1
 c05b65c:	d903      	bls.n	c05b666 <memcpy+0x1a>
 c05b65e:	ea41 0403 	orr.w	r4, r1, r3
 c05b662:	07a4      	lsls	r4, r4, #30
 c05b664:	d413      	bmi.n	c05b68e <memcpy+0x42>
{
 c05b666:	2400      	movs	r4, #0
        *(p_dest.p_dbyte)++ = *(p_src.p_dbyte)++;
        n -= sizeof(uint16_t);
    }

    /* Quad byte copy for aligned address. */
    while (n >= sizeof(uint32_t)) {
 c05b668:	18a5      	adds	r5, r4, r2
 c05b66a:	2d03      	cmp	r5, #3
 c05b66c:	d815      	bhi.n	c05b69a <memcpy+0x4e>
 c05b66e:	f022 0403 	bic.w	r4, r2, #3
 c05b672:	4423      	add	r3, r4
 c05b674:	440c      	add	r4, r1
 c05b676:	2100      	movs	r1, #0
 c05b678:	f002 0203 	and.w	r2, r2, #3
        *(p_dest.p_qbyte)++ = *(p_src.p_qbyte)++;
        n -= sizeof(uint32_t);
    }

    /* Byte copy for the remaining bytes. */
    while (n--) {
 c05b67c:	4291      	cmp	r1, r2
 c05b67e:	d112      	bne.n	c05b6a6 <memcpy+0x5a>
        *p_dest.p_byte++ = *p_src.p_byte++;
    }

    return dest;
}
 c05b680:	bd70      	pop	{r4, r5, r6, pc}
        *p_dest.p_byte++ = *p_src.p_byte++;
 c05b682:	f811 4b01 	ldrb.w	r4, [r1], #1
        n--;
 c05b686:	3a01      	subs	r2, #1
        *p_dest.p_byte++ = *p_src.p_byte++;
 c05b688:	f803 4b01 	strb.w	r4, [r3], #1
        n--;
 c05b68c:	e7e0      	b.n	c05b650 <memcpy+0x4>
        *(p_dest.p_dbyte)++ = *(p_src.p_dbyte)++;
 c05b68e:	f831 4b02 	ldrh.w	r4, [r1], #2
        n -= sizeof(uint16_t);
 c05b692:	3a02      	subs	r2, #2
        *(p_dest.p_dbyte)++ = *(p_src.p_dbyte)++;
 c05b694:	f823 4b02 	strh.w	r4, [r3], #2
        n -= sizeof(uint16_t);
 c05b698:	e7df      	b.n	c05b65a <memcpy+0xe>
        *(p_dest.p_qbyte)++ = *(p_src.p_qbyte)++;
 c05b69a:	1b0d      	subs	r5, r1, r4
 c05b69c:	682e      	ldr	r6, [r5, #0]
 c05b69e:	1b1d      	subs	r5, r3, r4
 c05b6a0:	602e      	str	r6, [r5, #0]
        n -= sizeof(uint32_t);
 c05b6a2:	3c04      	subs	r4, #4
 c05b6a4:	e7e0      	b.n	c05b668 <memcpy+0x1c>
        *p_dest.p_byte++ = *p_src.p_byte++;
 c05b6a6:	5d0d      	ldrb	r5, [r1, r4]
 c05b6a8:	54cd      	strb	r5, [r1, r3]
 c05b6aa:	3101      	adds	r1, #1
 c05b6ac:	e7e6      	b.n	c05b67c <memcpy+0x30>

0c05b6ae <memmove>:
{
    /*
     * FixMe: Add a "assert (dest == NULL || src == NULL)" here
     * after "assert()" for sprtl is implemented.
     */
    if (src >= dest) {
 c05b6ae:	4281      	cmp	r1, r0
{
 c05b6b0:	b570      	push	{r4, r5, r6, lr}
 c05b6b2:	4613      	mov	r3, r2
 c05b6b4:	4604      	mov	r4, r0
    if (src >= dest) {
 c05b6b6:	d303      	bcc.n	c05b6c0 <memmove+0x12>
        memcpy(dest, src, n);
 c05b6b8:	f7ff ffc8 	bl	c05b64c <memcpy>
    } else {
        memcpy_r(dest, src, n);
    }

    return dest;
}
 c05b6bc:	4620      	mov	r0, r4
 c05b6be:	bd70      	pop	{r4, r5, r6, pc}
    p_dest.uint_addr = (uintptr_t)dest + n;
 c05b6c0:	1882      	adds	r2, r0, r2
    p_src.uint_addr = (uintptr_t)src + n;
 c05b6c2:	4419      	add	r1, r3
    while (n && (GET_MEM_ADDR_BIT0(p_dest.uint_addr) ||
 c05b6c4:	b14b      	cbz	r3, c05b6da <memmove+0x2c>
 c05b6c6:	ea41 0002 	orr.w	r0, r1, r2
 c05b6ca:	07c5      	lsls	r5, r0, #31
 c05b6cc:	d41b      	bmi.n	c05b706 <memmove+0x58>
    while (n >= sizeof(uint16_t) && (GET_MEM_ADDR_BIT1(p_dest.uint_addr) ||
 c05b6ce:	2b01      	cmp	r3, #1
 c05b6d0:	d903      	bls.n	c05b6da <memmove+0x2c>
 c05b6d2:	ea41 0002 	orr.w	r0, r1, r2
 c05b6d6:	0780      	lsls	r0, r0, #30
 c05b6d8:	d41b      	bmi.n	c05b712 <memmove+0x64>
{
 c05b6da:	2000      	movs	r0, #0
    while (n >= sizeof(uint32_t)) {
 c05b6dc:	181d      	adds	r5, r3, r0
 c05b6de:	2d03      	cmp	r5, #3
 c05b6e0:	d81d      	bhi.n	c05b71e <memmove+0x70>
 c05b6e2:	f06f 0503 	mvn.w	r5, #3
 c05b6e6:	0898      	lsrs	r0, r3, #2
 c05b6e8:	4368      	muls	r0, r5
 c05b6ea:	4401      	add	r1, r0
 c05b6ec:	4402      	add	r2, r0
 c05b6ee:	4403      	add	r3, r0
 c05b6f0:	2000      	movs	r0, #0
    while (n--) {
 c05b6f2:	4298      	cmp	r0, r3
 c05b6f4:	d0e2      	beq.n	c05b6bc <memmove+0xe>
        *(--p_dest.p_byte) = *(--p_src.p_byte);
 c05b6f6:	1a0d      	subs	r5, r1, r0
 c05b6f8:	f815 6c01 	ldrb.w	r6, [r5, #-1]
 c05b6fc:	1a15      	subs	r5, r2, r0
 c05b6fe:	f805 6c01 	strb.w	r6, [r5, #-1]
 c05b702:	3001      	adds	r0, #1
 c05b704:	e7f5      	b.n	c05b6f2 <memmove+0x44>
        *(--p_dest.p_byte) = *(--p_src.p_byte);
 c05b706:	f811 0d01 	ldrb.w	r0, [r1, #-1]!
        n--;
 c05b70a:	3b01      	subs	r3, #1
        *(--p_dest.p_byte) = *(--p_src.p_byte);
 c05b70c:	f802 0d01 	strb.w	r0, [r2, #-1]!
        n--;
 c05b710:	e7d8      	b.n	c05b6c4 <memmove+0x16>
        *(--p_dest.p_dbyte) = *(--p_src.p_dbyte);
 c05b712:	f831 0d02 	ldrh.w	r0, [r1, #-2]!
        n -= sizeof(uint16_t);
 c05b716:	3b02      	subs	r3, #2
        *(--p_dest.p_dbyte) = *(--p_src.p_dbyte);
 c05b718:	f822 0d02 	strh.w	r0, [r2, #-2]!
        n -= sizeof(uint16_t);
 c05b71c:	e7d7      	b.n	c05b6ce <memmove+0x20>
        *(--p_dest.p_qbyte) = *(--p_src.p_qbyte);
 c05b71e:	1845      	adds	r5, r0, r1
 c05b720:	f855 6c04 	ldr.w	r6, [r5, #-4]
 c05b724:	1885      	adds	r5, r0, r2
 c05b726:	f845 6c04 	str.w	r6, [r5, #-4]
        n -= sizeof(uint32_t);
 c05b72a:	3804      	subs	r0, #4
 c05b72c:	e7d6      	b.n	c05b6dc <memmove+0x2e>

0c05b72e <memset>:
void *memset(void *s, int c, size_t n)
{
    union tfm_mem_addr_t p_mem;
    uint32_t quad_pattern;

    p_mem.p_byte = (uint8_t *)s;
 c05b72e:	4603      	mov	r3, r0
{
 c05b730:	b5f0      	push	{r4, r5, r6, r7, lr}
    quad_pattern = (((uint8_t)c) << 24) | (((uint8_t)c) << 16) |
 c05b732:	b2c9      	uxtb	r1, r1
                   (((uint8_t)c) << 8) | ((uint8_t)c);

    while (n && (p_mem.uint_addr & (sizeof(uint32_t) - 1))) {
 c05b734:	b952      	cbnz	r2, c05b74c <memset+0x1e>
 c05b736:	0894      	lsrs	r4, r2, #2
 c05b738:	eb03 0484 	add.w	r4, r3, r4, lsl #2
 c05b73c:	4413      	add	r3, r2
    while (n >= sizeof(uint32_t)) {
        *p_mem.p_qbyte++ = quad_pattern;
        n -= sizeof(uint32_t);
    }

    while (n--) {
 c05b73e:	42a3      	cmp	r3, r4
 c05b740:	d111      	bne.n	c05b766 <memset+0x38>
        *p_mem.p_byte++ = (uint8_t)c;
    }

    return s;
}
 c05b742:	bdf0      	pop	{r4, r5, r6, r7, pc}
        *p_mem.p_byte++ = (uint8_t)c;
 c05b744:	f803 1b01 	strb.w	r1, [r3], #1
        n--;
 c05b748:	3a01      	subs	r2, #1
 c05b74a:	e7f3      	b.n	c05b734 <memset+0x6>
    while (n && (p_mem.uint_addr & (sizeof(uint32_t) - 1))) {
 c05b74c:	079c      	lsls	r4, r3, #30
 c05b74e:	d1f9      	bne.n	c05b744 <memset+0x16>
 c05b750:	f04f 3501 	mov.w	r5, #16843009	@ 0x1010101
    quad_pattern = (((uint8_t)c) << 24) | (((uint8_t)c) << 16) |
 c05b754:	4614      	mov	r4, r2
 c05b756:	434d      	muls	r5, r1
        *p_mem.p_qbyte++ = quad_pattern;
 c05b758:	18d6      	adds	r6, r2, r3
    while (n >= sizeof(uint32_t)) {
 c05b75a:	2c03      	cmp	r4, #3
 c05b75c:	d9eb      	bls.n	c05b736 <memset+0x8>
        *p_mem.p_qbyte++ = quad_pattern;
 c05b75e:	1b37      	subs	r7, r6, r4
 c05b760:	603d      	str	r5, [r7, #0]
        n -= sizeof(uint32_t);
 c05b762:	3c04      	subs	r4, #4
 c05b764:	e7f9      	b.n	c05b75a <memset+0x2c>
        *p_mem.p_byte++ = (uint8_t)c;
 c05b766:	f804 1b01 	strb.w	r1, [r4], #1
 c05b76a:	e7e8      	b.n	c05b73e <memset+0x10>

0c05b76c <fih_cfi_get_and_increment>:

#ifdef FIH_ENABLE_CFI
fih_int _fih_cfi_ctr = FIH_INT_INIT(0);

fih_int fih_cfi_get_and_increment(uint8_t cnt)
{
 c05b76c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 c05b770:	b09b      	sub	sp, #108	@ 0x6c
    fih_int saved_ctr = _fih_cfi_ctr;
 c05b772:	466f      	mov	r7, sp
 c05b774:	4c45      	ldr	r4, [pc, #276]	@ (c05b88c <fih_cfi_get_and_increment+0x120>)
{
 c05b776:	4680      	mov	r8, r0
 c05b778:	460d      	mov	r5, r1
    fih_int saved_ctr = _fih_cfi_ctr;
 c05b77a:	e894 0003 	ldmia.w	r4, {r0, r1}
 c05b77e:	e887 0003 	stmia.w	r7, {r0, r1}

    if (fih_int_decode(_fih_cfi_ctr) < 0) {
 c05b782:	ab02      	add	r3, sp, #8
 c05b784:	e894 0003 	ldmia.w	r4, {r0, r1}
 c05b788:	e883 0003 	stmia.w	r3, {r0, r1}
    fih_int_validate(x);
 c05b78c:	aa04      	add	r2, sp, #16
 c05b78e:	e893 0003 	ldmia.w	r3, {r0, r1}
 c05b792:	e882 0003 	stmia.w	r2, {r0, r1}
    if (x.val != x_msk) {
 c05b796:	4e3e      	ldr	r6, [pc, #248]	@ (c05b890 <fih_cfi_get_and_increment+0x124>)
    int x_msk = x.msk;
 c05b798:	9b05      	ldr	r3, [sp, #20]
    if (x.val != x_msk) {
 c05b79a:	9a04      	ldr	r2, [sp, #16]
 c05b79c:	4073      	eors	r3, r6
 c05b79e:	4293      	cmp	r3, r2
 c05b7a0:	d001      	beq.n	c05b7a6 <fih_cfi_get_and_increment+0x3a>
        FIH_PANIC;
 c05b7a2:	f7f7 f8e1 	bl	c052968 <Error_Handler>
    return x.val;
 c05b7a6:	9b02      	ldr	r3, [sp, #8]
 c05b7a8:	2b00      	cmp	r3, #0
 c05b7aa:	da01      	bge.n	c05b7b0 <fih_cfi_get_and_increment+0x44>
        FIH_PANIC;
 c05b7ac:	f7f7 f8dc 	bl	c052968 <Error_Handler>
    }

    /* Overflow */
    int int_fih_cfi_ctr = fih_int_decode(_fih_cfi_ctr);
 c05b7b0:	e894 0003 	ldmia.w	r4, {r0, r1}
 c05b7b4:	ab0a      	add	r3, sp, #40	@ 0x28
 c05b7b6:	e883 0003 	stmia.w	r3, {r0, r1}
    fih_int_validate(x);
 c05b7ba:	aa0c      	add	r2, sp, #48	@ 0x30
 c05b7bc:	e893 0003 	ldmia.w	r3, {r0, r1}
 c05b7c0:	e882 0003 	stmia.w	r2, {r0, r1}
    int x_msk = x.msk;
 c05b7c4:	9b0d      	ldr	r3, [sp, #52]	@ 0x34
    if (x.val != x_msk) {
 c05b7c6:	9a0c      	ldr	r2, [sp, #48]	@ 0x30
 c05b7c8:	4073      	eors	r3, r6
 c05b7ca:	4293      	cmp	r3, r2
 c05b7cc:	d001      	beq.n	c05b7d2 <fih_cfi_get_and_increment+0x66>
        FIH_PANIC;
 c05b7ce:	f7f7 f8cb 	bl	c052968 <Error_Handler>
    return x.val;
 c05b7d2:	ab06      	add	r3, sp, #24
 c05b7d4:	f8dd 9028 	ldr.w	r9, [sp, #40]	@ 0x28
    if (int_fih_cfi_ctr > (fih_int_decode(_fih_cfi_ctr) + cnt)) {
 c05b7d8:	e894 0003 	ldmia.w	r4, {r0, r1}
 c05b7dc:	e883 0003 	stmia.w	r3, {r0, r1}
    fih_int_validate(x);
 c05b7e0:	aa08      	add	r2, sp, #32
 c05b7e2:	e893 0003 	ldmia.w	r3, {r0, r1}
 c05b7e6:	e882 0003 	stmia.w	r2, {r0, r1}
    int x_msk = x.msk;
 c05b7ea:	9b09      	ldr	r3, [sp, #36]	@ 0x24
    if (x.val != x_msk) {
 c05b7ec:	9a08      	ldr	r2, [sp, #32]
 c05b7ee:	4073      	eors	r3, r6
 c05b7f0:	4293      	cmp	r3, r2
 c05b7f2:	d001      	beq.n	c05b7f8 <fih_cfi_get_and_increment+0x8c>
        FIH_PANIC;
 c05b7f4:	f7f7 f8b8 	bl	c052968 <Error_Handler>
    return x.val;
 c05b7f8:	9b06      	ldr	r3, [sp, #24]
 c05b7fa:	442b      	add	r3, r5
 c05b7fc:	454b      	cmp	r3, r9
 c05b7fe:	da01      	bge.n	c05b804 <fih_cfi_get_and_increment+0x98>
        FIH_PANIC;
 c05b800:	f7f7 f8b2 	bl	c052968 <Error_Handler>
    }

    _fih_cfi_ctr = fih_int_encode(fih_int_decode(_fih_cfi_ctr) + cnt);
 c05b804:	e894 0003 	ldmia.w	r4, {r0, r1}
 c05b808:	ab16      	add	r3, sp, #88	@ 0x58
 c05b80a:	e883 0003 	stmia.w	r3, {r0, r1}
    fih_int_validate(x);
 c05b80e:	e893 0003 	ldmia.w	r3, {r0, r1}
 c05b812:	ab1a      	add	r3, sp, #104	@ 0x68
 c05b814:	e903 0003 	stmdb	r3, {r0, r1}
    int x_msk = x.msk;
 c05b818:	9b19      	ldr	r3, [sp, #100]	@ 0x64
    if (x.val != x_msk) {
 c05b81a:	9a18      	ldr	r2, [sp, #96]	@ 0x60
 c05b81c:	4073      	eors	r3, r6
 c05b81e:	4293      	cmp	r3, r2
 c05b820:	d001      	beq.n	c05b826 <fih_cfi_get_and_increment+0xba>
        FIH_PANIC;
 c05b822:	f7f7 f8a1 	bl	c052968 <Error_Handler>
    return x.val;
 c05b826:	9b16      	ldr	r3, [sp, #88]	@ 0x58
    fih_int ret = {x, x ^ _FIH_MASK_VALUE};
 c05b828:	aa10      	add	r2, sp, #64	@ 0x40
 c05b82a:	441d      	add	r5, r3
 c05b82c:	9514      	str	r5, [sp, #80]	@ 0x50
 c05b82e:	4075      	eors	r5, r6
 c05b830:	9515      	str	r5, [sp, #84]	@ 0x54
 c05b832:	e9dd 0114 	ldrd	r0, r1, [sp, #80]	@ 0x50
 c05b836:	e882 0003 	stmia.w	r2, {r0, r1}
    return ret;
 c05b83a:	ab12      	add	r3, sp, #72	@ 0x48
 c05b83c:	e892 0003 	ldmia.w	r2, {r0, r1}
 c05b840:	e883 0003 	stmia.w	r3, {r0, r1}
 c05b844:	e893 0003 	ldmia.w	r3, {r0, r1}
 c05b848:	e884 0003 	stmia.w	r4, {r0, r1}

    fih_int_validate(_fih_cfi_ctr);
 c05b84c:	e894 0003 	ldmia.w	r4, {r0, r1}
 c05b850:	e883 0003 	stmia.w	r3, {r0, r1}
    int x_msk = x.msk;
 c05b854:	9b13      	ldr	r3, [sp, #76]	@ 0x4c
    if (x.val != x_msk) {
 c05b856:	9a12      	ldr	r2, [sp, #72]	@ 0x48
 c05b858:	4073      	eors	r3, r6
 c05b85a:	4293      	cmp	r3, r2
 c05b85c:	d001      	beq.n	c05b862 <fih_cfi_get_and_increment+0xf6>
        FIH_PANIC;
 c05b85e:	f7f7 f883 	bl	c052968 <Error_Handler>
    fih_int_validate(saved_ctr);
 c05b862:	e897 0003 	ldmia.w	r7, {r0, r1}
 c05b866:	ab0e      	add	r3, sp, #56	@ 0x38
 c05b868:	e883 0003 	stmia.w	r3, {r0, r1}
    int x_msk = x.msk;
 c05b86c:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
    if (x.val != x_msk) {
 c05b86e:	9a0e      	ldr	r2, [sp, #56]	@ 0x38
 c05b870:	4073      	eors	r3, r6
 c05b872:	4293      	cmp	r3, r2
 c05b874:	d001      	beq.n	c05b87a <fih_cfi_get_and_increment+0x10e>
        FIH_PANIC;
 c05b876:	f7f7 f877 	bl	c052968 <Error_Handler>

    return saved_ctr;
 c05b87a:	e897 0003 	ldmia.w	r7, {r0, r1}
 c05b87e:	e888 0003 	stmia.w	r8, {r0, r1}
}
 c05b882:	4640      	mov	r0, r8
 c05b884:	b01b      	add	sp, #108	@ 0x6c
 c05b886:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 c05b88a:	bf00      	nop
 c05b88c:	30030914 	.word	0x30030914
 c05b890:	a5c35a3c 	.word	0xa5c35a3c

0c05b894 <fih_cfi_validate>:

void fih_cfi_validate(fih_int saved)
{
 c05b894:	b530      	push	{r4, r5, lr}
 c05b896:	b08b      	sub	sp, #44	@ 0x2c
 c05b898:	466a      	mov	r2, sp
 c05b89a:	e882 0003 	stmia.w	r2, {r0, r1}
 c05b89e:	ab06      	add	r3, sp, #24
 c05b8a0:	e892 0003 	ldmia.w	r2, {r0, r1}
 c05b8a4:	e883 0003 	stmia.w	r3, {r0, r1}
    fih_int_validate(x);
 c05b8a8:	e893 0003 	ldmia.w	r3, {r0, r1}
 c05b8ac:	ab0a      	add	r3, sp, #40	@ 0x28
 c05b8ae:	e903 0003 	stmdb	r3, {r0, r1}
    if (x.val != x_msk) {
 c05b8b2:	4c12      	ldr	r4, [pc, #72]	@ (c05b8fc <fih_cfi_validate+0x68>)
    int x_msk = x.msk;
 c05b8b4:	9b09      	ldr	r3, [sp, #36]	@ 0x24
    if (x.val != x_msk) {
 c05b8b6:	9a08      	ldr	r2, [sp, #32]
 c05b8b8:	4063      	eors	r3, r4
 c05b8ba:	4293      	cmp	r3, r2
 c05b8bc:	d001      	beq.n	c05b8c2 <fih_cfi_validate+0x2e>
        FIH_PANIC;
 c05b8be:	f7f7 f853 	bl	c052968 <Error_Handler>
    return x.val;
 c05b8c2:	4a0f      	ldr	r2, [pc, #60]	@ (c05b900 <fih_cfi_validate+0x6c>)
 c05b8c4:	ab02      	add	r3, sp, #8
 c05b8c6:	9d06      	ldr	r5, [sp, #24]
    int ret = fih_int_decode(saved);
    if (ret != fih_int_decode(_fih_cfi_ctr)) {
 c05b8c8:	e892 0003 	ldmia.w	r2, {r0, r1}
 c05b8cc:	e883 0003 	stmia.w	r3, {r0, r1}
    fih_int_validate(x);
 c05b8d0:	aa04      	add	r2, sp, #16
 c05b8d2:	e893 0003 	ldmia.w	r3, {r0, r1}
 c05b8d6:	e882 0003 	stmia.w	r2, {r0, r1}
    int x_msk = x.msk;
 c05b8da:	9b05      	ldr	r3, [sp, #20]
    if (x.val != x_msk) {
 c05b8dc:	9a04      	ldr	r2, [sp, #16]
 c05b8de:	4063      	eors	r3, r4
 c05b8e0:	4293      	cmp	r3, r2
 c05b8e2:	d001      	beq.n	c05b8e8 <fih_cfi_validate+0x54>
        FIH_PANIC;
 c05b8e4:	f7f7 f840 	bl	c052968 <Error_Handler>
    return x.val;
 c05b8e8:	9b02      	ldr	r3, [sp, #8]
 c05b8ea:	42ab      	cmp	r3, r5
 c05b8ec:	d004      	beq.n	c05b8f8 <fih_cfi_validate+0x64>
        FIH_PANIC;
    }
}
 c05b8ee:	b00b      	add	sp, #44	@ 0x2c
 c05b8f0:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
        FIH_PANIC;
 c05b8f4:	f7f7 b838 	b.w	c052968 <Error_Handler>
}
 c05b8f8:	b00b      	add	sp, #44	@ 0x2c
 c05b8fa:	bd30      	pop	{r4, r5, pc}
 c05b8fc:	a5c35a3c 	.word	0xa5c35a3c
 c05b900:	30030914 	.word	0x30030914

0c05b904 <fih_cfi_decrement>:

void fih_cfi_decrement(void)
{
 c05b904:	b530      	push	{r4, r5, lr}
 c05b906:	b08f      	sub	sp, #60	@ 0x3c
 c05b908:	466b      	mov	r3, sp
 c05b90a:	4c25      	ldr	r4, [pc, #148]	@ (c05b9a0 <fih_cfi_decrement+0x9c>)
 c05b90c:	aa02      	add	r2, sp, #8
 c05b90e:	e894 0003 	ldmia.w	r4, {r0, r1}
 c05b912:	e883 0003 	stmia.w	r3, {r0, r1}
    fih_int_validate(x);
 c05b916:	e893 0003 	ldmia.w	r3, {r0, r1}
 c05b91a:	e882 0003 	stmia.w	r2, {r0, r1}
    if (x.val != x_msk) {
 c05b91e:	4d21      	ldr	r5, [pc, #132]	@ (c05b9a4 <fih_cfi_decrement+0xa0>)
    int x_msk = x.msk;
 c05b920:	9b03      	ldr	r3, [sp, #12]
    if (x.val != x_msk) {
 c05b922:	9a02      	ldr	r2, [sp, #8]
 c05b924:	406b      	eors	r3, r5
 c05b926:	4293      	cmp	r3, r2
 c05b928:	d001      	beq.n	c05b92e <fih_cfi_decrement+0x2a>
        FIH_PANIC;
 c05b92a:	f7f7 f81d 	bl	c052968 <Error_Handler>
    return x.val;
 c05b92e:	9b00      	ldr	r3, [sp, #0]
    if (fih_int_decode(_fih_cfi_ctr) < 1) {
 c05b930:	2b00      	cmp	r3, #0
 c05b932:	dc01      	bgt.n	c05b938 <fih_cfi_decrement+0x34>
        FIH_PANIC;
 c05b934:	f7f7 f818 	bl	c052968 <Error_Handler>
    }

    _fih_cfi_ctr = fih_int_encode(fih_int_decode(_fih_cfi_ctr) - 1);
 c05b938:	e894 0003 	ldmia.w	r4, {r0, r1}
 c05b93c:	ab0a      	add	r3, sp, #40	@ 0x28
 c05b93e:	e883 0003 	stmia.w	r3, {r0, r1}
    fih_int_validate(x);
 c05b942:	e893 0003 	ldmia.w	r3, {r0, r1}
 c05b946:	ab0e      	add	r3, sp, #56	@ 0x38
 c05b948:	e903 0003 	stmdb	r3, {r0, r1}
    int x_msk = x.msk;
 c05b94c:	9b0d      	ldr	r3, [sp, #52]	@ 0x34
    if (x.val != x_msk) {
 c05b94e:	9a0c      	ldr	r2, [sp, #48]	@ 0x30
 c05b950:	406b      	eors	r3, r5
 c05b952:	4293      	cmp	r3, r2
 c05b954:	d001      	beq.n	c05b95a <fih_cfi_decrement+0x56>
        FIH_PANIC;
 c05b956:	f7f7 f807 	bl	c052968 <Error_Handler>
    return x.val;
 c05b95a:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
    fih_int ret = {x, x ^ _FIH_MASK_VALUE};
 c05b95c:	aa04      	add	r2, sp, #16
 c05b95e:	3b01      	subs	r3, #1
 c05b960:	9308      	str	r3, [sp, #32]
 c05b962:	406b      	eors	r3, r5
 c05b964:	9309      	str	r3, [sp, #36]	@ 0x24
 c05b966:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 c05b96a:	e882 0003 	stmia.w	r2, {r0, r1}
    return ret;
 c05b96e:	ab06      	add	r3, sp, #24
 c05b970:	e892 0003 	ldmia.w	r2, {r0, r1}
 c05b974:	e883 0003 	stmia.w	r3, {r0, r1}
 c05b978:	e893 0003 	ldmia.w	r3, {r0, r1}
 c05b97c:	e884 0003 	stmia.w	r4, {r0, r1}

    fih_int_validate(_fih_cfi_ctr);
 c05b980:	e894 0003 	ldmia.w	r4, {r0, r1}
 c05b984:	e883 0003 	stmia.w	r3, {r0, r1}
    int x_msk = x.msk;
 c05b988:	9b07      	ldr	r3, [sp, #28]
    if (x.val != x_msk) {
 c05b98a:	9a06      	ldr	r2, [sp, #24]
 c05b98c:	406b      	eors	r3, r5
 c05b98e:	4293      	cmp	r3, r2
 c05b990:	d004      	beq.n	c05b99c <fih_cfi_decrement+0x98>
}
 c05b992:	b00f      	add	sp, #60	@ 0x3c
 c05b994:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
        FIH_PANIC;
 c05b998:	f7f6 bfe6 	b.w	c052968 <Error_Handler>
 c05b99c:	b00f      	add	sp, #60	@ 0x3c
 c05b99e:	bd30      	pop	{r4, r5, pc}
 c05b9a0:	30030914 	.word	0x30030914
 c05b9a4:	a5c35a3c 	.word	0xa5c35a3c

0c05b9a8 <fih_delay_init>:
#endif /* FIH_ENABLE_GLOBAL_FAIL */

#ifdef FIH_ENABLE_DELAY
void fih_delay_init(void)
{
    volatile int32_t ret = TFM_HAL_ERROR_GENERIC;
 c05b9a8:	f643 33da 	movw	r3, #15322	@ 0x3bda
{
 c05b9ac:	b507      	push	{r0, r1, r2, lr}
    volatile int32_t ret = TFM_HAL_ERROR_GENERIC;
 c05b9ae:	9301      	str	r3, [sp, #4]

    ret = tfm_hal_random_init();
 c05b9b0:	f7f6 f87a 	bl	c051aa8 <tfm_hal_random_init>
 c05b9b4:	9001      	str	r0, [sp, #4]
    if (ret != TFM_HAL_SUCCESS) {
 c05b9b6:	9b01      	ldr	r3, [sp, #4]
 c05b9b8:	b123      	cbz	r3, c05b9c4 <fih_delay_init+0x1c>
        FIH_PANIC;
    }
}
 c05b9ba:	b003      	add	sp, #12
 c05b9bc:	f85d eb04 	ldr.w	lr, [sp], #4
        FIH_PANIC;
 c05b9c0:	f7f6 bfd2 	b.w	c052968 <Error_Handler>
}
 c05b9c4:	b003      	add	sp, #12
 c05b9c6:	f85d fb04 	ldr.w	pc, [sp], #4

0c05b9ca <fih_delay_random>:

uint8_t fih_delay_random(void)
{
    volatile int32_t ret = TFM_HAL_ERROR_GENERIC;
 c05b9ca:	f643 33da 	movw	r3, #15322	@ 0x3bda
{
 c05b9ce:	b507      	push	{r0, r1, r2, lr}
    volatile int32_t ret = TFM_HAL_ERROR_GENERIC;
 c05b9d0:	9301      	str	r3, [sp, #4]
    uint8_t rand_value = 0xFF;
 c05b9d2:	23ff      	movs	r3, #255	@ 0xff

    ret = tfm_hal_random_generate(&rand_value, sizeof(rand_value));
 c05b9d4:	2101      	movs	r1, #1
 c05b9d6:	f10d 0003 	add.w	r0, sp, #3
    uint8_t rand_value = 0xFF;
 c05b9da:	f88d 3003 	strb.w	r3, [sp, #3]
    ret = tfm_hal_random_generate(&rand_value, sizeof(rand_value));
 c05b9de:	f7f6 f889 	bl	c051af4 <tfm_hal_random_generate>
 c05b9e2:	9001      	str	r0, [sp, #4]
    if (ret != TFM_HAL_SUCCESS) {
 c05b9e4:	9b01      	ldr	r3, [sp, #4]
 c05b9e6:	b10b      	cbz	r3, c05b9ec <fih_delay_random+0x22>
        FIH_PANIC;
 c05b9e8:	f7f6 ffbe 	bl	c052968 <Error_Handler>
    }

    return rand_value;
}
 c05b9ec:	f89d 0003 	ldrb.w	r0, [sp, #3]
 c05b9f0:	b003      	add	sp, #12
 c05b9f2:	f85d fb04 	ldr.w	pc, [sp], #4

0c05b9f6 <is_range_valid>:
                           uint32_t off,
                           uint32_t len)
{
    uint32_t size;

    if (!area) {
 c05b9f6:	b140      	cbz	r0, c05ba0a <is_range_valid+0x14>
{
    /*
     * "a + b <= UINT32_MAX", subtract 'b' from both sides to avoid
     * the overflow.
     */
    if (a > UINT32_MAX - b) {
 c05b9f8:	1852      	adds	r2, r2, r1
 c05b9fa:	d205      	bcs.n	c05ba08 <is_range_valid+0x12>

    if (!boot_u32_safe_add(&size, off, len)) {
        return false;
    }

    if (area->fa_size < size) {
 c05b9fc:	68c0      	ldr	r0, [r0, #12]
 c05b9fe:	4290      	cmp	r0, r2
 c05ba00:	bf34      	ite	cc
 c05ba02:	2000      	movcc	r0, #0
 c05ba04:	2001      	movcs	r0, #1
 c05ba06:	4770      	bx	lr
        return false;
 c05ba08:	2000      	movs	r0, #0
        return false;
    }

    return true;
}
 c05ba0a:	4770      	bx	lr

0c05ba0c <flash_area_open>:
{
    int i;

    BOOT_LOG_DBG("area %d", id);

    for (i = 0; i < flash_map_entry_num; i++) {
 c05ba0c:	2300      	movs	r3, #0
{
 c05ba0e:	b530      	push	{r4, r5, lr}
        if (id == flash_map[i].fa_id) {
 c05ba10:	4c07      	ldr	r4, [pc, #28]	@ (c05ba30 <flash_area_open+0x24>)
 c05ba12:	011a      	lsls	r2, r3, #4
 c05ba14:	5ca2      	ldrb	r2, [r4, r2]
 c05ba16:	eb04 1503 	add.w	r5, r4, r3, lsl #4
 c05ba1a:	4282      	cmp	r2, r0
 c05ba1c:	d005      	beq.n	c05ba2a <flash_area_open+0x1e>
    for (i = 0; i < flash_map_entry_num; i++) {
 c05ba1e:	3301      	adds	r3, #1
 c05ba20:	2b09      	cmp	r3, #9
 c05ba22:	d1f6      	bne.n	c05ba12 <flash_area_open+0x6>
            break;
        }
    }
    if (i == flash_map_entry_num) {
        return -1;
 c05ba24:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
    }

    *area = &flash_map[i];
    return 0;
}
 c05ba28:	bd30      	pop	{r4, r5, pc}
    return 0;
 c05ba2a:	2000      	movs	r0, #0
    *area = &flash_map[i];
 c05ba2c:	600d      	str	r5, [r1, #0]
    return 0;
 c05ba2e:	e7fb      	b.n	c05ba28 <flash_area_open+0x1c>
 c05ba30:	0c0614d8 	.word	0x0c0614d8

0c05ba34 <flash_area_close>:

void flash_area_close(const struct flash_area *area)
{
    /* Nothing to do. */
}
 c05ba34:	4770      	bx	lr

0c05ba36 <flash_area_read>:

int flash_area_read(const struct flash_area *area, uint32_t off, void *dst,
                    uint32_t len)
{
 c05ba36:	b570      	push	{r4, r5, r6, lr}
 c05ba38:	4616      	mov	r6, r2
    BOOT_LOG_DBG("read area=%d, off=%#x, len=%#x", area->fa_id, off, len);

    if (!is_range_valid(area, off, len)) {
 c05ba3a:	461a      	mov	r2, r3
{
 c05ba3c:	4604      	mov	r4, r0
 c05ba3e:	460d      	mov	r5, r1
    if (!is_range_valid(area, off, len)) {
 c05ba40:	f7ff ffd9 	bl	c05b9f6 <is_range_valid>
 c05ba44:	b148      	cbz	r0, c05ba5a <flash_area_read+0x24>
        return -1;
    }

    return DRV_FLASH_AREA(area)->ReadData(area->fa_off + off, dst, len);
 c05ba46:	e9d4 2001 	ldrd	r2, r0, [r4, #4]
 c05ba4a:	6954      	ldr	r4, [r2, #20]
 c05ba4c:	4631      	mov	r1, r6
 c05ba4e:	461a      	mov	r2, r3
 c05ba50:	4428      	add	r0, r5
 c05ba52:	4623      	mov	r3, r4
}
 c05ba54:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    return DRV_FLASH_AREA(area)->ReadData(area->fa_off + off, dst, len);
 c05ba58:	4718      	bx	r3
}
 c05ba5a:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 c05ba5e:	bd70      	pop	{r4, r5, r6, pc}

0c05ba60 <flash_area_write>:

int flash_area_write(const struct flash_area *area, uint32_t off,
                     const void *src, uint32_t len)
{
 c05ba60:	b570      	push	{r4, r5, r6, lr}
 c05ba62:	4616      	mov	r6, r2
    BOOT_LOG_DBG("write area=%d, off=%#x, len=%#x", area->fa_id, off, len);

    if (!is_range_valid(area, off, len)) {
 c05ba64:	461a      	mov	r2, r3
{
 c05ba66:	4604      	mov	r4, r0
 c05ba68:	460d      	mov	r5, r1
    if (!is_range_valid(area, off, len)) {
 c05ba6a:	f7ff ffc4 	bl	c05b9f6 <is_range_valid>
 c05ba6e:	b148      	cbz	r0, c05ba84 <flash_area_write+0x24>
        return -1;
    }

    return DRV_FLASH_AREA(area)->ProgramData(area->fa_off + off, src, len);
 c05ba70:	e9d4 2001 	ldrd	r2, r0, [r4, #4]
 c05ba74:	6994      	ldr	r4, [r2, #24]
 c05ba76:	4631      	mov	r1, r6
 c05ba78:	461a      	mov	r2, r3
 c05ba7a:	4428      	add	r0, r5
 c05ba7c:	4623      	mov	r3, r4
}
 c05ba7e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    return DRV_FLASH_AREA(area)->ProgramData(area->fa_off + off, src, len);
 c05ba82:	4718      	bx	r3
}
 c05ba84:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 c05ba88:	bd70      	pop	{r4, r5, r6, pc}

0c05ba8a <flash_area_erase>:

int flash_area_erase(const struct flash_area *area, uint32_t off, uint32_t len)
{
 c05ba8a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 c05ba8e:	4605      	mov	r5, r0
 c05ba90:	460e      	mov	r6, r1
 c05ba92:	4690      	mov	r8, r2
    uint32_t deleted_len = 0;
    int32_t rc = 0;

    BOOT_LOG_DBG("erase area=%d, off=%#x, len=%#x", area->fa_id, off, len);

    if (!is_range_valid(area, off, len)) {
 c05ba94:	f7ff ffaf 	bl	c05b9f6 <is_range_valid>
 c05ba98:	b1a8      	cbz	r0, c05bac6 <flash_area_erase+0x3c>
        return -1;
    }

    flash_info = DRV_FLASH_AREA(area)->GetInfo();
 c05ba9a:	686b      	ldr	r3, [r5, #4]
 c05ba9c:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 c05ba9e:	4798      	blx	r3

    if (flash_info->sector_info == NULL) {
 c05baa0:	6804      	ldr	r4, [r0, #0]
    flash_info = DRV_FLASH_AREA(area)->GetInfo();
 c05baa2:	4607      	mov	r7, r0
    if (flash_info->sector_info == NULL) {
 c05baa4:	b164      	cbz	r4, c05bac0 <flash_area_erase+0x36>
        return -1;
 c05baa6:	2000      	movs	r0, #0
         * Currently not supported.
         */
    }

    return rc;
}
 c05baa8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
            rc = DRV_FLASH_AREA(area)->EraseSector(area->fa_off + off);
 c05baac:	e9d5 3001 	ldrd	r3, r0, [r5, #4]
 c05bab0:	69db      	ldr	r3, [r3, #28]
 c05bab2:	4430      	add	r0, r6
 c05bab4:	4798      	blx	r3
            if (rc != 0) {
 c05bab6:	2800      	cmp	r0, #0
 c05bab8:	d1f6      	bne.n	c05baa8 <flash_area_erase+0x1e>
            deleted_len += flash_info->sector_size;
 c05baba:	68bb      	ldr	r3, [r7, #8]
 c05babc:	441c      	add	r4, r3
            off         += flash_info->sector_size;
 c05babe:	441e      	add	r6, r3
        while (deleted_len < len) {
 c05bac0:	4544      	cmp	r4, r8
 c05bac2:	d3f3      	bcc.n	c05baac <flash_area_erase+0x22>
 c05bac4:	e7ef      	b.n	c05baa6 <flash_area_erase+0x1c>
        return -1;
 c05bac6:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 c05baca:	e7ed      	b.n	c05baa8 <flash_area_erase+0x1e>

0c05bacc <flash_area_align>:

uint32_t flash_area_align(const struct flash_area *area)
{
 c05bacc:	b508      	push	{r3, lr}
    ARM_FLASH_INFO *flash_info;

    flash_info = DRV_FLASH_AREA(area)->GetInfo();
 c05bace:	6843      	ldr	r3, [r0, #4]
 c05bad0:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 c05bad2:	4798      	blx	r3
    return flash_info->program_unit;
}
 c05bad4:	6900      	ldr	r0, [r0, #16]
 c05bad6:	bd08      	pop	{r3, pc}

0c05bad8 <flash_area_erased_val>:
{
    return flash_area_id_to_multi_image_slot(0, area_id);
}

uint8_t flash_area_erased_val(const struct flash_area *fap)
{
 c05bad8:	b508      	push	{r3, lr}
    return DRV_FLASH_AREA(fap)->GetInfo()->erased_value;
 c05bada:	6843      	ldr	r3, [r0, #4]
 c05badc:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 c05bade:	4798      	blx	r3
}
 c05bae0:	7d00      	ldrb	r0, [r0, #20]
 c05bae2:	bd08      	pop	{r3, pc}

0c05bae4 <main>:

    FIH_RET(fih_int_encode(TFM_SUCCESS));
}

int main(void)
{
 c05bae4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    fih_int fih_rc = FIH_FAILURE;
 c05bae8:	4d88      	ldr	r5, [pc, #544]	@ (c05bd0c <FIH_LABEL_FIH_CRITICAL_POINT_0_517+0x40>)
{
 c05baea:	f5ad 7d19 	sub.w	sp, sp, #612	@ 0x264
    fih_int fih_rc = FIH_FAILURE;
 c05baee:	af24      	add	r7, sp, #144	@ 0x90
 c05baf0:	e895 0003 	ldmia.w	r5, {r0, r1}
 c05baf4:	e887 0003 	stmia.w	r7, {r0, r1}
  __ASM volatile ("MRS %0, msp" : "=r" (result) );
 c05baf8:	f3ef 8308 	mrs	r3, MSP
     * manipulating MSP works here.
     */
    TFM_CORE_ASSERT((mstk_adr & 0x7) == 0);
    mstk_adr -= TFM_STACK_SEALED_SIZE;

    *((uint32_t *)mstk_adr)       = TFM_STACK_SEAL_VALUE;
 c05bafc:	4a84      	ldr	r2, [pc, #528]	@ (c05bd10 <FIH_LABEL_FIH_CRITICAL_POINT_0_517+0x44>)
    mstk_adr -= TFM_STACK_SEALED_SIZE;
 c05bafe:	f1a3 0108 	sub.w	r1, r3, #8
    *((uint32_t *)(mstk_adr + 4)) = TFM_STACK_SEAL_VALUE;
 c05bb02:	e943 2202 	strd	r2, r2, [r3, #-8]
  __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
 c05bb06:	f381 8808 	msr	MSP, r1
  __ASM volatile ("MSR msplim, %0" : : "r" (MainStackPtrLimit));
 c05bb0a:	4b82      	ldr	r3, [pc, #520]	@ (c05bd14 <FIH_LABEL_FIH_CRITICAL_POINT_0_517+0x48>)
 c05bb0c:	f383 880a 	msr	MSPLIM, r3

    /* set Main Stack Pointer limit */
    tfm_arch_init_secure_msp((uint32_t)&REGION_NAME(Image$$, ARM_LIB_STACK_MSP,
                                               $$ZI$$Base));

    fih_delay_init();
 c05bb10:	f7ff ff4a 	bl	c05b9a8 <fih_delay_init>

0c05bb14 <FIH_LABEL_FIH_CALL_START_tfm_core_init_0_80>:

    FIH_CALL(tfm_core_init, fih_rc);
 c05bb14:	f10d 0898 	add.w	r8, sp, #152	@ 0x98
 c05bb18:	2101      	movs	r1, #1
 c05bb1a:	4640      	mov	r0, r8
 c05bb1c:	f7ff fe26 	bl	c05b76c <fih_cfi_get_and_increment>
 c05bb20:	e895 0003 	ldmia.w	r5, {r0, r1}
    volatile uint32_t counter = 0;
 c05bb24:	2300      	movs	r3, #0
    volatile uint32_t delay = FIH_NEGATIVE_VALUE;
 c05bb26:	4c7c      	ldr	r4, [pc, #496]	@ (c05bd18 <FIH_LABEL_FIH_CRITICAL_POINT_0_517+0x4c>)
 c05bb28:	e887 0003 	stmia.w	r7, {r0, r1}
 c05bb2c:	940a      	str	r4, [sp, #40]	@ 0x28
    volatile uint32_t counter = 0;
 c05bb2e:	930b      	str	r3, [sp, #44]	@ 0x2c
    delay = fih_delay_random();
 c05bb30:	f7ff ff4b 	bl	c05b9ca <fih_delay_random>
 c05bb34:	900a      	str	r0, [sp, #40]	@ 0x28
    if (delay == FIH_NEGATIVE_VALUE) {
 c05bb36:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 c05bb38:	42a3      	cmp	r3, r4
 c05bb3a:	d101      	bne.n	c05bb40 <FIH_LABEL_FIH_CALL_START_tfm_core_init_0_80+0x2c>
        FIH_PANIC;
 c05bb3c:	f7f6 ff14 	bl	c052968 <Error_Handler>
    delay &= 0xFF;
 c05bb40:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 c05bb42:	b2db      	uxtb	r3, r3
 c05bb44:	930a      	str	r3, [sp, #40]	@ 0x28
    for (i = 0; i < delay; i++) {
 c05bb46:	2300      	movs	r3, #0
 c05bb48:	9a0a      	ldr	r2, [sp, #40]	@ 0x28
 c05bb4a:	4293      	cmp	r3, r2
 c05bb4c:	f0c0 80cb 	bcc.w	c05bce6 <FIH_LABEL_FIH_CRITICAL_POINT_0_517+0x1a>
    uint8_t local_delay = delay;
 c05bb50:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
    if (counter != local_delay) {
 c05bb52:	9a0b      	ldr	r2, [sp, #44]	@ 0x2c
 c05bb54:	b2db      	uxtb	r3, r3
 c05bb56:	4293      	cmp	r3, r2
 c05bb58:	d001      	beq.n	c05bb5e <FIH_LABEL_FIH_CALL_START_tfm_core_init_0_80+0x4a>
        FIH_PANIC;
 c05bb5a:	f7f6 ff05 	bl	c052968 <Error_Handler>
    fih_int fih_rc = FIH_FAILURE;
 c05bb5e:	e895 0003 	ldmia.w	r5, {r0, r1}
 c05bb62:	ac36      	add	r4, sp, #216	@ 0xd8
 c05bb64:	e884 0003 	stmia.w	r4, {r0, r1}
    stdio_init();
 c05bb68:	f002 fda8 	bl	c05e6bc <stdio_init>
    plat_err = tfm_spm_hal_enable_fault_handlers();
 c05bb6c:	f7f5 f862 	bl	c050c34 <tfm_spm_hal_enable_fault_handlers>
    if (plat_err != TFM_PLAT_ERR_SUCCESS) {
 c05bb70:	2800      	cmp	r0, #0
 c05bb72:	f000 80bd 	beq.w	c05bcf0 <FIH_LABEL_FIH_CRITICAL_POINT_0_517+0x24>
        FIH_RET(fih_int_encode(TFM_ERROR_GENERIC));
 c05bb76:	f7ff fec5 	bl	c05b904 <fih_cfi_decrement>
    fih_int ret = {x, x ^ _FIH_MASK_VALUE};
 c05bb7a:	231f      	movs	r3, #31
 c05bb7c:	9390      	str	r3, [sp, #576]	@ 0x240
 c05bb7e:	4b67      	ldr	r3, [pc, #412]	@ (c05bd1c <FIH_LABEL_FIH_CRITICAL_POINT_0_517+0x50>)
 c05bb80:	9391      	str	r3, [sp, #580]	@ 0x244
 c05bb82:	ab68      	add	r3, sp, #416	@ 0x1a0
 c05bb84:	e9dd 0190 	ldrd	r0, r1, [sp, #576]	@ 0x240
 c05bb88:	e883 0003 	stmia.w	r3, {r0, r1}
    return ret;
 c05bb8c:	aa76      	add	r2, sp, #472	@ 0x1d8
 c05bb8e:	e893 0003 	ldmia.w	r3, {r0, r1}
 c05bb92:	e882 0003 	stmia.w	r2, {r0, r1}
    FIH_CALL(tfm_core_init, fih_rc);
 c05bb96:	ac76      	add	r4, sp, #472	@ 0x1d8
 c05bb98:	e894 0003 	ldmia.w	r4, {r0, r1}
 c05bb9c:	e887 0003 	stmia.w	r7, {r0, r1}
 c05bba0:	e898 0003 	ldmia.w	r8, {r0, r1}
 c05bba4:	f7ff fe76 	bl	c05b894 <fih_cfi_validate>
 c05bba8:	e897 0003 	ldmia.w	r7, {r0, r1}
 c05bbac:	e884 0003 	stmia.w	r4, {r0, r1}
    if (x.val != x_msk) {
 c05bbb0:	4e5b      	ldr	r6, [pc, #364]	@ (c05bd20 <FIH_LABEL_FIH_CRITICAL_POINT_0_517+0x54>)
    int x_msk = x.msk;
 c05bbb2:	9b77      	ldr	r3, [sp, #476]	@ 0x1dc
    if (x.val != x_msk) {
 c05bbb4:	9a76      	ldr	r2, [sp, #472]	@ 0x1d8
 c05bbb6:	4073      	eors	r3, r6
 c05bbb8:	4293      	cmp	r3, r2
 c05bbba:	d001      	beq.n	c05bbc0 <FIH_LABEL_FIH_CALL_END_0_251>
        FIH_PANIC;
 c05bbbc:	f7f6 fed4 	bl	c052968 <Error_Handler>

0c05bbc0 <FIH_LABEL_FIH_CALL_END_0_251>:
    fih_int ret = {x, x ^ _FIH_MASK_VALUE};
 c05bbc0:	f04f 0c00 	mov.w	ip, #0
 c05bbc4:	aa32      	add	r2, sp, #200	@ 0xc8
 c05bbc6:	f8cd c0d0 	str.w	ip, [sp, #208]	@ 0xd0
 c05bbca:	ab34      	add	r3, sp, #208	@ 0xd0
 c05bbcc:	9635      	str	r6, [sp, #212]	@ 0xd4
 c05bbce:	e893 0003 	ldmia.w	r3, {r0, r1}
 c05bbd2:	e882 0003 	stmia.w	r2, {r0, r1}
    return ret;
 c05bbd6:	ab28      	add	r3, sp, #160	@ 0xa0
 c05bbd8:	e892 0003 	ldmia.w	r2, {r0, r1}
 c05bbdc:	e883 0003 	stmia.w	r3, {r0, r1}
 c05bbe0:	e897 0003 	ldmia.w	r7, {r0, r1}
 c05bbe4:	ad2a      	add	r5, sp, #168	@ 0xa8
 c05bbe6:	ac2c      	add	r4, sp, #176	@ 0xb0
 c05bbe8:	e885 0003 	stmia.w	r5, {r0, r1}
 c05bbec:	e893 0003 	ldmia.w	r3, {r0, r1}
 c05bbf0:	e884 0003 	stmia.w	r4, {r0, r1}
    volatile int32_t rc1 = FIH_FALSE;
 c05bbf4:	ab2e      	add	r3, sp, #184	@ 0xb8
 c05bbf6:	f8cd c010 	str.w	ip, [sp, #16]
    volatile int32_t rc2 = FIH_FALSE;
 c05bbfa:	f8cd c014 	str.w	ip, [sp, #20]
    fih_int_validate(x);
 c05bbfe:	e895 0003 	ldmia.w	r5, {r0, r1}
 c05bc02:	e883 0003 	stmia.w	r3, {r0, r1}
    int x_msk = x.msk;
 c05bc06:	685a      	ldr	r2, [r3, #4]
    if (x.val != x_msk) {
 c05bc08:	6819      	ldr	r1, [r3, #0]
 c05bc0a:	ea82 0306 	eor.w	r3, r2, r6
 c05bc0e:	428b      	cmp	r3, r1
 c05bc10:	d001      	beq.n	c05bc16 <FIH_LABEL_FIH_CALL_END_0_251+0x56>
        FIH_PANIC;
 c05bc12:	f7f6 fea9 	bl	c052968 <Error_Handler>
    fih_int_validate(y);
 c05bc16:	e894 0003 	ldmia.w	r4, {r0, r1}
 c05bc1a:	ab30      	add	r3, sp, #192	@ 0xc0
 c05bc1c:	e883 0003 	stmia.w	r3, {r0, r1}
    int x_msk = x.msk;
 c05bc20:	685a      	ldr	r2, [r3, #4]
    if (x.val != x_msk) {
 c05bc22:	6819      	ldr	r1, [r3, #0]
 c05bc24:	ea82 0306 	eor.w	r3, r2, r6
 c05bc28:	428b      	cmp	r3, r1
 c05bc2a:	d001      	beq.n	c05bc30 <FIH_LABEL_FIH_CALL_END_0_251+0x70>
        FIH_PANIC;
 c05bc2c:	f7f6 fe9c 	bl	c052968 <Error_Handler>
    int x_val = x.val;
 c05bc30:	682a      	ldr	r2, [r5, #0]
    if (x_val != y.val) {
 c05bc32:	6823      	ldr	r3, [r4, #0]
    volatile uint32_t delay = FIH_NEGATIVE_VALUE;
 c05bc34:	4e38      	ldr	r6, [pc, #224]	@ (c05bd18 <FIH_LABEL_FIH_CRITICAL_POINT_0_517+0x4c>)
    if (x_val != y.val) {
 c05bc36:	429a      	cmp	r2, r3
        rc1 = FIH_TRUE;
 c05bc38:	bf1c      	itt	ne
 c05bc3a:	f24c 335a 	movwne	r3, #50010	@ 0xc35a
 c05bc3e:	9304      	strne	r3, [sp, #16]
    volatile uint32_t counter = 0;
 c05bc40:	2300      	movs	r3, #0
    volatile uint32_t delay = FIH_NEGATIVE_VALUE;
 c05bc42:	9608      	str	r6, [sp, #32]
    volatile uint32_t counter = 0;
 c05bc44:	9309      	str	r3, [sp, #36]	@ 0x24
    delay = fih_delay_random();
 c05bc46:	f7ff fec0 	bl	c05b9ca <fih_delay_random>
 c05bc4a:	9008      	str	r0, [sp, #32]
    if (delay == FIH_NEGATIVE_VALUE) {
 c05bc4c:	9b08      	ldr	r3, [sp, #32]
 c05bc4e:	42b3      	cmp	r3, r6
 c05bc50:	d101      	bne.n	c05bc56 <FIH_LABEL_FIH_CALL_END_0_251+0x96>
        FIH_PANIC;
 c05bc52:	f7f6 fe89 	bl	c052968 <Error_Handler>
    delay &= 0xFF;
 c05bc56:	9b08      	ldr	r3, [sp, #32]
 c05bc58:	b2db      	uxtb	r3, r3
 c05bc5a:	9308      	str	r3, [sp, #32]
    for (i = 0; i < delay; i++) {
 c05bc5c:	2300      	movs	r3, #0
 c05bc5e:	9a08      	ldr	r2, [sp, #32]
 c05bc60:	4293      	cmp	r3, r2
 c05bc62:	f0c0 8368 	bcc.w	c05c336 <FIH_LABEL_FIH_CALL_END_0_1685+0x20c>
    uint8_t local_delay = delay;
 c05bc66:	9b08      	ldr	r3, [sp, #32]
    if (counter != local_delay) {
 c05bc68:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 c05bc6a:	b2db      	uxtb	r3, r3
 c05bc6c:	4293      	cmp	r3, r2
 c05bc6e:	d001      	beq.n	c05bc74 <FIH_LABEL_FIH_CALL_END_0_251+0xb4>
        FIH_PANIC;
 c05bc70:	f7f6 fe7a 	bl	c052968 <Error_Handler>
    int x_msk = x.msk;
 c05bc74:	686a      	ldr	r2, [r5, #4]
    if (x_msk != y.msk) {
 c05bc76:	6863      	ldr	r3, [r4, #4]
    volatile uint32_t delay = FIH_NEGATIVE_VALUE;
 c05bc78:	4c27      	ldr	r4, [pc, #156]	@ (c05bd18 <FIH_LABEL_FIH_CRITICAL_POINT_0_517+0x4c>)
    if (x_msk != y.msk) {
 c05bc7a:	429a      	cmp	r2, r3
        rc2 = FIH_TRUE;
 c05bc7c:	bf1c      	itt	ne
 c05bc7e:	f24c 335a 	movwne	r3, #50010	@ 0xc35a
 c05bc82:	9305      	strne	r3, [sp, #20]
    volatile uint32_t counter = 0;
 c05bc84:	2300      	movs	r3, #0
    volatile uint32_t delay = FIH_NEGATIVE_VALUE;
 c05bc86:	9406      	str	r4, [sp, #24]
    volatile uint32_t counter = 0;
 c05bc88:	9307      	str	r3, [sp, #28]
    delay = fih_delay_random();
 c05bc8a:	f7ff fe9e 	bl	c05b9ca <fih_delay_random>
 c05bc8e:	9006      	str	r0, [sp, #24]
    if (delay == FIH_NEGATIVE_VALUE) {
 c05bc90:	9b06      	ldr	r3, [sp, #24]
 c05bc92:	42a3      	cmp	r3, r4
 c05bc94:	d101      	bne.n	c05bc9a <FIH_LABEL_FIH_CALL_END_0_251+0xda>
        FIH_PANIC;
 c05bc96:	f7f6 fe67 	bl	c052968 <Error_Handler>
    delay &= 0xFF;
 c05bc9a:	9b06      	ldr	r3, [sp, #24]
 c05bc9c:	b2db      	uxtb	r3, r3
 c05bc9e:	9306      	str	r3, [sp, #24]
    for (i = 0; i < delay; i++) {
 c05bca0:	2300      	movs	r3, #0
 c05bca2:	9a06      	ldr	r2, [sp, #24]
 c05bca4:	4293      	cmp	r3, r2
 c05bca6:	f0c0 834b 	bcc.w	c05c340 <FIH_LABEL_FIH_CALL_END_0_1685+0x216>
    uint8_t local_delay = delay;
 c05bcaa:	9b06      	ldr	r3, [sp, #24]
    if (counter != local_delay) {
 c05bcac:	9a07      	ldr	r2, [sp, #28]
 c05bcae:	b2db      	uxtb	r3, r3
 c05bcb0:	4293      	cmp	r3, r2
 c05bcb2:	d001      	beq.n	c05bcb8 <FIH_LABEL_FIH_CALL_END_0_251+0xf8>
        FIH_PANIC;
 c05bcb4:	f7f6 fe58 	bl	c052968 <Error_Handler>
    int loc_rc1 = rc1;
 c05bcb8:	9a04      	ldr	r2, [sp, #16]
    if (loc_rc1 != rc2) {
 c05bcba:	9b05      	ldr	r3, [sp, #20]
 c05bcbc:	429a      	cmp	r2, r3
 c05bcbe:	d001      	beq.n	c05bcc4 <FIH_LABEL_FIH_CALL_END_0_251+0x104>
        FIH_PANIC;
 c05bcc0:	f7f6 fe52 	bl	c052968 <Error_Handler>
    return rc1;
 c05bcc4:	9b04      	ldr	r3, [sp, #16]
    if (fih_not_eq(fih_rc, fih_int_encode(TFM_SUCCESS))) {
 c05bcc6:	b10b      	cbz	r3, c05bccc <FIH_LABEL_FIH_CRITICAL_POINT_0_517>
        tfm_core_panic();
 c05bcc8:	f002 fd0e 	bl	c05e6e8 <tfm_core_panic>

0c05bccc <FIH_LABEL_FIH_CRITICAL_POINT_0_517>:

    /* All isolation should have been set up at this point */
    FIH_LABEL_CRITICAL_POINT();

    /* Print the TF-M version */
    SPMLOG_INFMSG("\033[1;34mBooting TFM v"VERSION_FULLSTR"\033[0m\r\n");
 c05bccc:	2120      	movs	r1, #32
 c05bcce:	4815      	ldr	r0, [pc, #84]	@ (c05bd24 <FIH_LABEL_FIH_CRITICAL_POINT_0_517+0x58>)
 c05bcd0:	f002 f96c 	bl	c05dfac <tfm_hal_output_spm_log>

    /*
     * Prioritise secure exceptions to avoid NS being able to pre-empt
     * secure SVC or SecureFault. Do it before PSA API initialization.
     */
    tfm_arch_set_secure_exception_priorities();
 c05bcd4:	f001 fbce 	bl	c05d474 <tfm_arch_set_secure_exception_priorities>

    /* Move to handler mode for further SPM initialization. */
    tfm_core_handler_mode();
 c05bcd8:	f001 fe92 	bl	c05da00 <tfm_core_handler_mode>
}
 c05bcdc:	2000      	movs	r0, #0
 c05bcde:	f50d 7d19 	add.w	sp, sp, #612	@ 0x264
 c05bce2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        counter++;
 c05bce6:	9a0b      	ldr	r2, [sp, #44]	@ 0x2c
    for (i = 0; i < delay; i++) {
 c05bce8:	3301      	adds	r3, #1
        counter++;
 c05bcea:	3201      	adds	r2, #1
 c05bcec:	920b      	str	r2, [sp, #44]	@ 0x2c
    for (i = 0; i < delay; i++) {
 c05bcee:	e72b      	b.n	c05bb48 <FIH_LABEL_FIH_CALL_START_tfm_core_init_0_80+0x34>
    plat_err = tfm_spm_hal_system_reset_cfg();
 c05bcf0:	f7f4 ffa2 	bl	c050c38 <tfm_spm_hal_system_reset_cfg>
    if (plat_err != TFM_PLAT_ERR_SUCCESS) {
 c05bcf4:	4682      	mov	sl, r0
 c05bcf6:	b1b8      	cbz	r0, c05bd28 <FIH_LABEL_FIH_CALL_START_tfm_spm_hal_init_debug_0_619>
        FIH_RET(fih_int_encode(TFM_ERROR_GENERIC));
 c05bcf8:	f7ff fe04 	bl	c05b904 <fih_cfi_decrement>
    fih_int ret = {x, x ^ _FIH_MASK_VALUE};
 c05bcfc:	231f      	movs	r3, #31
 c05bcfe:	938e      	str	r3, [sp, #568]	@ 0x238
 c05bd00:	4b06      	ldr	r3, [pc, #24]	@ (c05bd1c <FIH_LABEL_FIH_CRITICAL_POINT_0_517+0x50>)
 c05bd02:	938f      	str	r3, [sp, #572]	@ 0x23c
 c05bd04:	e9dd 018e 	ldrd	r0, r1, [sp, #568]	@ 0x238
 c05bd08:	ab66      	add	r3, sp, #408	@ 0x198
 c05bd0a:	e73d      	b.n	c05bb88 <FIH_LABEL_FIH_CALL_START_tfm_core_init_0_80+0x74>
 c05bd0c:	3003091c 	.word	0x3003091c
 c05bd10:	fef5eda5 	.word	0xfef5eda5
 c05bd14:	30030400 	.word	0x30030400
 c05bd18:	aaaa5555 	.word	0xaaaa5555
 c05bd1c:	a5c35a23 	.word	0xa5c35a23
 c05bd20:	a5c35a3c 	.word	0xa5c35a3c
 c05bd24:	0c0615cb 	.word	0x0c0615cb

0c05bd28 <FIH_LABEL_FIH_CALL_START_tfm_spm_hal_init_debug_0_619>:
    volatile uint32_t delay = FIH_NEGATIVE_VALUE;
 c05bd28:	4e6f      	ldr	r6, [pc, #444]	@ (c05bee8 <FIH_LABEL_FIH_CALL_END_0_731+0x140>)
    FIH_CALL(tfm_spm_hal_init_debug, fih_rc);
 c05bd2a:	f50d 79d4 	add.w	r9, sp, #424	@ 0x1a8
 c05bd2e:	2101      	movs	r1, #1
 c05bd30:	4648      	mov	r0, r9
 c05bd32:	f7ff fd1b 	bl	c05b76c <fih_cfi_get_and_increment>
 c05bd36:	e895 0003 	ldmia.w	r5, {r0, r1}
 c05bd3a:	e884 0003 	stmia.w	r4, {r0, r1}
 c05bd3e:	961e      	str	r6, [sp, #120]	@ 0x78
    volatile uint32_t counter = 0;
 c05bd40:	f8cd a07c 	str.w	sl, [sp, #124]	@ 0x7c
    delay = fih_delay_random();
 c05bd44:	f7ff fe41 	bl	c05b9ca <fih_delay_random>
 c05bd48:	901e      	str	r0, [sp, #120]	@ 0x78
    if (delay == FIH_NEGATIVE_VALUE) {
 c05bd4a:	9b1e      	ldr	r3, [sp, #120]	@ 0x78
 c05bd4c:	42b3      	cmp	r3, r6
 c05bd4e:	d101      	bne.n	c05bd54 <FIH_LABEL_FIH_CALL_START_tfm_spm_hal_init_debug_0_619+0x2c>
        FIH_PANIC;
 c05bd50:	f7f6 fe0a 	bl	c052968 <Error_Handler>
    delay &= 0xFF;
 c05bd54:	9b1e      	ldr	r3, [sp, #120]	@ 0x78
 c05bd56:	b2db      	uxtb	r3, r3
 c05bd58:	931e      	str	r3, [sp, #120]	@ 0x78
    for (i = 0; i < delay; i++) {
 c05bd5a:	2300      	movs	r3, #0
 c05bd5c:	9a1e      	ldr	r2, [sp, #120]	@ 0x78
 c05bd5e:	4293      	cmp	r3, r2
 c05bd60:	f0c0 80b3 	bcc.w	c05beca <FIH_LABEL_FIH_CALL_END_0_731+0x122>
    uint8_t local_delay = delay;
 c05bd64:	9b1e      	ldr	r3, [sp, #120]	@ 0x78
    if (counter != local_delay) {
 c05bd66:	9a1f      	ldr	r2, [sp, #124]	@ 0x7c
 c05bd68:	b2db      	uxtb	r3, r3
 c05bd6a:	4293      	cmp	r3, r2
 c05bd6c:	d001      	beq.n	c05bd72 <FIH_LABEL_FIH_CALL_START_tfm_spm_hal_init_debug_0_619+0x4a>
        FIH_PANIC;
 c05bd6e:	f7f6 fdfb 	bl	c052968 <Error_Handler>
 c05bd72:	ae02      	add	r6, sp, #8
 c05bd74:	4630      	mov	r0, r6
 c05bd76:	f7f5 fe79 	bl	c051a6c <tfm_spm_hal_init_debug>
 c05bd7a:	e896 0003 	ldmia.w	r6, {r0, r1}
 c05bd7e:	e884 0003 	stmia.w	r4, {r0, r1}
 c05bd82:	e899 0003 	ldmia.w	r9, {r0, r1}
 c05bd86:	f7ff fd85 	bl	c05b894 <fih_cfi_validate>
 c05bd8a:	e894 0003 	ldmia.w	r4, {r0, r1}
 c05bd8e:	ab6c      	add	r3, sp, #432	@ 0x1b0
 c05bd90:	e883 0003 	stmia.w	r3, {r0, r1}
    if (x.val != x_msk) {
 c05bd94:	f8df 9154 	ldr.w	r9, [pc, #340]	@ c05beec <FIH_LABEL_FIH_CALL_END_0_731+0x144>
    int x_msk = x.msk;
 c05bd98:	9b6d      	ldr	r3, [sp, #436]	@ 0x1b4
    if (x.val != x_msk) {
 c05bd9a:	9a6c      	ldr	r2, [sp, #432]	@ 0x1b0
 c05bd9c:	ea83 0309 	eor.w	r3, r3, r9
 c05bda0:	4293      	cmp	r3, r2
 c05bda2:	d001      	beq.n	c05bda8 <FIH_LABEL_FIH_CALL_END_0_731>
        FIH_PANIC;
 c05bda4:	f7f6 fde0 	bl	c052968 <Error_Handler>

0c05bda8 <FIH_LABEL_FIH_CALL_END_0_731>:
    fih_int ret = {x, x ^ _FIH_MASK_VALUE};
 c05bda8:	f04f 0c00 	mov.w	ip, #0
 c05bdac:	ab5c      	add	r3, sp, #368	@ 0x170
 c05bdae:	f8cd c230 	str.w	ip, [sp, #560]	@ 0x230
 c05bdb2:	f8cd 9234 	str.w	r9, [sp, #564]	@ 0x234
 c05bdb6:	e9dd 018c 	ldrd	r0, r1, [sp, #560]	@ 0x230
 c05bdba:	e883 0003 	stmia.w	r3, {r0, r1}
    return ret;
 c05bdbe:	aa96      	add	r2, sp, #600	@ 0x258
 c05bdc0:	e893 0003 	ldmia.w	r3, {r0, r1}
 c05bdc4:	e882 0003 	stmia.w	r2, {r0, r1}
 c05bdc8:	e894 0003 	ldmia.w	r4, {r0, r1}
 c05bdcc:	ab60      	add	r3, sp, #384	@ 0x180
 c05bdce:	f50d 7bbc 	add.w	fp, sp, #376	@ 0x178
 c05bdd2:	e883 0003 	stmia.w	r3, {r0, r1}
 c05bdd6:	e892 0003 	ldmia.w	r2, {r0, r1}
 c05bdda:	e88b 0003 	stmia.w	fp, {r0, r1}
    volatile int32_t rc1 = FIH_FALSE;
 c05bdde:	aa62      	add	r2, sp, #392	@ 0x188
 c05bde0:	f8cd c060 	str.w	ip, [sp, #96]	@ 0x60
    volatile int32_t rc2 = FIH_FALSE;
 c05bde4:	f8cd c064 	str.w	ip, [sp, #100]	@ 0x64
    fih_int_validate(x);
 c05bde8:	e893 0003 	ldmia.w	r3, {r0, r1}
 c05bdec:	e882 0003 	stmia.w	r2, {r0, r1}
    int x_msk = x.msk;
 c05bdf0:	9b63      	ldr	r3, [sp, #396]	@ 0x18c
    if (x.val != x_msk) {
 c05bdf2:	9a62      	ldr	r2, [sp, #392]	@ 0x188
 c05bdf4:	ea83 0309 	eor.w	r3, r3, r9
 c05bdf8:	4293      	cmp	r3, r2
 c05bdfa:	d001      	beq.n	c05be00 <FIH_LABEL_FIH_CALL_END_0_731+0x58>
        FIH_PANIC;
 c05bdfc:	f7f6 fdb4 	bl	c052968 <Error_Handler>
    fih_int_validate(y);
 c05be00:	e89b 0003 	ldmia.w	fp, {r0, r1}
 c05be04:	ab64      	add	r3, sp, #400	@ 0x190
 c05be06:	e883 0003 	stmia.w	r3, {r0, r1}
    int x_msk = x.msk;
 c05be0a:	9b65      	ldr	r3, [sp, #404]	@ 0x194
    if (x.val != x_msk) {
 c05be0c:	9a64      	ldr	r2, [sp, #400]	@ 0x190
 c05be0e:	ea83 0309 	eor.w	r3, r3, r9
 c05be12:	4293      	cmp	r3, r2
 c05be14:	d001      	beq.n	c05be1a <FIH_LABEL_FIH_CALL_END_0_731+0x72>
        FIH_PANIC;
 c05be16:	f7f6 fda7 	bl	c052968 <Error_Handler>
    int x_val = x.val;
 c05be1a:	9a60      	ldr	r2, [sp, #384]	@ 0x180
    if (x_val != y.val) {
 c05be1c:	9b5e      	ldr	r3, [sp, #376]	@ 0x178
    volatile uint32_t delay = FIH_NEGATIVE_VALUE;
 c05be1e:	f8df b0c8 	ldr.w	fp, [pc, #200]	@ c05bee8 <FIH_LABEL_FIH_CALL_END_0_731+0x140>
    if (x_val != y.val) {
 c05be22:	429a      	cmp	r2, r3
        rc1 = FIH_TRUE;
 c05be24:	bf1c      	itt	ne
 c05be26:	f24c 335a 	movwne	r3, #50010	@ 0xc35a
 c05be2a:	9318      	strne	r3, [sp, #96]	@ 0x60
    volatile uint32_t counter = 0;
 c05be2c:	2300      	movs	r3, #0
    volatile uint32_t delay = FIH_NEGATIVE_VALUE;
 c05be2e:	f8cd b070 	str.w	fp, [sp, #112]	@ 0x70
    volatile uint32_t counter = 0;
 c05be32:	931d      	str	r3, [sp, #116]	@ 0x74
    delay = fih_delay_random();
 c05be34:	f7ff fdc9 	bl	c05b9ca <fih_delay_random>
 c05be38:	901c      	str	r0, [sp, #112]	@ 0x70
    if (delay == FIH_NEGATIVE_VALUE) {
 c05be3a:	9b1c      	ldr	r3, [sp, #112]	@ 0x70
 c05be3c:	455b      	cmp	r3, fp
 c05be3e:	d101      	bne.n	c05be44 <FIH_LABEL_FIH_CALL_END_0_731+0x9c>
        FIH_PANIC;
 c05be40:	f7f6 fd92 	bl	c052968 <Error_Handler>
    delay &= 0xFF;
 c05be44:	9b1c      	ldr	r3, [sp, #112]	@ 0x70
 c05be46:	b2db      	uxtb	r3, r3
 c05be48:	931c      	str	r3, [sp, #112]	@ 0x70
    for (i = 0; i < delay; i++) {
 c05be4a:	2300      	movs	r3, #0
 c05be4c:	9a1c      	ldr	r2, [sp, #112]	@ 0x70
 c05be4e:	4293      	cmp	r3, r2
 c05be50:	d340      	bcc.n	c05bed4 <FIH_LABEL_FIH_CALL_END_0_731+0x12c>
    uint8_t local_delay = delay;
 c05be52:	9b1c      	ldr	r3, [sp, #112]	@ 0x70
    if (counter != local_delay) {
 c05be54:	9a1d      	ldr	r2, [sp, #116]	@ 0x74
 c05be56:	b2db      	uxtb	r3, r3
 c05be58:	4293      	cmp	r3, r2
 c05be5a:	d001      	beq.n	c05be60 <FIH_LABEL_FIH_CALL_END_0_731+0xb8>
        FIH_PANIC;
 c05be5c:	f7f6 fd84 	bl	c052968 <Error_Handler>
    int x_msk = x.msk;
 c05be60:	9a61      	ldr	r2, [sp, #388]	@ 0x184
    if (x_msk != y.msk) {
 c05be62:	9b5f      	ldr	r3, [sp, #380]	@ 0x17c
    volatile uint32_t delay = FIH_NEGATIVE_VALUE;
 c05be64:	f8df b080 	ldr.w	fp, [pc, #128]	@ c05bee8 <FIH_LABEL_FIH_CALL_END_0_731+0x140>
    if (x_msk != y.msk) {
 c05be68:	429a      	cmp	r2, r3
        rc2 = FIH_TRUE;
 c05be6a:	bf1c      	itt	ne
 c05be6c:	f24c 335a 	movwne	r3, #50010	@ 0xc35a
 c05be70:	9319      	strne	r3, [sp, #100]	@ 0x64
    volatile uint32_t counter = 0;
 c05be72:	2300      	movs	r3, #0
    volatile uint32_t delay = FIH_NEGATIVE_VALUE;
 c05be74:	f8cd b068 	str.w	fp, [sp, #104]	@ 0x68
    volatile uint32_t counter = 0;
 c05be78:	931b      	str	r3, [sp, #108]	@ 0x6c
    delay = fih_delay_random();
 c05be7a:	f7ff fda6 	bl	c05b9ca <fih_delay_random>
 c05be7e:	901a      	str	r0, [sp, #104]	@ 0x68
    if (delay == FIH_NEGATIVE_VALUE) {
 c05be80:	9b1a      	ldr	r3, [sp, #104]	@ 0x68
 c05be82:	455b      	cmp	r3, fp
 c05be84:	d101      	bne.n	c05be8a <FIH_LABEL_FIH_CALL_END_0_731+0xe2>
        FIH_PANIC;
 c05be86:	f7f6 fd6f 	bl	c052968 <Error_Handler>
    delay &= 0xFF;
 c05be8a:	9b1a      	ldr	r3, [sp, #104]	@ 0x68
 c05be8c:	b2db      	uxtb	r3, r3
 c05be8e:	931a      	str	r3, [sp, #104]	@ 0x68
    for (i = 0; i < delay; i++) {
 c05be90:	2300      	movs	r3, #0
 c05be92:	9a1a      	ldr	r2, [sp, #104]	@ 0x68
 c05be94:	4293      	cmp	r3, r2
 c05be96:	d322      	bcc.n	c05bede <FIH_LABEL_FIH_CALL_END_0_731+0x136>
    uint8_t local_delay = delay;
 c05be98:	9b1a      	ldr	r3, [sp, #104]	@ 0x68
    if (counter != local_delay) {
 c05be9a:	9a1b      	ldr	r2, [sp, #108]	@ 0x6c
 c05be9c:	b2db      	uxtb	r3, r3
 c05be9e:	4293      	cmp	r3, r2
 c05bea0:	d001      	beq.n	c05bea6 <FIH_LABEL_FIH_CALL_END_0_731+0xfe>
        FIH_PANIC;
 c05bea2:	f7f6 fd61 	bl	c052968 <Error_Handler>
    int loc_rc1 = rc1;
 c05bea6:	9a18      	ldr	r2, [sp, #96]	@ 0x60
    if (loc_rc1 != rc2) {
 c05bea8:	9b19      	ldr	r3, [sp, #100]	@ 0x64
 c05beaa:	429a      	cmp	r2, r3
 c05beac:	d001      	beq.n	c05beb2 <FIH_LABEL_FIH_CALL_END_0_731+0x10a>
        FIH_PANIC;
 c05beae:	f7f6 fd5b 	bl	c052968 <Error_Handler>
    return rc1;
 c05beb2:	9b18      	ldr	r3, [sp, #96]	@ 0x60
    if (fih_not_eq(fih_rc, fih_int_encode(TFM_PLAT_ERR_SUCCESS))) {
 c05beb4:	b1f3      	cbz	r3, c05bef4 <FIH_LABEL_FIH_CALL_END_0_731+0x14c>
        FIH_RET(fih_int_encode(TFM_ERROR_GENERIC));
 c05beb6:	f7ff fd25 	bl	c05b904 <fih_cfi_decrement>
    fih_int ret = {x, x ^ _FIH_MASK_VALUE};
 c05beba:	231f      	movs	r3, #31
 c05bebc:	938a      	str	r3, [sp, #552]	@ 0x228
 c05bebe:	4b0c      	ldr	r3, [pc, #48]	@ (c05bef0 <FIH_LABEL_FIH_CALL_END_0_731+0x148>)
 c05bec0:	938b      	str	r3, [sp, #556]	@ 0x22c
 c05bec2:	e9dd 018a 	ldrd	r0, r1, [sp, #552]	@ 0x228
 c05bec6:	ab5a      	add	r3, sp, #360	@ 0x168
 c05bec8:	e65e      	b.n	c05bb88 <FIH_LABEL_FIH_CALL_START_tfm_core_init_0_80+0x74>
        counter++;
 c05beca:	9a1f      	ldr	r2, [sp, #124]	@ 0x7c
    for (i = 0; i < delay; i++) {
 c05becc:	3301      	adds	r3, #1
        counter++;
 c05bece:	3201      	adds	r2, #1
 c05bed0:	921f      	str	r2, [sp, #124]	@ 0x7c
    for (i = 0; i < delay; i++) {
 c05bed2:	e743      	b.n	c05bd5c <FIH_LABEL_FIH_CALL_START_tfm_spm_hal_init_debug_0_619+0x34>
        counter++;
 c05bed4:	9a1d      	ldr	r2, [sp, #116]	@ 0x74
    for (i = 0; i < delay; i++) {
 c05bed6:	3301      	adds	r3, #1
        counter++;
 c05bed8:	3201      	adds	r2, #1
 c05beda:	921d      	str	r2, [sp, #116]	@ 0x74
    for (i = 0; i < delay; i++) {
 c05bedc:	e7b6      	b.n	c05be4c <FIH_LABEL_FIH_CALL_END_0_731+0xa4>
        counter++;
 c05bede:	9a1b      	ldr	r2, [sp, #108]	@ 0x6c
    for (i = 0; i < delay; i++) {
 c05bee0:	3301      	adds	r3, #1
        counter++;
 c05bee2:	3201      	adds	r2, #1
 c05bee4:	921b      	str	r2, [sp, #108]	@ 0x6c
    for (i = 0; i < delay; i++) {
 c05bee6:	e7d4      	b.n	c05be92 <FIH_LABEL_FIH_CALL_END_0_731+0xea>
 c05bee8:	aaaa5555 	.word	0xaaaa5555
 c05beec:	a5c35a3c 	.word	0xa5c35a3c
 c05bef0:	a5c35a23 	.word	0xa5c35a23
 c05bef4:	9301      	str	r3, [sp, #4]

0c05bef6 <FIH_LABEL_FIH_CALL_START_tfm_hal_set_up_static_boundaries_0_1098>:
    FIH_CALL(tfm_hal_set_up_static_boundaries, fih_rc);
 c05bef6:	f50d 7bdc 	add.w	fp, sp, #440	@ 0x1b8
 c05befa:	2101      	movs	r1, #1
 c05befc:	4658      	mov	r0, fp
 c05befe:	f7ff fc35 	bl	c05b76c <fih_cfi_get_and_increment>
 c05bf02:	e895 0003 	ldmia.w	r5, {r0, r1}
    volatile uint32_t counter = 0;
 c05bf06:	9b01      	ldr	r3, [sp, #4]
    volatile uint32_t delay = FIH_NEGATIVE_VALUE;
 c05bf08:	4d66      	ldr	r5, [pc, #408]	@ (c05c0a4 <FIH_LABEL_FIH_CALL_END_0_1207+0x134>)
 c05bf0a:	e884 0003 	stmia.w	r4, {r0, r1}
 c05bf0e:	9520      	str	r5, [sp, #128]	@ 0x80
    volatile uint32_t counter = 0;
 c05bf10:	9321      	str	r3, [sp, #132]	@ 0x84
    delay = fih_delay_random();
 c05bf12:	f7ff fd5a 	bl	c05b9ca <fih_delay_random>
 c05bf16:	9020      	str	r0, [sp, #128]	@ 0x80
    if (delay == FIH_NEGATIVE_VALUE) {
 c05bf18:	9b20      	ldr	r3, [sp, #128]	@ 0x80
 c05bf1a:	42ab      	cmp	r3, r5
 c05bf1c:	d101      	bne.n	c05bf22 <FIH_LABEL_FIH_CALL_START_tfm_hal_set_up_static_boundaries_0_1098+0x2c>
        FIH_PANIC;
 c05bf1e:	f7f6 fd23 	bl	c052968 <Error_Handler>
    delay &= 0xFF;
 c05bf22:	9b20      	ldr	r3, [sp, #128]	@ 0x80
 c05bf24:	b2db      	uxtb	r3, r3
 c05bf26:	9320      	str	r3, [sp, #128]	@ 0x80
    for (i = 0; i < delay; i++) {
 c05bf28:	2300      	movs	r3, #0
 c05bf2a:	9a20      	ldr	r2, [sp, #128]	@ 0x80
 c05bf2c:	4293      	cmp	r3, r2
 c05bf2e:	f0c0 80aa 	bcc.w	c05c086 <FIH_LABEL_FIH_CALL_END_0_1207+0x116>
    uint8_t local_delay = delay;
 c05bf32:	9b20      	ldr	r3, [sp, #128]	@ 0x80
    if (counter != local_delay) {
 c05bf34:	9a21      	ldr	r2, [sp, #132]	@ 0x84
 c05bf36:	b2db      	uxtb	r3, r3
 c05bf38:	4293      	cmp	r3, r2
 c05bf3a:	d001      	beq.n	c05bf40 <FIH_LABEL_FIH_CALL_START_tfm_hal_set_up_static_boundaries_0_1098+0x4a>
        FIH_PANIC;
 c05bf3c:	f7f6 fd14 	bl	c052968 <Error_Handler>
 c05bf40:	4630      	mov	r0, r6
 c05bf42:	f7f5 feb7 	bl	c051cb4 <tfm_hal_set_up_static_boundaries>
 c05bf46:	e896 0003 	ldmia.w	r6, {r0, r1}
 c05bf4a:	e884 0003 	stmia.w	r4, {r0, r1}
 c05bf4e:	e89b 0003 	ldmia.w	fp, {r0, r1}
 c05bf52:	f7ff fc9f 	bl	c05b894 <fih_cfi_validate>
 c05bf56:	e894 0003 	ldmia.w	r4, {r0, r1}
 c05bf5a:	ab70      	add	r3, sp, #448	@ 0x1c0
 c05bf5c:	e883 0003 	stmia.w	r3, {r0, r1}
    int x_msk = x.msk;
 c05bf60:	9b71      	ldr	r3, [sp, #452]	@ 0x1c4
    if (x.val != x_msk) {
 c05bf62:	9a70      	ldr	r2, [sp, #448]	@ 0x1c0
 c05bf64:	ea83 0309 	eor.w	r3, r3, r9
 c05bf68:	4293      	cmp	r3, r2
 c05bf6a:	d001      	beq.n	c05bf70 <FIH_LABEL_FIH_CALL_END_0_1207>
        FIH_PANIC;
 c05bf6c:	f7f6 fcfc 	bl	c052968 <Error_Handler>

0c05bf70 <FIH_LABEL_FIH_CALL_END_0_1207>:
    fih_int ret = {x, x ^ _FIH_MASK_VALUE};
 c05bf70:	2600      	movs	r6, #0
 c05bf72:	aa50      	add	r2, sp, #320	@ 0x140
 c05bf74:	9688      	str	r6, [sp, #544]	@ 0x220
 c05bf76:	f8cd 9224 	str.w	r9, [sp, #548]	@ 0x224
 c05bf7a:	e9dd 0188 	ldrd	r0, r1, [sp, #544]	@ 0x220
 c05bf7e:	e882 0003 	stmia.w	r2, {r0, r1}
    return ret;
 c05bf82:	ab94      	add	r3, sp, #592	@ 0x250
 c05bf84:	e892 0003 	ldmia.w	r2, {r0, r1}
 c05bf88:	e883 0003 	stmia.w	r3, {r0, r1}
 c05bf8c:	e894 0003 	ldmia.w	r4, {r0, r1}
 c05bf90:	ad54      	add	r5, sp, #336	@ 0x150
 c05bf92:	ac52      	add	r4, sp, #328	@ 0x148
 c05bf94:	e885 0003 	stmia.w	r5, {r0, r1}
 c05bf98:	e893 0003 	ldmia.w	r3, {r0, r1}
 c05bf9c:	e884 0003 	stmia.w	r4, {r0, r1}
    volatile int32_t rc1 = FIH_FALSE;
 c05bfa0:	ab56      	add	r3, sp, #344	@ 0x158
 c05bfa2:	9612      	str	r6, [sp, #72]	@ 0x48
    volatile int32_t rc2 = FIH_FALSE;
 c05bfa4:	9613      	str	r6, [sp, #76]	@ 0x4c
    fih_int_validate(x);
 c05bfa6:	e895 0003 	ldmia.w	r5, {r0, r1}
 c05bfaa:	e883 0003 	stmia.w	r3, {r0, r1}
    int x_msk = x.msk;
 c05bfae:	685a      	ldr	r2, [r3, #4]
    if (x.val != x_msk) {
 c05bfb0:	6819      	ldr	r1, [r3, #0]
 c05bfb2:	ea82 0309 	eor.w	r3, r2, r9
 c05bfb6:	428b      	cmp	r3, r1
 c05bfb8:	d001      	beq.n	c05bfbe <FIH_LABEL_FIH_CALL_END_0_1207+0x4e>
        FIH_PANIC;
 c05bfba:	f7f6 fcd5 	bl	c052968 <Error_Handler>
    fih_int_validate(y);
 c05bfbe:	e894 0003 	ldmia.w	r4, {r0, r1}
 c05bfc2:	ab58      	add	r3, sp, #352	@ 0x160
 c05bfc4:	e883 0003 	stmia.w	r3, {r0, r1}
    int x_msk = x.msk;
 c05bfc8:	685a      	ldr	r2, [r3, #4]
    if (x.val != x_msk) {
 c05bfca:	6819      	ldr	r1, [r3, #0]
 c05bfcc:	ea82 0309 	eor.w	r3, r2, r9
 c05bfd0:	428b      	cmp	r3, r1
 c05bfd2:	d001      	beq.n	c05bfd8 <FIH_LABEL_FIH_CALL_END_0_1207+0x68>
        FIH_PANIC;
 c05bfd4:	f7f6 fcc8 	bl	c052968 <Error_Handler>
    int x_val = x.val;
 c05bfd8:	682a      	ldr	r2, [r5, #0]
    if (x_val != y.val) {
 c05bfda:	6823      	ldr	r3, [r4, #0]
    volatile uint32_t delay = FIH_NEGATIVE_VALUE;
 c05bfdc:	4e31      	ldr	r6, [pc, #196]	@ (c05c0a4 <FIH_LABEL_FIH_CALL_END_0_1207+0x134>)
    if (x_val != y.val) {
 c05bfde:	429a      	cmp	r2, r3
        rc1 = FIH_TRUE;
 c05bfe0:	bf1c      	itt	ne
 c05bfe2:	f24c 335a 	movwne	r3, #50010	@ 0xc35a
 c05bfe6:	9312      	strne	r3, [sp, #72]	@ 0x48
    volatile uint32_t counter = 0;
 c05bfe8:	2300      	movs	r3, #0
    volatile uint32_t delay = FIH_NEGATIVE_VALUE;
 c05bfea:	9616      	str	r6, [sp, #88]	@ 0x58
    volatile uint32_t counter = 0;
 c05bfec:	9317      	str	r3, [sp, #92]	@ 0x5c
    delay = fih_delay_random();
 c05bfee:	f7ff fcec 	bl	c05b9ca <fih_delay_random>
 c05bff2:	9016      	str	r0, [sp, #88]	@ 0x58
    if (delay == FIH_NEGATIVE_VALUE) {
 c05bff4:	9b16      	ldr	r3, [sp, #88]	@ 0x58
 c05bff6:	42b3      	cmp	r3, r6
 c05bff8:	d101      	bne.n	c05bffe <FIH_LABEL_FIH_CALL_END_0_1207+0x8e>
        FIH_PANIC;
 c05bffa:	f7f6 fcb5 	bl	c052968 <Error_Handler>
    delay &= 0xFF;
 c05bffe:	9b16      	ldr	r3, [sp, #88]	@ 0x58
 c05c000:	b2db      	uxtb	r3, r3
 c05c002:	9316      	str	r3, [sp, #88]	@ 0x58
    for (i = 0; i < delay; i++) {
 c05c004:	2300      	movs	r3, #0
 c05c006:	9a16      	ldr	r2, [sp, #88]	@ 0x58
 c05c008:	4293      	cmp	r3, r2
 c05c00a:	d341      	bcc.n	c05c090 <FIH_LABEL_FIH_CALL_END_0_1207+0x120>
    uint8_t local_delay = delay;
 c05c00c:	9b16      	ldr	r3, [sp, #88]	@ 0x58
    if (counter != local_delay) {
 c05c00e:	9a17      	ldr	r2, [sp, #92]	@ 0x5c
 c05c010:	b2db      	uxtb	r3, r3
 c05c012:	4293      	cmp	r3, r2
 c05c014:	d001      	beq.n	c05c01a <FIH_LABEL_FIH_CALL_END_0_1207+0xaa>
        FIH_PANIC;
 c05c016:	f7f6 fca7 	bl	c052968 <Error_Handler>
    int x_msk = x.msk;
 c05c01a:	686a      	ldr	r2, [r5, #4]
    if (x_msk != y.msk) {
 c05c01c:	6863      	ldr	r3, [r4, #4]
    volatile uint32_t delay = FIH_NEGATIVE_VALUE;
 c05c01e:	4c21      	ldr	r4, [pc, #132]	@ (c05c0a4 <FIH_LABEL_FIH_CALL_END_0_1207+0x134>)
    if (x_msk != y.msk) {
 c05c020:	429a      	cmp	r2, r3
        rc2 = FIH_TRUE;
 c05c022:	bf1c      	itt	ne
 c05c024:	f24c 335a 	movwne	r3, #50010	@ 0xc35a
 c05c028:	9313      	strne	r3, [sp, #76]	@ 0x4c
    volatile uint32_t counter = 0;
 c05c02a:	2300      	movs	r3, #0
    volatile uint32_t delay = FIH_NEGATIVE_VALUE;
 c05c02c:	9414      	str	r4, [sp, #80]	@ 0x50
    volatile uint32_t counter = 0;
 c05c02e:	9315      	str	r3, [sp, #84]	@ 0x54
    delay = fih_delay_random();
 c05c030:	f7ff fccb 	bl	c05b9ca <fih_delay_random>
 c05c034:	9014      	str	r0, [sp, #80]	@ 0x50
    if (delay == FIH_NEGATIVE_VALUE) {
 c05c036:	9b14      	ldr	r3, [sp, #80]	@ 0x50
 c05c038:	42a3      	cmp	r3, r4
 c05c03a:	d101      	bne.n	c05c040 <FIH_LABEL_FIH_CALL_END_0_1207+0xd0>
        FIH_PANIC;
 c05c03c:	f7f6 fc94 	bl	c052968 <Error_Handler>
    delay &= 0xFF;
 c05c040:	9b14      	ldr	r3, [sp, #80]	@ 0x50
 c05c042:	b2db      	uxtb	r3, r3
 c05c044:	9314      	str	r3, [sp, #80]	@ 0x50
    for (i = 0; i < delay; i++) {
 c05c046:	2300      	movs	r3, #0
 c05c048:	9a14      	ldr	r2, [sp, #80]	@ 0x50
 c05c04a:	4293      	cmp	r3, r2
 c05c04c:	d325      	bcc.n	c05c09a <FIH_LABEL_FIH_CALL_END_0_1207+0x12a>
    uint8_t local_delay = delay;
 c05c04e:	9b14      	ldr	r3, [sp, #80]	@ 0x50
    if (counter != local_delay) {
 c05c050:	9a15      	ldr	r2, [sp, #84]	@ 0x54
 c05c052:	b2db      	uxtb	r3, r3
 c05c054:	4293      	cmp	r3, r2
 c05c056:	d001      	beq.n	c05c05c <FIH_LABEL_FIH_CALL_END_0_1207+0xec>
        FIH_PANIC;
 c05c058:	f7f6 fc86 	bl	c052968 <Error_Handler>
    int loc_rc1 = rc1;
 c05c05c:	9a12      	ldr	r2, [sp, #72]	@ 0x48
    if (loc_rc1 != rc2) {
 c05c05e:	9b13      	ldr	r3, [sp, #76]	@ 0x4c
 c05c060:	429a      	cmp	r2, r3
 c05c062:	d001      	beq.n	c05c068 <FIH_LABEL_FIH_CALL_END_0_1207+0xf8>
        FIH_PANIC;
 c05c064:	f7f6 fc80 	bl	c052968 <Error_Handler>
    return rc1;
 c05c068:	f8dd 9048 	ldr.w	r9, [sp, #72]	@ 0x48
    if (fih_not_eq(fih_rc, fih_int_encode(TFM_HAL_SUCCESS))) {
 c05c06c:	f1b9 0f00 	cmp.w	r9, #0
 c05c070:	d01c      	beq.n	c05c0ac <FIH_LABEL_FIH_CALL_START_tfm_spm_hal_verify_isolation_hw_0_1572>
        FIH_RET(fih_int_encode(TFM_ERROR_GENERIC));
 c05c072:	f7ff fc47 	bl	c05b904 <fih_cfi_decrement>
    fih_int ret = {x, x ^ _FIH_MASK_VALUE};
 c05c076:	231f      	movs	r3, #31
 c05c078:	9386      	str	r3, [sp, #536]	@ 0x218
 c05c07a:	4b0b      	ldr	r3, [pc, #44]	@ (c05c0a8 <FIH_LABEL_FIH_CALL_END_0_1207+0x138>)
 c05c07c:	9387      	str	r3, [sp, #540]	@ 0x21c
 c05c07e:	e9dd 0186 	ldrd	r0, r1, [sp, #536]	@ 0x218
 c05c082:	ab4e      	add	r3, sp, #312	@ 0x138
 c05c084:	e580      	b.n	c05bb88 <FIH_LABEL_FIH_CALL_START_tfm_core_init_0_80+0x74>
        counter++;
 c05c086:	9a21      	ldr	r2, [sp, #132]	@ 0x84
    for (i = 0; i < delay; i++) {
 c05c088:	3301      	adds	r3, #1
        counter++;
 c05c08a:	3201      	adds	r2, #1
 c05c08c:	9221      	str	r2, [sp, #132]	@ 0x84
    for (i = 0; i < delay; i++) {
 c05c08e:	e74c      	b.n	c05bf2a <FIH_LABEL_FIH_CALL_START_tfm_hal_set_up_static_boundaries_0_1098+0x34>
        counter++;
 c05c090:	9a17      	ldr	r2, [sp, #92]	@ 0x5c
    for (i = 0; i < delay; i++) {
 c05c092:	3301      	adds	r3, #1
        counter++;
 c05c094:	3201      	adds	r2, #1
 c05c096:	9217      	str	r2, [sp, #92]	@ 0x5c
    for (i = 0; i < delay; i++) {
 c05c098:	e7b5      	b.n	c05c006 <FIH_LABEL_FIH_CALL_END_0_1207+0x96>
        counter++;
 c05c09a:	9a15      	ldr	r2, [sp, #84]	@ 0x54
    for (i = 0; i < delay; i++) {
 c05c09c:	3301      	adds	r3, #1
        counter++;
 c05c09e:	3201      	adds	r2, #1
 c05c0a0:	9215      	str	r2, [sp, #84]	@ 0x54
    for (i = 0; i < delay; i++) {
 c05c0a2:	e7d1      	b.n	c05c048 <FIH_LABEL_FIH_CALL_END_0_1207+0xd8>
 c05c0a4:	aaaa5555 	.word	0xaaaa5555
 c05c0a8:	a5c35a23 	.word	0xa5c35a23

0c05c0ac <FIH_LABEL_FIH_CALL_START_tfm_spm_hal_verify_isolation_hw_0_1572>:
    FIH_CALL(tfm_spm_hal_verify_isolation_hw, fih_rc);
 c05c0ac:	ad72      	add	r5, sp, #456	@ 0x1c8
 c05c0ae:	2101      	movs	r1, #1
 c05c0b0:	4628      	mov	r0, r5
 c05c0b2:	f7ff fb5b 	bl	c05b76c <fih_cfi_get_and_increment>
    volatile uint32_t delay = FIH_NEGATIVE_VALUE;
 c05c0b6:	4ea5      	ldr	r6, [pc, #660]	@ (c05c34c <FIH_LABEL_FIH_CALL_END_0_1685+0x222>)
 c05c0b8:	4ba5      	ldr	r3, [pc, #660]	@ (c05c350 <FIH_LABEL_FIH_CALL_END_0_1685+0x226>)
 c05c0ba:	ac36      	add	r4, sp, #216	@ 0xd8
 c05c0bc:	e893 0003 	ldmia.w	r3, {r0, r1}
 c05c0c0:	e884 0003 	stmia.w	r4, {r0, r1}
 c05c0c4:	9622      	str	r6, [sp, #136]	@ 0x88
    volatile uint32_t counter = 0;
 c05c0c6:	f8cd 908c 	str.w	r9, [sp, #140]	@ 0x8c
    delay = fih_delay_random();
 c05c0ca:	f7ff fc7e 	bl	c05b9ca <fih_delay_random>
 c05c0ce:	9022      	str	r0, [sp, #136]	@ 0x88
    if (delay == FIH_NEGATIVE_VALUE) {
 c05c0d0:	9b22      	ldr	r3, [sp, #136]	@ 0x88
 c05c0d2:	42b3      	cmp	r3, r6
 c05c0d4:	d101      	bne.n	c05c0da <FIH_LABEL_FIH_CALL_START_tfm_spm_hal_verify_isolation_hw_0_1572+0x2e>
        FIH_PANIC;
 c05c0d6:	f7f6 fc47 	bl	c052968 <Error_Handler>
    delay &= 0xFF;
 c05c0da:	9b22      	ldr	r3, [sp, #136]	@ 0x88
 c05c0dc:	b2db      	uxtb	r3, r3
 c05c0de:	9322      	str	r3, [sp, #136]	@ 0x88
    for (i = 0; i < delay; i++) {
 c05c0e0:	2300      	movs	r3, #0
 c05c0e2:	9a22      	ldr	r2, [sp, #136]	@ 0x88
 c05c0e4:	4293      	cmp	r3, r2
 c05c0e6:	f0c0 80b1 	bcc.w	c05c24c <FIH_LABEL_FIH_CALL_END_0_1685+0x122>
    uint8_t local_delay = delay;
 c05c0ea:	9b22      	ldr	r3, [sp, #136]	@ 0x88
    if (counter != local_delay) {
 c05c0ec:	9a23      	ldr	r2, [sp, #140]	@ 0x8c
 c05c0ee:	b2db      	uxtb	r3, r3
 c05c0f0:	4293      	cmp	r3, r2
 c05c0f2:	d001      	beq.n	c05c0f8 <FIH_LABEL_FIH_CALL_START_tfm_spm_hal_verify_isolation_hw_0_1572+0x4c>
        FIH_PANIC;
 c05c0f4:	f7f6 fc38 	bl	c052968 <Error_Handler>
 c05c0f8:	ae02      	add	r6, sp, #8
 c05c0fa:	4630      	mov	r0, r6
 c05c0fc:	f7f5 fcce 	bl	c051a9c <tfm_spm_hal_verify_isolation_hw>
 c05c100:	e896 0003 	ldmia.w	r6, {r0, r1}
 c05c104:	e884 0003 	stmia.w	r4, {r0, r1}
 c05c108:	e895 0003 	ldmia.w	r5, {r0, r1}
 c05c10c:	f7ff fbc2 	bl	c05b894 <fih_cfi_validate>
 c05c110:	e894 0003 	ldmia.w	r4, {r0, r1}
 c05c114:	ab74      	add	r3, sp, #464	@ 0x1d0
 c05c116:	e883 0003 	stmia.w	r3, {r0, r1}
    if (x.val != x_msk) {
 c05c11a:	4e8e      	ldr	r6, [pc, #568]	@ (c05c354 <FIH_LABEL_FIH_CALL_END_0_1685+0x22a>)
    int x_msk = x.msk;
 c05c11c:	9b75      	ldr	r3, [sp, #468]	@ 0x1d4
    if (x.val != x_msk) {
 c05c11e:	9a74      	ldr	r2, [sp, #464]	@ 0x1d0
 c05c120:	4073      	eors	r3, r6
 c05c122:	4293      	cmp	r3, r2
 c05c124:	d001      	beq.n	c05c12a <FIH_LABEL_FIH_CALL_END_0_1685>
        FIH_PANIC;
 c05c126:	f7f6 fc1f 	bl	c052968 <Error_Handler>

0c05c12a <FIH_LABEL_FIH_CALL_END_0_1685>:
    fih_int ret = {x, x ^ _FIH_MASK_VALUE};
 c05c12a:	f04f 0c00 	mov.w	ip, #0
 c05c12e:	aa44      	add	r2, sp, #272	@ 0x110
 c05c130:	f8cd c210 	str.w	ip, [sp, #528]	@ 0x210
 c05c134:	9685      	str	r6, [sp, #532]	@ 0x214
 c05c136:	e9dd 0184 	ldrd	r0, r1, [sp, #528]	@ 0x210
 c05c13a:	e882 0003 	stmia.w	r2, {r0, r1}
    return ret;
 c05c13e:	ab92      	add	r3, sp, #584	@ 0x248
 c05c140:	e892 0003 	ldmia.w	r2, {r0, r1}
 c05c144:	e883 0003 	stmia.w	r3, {r0, r1}
 c05c148:	e894 0003 	ldmia.w	r4, {r0, r1}
 c05c14c:	ad48      	add	r5, sp, #288	@ 0x120
 c05c14e:	ac46      	add	r4, sp, #280	@ 0x118
 c05c150:	e885 0003 	stmia.w	r5, {r0, r1}
 c05c154:	e893 0003 	ldmia.w	r3, {r0, r1}
 c05c158:	e884 0003 	stmia.w	r4, {r0, r1}
    volatile int32_t rc1 = FIH_FALSE;
 c05c15c:	ab4a      	add	r3, sp, #296	@ 0x128
 c05c15e:	f8cd c030 	str.w	ip, [sp, #48]	@ 0x30
    volatile int32_t rc2 = FIH_FALSE;
 c05c162:	f8cd c034 	str.w	ip, [sp, #52]	@ 0x34
    fih_int_validate(x);
 c05c166:	e895 0003 	ldmia.w	r5, {r0, r1}
 c05c16a:	e883 0003 	stmia.w	r3, {r0, r1}
    int x_msk = x.msk;
 c05c16e:	685a      	ldr	r2, [r3, #4]
    if (x.val != x_msk) {
 c05c170:	6819      	ldr	r1, [r3, #0]
 c05c172:	ea82 0306 	eor.w	r3, r2, r6
 c05c176:	428b      	cmp	r3, r1
 c05c178:	d001      	beq.n	c05c17e <FIH_LABEL_FIH_CALL_END_0_1685+0x54>
        FIH_PANIC;
 c05c17a:	f7f6 fbf5 	bl	c052968 <Error_Handler>
    fih_int_validate(y);
 c05c17e:	e894 0003 	ldmia.w	r4, {r0, r1}
 c05c182:	ab4c      	add	r3, sp, #304	@ 0x130
 c05c184:	e883 0003 	stmia.w	r3, {r0, r1}
    int x_msk = x.msk;
 c05c188:	685a      	ldr	r2, [r3, #4]
    if (x.val != x_msk) {
 c05c18a:	6819      	ldr	r1, [r3, #0]
 c05c18c:	ea82 0306 	eor.w	r3, r2, r6
 c05c190:	428b      	cmp	r3, r1
 c05c192:	d001      	beq.n	c05c198 <FIH_LABEL_FIH_CALL_END_0_1685+0x6e>
        FIH_PANIC;
 c05c194:	f7f6 fbe8 	bl	c052968 <Error_Handler>
    int x_val = x.val;
 c05c198:	682a      	ldr	r2, [r5, #0]
    if (x_val != y.val) {
 c05c19a:	6823      	ldr	r3, [r4, #0]
    volatile uint32_t delay = FIH_NEGATIVE_VALUE;
 c05c19c:	f8df 91ac 	ldr.w	r9, [pc, #428]	@ c05c34c <FIH_LABEL_FIH_CALL_END_0_1685+0x222>
    if (x_val != y.val) {
 c05c1a0:	429a      	cmp	r2, r3
        rc1 = FIH_TRUE;
 c05c1a2:	bf1c      	itt	ne
 c05c1a4:	f24c 335a 	movwne	r3, #50010	@ 0xc35a
 c05c1a8:	930c      	strne	r3, [sp, #48]	@ 0x30
    volatile uint32_t counter = 0;
 c05c1aa:	2300      	movs	r3, #0
    volatile uint32_t delay = FIH_NEGATIVE_VALUE;
 c05c1ac:	f8cd 9040 	str.w	r9, [sp, #64]	@ 0x40
    volatile uint32_t counter = 0;
 c05c1b0:	9311      	str	r3, [sp, #68]	@ 0x44
    delay = fih_delay_random();
 c05c1b2:	f7ff fc0a 	bl	c05b9ca <fih_delay_random>
 c05c1b6:	9010      	str	r0, [sp, #64]	@ 0x40
    if (delay == FIH_NEGATIVE_VALUE) {
 c05c1b8:	9b10      	ldr	r3, [sp, #64]	@ 0x40
 c05c1ba:	454b      	cmp	r3, r9
 c05c1bc:	d101      	bne.n	c05c1c2 <FIH_LABEL_FIH_CALL_END_0_1685+0x98>
        FIH_PANIC;
 c05c1be:	f7f6 fbd3 	bl	c052968 <Error_Handler>
    delay &= 0xFF;
 c05c1c2:	9b10      	ldr	r3, [sp, #64]	@ 0x40
 c05c1c4:	b2db      	uxtb	r3, r3
 c05c1c6:	9310      	str	r3, [sp, #64]	@ 0x40
    for (i = 0; i < delay; i++) {
 c05c1c8:	2300      	movs	r3, #0
 c05c1ca:	9a10      	ldr	r2, [sp, #64]	@ 0x40
 c05c1cc:	4293      	cmp	r3, r2
 c05c1ce:	d342      	bcc.n	c05c256 <FIH_LABEL_FIH_CALL_END_0_1685+0x12c>
    uint8_t local_delay = delay;
 c05c1d0:	9b10      	ldr	r3, [sp, #64]	@ 0x40
    if (counter != local_delay) {
 c05c1d2:	9a11      	ldr	r2, [sp, #68]	@ 0x44
 c05c1d4:	b2db      	uxtb	r3, r3
 c05c1d6:	4293      	cmp	r3, r2
 c05c1d8:	d001      	beq.n	c05c1de <FIH_LABEL_FIH_CALL_END_0_1685+0xb4>
        FIH_PANIC;
 c05c1da:	f7f6 fbc5 	bl	c052968 <Error_Handler>
    int x_msk = x.msk;
 c05c1de:	686a      	ldr	r2, [r5, #4]
    if (x_msk != y.msk) {
 c05c1e0:	6863      	ldr	r3, [r4, #4]
    volatile uint32_t delay = FIH_NEGATIVE_VALUE;
 c05c1e2:	4c5a      	ldr	r4, [pc, #360]	@ (c05c34c <FIH_LABEL_FIH_CALL_END_0_1685+0x222>)
    if (x_msk != y.msk) {
 c05c1e4:	429a      	cmp	r2, r3
        rc2 = FIH_TRUE;
 c05c1e6:	bf1c      	itt	ne
 c05c1e8:	f24c 335a 	movwne	r3, #50010	@ 0xc35a
 c05c1ec:	930d      	strne	r3, [sp, #52]	@ 0x34
    volatile uint32_t counter = 0;
 c05c1ee:	2300      	movs	r3, #0
    volatile uint32_t delay = FIH_NEGATIVE_VALUE;
 c05c1f0:	940e      	str	r4, [sp, #56]	@ 0x38
    volatile uint32_t counter = 0;
 c05c1f2:	930f      	str	r3, [sp, #60]	@ 0x3c
    delay = fih_delay_random();
 c05c1f4:	f7ff fbe9 	bl	c05b9ca <fih_delay_random>
 c05c1f8:	900e      	str	r0, [sp, #56]	@ 0x38
    if (delay == FIH_NEGATIVE_VALUE) {
 c05c1fa:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
 c05c1fc:	42a3      	cmp	r3, r4
 c05c1fe:	d101      	bne.n	c05c204 <FIH_LABEL_FIH_CALL_END_0_1685+0xda>
        FIH_PANIC;
 c05c200:	f7f6 fbb2 	bl	c052968 <Error_Handler>
    delay &= 0xFF;
 c05c204:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
 c05c206:	b2db      	uxtb	r3, r3
 c05c208:	930e      	str	r3, [sp, #56]	@ 0x38
    for (i = 0; i < delay; i++) {
 c05c20a:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
 c05c20c:	459a      	cmp	sl, r3
 c05c20e:	d327      	bcc.n	c05c260 <FIH_LABEL_FIH_CALL_END_0_1685+0x136>
    uint8_t local_delay = delay;
 c05c210:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
    if (counter != local_delay) {
 c05c212:	9a0f      	ldr	r2, [sp, #60]	@ 0x3c
 c05c214:	b2db      	uxtb	r3, r3
 c05c216:	4293      	cmp	r3, r2
 c05c218:	d001      	beq.n	c05c21e <FIH_LABEL_FIH_CALL_END_0_1685+0xf4>
        FIH_PANIC;
 c05c21a:	f7f6 fba5 	bl	c052968 <Error_Handler>
    int loc_rc1 = rc1;
 c05c21e:	9a0c      	ldr	r2, [sp, #48]	@ 0x30
    if (loc_rc1 != rc2) {
 c05c220:	9b0d      	ldr	r3, [sp, #52]	@ 0x34
 c05c222:	429a      	cmp	r2, r3
 c05c224:	d001      	beq.n	c05c22a <FIH_LABEL_FIH_CALL_END_0_1685+0x100>
        FIH_PANIC;
 c05c226:	f7f6 fb9f 	bl	c052968 <Error_Handler>
    return rc1;
 c05c22a:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
    if (fih_not_eq(fih_rc, fih_int_encode(TFM_PLAT_ERR_SUCCESS))) {
 c05c22c:	b10b      	cbz	r3, c05c232 <FIH_LABEL_FIH_CALL_END_0_1685+0x108>
        tfm_core_panic();
 c05c22e:	f002 fa5b 	bl	c05e6e8 <tfm_core_panic>
    hal_status = tfm_hal_platform_init();
 c05c232:	f7df fa21 	bl	c03b678 <tfm_hal_platform_init>
    if (hal_status != TFM_HAL_SUCCESS) {
 c05c236:	b1c8      	cbz	r0, c05c26c <FIH_LABEL_FIH_CALL_END_0_1685+0x142>
        FIH_RET(fih_int_encode(TFM_ERROR_GENERIC));
 c05c238:	f7ff fb64 	bl	c05b904 <fih_cfi_decrement>
    fih_int ret = {x, x ^ _FIH_MASK_VALUE};
 c05c23c:	231f      	movs	r3, #31
 c05c23e:	9382      	str	r3, [sp, #520]	@ 0x208
 c05c240:	4b45      	ldr	r3, [pc, #276]	@ (c05c358 <FIH_LABEL_FIH_CALL_END_0_1685+0x22e>)
 c05c242:	9383      	str	r3, [sp, #524]	@ 0x20c
 c05c244:	e9dd 0182 	ldrd	r0, r1, [sp, #520]	@ 0x208
 c05c248:	ab42      	add	r3, sp, #264	@ 0x108
 c05c24a:	e49d      	b.n	c05bb88 <FIH_LABEL_FIH_CALL_START_tfm_core_init_0_80+0x74>
        counter++;
 c05c24c:	9a23      	ldr	r2, [sp, #140]	@ 0x8c
    for (i = 0; i < delay; i++) {
 c05c24e:	3301      	adds	r3, #1
        counter++;
 c05c250:	3201      	adds	r2, #1
 c05c252:	9223      	str	r2, [sp, #140]	@ 0x8c
    for (i = 0; i < delay; i++) {
 c05c254:	e745      	b.n	c05c0e2 <FIH_LABEL_FIH_CALL_START_tfm_spm_hal_verify_isolation_hw_0_1572+0x36>
        counter++;
 c05c256:	9a11      	ldr	r2, [sp, #68]	@ 0x44
    for (i = 0; i < delay; i++) {
 c05c258:	3301      	adds	r3, #1
        counter++;
 c05c25a:	3201      	adds	r2, #1
 c05c25c:	9211      	str	r2, [sp, #68]	@ 0x44
    for (i = 0; i < delay; i++) {
 c05c25e:	e7b4      	b.n	c05c1ca <FIH_LABEL_FIH_CALL_END_0_1685+0xa0>
        counter++;
 c05c260:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
    for (i = 0; i < delay; i++) {
 c05c262:	f10a 0a01 	add.w	sl, sl, #1
        counter++;
 c05c266:	3301      	adds	r3, #1
 c05c268:	930f      	str	r3, [sp, #60]	@ 0x3c
    for (i = 0; i < delay; i++) {
 c05c26a:	e7ce      	b.n	c05c20a <FIH_LABEL_FIH_CALL_END_0_1685+0xe0>
    tfm_arch_config_extensions();
 c05c26c:	f001 f916 	bl	c05d49c <tfm_arch_config_extensions>
    SPMLOG_INFMSG("\033[1;34m[Sec Thread] Secure image initializing!\033[0m\r\n");
 c05c270:	2135      	movs	r1, #53	@ 0x35
 c05c272:	483a      	ldr	r0, [pc, #232]	@ (c05c35c <FIH_LABEL_FIH_CALL_END_0_1685+0x232>)
 c05c274:	f001 fe9a 	bl	c05dfac <tfm_hal_output_spm_log>
    SPMLOG_DBGMSGVAL("TF-M isolation level is: ", TFM_LVL);
 c05c278:	2202      	movs	r2, #2
 c05c27a:	211a      	movs	r1, #26
 c05c27c:	4838      	ldr	r0, [pc, #224]	@ (c05c360 <FIH_LABEL_FIH_CALL_END_0_1685+0x236>)
 c05c27e:	f000 feb1 	bl	c05cfe4 <spm_log_msgval>
    tfm_core_validate_boot_data();
 c05c282:	f001 fa41 	bl	c05d708 <tfm_core_validate_boot_data>
    configure_ns_code();
 c05c286:	f002 f8e5 	bl	c05e454 <configure_ns_code>
    plat_err = tfm_spm_hal_nvic_interrupt_target_state_cfg();
 c05c28a:	f7f4 fcd7 	bl	c050c3c <tfm_spm_hal_nvic_interrupt_target_state_cfg>
    if (plat_err != TFM_PLAT_ERR_SUCCESS) {
 c05c28e:	4604      	mov	r4, r0
 c05c290:	b9e0      	cbnz	r0, c05c2cc <FIH_LABEL_FIH_CALL_END_0_1685+0x1a2>
    for (i = 0; i < tfm_core_irq_signals_count; ++i) {
 c05c292:	4b34      	ldr	r3, [pc, #208]	@ (c05c364 <FIH_LABEL_FIH_CALL_END_0_1685+0x23a>)
 c05c294:	4d34      	ldr	r5, [pc, #208]	@ (c05c368 <FIH_LABEL_FIH_CALL_END_0_1685+0x23e>)
 c05c296:	681b      	ldr	r3, [r3, #0]
 c05c298:	9301      	str	r3, [sp, #4]
 c05c29a:	9b01      	ldr	r3, [sp, #4]
 c05c29c:	429c      	cmp	r4, r3
 c05c29e:	d31f      	bcc.n	c05c2e0 <FIH_LABEL_FIH_CALL_END_0_1685+0x1b6>
    plat_err = tfm_spm_hal_nvic_interrupt_enable();
 c05c2a0:	f7f4 fcce 	bl	c050c40 <tfm_spm_hal_nvic_interrupt_enable>
    if (plat_err != TFM_PLAT_ERR_SUCCESS) {
 c05c2a4:	ac76      	add	r4, sp, #472	@ 0x1d8
 c05c2a6:	4605      	mov	r5, r0
 c05c2a8:	2800      	cmp	r0, #0
 c05c2aa:	d03c      	beq.n	c05c326 <FIH_LABEL_FIH_CALL_END_0_1685+0x1fc>
        FIH_RET(fih_int_encode(TFM_ERROR_GENERIC));
 c05c2ac:	f7ff fb2a 	bl	c05b904 <fih_cfi_decrement>
    fih_int ret = {x, x ^ _FIH_MASK_VALUE};
 c05c2b0:	231f      	movs	r3, #31
 c05c2b2:	937a      	str	r3, [sp, #488]	@ 0x1e8
 c05c2b4:	4b28      	ldr	r3, [pc, #160]	@ (c05c358 <FIH_LABEL_FIH_CALL_END_0_1685+0x22e>)
 c05c2b6:	937b      	str	r3, [sp, #492]	@ 0x1ec
 c05c2b8:	ab3a      	add	r3, sp, #232	@ 0xe8
 c05c2ba:	e9dd 017a 	ldrd	r0, r1, [sp, #488]	@ 0x1e8
 c05c2be:	e883 0003 	stmia.w	r3, {r0, r1}
    return ret;
 c05c2c2:	e893 0003 	ldmia.w	r3, {r0, r1}
 c05c2c6:	e884 0003 	stmia.w	r4, {r0, r1}
 c05c2ca:	e464      	b.n	c05bb96 <FIH_LABEL_FIH_CALL_START_tfm_core_init_0_80+0x82>
        FIH_RET(fih_int_encode(TFM_ERROR_GENERIC));
 c05c2cc:	f7ff fb1a 	bl	c05b904 <fih_cfi_decrement>
    fih_int ret = {x, x ^ _FIH_MASK_VALUE};
 c05c2d0:	231f      	movs	r3, #31
 c05c2d2:	9380      	str	r3, [sp, #512]	@ 0x200
 c05c2d4:	4b20      	ldr	r3, [pc, #128]	@ (c05c358 <FIH_LABEL_FIH_CALL_END_0_1685+0x22e>)
 c05c2d6:	9381      	str	r3, [sp, #516]	@ 0x204
 c05c2d8:	e9dd 0180 	ldrd	r0, r1, [sp, #512]	@ 0x200
 c05c2dc:	ab40      	add	r3, sp, #256	@ 0x100
 c05c2de:	e453      	b.n	c05bb88 <FIH_LABEL_FIH_CALL_START_tfm_core_init_0_80+0x74>
                                          tfm_core_irq_signals[i].irq_line,
 c05c2e0:	f995 a008 	ldrsb.w	sl, [r5, #8]
        plat_err = tfm_spm_hal_set_secure_irq_priority(
 c05c2e4:	68e9      	ldr	r1, [r5, #12]
 c05c2e6:	4650      	mov	r0, sl
 c05c2e8:	f7f4 fc34 	bl	c050b54 <tfm_spm_hal_set_secure_irq_priority>
        if (plat_err != TFM_PLAT_ERR_SUCCESS) {
 c05c2ec:	4601      	mov	r1, r0
 c05c2ee:	b148      	cbz	r0, c05c304 <FIH_LABEL_FIH_CALL_END_0_1685+0x1da>
            FIH_RET(fih_int_encode(TFM_ERROR_GENERIC));
 c05c2f0:	f7ff fb08 	bl	c05b904 <fih_cfi_decrement>
 c05c2f4:	231f      	movs	r3, #31
 c05c2f6:	937e      	str	r3, [sp, #504]	@ 0x1f8
 c05c2f8:	4b17      	ldr	r3, [pc, #92]	@ (c05c358 <FIH_LABEL_FIH_CALL_END_0_1685+0x22e>)
 c05c2fa:	937f      	str	r3, [sp, #508]	@ 0x1fc
 c05c2fc:	e9dd 017e 	ldrd	r0, r1, [sp, #504]	@ 0x1f8
 c05c300:	ab3e      	add	r3, sp, #248	@ 0xf8
 c05c302:	e441      	b.n	c05bb88 <FIH_LABEL_FIH_CALL_START_tfm_core_init_0_80+0x74>
        irq_target_state = tfm_spm_hal_set_irq_target_state(
 c05c304:	4650      	mov	r0, sl
 c05c306:	f7f4 fc67 	bl	c050bd8 <tfm_spm_hal_set_irq_target_state>
        if (irq_target_state != TFM_IRQ_TARGET_STATE_SECURE) {
 c05c30a:	3510      	adds	r5, #16
 c05c30c:	b148      	cbz	r0, c05c322 <FIH_LABEL_FIH_CALL_END_0_1685+0x1f8>
            FIH_RET(fih_int_encode(TFM_ERROR_GENERIC));
 c05c30e:	f7ff faf9 	bl	c05b904 <fih_cfi_decrement>
 c05c312:	231f      	movs	r3, #31
 c05c314:	937c      	str	r3, [sp, #496]	@ 0x1f0
 c05c316:	4b10      	ldr	r3, [pc, #64]	@ (c05c358 <FIH_LABEL_FIH_CALL_END_0_1685+0x22e>)
 c05c318:	937d      	str	r3, [sp, #500]	@ 0x1f4
 c05c31a:	e9dd 017c 	ldrd	r0, r1, [sp, #496]	@ 0x1f0
 c05c31e:	ab3c      	add	r3, sp, #240	@ 0xf0
 c05c320:	e432      	b.n	c05bb88 <FIH_LABEL_FIH_CALL_START_tfm_core_init_0_80+0x74>
    for (i = 0; i < tfm_core_irq_signals_count; ++i) {
 c05c322:	3401      	adds	r4, #1
 c05c324:	e7b9      	b.n	c05c29a <FIH_LABEL_FIH_CALL_END_0_1685+0x170>
    FIH_RET(fih_int_encode(TFM_SUCCESS));
 c05c326:	f7ff faed 	bl	c05b904 <fih_cfi_decrement>
 c05c32a:	9578      	str	r5, [sp, #480]	@ 0x1e0
 c05c32c:	9679      	str	r6, [sp, #484]	@ 0x1e4
 c05c32e:	ab38      	add	r3, sp, #224	@ 0xe0
 c05c330:	e9dd 0178 	ldrd	r0, r1, [sp, #480]	@ 0x1e0
 c05c334:	e7c3      	b.n	c05c2be <FIH_LABEL_FIH_CALL_END_0_1685+0x194>
        counter++;
 c05c336:	9a09      	ldr	r2, [sp, #36]	@ 0x24
    for (i = 0; i < delay; i++) {
 c05c338:	3301      	adds	r3, #1
        counter++;
 c05c33a:	3201      	adds	r2, #1
 c05c33c:	9209      	str	r2, [sp, #36]	@ 0x24
    for (i = 0; i < delay; i++) {
 c05c33e:	e48e      	b.n	c05bc5e <FIH_LABEL_FIH_CALL_END_0_251+0x9e>
        counter++;
 c05c340:	9a07      	ldr	r2, [sp, #28]
    for (i = 0; i < delay; i++) {
 c05c342:	3301      	adds	r3, #1
        counter++;
 c05c344:	3201      	adds	r2, #1
 c05c346:	9207      	str	r2, [sp, #28]
    for (i = 0; i < delay; i++) {
 c05c348:	e4ab      	b.n	c05bca2 <FIH_LABEL_FIH_CALL_END_0_251+0xe2>
 c05c34a:	bf00      	nop
 c05c34c:	aaaa5555 	.word	0xaaaa5555
 c05c350:	3003091c 	.word	0x3003091c
 c05c354:	a5c35a3c 	.word	0xa5c35a3c
 c05c358:	a5c35a23 	.word	0xa5c35a23
 c05c35c:	0c06157c 	.word	0x0c06157c
 c05c360:	0c0615b1 	.word	0x0c0615b1
 c05c364:	0c061908 	.word	0x0c061908
 c05c368:	0c06190c 	.word	0x0c06190c

0c05c36c <InsertEncodedTypeAndNumber>:
static void InsertEncodedTypeAndNumber(QCBOREncodeContext *me,
                                       uint8_t             uMajorType,
                                       int                 nMinLen,
                                       uint64_t            uNumber,
                                       size_t              uPos)
{
 c05c36c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   // Point to the last bytes and work backwards
   uint8_t *pByte = &bytes[sizeof(bytes)-1];
   // This is the 5 bits in the initial byte that is not the major type
   int nAdditionalInfo;

   if (uMajorType == CBOR_MAJOR_NONE_TYPE_ARRAY_INDEFINITE_LEN) {
 c05c370:	290c      	cmp	r1, #12
{
 c05c372:	b087      	sub	sp, #28
   if (uMajorType == CBOR_MAJOR_NONE_TYPE_ARRAY_INDEFINITE_LEN) {
 c05c374:	f10d 0515 	add.w	r5, sp, #21
{
 c05c378:	e9dd 360e 	ldrd	r3, r6, [sp, #56]	@ 0x38
   if (uMajorType == CBOR_MAJOR_NONE_TYPE_ARRAY_INDEFINITE_LEN) {
 c05c37c:	d03f      	beq.n	c05c3fe <InsertEncodedTypeAndNumber+0x92>
      uMajorType = CBOR_MAJOR_TYPE_ARRAY;
      nAdditionalInfo = LEN_IS_INDEFINITE;
   } else if (uMajorType == CBOR_MAJOR_NONE_TYPE_MAP_INDEFINITE_LEN) {
 c05c37e:	290d      	cmp	r1, #13
 c05c380:	d041      	beq.n	c05c406 <InsertEncodedTypeAndNumber+0x9a>
      uMajorType = CBOR_MAJOR_TYPE_MAP;
      nAdditionalInfo = LEN_IS_INDEFINITE;
   } else if (uNumber < CBOR_TWENTY_FOUR && nMinLen == 0) {
 c05c382:	2b18      	cmp	r3, #24
 c05c384:	f176 0400 	sbcs.w	r4, r6, #0
 c05c388:	d202      	bcs.n	c05c390 <InsertEncodedTypeAndNumber+0x24>
 c05c38a:	b91a      	cbnz	r2, c05c394 <InsertEncodedTypeAndNumber+0x28>
   uint8_t *pByte = &bytes[sizeof(bytes)-1];
 c05c38c:	462c      	mov	r4, r5
 c05c38e:	e00c      	b.n	c05c3aa <InsertEncodedTypeAndNumber+0x3e>
      // Simple case where argument is < 24
      nAdditionalInfo = (int)uNumber;
   } else if (uMajorType == CBOR_MAJOR_TYPE_SIMPLE && uNumber == CBOR_SIMPLE_BREAK) {
 c05c390:	2907      	cmp	r1, #7
 c05c392:	d01a      	beq.n	c05c3ca <InsertEncodedTypeAndNumber+0x5e>
       */
      static const uint8_t aIterate[] = {1,1,2,4};
      int i;
      for(i = 0; uNumber || nMinLen > 0; i++) {
         const int nIterations = aIterate[i];
         for(int j = 0; j < nIterations; j++) {
 c05c394:	2700      	movs	r7, #0
 c05c396:	462c      	mov	r4, r5
 c05c398:	f8df 8074 	ldr.w	r8, [pc, #116]	@ c05c410 <InsertEncodedTypeAndNumber+0xa4>
      for(i = 0; uNumber || nMinLen > 0; i++) {
 c05c39c:	ea53 0c06 	orrs.w	ip, r3, r6
 c05c3a0:	d119      	bne.n	c05c3d6 <InsertEncodedTypeAndNumber+0x6a>
 c05c3a2:	2a00      	cmp	r2, #0
 c05c3a4:	dc17      	bgt.n	c05c3d6 <InsertEncodedTypeAndNumber+0x6a>
         }
         nMinLen -= nIterations;
      }
      // Additional info is the encoding of the number of additional
      // bytes to encode argument.
      nAdditionalInfo = LEN_IS_ONE_BYTE-1 + i;
 c05c3a6:	f107 0317 	add.w	r3, r7, #23
    0x1f. The caller may pass in a too-large uMajor type. The
    conversion to unint8_t will cause an integer wrap around and
    incorrect CBOR will be generated, but no security issue will
    incur.
    */
   *--pByte = (uint8_t)((uMajorType << 5) + nAdditionalInfo);
 c05c3aa:	1e62      	subs	r2, r4, #1
   UsefulBufC Data = {pBytes, uLen};
 c05c3ac:	9201      	str	r2, [sp, #4]
 c05c3ae:	eb03 1341 	add.w	r3, r3, r1, lsl #5
   /*
    Will not go negative because the loops run for at most 8
    decrements of pByte, only one other decrement is made and the
    array is sized for this.
    */
   const size_t uHeadLen = (size_t)(&bytes[sizeof(bytes)-1] - pByte);
 c05c3b2:	1aad      	subs	r5, r5, r2
   *--pByte = (uint8_t)((uMajorType << 5) + nAdditionalInfo);
 c05c3b4:	f804 3c01 	strb.w	r3, [r4, #-1]
   UsefulOutBuf_InsertUsefulBuf(pMe, Data, uPos);
 c05c3b8:	462a      	mov	r2, r5
 c05c3ba:	9b10      	ldr	r3, [sp, #64]	@ 0x40
 c05c3bc:	9901      	ldr	r1, [sp, #4]
   UsefulBufC Data = {pBytes, uLen};
 c05c3be:	9502      	str	r5, [sp, #8]
   UsefulOutBuf_InsertUsefulBuf(pMe, Data, uPos);
 c05c3c0:	f7fe fdaa 	bl	c05af18 <UsefulOutBuf_InsertUsefulBuf>

   UsefulOutBuf_InsertData(&(me->OutBuf), pByte, uHeadLen, uPos);
}
 c05c3c4:	b007      	add	sp, #28
 c05c3c6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   } else if (uMajorType == CBOR_MAJOR_TYPE_SIMPLE && uNumber == CBOR_SIMPLE_BREAK) {
 c05c3ca:	f1a3 041f 	sub.w	r4, r3, #31
 c05c3ce:	4334      	orrs	r4, r6
 c05c3d0:	d1e0      	bne.n	c05c394 <InsertEncodedTypeAndNumber+0x28>
      nAdditionalInfo = (int)uNumber;
 c05c3d2:	231f      	movs	r3, #31
 c05c3d4:	e7da      	b.n	c05c38c <InsertEncodedTypeAndNumber+0x20>
         for(int j = 0; j < nIterations; j++) {
 c05c3d6:	46a6      	mov	lr, r4
         const int nIterations = aIterate[i];
 c05c3d8:	f818 cb01 	ldrb.w	ip, [r8], #1
         for(int j = 0; j < nIterations; j++) {
 c05c3dc:	eba4 090e 	sub.w	r9, r4, lr
 c05c3e0:	45cc      	cmp	ip, r9
 c05c3e2:	dc05      	bgt.n	c05c3f0 <InsertEncodedTypeAndNumber+0x84>
 c05c3e4:	eba4 040c 	sub.w	r4, r4, ip
         nMinLen -= nIterations;
 c05c3e8:	eba2 020c 	sub.w	r2, r2, ip
      for(i = 0; uNumber || nMinLen > 0; i++) {
 c05c3ec:	3701      	adds	r7, #1
 c05c3ee:	e7d5      	b.n	c05c39c <InsertEncodedTypeAndNumber+0x30>
            *--pByte = (uint8_t)(uNumber & 0xff);
 c05c3f0:	f80e 3d01 	strb.w	r3, [lr, #-1]!
            uNumber = uNumber >> 8;
 c05c3f4:	0a1b      	lsrs	r3, r3, #8
 c05c3f6:	ea43 6306 	orr.w	r3, r3, r6, lsl #24
 c05c3fa:	0a36      	lsrs	r6, r6, #8
         for(int j = 0; j < nIterations; j++) {
 c05c3fc:	e7ee      	b.n	c05c3dc <InsertEncodedTypeAndNumber+0x70>
      nAdditionalInfo = LEN_IS_INDEFINITE;
 c05c3fe:	231f      	movs	r3, #31
   uint8_t *pByte = &bytes[sizeof(bytes)-1];
 c05c400:	462c      	mov	r4, r5
      uMajorType = CBOR_MAJOR_TYPE_ARRAY;
 c05c402:	2104      	movs	r1, #4
 c05c404:	e7d1      	b.n	c05c3aa <InsertEncodedTypeAndNumber+0x3e>
      nAdditionalInfo = LEN_IS_INDEFINITE;
 c05c406:	231f      	movs	r3, #31
   uint8_t *pByte = &bytes[sizeof(bytes)-1];
 c05c408:	462c      	mov	r4, r5
      uMajorType = CBOR_MAJOR_TYPE_MAP;
 c05c40a:	2105      	movs	r1, #5
 c05c40c:	e7cd      	b.n	c05c3aa <InsertEncodedTypeAndNumber+0x3e>
 c05c40e:	bf00      	nop
 c05c410:	0c061618 	.word	0x0c061618

0c05c414 <AppendEncodedTypeAndNumber>:
 See InsertEncodedTypeAndNumber() function above for details.
*/
inline static void AppendEncodedTypeAndNumber(QCBOREncodeContext *me,
                                              uint8_t uMajorType,
                                              uint64_t uNumber)
{
 c05c414:	b51f      	push	{r0, r1, r2, r3, r4, lr}
   // An append is an insert at the end.
   InsertEncodedTypeAndNumber(me,
 c05c416:	6884      	ldr	r4, [r0, #8]
 c05c418:	e9cd 2300 	strd	r2, r3, [sp]
 c05c41c:	9402      	str	r4, [sp, #8]
 c05c41e:	2200      	movs	r2, #0
 c05c420:	f7ff ffa4 	bl	c05c36c <InsertEncodedTypeAndNumber>
                              uMajorType,
                              0,
                              uNumber,
                              UsefulOutBuf_GetEndPosition(&(me->OutBuf)));
}
 c05c424:	b004      	add	sp, #16
 c05c426:	bd10      	pop	{r4, pc}

0c05c428 <Nesting_Increment.isra.0>:
   if(1 >= QCBOR_MAX_ITEMS_IN_ARRAY - pNesting->pCurrentNesting->uCount) {
 c05c428:	8883      	ldrh	r3, [r0, #4]
 c05c42a:	f5c3 427f 	rsb	r2, r3, #65280	@ 0xff00
 c05c42e:	32fe      	adds	r2, #254	@ 0xfe
 c05c430:	2a01      	cmp	r2, #1
   pNesting->pCurrentNesting->uCount += 1;
 c05c432:	bfc3      	ittte	gt
 c05c434:	3301      	addgt	r3, #1
 c05c436:	8083      	strhgt	r3, [r0, #4]
   return QCBOR_SUCCESS;
 c05c438:	2000      	movgt	r0, #0
      return QCBOR_ERR_ARRAY_TOO_LONG;
 c05c43a:	2003      	movle	r0, #3
}
 c05c43c:	4770      	bx	lr

0c05c43e <QCBOREncode_Init>:
{
 c05c43e:	b537      	push	{r0, r1, r2, r4, r5, lr}
 c05c440:	466d      	mov	r5, sp
 c05c442:	4604      	mov	r4, r0
 c05c444:	e885 0006 	stmia.w	r5, {r1, r2}
   memset(me, 0, sizeof(QCBOREncodeContext));
 c05c448:	2298      	movs	r2, #152	@ 0x98
 c05c44a:	2100      	movs	r1, #0
 c05c44c:	f7ff f96f 	bl	c05b72e <memset>
   UsefulOutBuf_Init(&(me->OutBuf), Storage);
 c05c450:	e895 0006 	ldmia.w	r5, {r1, r2}
 c05c454:	4620      	mov	r0, r4
 c05c456:	f7fe fd4f 	bl	c05aef8 <UsefulOutBuf_Init>
   pNesting->pCurrentNesting = &pNesting->pArrays[0];
 c05c45a:	f104 0314 	add.w	r3, r4, #20
 c05c45e:	f8c4 3094 	str.w	r3, [r4, #148]	@ 0x94
   pNesting->pCurrentNesting->uMajorType = CBOR_MAJOR_TYPE_ARRAY;
 c05c462:	2304      	movs	r3, #4
 c05c464:	76a3      	strb	r3, [r4, #26]
}
 c05c466:	b003      	add	sp, #12
 c05c468:	bd30      	pop	{r4, r5, pc}

0c05c46a <QCBOREncode_AddInt64>:

/*
 Public functions for closing arrays and maps. See qcbor.h
 */
void QCBOREncode_AddInt64(QCBOREncodeContext *me, int64_t nNum)
{
 c05c46a:	b510      	push	{r4, lr}
   if(me->uError == QCBOR_SUCCESS) {
 c05c46c:	7c01      	ldrb	r1, [r0, #16]
{
 c05c46e:	4604      	mov	r4, r0
   if(me->uError == QCBOR_SUCCESS) {
 c05c470:	b959      	cbnz	r1, c05c48a <QCBOREncode_AddInt64+0x20>
      uint8_t      uMajorType;
      uint64_t     uValue;

      if(nNum < 0) {
 c05c472:	2b00      	cmp	r3, #0
         // In CBOR -1 encodes as 0x00 with major type negative int.
         uValue = (uint64_t)(-nNum - 1);
 c05c474:	bfbe      	ittt	lt
 c05c476:	43d2      	mvnlt	r2, r2
 c05c478:	43db      	mvnlt	r3, r3
         uMajorType = CBOR_MAJOR_TYPE_NEGATIVE_INT;
 c05c47a:	2101      	movlt	r1, #1
      } else {
         uValue = (uint64_t)nNum;
         uMajorType = CBOR_MAJOR_TYPE_POSITIVE_INT;
      }

      AppendEncodedTypeAndNumber(me, uMajorType, uValue);
 c05c47c:	f7ff ffca 	bl	c05c414 <AppendEncodedTypeAndNumber>
      me->uError = Nesting_Increment(&(me->nesting));
 c05c480:	f8d4 0094 	ldr.w	r0, [r4, #148]	@ 0x94
 c05c484:	f7ff ffd0 	bl	c05c428 <Nesting_Increment.isra.0>
 c05c488:	7420      	strb	r0, [r4, #16]
   }
}
 c05c48a:	bd10      	pop	{r4, pc}

0c05c48c <QCBOREncode_AddBuffer>:
 third just adds the bytes as the type and length are presumed to be
 in the bytes. The fourth just adds the type and length for the very
 special case of QCBOREncode_AddBytesLenOnly().
 */
void QCBOREncode_AddBuffer(QCBOREncodeContext *me, uint8_t uMajorType, UsefulBufC Bytes)
{
 c05c48c:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
 c05c48e:	466e      	mov	r6, sp
 c05c490:	e886 000c 	stmia.w	r6, {r2, r3}
   if(me->uError == QCBOR_SUCCESS) {
 c05c494:	7c03      	ldrb	r3, [r0, #16]
{
 c05c496:	4604      	mov	r4, r0
 c05c498:	460d      	mov	r5, r1
   if(me->uError == QCBOR_SUCCESS) {
 c05c49a:	b98b      	cbnz	r3, c05c4c0 <QCBOREncode_AddBuffer+0x34>
      // If it is not Raw CBOR, add the type and the length
      if(uMajorType != CBOR_MAJOR_NONE_TYPE_RAW) {
 c05c49c:	2909      	cmp	r1, #9
 c05c49e:	9a01      	ldr	r2, [sp, #4]
 c05c4a0:	d110      	bne.n	c05c4c4 <QCBOREncode_AddBuffer+0x38>
         AppendEncodedTypeAndNumber(me, uRealMajorType, Bytes.len);
      }

      if(uMajorType != CBOR_MAJOR_NONE_TYPE_BSTR_LEN_ONLY) {
         // Actually add the bytes
         UsefulOutBuf_AppendUsefulBuf(&(me->OutBuf), Bytes);
 c05c4a2:	e896 0003 	ldmia.w	r6, {r0, r1}
 c05c4a6:	aa02      	add	r2, sp, #8
 c05c4a8:	e882 0003 	stmia.w	r2, {r0, r1}
   UsefulOutBuf_InsertUsefulBuf(pMe, NewData, UsefulOutBuf_GetEndPosition(pMe));
 c05c4ac:	68a3      	ldr	r3, [r4, #8]
 c05c4ae:	4620      	mov	r0, r4
 c05c4b0:	ca06      	ldmia	r2, {r1, r2}
 c05c4b2:	f7fe fd31 	bl	c05af18 <UsefulOutBuf_InsertUsefulBuf>
      }

      // Update the array counting if there is any nesting at all
      me->uError = Nesting_Increment(&(me->nesting));
 c05c4b6:	f8d4 0094 	ldr.w	r0, [r4, #148]	@ 0x94
 c05c4ba:	f7ff ffb5 	bl	c05c428 <Nesting_Increment.isra.0>
 c05c4be:	7420      	strb	r0, [r4, #16]
   }
}
 c05c4c0:	b004      	add	sp, #16
 c05c4c2:	bd70      	pop	{r4, r5, r6, pc}
            uRealMajorType = CBOR_MAJOR_TYPE_BYTE_STRING;
 c05c4c4:	290b      	cmp	r1, #11
         AppendEncodedTypeAndNumber(me, uRealMajorType, Bytes.len);
 c05c4c6:	bf08      	it	eq
 c05c4c8:	2102      	moveq	r1, #2
 c05c4ca:	f7ff ffa3 	bl	c05c414 <AppendEncodedTypeAndNumber>
      if(uMajorType != CBOR_MAJOR_NONE_TYPE_BSTR_LEN_ONLY) {
 c05c4ce:	2d0b      	cmp	r5, #11
 c05c4d0:	d1e7      	bne.n	c05c4a2 <QCBOREncode_AddBuffer+0x16>
 c05c4d2:	e7f0      	b.n	c05c4b6 <QCBOREncode_AddBuffer+0x2a>

0c05c4d4 <QCBOREncode_AddTag>:
/*
 Public functions for closing arrays and maps. See qcbor.h
 */
void QCBOREncode_AddTag(QCBOREncodeContext *me, uint64_t uTag)
{
   AppendEncodedTypeAndNumber(me, CBOR_MAJOR_TYPE_OPTIONAL, uTag);
 c05c4d4:	2106      	movs	r1, #6
 c05c4d6:	f7ff bf9d 	b.w	c05c414 <AppendEncodedTypeAndNumber>

0c05c4da <QCBOREncode_OpenMapOrArray>:
 but they will usually call one of the inline wrappers rather than this.

 See header qcbor.h
*/
void QCBOREncode_OpenMapOrArray(QCBOREncodeContext *me, uint8_t uMajorType)
{
 c05c4da:	b538      	push	{r3, r4, r5, lr}
 c05c4dc:	f8d0 5094 	ldr.w	r5, [r0, #148]	@ 0x94
 c05c4e0:	4604      	mov	r4, r0
   // Add one item to the nesting level we are in for the new map or array
   me->uError = Nesting_Increment(&(me->nesting));
 c05c4e2:	4628      	mov	r0, r5
 c05c4e4:	f7ff ffa0 	bl	c05c428 <Nesting_Increment.isra.0>
 c05c4e8:	7420      	strb	r0, [r4, #16]
   if(me->uError == QCBOR_SUCCESS) {
 c05c4ea:	b928      	cbnz	r0, c05c4f8 <QCBOREncode_OpenMapOrArray+0x1e>
   return pMe->data_len;
 c05c4ec:	68a3      	ldr	r3, [r4, #8]
       code can run on a 32-bit machine and tests can pass on a 32-bit
       machine. If it was exactly UINT32_MAX, then this code would not
       compile or run on a 32-bit machine and an #ifdef or some
       machine size detection would be needed reducing portability.
      */
      if(uEndPosition >= QCBOR_MAX_ARRAY_OFFSET) {
 c05c4ee:	f113 0f66 	cmn.w	r3, #102	@ 0x66
 c05c4f2:	d902      	bls.n	c05c4fa <QCBOREncode_OpenMapOrArray+0x20>
         me->uError = QCBOR_ERR_BUFFER_TOO_LARGE;
 c05c4f4:	2307      	movs	r3, #7
 c05c4f6:	7423      	strb	r3, [r4, #16]
         // Increase nesting level because this is a map or array.  Cast
         // from size_t to uin32_t is safe because of check above
         me->uError = Nesting_Increase(&(me->nesting), uMajorType, (uint32_t)uEndPosition);
      }
   }
}
 c05c4f8:	bd38      	pop	{r3, r4, r5, pc}
   if(pNesting->pCurrentNesting == &pNesting->pArrays[QCBOR_MAX_ARRAY_NESTING]) {
 c05c4fa:	f104 028c 	add.w	r2, r4, #140	@ 0x8c
 c05c4fe:	4295      	cmp	r5, r2
      nReturn = QCBOR_ERR_ARRAY_NESTING_TOO_DEEP;
 c05c500:	bf0f      	iteee	eq
 c05c502:	2002      	moveq	r0, #2
      pNesting->pCurrentNesting++;
 c05c504:	f105 0208 	addne.w	r2, r5, #8
 c05c508:	f8c4 2094 	strne.w	r2, [r4, #148]	@ 0x94
      pNesting->pCurrentNesting->uCount     = 0;
 c05c50c:	81a8      	strhne	r0, [r5, #12]
      pNesting->pCurrentNesting->uStart     = uPos;
 c05c50e:	bf1c      	itt	ne
 c05c510:	60ab      	strne	r3, [r5, #8]
      pNesting->pCurrentNesting->uMajorType = uMajorType;
 c05c512:	73a9      	strbne	r1, [r5, #14]
         me->uError = Nesting_Increase(&(me->nesting), uMajorType, (uint32_t)uEndPosition);
 c05c514:	7420      	strb	r0, [r4, #16]
}
 c05c516:	e7ef      	b.n	c05c4f8 <QCBOREncode_OpenMapOrArray+0x1e>

0c05c518 <QCBOREncode_CloseMapOrArray>:
 Public functions for closing arrays and maps. See qcbor.h
 */
void QCBOREncode_CloseMapOrArray(QCBOREncodeContext *me,
                                 uint8_t uMajorType,
                                 UsefulBufC *pWrappedCBOR)
{
 c05c518:	b5f0      	push	{r4, r5, r6, r7, lr}
 c05c51a:	4616      	mov	r6, r2
   if(me->uError == QCBOR_SUCCESS) {
 c05c51c:	7c02      	ldrb	r2, [r0, #16]
{
 c05c51e:	4604      	mov	r4, r0
 c05c520:	460b      	mov	r3, r1
 c05c522:	b087      	sub	sp, #28
   if(me->uError == QCBOR_SUCCESS) {
 c05c524:	b93a      	cbnz	r2, c05c536 <QCBOREncode_CloseMapOrArray+0x1e>
   return pNesting->pCurrentNesting == &pNesting->pArrays[0] ? false : true;
 c05c526:	f8d0 2094 	ldr.w	r2, [r0, #148]	@ 0x94
 c05c52a:	f100 0114 	add.w	r1, r0, #20
      if(!Nesting_IsInNest(&(me->nesting))) {
 c05c52e:	428a      	cmp	r2, r1
 c05c530:	d103      	bne.n	c05c53a <QCBOREncode_CloseMapOrArray+0x22>
         me->uError = QCBOR_ERR_TOO_MANY_CLOSES;
 c05c532:	2304      	movs	r3, #4
      } else if(Nesting_GetMajorType(&(me->nesting)) != uMajorType) {
         me->uError = QCBOR_ERR_CLOSE_MISMATCH;
 c05c534:	7423      	strb	r3, [r4, #16]
            *pWrappedCBOR = UsefulBuf_Tail(PartialResult, uInsertPosition);
         }
         Nesting_Decrease(&(me->nesting));
      }
   }
}
 c05c536:	b007      	add	sp, #28
 c05c538:	bdf0      	pop	{r4, r5, r6, r7, pc}
   return pNesting->pCurrentNesting->uMajorType;
 c05c53a:	7991      	ldrb	r1, [r2, #6]
      } else if(Nesting_GetMajorType(&(me->nesting)) != uMajorType) {
 c05c53c:	428b      	cmp	r3, r1
 c05c53e:	d001      	beq.n	c05c544 <QCBOREncode_CloseMapOrArray+0x2c>
         me->uError = QCBOR_ERR_CLOSE_MISMATCH;
 c05c540:	230f      	movs	r3, #15
 c05c542:	e7f7      	b.n	c05c534 <QCBOREncode_CloseMapOrArray+0x1c>
                                         : Nesting_GetCount(&(me->nesting));
 c05c544:	2902      	cmp	r1, #2
   return pNesting->pCurrentNesting->uStart;
 c05c546:	6817      	ldr	r7, [r2, #0]
 c05c548:	6883      	ldr	r3, [r0, #8]
                                         : Nesting_GetCount(&(me->nesting));
 c05c54a:	d11c      	bne.n	c05c586 <QCBOREncode_CloseMapOrArray+0x6e>
         const size_t uLenOfEncodedMapOrArray = uEndPosition - uInsertPosition;
 c05c54c:	1bdb      	subs	r3, r3, r7
         InsertEncodedTypeAndNumber(me,
 c05c54e:	2500      	movs	r5, #0
 c05c550:	4620      	mov	r0, r4
 c05c552:	462a      	mov	r2, r5
 c05c554:	e9cd 3500 	strd	r3, r5, [sp]
 c05c558:	9702      	str	r7, [sp, #8]
 c05c55a:	f7ff ff07 	bl	c05c36c <InsertEncodedTypeAndNumber>
         if(pWrappedCBOR) {
 c05c55e:	b166      	cbz	r6, c05c57a <QCBOREncode_CloseMapOrArray+0x62>
            const UsefulBufC PartialResult = UsefulOutBuf_OutUBuf(&(me->OutBuf));
 c05c560:	4621      	mov	r1, r4
 c05c562:	a804      	add	r0, sp, #16
 c05c564:	f7fe fd06 	bl	c05af74 <UsefulOutBuf_OutUBuf>
            *pWrappedCBOR = UsefulBuf_Tail(PartialResult, uInsertPosition);
 c05c568:	e9dd 3204 	ldrd	r3, r2, [sp, #16]
   if(uAmount > UB.len) {
 c05c56c:	4297      	cmp	r7, r2
 c05c56e:	d80f      	bhi.n	c05c590 <QCBOREncode_CloseMapOrArray+0x78>
      ReturnValue = (UsefulBufC){NULL, UB.len - uAmount};
 c05c570:	1bd5      	subs	r5, r2, r7
   } else if(UB.ptr == NULL) {
 c05c572:	b103      	cbz	r3, c05c576 <QCBOREncode_CloseMapOrArray+0x5e>
      ReturnValue = (UsefulBufC){(uint8_t *)UB.ptr + uAmount, UB.len - uAmount};
 c05c574:	443b      	add	r3, r7
 c05c576:	e9c6 3500 	strd	r3, r5, [r6]
   pNesting->pCurrentNesting--;
 c05c57a:	f8d4 3094 	ldr.w	r3, [r4, #148]	@ 0x94
 c05c57e:	3b08      	subs	r3, #8
 c05c580:	f8c4 3094 	str.w	r3, [r4, #148]	@ 0x94
}
 c05c584:	e7d7      	b.n	c05c536 <QCBOREncode_CloseMapOrArray+0x1e>
      return (uint16_t)(pNesting->pCurrentNesting->uCount >> 1);
 c05c586:	8893      	ldrh	r3, [r2, #4]
   if(pNesting->pCurrentNesting->uMajorType == CBOR_MAJOR_TYPE_MAP) {
 c05c588:	2905      	cmp	r1, #5
      return (uint16_t)(pNesting->pCurrentNesting->uCount >> 1);
 c05c58a:	bf08      	it	eq
 c05c58c:	085b      	lsreq	r3, r3, #1
 c05c58e:	e7de      	b.n	c05c54e <QCBOREncode_CloseMapOrArray+0x36>
      ReturnValue = NULLUsefulBufC;
 c05c590:	462b      	mov	r3, r5
 c05c592:	e7f0      	b.n	c05c576 <QCBOREncode_CloseMapOrArray+0x5e>

0c05c594 <QCBOREncode_Finish>:

/*
 Public functions to finish and get the encoded result. See qcbor.h
 */
QCBORError QCBOREncode_Finish(QCBOREncodeContext *me, UsefulBufC *pEncodedCBOR)
{
 c05c594:	b573      	push	{r0, r1, r4, r5, r6, lr}
   return UsefulOutBuf_IsBufferNULL(&(pCtx->OutBuf));
}

static inline QCBORError QCBOREncode_GetErrorState(QCBOREncodeContext *pCtx)
{
   if(UsefulOutBuf_GetError(&(pCtx->OutBuf))) {
 c05c596:	7b82      	ldrb	r2, [r0, #14]
 c05c598:	460c      	mov	r4, r1
 c05c59a:	b10a      	cbz	r2, c05c5a0 <QCBOREncode_Finish+0xc>
      // This check catches this condition for all the appends and inserts
      // so checks aren't needed when the appends and inserts are performed.
      // And of course UsefulBuf will never overrun the input buffer given
      // to it. No complex analysis of the error handling in this file is
      // needed to know that is true. Just read the UsefulBuf code.
      pCtx->uError = QCBOR_ERR_BUFFER_TOO_SMALL;
 c05c59c:	2201      	movs	r2, #1
 c05c59e:	7402      	strb	r2, [r0, #16]
      // QCBOR_ERR_BUFFER_TOO_SMALL masks other errors, but that is
      // OK. Once the caller fixes this, they'll be unmasked.
   }

   return (QCBORError)pCtx->uError;
 c05c5a0:	7c05      	ldrb	r5, [r0, #16]
   QCBORError uReturn = QCBOREncode_GetErrorState(me);

   if(uReturn != QCBOR_SUCCESS) {
 c05c5a2:	b975      	cbnz	r5, c05c5c2 <QCBOREncode_Finish+0x2e>
      goto Done;
   }

   if (Nesting_IsInNest(&(me->nesting))) {
 c05c5a4:	f8d0 1094 	ldr.w	r1, [r0, #148]	@ 0x94
   return pNesting->pCurrentNesting == &pNesting->pArrays[0] ? false : true;
 c05c5a8:	f100 0214 	add.w	r2, r0, #20
   if (Nesting_IsInNest(&(me->nesting))) {
 c05c5ac:	4291      	cmp	r1, r2
 c05c5ae:	d10b      	bne.n	c05c5c8 <QCBOREncode_Finish+0x34>
      uReturn = QCBOR_ERR_ARRAY_OR_MAP_STILL_OPEN;
      goto Done;
   }

   *pEncodedCBOR = UsefulOutBuf_OutUBuf(&(me->OutBuf));
 c05c5b0:	466e      	mov	r6, sp
 c05c5b2:	4601      	mov	r1, r0
 c05c5b4:	4630      	mov	r0, r6
 c05c5b6:	f7fe fcdd 	bl	c05af74 <UsefulOutBuf_OutUBuf>
 c05c5ba:	e896 0003 	ldmia.w	r6, {r0, r1}
 c05c5be:	e884 0003 	stmia.w	r4, {r0, r1}

Done:
   return uReturn;
}
 c05c5c2:	4628      	mov	r0, r5
 c05c5c4:	b002      	add	sp, #8
 c05c5c6:	bd70      	pop	{r4, r5, r6, pc}
      uReturn = QCBOR_ERR_ARRAY_OR_MAP_STILL_OPEN;
 c05c5c8:	250a      	movs	r5, #10
 c05c5ca:	e7fa      	b.n	c05c5c2 <QCBOREncode_Finish+0x2e>

0c05c5cc <tfm_spm_get_partition_by_id>:
 */
static uint32_t get_partition_idx(uint32_t partition_id)
{
    uint32_t i;

    if (partition_id == INVALID_PARTITION_ID) {
 c05c5cc:	1c42      	adds	r2, r0, #1
 * \retval NULL             Failed
 * \retval "Not NULL"       Target partition context pointer,
 *                          \ref partition_t structures
 */
static struct partition_t *tfm_spm_get_partition_by_id(int32_t partition_id)
{
 c05c5ce:	4603      	mov	r3, r0
 c05c5d0:	b530      	push	{r4, r5, lr}
    if (partition_id == INVALID_PARTITION_ID) {
 c05c5d2:	d005      	beq.n	c05c5e0 <tfm_spm_get_partition_by_id+0x14>
    for (i = 0; i < g_spm_partition_db.partition_count; ++i) {
 c05c5d4:	4a07      	ldr	r2, [pc, #28]	@ (c05c5f4 <tfm_spm_get_partition_by_id+0x28>)
 c05c5d6:	e9d2 4100 	ldrd	r4, r1, [r2]
 c05c5da:	2200      	movs	r2, #0
 c05c5dc:	42a2      	cmp	r2, r4
 c05c5de:	d101      	bne.n	c05c5e4 <tfm_spm_get_partition_by_id+0x18>
    uint32_t idx = get_partition_idx(partition_id);

    if (idx != SPM_INVALID_PARTITION_IDX) {
        return &(g_spm_partition_db.partitions[idx]);
    }
    return NULL;
 c05c5e0:	2000      	movs	r0, #0
}
 c05c5e2:	bd30      	pop	{r4, r5, pc}
        if (g_spm_partition_db.partitions[i].p_static->pid == partition_id) {
 c05c5e4:	4608      	mov	r0, r1
 c05c5e6:	6805      	ldr	r5, [r0, #0]
 c05c5e8:	317c      	adds	r1, #124	@ 0x7c
 c05c5ea:	686d      	ldr	r5, [r5, #4]
 c05c5ec:	42ab      	cmp	r3, r5
 c05c5ee:	d0f8      	beq.n	c05c5e2 <tfm_spm_get_partition_by_id+0x16>
    for (i = 0; i < g_spm_partition_db.partition_count; ++i) {
 c05c5f0:	3201      	adds	r2, #1
 c05c5f2:	e7f3      	b.n	c05c5dc <tfm_spm_get_partition_by_id+0x10>
 c05c5f4:	30030958 	.word	0x30030958

0c05c5f8 <tfm_spm_to_user_handle>:
    loop_index = (loop_index + 1) % CONVERSION_FACTOR_VALUE;
 c05c5f8:	4a05      	ldr	r2, [pc, #20]	@ (c05c610 <tfm_spm_to_user_handle+0x18>)
 c05c5fa:	6813      	ldr	r3, [r2, #0]
 c05c5fc:	3301      	adds	r3, #1
 c05c5fe:	f003 0307 	and.w	r3, r3, #7
 c05c602:	6013      	str	r3, [r2, #0]
    user_handle = (psa_handle_t)((((uintptr_t)handle_instance -
 c05c604:	4a03      	ldr	r2, [pc, #12]	@ (c05c614 <tfm_spm_to_user_handle+0x1c>)
                  CLIENT_HANDLE_VALUE_MIN + loop_index);
 c05c606:	3301      	adds	r3, #1
    user_handle = (psa_handle_t)((((uintptr_t)handle_instance -
 c05c608:	1a80      	subs	r0, r0, r2
}
 c05c60a:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
 c05c60e:	4770      	bx	lr
 c05c610:	30037804 	.word	0x30037804
 c05c614:	30037808 	.word	0x30037808

0c05c618 <tfm_spm_to_handle_instance>:
    if (user_handle == PSA_NULL_HANDLE) {
 c05c618:	b118      	cbz	r0, c05c622 <tfm_spm_to_handle_instance+0xa>
                      CLIENT_HANDLE_VALUE_MIN) >> CONVERSION_FACTOR_BITOFFSET) +
 c05c61a:	4b02      	ldr	r3, [pc, #8]	@ (c05c624 <tfm_spm_to_handle_instance+0xc>)
    handle_instance = (struct tfm_conn_handle_t *)((((uintptr_t)user_handle -
 c05c61c:	3801      	subs	r0, #1
                      CLIENT_HANDLE_VALUE_MIN) >> CONVERSION_FACTOR_BITOFFSET) +
 c05c61e:	eb03 00d0 	add.w	r0, r3, r0, lsr #3
}
 c05c622:	4770      	bx	lr
 c05c624:	30037808 	.word	0x30037808

0c05c628 <tfm_spm_create_conn_handle>:
{
 c05c628:	b538      	push	{r3, r4, r5, lr}
 c05c62a:	4604      	mov	r4, r0
    p_handle = (struct tfm_conn_handle_t *)tfm_pool_alloc(conn_handle_pool);
 c05c62c:	480a      	ldr	r0, [pc, #40]	@ (c05c658 <tfm_spm_create_conn_handle+0x30>)
{
 c05c62e:	460d      	mov	r5, r1
    p_handle = (struct tfm_conn_handle_t *)tfm_pool_alloc(conn_handle_pool);
 c05c630:	f001 ff50 	bl	c05e4d4 <tfm_pool_alloc>
    if (!p_handle) {
 c05c634:	b170      	cbz	r0, c05c654 <tfm_spm_create_conn_handle+0x2c>
    p_handle->status = TFM_HANDLE_STATUS_IDLE;
 c05c636:	2300      	movs	r3, #0
    BI_LIST_INSERT_BEFORE(&service->handle_list, &p_handle->list);
 c05c638:	68a2      	ldr	r2, [r4, #8]
    p_handle->client_id = client_id;
 c05c63a:	e9c0 3501 	strd	r3, r5, [r0, #4]
    BI_LIST_INSERT_BEFORE(&service->handle_list, &p_handle->list);
 c05c63e:	f100 039c 	add.w	r3, r0, #156	@ 0x9c
    p_handle->service = service;
 c05c642:	f8c0 4098 	str.w	r4, [r0, #152]	@ 0x98
    BI_LIST_INSERT_BEFORE(&service->handle_list, &p_handle->list);
 c05c646:	6053      	str	r3, [r2, #4]
 c05c648:	f8c0 209c 	str.w	r2, [r0, #156]	@ 0x9c
 c05c64c:	f844 3f08 	str.w	r3, [r4, #8]!
 c05c650:	f8c0 40a0 	str.w	r4, [r0, #160]	@ 0xa0
}
 c05c654:	bd38      	pop	{r3, r4, r5, pc}
 c05c656:	bf00      	nop
 c05c658:	30037808 	.word	0x30037808

0c05c65c <tfm_spm_validate_conn_handle>:
{
 c05c65c:	b538      	push	{r3, r4, r5, lr}
 c05c65e:	4604      	mov	r4, r0
 c05c660:	460d      	mov	r5, r1
    if (is_valid_chunk_data_in_pool(conn_handle_pool,
 c05c662:	4601      	mov	r1, r0
 c05c664:	4805      	ldr	r0, [pc, #20]	@ (c05c67c <tfm_spm_validate_conn_handle+0x20>)
 c05c666:	f001 ff4e 	bl	c05e506 <is_valid_chunk_data_in_pool>
 c05c66a:	b128      	cbz	r0, c05c678 <tfm_spm_validate_conn_handle+0x1c>
    if (conn_handle->client_id != client_id) {
 c05c66c:	68a3      	ldr	r3, [r4, #8]
        return SPM_ERROR_GENERIC;
 c05c66e:	4804      	ldr	r0, [pc, #16]	@ (c05c680 <tfm_spm_validate_conn_handle+0x24>)
 c05c670:	42ab      	cmp	r3, r5
 c05c672:	bf08      	it	eq
 c05c674:	2000      	moveq	r0, #0
}
 c05c676:	bd38      	pop	{r3, r4, r5, pc}
        return SPM_ERROR_GENERIC;
 c05c678:	4801      	ldr	r0, [pc, #4]	@ (c05c680 <tfm_spm_validate_conn_handle+0x24>)
 c05c67a:	e7fc      	b.n	c05c676 <tfm_spm_validate_conn_handle+0x1a>
 c05c67c:	30037808 	.word	0x30037808
 c05c680:	80000005 	.word	0x80000005

0c05c684 <tfm_spm_free_conn_handle>:
{
 c05c684:	b510      	push	{r4, lr}
    BI_LIST_REMOVE_NODE(&conn_handle->list);
 c05c686:	e9d1 2327 	ldrd	r2, r3, [r1, #156]	@ 0x9c
    conn_handle->internal_msg.magic = 0;
 c05c68a:	2400      	movs	r4, #0
    tfm_pool_free(conn_handle_pool, conn_handle);
 c05c68c:	4803      	ldr	r0, [pc, #12]	@ (c05c69c <tfm_spm_free_conn_handle+0x18>)
    conn_handle->internal_msg.magic = 0;
 c05c68e:	60cc      	str	r4, [r1, #12]
    BI_LIST_REMOVE_NODE(&conn_handle->list);
 c05c690:	6053      	str	r3, [r2, #4]
 c05c692:	601a      	str	r2, [r3, #0]
    tfm_pool_free(conn_handle_pool, conn_handle);
 c05c694:	f001 ff2c 	bl	c05e4f0 <tfm_pool_free>
}
 c05c698:	4620      	mov	r0, r4
 c05c69a:	bd10      	pop	{r4, pc}
 c05c69c:	30037808 	.word	0x30037808

0c05c6a0 <tfm_spm_set_rhandle>:
}
 c05c6a0:	2000      	movs	r0, #0
    conn_handle->rhandle = rhandle;
 c05c6a2:	600a      	str	r2, [r1, #0]
}
 c05c6a4:	4770      	bx	lr

0c05c6a6 <tfm_spm_get_msg_by_signal>:
    if (BI_LIST_IS_EMPTY(head)) {
 c05c6a6:	6e83      	ldr	r3, [r0, #104]	@ 0x68
{
 c05c6a8:	b570      	push	{r4, r5, r6, lr}
    head = &partition->msg_list;
 c05c6aa:	f100 0464 	add.w	r4, r0, #100	@ 0x64
    if (BI_LIST_IS_EMPTY(head)) {
 c05c6ae:	42a3      	cmp	r3, r4
{
 c05c6b0:	4602      	mov	r2, r0
        return NULL;
 c05c6b2:	f04f 0000 	mov.w	r0, #0
    if (BI_LIST_IS_EMPTY(head)) {
 c05c6b6:	d014      	beq.n	c05c6e2 <tfm_spm_get_msg_by_signal+0x3c>
        if (tmp_msg->service->service_db->signal == signal && msg) {
 c05c6b8:	f853 6c80 	ldr.w	r6, [r3, #-128]
        tmp_msg = TFM_GET_CONTAINER_PTR(node, struct tfm_msg_body_t, msg_node);
 c05c6bc:	f1a3 0584 	sub.w	r5, r3, #132	@ 0x84
        if (tmp_msg->service->service_db->signal == signal && msg) {
 c05c6c0:	6836      	ldr	r6, [r6, #0]
 c05c6c2:	68b6      	ldr	r6, [r6, #8]
 c05c6c4:	428e      	cmp	r6, r1
 c05c6c6:	d105      	bne.n	c05c6d4 <tfm_spm_get_msg_by_signal+0x2e>
 c05c6c8:	b958      	cbnz	r0, c05c6e2 <tfm_spm_get_msg_by_signal+0x3c>
            BI_LIST_REMOVE_NODE(node);
 c05c6ca:	e9d3 6000 	ldrd	r6, r0, [r3]
 c05c6ce:	6070      	str	r0, [r6, #4]
 c05c6d0:	6006      	str	r6, [r0, #0]
 c05c6d2:	4628      	mov	r0, r5
    BI_LIST_FOR_EACH(node, head) {
 c05c6d4:	685b      	ldr	r3, [r3, #4]
 c05c6d6:	429c      	cmp	r4, r3
 c05c6d8:	d1ee      	bne.n	c05c6b8 <tfm_spm_get_msg_by_signal+0x12>
    partition->signals_asserted &= ~signal;
 c05c6da:	6f53      	ldr	r3, [r2, #116]	@ 0x74
 c05c6dc:	ea23 0301 	bic.w	r3, r3, r1
 c05c6e0:	6753      	str	r3, [r2, #116]	@ 0x74
}
 c05c6e2:	bd70      	pop	{r4, r5, r6, pc}

0c05c6e4 <tfm_spm_partition_get_privileged_mode>:
}
 c05c6e4:	f3c0 0040 	ubfx	r0, r0, #1, #1
 c05c6e8:	4770      	bx	lr
	...

0c05c6ec <tfm_spm_get_service_by_sid>:
{
 c05c6ec:	b530      	push	{r4, r5, lr}
 c05c6ee:	4602      	mov	r2, r0
    for (i = 0; i < num; i++) {
 c05c6f0:	2300      	movs	r3, #0
 c05c6f2:	2518      	movs	r5, #24
        if (service[i].service_db->sid == sid) {
 c05c6f4:	4906      	ldr	r1, [pc, #24]	@ (c05c710 <tfm_spm_get_service_by_sid+0x24>)
 c05c6f6:	fb05 f403 	mul.w	r4, r5, r3
 c05c6fa:	1860      	adds	r0, r4, r1
 c05c6fc:	590c      	ldr	r4, [r1, r4]
 c05c6fe:	68e4      	ldr	r4, [r4, #12]
 c05c700:	4294      	cmp	r4, r2
 c05c702:	d003      	beq.n	c05c70c <tfm_spm_get_service_by_sid+0x20>
    for (i = 0; i < num; i++) {
 c05c704:	3301      	adds	r3, #1
 c05c706:	2b17      	cmp	r3, #23
 c05c708:	d1f5      	bne.n	c05c6f6 <tfm_spm_get_service_by_sid+0xa>
    return NULL;
 c05c70a:	2000      	movs	r0, #0
}
 c05c70c:	bd30      	pop	{r4, r5, pc}
 c05c70e:	bf00      	nop
 c05c710:	300386b8 	.word	0x300386b8

0c05c714 <tfm_spm_get_running_partition>:

struct partition_t *tfm_spm_get_running_partition(void)
{
 c05c714:	b508      	push	{r3, lr}
    struct tfm_core_thread_t *pth = tfm_core_thrd_get_curr();
 c05c716:	f001 ff19 	bl	c05e54c <tfm_core_thrd_get_curr>
    struct partition_t *partition;

    partition = TFM_GET_CONTAINER_PTR(pth, struct partition_t, sp_thread);

    return partition;
}
 c05c71a:	3810      	subs	r0, #16
 c05c71c:	bd08      	pop	{r3, pc}
	...

0c05c720 <tfm_spm_check_client_version>:
int32_t tfm_spm_check_client_version(struct tfm_spm_service_t *service,
                                     uint32_t version)
{
    TFM_CORE_ASSERT(service);

    switch (service->service_db->version_policy) {
 c05c720:	6803      	ldr	r3, [r0, #0]
 c05c722:	699a      	ldr	r2, [r3, #24]
 c05c724:	b11a      	cbz	r2, c05c72e <tfm_spm_check_client_version+0xe>
 c05c726:	2a01      	cmp	r2, #1
 c05c728:	d007      	beq.n	c05c73a <tfm_spm_check_client_version+0x1a>
 c05c72a:	4807      	ldr	r0, [pc, #28]	@ (c05c748 <tfm_spm_check_client_version+0x28>)
 c05c72c:	4770      	bx	lr
    case TFM_VERSION_POLICY_RELAXED:
        if (version > service->service_db->version) {
 c05c72e:	695b      	ldr	r3, [r3, #20]
 c05c730:	4805      	ldr	r0, [pc, #20]	@ (c05c748 <tfm_spm_check_client_version+0x28>)
 c05c732:	428b      	cmp	r3, r1
 c05c734:	bf28      	it	cs
 c05c736:	2000      	movcs	r0, #0
 c05c738:	4770      	bx	lr
            return SPM_ERROR_VERSION;
        }
        break;
    case TFM_VERSION_POLICY_STRICT:
        if (version != service->service_db->version) {
 c05c73a:	695b      	ldr	r3, [r3, #20]
 c05c73c:	4802      	ldr	r0, [pc, #8]	@ (c05c748 <tfm_spm_check_client_version+0x28>)
 c05c73e:	428b      	cmp	r3, r1
 c05c740:	bf08      	it	eq
 c05c742:	2000      	moveq	r0, #0
        break;
    default:
        return SPM_ERROR_VERSION;
    }
    return SPM_SUCCESS;
}
 c05c744:	4770      	bx	lr
 c05c746:	bf00      	nop
 c05c748:	80000003 	.word	0x80000003

0c05c74c <tfm_spm_check_authorization>:

int32_t tfm_spm_check_authorization(uint32_t sid,
                                    struct tfm_spm_service_t *service,
                                    bool ns_caller)
{
 c05c74c:	b538      	push	{r3, r4, r5, lr}
 c05c74e:	4605      	mov	r5, r0
    struct partition_t *partition = NULL;
    int32_t i;

    TFM_CORE_ASSERT(service);

    if (ns_caller) {
 c05c750:	b122      	cbz	r2, c05c75c <tfm_spm_check_authorization+0x10>
        if (!service->service_db->non_secure_client) {
 c05c752:	680b      	ldr	r3, [r1, #0]
 c05c754:	7c1b      	ldrb	r3, [r3, #16]
 c05c756:	b19b      	cbz	r3, c05c780 <tfm_spm_check_authorization+0x34>

        if (i == partition->p_static->ndeps) {
            return SPM_ERROR_GENERIC;
        }
    }
    return SPM_SUCCESS;
 c05c758:	2000      	movs	r0, #0
}
 c05c75a:	bd38      	pop	{r3, r4, r5, pc}
        partition = tfm_spm_get_running_partition();
 c05c75c:	f7ff ffda 	bl	c05c714 <tfm_spm_get_running_partition>
        if (!partition) {
 c05c760:	4604      	mov	r4, r0
 c05c762:	b908      	cbnz	r0, c05c768 <tfm_spm_check_authorization+0x1c>
            tfm_core_panic();
 c05c764:	f001 ffc0 	bl	c05e6e8 <tfm_core_panic>
        for (i = 0; i < partition->p_static->ndeps; i++) {
 c05c768:	2300      	movs	r3, #0
 c05c76a:	6821      	ldr	r1, [r4, #0]
 c05c76c:	6a8a      	ldr	r2, [r1, #40]	@ 0x28
 c05c76e:	429a      	cmp	r2, r3
 c05c770:	d006      	beq.n	c05c780 <tfm_spm_check_authorization+0x34>
            if (partition->p_static->deps[i] == sid) {
 c05c772:	6ac8      	ldr	r0, [r1, #44]	@ 0x2c
 c05c774:	f850 0023 	ldr.w	r0, [r0, r3, lsl #2]
 c05c778:	42a8      	cmp	r0, r5
 c05c77a:	d103      	bne.n	c05c784 <tfm_spm_check_authorization+0x38>
        if (i == partition->p_static->ndeps) {
 c05c77c:	429a      	cmp	r2, r3
 c05c77e:	d1eb      	bne.n	c05c758 <tfm_spm_check_authorization+0xc>
            return SPM_ERROR_GENERIC;
 c05c780:	4801      	ldr	r0, [pc, #4]	@ (c05c788 <tfm_spm_check_authorization+0x3c>)
 c05c782:	e7ea      	b.n	c05c75a <tfm_spm_check_authorization+0xe>
        for (i = 0; i < partition->p_static->ndeps; i++) {
 c05c784:	3301      	adds	r3, #1
 c05c786:	e7f2      	b.n	c05c76e <tfm_spm_check_authorization+0x22>
 c05c788:	80000005 	.word	0x80000005

0c05c78c <tfm_spm_get_msg_buffer_from_conn_handle>:
 tfm_spm_get_msg_buffer_from_conn_handle(struct tfm_conn_handle_t *conn_handle)
{
    TFM_CORE_ASSERT(conn_handle != NULL);

    return &(conn_handle->internal_msg);
}
 c05c78c:	300c      	adds	r0, #12
 c05c78e:	4770      	bx	lr

0c05c790 <tfm_spm_fill_msg>:
                      psa_handle_t handle,
                      int32_t type, int32_t client_id,
                      psa_invec *invec, size_t in_len,
                      psa_outvec *outvec, size_t out_len,
                      psa_outvec *caller_outvec)
{
 c05c790:	e92d 4af8 	stmdb	sp!, {r3, r4, r5, r6, r7, r9, fp, lr}
 c05c794:	4689      	mov	r9, r1
 c05c796:	4617      	mov	r7, r2
    TFM_CORE_ASSERT(in_len <= PSA_MAX_IOVEC);
    TFM_CORE_ASSERT(out_len <= PSA_MAX_IOVEC);
    TFM_CORE_ASSERT(in_len + out_len <= PSA_MAX_IOVEC);

    /* Clear message buffer before using it */
    spm_memset(msg, 0, sizeof(struct tfm_msg_body_t));
 c05c798:	2100      	movs	r1, #0
 c05c79a:	228c      	movs	r2, #140	@ 0x8c
{
 c05c79c:	4604      	mov	r4, r0
 c05c79e:	469b      	mov	fp, r3
 c05c7a0:	9e09      	ldr	r6, [sp, #36]	@ 0x24
 c05c7a2:	9d0b      	ldr	r5, [sp, #44]	@ 0x2c
    spm_memset(msg, 0, sizeof(struct tfm_msg_body_t));
 c05c7a4:	f001 f95f 	bl	c05da66 <spm_memset>
 *  pevnt      -    The pointer of event object allocated by the caller
 */
void __STATIC_INLINE tfm_event_init(struct tfm_event_t *pevnt)
{
    pevnt->magic = TFM_EVENT_MAGIC;
    pevnt->owner = NULL;
 c05c7a8:	2300      	movs	r3, #0
 c05c7aa:	4a1f      	ldr	r2, [pc, #124]	@ (c05c828 <tfm_spm_fill_msg+0x98>)
    msg->service = service;
    msg->caller_outvec = caller_outvec;
    msg->msg.client_id = client_id;

    /* Copy contents */
    msg->msg.type = type;
 c05c7ac:	f8c4 b010 	str.w	fp, [r4, #16]
 c05c7b0:	e9c4 2302 	strd	r2, r3, [r4, #8]
    msg->magic = TFM_MSG_MAGIC;
 c05c7b4:	4a1d      	ldr	r2, [pc, #116]	@ (c05c82c <tfm_spm_fill_msg+0x9c>)

    for (i = 0; i < in_len; i++) {
        msg->msg.in_size[i] = invec[i].len;
 c05c7b6:	1d30      	adds	r0, r6, #4
    msg->service = service;
 c05c7b8:	e9c4 2900 	strd	r2, r9, [r4]
    msg->caller_outvec = caller_outvec;
 c05c7bc:	9a0d      	ldr	r2, [sp, #52]	@ 0x34
        msg->invec[i].base = invec[i].base;
 c05c7be:	f104 0c40 	add.w	ip, r4, #64	@ 0x40
    msg->caller_outvec = caller_outvec;
 c05c7c2:	f8c4 2080 	str.w	r2, [r4, #128]	@ 0x80
    msg->msg.client_id = client_id;
 c05c7c6:	9a08      	ldr	r2, [sp, #32]
 c05c7c8:	61a2      	str	r2, [r4, #24]
    for (i = 0; i < in_len; i++) {
 c05c7ca:	f104 021c 	add.w	r2, r4, #28
 c05c7ce:	990a      	ldr	r1, [sp, #40]	@ 0x28
 c05c7d0:	428b      	cmp	r3, r1
 c05c7d2:	d114      	bne.n	c05c7fe <tfm_spm_fill_msg+0x6e>
    }

    for (i = 0; i < out_len; i++) {
 c05c7d4:	2300      	movs	r3, #0
        msg->msg.out_size[i] = outvec[i].len;
        msg->outvec[i].base = outvec[i].base;
        /* Out len is used to record the writed number, set 0 here again */
        msg->outvec[i].len = 0;
 c05c7d6:	4618      	mov	r0, r3
 c05c7d8:	f104 012c 	add.w	r1, r4, #44	@ 0x2c
 c05c7dc:	f104 0260 	add.w	r2, r4, #96	@ 0x60
        msg->msg.out_size[i] = outvec[i].len;
 c05c7e0:	1d2e      	adds	r6, r5, #4
    for (i = 0; i < out_len; i++) {
 c05c7e2:	f8dd c030 	ldr.w	ip, [sp, #48]	@ 0x30
 c05c7e6:	3208      	adds	r2, #8
 c05c7e8:	4563      	cmp	r3, ip
 c05c7ea:	d112      	bne.n	c05c812 <tfm_spm_fill_msg+0x82>
    }

    /* Use the user connect handle as the message handle */
    msg->msg.handle = handle;

    conn_handle = tfm_spm_to_handle_instance(handle);
 c05c7ec:	4638      	mov	r0, r7
    msg->msg.handle = handle;
 c05c7ee:	6167      	str	r7, [r4, #20]
    conn_handle = tfm_spm_to_handle_instance(handle);
 c05c7f0:	f7ff ff12 	bl	c05c618 <tfm_spm_to_handle_instance>
    /* For connected handle, set rhandle to every message */
    if (conn_handle) {
 c05c7f4:	b108      	cbz	r0, c05c7fa <tfm_spm_fill_msg+0x6a>
        msg->msg.rhandle = tfm_spm_get_rhandle(service, conn_handle);
 c05c7f6:	6803      	ldr	r3, [r0, #0]
 c05c7f8:	61e3      	str	r3, [r4, #28]

    /* Set the private data of NSPE client caller in multi-core topology */
    if (TFM_CLIENT_ID_IS_NS(client_id)) {
        tfm_rpc_set_caller_data(msg, client_id);
    }
}
 c05c7fa:	e8bd 8af8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r9, fp, pc}
        msg->msg.in_size[i] = invec[i].len;
 c05c7fe:	f850 1033 	ldr.w	r1, [r0, r3, lsl #3]
 c05c802:	f842 1f04 	str.w	r1, [r2, #4]!
        msg->invec[i].base = invec[i].base;
 c05c806:	f856 1033 	ldr.w	r1, [r6, r3, lsl #3]
 c05c80a:	f84c 1033 	str.w	r1, [ip, r3, lsl #3]
    for (i = 0; i < in_len; i++) {
 c05c80e:	3301      	adds	r3, #1
 c05c810:	e7dd      	b.n	c05c7ce <tfm_spm_fill_msg+0x3e>
        msg->msg.out_size[i] = outvec[i].len;
 c05c812:	f856 c033 	ldr.w	ip, [r6, r3, lsl #3]
 c05c816:	f841 cf04 	str.w	ip, [r1, #4]!
        msg->outvec[i].base = outvec[i].base;
 c05c81a:	f855 c033 	ldr.w	ip, [r5, r3, lsl #3]
    for (i = 0; i < out_len; i++) {
 c05c81e:	3301      	adds	r3, #1
        msg->outvec[i].len = 0;
 c05c820:	e942 c002 	strd	ip, r0, [r2, #-8]
    for (i = 0; i < out_len; i++) {
 c05c824:	e7dd      	b.n	c05c7e2 <tfm_spm_fill_msg+0x52>
 c05c826:	bf00      	nop
 c05c828:	65766e74 	.word	0x65766e74
 c05c82c:	15154343 	.word	0x15154343

0c05c830 <tfm_spm_send_event>:

void tfm_spm_send_event(struct tfm_spm_service_t *service,
                        struct tfm_msg_body_t *msg)
{
 c05c830:	b570      	push	{r4, r5, r6, lr}
 c05c832:	4606      	mov	r6, r0
    struct partition_t *partition = NULL;
    psa_signal_t signal = 0;

    if (!msg || !service || !service->service_db || !service->partition) {
 c05c834:	460d      	mov	r5, r1
 c05c836:	b121      	cbz	r1, c05c842 <tfm_spm_send_event+0x12>
 c05c838:	b118      	cbz	r0, c05c842 <tfm_spm_send_event+0x12>
 c05c83a:	6803      	ldr	r3, [r0, #0]
 c05c83c:	b10b      	cbz	r3, c05c842 <tfm_spm_send_event+0x12>
 c05c83e:	6843      	ldr	r3, [r0, #4]
 c05c840:	b90b      	cbnz	r3, c05c846 <tfm_spm_send_event+0x16>
        tfm_core_panic();
 c05c842:	f001 ff51 	bl	c05e6e8 <tfm_core_panic>
    }

    partition = service->partition;
    signal = service->service_db->signal;
 c05c846:	e9d6 3400 	ldrd	r3, r4, [r6]
 c05c84a:	689e      	ldr	r6, [r3, #8]

    /* Add message to partition message list tail */
    BI_LIST_INSERT_BEFORE(&partition->msg_list, &msg->msg_node);
 c05c84c:	6e63      	ldr	r3, [r4, #100]	@ 0x64
 c05c84e:	f105 0284 	add.w	r2, r5, #132	@ 0x84
 c05c852:	605a      	str	r2, [r3, #4]
 c05c854:	f8c5 3084 	str.w	r3, [r5, #132]	@ 0x84
 c05c858:	4623      	mov	r3, r4
 c05c85a:	f843 2f64 	str.w	r2, [r3, #100]!
 c05c85e:	f8c5 3088 	str.w	r3, [r5, #136]	@ 0x88

    /* Messages put. Update signals */
    partition->signals_asserted |= signal;

    if (partition->signals_waiting & signal) {
 c05c862:	6f21      	ldr	r1, [r4, #112]	@ 0x70
    partition->signals_asserted |= signal;
 c05c864:	6f63      	ldr	r3, [r4, #116]	@ 0x74
    if (partition->signals_waiting & signal) {
 c05c866:	4231      	tst	r1, r6
    partition->signals_asserted |= signal;
 c05c868:	ea43 0306 	orr.w	r3, r3, r6
 c05c86c:	6763      	str	r3, [r4, #116]	@ 0x74
    if (partition->signals_waiting & signal) {
 c05c86e:	d008      	beq.n	c05c882 <tfm_spm_send_event+0x52>
        tfm_event_wake(
 c05c870:	4019      	ands	r1, r3
 c05c872:	f104 005c 	add.w	r0, r4, #92	@ 0x5c
 c05c876:	f001 fef3 	bl	c05e660 <tfm_event_wake>
                    &partition->event,
                    (partition->signals_asserted & partition->signals_waiting));
        partition->signals_waiting &= ~signal;
 c05c87a:	6f23      	ldr	r3, [r4, #112]	@ 0x70
 c05c87c:	ea23 0306 	bic.w	r3, r3, r6
 c05c880:	6723      	str	r3, [r4, #112]	@ 0x70
    /*
     * If it is a NS request via RPC, it is unnecessary to block current
     * thread.
     */
    if (!is_tfm_rpc_msg(msg)) {
        tfm_event_wait(&msg->ack_evnt);
 c05c882:	f105 0008 	add.w	r0, r5, #8
    }
}
 c05c886:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        tfm_event_wait(&msg->ack_evnt);
 c05c88a:	f001 bedd 	b.w	c05e648 <tfm_event_wait>

0c05c88e <tfm_spm_partition_get_running_partition_id>:

uint32_t tfm_spm_partition_get_running_partition_id(void)
{
 c05c88e:	b508      	push	{r3, lr}
    struct partition_t *partition;

    partition = tfm_spm_get_running_partition();
 c05c890:	f7ff ff40 	bl	c05c714 <tfm_spm_get_running_partition>
    if (partition && partition->p_static) {
 c05c894:	b118      	cbz	r0, c05c89e <tfm_spm_partition_get_running_partition_id+0x10>
 c05c896:	6803      	ldr	r3, [r0, #0]
 c05c898:	b10b      	cbz	r3, c05c89e <tfm_spm_partition_get_running_partition_id+0x10>
        return partition->p_static->pid;
 c05c89a:	6858      	ldr	r0, [r3, #4]
    } else {
        return INVALID_PARTITION_ID;
    }
}
 c05c89c:	bd08      	pop	{r3, pc}
        return INVALID_PARTITION_ID;
 c05c89e:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 c05c8a2:	e7fb      	b.n	c05c89c <tfm_spm_partition_get_running_partition_id+0xe>

0c05c8a4 <tfm_spm_get_msg_from_handle>:
{
 c05c8a4:	b510      	push	{r4, lr}
                                     tfm_spm_to_handle_instance(msg_handle);
 c05c8a6:	f7ff feb7 	bl	c05c618 <tfm_spm_to_handle_instance>
 c05c8aa:	4604      	mov	r4, r0
    if (is_valid_chunk_data_in_pool(
 c05c8ac:	4601      	mov	r1, r0
 c05c8ae:	480a      	ldr	r0, [pc, #40]	@ (c05c8d8 <tfm_spm_get_msg_from_handle+0x34>)
 c05c8b0:	f001 fe29 	bl	c05e506 <is_valid_chunk_data_in_pool>
 c05c8b4:	b908      	cbnz	r0, c05c8ba <tfm_spm_get_msg_from_handle+0x16>
        return NULL;
 c05c8b6:	2000      	movs	r0, #0
}
 c05c8b8:	bd10      	pop	{r4, pc}
    if (p_msg->magic != TFM_MSG_MAGIC) {
 c05c8ba:	68e2      	ldr	r2, [r4, #12]
 c05c8bc:	4b07      	ldr	r3, [pc, #28]	@ (c05c8dc <tfm_spm_get_msg_from_handle+0x38>)
 c05c8be:	429a      	cmp	r2, r3
 c05c8c0:	d1f9      	bne.n	c05c8b6 <tfm_spm_get_msg_from_handle+0x12>
    partition_id = tfm_spm_partition_get_running_partition_id();
 c05c8c2:	f7ff ffe4 	bl	c05c88e <tfm_spm_partition_get_running_partition_id>
    if (partition_id != p_msg->service->partition->p_static->pid) {
 c05c8c6:	6923      	ldr	r3, [r4, #16]
 c05c8c8:	685b      	ldr	r3, [r3, #4]
 c05c8ca:	681b      	ldr	r3, [r3, #0]
 c05c8cc:	685b      	ldr	r3, [r3, #4]
 c05c8ce:	4283      	cmp	r3, r0
 c05c8d0:	d1f1      	bne.n	c05c8b6 <tfm_spm_get_msg_from_handle+0x12>
    p_msg = &p_conn_handle->internal_msg;
 c05c8d2:	f104 000c 	add.w	r0, r4, #12
 c05c8d6:	e7ef      	b.n	c05c8b8 <tfm_spm_get_msg_from_handle+0x14>
 c05c8d8:	30037808 	.word	0x30037808
 c05c8dc:	15154343 	.word	0x15154343

0c05c8e0 <tfm_memory_check>:

int32_t tfm_memory_check(const void *buffer, size_t len, bool ns_caller,
                         enum tfm_memory_access_e access,
                         uint32_t privileged)
{
 c05c8e0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 c05c8e4:	460d      	mov	r5, r1
    uint32_t attr = 0;
#ifdef TFM_FIH_PROFILE_ON
    fih_int fih_rc = FIH_FAILURE;
 c05c8e6:	4f7b      	ldr	r7, [pc, #492]	@ (c05cad4 <FIH_LABEL_FIH_CALL_END_0_1414+0x11e>)
{
 c05c8e8:	b09e      	sub	sp, #120	@ 0x78
    fih_int fih_rc = FIH_FAILURE;
 c05c8ea:	ac0a      	add	r4, sp, #40	@ 0x28
{
 c05c8ec:	4606      	mov	r6, r0
    fih_int fih_rc = FIH_FAILURE;
 c05c8ee:	e897 0003 	ldmia.w	r7, {r0, r1}
 c05c8f2:	46ba      	mov	sl, r7
 c05c8f4:	e884 0003 	stmia.w	r4, {r0, r1}
#else
    enum tfm_hal_status_t err;
#endif

    /* If len is zero, this indicates an empty buffer and base is ignored */
    if (len == 0) {
 c05c8f8:	b91d      	cbnz	r5, c05c902 <tfm_memory_check+0x22>
        return SPM_SUCCESS;
 c05c8fa:	2000      	movs	r0, #0
    if (err == TFM_HAL_SUCCESS) {
        return SPM_SUCCESS;
    }
#endif
    return SPM_ERROR_MEMORY_CHECK;
}
 c05c8fc:	b01e      	add	sp, #120	@ 0x78
 c05c8fe:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if (!buffer) {
 c05c902:	2e00      	cmp	r6, #0
 c05c904:	f000 80e4 	beq.w	c05cad0 <FIH_LABEL_FIH_CALL_END_0_1414+0x11a>
    if ((uintptr_t)buffer > (UINTPTR_MAX - len)) {
 c05c908:	1971      	adds	r1, r6, r5
 c05c90a:	bf2c      	ite	cs
 c05c90c:	f04f 0801 	movcs.w	r8, #1
 c05c910:	f04f 0800 	movcc.w	r8, #0
 c05c914:	d301      	bcc.n	c05c91a <tfm_memory_check+0x3a>
        return SPM_ERROR_MEMORY_CHECK;
 c05c916:	4870      	ldr	r0, [pc, #448]	@ (c05cad8 <FIH_LABEL_FIH_CALL_END_0_1414+0x122>)
 c05c918:	e7f0      	b.n	c05c8fc <tfm_memory_check+0x1c>
        attr |= (TFM_HAL_ACCESS_READABLE | TFM_HAL_ACCESS_WRITABLE);
 c05c91a:	2b02      	cmp	r3, #2
    if (privileged == TFM_PARTITION_UNPRIVILEGED_MODE) {
 c05c91c:	9b26      	ldr	r3, [sp, #152]	@ 0x98
        attr |= (TFM_HAL_ACCESS_READABLE | TFM_HAL_ACCESS_WRITABLE);
 c05c91e:	bf14      	ite	ne
 c05c920:	2702      	movne	r7, #2
 c05c922:	2706      	moveq	r7, #6
    if (privileged == TFM_PARTITION_UNPRIVILEGED_MODE) {
 c05c924:	b90b      	cbnz	r3, c05c92a <tfm_memory_check+0x4a>
        attr |= TFM_HAL_ACCESS_UNPRIVILEGED;
 c05c926:	f047 0708 	orr.w	r7, r7, #8
    if (ns_caller) {
 c05c92a:	b10a      	cbz	r2, c05c930 <FIH_LABEL_FIH_CALL_START_tfm_hal_memory_has_access_0_1297>
        attr |= TFM_HAL_ACCESS_NS;
 c05c92c:	f047 0720 	orr.w	r7, r7, #32

0c05c930 <FIH_LABEL_FIH_CALL_START_tfm_hal_memory_has_access_0_1297>:
    FIH_CALL(tfm_hal_memory_has_access, fih_rc,
 c05c930:	f10d 0930 	add.w	r9, sp, #48	@ 0x30
 c05c934:	2101      	movs	r1, #1
 c05c936:	4648      	mov	r0, r9
 c05c938:	f7fe ff18 	bl	c05b76c <fih_cfi_get_and_increment>
 c05c93c:	e89a 0003 	ldmia.w	sl, {r0, r1}
    volatile uint32_t counter = 0;
 c05c940:	2300      	movs	r3, #0
    volatile uint32_t delay = FIH_NEGATIVE_VALUE;
 c05c942:	f8df a198 	ldr.w	sl, [pc, #408]	@ c05cadc <FIH_LABEL_FIH_CALL_END_0_1414+0x126>
 c05c946:	e884 0003 	stmia.w	r4, {r0, r1}
 c05c94a:	f8cd a020 	str.w	sl, [sp, #32]
    volatile uint32_t counter = 0;
 c05c94e:	9309      	str	r3, [sp, #36]	@ 0x24
    delay = fih_delay_random();
 c05c950:	f7ff f83b 	bl	c05b9ca <fih_delay_random>
 c05c954:	9008      	str	r0, [sp, #32]
    if (delay == FIH_NEGATIVE_VALUE) {
 c05c956:	9b08      	ldr	r3, [sp, #32]
 c05c958:	4553      	cmp	r3, sl
 c05c95a:	d101      	bne.n	c05c960 <FIH_LABEL_FIH_CALL_START_tfm_hal_memory_has_access_0_1297+0x30>
        FIH_PANIC;
 c05c95c:	f7f6 f804 	bl	c052968 <Error_Handler>
    delay &= 0xFF;
 c05c960:	9b08      	ldr	r3, [sp, #32]
 c05c962:	b2db      	uxtb	r3, r3
 c05c964:	9308      	str	r3, [sp, #32]
    for (i = 0; i < delay; i++) {
 c05c966:	2300      	movs	r3, #0
 c05c968:	9a08      	ldr	r2, [sp, #32]
 c05c96a:	4293      	cmp	r3, r2
 c05c96c:	f0c0 80a0 	bcc.w	c05cab0 <FIH_LABEL_FIH_CALL_END_0_1414+0xfa>
    uint8_t local_delay = delay;
 c05c970:	9b08      	ldr	r3, [sp, #32]
    if (counter != local_delay) {
 c05c972:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 c05c974:	b2db      	uxtb	r3, r3
 c05c976:	4293      	cmp	r3, r2
 c05c978:	d001      	beq.n	c05c97e <FIH_LABEL_FIH_CALL_START_tfm_hal_memory_has_access_0_1297+0x4e>
        FIH_PANIC;
 c05c97a:	f7f5 fff5 	bl	c052968 <Error_Handler>
 c05c97e:	46ea      	mov	sl, sp
 c05c980:	462a      	mov	r2, r5
 c05c982:	463b      	mov	r3, r7
 c05c984:	4631      	mov	r1, r6
 c05c986:	4650      	mov	r0, sl
 c05c988:	f001 faac 	bl	c05dee4 <tfm_hal_memory_has_access>
 c05c98c:	e89a 0003 	ldmia.w	sl, {r0, r1}
 c05c990:	e884 0003 	stmia.w	r4, {r0, r1}
 c05c994:	e899 0003 	ldmia.w	r9, {r0, r1}
 c05c998:	f7fe ff7c 	bl	c05b894 <fih_cfi_validate>
 c05c99c:	e894 0003 	ldmia.w	r4, {r0, r1}
 c05c9a0:	ab1e      	add	r3, sp, #120	@ 0x78
 c05c9a2:	e903 0003 	stmdb	r3, {r0, r1}
    if (x.val != x_msk) {
 c05c9a6:	4d4e      	ldr	r5, [pc, #312]	@ (c05cae0 <FIH_LABEL_FIH_CALL_END_0_1414+0x12a>)
    int x_msk = x.msk;
 c05c9a8:	9b1d      	ldr	r3, [sp, #116]	@ 0x74
    if (x.val != x_msk) {
 c05c9aa:	9a1c      	ldr	r2, [sp, #112]	@ 0x70
 c05c9ac:	406b      	eors	r3, r5
 c05c9ae:	4293      	cmp	r3, r2
 c05c9b0:	d001      	beq.n	c05c9b6 <FIH_LABEL_FIH_CALL_END_0_1414>
        FIH_PANIC;
 c05c9b2:	f7f5 ffd9 	bl	c052968 <Error_Handler>

0c05c9b6 <FIH_LABEL_FIH_CALL_END_0_1414>:
    fih_int ret = {x, x ^ _FIH_MASK_VALUE};
 c05c9b6:	2600      	movs	r6, #0
 c05c9b8:	ab18      	add	r3, sp, #96	@ 0x60
 c05c9ba:	961a      	str	r6, [sp, #104]	@ 0x68
 c05c9bc:	951b      	str	r5, [sp, #108]	@ 0x6c
 c05c9be:	e9dd 011a 	ldrd	r0, r1, [sp, #104]	@ 0x68
 c05c9c2:	e883 0003 	stmia.w	r3, {r0, r1}
    return ret;
 c05c9c6:	aa0e      	add	r2, sp, #56	@ 0x38
 c05c9c8:	e893 0003 	ldmia.w	r3, {r0, r1}
 c05c9cc:	e882 0003 	stmia.w	r2, {r0, r1}
 c05c9d0:	e894 0003 	ldmia.w	r4, {r0, r1}
 c05c9d4:	ab10      	add	r3, sp, #64	@ 0x40
 c05c9d6:	ac12      	add	r4, sp, #72	@ 0x48
 c05c9d8:	e883 0003 	stmia.w	r3, {r0, r1}
 c05c9dc:	e892 0003 	ldmia.w	r2, {r0, r1}
 c05c9e0:	e884 0003 	stmia.w	r4, {r0, r1}
    volatile int32_t rc1 = FIH_FALSE;
 c05c9e4:	aa14      	add	r2, sp, #80	@ 0x50
 c05c9e6:	9602      	str	r6, [sp, #8]
    volatile int32_t rc2 = FIH_FALSE;
 c05c9e8:	9603      	str	r6, [sp, #12]
    fih_int_validate(x);
 c05c9ea:	e893 0003 	ldmia.w	r3, {r0, r1}
 c05c9ee:	e882 0003 	stmia.w	r2, {r0, r1}
    int x_msk = x.msk;
 c05c9f2:	9b15      	ldr	r3, [sp, #84]	@ 0x54
    if (x.val != x_msk) {
 c05c9f4:	9a14      	ldr	r2, [sp, #80]	@ 0x50
 c05c9f6:	406b      	eors	r3, r5
 c05c9f8:	4293      	cmp	r3, r2
 c05c9fa:	d001      	beq.n	c05ca00 <FIH_LABEL_FIH_CALL_END_0_1414+0x4a>
        FIH_PANIC;
 c05c9fc:	f7f5 ffb4 	bl	c052968 <Error_Handler>
    fih_int_validate(y);
 c05ca00:	e894 0003 	ldmia.w	r4, {r0, r1}
 c05ca04:	ab16      	add	r3, sp, #88	@ 0x58
 c05ca06:	e883 0003 	stmia.w	r3, {r0, r1}
    int x_msk = x.msk;
 c05ca0a:	9b17      	ldr	r3, [sp, #92]	@ 0x5c
    if (x.val != x_msk) {
 c05ca0c:	9a16      	ldr	r2, [sp, #88]	@ 0x58
 c05ca0e:	406b      	eors	r3, r5
 c05ca10:	4293      	cmp	r3, r2
 c05ca12:	d001      	beq.n	c05ca18 <FIH_LABEL_FIH_CALL_END_0_1414+0x62>
        FIH_PANIC;
 c05ca14:	f7f5 ffa8 	bl	c052968 <Error_Handler>
    int x_val = x.val;
 c05ca18:	9a10      	ldr	r2, [sp, #64]	@ 0x40
    if (x_val == y.val) {
 c05ca1a:	9b12      	ldr	r3, [sp, #72]	@ 0x48
    volatile uint32_t delay = FIH_NEGATIVE_VALUE;
 c05ca1c:	4c2f      	ldr	r4, [pc, #188]	@ (c05cadc <FIH_LABEL_FIH_CALL_END_0_1414+0x126>)
    if (x_val == y.val) {
 c05ca1e:	429a      	cmp	r2, r3
        rc1 = FIH_TRUE;
 c05ca20:	bf04      	itt	eq
 c05ca22:	f24c 335a 	movweq	r3, #50010	@ 0xc35a
 c05ca26:	9302      	streq	r3, [sp, #8]
    volatile uint32_t counter = 0;
 c05ca28:	2300      	movs	r3, #0
    volatile uint32_t delay = FIH_NEGATIVE_VALUE;
 c05ca2a:	9406      	str	r4, [sp, #24]
    volatile uint32_t counter = 0;
 c05ca2c:	9307      	str	r3, [sp, #28]
    delay = fih_delay_random();
 c05ca2e:	f7fe ffcc 	bl	c05b9ca <fih_delay_random>
 c05ca32:	9006      	str	r0, [sp, #24]
    if (delay == FIH_NEGATIVE_VALUE) {
 c05ca34:	9b06      	ldr	r3, [sp, #24]
 c05ca36:	42a3      	cmp	r3, r4
 c05ca38:	d101      	bne.n	c05ca3e <FIH_LABEL_FIH_CALL_END_0_1414+0x88>
        FIH_PANIC;
 c05ca3a:	f7f5 ff95 	bl	c052968 <Error_Handler>
    delay &= 0xFF;
 c05ca3e:	9b06      	ldr	r3, [sp, #24]
 c05ca40:	b2db      	uxtb	r3, r3
 c05ca42:	9306      	str	r3, [sp, #24]
    for (i = 0; i < delay; i++) {
 c05ca44:	2300      	movs	r3, #0
 c05ca46:	9a06      	ldr	r2, [sp, #24]
 c05ca48:	4293      	cmp	r3, r2
 c05ca4a:	d336      	bcc.n	c05caba <FIH_LABEL_FIH_CALL_END_0_1414+0x104>
    uint8_t local_delay = delay;
 c05ca4c:	9b06      	ldr	r3, [sp, #24]
    if (counter != local_delay) {
 c05ca4e:	9a07      	ldr	r2, [sp, #28]
 c05ca50:	b2db      	uxtb	r3, r3
 c05ca52:	4293      	cmp	r3, r2
 c05ca54:	d001      	beq.n	c05ca5a <FIH_LABEL_FIH_CALL_END_0_1414+0xa4>
        FIH_PANIC;
 c05ca56:	f7f5 ff87 	bl	c052968 <Error_Handler>
    int x_msk = x.msk;
 c05ca5a:	9a11      	ldr	r2, [sp, #68]	@ 0x44
    if (x_msk == y.msk) {
 c05ca5c:	9b13      	ldr	r3, [sp, #76]	@ 0x4c
    volatile uint32_t delay = FIH_NEGATIVE_VALUE;
 c05ca5e:	4c1f      	ldr	r4, [pc, #124]	@ (c05cadc <FIH_LABEL_FIH_CALL_END_0_1414+0x126>)
    if (x_msk == y.msk) {
 c05ca60:	429a      	cmp	r2, r3
        rc2 = FIH_TRUE;
 c05ca62:	bf04      	itt	eq
 c05ca64:	f24c 335a 	movweq	r3, #50010	@ 0xc35a
 c05ca68:	9303      	streq	r3, [sp, #12]
    volatile uint32_t counter = 0;
 c05ca6a:	2300      	movs	r3, #0
    volatile uint32_t delay = FIH_NEGATIVE_VALUE;
 c05ca6c:	9404      	str	r4, [sp, #16]
    volatile uint32_t counter = 0;
 c05ca6e:	9305      	str	r3, [sp, #20]
    delay = fih_delay_random();
 c05ca70:	f7fe ffab 	bl	c05b9ca <fih_delay_random>
 c05ca74:	9004      	str	r0, [sp, #16]
    if (delay == FIH_NEGATIVE_VALUE) {
 c05ca76:	9b04      	ldr	r3, [sp, #16]
 c05ca78:	42a3      	cmp	r3, r4
 c05ca7a:	d101      	bne.n	c05ca80 <FIH_LABEL_FIH_CALL_END_0_1414+0xca>
        FIH_PANIC;
 c05ca7c:	f7f5 ff74 	bl	c052968 <Error_Handler>
    delay &= 0xFF;
 c05ca80:	9b04      	ldr	r3, [sp, #16]
 c05ca82:	b2db      	uxtb	r3, r3
 c05ca84:	9304      	str	r3, [sp, #16]
    for (i = 0; i < delay; i++) {
 c05ca86:	9b04      	ldr	r3, [sp, #16]
 c05ca88:	4598      	cmp	r8, r3
 c05ca8a:	d31b      	bcc.n	c05cac4 <FIH_LABEL_FIH_CALL_END_0_1414+0x10e>
    uint8_t local_delay = delay;
 c05ca8c:	9b04      	ldr	r3, [sp, #16]
    if (counter != local_delay) {
 c05ca8e:	9a05      	ldr	r2, [sp, #20]
 c05ca90:	b2db      	uxtb	r3, r3
 c05ca92:	4293      	cmp	r3, r2
 c05ca94:	d001      	beq.n	c05ca9a <FIH_LABEL_FIH_CALL_END_0_1414+0xe4>
        FIH_PANIC;
 c05ca96:	f7f5 ff67 	bl	c052968 <Error_Handler>
    int loc_rc1 = rc1;
 c05ca9a:	9a02      	ldr	r2, [sp, #8]
    if (loc_rc1 != rc2) {
 c05ca9c:	9b03      	ldr	r3, [sp, #12]
 c05ca9e:	429a      	cmp	r2, r3
 c05caa0:	d001      	beq.n	c05caa6 <FIH_LABEL_FIH_CALL_END_0_1414+0xf0>
        FIH_PANIC;
 c05caa2:	f7f5 ff61 	bl	c052968 <Error_Handler>
    return rc1;
 c05caa6:	9b02      	ldr	r3, [sp, #8]
    if (fih_eq(fih_rc, fih_int_encode(TFM_HAL_SUCCESS))) {
 c05caa8:	2b00      	cmp	r3, #0
 c05caaa:	f47f af26 	bne.w	c05c8fa <tfm_memory_check+0x1a>
 c05caae:	e732      	b.n	c05c916 <tfm_memory_check+0x36>
        counter++;
 c05cab0:	9a09      	ldr	r2, [sp, #36]	@ 0x24
    for (i = 0; i < delay; i++) {
 c05cab2:	3301      	adds	r3, #1
        counter++;
 c05cab4:	3201      	adds	r2, #1
 c05cab6:	9209      	str	r2, [sp, #36]	@ 0x24
    for (i = 0; i < delay; i++) {
 c05cab8:	e756      	b.n	c05c968 <FIH_LABEL_FIH_CALL_START_tfm_hal_memory_has_access_0_1297+0x38>
        counter++;
 c05caba:	9a07      	ldr	r2, [sp, #28]
    for (i = 0; i < delay; i++) {
 c05cabc:	3301      	adds	r3, #1
        counter++;
 c05cabe:	3201      	adds	r2, #1
 c05cac0:	9207      	str	r2, [sp, #28]
    for (i = 0; i < delay; i++) {
 c05cac2:	e7c0      	b.n	c05ca46 <FIH_LABEL_FIH_CALL_END_0_1414+0x90>
        counter++;
 c05cac4:	9b05      	ldr	r3, [sp, #20]
    for (i = 0; i < delay; i++) {
 c05cac6:	f108 0801 	add.w	r8, r8, #1
        counter++;
 c05caca:	3301      	adds	r3, #1
 c05cacc:	9305      	str	r3, [sp, #20]
    for (i = 0; i < delay; i++) {
 c05cace:	e7da      	b.n	c05ca86 <FIH_LABEL_FIH_CALL_END_0_1414+0xd0>
        return SPM_ERROR_BAD_PARAMETERS;
 c05cad0:	4804      	ldr	r0, [pc, #16]	@ (c05cae4 <FIH_LABEL_FIH_CALL_END_0_1414+0x12e>)
 c05cad2:	e713      	b.n	c05c8fc <tfm_memory_check+0x1c>
 c05cad4:	3003091c 	.word	0x3003091c
 c05cad8:	80000004 	.word	0x80000004
 c05cadc:	aaaa5555 	.word	0xaaaa5555
 c05cae0:	a5c35a3c 	.word	0xa5c35a3c
 c05cae4:	80000001 	.word	0x80000001

0c05cae8 <tfm_spm_init>:

uint32_t tfm_spm_init(void)
{
 c05cae8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    uint32_t i, j, num;
    struct partition_t *partition;
    struct tfm_core_thread_t *pth, *p_ns_entry_thread = NULL;
    const struct platform_data_t **platform_data_p;
#ifdef TFM_FIH_PROFILE_ON
    fih_int fih_rc = FIH_FAILURE;
 c05caec:	4c5e      	ldr	r4, [pc, #376]	@ (c05cc68 <tfm_spm_init+0x180>)
{
 c05caee:	b0a5      	sub	sp, #148	@ 0x94
    fih_int fih_rc = FIH_FAILURE;
 c05caf0:	ad10      	add	r5, sp, #64	@ 0x40
 c05caf2:	e894 0003 	ldmia.w	r4, {r0, r1}
#endif

    tfm_pool_init(conn_handle_pool,
 c05caf6:	2310      	movs	r3, #16
    fih_int fih_rc = FIH_FAILURE;
 c05caf8:	e885 0003 	stmia.w	r5, {r0, r1}
    tfm_pool_init(conn_handle_pool,
 c05cafc:	22a4      	movs	r2, #164	@ 0xa4
 c05cafe:	f44f 612d 	mov.w	r1, #2768	@ 0xad0
 c05cb02:	485a      	ldr	r0, [pc, #360]	@ (c05cc6c <tfm_spm_init+0x184>)
 c05cb04:	f001 fcb2 	bl	c05e46c <tfm_pool_init>
                  POOL_BUFFER_SIZE(conn_handle_pool),
                  sizeof(struct tfm_conn_handle_t),
                  TFM_CONN_HANDLE_MAX_NUM);

    /* Init partition first for it will be used when init service */
    for (i = 0; i < g_spm_partition_db.partition_count; i++) {
 c05cb08:	4b59      	ldr	r3, [pc, #356]	@ (c05cc70 <tfm_spm_init+0x188>)
 c05cb0a:	9405      	str	r4, [sp, #20]
 c05cb0c:	9302      	str	r3, [sp, #8]
 c05cb0e:	4b59      	ldr	r3, [pc, #356]	@ (c05cc74 <tfm_spm_init+0x18c>)
 c05cb10:	9303      	str	r3, [sp, #12]
    struct tfm_core_thread_t *pth, *p_ns_entry_thread = NULL;
 c05cb12:	2300      	movs	r3, #0
    for (i = 0; i < g_spm_partition_db.partition_count; i++) {
 c05cb14:	469a      	mov	sl, r3
    struct tfm_core_thread_t *pth, *p_ns_entry_thread = NULL;
 c05cb16:	9304      	str	r3, [sp, #16]
    for (i = 0; i < g_spm_partition_db.partition_count; i++) {
 c05cb18:	4b57      	ldr	r3, [pc, #348]	@ (c05cc78 <tfm_spm_init+0x190>)
 c05cb1a:	681b      	ldr	r3, [r3, #0]
 c05cb1c:	4553      	cmp	r3, sl
 c05cb1e:	d830      	bhi.n	c05cb82 <tfm_spm_init+0x9a>
        }
    }

    /* Init Service */
    num = sizeof(service) / sizeof(struct tfm_spm_service_t);
    for (i = 0; i < num; i++) {
 c05cb20:	2700      	movs	r7, #0
 c05cb22:	4d56      	ldr	r5, [pc, #344]	@ (c05cc7c <tfm_spm_init+0x194>)
 c05cb24:	4c56      	ldr	r4, [pc, #344]	@ (c05cc80 <tfm_spm_init+0x198>)
        partition->signals_allowed |= service[i].service_db->signal;

        /* Populate the p_service of stateless_service_ref[] */
        if (service_db[i].connection_based == false) {
            for (j = 0; j < STATIC_HANDLE_NUM_LIMIT; j++) {
                if (stateless_service_ref[j].sid == service_db[i].sid) {
 c05cb26:	f8df 815c 	ldr.w	r8, [pc, #348]	@ c05cc84 <tfm_spm_init+0x19c>
            tfm_spm_get_partition_by_id(service[i].service_db->partition_id);
 c05cb2a:	6868      	ldr	r0, [r5, #4]
        service[i].service_db = &service_db[i];
 c05cb2c:	6025      	str	r5, [r4, #0]
            tfm_spm_get_partition_by_id(service[i].service_db->partition_id);
 c05cb2e:	f7ff fd4d 	bl	c05c5cc <tfm_spm_get_partition_by_id>
        if (!partition) {
 c05cb32:	4606      	mov	r6, r0
 c05cb34:	b908      	cbnz	r0, c05cb3a <tfm_spm_init+0x52>
            tfm_core_panic();
 c05cb36:	f001 fdd7 	bl	c05e6e8 <tfm_core_panic>
        partition->signals_allowed |= service[i].service_db->signal;
 c05cb3a:	6822      	ldr	r2, [r4, #0]
 c05cb3c:	6ef3      	ldr	r3, [r6, #108]	@ 0x6c
 c05cb3e:	6892      	ldr	r2, [r2, #8]
        service[i].partition = partition;
 c05cb40:	6066      	str	r6, [r4, #4]
        partition->signals_allowed |= service[i].service_db->signal;
 c05cb42:	4313      	orrs	r3, r2
 c05cb44:	66f3      	str	r3, [r6, #108]	@ 0x6c
        if (service_db[i].connection_based == false) {
 c05cb46:	7c6b      	ldrb	r3, [r5, #17]
 c05cb48:	b943      	cbnz	r3, c05cb5c <tfm_spm_init+0x74>
                if (stateless_service_ref[j].sid == service_db[i].sid) {
 c05cb4a:	68ea      	ldr	r2, [r5, #12]
 c05cb4c:	f858 1033 	ldr.w	r1, [r8, r3, lsl #3]
 c05cb50:	eb08 00c3 	add.w	r0, r8, r3, lsl #3
 c05cb54:	4291      	cmp	r1, r2
 c05cb56:	f040 8192 	bne.w	c05ce7e <FIH_LABEL_FIH_CALL_END_0_2277+0x156>
                    stateless_service_ref[j].p_service = &service[i];
 c05cb5a:	6044      	str	r4, [r0, #4]
    for (i = 0; i < num; i++) {
 c05cb5c:	3701      	adds	r7, #1
            if (j >= STATIC_HANDLE_NUM_LIMIT) {
                tfm_core_panic();
            }
        }

        BI_LIST_INIT_NODE(&service[i].handle_list);
 c05cb5e:	f104 0308 	add.w	r3, r4, #8
    for (i = 0; i < num; i++) {
 c05cb62:	2f17      	cmp	r7, #23
        BI_LIST_INIT_NODE(&service[i].handle_list);
 c05cb64:	e9c4 3302 	strd	r3, r3, [r4, #8]
    for (i = 0; i < num; i++) {
 c05cb68:	f105 051c 	add.w	r5, r5, #28
 c05cb6c:	f104 0418 	add.w	r4, r4, #24
 c05cb70:	d1db      	bne.n	c05cb2a <tfm_spm_init+0x42>
     * initialization thread who calls SPM SVC, which re-uses the non-secure
     * entry thread's stack. After SPM initialization is done, this stack is
     * cleaned up and the background context is never going to return. Tell
     * the scheduler that the current thread is non-secure entry thread.
     */
    tfm_core_thrd_start_scheduler(p_ns_entry_thread);
 c05cb72:	9804      	ldr	r0, [sp, #16]
 c05cb74:	f001 fd42 	bl	c05e5fc <tfm_core_thrd_start_scheduler>

    return p_ns_entry_thread->arch_ctx.lr;
}
 c05cb78:	9b04      	ldr	r3, [sp, #16]
 c05cb7a:	6c58      	ldr	r0, [r3, #68]	@ 0x44
 c05cb7c:	b025      	add	sp, #148	@ 0x94
 c05cb7e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        partition = &g_spm_partition_db.partitions[i];
 c05cb82:	267c      	movs	r6, #124	@ 0x7c
 c05cb84:	4b3c      	ldr	r3, [pc, #240]	@ (c05cc78 <tfm_spm_init+0x190>)
 c05cb86:	fb06 f60a 	mul.w	r6, r6, sl
 c05cb8a:	685f      	ldr	r7, [r3, #4]
        partition->p_static = &static_data_list[i];
 c05cb8c:	9b02      	ldr	r3, [sp, #8]
        partition = &g_spm_partition_db.partitions[i];
 c05cb8e:	19bc      	adds	r4, r7, r6
        partition->p_static = &static_data_list[i];
 c05cb90:	51bb      	str	r3, [r7, r6]
        partition->memory_data = &memory_data_list[i];
 c05cb92:	9b03      	ldr	r3, [sp, #12]
 c05cb94:	67a3      	str	r3, [r4, #120]	@ 0x78
        if (!(partition->p_static->flags & SPM_PART_FLAG_IPC)) {
 c05cb96:	9b02      	ldr	r3, [sp, #8]
 c05cb98:	689b      	ldr	r3, [r3, #8]
 c05cb9a:	075b      	lsls	r3, r3, #29
 c05cb9c:	d401      	bmi.n	c05cba2 <tfm_spm_init+0xba>
            tfm_core_panic();
 c05cb9e:	f001 fda3 	bl	c05e6e8 <tfm_core_panic>
        if (partition->p_static->psa_ff_ver >
 c05cba2:	59bb      	ldr	r3, [r7, r6]
 c05cba4:	681a      	ldr	r2, [r3, #0]
 c05cba6:	f5b2 7f81 	cmp.w	r2, #258	@ 0x102
 c05cbaa:	d254      	bcs.n	c05cc56 <tfm_spm_init+0x16e>
            (const struct platform_data_t **)partition->p_static->platform_data;
 c05cbac:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
        if (platform_data_p != NULL) {
 c05cbae:	2b00      	cmp	r3, #0
 c05cbb0:	d16c      	bne.n	c05cc8c <tfm_spm_init+0x1a4>
        partition->signals_allowed |= PSA_DOORBELL;
 c05cbb2:	6ee3      	ldr	r3, [r4, #108]	@ 0x6c
 c05cbb4:	f043 0208 	orr.w	r2, r3, #8
 c05cbb8:	66e2      	str	r2, [r4, #108]	@ 0x6c
                partition->p_static->pid) {
 c05cbba:	59ba      	ldr	r2, [r7, r6]
            if (tfm_core_irq_signals[j].partition_id ==
 c05cbbc:	6851      	ldr	r1, [r2, #4]
 c05cbbe:	f5b1 7f82 	cmp.w	r1, #260	@ 0x104
 c05cbc2:	d110      	bne.n	c05cbe6 <tfm_spm_init+0xfe>
                partition->signals_allowed |=
 c05cbc4:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
 c05cbc8:	f043 0308 	orr.w	r3, r3, #8
 c05cbcc:	66e3      	str	r3, [r4, #108]	@ 0x6c
                if (partition->p_static->psa_ff_ver == 0x0100) {
 c05cbce:	6813      	ldr	r3, [r2, #0]
 c05cbd0:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 c05cbd4:	f000 814b 	beq.w	c05ce6e <FIH_LABEL_FIH_CALL_END_0_2277+0x146>
                } else if (partition->p_static->psa_ff_ver == 0x0101) {
 c05cbd8:	f240 1201 	movw	r2, #257	@ 0x101
 c05cbdc:	4293      	cmp	r3, r2
 c05cbde:	d102      	bne.n	c05cbe6 <tfm_spm_init+0xfe>
                    tfm_spm_hal_disable_irq(tfm_core_irq_signals[j].irq_line);
 c05cbe0:	2004      	movs	r0, #4
 c05cbe2:	f7f3 ffe7 	bl	c050bb4 <tfm_spm_hal_disable_irq>
                partition->p_static->pid) {
 c05cbe6:	59ba      	ldr	r2, [r7, r6]
            if (tfm_core_irq_signals[j].partition_id ==
 c05cbe8:	6853      	ldr	r3, [r2, #4]
 c05cbea:	f5b3 7f82 	cmp.w	r3, #260	@ 0x104
 c05cbee:	d10f      	bne.n	c05cc10 <tfm_spm_init+0x128>
                partition->signals_allowed |=
 c05cbf0:	6ee3      	ldr	r3, [r4, #108]	@ 0x6c
 c05cbf2:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
 c05cbf6:	66e3      	str	r3, [r4, #108]	@ 0x6c
                if (partition->p_static->psa_ff_ver == 0x0100) {
 c05cbf8:	6813      	ldr	r3, [r2, #0]
 c05cbfa:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 c05cbfe:	f000 813a 	beq.w	c05ce76 <FIH_LABEL_FIH_CALL_END_0_2277+0x14e>
                } else if (partition->p_static->psa_ff_ver == 0x0101) {
 c05cc02:	f240 1201 	movw	r2, #257	@ 0x101
 c05cc06:	4293      	cmp	r3, r2
 c05cc08:	d102      	bne.n	c05cc10 <tfm_spm_init+0x128>
                    tfm_spm_hal_disable_irq(tfm_core_irq_signals[j].irq_line);
 c05cc0a:	2008      	movs	r0, #8
 c05cc0c:	f7f3 ffd2 	bl	c050bb4 <tfm_spm_hal_disable_irq>
 c05cc10:	2200      	movs	r2, #0
 c05cc12:	4b1d      	ldr	r3, [pc, #116]	@ (c05cc88 <tfm_spm_init+0x1a0>)
                           (tfm_core_thrd_entry_t)partition->p_static->entry,
 c05cc14:	59b9      	ldr	r1, [r7, r6]
 c05cc16:	e9c4 3217 	strd	r3, r2, [r4, #92]	@ 0x5c
        BI_LIST_INIT_NODE(&partition->msg_list);
 c05cc1a:	f104 0364 	add.w	r3, r4, #100	@ 0x64
 c05cc1e:	e9c4 3319 	strd	r3, r3, [r4, #100]	@ 0x64
                           (uintptr_t)partition->memory_data->stack_top,
 c05cc22:	6fa3      	ldr	r3, [r4, #120]	@ 0x78
        pth = &partition->sp_thread;
 c05cc24:	f104 0810 	add.w	r8, r4, #16
        tfm_core_thrd_init(pth,
 c05cc28:	6818      	ldr	r0, [r3, #0]
 c05cc2a:	9000      	str	r0, [sp, #0]
 c05cc2c:	685b      	ldr	r3, [r3, #4]
 c05cc2e:	4640      	mov	r0, r8
 c05cc30:	6909      	ldr	r1, [r1, #16]
 c05cc32:	f001 fc91 	bl	c05e558 <tfm_core_thrd_init>
        pth->prior = partition->p_static->priority;
 c05cc36:	59bb      	ldr	r3, [r7, r6]
 c05cc38:	68da      	ldr	r2, [r3, #12]
        if (partition->p_static->pid == TFM_SP_NON_SECURE_ID) {
 c05cc3a:	685b      	ldr	r3, [r3, #4]
        pth->prior = partition->p_static->priority;
 c05cc3c:	6222      	str	r2, [r4, #32]
        if (partition->p_static->pid == TFM_SP_NON_SECURE_ID) {
 c05cc3e:	b923      	cbnz	r3, c05cc4a <tfm_spm_init+0x162>
            pth->param = (void *)tfm_spm_hal_get_ns_entry_point();
 c05cc40:	f7f3 ff82 	bl	c050b48 <tfm_spm_hal_get_ns_entry_point>
            p_ns_entry_thread = pth;
 c05cc44:	f8cd 8010 	str.w	r8, [sp, #16]
            pth->param = (void *)tfm_spm_hal_get_ns_entry_point();
 c05cc48:	6160      	str	r0, [r4, #20]
        if (tfm_core_thrd_start(pth) != THRD_SUCCESS) {
 c05cc4a:	4640      	mov	r0, r8
 c05cc4c:	f001 fca2 	bl	c05e594 <tfm_core_thrd_start>
 c05cc50:	b108      	cbz	r0, c05cc56 <tfm_spm_init+0x16e>
            tfm_core_panic();
 c05cc52:	f001 fd49 	bl	c05e6e8 <tfm_core_panic>
    for (i = 0; i < g_spm_partition_db.partition_count; i++) {
 c05cc56:	9b02      	ldr	r3, [sp, #8]
 c05cc58:	f10a 0a01 	add.w	sl, sl, #1
 c05cc5c:	3330      	adds	r3, #48	@ 0x30
 c05cc5e:	9302      	str	r3, [sp, #8]
 c05cc60:	9b03      	ldr	r3, [sp, #12]
 c05cc62:	3308      	adds	r3, #8
 c05cc64:	9303      	str	r3, [sp, #12]
 c05cc66:	e757      	b.n	c05cb18 <tfm_spm_init+0x30>
 c05cc68:	3003091c 	.word	0x3003091c
 c05cc6c:	30037808 	.word	0x30037808
 c05cc70:	0c06197c 	.word	0x0c06197c
 c05cc74:	0c06193c 	.word	0x0c06193c
 c05cc78:	30030958 	.word	0x30030958
 c05cc7c:	0c061c90 	.word	0x0c061c90
 c05cc80:	300386b8 	.word	0x300386b8
 c05cc84:	30030998 	.word	0x30030998
 c05cc88:	65766e74 	.word	0x65766e74
        platform_data_p =
 c05cc8c:	4698      	mov	r8, r3
    volatile uint32_t delay = FIH_NEGATIVE_VALUE;
 c05cc8e:	f8df 91fc 	ldr.w	r9, [pc, #508]	@ c05ce8c <FIH_LABEL_FIH_CALL_END_0_2277+0x164>
            while ((*platform_data_p) != NULL) {
 c05cc92:	f8d8 3000 	ldr.w	r3, [r8]
 c05cc96:	2b00      	cmp	r3, #0
 c05cc98:	d08b      	beq.n	c05cbb2 <tfm_spm_init+0xca>

0c05cc9a <FIH_LABEL_FIH_CALL_START_tfm_spm_hal_configure_default_isolation_0_2156>:
                FIH_CALL(tfm_spm_hal_configure_default_isolation, fih_rc, i,
 c05cc9a:	f10d 0b48 	add.w	fp, sp, #72	@ 0x48
 c05cc9e:	2101      	movs	r1, #1
 c05cca0:	4658      	mov	r0, fp
 c05cca2:	f7fe fd63 	bl	c05b76c <fih_cfi_get_and_increment>
 c05cca6:	9b05      	ldr	r3, [sp, #20]
 c05cca8:	e893 0003 	ldmia.w	r3, {r0, r1}
    volatile uint32_t counter = 0;
 c05ccac:	2300      	movs	r3, #0
 c05ccae:	e885 0003 	stmia.w	r5, {r0, r1}
    volatile uint32_t delay = FIH_NEGATIVE_VALUE;
 c05ccb2:	f8cd 9038 	str.w	r9, [sp, #56]	@ 0x38
    volatile uint32_t counter = 0;
 c05ccb6:	930f      	str	r3, [sp, #60]	@ 0x3c
    delay = fih_delay_random();
 c05ccb8:	f7fe fe87 	bl	c05b9ca <fih_delay_random>
 c05ccbc:	900e      	str	r0, [sp, #56]	@ 0x38
    if (delay == FIH_NEGATIVE_VALUE) {
 c05ccbe:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
 c05ccc0:	454b      	cmp	r3, r9
 c05ccc2:	d101      	bne.n	c05ccc8 <FIH_LABEL_FIH_CALL_START_tfm_spm_hal_configure_default_isolation_0_2156+0x2e>
        FIH_PANIC;
 c05ccc4:	f7f5 fe50 	bl	c052968 <Error_Handler>
    delay &= 0xFF;
 c05ccc8:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
 c05ccca:	b2db      	uxtb	r3, r3
 c05cccc:	930e      	str	r3, [sp, #56]	@ 0x38
    for (i = 0; i < delay; i++) {
 c05ccce:	2300      	movs	r3, #0
 c05ccd0:	9a0e      	ldr	r2, [sp, #56]	@ 0x38
 c05ccd2:	4293      	cmp	r3, r2
 c05ccd4:	f0c0 80bc 	bcc.w	c05ce50 <FIH_LABEL_FIH_CALL_END_0_2277+0x128>
    uint8_t local_delay = delay;
 c05ccd8:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
    if (counter != local_delay) {
 c05ccda:	9a0f      	ldr	r2, [sp, #60]	@ 0x3c
 c05ccdc:	b2db      	uxtb	r3, r3
 c05ccde:	4293      	cmp	r3, r2
 c05cce0:	d001      	beq.n	c05cce6 <FIH_LABEL_FIH_CALL_START_tfm_spm_hal_configure_default_isolation_0_2156+0x4c>
        FIH_PANIC;
 c05cce2:	f7f5 fe41 	bl	c052968 <Error_Handler>
 c05cce6:	f8d8 2000 	ldr.w	r2, [r8]
 c05ccea:	4651      	mov	r1, sl
 c05ccec:	a806      	add	r0, sp, #24
 c05ccee:	f7f3 ff15 	bl	c050b1c <tfm_spm_hal_configure_default_isolation>
 c05ccf2:	a806      	add	r0, sp, #24
 c05ccf4:	c803      	ldmia	r0, {r0, r1}
 c05ccf6:	e885 0003 	stmia.w	r5, {r0, r1}
 c05ccfa:	e89b 0003 	ldmia.w	fp, {r0, r1}
 c05ccfe:	f7fe fdc9 	bl	c05b894 <fih_cfi_validate>
 c05cd02:	e895 0003 	ldmia.w	r5, {r0, r1}
 c05cd06:	ab24      	add	r3, sp, #144	@ 0x90
 c05cd08:	e903 0003 	stmdb	r3, {r0, r1}
    int x_msk = x.msk;
 c05cd0c:	9b23      	ldr	r3, [sp, #140]	@ 0x8c
    if (x.val != x_msk) {
 c05cd0e:	9a22      	ldr	r2, [sp, #136]	@ 0x88
 c05cd10:	f083 4325 	eor.w	r3, r3, #2768240640	@ 0xa5000000
 c05cd14:	f483 0343 	eor.w	r3, r3, #12779520	@ 0xc30000
 c05cd18:	f483 43b4 	eor.w	r3, r3, #23040	@ 0x5a00
 c05cd1c:	f083 033c 	eor.w	r3, r3, #60	@ 0x3c
 c05cd20:	4293      	cmp	r3, r2
 c05cd22:	d001      	beq.n	c05cd28 <FIH_LABEL_FIH_CALL_END_0_2277>
        FIH_PANIC;
 c05cd24:	f7f5 fe20 	bl	c052968 <Error_Handler>

0c05cd28 <FIH_LABEL_FIH_CALL_END_0_2277>:
    fih_int ret = {x, x ^ _FIH_MASK_VALUE};
 c05cd28:	f04f 0c00 	mov.w	ip, #0
 c05cd2c:	4b58      	ldr	r3, [pc, #352]	@ (c05ce90 <FIH_LABEL_FIH_CALL_END_0_2277+0x168>)
 c05cd2e:	f8cd c080 	str.w	ip, [sp, #128]	@ 0x80
 c05cd32:	9321      	str	r3, [sp, #132]	@ 0x84
 c05cd34:	ab1e      	add	r3, sp, #120	@ 0x78
 c05cd36:	e9dd 0120 	ldrd	r0, r1, [sp, #128]	@ 0x80
 c05cd3a:	e883 0003 	stmia.w	r3, {r0, r1}
    return ret;
 c05cd3e:	aa14      	add	r2, sp, #80	@ 0x50
 c05cd40:	e893 0003 	ldmia.w	r3, {r0, r1}
 c05cd44:	e882 0003 	stmia.w	r2, {r0, r1}
 c05cd48:	e895 0003 	ldmia.w	r5, {r0, r1}
 c05cd4c:	ab16      	add	r3, sp, #88	@ 0x58
 c05cd4e:	f10d 0b60 	add.w	fp, sp, #96	@ 0x60
 c05cd52:	e883 0003 	stmia.w	r3, {r0, r1}
 c05cd56:	e892 0003 	ldmia.w	r2, {r0, r1}
 c05cd5a:	e88b 0003 	stmia.w	fp, {r0, r1}
    volatile int32_t rc1 = FIH_FALSE;
 c05cd5e:	aa1a      	add	r2, sp, #104	@ 0x68
 c05cd60:	f8cd c020 	str.w	ip, [sp, #32]
    volatile int32_t rc2 = FIH_FALSE;
 c05cd64:	f8cd c024 	str.w	ip, [sp, #36]	@ 0x24
    fih_int_validate(x);
 c05cd68:	e893 0003 	ldmia.w	r3, {r0, r1}
 c05cd6c:	e882 0003 	stmia.w	r2, {r0, r1}
    int x_msk = x.msk;
 c05cd70:	9b1b      	ldr	r3, [sp, #108]	@ 0x6c
    if (x.val != x_msk) {
 c05cd72:	9a1a      	ldr	r2, [sp, #104]	@ 0x68
 c05cd74:	f083 4325 	eor.w	r3, r3, #2768240640	@ 0xa5000000
 c05cd78:	f483 0343 	eor.w	r3, r3, #12779520	@ 0xc30000
 c05cd7c:	f483 43b4 	eor.w	r3, r3, #23040	@ 0x5a00
 c05cd80:	f083 033c 	eor.w	r3, r3, #60	@ 0x3c
 c05cd84:	4293      	cmp	r3, r2
 c05cd86:	d001      	beq.n	c05cd8c <FIH_LABEL_FIH_CALL_END_0_2277+0x64>
        FIH_PANIC;
 c05cd88:	f7f5 fdee 	bl	c052968 <Error_Handler>
    fih_int_validate(y);
 c05cd8c:	e89b 0003 	ldmia.w	fp, {r0, r1}
 c05cd90:	ab1c      	add	r3, sp, #112	@ 0x70
 c05cd92:	e883 0003 	stmia.w	r3, {r0, r1}
    int x_msk = x.msk;
 c05cd96:	9b1d      	ldr	r3, [sp, #116]	@ 0x74
    if (x.val != x_msk) {
 c05cd98:	9a1c      	ldr	r2, [sp, #112]	@ 0x70
 c05cd9a:	f083 4325 	eor.w	r3, r3, #2768240640	@ 0xa5000000
 c05cd9e:	f483 0343 	eor.w	r3, r3, #12779520	@ 0xc30000
 c05cda2:	f483 43b4 	eor.w	r3, r3, #23040	@ 0x5a00
 c05cda6:	f083 033c 	eor.w	r3, r3, #60	@ 0x3c
 c05cdaa:	4293      	cmp	r3, r2
 c05cdac:	d001      	beq.n	c05cdb2 <FIH_LABEL_FIH_CALL_END_0_2277+0x8a>
        FIH_PANIC;
 c05cdae:	f7f5 fddb 	bl	c052968 <Error_Handler>
    int x_val = x.val;
 c05cdb2:	9a16      	ldr	r2, [sp, #88]	@ 0x58
    if (x_val != y.val) {
 c05cdb4:	9b18      	ldr	r3, [sp, #96]	@ 0x60
 c05cdb6:	429a      	cmp	r2, r3
        rc1 = FIH_TRUE;
 c05cdb8:	bf1c      	itt	ne
 c05cdba:	f24c 335a 	movwne	r3, #50010	@ 0xc35a
 c05cdbe:	9308      	strne	r3, [sp, #32]
    volatile uint32_t counter = 0;
 c05cdc0:	2300      	movs	r3, #0
    volatile uint32_t delay = FIH_NEGATIVE_VALUE;
 c05cdc2:	f8cd 9030 	str.w	r9, [sp, #48]	@ 0x30
    volatile uint32_t counter = 0;
 c05cdc6:	930d      	str	r3, [sp, #52]	@ 0x34
    delay = fih_delay_random();
 c05cdc8:	f7fe fdff 	bl	c05b9ca <fih_delay_random>
 c05cdcc:	900c      	str	r0, [sp, #48]	@ 0x30
    if (delay == FIH_NEGATIVE_VALUE) {
 c05cdce:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
 c05cdd0:	454b      	cmp	r3, r9
 c05cdd2:	d101      	bne.n	c05cdd8 <FIH_LABEL_FIH_CALL_END_0_2277+0xb0>
        FIH_PANIC;
 c05cdd4:	f7f5 fdc8 	bl	c052968 <Error_Handler>
    delay &= 0xFF;
 c05cdd8:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
 c05cdda:	b2db      	uxtb	r3, r3
 c05cddc:	930c      	str	r3, [sp, #48]	@ 0x30
    for (i = 0; i < delay; i++) {
 c05cdde:	2300      	movs	r3, #0
 c05cde0:	9a0c      	ldr	r2, [sp, #48]	@ 0x30
 c05cde2:	4293      	cmp	r3, r2
 c05cde4:	d339      	bcc.n	c05ce5a <FIH_LABEL_FIH_CALL_END_0_2277+0x132>
    uint8_t local_delay = delay;
 c05cde6:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
    if (counter != local_delay) {
 c05cde8:	9a0d      	ldr	r2, [sp, #52]	@ 0x34
 c05cdea:	b2db      	uxtb	r3, r3
 c05cdec:	4293      	cmp	r3, r2
 c05cdee:	d001      	beq.n	c05cdf4 <FIH_LABEL_FIH_CALL_END_0_2277+0xcc>
        FIH_PANIC;
 c05cdf0:	f7f5 fdba 	bl	c052968 <Error_Handler>
    int x_msk = x.msk;
 c05cdf4:	9a17      	ldr	r2, [sp, #92]	@ 0x5c
    if (x_msk != y.msk) {
 c05cdf6:	9b19      	ldr	r3, [sp, #100]	@ 0x64
 c05cdf8:	429a      	cmp	r2, r3
        rc2 = FIH_TRUE;
 c05cdfa:	bf1c      	itt	ne
 c05cdfc:	f24c 335a 	movwne	r3, #50010	@ 0xc35a
 c05ce00:	9309      	strne	r3, [sp, #36]	@ 0x24
    volatile uint32_t counter = 0;
 c05ce02:	2300      	movs	r3, #0
    volatile uint32_t delay = FIH_NEGATIVE_VALUE;
 c05ce04:	f8cd 9028 	str.w	r9, [sp, #40]	@ 0x28
    volatile uint32_t counter = 0;
 c05ce08:	930b      	str	r3, [sp, #44]	@ 0x2c
    delay = fih_delay_random();
 c05ce0a:	f7fe fdde 	bl	c05b9ca <fih_delay_random>
 c05ce0e:	900a      	str	r0, [sp, #40]	@ 0x28
    if (delay == FIH_NEGATIVE_VALUE) {
 c05ce10:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 c05ce12:	454b      	cmp	r3, r9
 c05ce14:	d101      	bne.n	c05ce1a <FIH_LABEL_FIH_CALL_END_0_2277+0xf2>
        FIH_PANIC;
 c05ce16:	f7f5 fda7 	bl	c052968 <Error_Handler>
    delay &= 0xFF;
 c05ce1a:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 c05ce1c:	b2db      	uxtb	r3, r3
 c05ce1e:	930a      	str	r3, [sp, #40]	@ 0x28
    for (i = 0; i < delay; i++) {
 c05ce20:	2300      	movs	r3, #0
 c05ce22:	9a0a      	ldr	r2, [sp, #40]	@ 0x28
 c05ce24:	4293      	cmp	r3, r2
 c05ce26:	d31d      	bcc.n	c05ce64 <FIH_LABEL_FIH_CALL_END_0_2277+0x13c>
    uint8_t local_delay = delay;
 c05ce28:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
    if (counter != local_delay) {
 c05ce2a:	9a0b      	ldr	r2, [sp, #44]	@ 0x2c
 c05ce2c:	b2db      	uxtb	r3, r3
 c05ce2e:	4293      	cmp	r3, r2
 c05ce30:	d001      	beq.n	c05ce36 <FIH_LABEL_FIH_CALL_END_0_2277+0x10e>
        FIH_PANIC;
 c05ce32:	f7f5 fd99 	bl	c052968 <Error_Handler>
    int loc_rc1 = rc1;
 c05ce36:	9a08      	ldr	r2, [sp, #32]
    if (loc_rc1 != rc2) {
 c05ce38:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 c05ce3a:	429a      	cmp	r2, r3
 c05ce3c:	d001      	beq.n	c05ce42 <FIH_LABEL_FIH_CALL_END_0_2277+0x11a>
        FIH_PANIC;
 c05ce3e:	f7f5 fd93 	bl	c052968 <Error_Handler>
    return rc1;
 c05ce42:	9b08      	ldr	r3, [sp, #32]
                if (fih_not_eq(fih_rc, fih_int_encode(TFM_PLAT_ERR_SUCCESS))) {
 c05ce44:	b10b      	cbz	r3, c05ce4a <FIH_LABEL_FIH_CALL_END_0_2277+0x122>
                    tfm_core_panic();
 c05ce46:	f001 fc4f 	bl	c05e6e8 <tfm_core_panic>
                ++platform_data_p;
 c05ce4a:	f108 0804 	add.w	r8, r8, #4
 c05ce4e:	e720      	b.n	c05cc92 <tfm_spm_init+0x1aa>
        counter++;
 c05ce50:	9a0f      	ldr	r2, [sp, #60]	@ 0x3c
    for (i = 0; i < delay; i++) {
 c05ce52:	3301      	adds	r3, #1
        counter++;
 c05ce54:	3201      	adds	r2, #1
 c05ce56:	920f      	str	r2, [sp, #60]	@ 0x3c
    for (i = 0; i < delay; i++) {
 c05ce58:	e73a      	b.n	c05ccd0 <FIH_LABEL_FIH_CALL_START_tfm_spm_hal_configure_default_isolation_0_2156+0x36>
        counter++;
 c05ce5a:	9a0d      	ldr	r2, [sp, #52]	@ 0x34
    for (i = 0; i < delay; i++) {
 c05ce5c:	3301      	adds	r3, #1
        counter++;
 c05ce5e:	3201      	adds	r2, #1
 c05ce60:	920d      	str	r2, [sp, #52]	@ 0x34
    for (i = 0; i < delay; i++) {
 c05ce62:	e7bd      	b.n	c05cde0 <FIH_LABEL_FIH_CALL_END_0_2277+0xb8>
        counter++;
 c05ce64:	9a0b      	ldr	r2, [sp, #44]	@ 0x2c
    for (i = 0; i < delay; i++) {
 c05ce66:	3301      	adds	r3, #1
        counter++;
 c05ce68:	3201      	adds	r2, #1
 c05ce6a:	920b      	str	r2, [sp, #44]	@ 0x2c
    for (i = 0; i < delay; i++) {
 c05ce6c:	e7d9      	b.n	c05ce22 <FIH_LABEL_FIH_CALL_END_0_2277+0xfa>
                    tfm_spm_hal_enable_irq(tfm_core_irq_signals[j].irq_line);
 c05ce6e:	2004      	movs	r0, #4
 c05ce70:	f7f3 fe92 	bl	c050b98 <tfm_spm_hal_enable_irq>
 c05ce74:	e6b7      	b.n	c05cbe6 <tfm_spm_init+0xfe>
 c05ce76:	2008      	movs	r0, #8
 c05ce78:	f7f3 fe8e 	bl	c050b98 <tfm_spm_hal_enable_irq>
 c05ce7c:	e6c8      	b.n	c05cc10 <tfm_spm_init+0x128>
            for (j = 0; j < STATIC_HANDLE_NUM_LIMIT; j++) {
 c05ce7e:	3301      	adds	r3, #1
 c05ce80:	2b20      	cmp	r3, #32
 c05ce82:	f47f ae63 	bne.w	c05cb4c <tfm_spm_init+0x64>
                tfm_core_panic();
 c05ce86:	f001 fc2f 	bl	c05e6e8 <tfm_core_panic>
 c05ce8a:	e667      	b.n	c05cb5c <tfm_spm_init+0x74>
 c05ce8c:	aaaa5555 	.word	0xaaaa5555
 c05ce90:	a5c35a3c 	.word	0xa5c35a3c

0c05ce94 <tfm_pendsv_do_schedule>:

void tfm_pendsv_do_schedule(struct tfm_arch_ctx_t *p_actx)
{
 c05ce94:	b538      	push	{r3, r4, r5, lr}
 c05ce96:	4605      	mov	r5, r0
#if TFM_LVL != 1
    struct partition_t *p_next_partition;
    uint32_t is_privileged;
#endif
    struct tfm_core_thread_t *pth_next = tfm_core_thrd_get_next();
 c05ce98:	f001 fb4c 	bl	c05e534 <tfm_core_thrd_get_next>
 c05ce9c:	4604      	mov	r4, r0
    struct tfm_core_thread_t *pth_curr = tfm_core_thrd_get_curr();
 c05ce9e:	f001 fb55 	bl	c05e54c <tfm_core_thrd_get_curr>
 c05cea2:	4601      	mov	r1, r0
#if defined(TFM_FIH_PROFILE_ON) && (TFM_LVL == 3)
    fih_int fih_rc = FIH_FAILURE;
#endif

    if (pth_next != NULL && pth_curr != pth_next) {
 c05cea4:	b1a4      	cbz	r4, c05ced0 <tfm_pendsv_do_schedule+0x3c>
 c05cea6:	4284      	cmp	r4, r0
 c05cea8:	d012      	beq.n	c05ced0 <tfm_pendsv_do_schedule+0x3c>
#if TFM_LVL != 1
        p_next_partition = TFM_GET_CONTAINER_PTR(pth_next,
                                                 struct partition_t,
                                                 sp_thread);

        if (p_next_partition->p_static->flags & SPM_PART_FLAG_PSA_ROT) {
 c05ceaa:	f854 3c10 	ldr.w	r3, [r4, #-16]
 c05ceae:	689b      	ldr	r3, [r3, #8]
 c05ceb0:	f3c3 0340 	ubfx	r3, r3, #1, #1
  __ASM volatile ("MRS %0, control" : "=r" (result) );
 c05ceb4:	f3ef 8214 	mrs	r2, CONTROL
    if (privileged == TFM_PARTITION_PRIVILEGED_MODE) {
 c05ceb8:	f1c3 0301 	rsb	r3, r3, #1
 c05cebc:	f363 0200 	bfi	r2, r3, #0, #1
  __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
 c05cec0:	f382 8814 	msr	CONTROL, r2
#endif /* TFM_FIH_PROFILE_ON */
        }
#endif /* TFM_LVL == 3 */
#endif /* TFM_LVL != 1 */

        tfm_core_thrd_switch_context(p_actx, pth_curr, pth_next);
 c05cec4:	4622      	mov	r2, r4
 c05cec6:	4628      	mov	r0, r5
    /*
     * Handle pending mailbox message from NS in multi-core topology.
     * Empty operation on single Armv8-M platform.
     */
    tfm_rpc_client_call_handler();
}
 c05cec8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
        tfm_core_thrd_switch_context(p_actx, pth_curr, pth_next);
 c05cecc:	f001 bba8 	b.w	c05e620 <tfm_core_thrd_switch_context>
}
 c05ced0:	bd38      	pop	{r3, r4, r5, pc}

0c05ced2 <update_caller_outvec_len>:

void update_caller_outvec_len(struct tfm_msg_body_t *msg)
{
 c05ced2:	b530      	push	{r4, r5, lr}
            continue;
        }

        TFM_CORE_ASSERT(msg->caller_outvec[i].base == msg->outvec[i].base);

        msg->caller_outvec[i].len = msg->outvec[i].len;
 c05ced4:	f06f 0403 	mvn.w	r4, #3
{
 c05ced8:	2300      	movs	r3, #0
 c05ceda:	f100 0230 	add.w	r2, r0, #48	@ 0x30
        msg->caller_outvec[i].len = msg->outvec[i].len;
 c05cede:	1a24      	subs	r4, r4, r0
        if (msg->msg.out_size[i] == 0) {
 c05cee0:	f852 1b04 	ldr.w	r1, [r2], #4
 c05cee4:	b129      	cbz	r1, c05cef2 <update_caller_outvec_len+0x20>
        msg->caller_outvec[i].len = msg->outvec[i].len;
 c05cee6:	f8d0 1080 	ldr.w	r1, [r0, #128]	@ 0x80
 c05ceea:	f854 5012 	ldr.w	r5, [r4, r2, lsl #1]
 c05ceee:	4419      	add	r1, r3
 c05cef0:	604d      	str	r5, [r1, #4]
    for (i = 0; i < PSA_MAX_IOVEC; i++) {
 c05cef2:	3308      	adds	r3, #8
 c05cef4:	2b20      	cmp	r3, #32
 c05cef6:	d1f3      	bne.n	c05cee0 <update_caller_outvec_len+0xe>
    }
}
 c05cef8:	bd30      	pop	{r4, r5, pc}

0c05cefa <notify_with_signal>:

void notify_with_signal(int32_t partition_id, psa_signal_t signal)
{
 c05cefa:	b538      	push	{r3, r4, r5, lr}
    /*
     * The value of partition_id must be greater than zero as the target of
     * notification must be a Secure Partition, providing a Non-secure
     * Partition ID is a fatal error.
     */
    if (!TFM_CLIENT_ID_IS_S(partition_id)) {
 c05cefc:	1e04      	subs	r4, r0, #0
{
 c05cefe:	460d      	mov	r5, r1
    if (!TFM_CLIENT_ID_IS_S(partition_id)) {
 c05cf00:	dc01      	bgt.n	c05cf06 <notify_with_signal+0xc>
        tfm_core_panic();
 c05cf02:	f001 fbf1 	bl	c05e6e8 <tfm_core_panic>

    /*
     * It is a fatal error if partition_id does not correspond to a Secure
     * Partition.
     */
    partition = tfm_spm_get_partition_by_id(partition_id);
 c05cf06:	4620      	mov	r0, r4
 c05cf08:	f7ff fb60 	bl	c05c5cc <tfm_spm_get_partition_by_id>
    if (!partition) {
 c05cf0c:	4604      	mov	r4, r0
 c05cf0e:	b908      	cbnz	r0, c05cf14 <notify_with_signal+0x1a>
        tfm_core_panic();
 c05cf10:	f001 fbea 	bl	c05e6e8 <tfm_core_panic>
    }

    partition->signals_asserted |= signal;
 c05cf14:	6f63      	ldr	r3, [r4, #116]	@ 0x74

    if (partition->signals_waiting & signal) {
 c05cf16:	6f21      	ldr	r1, [r4, #112]	@ 0x70
    partition->signals_asserted |= signal;
 c05cf18:	432b      	orrs	r3, r5
    if (partition->signals_waiting & signal) {
 c05cf1a:	4229      	tst	r1, r5
    partition->signals_asserted |= signal;
 c05cf1c:	6763      	str	r3, [r4, #116]	@ 0x74
    if (partition->signals_waiting & signal) {
 c05cf1e:	d008      	beq.n	c05cf32 <notify_with_signal+0x38>
        tfm_event_wake(
 c05cf20:	4019      	ands	r1, r3
 c05cf22:	f104 005c 	add.w	r0, r4, #92	@ 0x5c
 c05cf26:	f001 fb9b 	bl	c05e660 <tfm_event_wake>
                      &partition->event,
                      partition->signals_asserted & partition->signals_waiting);
        partition->signals_waiting &= ~signal;
 c05cf2a:	6f23      	ldr	r3, [r4, #112]	@ 0x70
 c05cf2c:	ea23 0305 	bic.w	r3, r3, r5
 c05cf30:	6723      	str	r3, [r4, #112]	@ 0x70
    }
}
 c05cf32:	bd38      	pop	{r3, r4, r5, pc}

0c05cf34 <tfm_set_irq_signal>:
 * \retval void                 Success.
 * \retval "Does not return"    Partition ID is invalid
 */
void tfm_set_irq_signal(uint32_t partition_id, psa_signal_t signal,
                        IRQn_Type irq_line)
{
 c05cf34:	b538      	push	{r3, r4, r5, lr}
 c05cf36:	4604      	mov	r4, r0
 c05cf38:	460d      	mov	r5, r1
 c05cf3a:	4610      	mov	r0, r2
  __ASM volatile ("cpsid i" : : : "memory");
 c05cf3c:	b672      	cpsid	i
    __disable_irq();

    tfm_spm_hal_disable_irq(irq_line);
 c05cf3e:	f7f3 fe39 	bl	c050bb4 <tfm_spm_hal_disable_irq>
    notify_with_signal(partition_id, signal);
 c05cf42:	4629      	mov	r1, r5
 c05cf44:	4620      	mov	r0, r4
 c05cf46:	f7ff ffd8 	bl	c05cefa <notify_with_signal>
  __ASM volatile ("cpsie i" : : : "memory");
 c05cf4a:	b662      	cpsie	i

    __enable_irq();
}
 c05cf4c:	bd38      	pop	{r3, r4, r5, pc}

0c05cf4e <GTZC_IRQHandler>:
    tfm_set_irq_signal(TFM_SP_PLATFORM, SPM_TAMPER_IRQ, TAMP_IRQ);
}

void GTZC_IRQHandler(void)
{
    tfm_set_irq_signal(TFM_SP_PLATFORM, SPM_GTZC_IRQ, GTZC_IRQ);
 c05cf4e:	2208      	movs	r2, #8
 c05cf50:	f04f 4180 	mov.w	r1, #1073741824	@ 0x40000000
 c05cf54:	f44f 7082 	mov.w	r0, #260	@ 0x104
 c05cf58:	f7ff bfec 	b.w	c05cf34 <tfm_set_irq_signal>

0c05cf5c <get_irq_line_for_signal>:

int32_t get_irq_line_for_signal(int32_t partition_id, psa_signal_t signal)
{
    size_t i;

    if (!IS_ONLY_ONE_BIT_IN_UINT32(signal)) {
 c05cf5c:	b191      	cbz	r1, c05cf84 <get_irq_line_for_signal+0x28>
 c05cf5e:	1e4b      	subs	r3, r1, #1
 c05cf60:	400b      	ands	r3, r1
 c05cf62:	d10f      	bne.n	c05cf84 <get_irq_line_for_signal+0x28>
        return -1;
    }

    for (i = 0; i < tfm_core_irq_signals_count; ++i) {
        if (tfm_core_irq_signals[i].partition_id == partition_id &&
 c05cf64:	f5b0 7f82 	cmp.w	r0, #260	@ 0x104
 c05cf68:	d10f      	bne.n	c05cf8a <get_irq_line_for_signal+0x2e>
 c05cf6a:	f1b1 4f00 	cmp.w	r1, #2147483648	@ 0x80000000
 c05cf6e:	d003      	beq.n	c05cf78 <get_irq_line_for_signal+0x1c>
 c05cf70:	f1b1 4f80 	cmp.w	r1, #1073741824	@ 0x40000000
 c05cf74:	d109      	bne.n	c05cf8a <get_irq_line_for_signal+0x2e>
    for (i = 0; i < tfm_core_irq_signals_count; ++i) {
 c05cf76:	2301      	movs	r3, #1
            tfm_core_irq_signals[i].signal_value == signal) {
            return tfm_core_irq_signals[i].irq_line;
 c05cf78:	4a05      	ldr	r2, [pc, #20]	@ (c05cf90 <get_irq_line_for_signal+0x34>)
 c05cf7a:	eb02 1303 	add.w	r3, r2, r3, lsl #4
 c05cf7e:	f993 0008 	ldrsb.w	r0, [r3, #8]
 c05cf82:	4770      	bx	lr
        return -1;
 c05cf84:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 c05cf88:	4770      	bx	lr
        }
    }

    return SPM_ERROR_GENERIC;
 c05cf8a:	4802      	ldr	r0, [pc, #8]	@ (c05cf94 <get_irq_line_for_signal+0x38>)
}
 c05cf8c:	4770      	bx	lr
 c05cf8e:	bf00      	nop
 c05cf90:	0c06190c 	.word	0x0c06190c
 c05cf94:	80000005 	.word	0x80000005

0c05cf98 <tfm_spm_validate_caller>:

#if !defined(__ARM_ARCH_8_1M_MAIN__)
void tfm_spm_validate_caller(struct partition_t *p_cur_sp, uint32_t *p_ctx,
                             uint32_t exc_return, bool ns_caller)
{
 c05cf98:	b570      	push	{r4, r5, r6, lr}
 c05cf9a:	4616      	mov	r6, r2
        /*
         * The background IRQ can't be supported, since if SP is executing,
         * the preempted context of SP can be different with the one who
         * preempts veneer.
         */
        if (p_cur_sp->p_static->pid != TFM_SP_NON_SECURE_ID) {
 c05cf9c:	6802      	ldr	r2, [r0, #0]
{
 c05cf9e:	4605      	mov	r5, r0
 c05cfa0:	460c      	mov	r4, r1
        if (p_cur_sp->p_static->pid != TFM_SP_NON_SECURE_ID) {
 c05cfa2:	6852      	ldr	r2, [r2, #4]
    if (ns_caller) {
 c05cfa4:	b16b      	cbz	r3, c05cfc2 <tfm_spm_validate_caller+0x2a>
        if (p_cur_sp->p_static->pid != TFM_SP_NON_SECURE_ID) {
 c05cfa6:	b10a      	cbz	r2, c05cfac <tfm_spm_validate_caller+0x14>
            tfm_core_panic();
 c05cfa8:	f001 fb9e 	bl	c05e6e8 <tfm_core_panic>
         */
        stacked_ctx_pos = (uintptr_t)p_ctx +
                          sizeof(struct tfm_state_context_t) +
                          TFM_STACK_SEALED_SIZE;

        if (is_stack_alloc_fp_space(exc_return)) {
 c05cfac:	06f3      	lsls	r3, r6, #27
            }
#endif
            stacked_ctx_pos += TFM_BASIC_FP_CONTEXT_WORDS * sizeof(uint32_t);
        }

        if (stacked_ctx_pos != p_cur_sp->sp_thread.stk_top) {
 c05cfae:	69eb      	ldr	r3, [r5, #28]
        stacked_ctx_pos = (uintptr_t)p_ctx +
 c05cfb0:	bf4c      	ite	mi
 c05cfb2:	3428      	addmi	r4, #40	@ 0x28
            stacked_ctx_pos += TFM_BASIC_FP_CONTEXT_WORDS * sizeof(uint32_t);
 c05cfb4:	3470      	addpl	r4, #112	@ 0x70
        if (stacked_ctx_pos != p_cur_sp->sp_thread.stk_top) {
 c05cfb6:	42a3      	cmp	r3, r4
 c05cfb8:	d005      	beq.n	c05cfc6 <tfm_spm_validate_caller+0x2e>
            tfm_core_panic();
        }
    } else if (p_cur_sp->p_static->pid <= 0) {
        tfm_core_panic();
    }
}
 c05cfba:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
            tfm_core_panic();
 c05cfbe:	f001 bb93 	b.w	c05e6e8 <tfm_core_panic>
    } else if (p_cur_sp->p_static->pid <= 0) {
 c05cfc2:	2a00      	cmp	r2, #0
 c05cfc4:	d0f9      	beq.n	c05cfba <tfm_spm_validate_caller+0x22>
}
 c05cfc6:	bd70      	pop	{r4, r5, r6, pc}

0c05cfc8 <tfm_spm_request_handler>:
#endif

void tfm_spm_request_handler(const struct tfm_state_context_t *svc_ctx)
{
 c05cfc8:	b538      	push	{r3, r4, r5, lr}
    uint32_t running_partition_flags = 0;
    const struct partition_t *partition = NULL;

    /* Check permissions on request type basis */

    switch (svc_ctx->r0) {
 c05cfca:	6805      	ldr	r5, [r0, #0]
{
 c05cfcc:	4604      	mov	r4, r0
    switch (svc_ctx->r0) {
 c05cfce:	b935      	cbnz	r5, c05cfde <tfm_spm_request_handler+0x16>
    case TFM_SPM_REQUEST_RESET_VOTE:
        partition = tfm_spm_get_running_partition();
 c05cfd0:	f7ff fba0 	bl	c05c714 <tfm_spm_get_running_partition>
        if (!partition) {
 c05cfd4:	b908      	cbnz	r0, c05cfda <tfm_spm_request_handler+0x12>
            tfm_core_panic();
 c05cfd6:	f001 fb87 	bl	c05e6e8 <tfm_core_panic>
        }

        /* FixMe: this is a placeholder for checks to be performed before
         * allowing execution of reset
         */
        *res_ptr = (uint32_t)TFM_SUCCESS;
 c05cfda:	6025      	str	r5, [r4, #0]

        break;
    default:
        *res_ptr = (uint32_t)TFM_ERROR_INVALID_PARAMETER;
    }
}
 c05cfdc:	bd38      	pop	{r3, r4, r5, pc}
    switch (svc_ctx->r0) {
 c05cfde:	2503      	movs	r5, #3
 c05cfe0:	e7fb      	b.n	c05cfda <tfm_spm_request_handler+0x12>
	...

0c05cfe4 <spm_log_msgval>:
    msg[i--] = 'x';
    msg[i--] = '0';
}

int32_t spm_log_msgval(const char *msg, size_t len, uint32_t value)
{
 c05cfe4:	b530      	push	{r4, r5, lr}
 c05cfe6:	460c      	mov	r4, r1
 c05cfe8:	4615      	mov	r5, r2
 c05cfea:	b085      	sub	sp, #20
    int32_t result_msg = 0, result_val;
    char value_str[MAX_DIGIT_BITS];

    if (msg && len) {
 c05cfec:	b138      	cbz	r0, c05cffe <spm_log_msgval+0x1a>
 c05cfee:	b139      	cbz	r1, c05d000 <spm_log_msgval+0x1c>
        result_msg = tfm_hal_output_spm_log(msg, len);
 c05cff0:	f000 ffdc 	bl	c05dfac <tfm_hal_output_spm_log>
        if (result_msg < TFM_HAL_SUCCESS) {
 c05cff4:	1e04      	subs	r4, r0, #0
 c05cff6:	da03      	bge.n	c05d000 <spm_log_msgval+0x1c>
                                        MAX_DIGIT_BITS);
    if (result_val < TFM_HAL_SUCCESS) {
        return result_val;
    }
    return (result_msg + result_val);
}
 c05cff8:	4620      	mov	r0, r4
 c05cffa:	b005      	add	sp, #20
 c05cffc:	bd30      	pop	{r4, r5, pc}
    int32_t result_msg = 0, result_val;
 c05cffe:	4604      	mov	r4, r0
    msg[i--] = '\r';
 c05d000:	f640 230d 	movw	r3, #2573	@ 0xa0d
 c05d004:	f8ad 300e 	strh.w	r3, [sp, #14]
 c05d008:	2309      	movs	r3, #9
        msg[i] = HEX_TABLE[value & 0xF];
 c05d00a:	490b      	ldr	r1, [pc, #44]	@ (c05d038 <spm_log_msgval+0x54>)
 c05d00c:	a801      	add	r0, sp, #4
 c05d00e:	f005 020f 	and.w	r2, r5, #15
 c05d012:	5c8a      	ldrb	r2, [r1, r2]
    for (; i > 1; i--, value >>= 4) {
 c05d014:	092d      	lsrs	r5, r5, #4
        msg[i] = HEX_TABLE[value & 0xF];
 c05d016:	541a      	strb	r2, [r3, r0]
    for (; i > 1; i--, value >>= 4) {
 c05d018:	3b01      	subs	r3, #1
 c05d01a:	2b01      	cmp	r3, #1
 c05d01c:	d1f7      	bne.n	c05d00e <spm_log_msgval+0x2a>
    msg[i--] = '0';
 c05d01e:	f647 0330 	movw	r3, #30768	@ 0x7830
    result_val = tfm_hal_output_spm_log(value_str,
 c05d022:	210c      	movs	r1, #12
    msg[i--] = '0';
 c05d024:	f8ad 3004 	strh.w	r3, [sp, #4]
    result_val = tfm_hal_output_spm_log(value_str,
 c05d028:	f000 ffc0 	bl	c05dfac <tfm_hal_output_spm_log>
    if (result_val < TFM_HAL_SUCCESS) {
 c05d02c:	2800      	cmp	r0, #0
    return (result_msg + result_val);
 c05d02e:	bfb4      	ite	lt
 c05d030:	4604      	movlt	r4, r0
 c05d032:	1824      	addge	r4, r4, r0
 c05d034:	e7e0      	b.n	c05cff8 <spm_log_msgval+0x14>
 c05d036:	bf00      	nop
 c05d038:	0c061f14 	.word	0x0c061f14

0c05d03c <t_cose_sign1_encode_parameters>:
 * Public function. See t_cose_sign1_sign.h
 */
enum t_cose_err_t
t_cose_sign1_encode_parameters(struct t_cose_sign1_sign_ctx *me,
                               QCBOREncodeContext           *cbor_encode_ctx)
{
 c05d03c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 c05d040:	4604      	mov	r4, r0
 c05d042:	b0aa      	sub	sp, #168	@ 0xa8
    int32_t                hash_alg_id;

    /* Check the cose_algorithm_id now by getting the hash alg as an
     * early error check even though it is not used until later.
     */
    hash_alg_id = hash_alg_id_from_sig_alg_id(me->cose_algorithm_id);
 c05d044:	6a00      	ldr	r0, [r0, #32]
{
 c05d046:	460e      	mov	r6, r1
    hash_alg_id = hash_alg_id_from_sig_alg_id(me->cose_algorithm_id);
 c05d048:	f000 f927 	bl	c05d29a <hash_alg_id_from_sig_alg_id>
    if(hash_alg_id == T_COSE_INVALID_ALGORITHM_ID) {
 c05d04c:	2800      	cmp	r0, #0
 c05d04e:	d073      	beq.n	c05d138 <t_cose_sign1_encode_parameters+0xfc>
        return T_COSE_ERR_UNSUPPORTED_SIGNING_ALG;
    }

    /* Add the CBOR tag indicating COSE_Sign1 */
    if(!(me->option_flags & T_COSE_OPT_OMIT_CBOR_TAG)) {
 c05d050:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
 c05d052:	079a      	lsls	r2, r3, #30
 c05d054:	d404      	bmi.n	c05d060 <t_cose_sign1_encode_parameters+0x24>
        QCBOREncode_AddTag(cbor_encode_ctx, CBOR_TAG_COSE_SIGN1);
 c05d056:	2212      	movs	r2, #18
 c05d058:	2300      	movs	r3, #0
 c05d05a:	4630      	mov	r0, r6
 c05d05c:	f7ff fa3a 	bl	c05c4d4 <QCBOREncode_AddTag>
   QCBOREncode_OpenMapOrArray(pCtx, CBOR_MAJOR_TYPE_ARRAY);
 c05d060:	2104      	movs	r1, #4
 c05d062:	4630      	mov	r0, r6
 c05d064:	f7ff fa39 	bl	c05c4da <QCBOREncode_OpenMapOrArray>
     * a cose single signed message */
    QCBOREncode_OpenArray(cbor_encode_ctx);

    /* The protected parameters, which are added as a wrapped bstr  */
    buffer_for_protected_parameters = Q_USEFUL_BUF_FROM_BYTE_ARRAY(me->protected_parameters_buffer);
    me->protected_parameters = encode_protected_parameters(me->cose_algorithm_id, buffer_for_protected_parameters);
 c05d068:	2318      	movs	r3, #24
    QCBOREncode_Init(&cbor_encode_ctx, buffer_for_parameters);
 c05d06a:	ad04      	add	r5, sp, #16
 c05d06c:	461a      	mov	r2, r3
 c05d06e:	4621      	mov	r1, r4
 c05d070:	4628      	mov	r0, r5
    me->protected_parameters = encode_protected_parameters(me->cose_algorithm_id, buffer_for_protected_parameters);
 c05d072:	6a27      	ldr	r7, [r4, #32]
 c05d074:	9301      	str	r3, [sp, #4]
    QCBOREncode_Init(&cbor_encode_ctx, buffer_for_parameters);
 c05d076:	9400      	str	r4, [sp, #0]
 c05d078:	f7ff f9e1 	bl	c05c43e <QCBOREncode_Init>
   QCBOREncode_OpenMapOrArray(pCtx, CBOR_MAJOR_TYPE_MAP);
 c05d07c:	2105      	movs	r1, #5
 c05d07e:	4628      	mov	r0, r5
 c05d080:	f7ff fa2b 	bl	c05c4da <QCBOREncode_OpenMapOrArray>
   QCBOREncode_AddInt64(pCtx, nLabel);
 c05d084:	2201      	movs	r2, #1
 c05d086:	2300      	movs	r3, #0
 c05d088:	4628      	mov	r0, r5
 c05d08a:	f7ff f9ee 	bl	c05c46a <QCBOREncode_AddInt64>
   QCBOREncode_AddInt64(pCtx, uNum);
 c05d08e:	463a      	mov	r2, r7
 c05d090:	4628      	mov	r0, r5
 c05d092:	17fb      	asrs	r3, r7, #31
 c05d094:	f7ff f9e9 	bl	c05c46a <QCBOREncode_AddInt64>
   QCBOREncode_CloseMapOrArray(pCtx, CBOR_MAJOR_TYPE_MAP, NULL);
 c05d098:	2105      	movs	r1, #5
 c05d09a:	4628      	mov	r0, r5
 c05d09c:	2200      	movs	r2, #0
 c05d09e:	f7ff fa3b 	bl	c05c518 <QCBOREncode_CloseMapOrArray>
    qcbor_result = QCBOREncode_Finish(&cbor_encode_ctx, &protected_parameters);
 c05d0a2:	4628      	mov	r0, r5
 c05d0a4:	a902      	add	r1, sp, #8
 c05d0a6:	f7ff fa75 	bl	c05c594 <QCBOREncode_Finish>
    if(qcbor_result == QCBOR_SUCCESS) {
 c05d0aa:	2800      	cmp	r0, #0
 c05d0ac:	d13f      	bne.n	c05d12e <t_cose_sign1_encode_parameters+0xf2>
        return_value = protected_parameters;
 c05d0ae:	e9dd 3202 	ldrd	r3, r2, [sp, #8]
    me->protected_parameters = encode_protected_parameters(me->cose_algorithm_id, buffer_for_protected_parameters);
 c05d0b2:	e9c4 3206 	strd	r3, r2, [r4, #24]
    if(q_useful_buf_c_is_null(me->protected_parameters)) {
 c05d0b6:	2b00      	cmp	r3, #0
 c05d0b8:	d03c      	beq.n	c05d134 <t_cose_sign1_encode_parameters+0xf8>
         * off (should never happen in tested, released code) */
        return_value = T_COSE_ERR_MAKING_PROTECTED;
        goto Done;
    }
    /* The use of _AddBytes here achieves the bstr wrapping */
    QCBOREncode_AddBytes(cbor_encode_ctx, me->protected_parameters);
 c05d0ba:	4611      	mov	r1, r2
 c05d0bc:	4618      	mov	r0, r3
 c05d0be:	e885 0003 	stmia.w	r5, {r0, r1}
   QCBOREncode_AddBuffer(pCtx, CBOR_MAJOR_TYPE_BYTE_STRING, Bytes);
 c05d0c2:	2102      	movs	r1, #2
 c05d0c4:	e895 000c 	ldmia.w	r5, {r2, r3}
 c05d0c8:	4630      	mov	r0, r6
 c05d0ca:	f7ff f9df 	bl	c05c48c <QCBOREncode_AddBuffer>

    /* The Unprotected parameters */
    /* Get the kid because it goes into the parameters that are about
     * to be made. */
    kid = me->kid;
 c05d0ce:	e9d4 870f 	ldrd	r8, r7, [r4, #60]	@ 0x3c

    if(me->option_flags & T_COSE_OPT_SHORT_CIRCUIT_SIG) {
 c05d0d2:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
 c05d0d4:	07db      	lsls	r3, r3, #31
 c05d0d6:	d508      	bpl.n	c05d0ea <t_cose_sign1_encode_parameters+0xae>
   return UsefulBuf_IsEmptyC(UB) || UsefulBuf_IsNULLC(UB);
 c05d0d8:	b117      	cbz	r7, c05d0e0 <t_cose_sign1_encode_parameters+0xa4>
 c05d0da:	f1b8 0f00 	cmp.w	r8, #0
 c05d0de:	d104      	bne.n	c05d0ea <t_cose_sign1_encode_parameters+0xae>
#ifndef T_COSE_DISABLE_SHORT_CIRCUIT_SIGN
        if(q_useful_buf_c_is_null_or_empty(kid)) {
            /* No kid passed in, Use the short-circuit kid */
            kid = get_short_circuit_kid();
 c05d0e0:	a802      	add	r0, sp, #8
 c05d0e2:	f000 f961 	bl	c05d3a8 <get_short_circuit_kid>
 c05d0e6:	e9dd 8702 	ldrd	r8, r7, [sp, #8]
   QCBOREncode_OpenMapOrArray(pCtx, CBOR_MAJOR_TYPE_MAP);
 c05d0ea:	2105      	movs	r1, #5
 c05d0ec:	4630      	mov	r0, r6
 c05d0ee:	f7ff f9f4 	bl	c05c4da <QCBOREncode_OpenMapOrArray>
 c05d0f2:	b17f      	cbz	r7, c05d114 <t_cose_sign1_encode_parameters+0xd8>
 c05d0f4:	f1b8 0f00 	cmp.w	r8, #0
 c05d0f8:	d00c      	beq.n	c05d114 <t_cose_sign1_encode_parameters+0xd8>
   QCBOREncode_AddInt64(pCtx, nLabel);
 c05d0fa:	2204      	movs	r2, #4
 c05d0fc:	2300      	movs	r3, #0
 c05d0fe:	4630      	mov	r0, r6
 c05d100:	f7ff f9b3 	bl	c05c46a <QCBOREncode_AddInt64>
   QCBOREncode_AddBytes(pCtx, Bytes);
 c05d104:	e9cd 8704 	strd	r8, r7, [sp, #16]
   QCBOREncode_AddBuffer(pCtx, CBOR_MAJOR_TYPE_BYTE_STRING, Bytes);
 c05d108:	2102      	movs	r1, #2
 c05d10a:	e895 000c 	ldmia.w	r5, {r2, r3}
 c05d10e:	4630      	mov	r0, r6
 c05d110:	f7ff f9bc 	bl	c05c48c <QCBOREncode_AddBuffer>
   QCBOREncode_CloseMapOrArray(pCtx, CBOR_MAJOR_TYPE_MAP, NULL);
 c05d114:	2200      	movs	r2, #0
 c05d116:	2105      	movs	r1, #5
 c05d118:	4630      	mov	r0, r6
 c05d11a:	f7ff f9fd 	bl	c05c518 <QCBOREncode_CloseMapOrArray>
   QCBOREncode_OpenMapOrArray(pCtx, CBOR_MAJOR_TYPE_BYTE_STRING);
 c05d11e:	4630      	mov	r0, r6
 c05d120:	2102      	movs	r1, #2
 c05d122:	f7ff f9da 	bl	c05c4da <QCBOREncode_OpenMapOrArray>
        return_value = T_COSE_ERR_SHORT_CIRCUIT_SIG_DISABLED;
        goto Done;
#endif
    }

    return_value = add_unprotected_parameters(me, kid, cbor_encode_ctx);
 c05d126:	2000      	movs	r0, #0
     * encoder tracks it internally.
     */

Done:
    return return_value;
}
 c05d128:	b02a      	add	sp, #168	@ 0xa8
 c05d12a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        return_value = NULL_Q_USEFUL_BUF_C;
 c05d12e:	2200      	movs	r2, #0
 c05d130:	4613      	mov	r3, r2
 c05d132:	e7be      	b.n	c05d0b2 <t_cose_sign1_encode_parameters+0x76>
        return_value = T_COSE_ERR_MAKING_PROTECTED;
 c05d134:	2002      	movs	r0, #2
 c05d136:	e7f7      	b.n	c05d128 <t_cose_sign1_encode_parameters+0xec>
        return T_COSE_ERR_UNSUPPORTED_SIGNING_ALG;
 c05d138:	2001      	movs	r0, #1
 c05d13a:	e7f5      	b.n	c05d128 <t_cose_sign1_encode_parameters+0xec>

0c05d13c <t_cose_sign1_encode_signature>:
    /* pointer and length of the completed tbs hash */
    struct q_useful_buf_c        tbs_hash;
    /* Pointer and length of the completed signature */
    struct q_useful_buf_c        signature;
    /* Buffer for the actual signature */
    Q_USEFUL_BUF_MAKE_STACK_UB(  buffer_for_signature, T_COSE_MAX_SIG_SIZE);
 c05d13c:	2384      	movs	r3, #132	@ 0x84
{
 c05d13e:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c05d142:	b0c7      	sub	sp, #284	@ 0x11c
 c05d144:	460e      	mov	r6, r1
    Q_USEFUL_BUF_MAKE_STACK_UB(  buffer_for_signature, T_COSE_MAX_SIG_SIZE);
 c05d146:	930e      	str	r3, [sp, #56]	@ 0x38
    /* Buffer for the tbs hash. */
    Q_USEFUL_BUF_MAKE_STACK_UB(  buffer_for_tbs_hash, T_COSE_CRYPTO_MAX_HASH_SIZE);
 c05d148:	ab15      	add	r3, sp, #84	@ 0x54
 c05d14a:	930f      	str	r3, [sp, #60]	@ 0x3c
 c05d14c:	2340      	movs	r3, #64	@ 0x40
   QCBOREncode_CloseMapOrArray(pCtx, CBOR_MAJOR_TYPE_BYTE_STRING, pWrappedCBOR);
 c05d14e:	ad11      	add	r5, sp, #68	@ 0x44
{
 c05d150:	4604      	mov	r4, r0
 c05d152:	462a      	mov	r2, r5
 c05d154:	2102      	movs	r1, #2
 c05d156:	4630      	mov	r0, r6
    Q_USEFUL_BUF_MAKE_STACK_UB(  buffer_for_signature, T_COSE_MAX_SIG_SIZE);
 c05d158:	af25      	add	r7, sp, #148	@ 0x94
    Q_USEFUL_BUF_MAKE_STACK_UB(  buffer_for_tbs_hash, T_COSE_CRYPTO_MAX_HASH_SIZE);
 c05d15a:	9310      	str	r3, [sp, #64]	@ 0x40
    Q_USEFUL_BUF_MAKE_STACK_UB(  buffer_for_signature, T_COSE_MAX_SIG_SIZE);
 c05d15c:	970d      	str	r7, [sp, #52]	@ 0x34
 c05d15e:	f7ff f9db 	bl	c05c518 <QCBOREncode_CloseMapOrArray>
   if(UsefulOutBuf_GetError(&(pCtx->OutBuf))) {
 c05d162:	7bb3      	ldrb	r3, [r6, #14]
 c05d164:	b10b      	cbz	r3, c05d16a <t_cose_sign1_encode_signature+0x2e>
      pCtx->uError = QCBOR_ERR_BUFFER_TOO_SMALL;
 c05d166:	2301      	movs	r3, #1
 c05d168:	7433      	strb	r3, [r6, #16]
   return (QCBORError)pCtx->uError;
 c05d16a:	7c33      	ldrb	r3, [r6, #16]
     * with hashing and signing. This is not actually necessary as the
     * errors will be caught correctly later, but it does make it a
     * bit easier for the caller to debug problems.
     */
    cbor_err = QCBOREncode_GetErrorState(cbor_encode_ctx);
    if(cbor_err == QCBOR_ERR_BUFFER_TOO_SMALL) {
 c05d16c:	2b01      	cmp	r3, #1
 c05d16e:	d07c      	beq.n	c05d26a <t_cose_sign1_encode_signature+0x12e>
        return_value = T_COSE_ERR_TOO_SMALL;
        goto Done;
    } else if(cbor_err != QCBOR_SUCCESS) {
 c05d170:	2b00      	cmp	r3, #0
 c05d172:	d17c      	bne.n	c05d26e <t_cose_sign1_encode_signature+0x132>
        return_value = T_COSE_ERR_CBOR_FORMATTING;
        goto Done;
    }

    if (QCBOREncode_IsBufferNULL(cbor_encode_ctx)) {
 c05d174:	6832      	ldr	r2, [r6, #0]
        /* Just calculating sizes. All that is needed is the signature
         * size.
         */
        signature.ptr = NULL;
        return_value  = t_cose_crypto_sig_size(me->cose_algorithm_id,
 c05d176:	f8d4 c020 	ldr.w	ip, [r4, #32]
    if (QCBOREncode_IsBufferNULL(cbor_encode_ctx)) {
 c05d17a:	b9fa      	cbnz	r2, c05d1bc <t_cose_sign1_encode_signature+0x80>
        return_value  = t_cose_crypto_sig_size(me->cose_algorithm_id,
 c05d17c:	ab0c      	add	r3, sp, #48	@ 0x30
 c05d17e:	9302      	str	r3, [sp, #8]
 c05d180:	e9d4 010c 	ldrd	r0, r1, [r4, #48]	@ 0x30
 c05d184:	e88d 0003 	stmia.w	sp, {r0, r1}
        signature.ptr = NULL;
 c05d188:	920b      	str	r2, [sp, #44]	@ 0x2c
        return_value  = t_cose_crypto_sig_size(me->cose_algorithm_id,
 c05d18a:	4660      	mov	r0, ip
 c05d18c:	e9d4 230a 	ldrd	r2, r3, [r4, #40]	@ 0x28
 c05d190:	f7ed ffa4 	bl	c04b0dc <t_cose_crypto_sig_size>
 c05d194:	4605      	mov	r5, r0
            goto Done;
        }
    }

    /* Add signature to CBOR and close out the array */
    QCBOREncode_AddBytes(cbor_encode_ctx, signature);
 c05d196:	e9dd 010b 	ldrd	r0, r1, [sp, #44]	@ 0x2c
 c05d19a:	ab13      	add	r3, sp, #76	@ 0x4c
 c05d19c:	e883 0003 	stmia.w	r3, {r0, r1}
   QCBOREncode_AddBuffer(pCtx, CBOR_MAJOR_TYPE_BYTE_STRING, Bytes);
 c05d1a0:	2102      	movs	r1, #2
 c05d1a2:	cb0c      	ldmia	r3, {r2, r3}
 c05d1a4:	4630      	mov	r0, r6
 c05d1a6:	f7ff f971 	bl	c05c48c <QCBOREncode_AddBuffer>
   QCBOREncode_CloseMapOrArray(pCtx, CBOR_MAJOR_TYPE_ARRAY, NULL);
 c05d1aa:	2200      	movs	r2, #0
 c05d1ac:	2104      	movs	r1, #4
 c05d1ae:	4630      	mov	r0, r6
 c05d1b0:	f7ff f9b2 	bl	c05c518 <QCBOREncode_CloseMapOrArray>
     * errors CBOR encoding errors.  Some are detected at the start of
     * this function, but they cannot all be deteced there.
     */
Done:
    return return_value;
}
 c05d1b4:	4628      	mov	r0, r5
 c05d1b6:	b047      	add	sp, #284	@ 0x11c
 c05d1b8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        return_value = create_tbs_hash(me->cose_algorithm_id,
 c05d1bc:	f10d 0924 	add.w	r9, sp, #36	@ 0x24
 c05d1c0:	f10d 0808 	add.w	r8, sp, #8
 c05d1c4:	f8cd 9010 	str.w	r9, [sp, #16]
 c05d1c8:	e9dd 010f 	ldrd	r0, r1, [sp, #60]	@ 0x3c
 c05d1cc:	e888 0003 	stmia.w	r8, {r0, r1}
 c05d1d0:	e895 0003 	ldmia.w	r5, {r0, r1}
 c05d1d4:	e88d 0003 	stmia.w	sp, {r0, r1}
 c05d1d8:	4660      	mov	r0, ip
 c05d1da:	e9d4 1206 	ldrd	r1, r2, [r4, #24]
 c05d1de:	f000 f86f 	bl	c05d2c0 <create_tbs_hash>
        if(return_value) {
 c05d1e2:	4605      	mov	r5, r0
 c05d1e4:	2800      	cmp	r0, #0
 c05d1e6:	d1e5      	bne.n	c05d1b4 <t_cose_sign1_encode_signature+0x78>
        if(!(me->option_flags & T_COSE_OPT_SHORT_CIRCUIT_SIG)) {
 c05d1e8:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
            return_value = t_cose_crypto_pub_key_sign(me->cose_algorithm_id,
 c05d1ea:	f8d4 c020 	ldr.w	ip, [r4, #32]
        if(!(me->option_flags & T_COSE_OPT_SHORT_CIRCUIT_SIG)) {
 c05d1ee:	07db      	lsls	r3, r3, #31
 c05d1f0:	d417      	bmi.n	c05d222 <t_cose_sign1_encode_signature+0xe6>
            return_value = t_cose_crypto_pub_key_sign(me->cose_algorithm_id,
 c05d1f2:	e9dd 010d 	ldrd	r0, r1, [sp, #52]	@ 0x34
 c05d1f6:	ab0b      	add	r3, sp, #44	@ 0x2c
 c05d1f8:	9306      	str	r3, [sp, #24]
 c05d1fa:	ab04      	add	r3, sp, #16
 c05d1fc:	e883 0003 	stmia.w	r3, {r0, r1}
 c05d200:	e899 0003 	ldmia.w	r9, {r0, r1}
 c05d204:	e888 0003 	stmia.w	r8, {r0, r1}
 c05d208:	e9d4 010c 	ldrd	r0, r1, [r4, #48]	@ 0x30
 c05d20c:	e88d 0003 	stmia.w	sp, {r0, r1}
 c05d210:	4660      	mov	r0, ip
 c05d212:	e9d4 230a 	ldrd	r2, r3, [r4, #40]	@ 0x28
 c05d216:	f7ed ff29 	bl	c04b06c <t_cose_crypto_pub_key_sign>
        if(return_value) {
 c05d21a:	2800      	cmp	r0, #0
 c05d21c:	d0bb      	beq.n	c05d196 <t_cose_sign1_encode_signature+0x5a>
 c05d21e:	4605      	mov	r5, r0
 c05d220:	e7c8      	b.n	c05d1b4 <t_cose_sign1_encode_signature+0x78>
    sig_size = cose_algorithm_id == COSE_ALGORITHM_ES256 ? T_COSE_EC_P256_SIG_SIZE :
 c05d222:	f11c 0f07 	cmn.w	ip, #7
 c05d226:	d01c      	beq.n	c05d262 <t_cose_sign1_encode_signature+0x126>
 c05d228:	f11c 0f23 	cmn.w	ip, #35	@ 0x23
 c05d22c:	d01b      	beq.n	c05d266 <t_cose_sign1_encode_signature+0x12a>
 c05d22e:	f11c 0f24 	cmn.w	ip, #36	@ 0x24
 c05d232:	d11e      	bne.n	c05d272 <t_cose_sign1_encode_signature+0x136>
 c05d234:	2484      	movs	r4, #132	@ 0x84
 c05d236:	e9dd ba09 	ldrd	fp, sl, [sp, #36]	@ 0x24
 c05d23a:	46a1      	mov	r9, r4
    for(array_indx = 0; array_indx < sig_size; array_indx += hash_to_sign.len) {
 c05d23c:	f04f 0800 	mov.w	r8, #0
        memcpy((uint8_t *)signature_buffer.ptr + array_indx,
 c05d240:	45d1      	cmp	r9, sl
 c05d242:	464a      	mov	r2, r9
 c05d244:	eb07 0008 	add.w	r0, r7, r8
 c05d248:	bf28      	it	cs
 c05d24a:	4652      	movcs	r2, sl
 c05d24c:	4659      	mov	r1, fp
    for(array_indx = 0; array_indx < sig_size; array_indx += hash_to_sign.len) {
 c05d24e:	44d0      	add	r8, sl
        memcpy((uint8_t *)signature_buffer.ptr + array_indx,
 c05d250:	f7fe f9fc 	bl	c05b64c <memcpy>
    for(array_indx = 0; array_indx < sig_size; array_indx += hash_to_sign.len) {
 c05d254:	45a0      	cmp	r8, r4
 c05d256:	eba9 090a 	sub.w	r9, r9, sl
 c05d25a:	d3f1      	bcc.n	c05d240 <t_cose_sign1_encode_signature+0x104>
    signature->len = sig_size;
 c05d25c:	e9cd 740b 	strd	r7, r4, [sp, #44]	@ 0x2c
        if(return_value) {
 c05d260:	e799      	b.n	c05d196 <t_cose_sign1_encode_signature+0x5a>
    sig_size = cose_algorithm_id == COSE_ALGORITHM_ES256 ? T_COSE_EC_P256_SIG_SIZE :
 c05d262:	2440      	movs	r4, #64	@ 0x40
 c05d264:	e7e7      	b.n	c05d236 <t_cose_sign1_encode_signature+0xfa>
 c05d266:	2460      	movs	r4, #96	@ 0x60
 c05d268:	e7e5      	b.n	c05d236 <t_cose_sign1_encode_signature+0xfa>
        return_value = T_COSE_ERR_TOO_SMALL;
 c05d26a:	2519      	movs	r5, #25
 c05d26c:	e7a2      	b.n	c05d1b4 <t_cose_sign1_encode_signature+0x78>
        return_value = T_COSE_ERR_CBOR_FORMATTING;
 c05d26e:	2518      	movs	r5, #24
 c05d270:	e7a0      	b.n	c05d1b4 <t_cose_sign1_encode_signature+0x78>
        return_value = T_COSE_ERR_UNSUPPORTED_SIGNING_ALG;
 c05d272:	2501      	movs	r5, #1
 c05d274:	e79e      	b.n	c05d1b4 <t_cose_sign1_encode_signature+0x78>

0c05d276 <QCBOREncode_AddSZString>:
{
 c05d276:	b537      	push	{r0, r1, r2, r4, r5, lr}
 c05d278:	4605      	mov	r5, r0
   return ((UsefulBufC) {szString, strlen(szString)});
 c05d27a:	4608      	mov	r0, r1
 c05d27c:	460c      	mov	r4, r1
 c05d27e:	f7e5 fa0e 	bl	c04269e <strlen>
   QCBOREncode_AddBuffer(pCtx, CBOR_MAJOR_TYPE_TEXT_STRING, Text);
 c05d282:	2103      	movs	r1, #3
 c05d284:	e9cd 4000 	strd	r4, r0, [sp]
 c05d288:	4628      	mov	r0, r5
 c05d28a:	ab02      	add	r3, sp, #8
 c05d28c:	e913 000c 	ldmdb	r3, {r2, r3}
}
 c05d290:	b003      	add	sp, #12
 c05d292:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
   QCBOREncode_AddBuffer(pCtx, CBOR_MAJOR_TYPE_TEXT_STRING, Text);
 c05d296:	f7ff b8f9 	b.w	c05c48c <QCBOREncode_AddBuffer>

0c05d29a <hash_alg_id_from_sig_alg_id>:
     * \ref T_COSE_CRYPTO_MAX_HASH_SIZE.
     */
    /* ? : operator precedence is correct here. This makes smaller
     * code than a switch statement and is easier to read.
     */
    return cose_algorithm_id == COSE_ALGORITHM_ES256 ? COSE_ALGORITHM_SHA_256 :
 c05d29a:	f110 0f23 	cmn.w	r0, #35	@ 0x23
 c05d29e:	d008      	beq.n	c05d2b2 <hash_alg_id_from_sig_alg_id+0x18>
 c05d2a0:	1dc3      	adds	r3, r0, #7
 c05d2a2:	d009      	beq.n	c05d2b8 <hash_alg_id_from_sig_alg_id+0x1e>
 c05d2a4:	f110 0f24 	cmn.w	r0, #36	@ 0x24
 c05d2a8:	bf0c      	ite	eq
 c05d2aa:	f06f 002b 	mvneq.w	r0, #43	@ 0x2b
 c05d2ae:	2000      	movne	r0, #0
 c05d2b0:	4770      	bx	lr
{
 c05d2b2:	f06f 002a 	mvn.w	r0, #42	@ 0x2a
 c05d2b6:	4770      	bx	lr
 c05d2b8:	f06f 000f 	mvn.w	r0, #15
#endif
#ifndef T_COSE_DISABLE_ES512
           cose_algorithm_id == COSE_ALGORITHM_ES512 ? COSE_ALGORITHM_SHA_512 :
#endif
                                                       T_COSE_INVALID_ALGORITHM_ID;
}
 c05d2bc:	4770      	bx	lr
	...

0c05d2c0 <create_tbs_hash>:
                                  struct q_useful_buf_c       protected_parameters,
                                  enum t_cose_tbs_hash_mode_t payload_mode,
                                  struct q_useful_buf_c       payload,
                                  struct q_useful_buf         buffer_for_hash,
                                  struct q_useful_buf_c      *hash)
{
 c05d2c0:	b5f0      	push	{r4, r5, r6, r7, lr}
 c05d2c2:	b0bd      	sub	sp, #244	@ 0xf4
 c05d2c4:	461e      	mov	r6, r3
     *    8 to 224 of hash context depending on hash implementation
     *    220 to 434 bytes total
     */
    enum t_cose_err_t           return_value;
    QCBOREncodeContext          cbor_encode_ctx;
    UsefulBuf_MAKE_STACK_UB(    buffer_for_TBS_first_part, T_COSE_SIZE_OF_TBS);
 c05d2c6:	ab0a      	add	r3, sp, #40	@ 0x28
{
 c05d2c8:	466d      	mov	r5, sp
    UsefulBuf_MAKE_STACK_UB(    buffer_for_TBS_first_part, T_COSE_SIZE_OF_TBS);
 c05d2ca:	9302      	str	r3, [sp, #8]
 c05d2cc:	2330      	movs	r3, #48	@ 0x30
{
 c05d2ce:	e885 0006 	stmia.w	r5, {r1, r2}
 c05d2d2:	4607      	mov	r7, r0
    struct t_cose_crypto_hash   hash_ctx;
    int32_t                     hash_alg_id;
    size_t                      bytes_to_omit;

    /* This builds the CBOR-format to-be-signed bytes */
    QCBOREncode_Init(&cbor_encode_ctx, buffer_for_TBS_first_part);
 c05d2d4:	461a      	mov	r2, r3
 c05d2d6:	9902      	ldr	r1, [sp, #8]
 c05d2d8:	a816      	add	r0, sp, #88	@ 0x58
    UsefulBuf_MAKE_STACK_UB(    buffer_for_TBS_first_part, T_COSE_SIZE_OF_TBS);
 c05d2da:	9303      	str	r3, [sp, #12]
    QCBOREncode_Init(&cbor_encode_ctx, buffer_for_TBS_first_part);
 c05d2dc:	f7ff f8af 	bl	c05c43e <QCBOREncode_Init>
   QCBOREncode_OpenMapOrArray(pCtx, CBOR_MAJOR_TYPE_ARRAY);
 c05d2e0:	2104      	movs	r1, #4
 c05d2e2:	a816      	add	r0, sp, #88	@ 0x58
 c05d2e4:	f7ff f8f9 	bl	c05c4da <QCBOREncode_OpenMapOrArray>
    QCBOREncode_OpenArray(&cbor_encode_ctx);

    /* context */
    QCBOREncode_AddSZString(&cbor_encode_ctx, COSE_SIG_CONTEXT_STRING_SIGNATURE1);
 c05d2e8:	492e      	ldr	r1, [pc, #184]	@ (c05d3a4 <create_tbs_hash+0xe4>)
 c05d2ea:	a816      	add	r0, sp, #88	@ 0x58
 c05d2ec:	f7ff ffc3 	bl	c05d276 <QCBOREncode_AddSZString>
    /* body_protected */
    QCBOREncode_AddBytes(&cbor_encode_ctx, protected_parameters);
 c05d2f0:	e895 0003 	ldmia.w	r5, {r0, r1}
 c05d2f4:	2500      	movs	r5, #0
 c05d2f6:	ac08      	add	r4, sp, #32
 c05d2f8:	e884 0003 	stmia.w	r4, {r0, r1}
   QCBOREncode_AddBuffer(pCtx, CBOR_MAJOR_TYPE_BYTE_STRING, Bytes);
 c05d2fc:	2102      	movs	r1, #2
 c05d2fe:	e894 000c 	ldmia.w	r4, {r2, r3}
 c05d302:	a816      	add	r0, sp, #88	@ 0x58
 c05d304:	f7ff f8c2 	bl	c05c48c <QCBOREncode_AddBuffer>

    /* sign_protected is not used for COSE_Sign1 */

    /* external_aad. There is none so an empty bstr */
    QCBOREncode_AddBytes(&cbor_encode_ctx, NULL_Q_USEFUL_BUF_C);
 c05d308:	e9cd 5508 	strd	r5, r5, [sp, #32]
 c05d30c:	2102      	movs	r1, #2
 c05d30e:	e894 000c 	ldmia.w	r4, {r2, r3}
 c05d312:	a816      	add	r0, sp, #88	@ 0x58
 c05d314:	f7ff f8ba 	bl	c05c48c <QCBOREncode_AddBuffer>

    /* The short fake payload */
    if(payload_mode == T_COSE_TBS_PAYLOAD_IS_BSTR_WRAPPED) {
 c05d318:	2e00      	cmp	r6, #0
 c05d31a:	d134      	bne.n	c05d386 <create_tbs_hash+0xc6>
        /* Fake payload is just an empty bstr. It is here only
         * to make the array count right. It must be ommitted
         * in the actual hashing below.
         */
        bytes_to_omit = 1;
        QCBOREncode_AddBytes(&cbor_encode_ctx, NULL_Q_USEFUL_BUF_C);
 c05d31c:	e9cd 6608 	strd	r6, r6, [sp, #32]
 c05d320:	2102      	movs	r1, #2
 c05d322:	e894 000c 	ldmia.w	r4, {r2, r3}
 c05d326:	a816      	add	r0, sp, #88	@ 0x58
 c05d328:	f7ff f8b0 	bl	c05c48c <QCBOREncode_AddBuffer>
        bytes_to_omit = 1;
 c05d32c:	2501      	movs	r5, #1
   QCBOREncode_CloseMapOrArray(pCtx, CBOR_MAJOR_TYPE_ARRAY, NULL);
 c05d32e:	2104      	movs	r1, #4
 c05d330:	a816      	add	r0, sp, #88	@ 0x58
 c05d332:	2200      	movs	r2, #0
 c05d334:	f7ff f8f0 	bl	c05c518 <QCBOREncode_CloseMapOrArray>

    /* Close off the array */
    QCBOREncode_CloseArray(&cbor_encode_ctx);

    /* get the encoded results, except for payload */
    qcbor_result = QCBOREncode_Finish(&cbor_encode_ctx, &tbs_first_part);
 c05d338:	a904      	add	r1, sp, #16
 c05d33a:	a816      	add	r0, sp, #88	@ 0x58
 c05d33c:	f7ff f92a 	bl	c05c594 <QCBOREncode_Finish>
    if(qcbor_result) {
 c05d340:	bb68      	cbnz	r0, c05d39e <create_tbs_hash+0xde>
        return_value = T_COSE_ERR_SIG_STRUCT;
        goto Done;
    }

    /* Start the hashing */
    hash_alg_id = hash_alg_id_from_sig_alg_id(cose_algorithm_id);
 c05d342:	4638      	mov	r0, r7
 c05d344:	f7ff ffa9 	bl	c05d29a <hash_alg_id_from_sig_alg_id>
 c05d348:	4601      	mov	r1, r0
    /* Don't check hash_alg_id for failure. t_cose_crypto_hash_start()
     * will handle error properly. It was also checked earlier.
     */
    return_value = t_cose_crypto_hash_start(&hash_ctx, hash_alg_id);
 c05d34a:	a806      	add	r0, sp, #24
 c05d34c:	f7ed fef2 	bl	c04b134 <t_cose_crypto_hash_start>
    if(return_value) {
 c05d350:	b9b8      	cbnz	r0, c05d382 <create_tbs_hash+0xc2>
     */

    /* This is the hashing of the first part, all the CBOR except the
     * payload.
     */
    t_cose_crypto_hash_update(&hash_ctx,
 c05d352:	9b05      	ldr	r3, [sp, #20]
   if(uAmount > UB.len) {
 c05d354:	1b5b      	subs	r3, r3, r5
 c05d356:	bf34      	ite	cc
 c05d358:	4603      	movcc	r3, r0
 c05d35a:	9804      	ldrcs	r0, [sp, #16]
      return NULLUsefulBufC;
 c05d35c:	e9cd 0308 	strd	r0, r3, [sp, #32]
 c05d360:	a806      	add	r0, sp, #24
 c05d362:	e894 0006 	ldmia.w	r4, {r1, r2}
 c05d366:	f7ed ff11 	bl	c04b18c <t_cose_crypto_hash_update>
                                                tbs_first_part.len - bytes_to_omit));

    /* Hash the payload, the second part. This may or may not have the
     * bstr wrapping. If not, it was hashed above.
     */
    t_cose_crypto_hash_update(&hash_ctx, payload);
 c05d36a:	ab42      	add	r3, sp, #264	@ 0x108
 c05d36c:	e893 0006 	ldmia.w	r3, {r1, r2}
 c05d370:	a806      	add	r0, sp, #24
 c05d372:	f7ed ff0b 	bl	c04b18c <t_cose_crypto_hash_update>

    /* Finish the hash and set up to return it */
    return_value = t_cose_crypto_hash_finish(&hash_ctx,
 c05d376:	e9dd 2345 	ldrd	r2, r3, [sp, #276]	@ 0x114
 c05d37a:	9944      	ldr	r1, [sp, #272]	@ 0x110
 c05d37c:	a806      	add	r0, sp, #24
 c05d37e:	f7ed ff12 	bl	c04b1a6 <t_cose_crypto_hash_finish>
                                             buffer_for_hash,
                                             hash);
Done:
    return return_value;
}
 c05d382:	b03d      	add	sp, #244	@ 0xf4
 c05d384:	bdf0      	pop	{r4, r5, r6, r7, pc}
        QCBOREncode_AddBytesLenOnly(&cbor_encode_ctx, payload);
 c05d386:	ab42      	add	r3, sp, #264	@ 0x108
 c05d388:	e893 0003 	ldmia.w	r3, {r0, r1}
 c05d38c:	e884 0003 	stmia.w	r4, {r0, r1}
    QCBOREncode_AddBuffer(pCtx, CBOR_MAJOR_NONE_TYPE_BSTR_LEN_ONLY, Bytes);
 c05d390:	210b      	movs	r1, #11
 c05d392:	e894 000c 	ldmia.w	r4, {r2, r3}
 c05d396:	a816      	add	r0, sp, #88	@ 0x58
 c05d398:	f7ff f878 	bl	c05c48c <QCBOREncode_AddBuffer>
 c05d39c:	e7c7      	b.n	c05d32e <create_tbs_hash+0x6e>
        return_value = T_COSE_ERR_SIG_STRUCT;
 c05d39e:	2015      	movs	r0, #21
 c05d3a0:	e7ef      	b.n	c05d382 <create_tbs_hash+0xc2>
 c05d3a2:	bf00      	nop
 c05d3a4:	0c061f34 	.word	0x0c061f34

0c05d3a8 <get_short_circuit_kid>:
/*
 * Public function. See t_cose_util.h
 */
struct q_useful_buf_c get_short_circuit_kid(void)
{
    short_circuit_kid.len = sizeof(defined_short_circuit_kid);
 c05d3a8:	2120      	movs	r1, #32
{
 c05d3aa:	4603      	mov	r3, r0
    short_circuit_kid.len = sizeof(defined_short_circuit_kid);
 c05d3ac:	4a04      	ldr	r2, [pc, #16]	@ (c05d3c0 <get_short_circuit_kid+0x18>)
 c05d3ae:	6051      	str	r1, [r2, #4]
    short_circuit_kid.ptr = defined_short_circuit_kid;
 c05d3b0:	4904      	ldr	r1, [pc, #16]	@ (c05d3c4 <get_short_circuit_kid+0x1c>)
 c05d3b2:	6011      	str	r1, [r2, #0]

    return short_circuit_kid;
 c05d3b4:	e892 0003 	ldmia.w	r2, {r0, r1}
 c05d3b8:	e883 0003 	stmia.w	r3, {r0, r1}
}
 c05d3bc:	4618      	mov	r0, r3
 c05d3be:	4770      	bx	lr
 c05d3c0:	300388e0 	.word	0x300388e0
 c05d3c4:	0c061f3f 	.word	0x0c061f3f

0c05d3c8 <tfm_spm_request>:
#endif

__attribute__((naked))
static int32_t tfm_spm_request(int32_t request_type)
{
    __ASM volatile(
 c05d3c8:	df03      	svc	3
 c05d3ca:	4770      	bx	lr

0c05d3cc <tfm_spm_request_reset_vote>:
        : : "I" (TFM_SVC_SPM_REQUEST));
}

int32_t tfm_spm_request_reset_vote(void)
{
    return tfm_spm_request((int32_t)TFM_SPM_REQUEST_RESET_VOTE);
 c05d3cc:	2000      	movs	r0, #0
 c05d3ce:	f7ff bffb 	b.w	c05d3c8 <tfm_spm_request>
	...

0c05d3d4 <tfm_arch_init_context>:
}

void tfm_arch_init_context(struct tfm_arch_ctx_t *p_actx,
                           void *param, uintptr_t pfn,
                           uintptr_t stk_btm, uintptr_t stk_top)
{
 c05d3d4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 c05d3d8:	9c08      	ldr	r4, [sp, #32]
 c05d3da:	4698      	mov	r8, r3
    *((uint32_t *)stk)       = TFM_STACK_SEAL_VALUE;
 c05d3dc:	4b12      	ldr	r3, [pc, #72]	@ (c05d428 <tfm_arch_init_context+0x54>)
    stk -= TFM_STACK_SEALED_SIZE;
 c05d3de:	f1a4 0708 	sub.w	r7, r4, #8
    *((uint32_t *)(stk + 4)) = TFM_STACK_SEAL_VALUE;
 c05d3e2:	e944 3302 	strd	r3, r3, [r4, #-8]

    /*
     * Shift back SP to leave space for holding common state context
     * since thread is kicked off through exception return.
     */
    p_stat_ctx--;
 c05d3e6:	3c28      	subs	r4, #40	@ 0x28
{
 c05d3e8:	4606      	mov	r6, r0
 c05d3ea:	4689      	mov	r9, r1
 c05d3ec:	4615      	mov	r5, r2

    /* First the common state context - ZERO it before usage. */
    spm_memset(p_stat_ctx, 0, sizeof(*p_stat_ctx));
 c05d3ee:	2100      	movs	r1, #0
 c05d3f0:	2220      	movs	r2, #32
 c05d3f2:	4620      	mov	r0, r4
 c05d3f4:	f000 fb37 	bl	c05da66 <spm_memset>
    p_stat_ctx->xpsr = XPSR_T32;
 c05d3f8:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
    p_stat_ctx->ra = (uint32_t)pfn;
 c05d3fc:	f847 5c08 	str.w	r5, [r7, #-8]
    p_stat_ctx->lr = ((uint32_t)pfn) & (~1UL);
 c05d400:	f025 0501 	bic.w	r5, r5, #1
    tfm_arch_init_state_ctx(p_stat_ctx, param, pfn);

    /* Then the architecture-specific context. */
    spm_memset(p_actx, 0, sizeof(*p_actx));
 c05d404:	2230      	movs	r2, #48	@ 0x30
 c05d406:	2100      	movs	r1, #0
 c05d408:	4630      	mov	r0, r6
    p_stat_ctx->r0 = (uint32_t)param;
 c05d40a:	f847 9c20 	str.w	r9, [r7, #-32]
    p_stat_ctx->lr = ((uint32_t)pfn) & (~1UL);
 c05d40e:	f847 5c0c 	str.w	r5, [r7, #-12]
    p_stat_ctx->xpsr = XPSR_T32;
 c05d412:	f847 3c04 	str.w	r3, [r7, #-4]
    spm_memset(p_actx, 0, sizeof(*p_actx));
 c05d416:	f000 fb26 	bl	c05da66 <spm_memset>
    tfm_arch_init_actx(p_actx, (uint32_t)p_stat_ctx, (uint32_t)stk_btm);
 c05d41a:	4642      	mov	r2, r8
 c05d41c:	4621      	mov	r1, r4
 c05d41e:	4630      	mov	r0, r6
}
 c05d420:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    tfm_arch_init_actx(p_actx, (uint32_t)p_stat_ctx, (uint32_t)stk_btm);
 c05d424:	f000 b815 	b.w	c05d452 <tfm_arch_init_actx>
 c05d428:	fef5eda5 	.word	0xfef5eda5

0c05d42c <PendSV_Handler>:
#pragma required = tfm_pendsv_do_schedule
#endif

__attribute__((naked)) void PendSV_Handler(void)
{
    __ASM volatile(
 c05d42c:	f3ef 8009 	mrs	r0, PSP
 c05d430:	f3ef 810b 	mrs	r1, PSPLIM
 c05d434:	b507      	push	{r0, r1, r2, lr}
 c05d436:	e92d 0ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
 c05d43a:	4668      	mov	r0, sp
 c05d43c:	f7ff fd2a 	bl	c05ce94 <tfm_pendsv_do_schedule>
 c05d440:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
 c05d444:	e8bd 4007 	ldmia.w	sp!, {r0, r1, r2, lr}
 c05d448:	f380 8809 	msr	PSP, r0
 c05d44c:	f381 880b 	msr	PSPLIM, r1
 c05d450:	4770      	bx	lr

0c05d452 <tfm_arch_init_actx>:
void tfm_arch_init_actx(struct tfm_arch_ctx_t *p_actx,
                        uint32_t sp, uint32_t sp_limit)
{
    p_actx->sp = sp;
    p_actx->sp_limit = sp_limit;
    p_actx->lr = EXC_RETURN_THREAD_S_PSP;
 c05d452:	f06f 0302 	mvn.w	r3, #2
    p_actx->sp_limit = sp_limit;
 c05d456:	e9c0 1208 	strd	r1, r2, [r0, #32]
    p_actx->lr = EXC_RETURN_THREAD_S_PSP;
 c05d45a:	62c3      	str	r3, [r0, #44]	@ 0x2c
}
 c05d45c:	4770      	bx	lr

0c05d45e <SecureFault_Handler>:
    /* A SecureFault may indicate corruption of secure state, so it is essential
     * that Non-secure code does not regain control after one is raised.
     * Returning from this exception could allow a pending NS exception to be
     * taken, so the current solution is not to return.
     */
    __ASM volatile("b    .");
 c05d45e:	e7fe      	b.n	c05d45e <SecureFault_Handler>

0c05d460 <SVC_Handler>:
#pragma required = tfm_core_svc_handler
#endif

__attribute__((naked)) void SVC_Handler(void)
{
    __ASM volatile(
 c05d460:	f3ef 8008 	mrs	r0, MSP
 c05d464:	f3ef 8109 	mrs	r1, PSP
 c05d468:	4672      	mov	r2, lr
 c05d46a:	f000 fa13 	bl	c05d894 <tfm_core_svc_handler>
 c05d46e:	4700      	bx	r0

0c05d470 <UsageFault_Handler>:
}

__attribute__((naked)) void UsageFault_Handler(void)
{
    EXCEPTION_INFO(EXCEPTION_TYPE_USAGEFAULT);
    __ASM volatile("b    .");
 c05d470:	e7fe      	b.n	c05d470 <UsageFault_Handler>
	...

0c05d474 <tfm_arch_set_secure_exception_priorities>:
    uint32_t VECTKEY;
    SCB_Type *scb = SCB;
    uint32_t AIRCR;

    /* Set PRIS flag in AIRCR */
    AIRCR = scb->AIRCR;
 c05d474:	4b08      	ldr	r3, [pc, #32]	@ (c05d498 <tfm_arch_set_secure_exception_priorities+0x24>)
 c05d476:	68da      	ldr	r2, [r3, #12]
    VECTKEY = (~AIRCR & SCB_AIRCR_VECTKEYSTAT_Msk);
    scb->AIRCR = SCB_AIRCR_PRIS_Msk |
                 VECTKEY |
 c05d478:	f082 427f 	eor.w	r2, r2, #4278190080	@ 0xff000000
 c05d47c:	f482 027f 	eor.w	r2, r2, #16711680	@ 0xff0000
 c05d480:	f442 4280 	orr.w	r2, r2, #16384	@ 0x4000
    scb->AIRCR = SCB_AIRCR_PRIS_Msk |
 c05d484:	60da      	str	r2, [r3, #12]
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 c05d486:	2200      	movs	r2, #0
 c05d488:	761a      	strb	r2, [r3, #24]
 c05d48a:	765a      	strb	r2, [r3, #25]
 c05d48c:	76da      	strb	r2, [r3, #27]
 c05d48e:	77da      	strb	r2, [r3, #31]
 c05d490:	2270      	movs	r2, #112	@ 0x70
 c05d492:	f883 2022 	strb.w	r2, [r3, #34]	@ 0x22
     * For this reason, set the priority of the PendSV interrupt to the next
     * priority level configurable on the platform, just below 0x80.
     */
    NVIC_SetPriority(PendSV_IRQn, (1 << (__NVIC_PRIO_BITS - 1)) - 1);
#endif
}
 c05d496:	4770      	bx	lr
 c05d498:	e000ed00 	.word	0xe000ed00

0c05d49c <tfm_arch_config_extensions>:

    /* Permit Non-secure access to the Floating-point Extension.
     * Note: It is still necessary to set CPACR_NS to enable the FP Extension in
     * the NSPE. This configuration is left to NS privileged software.
     */
    SCB->NSACR |= SCB_NSACR_CP10_Msk | SCB_NSACR_CP11_Msk;
 c05d49c:	4a03      	ldr	r2, [pc, #12]	@ (c05d4ac <tfm_arch_config_extensions+0x10>)
 c05d49e:	f8d2 308c 	ldr.w	r3, [r2, #140]	@ 0x8c
 c05d4a2:	f443 6340 	orr.w	r3, r3, #3072	@ 0xc00
 c05d4a6:	f8c2 308c 	str.w	r3, [r2, #140]	@ 0x8c

#if defined(__ARM_ARCH_8_1M_MAIN__)
    SCB->CCR |= SCB_CCR_TRD_Msk;
#endif
#endif
}
 c05d4aa:	4770      	bx	lr
 c05d4ac:	e000ed00 	.word	0xe000ed00

0c05d4b0 <tfm_arch_clear_fp_status>:

__attribute__((naked, noinline)) void tfm_arch_clear_fp_status(void)
{
    __ASM volatile(
 c05d4b0:	f3ef 8014 	mrs	r0, CONTROL
 c05d4b4:	f030 0004 	bics.w	r0, r0, #4
 c05d4b8:	f380 8814 	msr	CONTROL, r0
 c05d4bc:	f3bf 8f6f 	isb	sy
 c05d4c0:	4770      	bx	lr
	...

0c05d4c4 <attest_get_caller_client_id>:
    tfm_res = tfm_core_get_caller_client_id(caller_id);
    if (tfm_res) {
        attest_res = PSA_ATTEST_ERR_CLAIM_UNAVAILABLE;
    }
#else
    *caller_id = g_attest_caller_id;
 c05d4c4:	4b02      	ldr	r3, [pc, #8]	@ (c05d4d0 <attest_get_caller_client_id+0xc>)
 c05d4c6:	681b      	ldr	r3, [r3, #0]
 c05d4c8:	6003      	str	r3, [r0, #0]
#endif

    return attest_res;
}
 c05d4ca:	2000      	movs	r0, #0
 c05d4cc:	4770      	bx	lr
 c05d4ce:	bf00      	nop
 c05d4d0:	300388e8 	.word	0x300388e8

0c05d4d4 <attest_get_boot_data>:

enum psa_attest_err_t
attest_get_boot_data(uint8_t major_type,
                     struct tfm_boot_data *boot_data,
                     uint32_t len)
{
 c05d4d4:	b508      	push	{r3, lr}
    enum psa_attest_err_t attest_res = PSA_ATTEST_ERR_SUCCESS;
    int32_t tfm_res;

    tfm_res = tfm_core_get_boot_data(major_type, boot_data, len);
 c05d4d6:	f7df f967 	bl	c03c7a8 <tfm_core_get_boot_data>
    if (tfm_res != (int32_t)TFM_SUCCESS) {
        attest_res =  PSA_ATTEST_ERR_INIT_FAILED;
    }

    return attest_res;
}
 c05d4da:	3800      	subs	r0, #0
 c05d4dc:	bf18      	it	ne
 c05d4de:	2001      	movne	r0, #1
 c05d4e0:	bd08      	pop	{r3, pc}
	...

0c05d4e4 <tfm_attest_get_public_key>:
    psa_status_t status = PSA_SUCCESS;
    uint8_t key_buf[ECC_P256_PUBLIC_KEY_SIZE];
    size_t key_len;
    psa_ecc_family_t curve_type;

    psa_outvec out_vec[] = {
 c05d4e4:	2341      	movs	r3, #65	@ 0x41
{
 c05d4e6:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 c05d4ea:	b09b      	sub	sp, #108	@ 0x6c
    psa_outvec out_vec[] = {
 c05d4ec:	9304      	str	r3, [sp, #16]
 c05d4ee:	2301      	movs	r3, #1
 c05d4f0:	9306      	str	r3, [sp, #24]
 c05d4f2:	2304      	movs	r3, #4
        {.base = key_buf,     .len = sizeof(key_buf)},
        {.base = &curve_type, .len = sizeof(curve_type)},
        {.base = &key_len,    .len = sizeof(key_len)}
    };

    if (msg->out_size[1] != out_vec[1].len ||
 c05d4f4:	6a47      	ldr	r7, [r0, #36]	@ 0x24
    psa_outvec out_vec[] = {
 c05d4f6:	f10d 0924 	add.w	r9, sp, #36	@ 0x24
 c05d4fa:	f10d 0807 	add.w	r8, sp, #7
 c05d4fe:	ae02      	add	r6, sp, #8
    if (msg->out_size[1] != out_vec[1].len ||
 c05d500:	2f01      	cmp	r7, #1
{
 c05d502:	4604      	mov	r4, r0
    psa_outvec out_vec[] = {
 c05d504:	f8cd 900c 	str.w	r9, [sp, #12]
 c05d508:	f8cd 8014 	str.w	r8, [sp, #20]
 c05d50c:	9607      	str	r6, [sp, #28]
 c05d50e:	9308      	str	r3, [sp, #32]
    if (msg->out_size[1] != out_vec[1].len ||
 c05d510:	d126      	bne.n	c05d560 <tfm_attest_get_public_key+0x7c>
 c05d512:	6a83      	ldr	r3, [r0, #40]	@ 0x28
 c05d514:	2b04      	cmp	r3, #4
 c05d516:	d123      	bne.n	c05d560 <tfm_attest_get_public_key+0x7c>
    }

    /* Store the client ID here for later use in service. */
    g_attest_caller_id = msg->client_id;

    status = initial_attest_get_public_key(NULL, 0,
 c05d518:	2100      	movs	r1, #0
    g_attest_caller_id = msg->client_id;
 c05d51a:	6882      	ldr	r2, [r0, #8]
 c05d51c:	4b13      	ldr	r3, [pc, #76]	@ (c05d56c <tfm_attest_get_public_key+0x88>)
    status = initial_attest_get_public_key(NULL, 0,
 c05d51e:	4608      	mov	r0, r1
    g_attest_caller_id = msg->client_id;
 c05d520:	601a      	str	r2, [r3, #0]
    status = initial_attest_get_public_key(NULL, 0,
 c05d522:	2303      	movs	r3, #3
 c05d524:	aa03      	add	r2, sp, #12
 c05d526:	f7fd ffaf 	bl	c05b488 <initial_attest_get_public_key>
                                           out_vec, IOVEC_LEN(out_vec));

    if (msg->out_size[0] < key_len) {
 c05d52a:	9b02      	ldr	r3, [sp, #8]
 c05d52c:	6a22      	ldr	r2, [r4, #32]
    status = initial_attest_get_public_key(NULL, 0,
 c05d52e:	4605      	mov	r5, r0
    if (msg->out_size[0] < key_len) {
 c05d530:	429a      	cmp	r2, r3
 c05d532:	d318      	bcc.n	c05d566 <tfm_attest_get_public_key+0x82>
        return PSA_ERROR_BUFFER_TOO_SMALL;
    }

    if (status == PSA_SUCCESS) {
 c05d534:	b980      	cbnz	r0, c05d558 <tfm_attest_get_public_key+0x74>
        psa_write(msg->handle, 0, key_buf, key_len);
 c05d536:	4601      	mov	r1, r0
 c05d538:	464a      	mov	r2, r9
 c05d53a:	6860      	ldr	r0, [r4, #4]
 c05d53c:	f7df f96a 	bl	c03c814 <psa_write>
        psa_write(msg->handle, 1, &curve_type, out_vec[1].len);
 c05d540:	4642      	mov	r2, r8
 c05d542:	4639      	mov	r1, r7
 c05d544:	9b06      	ldr	r3, [sp, #24]
 c05d546:	6860      	ldr	r0, [r4, #4]
 c05d548:	f7df f964 	bl	c03c814 <psa_write>
        psa_write(msg->handle, 2, &key_len, out_vec[2].len);
 c05d54c:	4632      	mov	r2, r6
 c05d54e:	2102      	movs	r1, #2
 c05d550:	9b08      	ldr	r3, [sp, #32]
 c05d552:	6860      	ldr	r0, [r4, #4]
 c05d554:	f7df f95e 	bl	c03c814 <psa_write>
    }

    return status;
}
 c05d558:	4628      	mov	r0, r5
 c05d55a:	b01b      	add	sp, #108	@ 0x6c
 c05d55c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        return PSA_ERROR_INVALID_ARGUMENT;
 c05d560:	f06f 0586 	mvn.w	r5, #134	@ 0x86
 c05d564:	e7f8      	b.n	c05d558 <tfm_attest_get_public_key+0x74>
        return PSA_ERROR_BUFFER_TOO_SMALL;
 c05d566:	f06f 0589 	mvn.w	r5, #137	@ 0x89
 c05d56a:	e7f5      	b.n	c05d558 <tfm_attest_get_public_key+0x74>
 c05d56c:	300388e8 	.word	0x300388e8

0c05d570 <psa_attest_get_token_size>:
{
 c05d570:	b530      	push	{r4, r5, lr}
 c05d572:	b087      	sub	sp, #28
        {&challenge_size, msg->in_size[0]}
 c05d574:	6902      	ldr	r2, [r0, #16]
    psa_outvec out_vec[] = {
 c05d576:	ab01      	add	r3, sp, #4
 c05d578:	9304      	str	r3, [sp, #16]
        {&token_size, msg->out_size[0]}
 c05d57a:	6a03      	ldr	r3, [r0, #32]
    if (msg->in_size[0] != sizeof(challenge_size)
 c05d57c:	2a04      	cmp	r2, #4
{
 c05d57e:	4604      	mov	r4, r0
    psa_invec in_vec[] = {
 c05d580:	f8cd d008 	str.w	sp, [sp, #8]
 c05d584:	9203      	str	r2, [sp, #12]
    psa_outvec out_vec[] = {
 c05d586:	9305      	str	r3, [sp, #20]
    if (msg->in_size[0] != sizeof(challenge_size)
 c05d588:	d004      	beq.n	c05d594 <psa_attest_get_token_size+0x24>
        return PSA_ERROR_INVALID_ARGUMENT;
 c05d58a:	f06f 0586 	mvn.w	r5, #134	@ 0x86
}
 c05d58e:	4628      	mov	r0, r5
 c05d590:	b007      	add	sp, #28
 c05d592:	bd30      	pop	{r4, r5, pc}
        || msg->out_size[0] != sizeof(token_size)) {
 c05d594:	2b04      	cmp	r3, #4
 c05d596:	d1f8      	bne.n	c05d58a <psa_attest_get_token_size+0x1a>
    g_attest_caller_id = msg->client_id;
 c05d598:	6881      	ldr	r1, [r0, #8]
 c05d59a:	4a0d      	ldr	r2, [pc, #52]	@ (c05d5d0 <psa_attest_get_token_size+0x60>)
    bytes_read = psa_read(msg->handle, 0,
 c05d59c:	6840      	ldr	r0, [r0, #4]
    g_attest_caller_id = msg->client_id;
 c05d59e:	6011      	str	r1, [r2, #0]
    bytes_read = psa_read(msg->handle, 0,
 c05d5a0:	466a      	mov	r2, sp
 c05d5a2:	2100      	movs	r1, #0
 c05d5a4:	f7df f934 	bl	c03c810 <psa_read>
    if (bytes_read != msg->in_size[0]) {
 c05d5a8:	6923      	ldr	r3, [r4, #16]
 c05d5aa:	4283      	cmp	r3, r0
 c05d5ac:	d1ed      	bne.n	c05d58a <psa_attest_get_token_size+0x1a>
    status = initial_attest_get_token_size(in_vec, IOVEC_LEN(in_vec),
 c05d5ae:	2301      	movs	r3, #1
 c05d5b0:	aa04      	add	r2, sp, #16
 c05d5b2:	4619      	mov	r1, r3
 c05d5b4:	a802      	add	r0, sp, #8
 c05d5b6:	f7fd ff3b 	bl	c05b430 <initial_attest_get_token_size>
    if (status == PSA_SUCCESS) {
 c05d5ba:	4605      	mov	r5, r0
 c05d5bc:	2800      	cmp	r0, #0
 c05d5be:	d1e6      	bne.n	c05d58e <psa_attest_get_token_size+0x1e>
        psa_write(msg->handle, 0, out_vec[0].base, out_vec[0].len);
 c05d5c0:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 c05d5c4:	4601      	mov	r1, r0
 c05d5c6:	6860      	ldr	r0, [r4, #4]
 c05d5c8:	f7df f924 	bl	c03c814 <psa_write>
 c05d5cc:	e7df      	b.n	c05d58e <psa_attest_get_token_size+0x1e>
 c05d5ce:	bf00      	nop
 c05d5d0:	300388e8 	.word	0x300388e8

0c05d5d4 <psa_attest_get_token>:
{
 c05d5d4:	b530      	push	{r4, r5, lr}
    size_t challenge_size = msg->in_size[0];
 c05d5d6:	6904      	ldr	r4, [r0, #16]
{
 c05d5d8:	f5ad 7d29 	sub.w	sp, sp, #676	@ 0x2a4
    psa_invec in_vec[] = {
 c05d5dc:	aa04      	add	r2, sp, #16
    psa_outvec out_vec[] = {
 c05d5de:	a914      	add	r1, sp, #80	@ 0x50
    if (challenge_size > PSA_INITIAL_ATTEST_CHALLENGE_SIZE_64) {
 c05d5e0:	2c40      	cmp	r4, #64	@ 0x40
{
 c05d5e2:	4605      	mov	r5, r0
    psa_invec in_vec[] = {
 c05d5e4:	e9cd 2400 	strd	r2, r4, [sp]
    size_t token_size = msg->out_size[0];
 c05d5e8:	6a03      	ldr	r3, [r0, #32]
    psa_outvec out_vec[] = {
 c05d5ea:	9102      	str	r1, [sp, #8]
    if (challenge_size > PSA_INITIAL_ATTEST_CHALLENGE_SIZE_64) {
 c05d5ec:	d821      	bhi.n	c05d632 <psa_attest_get_token+0x5e>
    if (token_size < sizeof(token_buff)) {
 c05d5ee:	f5b3 7f14 	cmp.w	r3, #592	@ 0x250
 c05d5f2:	bf28      	it	cs
 c05d5f4:	f44f 7314 	movcs.w	r3, #592	@ 0x250
    g_attest_caller_id = msg->client_id;
 c05d5f8:	6881      	ldr	r1, [r0, #8]
 c05d5fa:	9303      	str	r3, [sp, #12]
 c05d5fc:	4b10      	ldr	r3, [pc, #64]	@ (c05d640 <psa_attest_get_token+0x6c>)
    bytes_read = psa_read(msg->handle, 0,
 c05d5fe:	6840      	ldr	r0, [r0, #4]
    g_attest_caller_id = msg->client_id;
 c05d600:	6019      	str	r1, [r3, #0]
    bytes_read = psa_read(msg->handle, 0,
 c05d602:	4623      	mov	r3, r4
 c05d604:	2100      	movs	r1, #0
 c05d606:	f7df f903 	bl	c03c810 <psa_read>
    if (bytes_read != challenge_size) {
 c05d60a:	4284      	cmp	r4, r0
 c05d60c:	d114      	bne.n	c05d638 <psa_attest_get_token+0x64>
    status = initial_attest_get_token(in_vec, IOVEC_LEN(in_vec),
 c05d60e:	2301      	movs	r3, #1
 c05d610:	4668      	mov	r0, sp
 c05d612:	4619      	mov	r1, r3
 c05d614:	aa02      	add	r2, sp, #8
 c05d616:	f7fd fee1 	bl	c05b3dc <initial_attest_get_token>
    if (status == PSA_SUCCESS) {
 c05d61a:	4604      	mov	r4, r0
 c05d61c:	b928      	cbnz	r0, c05d62a <psa_attest_get_token+0x56>
        psa_write(msg->handle, 0, out_vec[0].base, out_vec[0].len);
 c05d61e:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 c05d622:	4601      	mov	r1, r0
 c05d624:	6868      	ldr	r0, [r5, #4]
 c05d626:	f7df f8f5 	bl	c03c814 <psa_write>
}
 c05d62a:	4620      	mov	r0, r4
 c05d62c:	f50d 7d29 	add.w	sp, sp, #676	@ 0x2a4
 c05d630:	bd30      	pop	{r4, r5, pc}
        return PSA_ERROR_INVALID_ARGUMENT;
 c05d632:	f06f 0486 	mvn.w	r4, #134	@ 0x86
 c05d636:	e7f8      	b.n	c05d62a <psa_attest_get_token+0x56>
        return PSA_ERROR_GENERIC_ERROR;
 c05d638:	f06f 0483 	mvn.w	r4, #131	@ 0x83
 c05d63c:	e7f5      	b.n	c05d62a <psa_attest_get_token+0x56>
 c05d63e:	bf00      	nop
 c05d640:	300388e8 	.word	0x300388e8

0c05d644 <attest_signal_handle>:
    while (1)
        ;
}

static void attest_signal_handle(psa_signal_t signal, attest_func_t pfn)
{
 c05d644:	b510      	push	{r4, lr}
 c05d646:	b08c      	sub	sp, #48	@ 0x30
 c05d648:	460c      	mov	r4, r1
    psa_msg_t msg;
    psa_status_t status;

    status = psa_get(signal, &msg);
 c05d64a:	4669      	mov	r1, sp
 c05d64c:	f7df f8de 	bl	c03c80c <psa_get>
    switch (msg.type) {
 c05d650:	9b00      	ldr	r3, [sp, #0]
 c05d652:	2b00      	cmp	r3, #0
 c05d654:	da02      	bge.n	c05d65c <attest_signal_handle+0x18>
 c05d656:	3302      	adds	r3, #2
 c05d658:	da02      	bge.n	c05d660 <attest_signal_handle+0x1c>
 c05d65a:	e7fe      	b.n	c05d65a <attest_signal_handle+0x16>
 c05d65c:	d006      	beq.n	c05d66c <attest_signal_handle+0x28>
 c05d65e:	e7fc      	b.n	c05d65a <attest_signal_handle+0x16>
    case PSA_IPC_CONNECT:
        psa_reply(msg.handle, PSA_SUCCESS);
 c05d660:	2100      	movs	r1, #0
        break;
    case PSA_IPC_CALL:
        status = (psa_status_t)pfn(&msg);
        psa_reply(msg.handle, status);
 c05d662:	9801      	ldr	r0, [sp, #4]
 c05d664:	f7df f8d8 	bl	c03c818 <psa_reply>
        psa_reply(msg.handle, PSA_SUCCESS);
        break;
    default:
        tfm_abort();
    }
}
 c05d668:	b00c      	add	sp, #48	@ 0x30
 c05d66a:	bd10      	pop	{r4, pc}
        status = (psa_status_t)pfn(&msg);
 c05d66c:	4668      	mov	r0, sp
 c05d66e:	47a0      	blx	r4
 c05d670:	4601      	mov	r1, r0
 c05d672:	e7f6      	b.n	c05d662 <attest_signal_handle+0x1e>

0c05d674 <attest_partition_init>:
#endif

psa_status_t attest_partition_init(void)
{
 c05d674:	b570      	push	{r4, r5, r6, lr}
    psa_status_t err = attest_init();
 c05d676:	f7fd fe9d 	bl	c05b3b4 <attest_init>
#ifdef TFM_PSA_API
    psa_signal_t signals;

    if (err != PSA_SUCCESS) {
 c05d67a:	b978      	cbnz	r0, c05d69c <attest_partition_init+0x28>
                                 psa_attest_get_token);
        } else if (signals & TFM_ATTEST_GET_TOKEN_SIZE_SIGNAL) {
            attest_signal_handle(TFM_ATTEST_GET_TOKEN_SIZE_SIGNAL,
                                 psa_attest_get_token_size);
        } else if (signals & TFM_ATTEST_GET_PUBLIC_KEY_SIGNAL) {
            attest_signal_handle(TFM_ATTEST_GET_PUBLIC_KEY_SIGNAL,
 c05d67c:	4c0d      	ldr	r4, [pc, #52]	@ (c05d6b4 <attest_partition_init+0x40>)
            attest_signal_handle(TFM_ATTEST_GET_TOKEN_SIZE_SIGNAL,
 c05d67e:	4d0e      	ldr	r5, [pc, #56]	@ (c05d6b8 <attest_partition_init+0x44>)
            attest_signal_handle(TFM_ATTEST_GET_TOKEN_SIGNAL,
 c05d680:	4e0e      	ldr	r6, [pc, #56]	@ (c05d6bc <attest_partition_init+0x48>)
        signals = psa_wait(PSA_WAIT_ANY, PSA_BLOCK);
 c05d682:	f04f 4100 	mov.w	r1, #2147483648	@ 0x80000000
 c05d686:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 c05d68a:	f7df f8bd 	bl	c03c808 <psa_wait>
        if (signals & TFM_ATTEST_GET_TOKEN_SIGNAL) {
 c05d68e:	06c1      	lsls	r1, r0, #27
 c05d690:	d505      	bpl.n	c05d69e <attest_partition_init+0x2a>
            attest_signal_handle(TFM_ATTEST_GET_TOKEN_SIGNAL,
 c05d692:	4631      	mov	r1, r6
 c05d694:	2010      	movs	r0, #16
            attest_signal_handle(TFM_ATTEST_GET_PUBLIC_KEY_SIGNAL,
 c05d696:	f7ff ffd5 	bl	c05d644 <attest_signal_handle>
 c05d69a:	e7f2      	b.n	c05d682 <attest_partition_init+0xe>
 c05d69c:	e7fe      	b.n	c05d69c <attest_partition_init+0x28>
        } else if (signals & TFM_ATTEST_GET_TOKEN_SIZE_SIGNAL) {
 c05d69e:	0682      	lsls	r2, r0, #26
 c05d6a0:	d502      	bpl.n	c05d6a8 <attest_partition_init+0x34>
            attest_signal_handle(TFM_ATTEST_GET_TOKEN_SIZE_SIGNAL,
 c05d6a2:	4629      	mov	r1, r5
 c05d6a4:	2020      	movs	r0, #32
 c05d6a6:	e7f6      	b.n	c05d696 <attest_partition_init+0x22>
        } else if (signals & TFM_ATTEST_GET_PUBLIC_KEY_SIGNAL) {
 c05d6a8:	0643      	lsls	r3, r0, #25
 c05d6aa:	d502      	bpl.n	c05d6b2 <attest_partition_init+0x3e>
            attest_signal_handle(TFM_ATTEST_GET_PUBLIC_KEY_SIGNAL,
 c05d6ac:	4621      	mov	r1, r4
 c05d6ae:	2040      	movs	r0, #64	@ 0x40
 c05d6b0:	e7f1      	b.n	c05d696 <attest_partition_init+0x22>
 c05d6b2:	e7fe      	b.n	c05d6b2 <attest_partition_init+0x3e>
 c05d6b4:	0c05d4e5 	.word	0x0c05d4e5
 c05d6b8:	0c05d571 	.word	0x0c05d571
 c05d6bc:	0c05d5d5 	.word	0x0c05d5d5

0c05d6c0 <tfm_core_check_boot_data_access_policy>:
 * \param[in]  major_type  Data type identifier.
 *
 * \return  Returns 0 in case of success, otherwise -1.
 */
static int32_t tfm_core_check_boot_data_access_policy(uint8_t major_type)
{
 c05d6c0:	b510      	push	{r4, lr}
 c05d6c2:	4604      	mov	r4, r0
#ifndef TFM_PSA_API
    uint32_t partition_idx = tfm_spm_partition_get_running_partition_idx();

    partition_id = tfm_spm_partition_get_partition_id(partition_idx);
#else
    partition_id = tfm_spm_partition_get_running_partition_id();
 c05d6c4:	f7ff f8e3 	bl	c05c88e <tfm_spm_partition_get_running_partition_id>
#endif

    for (i = 0; i < array_size; ++i) {
        if (partition_id == access_policy_table[i].partition_id) {
 c05d6c8:	f240 1305 	movw	r3, #261	@ 0x105
 c05d6cc:	4298      	cmp	r0, r3
 c05d6ce:	d103      	bne.n	c05d6d8 <tfm_core_check_boot_data_access_policy+0x18>
            if (major_type == access_policy_table[i].major_type) {
 c05d6d0:	2c01      	cmp	r4, #1
 c05d6d2:	d10a      	bne.n	c05d6ea <tfm_core_check_boot_data_access_policy+0x2a>
                rc = 0;
 c05d6d4:	2000      	movs	r0, #0
 c05d6d6:	e00c      	b.n	c05d6f2 <tfm_core_check_boot_data_access_policy+0x32>
        if (partition_id == access_policy_table[i].partition_id) {
 c05d6d8:	f240 130f 	movw	r3, #271	@ 0x10f
 c05d6dc:	4298      	cmp	r0, r3
 c05d6de:	d109      	bne.n	c05d6f4 <tfm_core_check_boot_data_access_policy+0x34>
            if (major_type == access_policy_table[i].major_type) {
 c05d6e0:	1ea0      	subs	r0, r4, #2
 c05d6e2:	bf18      	it	ne
 c05d6e4:	f04f 30ff 	movne.w	r0, #4294967295	@ 0xffffffff
 c05d6e8:	e003      	b.n	c05d6f2 <tfm_core_check_boot_data_access_policy+0x32>
 c05d6ea:	1e20      	subs	r0, r4, #0
 c05d6ec:	bf18      	it	ne
 c05d6ee:	2001      	movne	r0, #1
 c05d6f0:	4240      	negs	r0, r0
            }
        }
    }

    return rc;
}
 c05d6f2:	bd10      	pop	{r4, pc}
        if (partition_id == access_policy_table[i].partition_id) {
 c05d6f4:	f240 1303 	movw	r3, #259	@ 0x103
 c05d6f8:	4298      	cmp	r0, r3
 c05d6fa:	d101      	bne.n	c05d700 <tfm_core_check_boot_data_access_policy+0x40>
            if (major_type == access_policy_table[i].major_type) {
 c05d6fc:	1ee0      	subs	r0, r4, #3
 c05d6fe:	e7f0      	b.n	c05d6e2 <tfm_core_check_boot_data_access_policy+0x22>
    int32_t rc = -1;
 c05d700:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
    return rc;
 c05d704:	e7f5      	b.n	c05d6f2 <tfm_core_check_boot_data_access_policy+0x32>
	...

0c05d708 <tfm_core_validate_boot_data>:
#ifdef BOOT_DATA_AVAILABLE
    struct tfm_boot_data *boot_data;

    boot_data = (struct tfm_boot_data *)BOOT_TFM_SHARED_DATA_BASE;

    if (boot_data->header.tlv_magic == SHARED_DATA_TLV_INFO_MAGIC) {
 c05d708:	4b04      	ldr	r3, [pc, #16]	@ (c05d71c <tfm_core_validate_boot_data+0x14>)
 c05d70a:	881a      	ldrh	r2, [r3, #0]
 c05d70c:	f242 0316 	movw	r3, #8214	@ 0x2016
 c05d710:	429a      	cmp	r2, r3
        is_boot_data_valid = BOOT_DATA_VALID;
 c05d712:	bf02      	ittt	eq
 c05d714:	2201      	moveq	r2, #1
 c05d716:	4b02      	ldreq	r3, [pc, #8]	@ (c05d720 <tfm_core_validate_boot_data+0x18>)
 c05d718:	601a      	streq	r2, [r3, #0]
    }
#else
    is_boot_data_valid = BOOT_DATA_VALID;
#endif /* BOOT_DATA_AVAILABLE */
}
 c05d71a:	4770      	bx	lr
 c05d71c:	30030000 	.word	0x30030000
 c05d720:	300388ec 	.word	0x300388ec

0c05d724 <tfm_core_get_boot_data_handler>:

void tfm_core_get_boot_data_handler(uint32_t args[])
{
 c05d724:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    uint8_t  tlv_major = (uint8_t)args[0];
    uint8_t *buf_start = (uint8_t *)args[1];
 c05d728:	e9d0 a400 	ldrd	sl, r4, [r0]
{
 c05d72c:	b085      	sub	sp, #20
 c05d72e:	4606      	mov	r6, r0
    uint16_t buf_size  = (uint16_t)args[2];
 c05d730:	6885      	ldr	r5, [r0, #8]
        /* Not in accessible range, return error */
        args[0] = (uint32_t)TFM_ERROR_INVALID_PARAMETER;
        return;
    }
#else
    partition = tfm_spm_get_running_partition();
 c05d732:	f7fe ffef 	bl	c05c714 <tfm_spm_get_running_partition>
    if (!partition) {
 c05d736:	4607      	mov	r7, r0
 c05d738:	b908      	cbnz	r0, c05d73e <tfm_core_get_boot_data_handler+0x1a>
        tfm_core_panic();
 c05d73a:	f000 ffd5 	bl	c05e6e8 <tfm_core_panic>
    }
    privileged =
        tfm_spm_partition_get_privileged_mode(partition->p_static->flags);
 c05d73e:	683b      	ldr	r3, [r7, #0]
 c05d740:	fa1f fb85 	uxth.w	fp, r5
 c05d744:	6898      	ldr	r0, [r3, #8]
 c05d746:	f7fe ffcd 	bl	c05c6e4 <tfm_spm_partition_get_privileged_mode>

    if (tfm_memory_check(buf_start, buf_size, false, TFM_MEMORY_ACCESS_RW,
 c05d74a:	2302      	movs	r3, #2
 c05d74c:	9000      	str	r0, [sp, #0]
 c05d74e:	2200      	movs	r2, #0
 c05d750:	4659      	mov	r1, fp
 c05d752:	4620      	mov	r0, r4
 c05d754:	f7ff f8c4 	bl	c05c8e0 <tfm_memory_check>
 c05d758:	b120      	cbz	r0, c05d764 <tfm_core_get_boot_data_handler+0x40>
        privileged) != SPM_SUCCESS) {
        /* Not in accessible range, return error */
        args[0] = (uint32_t)TFM_ERROR_INVALID_PARAMETER;
        return;
 c05d75a:	2303      	movs	r3, #3
        args[0] = (uint32_t)TFM_ERROR_INVALID_PARAMETER;
 c05d75c:	6033      	str	r3, [r6, #0]
    }
#endif /* BOOT_DATA_AVAILABLE */

    args[0] = (uint32_t)TFM_SUCCESS;
    return;
}
 c05d75e:	b005      	add	sp, #20
 c05d760:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if (is_boot_data_valid != BOOT_DATA_VALID) {
 c05d764:	4b1f      	ldr	r3, [pc, #124]	@ (c05d7e4 <tfm_core_get_boot_data_handler+0xc0>)
 c05d766:	681b      	ldr	r3, [r3, #0]
 c05d768:	2b01      	cmp	r3, #1
 c05d76a:	d1f6      	bne.n	c05d75a <tfm_core_get_boot_data_handler+0x36>
    uint8_t  tlv_major = (uint8_t)args[0];
 c05d76c:	fa5f fa8a 	uxtb.w	sl, sl
    if (tfm_core_check_boot_data_access_policy(tlv_major)) {
 c05d770:	4650      	mov	r0, sl
 c05d772:	f7ff ffa5 	bl	c05d6c0 <tfm_core_check_boot_data_access_policy>
 c05d776:	2800      	cmp	r0, #0
 c05d778:	d1ef      	bne.n	c05d75a <tfm_core_get_boot_data_handler+0x36>
    tlv_end = BOOT_TFM_SHARED_DATA_BASE + boot_data->header.tlv_tot_len;
 c05d77a:	4b1b      	ldr	r3, [pc, #108]	@ (c05d7e8 <tfm_core_get_boot_data_handler+0xc4>)
    if (buf_size < SHARED_DATA_HEADER_SIZE) {
 c05d77c:	b2ad      	uxth	r5, r5
 c05d77e:	2d03      	cmp	r5, #3
    tlv_end = BOOT_TFM_SHARED_DATA_BASE + boot_data->header.tlv_tot_len;
 c05d780:	885f      	ldrh	r7, [r3, #2]
    if (buf_size < SHARED_DATA_HEADER_SIZE) {
 c05d782:	d9ea      	bls.n	c05d75a <tfm_core_get_boot_data_handler+0x36>
        boot_data->header.tlv_magic   = SHARED_DATA_TLV_INFO_MAGIC;
 c05d784:	f242 0316 	movw	r3, #8214	@ 0x2016
 c05d788:	8023      	strh	r3, [r4, #0]
        boot_data->header.tlv_tot_len = SHARED_DATA_HEADER_SIZE;
 c05d78a:	2304      	movs	r3, #4
    tlv_end = BOOT_TFM_SHARED_DATA_BASE + boot_data->header.tlv_tot_len;
 c05d78c:	f107 5740 	add.w	r7, r7, #805306368	@ 0x30000000
    offset  = BOOT_TFM_SHARED_DATA_BASE + SHARED_DATA_HEADER_SIZE;
 c05d790:	f8df 8058 	ldr.w	r8, [pc, #88]	@ c05d7ec <tfm_core_get_boot_data_handler+0xc8>
    tlv_end = BOOT_TFM_SHARED_DATA_BASE + boot_data->header.tlv_tot_len;
 c05d794:	f507 3740 	add.w	r7, r7, #196608	@ 0x30000
        boot_data->header.tlv_tot_len = SHARED_DATA_HEADER_SIZE;
 c05d798:	8063      	strh	r3, [r4, #2]
    ptr = boot_data->data;
 c05d79a:	eb04 0903 	add.w	r9, r4, r3
    for (; offset < tlv_end; offset += next_tlv_offset) {
 c05d79e:	45b8      	cmp	r8, r7
 c05d7a0:	d301      	bcc.n	c05d7a6 <tfm_core_get_boot_data_handler+0x82>
 c05d7a2:	2300      	movs	r3, #0
 c05d7a4:	e7da      	b.n	c05d75c <tfm_core_get_boot_data_handler+0x38>
        (void)spm_memcpy(&tlv_entry, (const void *)offset,
 c05d7a6:	2204      	movs	r2, #4
 c05d7a8:	4641      	mov	r1, r8
 c05d7aa:	a803      	add	r0, sp, #12
 c05d7ac:	f000 f92a 	bl	c05da04 <spm_memcpy>
        if (GET_MAJOR(tlv_entry.tlv_type) == tlv_major) {
 c05d7b0:	f8bd 300c 	ldrh.w	r3, [sp, #12]
        next_tlv_offset = SHARED_DATA_ENTRY_HEADER_SIZE + tlv_entry.tlv_len;
 c05d7b4:	f8bd 500e 	ldrh.w	r5, [sp, #14]
        if (GET_MAJOR(tlv_entry.tlv_type) == tlv_major) {
 c05d7b8:	ebba 3f13 	cmp.w	sl, r3, lsr #12
        next_tlv_offset = SHARED_DATA_ENTRY_HEADER_SIZE + tlv_entry.tlv_len;
 c05d7bc:	f105 0504 	add.w	r5, r5, #4
        if (GET_MAJOR(tlv_entry.tlv_type) == tlv_major) {
 c05d7c0:	d10d      	bne.n	c05d7de <tfm_core_get_boot_data_handler+0xba>
            if (((ptr - buf_start) + next_tlv_offset) > buf_size) {
 c05d7c2:	eba9 0304 	sub.w	r3, r9, r4
 c05d7c6:	442b      	add	r3, r5
 c05d7c8:	455b      	cmp	r3, fp
 c05d7ca:	d8c6      	bhi.n	c05d75a <tfm_core_get_boot_data_handler+0x36>
            (void)spm_memcpy(ptr, (const void *)offset, next_tlv_offset);
 c05d7cc:	4648      	mov	r0, r9
 c05d7ce:	462a      	mov	r2, r5
 c05d7d0:	4641      	mov	r1, r8
 c05d7d2:	f000 f917 	bl	c05da04 <spm_memcpy>
            boot_data->header.tlv_tot_len += next_tlv_offset;
 c05d7d6:	8863      	ldrh	r3, [r4, #2]
            ptr += next_tlv_offset;
 c05d7d8:	44a9      	add	r9, r5
            boot_data->header.tlv_tot_len += next_tlv_offset;
 c05d7da:	442b      	add	r3, r5
 c05d7dc:	8063      	strh	r3, [r4, #2]
    for (; offset < tlv_end; offset += next_tlv_offset) {
 c05d7de:	44a8      	add	r8, r5
 c05d7e0:	e7dd      	b.n	c05d79e <tfm_core_get_boot_data_handler+0x7a>
 c05d7e2:	bf00      	nop
 c05d7e4:	300388ec 	.word	0x300388ec
 c05d7e8:	30030000 	.word	0x30030000
 c05d7ec:	30030004 	.word	0x30030004

0c05d7f0 <tfm_core_get_boot_value_handler>:


void tfm_core_get_boot_value_handler(uint32_t args[])
{
 c05d7f0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    uint16_t  tlv = (uint16_t)args[0];
    uint8_t *buf_start = (uint8_t *)args[1];
 c05d7f4:	e9d0 6800 	ldrd	r6, r8, [r0]
{
 c05d7f8:	b085      	sub	sp, #20
 c05d7fa:	4604      	mov	r4, r0
    uint16_t buf_size  = (uint16_t)args[2];
 c05d7fc:	6887      	ldr	r7, [r0, #8]
        /* Not in accessible range, return error */
        args[0] = TFM_ERROR_INVALID_PARAMETER;
        return;
    }
#else
    partition = tfm_spm_get_running_partition();
 c05d7fe:	f7fe ff89 	bl	c05c714 <tfm_spm_get_running_partition>
    if (!partition) {
 c05d802:	4605      	mov	r5, r0
 c05d804:	b908      	cbnz	r0, c05d80a <tfm_core_get_boot_value_handler+0x1a>
        tfm_core_panic();
 c05d806:	f000 ff6f 	bl	c05e6e8 <tfm_core_panic>
    }
     privileged =
        tfm_spm_partition_get_privileged_mode(partition->p_static->flags);
 c05d80a:	682b      	ldr	r3, [r5, #0]
 c05d80c:	6898      	ldr	r0, [r3, #8]
 c05d80e:	f7fe ff69 	bl	c05c6e4 <tfm_spm_partition_get_privileged_mode>

    if (tfm_memory_check(buf_start, buf_size, false, TFM_MEMORY_ACCESS_RW,
 c05d812:	2302      	movs	r3, #2
 c05d814:	9000      	str	r0, [sp, #0]
 c05d816:	2200      	movs	r2, #0
 c05d818:	4640      	mov	r0, r8
 c05d81a:	b2b9      	uxth	r1, r7
 c05d81c:	f7ff f860 	bl	c05c8e0 <tfm_memory_check>
 c05d820:	b120      	cbz	r0, c05d82c <tfm_core_get_boot_value_handler+0x3c>
        privileged) != SPM_SUCCESS) {
        /* Not in accessible range, return error */
        args[0] = TFM_ERROR_INVALID_PARAMETER;
        return;
 c05d822:	2303      	movs	r3, #3
        args[0] = TFM_ERROR_INVALID_PARAMETER;
 c05d824:	6023      	str	r3, [r4, #0]
    if (found)
      args[0] = TFM_SUCCESS;
    else
      args[0] = TFM_ERROR_INVALID_PARAMETER;
    return;
}
 c05d826:	b005      	add	sp, #20
 c05d828:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    if (tfm_core_check_boot_data_access_policy(GET_MAJOR(tlv))) {
 c05d82c:	f3c6 3003 	ubfx	r0, r6, #12, #4
    uint16_t  tlv = (uint16_t)args[0];
 c05d830:	fa1f f986 	uxth.w	r9, r6
    if (tfm_core_check_boot_data_access_policy(GET_MAJOR(tlv))) {
 c05d834:	f7ff ff44 	bl	c05d6c0 <tfm_core_check_boot_data_access_policy>
 c05d838:	2800      	cmp	r0, #0
 c05d83a:	d1f2      	bne.n	c05d822 <tfm_core_get_boot_value_handler+0x32>
    if (is_boot_data_valid != BOOT_DATA_VALID) {
 c05d83c:	4b12      	ldr	r3, [pc, #72]	@ (c05d888 <tfm_core_get_boot_value_handler+0x98>)
 c05d83e:	681b      	ldr	r3, [r3, #0]
 c05d840:	2b01      	cmp	r3, #1
 c05d842:	d1ee      	bne.n	c05d822 <tfm_core_get_boot_value_handler+0x32>
    tlv_end = BOOT_TFM_SHARED_DATA_BASE + boot_data->header.tlv_tot_len;
 c05d844:	4b11      	ldr	r3, [pc, #68]	@ (c05d88c <tfm_core_get_boot_value_handler+0x9c>)
    offset  = BOOT_TFM_SHARED_DATA_BASE + SHARED_DATA_HEADER_SIZE;
 c05d846:	4e12      	ldr	r6, [pc, #72]	@ (c05d890 <tfm_core_get_boot_value_handler+0xa0>)
    tlv_end = BOOT_TFM_SHARED_DATA_BASE + boot_data->header.tlv_tot_len;
 c05d848:	885d      	ldrh	r5, [r3, #2]
 c05d84a:	f105 5540 	add.w	r5, r5, #805306368	@ 0x30000000
 c05d84e:	f505 3540 	add.w	r5, r5, #196608	@ 0x30000
    for (; offset < tlv_end; offset += next_tlv_offset) {
 c05d852:	42ae      	cmp	r6, r5
 c05d854:	d2e5      	bcs.n	c05d822 <tfm_core_get_boot_value_handler+0x32>
        (void)spm_memcpy(&tlv_entry, (const void *)offset,
 c05d856:	2204      	movs	r2, #4
 c05d858:	4631      	mov	r1, r6
 c05d85a:	a803      	add	r0, sp, #12
 c05d85c:	f000 f8d2 	bl	c05da04 <spm_memcpy>
        if (tlv_entry.tlv_type == tlv) {
 c05d860:	f8bd 100c 	ldrh.w	r1, [sp, #12]
        next_tlv_offset = SHARED_DATA_ENTRY_HEADER_SIZE + tlv_entry.tlv_len;
 c05d864:	f8bd 200e 	ldrh.w	r2, [sp, #14]
        if (tlv_entry.tlv_type == tlv) {
 c05d868:	4549      	cmp	r1, r9
        next_tlv_offset = SHARED_DATA_ENTRY_HEADER_SIZE + tlv_entry.tlv_len;
 c05d86a:	f102 0304 	add.w	r3, r2, #4
        if (tlv_entry.tlv_type == tlv) {
 c05d86e:	d108      	bne.n	c05d882 <tfm_core_get_boot_value_handler+0x92>
            if (tlv_entry.tlv_len > buf_size) {
 c05d870:	b2bf      	uxth	r7, r7
 c05d872:	42ba      	cmp	r2, r7
 c05d874:	d8d5      	bhi.n	c05d822 <tfm_core_get_boot_value_handler+0x32>
	    spm_memcpy(buf_start, (const void *)((uint32_t)offset+sizeof(tlv_entry)), tlv_entry.tlv_len);
 c05d876:	4640      	mov	r0, r8
 c05d878:	1d31      	adds	r1, r6, #4
 c05d87a:	f000 f8c3 	bl	c05da04 <spm_memcpy>
      args[0] = TFM_SUCCESS;
 c05d87e:	2300      	movs	r3, #0
 c05d880:	e7d0      	b.n	c05d824 <tfm_core_get_boot_value_handler+0x34>
    for (; offset < tlv_end; offset += next_tlv_offset) {
 c05d882:	441e      	add	r6, r3
 c05d884:	e7e5      	b.n	c05d852 <tfm_core_get_boot_value_handler+0x62>
 c05d886:	bf00      	nop
 c05d888:	300388ec 	.word	0x300388ec
 c05d88c:	30030000 	.word	0x30030000
 c05d890:	30030004 	.word	0x30030004

0c05d894 <tfm_core_svc_handler>:
    return PSA_SUCCESS;
}


uint32_t tfm_core_svc_handler(uint32_t *msp, uint32_t *psp, uint32_t exc_return)
{
 c05d894:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 c05d898:	4615      	mov	r5, r2
    tfm_svc_number_t svc_number = TFM_SVC_PSA_FRAMEWORK_VERSION;
    uint32_t *svc_args = msp;

    if (!(exc_return & EXC_RETURN_MODE)) {
 c05d89a:	072a      	lsls	r2, r5, #28
{
 c05d89c:	4606      	mov	r6, r0
 c05d89e:	460c      	mov	r4, r1
    if (!(exc_return & EXC_RETURN_MODE)) {
 c05d8a0:	d401      	bmi.n	c05d8a6 <tfm_core_svc_handler+0x12>
        /* Calling SVC from Handler Mode is not supported */
        tfm_core_panic();
 c05d8a2:	f000 ff21 	bl	c05e6e8 <tfm_core_panic>
    }

    if ((exc_return & EXC_RETURN_MODE) && (exc_return & EXC_RETURN_SPSEL)) {
 c05d8a6:	f005 030c 	and.w	r3, r5, #12
        /* Use PSP when both EXC_RETURN.MODE and EXC_RETURN.SPSEL are set */
        svc_args = psp;
    } else {
        svc_args = msp;
 c05d8aa:	2b0c      	cmp	r3, #12
 c05d8ac:	bf18      	it	ne
 c05d8ae:	4634      	movne	r4, r6
    /*
     * Stack contains:
     * r0, r1, r2, r3, r12, r14 (lr), the return address and xPSR
     * First argument (r0) is svc_args[0]
     */
    if (is_return_secure_stack(exc_return)) {
 c05d8b0:	066b      	lsls	r3, r5, #25
 c05d8b2:	d50e      	bpl.n	c05d8d2 <tfm_core_svc_handler+0x3e>
        /* SV called directly from secure context. Check instruction for
         * svc_number
         */
        svc_number = ((tfm_svc_number_t *)svc_args[6])[-2];
 c05d8b4:	69a3      	ldr	r3, [r4, #24]
 c05d8b6:	f813 7c02 	ldrb.w	r7, [r3, #-2]
         * NS cannot directly trigger S SVC so this should not happen. This is
         * an unrecoverable error.
         */
        tfm_core_panic();
    }
    switch (svc_number) {
 c05d8ba:	2f09      	cmp	r7, #9
 c05d8bc:	d035      	beq.n	c05d92a <tfm_core_svc_handler+0x96>
 c05d8be:	2f1c      	cmp	r7, #28
 c05d8c0:	d039      	beq.n	c05d936 <tfm_core_svc_handler+0xa2>
 c05d8c2:	2f04      	cmp	r7, #4
 c05d8c4:	d108      	bne.n	c05d8d8 <tfm_core_svc_handler+0x44>
    case TFM_SVC_HANDLER_MODE:
        tfm_arch_clear_fp_status();
        exc_return = tfm_spm_init();
        break;
    case TFM_SVC_GET_BOOT_DATA:
        tfm_core_get_boot_data_handler(svc_args);
 c05d8c6:	4620      	mov	r0, r4
 c05d8c8:	f7ff ff2c 	bl	c05d724 <tfm_core_get_boot_data_handler>
        svc_args[0] = SVC_Handler_IPC(svc_number, svc_args, exc_return);
        break;
    }

    return exc_return;
}
 c05d8cc:	4628      	mov	r0, r5
 c05d8ce:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        tfm_core_panic();
 c05d8d2:	f000 ff09 	bl	c05e6e8 <tfm_core_panic>
    tfm_svc_number_t svc_number = TFM_SVC_PSA_FRAMEWORK_VERSION;
 c05d8d6:	270a      	movs	r7, #10
    if (ctx[6] >= veneer_base && ctx[6] < veneer_limit &&
 c05d8d8:	69a3      	ldr	r3, [r4, #24]
 c05d8da:	4a47      	ldr	r2, [pc, #284]	@ (c05d9f8 <tfm_core_svc_handler+0x164>)
 c05d8dc:	4293      	cmp	r3, r2
 c05d8de:	d32e      	bcc.n	c05d93e <tfm_core_svc_handler+0xaa>
 c05d8e0:	4a46      	ldr	r2, [pc, #280]	@ (c05d9fc <tfm_core_svc_handler+0x168>)
 c05d8e2:	4293      	cmp	r3, r2
 c05d8e4:	d22b      	bcs.n	c05d93e <tfm_core_svc_handler+0xaa>
 c05d8e6:	6966      	ldr	r6, [r4, #20]
 c05d8e8:	43f6      	mvns	r6, r6
 c05d8ea:	f006 0601 	and.w	r6, r6, #1
    partition = tfm_spm_get_running_partition();
 c05d8ee:	f7fe ff11 	bl	c05c714 <tfm_spm_get_running_partition>
    if (!partition) {
 c05d8f2:	4680      	mov	r8, r0
 c05d8f4:	b908      	cbnz	r0, c05d8fa <tfm_core_svc_handler+0x66>
        tfm_core_panic();
 c05d8f6:	f000 fef7 	bl	c05e6e8 <tfm_core_panic>
    tfm_spm_validate_caller(partition, ctx, lr, ns_caller);
 c05d8fa:	4633      	mov	r3, r6
 c05d8fc:	462a      	mov	r2, r5
 c05d8fe:	4621      	mov	r1, r4
 c05d900:	4640      	mov	r0, r8
    switch (svc_num) {
 c05d902:	3f03      	subs	r7, #3
    tfm_spm_validate_caller(partition, ctx, lr, ns_caller);
 c05d904:	f7ff fb48 	bl	c05cf98 <tfm_spm_validate_caller>
    switch (svc_num) {
 c05d908:	2f18      	cmp	r7, #24
 c05d90a:	d872      	bhi.n	c05d9f2 <tfm_core_svc_handler+0x15e>
 c05d90c:	e8df f007 	tbb	[pc, r7]
 c05d910:	7171715d 	.word	0x7171715d
 c05d914:	19715633 	.word	0x19715633
 c05d918:	2d27221d 	.word	0x2d27221d
 c05d91c:	433f3b37 	.word	0x433f3b37
 c05d920:	534f4b47 	.word	0x534f4b47
 c05d924:	6964615a 	.word	0x6964615a
 c05d928:	6d          	.byte	0x6d
 c05d929:	00          	.byte	0x00
        tfm_arch_clear_fp_status();
 c05d92a:	f7ff fdc1 	bl	c05d4b0 <tfm_arch_clear_fp_status>
}
 c05d92e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
        exc_return = tfm_spm_init();
 c05d932:	f7ff b8d9 	b.w	c05cae8 <tfm_spm_init>
        tfm_core_get_boot_value_handler(svc_args);
 c05d936:	4620      	mov	r0, r4
 c05d938:	f7ff ff5a 	bl	c05d7f0 <tfm_core_get_boot_value_handler>
        break;
 c05d93c:	e7c6      	b.n	c05d8cc <tfm_core_svc_handler+0x38>
    bool ns_caller = false;
 c05d93e:	2600      	movs	r6, #0
 c05d940:	e7d5      	b.n	c05d8ee <tfm_core_svc_handler+0x5a>
        return tfm_spm_psa_framework_version();
 c05d942:	f7ec fa59 	bl	c049df8 <tfm_spm_psa_framework_version>
        svc_args[0] = SVC_Handler_IPC(svc_number, svc_args, exc_return);
 c05d946:	6020      	str	r0, [r4, #0]
        break;
 c05d948:	e7c0      	b.n	c05d8cc <tfm_core_svc_handler+0x38>
        return tfm_spm_psa_version(ctx, ns_caller);
 c05d94a:	4631      	mov	r1, r6
 c05d94c:	4620      	mov	r0, r4
 c05d94e:	f7ec fa55 	bl	c049dfc <tfm_spm_psa_version>
 c05d952:	e7f8      	b.n	c05d946 <tfm_core_svc_handler+0xb2>
        return tfm_spm_psa_connect(ctx, ns_caller);
 c05d954:	4631      	mov	r1, r6
 c05d956:	4620      	mov	r0, r4
 c05d958:	f7ec fa53 	bl	c049e02 <tfm_spm_psa_connect>
 c05d95c:	e7f3      	b.n	c05d946 <tfm_core_svc_handler+0xb2>
        return tfm_spm_psa_call(ctx, ns_caller, lr);
 c05d95e:	462a      	mov	r2, r5
 c05d960:	4631      	mov	r1, r6
 c05d962:	4620      	mov	r0, r4
 c05d964:	f7ec fa52 	bl	c049e0c <tfm_spm_psa_call>
 c05d968:	e7ed      	b.n	c05d946 <tfm_core_svc_handler+0xb2>
        tfm_spm_psa_close(ctx, ns_caller);
 c05d96a:	4631      	mov	r1, r6
 c05d96c:	4620      	mov	r0, r4
 c05d96e:	f7ec fa8b 	bl	c049e88 <tfm_spm_psa_close>
    return PSA_SUCCESS;
 c05d972:	2000      	movs	r0, #0
 c05d974:	e7e7      	b.n	c05d946 <tfm_core_svc_handler+0xb2>
        return tfm_spm_psa_wait(ctx);
 c05d976:	4620      	mov	r0, r4
 c05d978:	f7ec fa89 	bl	c049e8e <tfm_spm_psa_wait>
 c05d97c:	e7e3      	b.n	c05d946 <tfm_core_svc_handler+0xb2>
        return tfm_spm_psa_get(ctx);
 c05d97e:	4620      	mov	r0, r4
 c05d980:	f7ec faa0 	bl	c049ec4 <tfm_spm_psa_get>
 c05d984:	e7df      	b.n	c05d946 <tfm_core_svc_handler+0xb2>
        tfm_spm_psa_set_rhandle(ctx);
 c05d986:	4620      	mov	r0, r4
 c05d988:	f7ec fad6 	bl	c049f38 <tfm_spm_psa_set_rhandle>
        break;
 c05d98c:	e7f1      	b.n	c05d972 <tfm_core_svc_handler+0xde>
        return tfm_spm_psa_read(ctx);
 c05d98e:	4620      	mov	r0, r4
 c05d990:	f7ec faed 	bl	c049f6e <tfm_spm_psa_read>
 c05d994:	e7d7      	b.n	c05d946 <tfm_core_svc_handler+0xb2>
        return tfm_spm_psa_skip(ctx);
 c05d996:	4620      	mov	r0, r4
 c05d998:	f7ec fb2a 	bl	c049ff0 <tfm_spm_psa_skip>
 c05d99c:	e7d3      	b.n	c05d946 <tfm_core_svc_handler+0xb2>
        tfm_spm_psa_write(ctx);
 c05d99e:	4620      	mov	r0, r4
 c05d9a0:	f7ec fb4a 	bl	c04a038 <tfm_spm_psa_write>
        break;
 c05d9a4:	e7e5      	b.n	c05d972 <tfm_core_svc_handler+0xde>
        tfm_spm_psa_reply(ctx);
 c05d9a6:	4620      	mov	r0, r4
 c05d9a8:	f7ec fb85 	bl	c04a0b6 <tfm_spm_psa_reply>
        break;
 c05d9ac:	e7e1      	b.n	c05d972 <tfm_core_svc_handler+0xde>
        tfm_spm_psa_notify(ctx);
 c05d9ae:	4620      	mov	r0, r4
 c05d9b0:	f7ec fbcf 	bl	c04a152 <tfm_spm_psa_notify>
        break;
 c05d9b4:	e7dd      	b.n	c05d972 <tfm_core_svc_handler+0xde>
        tfm_spm_psa_clear();
 c05d9b6:	f7ec fbd0 	bl	c04a15a <tfm_spm_psa_clear>
        break;
 c05d9ba:	e7da      	b.n	c05d972 <tfm_core_svc_handler+0xde>
        tfm_spm_psa_eoi(ctx);
 c05d9bc:	4620      	mov	r0, r4
 c05d9be:	f7ec fbdd 	bl	c04a17c <tfm_spm_psa_eoi>
        break;
 c05d9c2:	e7d6      	b.n	c05d972 <tfm_core_svc_handler+0xde>
        tfm_spm_psa_panic();
 c05d9c4:	f7ec fbfd 	bl	c04a1c2 <tfm_spm_psa_panic>
        break;
 c05d9c8:	e7d3      	b.n	c05d972 <tfm_core_svc_handler+0xde>
        tfm_spm_request_handler((const struct tfm_state_context_t *)ctx);
 c05d9ca:	4620      	mov	r0, r4
 c05d9cc:	f7ff fafc 	bl	c05cfc8 <tfm_spm_request_handler>
        break;
 c05d9d0:	e7cf      	b.n	c05d972 <tfm_core_svc_handler+0xde>
        return tfm_spm_get_lifecycle_state();
 c05d9d2:	f7ec fa0f 	bl	c049df4 <tfm_spm_get_lifecycle_state>
 c05d9d6:	e7b6      	b.n	c05d946 <tfm_core_svc_handler+0xb2>
        return tfm_hal_output_spm_log((const char *)ctx[0], ctx[1]);
 c05d9d8:	e9d4 0100 	ldrd	r0, r1, [r4]
 c05d9dc:	f000 fae6 	bl	c05dfac <tfm_hal_output_spm_log>
 c05d9e0:	e7b1      	b.n	c05d946 <tfm_core_svc_handler+0xb2>
        tfm_spm_irq_enable(ctx);
 c05d9e2:	4620      	mov	r0, r4
 c05d9e4:	f7ec fbef 	bl	c04a1c6 <tfm_spm_irq_enable>
        break;
 c05d9e8:	e7c3      	b.n	c05d972 <tfm_core_svc_handler+0xde>
        return tfm_spm_irq_disable(ctx);
 c05d9ea:	4620      	mov	r0, r4
 c05d9ec:	f7ec fc01 	bl	c04a1f2 <tfm_spm_irq_disable>
 c05d9f0:	e7a9      	b.n	c05d946 <tfm_core_svc_handler+0xb2>
    switch (svc_num) {
 c05d9f2:	f06f 0083 	mvn.w	r0, #131	@ 0x83
 c05d9f6:	e7a6      	b.n	c05d946 <tfm_core_svc_handler+0xb2>
 c05d9f8:	0c03c000 	.word	0x0c03c000
 c05d9fc:	0c043d60 	.word	0x0c043d60

0c05da00 <tfm_core_handler_mode>:

__attribute__ ((naked)) void tfm_core_handler_mode(void)
{
    __ASM volatile("SVC %0           \n"
 c05da00:	df09      	svc	9
 c05da02:	4770      	bx	lr

0c05da04 <spm_memcpy>:

void *spm_memcpy(void *dest, const void *src, size_t n)
{
    union tfm_mem_addr_t p_dest, p_src;

    p_dest.uint_addr = (uintptr_t)dest;
 c05da04:	4603      	mov	r3, r0
{
 c05da06:	b570      	push	{r4, r5, r6, lr}
    p_src.uint_addr = (uintptr_t)src;

    /* Byte copy for unaligned address. check the last bit of address. */
    while (n && (GET_MEM_ADDR_BIT0(p_dest.uint_addr) ||
 c05da08:	b14a      	cbz	r2, c05da1e <spm_memcpy+0x1a>
 c05da0a:	ea41 0403 	orr.w	r4, r1, r3
 c05da0e:	07e5      	lsls	r5, r4, #31
 c05da10:	d413      	bmi.n	c05da3a <spm_memcpy+0x36>

    /*
     * Double byte copy for aligned address.
     * Check the 2nd last bit of address.
     */
    while (n >= sizeof(uint16_t) && (GET_MEM_ADDR_BIT1(p_dest.uint_addr) ||
 c05da12:	2a01      	cmp	r2, #1
 c05da14:	d903      	bls.n	c05da1e <spm_memcpy+0x1a>
 c05da16:	ea41 0403 	orr.w	r4, r1, r3
 c05da1a:	07a4      	lsls	r4, r4, #30
 c05da1c:	d413      	bmi.n	c05da46 <spm_memcpy+0x42>
{
 c05da1e:	2400      	movs	r4, #0
        *(p_dest.p_dbyte)++ = *(p_src.p_dbyte)++;
        n -= sizeof(uint16_t);
    }

    /* Quad byte copy for aligned address. */
    while (n >= sizeof(uint32_t)) {
 c05da20:	18a5      	adds	r5, r4, r2
 c05da22:	2d03      	cmp	r5, #3
 c05da24:	d815      	bhi.n	c05da52 <spm_memcpy+0x4e>
 c05da26:	f022 0403 	bic.w	r4, r2, #3
 c05da2a:	4423      	add	r3, r4
 c05da2c:	440c      	add	r4, r1
 c05da2e:	2100      	movs	r1, #0
 c05da30:	f002 0203 	and.w	r2, r2, #3
        *(p_dest.p_qbyte)++ = *(p_src.p_qbyte)++;
        n -= sizeof(uint32_t);
    }

    /* Byte copy for the remaining bytes. */
    while (n--) {
 c05da34:	4291      	cmp	r1, r2
 c05da36:	d112      	bne.n	c05da5e <spm_memcpy+0x5a>
        *p_dest.p_byte++ = *p_src.p_byte++;
    }

    return dest;
}
 c05da38:	bd70      	pop	{r4, r5, r6, pc}
        *p_dest.p_byte++ = *p_src.p_byte++;
 c05da3a:	f811 4b01 	ldrb.w	r4, [r1], #1
        n--;
 c05da3e:	3a01      	subs	r2, #1
        *p_dest.p_byte++ = *p_src.p_byte++;
 c05da40:	f803 4b01 	strb.w	r4, [r3], #1
        n--;
 c05da44:	e7e0      	b.n	c05da08 <spm_memcpy+0x4>
        *(p_dest.p_dbyte)++ = *(p_src.p_dbyte)++;
 c05da46:	f831 4b02 	ldrh.w	r4, [r1], #2
        n -= sizeof(uint16_t);
 c05da4a:	3a02      	subs	r2, #2
        *(p_dest.p_dbyte)++ = *(p_src.p_dbyte)++;
 c05da4c:	f823 4b02 	strh.w	r4, [r3], #2
        n -= sizeof(uint16_t);
 c05da50:	e7df      	b.n	c05da12 <spm_memcpy+0xe>
        *(p_dest.p_qbyte)++ = *(p_src.p_qbyte)++;
 c05da52:	1b0d      	subs	r5, r1, r4
 c05da54:	682e      	ldr	r6, [r5, #0]
 c05da56:	1b1d      	subs	r5, r3, r4
 c05da58:	602e      	str	r6, [r5, #0]
        n -= sizeof(uint32_t);
 c05da5a:	3c04      	subs	r4, #4
 c05da5c:	e7e0      	b.n	c05da20 <spm_memcpy+0x1c>
        *p_dest.p_byte++ = *p_src.p_byte++;
 c05da5e:	5d0d      	ldrb	r5, [r1, r4]
 c05da60:	54cd      	strb	r5, [r1, r3]
 c05da62:	3101      	adds	r1, #1
 c05da64:	e7e6      	b.n	c05da34 <spm_memcpy+0x30>

0c05da66 <spm_memset>:
void *spm_memset(void *s, int c, size_t n)
{
    union tfm_mem_addr_t p_mem;
    uint32_t quad_pattern;

    p_mem.p_byte = (uint8_t *)s;
 c05da66:	4603      	mov	r3, r0
{
 c05da68:	b5f0      	push	{r4, r5, r6, r7, lr}
    quad_pattern = (((uint8_t)c) << 24) | (((uint8_t)c) << 16) |
 c05da6a:	b2c9      	uxtb	r1, r1
                   (((uint8_t)c) << 8) | ((uint8_t)c);

    while (n && (p_mem.uint_addr & (sizeof(uint32_t) - 1))) {
 c05da6c:	b952      	cbnz	r2, c05da84 <spm_memset+0x1e>
 c05da6e:	0894      	lsrs	r4, r2, #2
 c05da70:	eb03 0484 	add.w	r4, r3, r4, lsl #2
 c05da74:	4413      	add	r3, r2
    while (n >= sizeof(uint32_t)) {
        *p_mem.p_qbyte++ = quad_pattern;
        n -= sizeof(uint32_t);
    }

    while (n--) {
 c05da76:	42a3      	cmp	r3, r4
 c05da78:	d111      	bne.n	c05da9e <spm_memset+0x38>
        *p_mem.p_byte++ = (uint8_t)c;
    }

    return s;
}
 c05da7a:	bdf0      	pop	{r4, r5, r6, r7, pc}
        *p_mem.p_byte++ = (uint8_t)c;
 c05da7c:	f803 1b01 	strb.w	r1, [r3], #1
        n--;
 c05da80:	3a01      	subs	r2, #1
 c05da82:	e7f3      	b.n	c05da6c <spm_memset+0x6>
    while (n && (p_mem.uint_addr & (sizeof(uint32_t) - 1))) {
 c05da84:	079c      	lsls	r4, r3, #30
 c05da86:	d1f9      	bne.n	c05da7c <spm_memset+0x16>
 c05da88:	f04f 3501 	mov.w	r5, #16843009	@ 0x1010101
    quad_pattern = (((uint8_t)c) << 24) | (((uint8_t)c) << 16) |
 c05da8c:	4614      	mov	r4, r2
 c05da8e:	434d      	muls	r5, r1
        *p_mem.p_qbyte++ = quad_pattern;
 c05da90:	18d6      	adds	r6, r2, r3
    while (n >= sizeof(uint32_t)) {
 c05da92:	2c03      	cmp	r4, #3
 c05da94:	d9eb      	bls.n	c05da6e <spm_memset+0x8>
        *p_mem.p_qbyte++ = quad_pattern;
 c05da96:	1b37      	subs	r7, r6, r4
 c05da98:	603d      	str	r5, [r7, #0]
        n -= sizeof(uint32_t);
 c05da9a:	3c04      	subs	r4, #4
 c05da9c:	e7f9      	b.n	c05da92 <spm_memset+0x2c>
        *p_mem.p_byte++ = (uint8_t)c;
 c05da9e:	f804 1b01 	strb.w	r1, [r4], #1
 c05daa2:	e7e8      	b.n	c05da76 <spm_memset+0x10>

0c05daa4 <tfm_internal_fwu_initialize>:
#include "tfm_fwu.h"
#include "flash_layout.h"

#if !defined(MCUBOOT_PRIMARY_ONLY)
psa_status_t tfm_internal_fwu_initialize(psa_image_id_t image_id)
{
 c05daa4:	4601      	mov	r1, r0
    uint8_t image_type = (uint8_t)FWU_IMAGE_ID_GET_TYPE(image_id);
    uint8_t slot_id = (uint8_t)FWU_IMAGE_ID_GET_SLOT(image_id);

    /* Check the image slot, the target should be the staging slot. */
    if (slot_id != FWU_IMAGE_ID_SLOT_STAGE) {
 c05daa6:	b2c9      	uxtb	r1, r1
 c05daa8:	2902      	cmp	r1, #2
{
 c05daaa:	b508      	push	{r3, lr}
    uint8_t image_type = (uint8_t)FWU_IMAGE_ID_GET_TYPE(image_id);
 c05daac:	f3c0 2007 	ubfx	r0, r0, #8, #8
    if (slot_id != FWU_IMAGE_ID_SLOT_STAGE) {
 c05dab0:	d103      	bne.n	c05daba <tfm_internal_fwu_initialize+0x16>
        LOG_MSG("TFM FWU: invalid slot_id: %d", slot_id);
        return PSA_ERROR_INVALID_ARGUMENT;
    }

    return fwu_bootloader_staging_area_init(image_type);
}
 c05dab2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    return fwu_bootloader_staging_area_init(image_type);
 c05dab6:	f000 bae9 	b.w	c05e08c <fwu_bootloader_staging_area_init>
        LOG_MSG("TFM FWU: invalid slot_id: %d", slot_id);
 c05daba:	4803      	ldr	r0, [pc, #12]	@ (c05dac8 <tfm_internal_fwu_initialize+0x24>)
 c05dabc:	f7de ff18 	bl	c03c8f0 <tfm_log_printf>
}
 c05dac0:	f06f 0086 	mvn.w	r0, #134	@ 0x86
 c05dac4:	bd08      	pop	{r3, pc}
 c05dac6:	bf00      	nop
 c05dac8:	0c061f5f 	.word	0x0c061f5f

0c05dacc <tfm_internal_fwu_write>:

psa_status_t tfm_internal_fwu_write(psa_image_id_t image_id,
                           size_t block_offset,
                           const void *block,
                           size_t block_size)
{
 c05dacc:	b410      	push	{r4}
 c05dace:	4604      	mov	r4, r0
    uint8_t image_type = (uint8_t)FWU_IMAGE_ID_GET_TYPE(image_id);
 c05dad0:	f3c0 2007 	ubfx	r0, r0, #8, #8
    uint8_t slot_id = (uint8_t)FWU_IMAGE_ID_GET_SLOT(image_id);
 c05dad4:	b2e4      	uxtb	r4, r4

    if ((block == NULL) || (slot_id != FWU_IMAGE_ID_SLOT_STAGE)) {
 c05dad6:	b122      	cbz	r2, c05dae2 <tfm_internal_fwu_write+0x16>
 c05dad8:	2c02      	cmp	r4, #2
 c05dada:	d102      	bne.n	c05dae2 <tfm_internal_fwu_write+0x16>

    return fwu_bootloader_load_image(image_type,
                                     block_offset,
                                     block,
                                     block_size);
}
 c05dadc:	bc10      	pop	{r4}
    return fwu_bootloader_load_image(image_type,
 c05dade:	f000 bb25 	b.w	c05e12c <fwu_bootloader_load_image>
}
 c05dae2:	f06f 0086 	mvn.w	r0, #134	@ 0x86
 c05dae6:	bc10      	pop	{r4}
 c05dae8:	4770      	bx	lr
	...

0c05daec <tfm_internal_fwu_install>:

psa_status_t tfm_internal_fwu_install(psa_image_id_t image_id,
                                      psa_image_id_t *dependency,
                                      psa_image_version_t *dependency_version)
{
 c05daec:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
 c05daee:	4603      	mov	r3, r0
 c05daf0:	460d      	mov	r5, r1
    bl_image_id_t dependency_bl;
    psa_image_version_t version;
    psa_status_t result;

    /* Check the image slot, the target should be the staging slot. */
    if (slot_id != FWU_IMAGE_ID_SLOT_STAGE) {
 c05daf2:	b2d9      	uxtb	r1, r3
 c05daf4:	2902      	cmp	r1, #2
{
 c05daf6:	4614      	mov	r4, r2
    uint8_t image_type = (uint8_t)FWU_IMAGE_ID_GET_TYPE(image_id);
 c05daf8:	f3c0 2007 	ubfx	r0, r0, #8, #8
    if (slot_id != FWU_IMAGE_ID_SLOT_STAGE) {
 c05dafc:	d007      	beq.n	c05db0e <tfm_internal_fwu_install+0x22>
        LOG_MSG("TFM FWU: invalid slot_id: %d", slot_id);
 c05dafe:	4810      	ldr	r0, [pc, #64]	@ (c05db40 <tfm_internal_fwu_install+0x54>)
 c05db00:	f7de fef6 	bl	c03c8f0 <tfm_log_printf>
        return PSA_ERROR_INVALID_ARGUMENT;
 c05db04:	f06f 0386 	mvn.w	r3, #134	@ 0x86
                                                             0);
        *dependency_version = version;
    }

    return result;
}
 c05db08:	4618      	mov	r0, r3
 c05db0a:	b004      	add	sp, #16
 c05db0c:	bd70      	pop	{r4, r5, r6, pc}
    result = fwu_bootloader_install_image(image_type,
 c05db0e:	ae02      	add	r6, sp, #8
 c05db10:	4632      	mov	r2, r6
 c05db12:	f10d 0107 	add.w	r1, sp, #7
 c05db16:	f000 fb41 	bl	c05e19c <fwu_bootloader_install_image>
    if (result == PSA_ERROR_DEPENDENCY_NEEDED) {
 c05db1a:	f110 0f9c 	cmn.w	r0, #156	@ 0x9c
    result = fwu_bootloader_install_image(image_type,
 c05db1e:	4603      	mov	r3, r0
    if (result == PSA_ERROR_DEPENDENCY_NEEDED) {
 c05db20:	d1f2      	bne.n	c05db08 <tfm_internal_fwu_install+0x1c>
        if (dependency == NULL || dependency_version == NULL) {
 c05db22:	2d00      	cmp	r5, #0
 c05db24:	d0ee      	beq.n	c05db04 <tfm_internal_fwu_install+0x18>
 c05db26:	2c00      	cmp	r4, #0
 c05db28:	d0ec      	beq.n	c05db04 <tfm_internal_fwu_install+0x18>
        *dependency = (psa_image_id_t)FWU_CALCULATE_IMAGE_ID(FWU_IMAGE_ID_SLOT_STAGE,
 c05db2a:	f89d 0007 	ldrb.w	r0, [sp, #7]
 c05db2e:	0200      	lsls	r0, r0, #8
 c05db30:	f040 0002 	orr.w	r0, r0, #2
 c05db34:	6028      	str	r0, [r5, #0]
        *dependency_version = version;
 c05db36:	e896 0003 	ldmia.w	r6, {r0, r1}
 c05db3a:	e884 0003 	stmia.w	r4, {r0, r1}
 c05db3e:	e7e3      	b.n	c05db08 <tfm_internal_fwu_install+0x1c>
 c05db40:	0c061f5f 	.word	0x0c061f5f

0c05db44 <tfm_internal_fwu_abort>:

psa_status_t tfm_internal_fwu_abort(psa_image_id_t image_id)
{
 c05db44:	4603      	mov	r3, r0
    uint8_t image_type = (uint8_t)FWU_IMAGE_ID_GET_TYPE(image_id);
    uint8_t slot_id = (uint8_t)FWU_IMAGE_ID_GET_SLOT(image_id);

    if (slot_id != FWU_IMAGE_ID_SLOT_STAGE) {
 c05db46:	b2db      	uxtb	r3, r3
 c05db48:	2b02      	cmp	r3, #2
    uint8_t image_type = (uint8_t)FWU_IMAGE_ID_GET_TYPE(image_id);
 c05db4a:	f3c0 2007 	ubfx	r0, r0, #8, #8
    if (slot_id != FWU_IMAGE_ID_SLOT_STAGE) {
 c05db4e:	d101      	bne.n	c05db54 <tfm_internal_fwu_abort+0x10>
        return PSA_ERROR_INVALID_ARGUMENT;
    }

    return fwu_bootloader_abort(image_type);
 c05db50:	f000 bb56 	b.w	c05e200 <fwu_bootloader_abort>
}
 c05db54:	f06f 0086 	mvn.w	r0, #134	@ 0x86
 c05db58:	4770      	bx	lr
	...

0c05db5c <tfm_internal_fwu_query>:

/* The image version of the given image. */
psa_status_t tfm_internal_fwu_query(psa_image_id_t image_id,
                           psa_image_info_t *info)
{
 c05db5c:	b508      	push	{r3, lr}
 c05db5e:	4603      	mov	r3, r0
 c05db60:	460a      	mov	r2, r1
    uint8_t image_type = (uint8_t)FWU_IMAGE_ID_GET_TYPE(image_id);
    uint8_t slot_id = (uint8_t)FWU_IMAGE_ID_GET_SLOT(image_id);
 c05db62:	b2d9      	uxtb	r1, r3
    bool active_image = 0;

    if (slot_id == FWU_IMAGE_ID_SLOT_STAGE) {
 c05db64:	2902      	cmp	r1, #2
    uint8_t image_type = (uint8_t)FWU_IMAGE_ID_GET_TYPE(image_id);
 c05db66:	f3c0 2007 	ubfx	r0, r0, #8, #8
    if (slot_id == FWU_IMAGE_ID_SLOT_STAGE) {
 c05db6a:	d007      	beq.n	c05db7c <tfm_internal_fwu_query+0x20>
        active_image = false;
    } else if (slot_id == FWU_IMAGE_ID_SLOT_ACTIVE) {
 c05db6c:	2901      	cmp	r1, #1
 c05db6e:	d006      	beq.n	c05db7e <tfm_internal_fwu_query+0x22>
        active_image = true;
    } else {
        LOG_MSG("TFM FWU: invalid slot_id: %d", slot_id);
 c05db70:	4805      	ldr	r0, [pc, #20]	@ (c05db88 <tfm_internal_fwu_query+0x2c>)
 c05db72:	f7de febd 	bl	c03c8f0 <tfm_log_printf>
        return PSA_ERROR_INVALID_ARGUMENT;
    }

    return fwu_bootloader_get_image_info(image_type, active_image, info);
}
 c05db76:	f06f 0086 	mvn.w	r0, #134	@ 0x86
 c05db7a:	bd08      	pop	{r3, pc}
        active_image = false;
 c05db7c:	2100      	movs	r1, #0
}
 c05db7e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    return fwu_bootloader_get_image_info(image_type, active_image, info);
 c05db82:	f000 bb6d 	b.w	c05e260 <fwu_bootloader_get_image_info>
 c05db86:	bf00      	nop
 c05db88:	0c061f5f 	.word	0x0c061f5f

0c05db8c <tfm_internal_fwu_request_reboot>:

void tfm_internal_fwu_request_reboot(void)
{
    tfm_platform_system_reset();
 c05db8c:	f7de bdf3 	b.w	c03c776 <tfm_platform_system_reset>

0c05db90 <tfm_internal_fwu_accept>:
}

psa_status_t tfm_internal_fwu_accept(void)
{
    return fwu_bootloader_mark_image_accepted();
 c05db90:	f000 bb2e 	b.w	c05e1f0 <fwu_bootloader_mark_image_accepted>

0c05db94 <tfm_fwu_accept_ipc>:
static psa_status_t tfm_fwu_accept_ipc(void)
{
    /* This operation set the running image to INSTALLED state, the images
     * in the staging area does not impact this operation.
     */
    return tfm_internal_fwu_accept();
 c05db94:	f7ff bffc 	b.w	c05db90 <tfm_internal_fwu_accept>

0c05db98 <tfm_fwu_request_reboot_ipc>:
{
 c05db98:	b508      	push	{r3, lr}
    tfm_internal_fwu_request_reboot();
 c05db9a:	f7ff fff7 	bl	c05db8c <tfm_internal_fwu_request_reboot>
}
 c05db9e:	2000      	movs	r0, #0
 c05dba0:	bd08      	pop	{r3, pc}
	...

0c05dba4 <get_image_index.part.0>:
        if (fwu_ctx[i].in_use && (fwu_ctx[i].image_id == image_id)) {
 c05dba4:	4a09      	ldr	r2, [pc, #36]	@ (c05dbcc <get_image_index.part.0+0x28>)
static bool get_image_index(psa_image_id_t image_id, uint8_t *index)
 c05dba6:	4603      	mov	r3, r0
        if (fwu_ctx[i].in_use && (fwu_ctx[i].image_id == image_id)) {
 c05dba8:	7950      	ldrb	r0, [r2, #5]
 c05dbaa:	b110      	cbz	r0, c05dbb2 <get_image_index.part.0+0xe>
 c05dbac:	6810      	ldr	r0, [r2, #0]
 c05dbae:	4283      	cmp	r3, r0
 c05dbb0:	d008      	beq.n	c05dbc4 <get_image_index.part.0+0x20>
 c05dbb2:	7b50      	ldrb	r0, [r2, #13]
 c05dbb4:	b148      	cbz	r0, c05dbca <get_image_index.part.0+0x26>
 c05dbb6:	6892      	ldr	r2, [r2, #8]
 c05dbb8:	4293      	cmp	r3, r2
 c05dbba:	d105      	bne.n	c05dbc8 <get_image_index.part.0+0x24>
    for (uint8_t i = 0; i < TFM_FWU_MAX_IMAGES; i++) {
 c05dbbc:	2301      	movs	r3, #1
            return true;
 c05dbbe:	2001      	movs	r0, #1
            *index = i;
 c05dbc0:	700b      	strb	r3, [r1, #0]
            return true;
 c05dbc2:	4770      	bx	lr
    for (uint8_t i = 0; i < TFM_FWU_MAX_IMAGES; i++) {
 c05dbc4:	2300      	movs	r3, #0
 c05dbc6:	e7fa      	b.n	c05dbbe <get_image_index.part.0+0x1a>
        return false;
 c05dbc8:	2000      	movs	r0, #0
}
 c05dbca:	4770      	bx	lr
 c05dbcc:	30038920 	.word	0x30038920

0c05dbd0 <tfm_fwu_query_ipc>:
{
 c05dbd0:	b530      	push	{r4, r5, lr}
    if (msg.in_size[0] != sizeof(image_id)) {
 c05dbd2:	4d18      	ldr	r5, [pc, #96]	@ (c05dc34 <tfm_fwu_query_ipc+0x64>)
{
 c05dbd4:	b08f      	sub	sp, #60	@ 0x3c
    if (msg.in_size[0] != sizeof(image_id)) {
 c05dbd6:	692b      	ldr	r3, [r5, #16]
 c05dbd8:	2b04      	cmp	r3, #4
 c05dbda:	d004      	beq.n	c05dbe6 <tfm_fwu_query_ipc+0x16>
        return PSA_ERROR_PROGRAMMER_ERROR;
 c05dbdc:	f06f 0480 	mvn.w	r4, #128	@ 0x80
}
 c05dbe0:	4620      	mov	r0, r4
 c05dbe2:	b00f      	add	sp, #60	@ 0x3c
 c05dbe4:	bd30      	pop	{r4, r5, pc}
    num = psa_read(msg.handle, 0, &image_id, sizeof(image_id));
 c05dbe6:	2100      	movs	r1, #0
 c05dbe8:	6868      	ldr	r0, [r5, #4]
 c05dbea:	aa02      	add	r2, sp, #8
 c05dbec:	f7de fe10 	bl	c03c810 <psa_read>
    if (num != sizeof(image_id)) {
 c05dbf0:	2804      	cmp	r0, #4
 c05dbf2:	d1f3      	bne.n	c05dbdc <tfm_fwu_query_ipc+0xc>
    result = tfm_internal_fwu_query(image_id, &info);
 c05dbf4:	9802      	ldr	r0, [sp, #8]
 c05dbf6:	a903      	add	r1, sp, #12
 c05dbf8:	f7ff ffb0 	bl	c05db5c <tfm_internal_fwu_query>
    if (result == PSA_SUCCESS) {
 c05dbfc:	4604      	mov	r4, r0
 c05dbfe:	2800      	cmp	r0, #0
 c05dc00:	d1ee      	bne.n	c05dbe0 <tfm_fwu_query_ipc+0x10>
        if (info.state == PSA_IMAGE_UNDEFINED) {
 c05dc02:	f89d 3014 	ldrb.w	r3, [sp, #20]
 c05dc06:	b96b      	cbnz	r3, c05dc24 <tfm_fwu_query_ipc+0x54>
    if (!index) {
 c05dc08:	9802      	ldr	r0, [sp, #8]
 c05dc0a:	f10d 0107 	add.w	r1, sp, #7
 c05dc0e:	f7ff ffc9 	bl	c05dba4 <get_image_index.part.0>
            if (get_image_index(image_id, &image_index)) {
 c05dc12:	b138      	cbz	r0, c05dc24 <tfm_fwu_query_ipc+0x54>
                info.state = fwu_ctx[image_index].image_state;
 c05dc14:	f89d 2007 	ldrb.w	r2, [sp, #7]
 c05dc18:	4b07      	ldr	r3, [pc, #28]	@ (c05dc38 <tfm_fwu_query_ipc+0x68>)
 c05dc1a:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 c05dc1e:	791b      	ldrb	r3, [r3, #4]
 c05dc20:	f88d 3014 	strb.w	r3, [sp, #20]
        psa_write(msg.handle, 0, &info, sizeof(info));
 c05dc24:	232c      	movs	r3, #44	@ 0x2c
 c05dc26:	2100      	movs	r1, #0
 c05dc28:	6868      	ldr	r0, [r5, #4]
 c05dc2a:	aa03      	add	r2, sp, #12
 c05dc2c:	f7de fdf2 	bl	c03c814 <psa_write>
 c05dc30:	e7d6      	b.n	c05dbe0 <tfm_fwu_query_ipc+0x10>
 c05dc32:	bf00      	nop
 c05dc34:	300388f0 	.word	0x300388f0
 c05dc38:	30038920 	.word	0x30038920

0c05dc3c <tfm_fwu_abort_ipc>:
}

static psa_status_t tfm_fwu_abort_ipc(void)
{
 c05dc3c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    psa_image_id_t image_id;
    size_t num;
    uint8_t image_index;
    psa_status_t status;

    if (msg.in_size[0] != sizeof(image_id)) {
 c05dc3e:	4818      	ldr	r0, [pc, #96]	@ (c05dca0 <tfm_fwu_abort_ipc+0x64>)
 c05dc40:	6903      	ldr	r3, [r0, #16]
 c05dc42:	2b04      	cmp	r3, #4
 c05dc44:	d003      	beq.n	c05dc4e <tfm_fwu_abort_ipc+0x12>
        return PSA_ERROR_PROGRAMMER_ERROR;
 c05dc46:	f06f 0080 	mvn.w	r0, #128	@ 0x80
        }
    } else {
        /* No image with the provided image_id is not in FWU process. */
        return PSA_ERROR_INVALID_ARGUMENT;
    }
}
 c05dc4a:	b003      	add	sp, #12
 c05dc4c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    num = psa_read(msg.handle, 0, &image_id, sizeof(image_id));
 c05dc4e:	2100      	movs	r1, #0
 c05dc50:	6840      	ldr	r0, [r0, #4]
 c05dc52:	aa01      	add	r2, sp, #4
 c05dc54:	f7de fddc 	bl	c03c810 <psa_read>
    if (num != sizeof(image_id)) {
 c05dc58:	2804      	cmp	r0, #4
 c05dc5a:	d1f4      	bne.n	c05dc46 <tfm_fwu_abort_ipc+0xa>
    if (get_image_index(image_id, &image_index)) {
 c05dc5c:	9e01      	ldr	r6, [sp, #4]
    if (!index) {
 c05dc5e:	f10d 0103 	add.w	r1, sp, #3
 c05dc62:	4630      	mov	r0, r6
 c05dc64:	f7ff ff9e 	bl	c05dba4 <get_image_index.part.0>
    if (get_image_index(image_id, &image_index)) {
 c05dc68:	b1b0      	cbz	r0, c05dc98 <tfm_fwu_abort_ipc+0x5c>
        if ((fwu_ctx[image_index].image_state == PSA_IMAGE_CANDIDATE) ||
 c05dc6a:	f89d 5003 	ldrb.w	r5, [sp, #3]
 c05dc6e:	4c0d      	ldr	r4, [pc, #52]	@ (c05dca4 <tfm_fwu_abort_ipc+0x68>)
 c05dc70:	00ef      	lsls	r7, r5, #3
 c05dc72:	eb04 03c5 	add.w	r3, r4, r5, lsl #3
 c05dc76:	791b      	ldrb	r3, [r3, #4]
 c05dc78:	f003 02fd 	and.w	r2, r3, #253	@ 0xfd
 c05dc7c:	2a01      	cmp	r2, #1
 c05dc7e:	d001      	beq.n	c05dc84 <tfm_fwu_abort_ipc+0x48>
 c05dc80:	2b05      	cmp	r3, #5
 c05dc82:	d1e0      	bne.n	c05dc46 <tfm_fwu_abort_ipc+0xa>
            status = tfm_internal_fwu_abort(image_id);
 c05dc84:	4630      	mov	r0, r6
 c05dc86:	f7ff ff5d 	bl	c05db44 <tfm_internal_fwu_abort>
            if (status != PSA_SUCCESS) {
 c05dc8a:	2800      	cmp	r0, #0
 c05dc8c:	d1dd      	bne.n	c05dc4a <tfm_fwu_abort_ipc+0xe>
            fwu_ctx[image_index].image_id = TFM_FWU_INVALID_IMAGE_ID;
 c05dc8e:	f844 0035 	str.w	r0, [r4, r5, lsl #3]
            fwu_ctx[image_index].image_state = PSA_IMAGE_UNDEFINED;
 c05dc92:	443c      	add	r4, r7
 c05dc94:	80a0      	strh	r0, [r4, #4]
            return PSA_SUCCESS;
 c05dc96:	e7d8      	b.n	c05dc4a <tfm_fwu_abort_ipc+0xe>
        return PSA_ERROR_INVALID_ARGUMENT;
 c05dc98:	f06f 0086 	mvn.w	r0, #134	@ 0x86
 c05dc9c:	e7d5      	b.n	c05dc4a <tfm_fwu_abort_ipc+0xe>
 c05dc9e:	bf00      	nop
 c05dca0:	300388f0 	.word	0x300388f0
 c05dca4:	30038920 	.word	0x30038920

0c05dca8 <tfm_fwu_install_ipc>:
{
 c05dca8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    if (msg.in_size[0] != sizeof(image_id) ||
 c05dcac:	4e27      	ldr	r6, [pc, #156]	@ (c05dd4c <tfm_fwu_install_ipc+0xa4>)
{
 c05dcae:	b087      	sub	sp, #28
    if (msg.in_size[0] != sizeof(image_id) ||
 c05dcb0:	6933      	ldr	r3, [r6, #16]
 c05dcb2:	2b04      	cmp	r3, #4
 c05dcb4:	d005      	beq.n	c05dcc2 <tfm_fwu_install_ipc+0x1a>
        return PSA_ERROR_PROGRAMMER_ERROR;
 c05dcb6:	f06f 0480 	mvn.w	r4, #128	@ 0x80
}
 c05dcba:	4620      	mov	r0, r4
 c05dcbc:	b007      	add	sp, #28
 c05dcbe:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    if (msg.in_size[0] != sizeof(image_id) ||
 c05dcc2:	6a33      	ldr	r3, [r6, #32]
 c05dcc4:	2b04      	cmp	r3, #4
 c05dcc6:	d1f6      	bne.n	c05dcb6 <tfm_fwu_install_ipc+0xe>
        msg.out_size[0] != sizeof(dependency_id) ||
 c05dcc8:	f8d6 9024 	ldr.w	r9, [r6, #36]	@ 0x24
 c05dccc:	f1b9 0f08 	cmp.w	r9, #8
 c05dcd0:	d1f1      	bne.n	c05dcb6 <tfm_fwu_install_ipc+0xe>
    num = psa_read(msg.handle, 0, &image_id, sizeof(image_id));
 c05dcd2:	2100      	movs	r1, #0
 c05dcd4:	6870      	ldr	r0, [r6, #4]
 c05dcd6:	aa02      	add	r2, sp, #8
 c05dcd8:	f7de fd9a 	bl	c03c810 <psa_read>
    if (num != sizeof(image_id)) {
 c05dcdc:	2804      	cmp	r0, #4
    num = psa_read(msg.handle, 0, &image_id, sizeof(image_id));
 c05dcde:	4607      	mov	r7, r0
    if (num != sizeof(image_id)) {
 c05dce0:	d1e9      	bne.n	c05dcb6 <tfm_fwu_install_ipc+0xe>
    if ((!get_image_index(image_id, &image_index)) ||
 c05dce2:	9c02      	ldr	r4, [sp, #8]
    if (!index) {
 c05dce4:	f10d 0107 	add.w	r1, sp, #7
 c05dce8:	4620      	mov	r0, r4
 c05dcea:	f7ff ff5b 	bl	c05dba4 <get_image_index.part.0>
    if ((!get_image_index(image_id, &image_index)) ||
 c05dcee:	b348      	cbz	r0, c05dd44 <tfm_fwu_install_ipc+0x9c>
       (fwu_ctx[image_index].image_state != PSA_IMAGE_CANDIDATE)) {
 c05dcf0:	f89d 3007 	ldrb.w	r3, [sp, #7]
 c05dcf4:	4d16      	ldr	r5, [pc, #88]	@ (c05dd50 <tfm_fwu_install_ipc+0xa8>)
 c05dcf6:	eb05 05c3 	add.w	r5, r5, r3, lsl #3
    if ((!get_image_index(image_id, &image_index)) ||
 c05dcfa:	f895 8004 	ldrb.w	r8, [r5, #4]
 c05dcfe:	f1b8 0f01 	cmp.w	r8, #1
 c05dd02:	d11f      	bne.n	c05dd44 <tfm_fwu_install_ipc+0x9c>
        status = tfm_internal_fwu_install(image_id,
 c05dd04:	4620      	mov	r0, r4
 c05dd06:	aa04      	add	r2, sp, #16
 c05dd08:	a903      	add	r1, sp, #12
 c05dd0a:	f7ff feef 	bl	c05daec <tfm_internal_fwu_install>
        if (status == PSA_SUCCESS) {
 c05dd0e:	4604      	mov	r4, r0
 c05dd10:	b910      	cbnz	r0, c05dd18 <tfm_fwu_install_ipc+0x70>
            fwu_ctx[image_index].image_state = PSA_IMAGE_INSTALLED;
 c05dd12:	2302      	movs	r3, #2
 c05dd14:	80ab      	strh	r3, [r5, #4]
 c05dd16:	e7d0      	b.n	c05dcba <tfm_fwu_install_ipc+0x12>
        } else if (status == PSA_SUCCESS_REBOOT) {
 c05dd18:	2801      	cmp	r0, #1
 c05dd1a:	d102      	bne.n	c05dd22 <tfm_fwu_install_ipc+0x7a>
            fwu_ctx[image_index].image_state = PSA_IMAGE_REBOOT_NEEDED;
 c05dd1c:	2305      	movs	r3, #5
            fwu_ctx[image_index].image_state = PSA_IMAGE_REJECTED;
 c05dd1e:	712b      	strb	r3, [r5, #4]
 c05dd20:	e7cb      	b.n	c05dcba <tfm_fwu_install_ipc+0x12>
        } else if (status == PSA_ERROR_DEPENDENCY_NEEDED) {
 c05dd22:	f110 0f9c 	cmn.w	r0, #156	@ 0x9c
 c05dd26:	d10b      	bne.n	c05dd40 <tfm_fwu_install_ipc+0x98>
            psa_write(msg.handle, 0, &dependency_id, sizeof(dependency_id));
 c05dd28:	463b      	mov	r3, r7
 c05dd2a:	2100      	movs	r1, #0
 c05dd2c:	6870      	ldr	r0, [r6, #4]
 c05dd2e:	aa03      	add	r2, sp, #12
 c05dd30:	f7de fd70 	bl	c03c814 <psa_write>
            psa_write(msg.handle, 1, &dependency_version,
 c05dd34:	464b      	mov	r3, r9
 c05dd36:	4641      	mov	r1, r8
 c05dd38:	6870      	ldr	r0, [r6, #4]
 c05dd3a:	aa04      	add	r2, sp, #16
 c05dd3c:	f7de fd6a 	bl	c03c814 <psa_write>
            fwu_ctx[image_index].image_state = PSA_IMAGE_REJECTED;
 c05dd40:	2303      	movs	r3, #3
 c05dd42:	e7ec      	b.n	c05dd1e <tfm_fwu_install_ipc+0x76>
        return PSA_ERROR_INVALID_ARGUMENT;
 c05dd44:	f06f 0486 	mvn.w	r4, #134	@ 0x86
 c05dd48:	e7b7      	b.n	c05dcba <tfm_fwu_install_ipc+0x12>
 c05dd4a:	bf00      	nop
 c05dd4c:	300388f0 	.word	0x300388f0
 c05dd50:	30038920 	.word	0x30038920

0c05dd54 <tfm_fwu_write_ipc>:
{
 c05dd54:	b5f0      	push	{r4, r5, r6, r7, lr}
    if (msg.in_size[2] > sizeof(data_block)) {
 c05dd56:	4c33      	ldr	r4, [pc, #204]	@ (c05de24 <tfm_fwu_write_ipc+0xd0>)
{
 c05dd58:	f2ad 4d14 	subw	sp, sp, #1044	@ 0x414
    if (msg.in_size[2] > sizeof(data_block)) {
 c05dd5c:	69a3      	ldr	r3, [r4, #24]
 c05dd5e:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 c05dd62:	d855      	bhi.n	c05de10 <tfm_fwu_write_ipc+0xbc>
    if (msg.in_size[0] != sizeof(image_id) ||
 c05dd64:	6923      	ldr	r3, [r4, #16]
 c05dd66:	2b04      	cmp	r3, #4
 c05dd68:	d004      	beq.n	c05dd74 <tfm_fwu_write_ipc+0x20>
        return PSA_ERROR_PROGRAMMER_ERROR;
 c05dd6a:	f06f 0080 	mvn.w	r0, #128	@ 0x80
}
 c05dd6e:	f20d 4d14 	addw	sp, sp, #1044	@ 0x414
 c05dd72:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if (msg.in_size[0] != sizeof(image_id) ||
 c05dd74:	6963      	ldr	r3, [r4, #20]
 c05dd76:	2b04      	cmp	r3, #4
 c05dd78:	d1f7      	bne.n	c05dd6a <tfm_fwu_write_ipc+0x16>
    num = psa_read(msg.handle, 0, &image_id, sizeof(image_id));
 c05dd7a:	2100      	movs	r1, #0
 c05dd7c:	6860      	ldr	r0, [r4, #4]
 c05dd7e:	aa02      	add	r2, sp, #8
 c05dd80:	f7de fd46 	bl	c03c810 <psa_read>
    if (num != sizeof(image_id)) {
 c05dd84:	2804      	cmp	r0, #4
    num = psa_read(msg.handle, 0, &image_id, sizeof(image_id));
 c05dd86:	4603      	mov	r3, r0
    if (num != sizeof(image_id)) {
 c05dd88:	d1ef      	bne.n	c05dd6a <tfm_fwu_write_ipc+0x16>
    num = psa_read(msg.handle, 1, &block_offset, sizeof(block_offset));
 c05dd8a:	2101      	movs	r1, #1
 c05dd8c:	6860      	ldr	r0, [r4, #4]
 c05dd8e:	aa03      	add	r2, sp, #12
 c05dd90:	f7de fd3e 	bl	c03c810 <psa_read>
    if (num != sizeof(block_offset)) {
 c05dd94:	2804      	cmp	r0, #4
 c05dd96:	d1e8      	bne.n	c05dd6a <tfm_fwu_write_ipc+0x16>
    return (memset(ptr, value, num));
 c05dd98:	f44f 6280 	mov.w	r2, #1024	@ 0x400
 c05dd9c:	2100      	movs	r1, #0
 c05dd9e:	a804      	add	r0, sp, #16
 c05dda0:	f7fd fcc5 	bl	c05b72e <memset>
    data_length = msg.in_size[2];
 c05dda4:	69a6      	ldr	r6, [r4, #24]
    num = psa_read(msg.handle, 2, data_block, data_length);
 c05dda6:	2102      	movs	r1, #2
 c05dda8:	4633      	mov	r3, r6
 c05ddaa:	6860      	ldr	r0, [r4, #4]
 c05ddac:	aa04      	add	r2, sp, #16
 c05ddae:	f7de fd2f 	bl	c03c810 <psa_read>
    if (num != data_length) {
 c05ddb2:	4286      	cmp	r6, r0
 c05ddb4:	d1d9      	bne.n	c05dd6a <tfm_fwu_write_ipc+0x16>
    if (get_image_index(image_id, &image_index)) {
 c05ddb6:	9f02      	ldr	r7, [sp, #8]
    if (!index) {
 c05ddb8:	f10d 0107 	add.w	r1, sp, #7
 c05ddbc:	4638      	mov	r0, r7
 c05ddbe:	f7ff fef1 	bl	c05dba4 <get_image_index.part.0>
 c05ddc2:	4c19      	ldr	r4, [pc, #100]	@ (c05de28 <tfm_fwu_write_ipc+0xd4>)
    if (get_image_index(image_id, &image_index)) {
 c05ddc4:	b9a0      	cbnz	r0, c05ddf0 <tfm_fwu_write_ipc+0x9c>
        if (!fwu_ctx[i].in_use) {
 c05ddc6:	7965      	ldrb	r5, [r4, #5]
 c05ddc8:	b115      	cbz	r5, c05ddd0 <tfm_fwu_write_ipc+0x7c>
 c05ddca:	7b63      	ldrb	r3, [r4, #13]
 c05ddcc:	bb1b      	cbnz	r3, c05de16 <tfm_fwu_write_ipc+0xc2>
    for (uint8_t i = 0; i < TFM_FWU_MAX_IMAGES; i++) {
 c05ddce:	2501      	movs	r5, #1
            status = tfm_internal_fwu_initialize(image_id);
 c05ddd0:	4638      	mov	r0, r7
            *index = i;
 c05ddd2:	f88d 5007 	strb.w	r5, [sp, #7]
            status = tfm_internal_fwu_initialize(image_id);
 c05ddd6:	f7ff fe65 	bl	c05daa4 <tfm_internal_fwu_initialize>
            if (status != PSA_SUCCESS) {
 c05ddda:	2800      	cmp	r0, #0
 c05dddc:	d1c7      	bne.n	c05dd6e <tfm_fwu_write_ipc+0x1a>
            fwu_ctx[image_index].image_id = image_id;
 c05ddde:	9b02      	ldr	r3, [sp, #8]
 c05dde0:	f844 3035 	str.w	r3, [r4, r5, lsl #3]
            fwu_ctx[image_index].image_state = PSA_IMAGE_CANDIDATE;
 c05dde4:	f240 1301 	movw	r3, #257	@ 0x101
 c05dde8:	eb04 04c5 	add.w	r4, r4, r5, lsl #3
 c05ddec:	80a3      	strh	r3, [r4, #4]
 c05ddee:	e008      	b.n	c05de02 <tfm_fwu_write_ipc+0xae>
        if ((fwu_ctx[image_index].image_state != PSA_IMAGE_CANDIDATE) &&
 c05ddf0:	f89d 3007 	ldrb.w	r3, [sp, #7]
 c05ddf4:	eb04 04c3 	add.w	r4, r4, r3, lsl #3
 c05ddf8:	7923      	ldrb	r3, [r4, #4]
 c05ddfa:	f003 03fd 	and.w	r3, r3, #253	@ 0xfd
 c05ddfe:	2b01      	cmp	r3, #1
 c05de00:	d10c      	bne.n	c05de1c <tfm_fwu_write_ipc+0xc8>
    return tfm_internal_fwu_write(image_id,
 c05de02:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 c05de06:	4633      	mov	r3, r6
 c05de08:	aa04      	add	r2, sp, #16
 c05de0a:	f7ff fe5f 	bl	c05dacc <tfm_internal_fwu_write>
 c05de0e:	e7ae      	b.n	c05dd6e <tfm_fwu_write_ipc+0x1a>
        return PSA_ERROR_INVALID_ARGUMENT;
 c05de10:	f06f 0086 	mvn.w	r0, #134	@ 0x86
 c05de14:	e7ab      	b.n	c05dd6e <tfm_fwu_write_ipc+0x1a>
            return PSA_ERROR_INSUFFICIENT_MEMORY;
 c05de16:	f06f 008c 	mvn.w	r0, #140	@ 0x8c
 c05de1a:	e7a8      	b.n	c05dd6e <tfm_fwu_write_ipc+0x1a>
            return PSA_ERROR_CURRENTLY_INSTALLING;
 c05de1c:	f06f 009c 	mvn.w	r0, #156	@ 0x9c
 c05de20:	e7a5      	b.n	c05dd6e <tfm_fwu_write_ipc+0x1a>
 c05de22:	bf00      	nop
 c05de24:	300388f0 	.word	0x300388f0
 c05de28:	30038920 	.word	0x30038920

0c05de2c <fwu_signal_handle>:

static void fwu_signal_handle(psa_signal_t signal, fwu_func_t pfn)
{
 c05de2c:	b538      	push	{r3, r4, r5, lr}
    psa_status_t status;

    status = psa_get(signal, &msg);
 c05de2e:	4c0c      	ldr	r4, [pc, #48]	@ (c05de60 <fwu_signal_handle+0x34>)
{
 c05de30:	460d      	mov	r5, r1
    status = psa_get(signal, &msg);
 c05de32:	4621      	mov	r1, r4
 c05de34:	f7de fcea 	bl	c03c80c <psa_get>
    if (status != PSA_SUCCESS) {
 c05de38:	4601      	mov	r1, r0
 c05de3a:	b980      	cbnz	r0, c05de5e <fwu_signal_handle+0x32>
        return;
    }

    switch (msg.type) {
 c05de3c:	6823      	ldr	r3, [r4, #0]
 c05de3e:	2b00      	cmp	r3, #0
 c05de40:	da05      	bge.n	c05de4e <fwu_signal_handle+0x22>
 c05de42:	3302      	adds	r3, #2
 c05de44:	da06      	bge.n	c05de54 <fwu_signal_handle+0x28>
        psa_reply(msg.handle, PSA_SUCCESS);
        break;
    default:
        psa_panic();
    }
}
 c05de46:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
        psa_panic();
 c05de4a:	f7de bce7 	b.w	c03c81c <psa_panic>
    switch (msg.type) {
 c05de4e:	d1fa      	bne.n	c05de46 <fwu_signal_handle+0x1a>
        status = pfn();
 c05de50:	47a8      	blx	r5
 c05de52:	4601      	mov	r1, r0
        psa_reply(msg.handle, status);
 c05de54:	6860      	ldr	r0, [r4, #4]
}
 c05de56:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
        psa_reply(msg.handle, status);
 c05de5a:	f7de bcdd 	b.w	c03c818 <psa_reply>
}
 c05de5e:	bd38      	pop	{r3, r4, r5, pc}
 c05de60:	300388f0 	.word	0x300388f0

0c05de64 <tfm_fwu_init>:
#endif

psa_status_t tfm_fwu_init(void)
{
 c05de64:	b570      	push	{r4, r5, r6, lr}
#ifdef TFM_PSA_API
    psa_signal_t signals = 0;

    if (fwu_bootloader_init() != 0) {
 c05de66:	f000 f903 	bl	c05e070 <fwu_bootloader_init>
 c05de6a:	b108      	cbz	r0, c05de70 <tfm_fwu_init+0xc>
        psa_panic();
 c05de6c:	f7de fcd6 	bl	c03c81c <psa_panic>
            fwu_signal_handle(TFM_FWU_QUERY_SIGNAL, tfm_fwu_query_ipc);
        } else if (signals & TFM_FWU_REQUEST_REBOOT_SIGNAL) {
            fwu_signal_handle(TFM_FWU_REQUEST_REBOOT_SIGNAL,
                              tfm_fwu_request_reboot_ipc);
        } else if (signals & TFM_FWU_ACCEPT_SIGNAL) {
            fwu_signal_handle(TFM_FWU_ACCEPT_SIGNAL, tfm_fwu_accept_ipc);
 c05de70:	4c16      	ldr	r4, [pc, #88]	@ (c05decc <tfm_fwu_init+0x68>)
            fwu_signal_handle(TFM_FWU_REQUEST_REBOOT_SIGNAL,
 c05de72:	4d17      	ldr	r5, [pc, #92]	@ (c05ded0 <tfm_fwu_init+0x6c>)
            fwu_signal_handle(TFM_FWU_QUERY_SIGNAL, tfm_fwu_query_ipc);
 c05de74:	4e17      	ldr	r6, [pc, #92]	@ (c05ded4 <tfm_fwu_init+0x70>)
        signals = psa_wait(PSA_WAIT_ANY, PSA_BLOCK);
 c05de76:	f04f 4100 	mov.w	r1, #2147483648	@ 0x80000000
 c05de7a:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 c05de7e:	f7de fcc3 	bl	c03c808 <psa_wait>
        if (signals & TFM_FWU_WRITE_SIGNAL) {
 c05de82:	06c1      	lsls	r1, r0, #27
 c05de84:	d504      	bpl.n	c05de90 <tfm_fwu_init+0x2c>
            fwu_signal_handle(TFM_FWU_WRITE_SIGNAL, tfm_fwu_write_ipc);
 c05de86:	2010      	movs	r0, #16
 c05de88:	4913      	ldr	r1, [pc, #76]	@ (c05ded8 <tfm_fwu_init+0x74>)
            fwu_signal_handle(TFM_FWU_ACCEPT_SIGNAL, tfm_fwu_accept_ipc);
 c05de8a:	f7ff ffcf 	bl	c05de2c <fwu_signal_handle>
 c05de8e:	e7f2      	b.n	c05de76 <tfm_fwu_init+0x12>
        } else if (signals & TFM_FWU_INSTALL_SIGNAL) {
 c05de90:	0682      	lsls	r2, r0, #26
 c05de92:	d502      	bpl.n	c05de9a <tfm_fwu_init+0x36>
            fwu_signal_handle(TFM_FWU_INSTALL_SIGNAL, tfm_fwu_install_ipc);
 c05de94:	2020      	movs	r0, #32
 c05de96:	4911      	ldr	r1, [pc, #68]	@ (c05dedc <tfm_fwu_init+0x78>)
 c05de98:	e7f7      	b.n	c05de8a <tfm_fwu_init+0x26>
        } else if (signals & TFM_FWU_ABORT_SIGNAL) {
 c05de9a:	0643      	lsls	r3, r0, #25
 c05de9c:	d502      	bpl.n	c05dea4 <tfm_fwu_init+0x40>
            fwu_signal_handle(TFM_FWU_ABORT_SIGNAL, tfm_fwu_abort_ipc);
 c05de9e:	2040      	movs	r0, #64	@ 0x40
 c05dea0:	490f      	ldr	r1, [pc, #60]	@ (c05dee0 <tfm_fwu_init+0x7c>)
 c05dea2:	e7f2      	b.n	c05de8a <tfm_fwu_init+0x26>
        } else if (signals & TFM_FWU_QUERY_SIGNAL) {
 c05dea4:	0601      	lsls	r1, r0, #24
 c05dea6:	d502      	bpl.n	c05deae <tfm_fwu_init+0x4a>
            fwu_signal_handle(TFM_FWU_QUERY_SIGNAL, tfm_fwu_query_ipc);
 c05dea8:	4631      	mov	r1, r6
 c05deaa:	2080      	movs	r0, #128	@ 0x80
 c05deac:	e7ed      	b.n	c05de8a <tfm_fwu_init+0x26>
        } else if (signals & TFM_FWU_REQUEST_REBOOT_SIGNAL) {
 c05deae:	05c2      	lsls	r2, r0, #23
 c05deb0:	d503      	bpl.n	c05deba <tfm_fwu_init+0x56>
            fwu_signal_handle(TFM_FWU_REQUEST_REBOOT_SIGNAL,
 c05deb2:	4629      	mov	r1, r5
 c05deb4:	f44f 7080 	mov.w	r0, #256	@ 0x100
 c05deb8:	e7e7      	b.n	c05de8a <tfm_fwu_init+0x26>
        } else if (signals & TFM_FWU_ACCEPT_SIGNAL) {
 c05deba:	0583      	lsls	r3, r0, #22
 c05debc:	d503      	bpl.n	c05dec6 <tfm_fwu_init+0x62>
            fwu_signal_handle(TFM_FWU_ACCEPT_SIGNAL, tfm_fwu_accept_ipc);
 c05debe:	4621      	mov	r1, r4
 c05dec0:	f44f 7000 	mov.w	r0, #512	@ 0x200
 c05dec4:	e7e1      	b.n	c05de8a <tfm_fwu_init+0x26>
        } else {
            psa_panic();
 c05dec6:	f7de fca9 	bl	c03c81c <psa_panic>
 c05deca:	e7d4      	b.n	c05de76 <tfm_fwu_init+0x12>
 c05decc:	0c05db95 	.word	0x0c05db95
 c05ded0:	0c05db99 	.word	0x0c05db99
 c05ded4:	0c05dbd1 	.word	0x0c05dbd1
 c05ded8:	0c05dd55 	.word	0x0c05dd55
 c05dedc:	0c05dca9 	.word	0x0c05dca9
 c05dee0:	0c05dc3d 	.word	0x0c05dc3d

0c05dee4 <tfm_hal_memory_has_access>:
#else
enum tfm_hal_status_t tfm_hal_memory_has_access(uintptr_t base,
                                                size_t size,
                                                uint32_t attr)
#endif
{
 c05dee4:	b530      	push	{r4, r5, lr}
    int flags = 0;

    if (attr & TFM_HAL_ACCESS_NS) {
 c05dee6:	f013 0420 	ands.w	r4, r3, #32
{
 c05deea:	4605      	mov	r5, r0
 c05deec:	b08d      	sub	sp, #52	@ 0x34
 c05deee:	4608      	mov	r0, r1
 c05def0:	4611      	mov	r1, r2
    if (attr & TFM_HAL_ACCESS_NS) {
 c05def2:	d009      	beq.n	c05df08 <tfm_hal_memory_has_access+0x24>
  __ASM volatile ("MRS %0, control_ns" : "=r" (result) );
 c05def4:	f3ef 8294 	mrs	r2, CONTROL_NS
        CONTROL_Type ctrl;
        ctrl.w = __TZ_get_CONTROL_NS();
        if (ctrl.b.nPRIV == 1) {
 c05def8:	07d4      	lsls	r4, r2, #31
            attr |= TFM_HAL_ACCESS_UNPRIVILEGED;
        } else {
            attr &= ~TFM_HAL_ACCESS_UNPRIVILEGED;
        }
        flags |= CMSE_NONSECURE;
 c05defa:	f04f 0412 	mov.w	r4, #18
            attr |= TFM_HAL_ACCESS_UNPRIVILEGED;
 c05defe:	bf4c      	ite	mi
 c05df00:	f043 0308 	orrmi.w	r3, r3, #8
            attr &= ~TFM_HAL_ACCESS_UNPRIVILEGED;
 c05df04:	f023 0308 	bicpl.w	r3, r3, #8
    }

    if (attr & TFM_HAL_ACCESS_UNPRIVILEGED) {
 c05df08:	071a      	lsls	r2, r3, #28
        flags |= CMSE_MPU_UNPRIV;
    }

    if ((attr & TFM_HAL_ACCESS_READABLE) && (attr & TFM_HAL_ACCESS_WRITABLE)) {
 c05df0a:	f003 0206 	and.w	r2, r3, #6
        flags |= CMSE_MPU_UNPRIV;
 c05df0e:	bf48      	it	mi
 c05df10:	f044 0404 	orrmi.w	r4, r4, #4
    if ((attr & TFM_HAL_ACCESS_READABLE) && (attr & TFM_HAL_ACCESS_WRITABLE)) {
 c05df14:	2a06      	cmp	r2, #6
 c05df16:	d10e      	bne.n	c05df36 <tfm_hal_memory_has_access+0x52>
        flags |= CMSE_MPU_READWRITE;
 c05df18:	f044 0201 	orr.w	r2, r4, #1
#else
        return TFM_HAL_ERROR_INVALID_INPUT;
#endif
    }

    if (cmse_check_address_range((void *)base, size, flags) != NULL) {
 c05df1c:	f7e5 fa5a 	bl	c0433d4 <cmse_check_address_range>
 c05df20:	b308      	cbz	r0, c05df66 <tfm_hal_memory_has_access+0x82>
#ifdef TFM_FIH_PROFILE_ON
        FIH_RET(fih_int_encode(TFM_HAL_SUCCESS));
 c05df22:	f7fd fcef 	bl	c05b904 <fih_cfi_decrement>
    fih_int ret = {x, x ^ _FIH_MASK_VALUE};
 c05df26:	2300      	movs	r3, #0
 c05df28:	9306      	str	r3, [sp, #24]
 c05df2a:	4b17      	ldr	r3, [pc, #92]	@ (c05df88 <tfm_hal_memory_has_access+0xa4>)
 c05df2c:	9307      	str	r3, [sp, #28]
 c05df2e:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 c05df32:	ab04      	add	r3, sp, #16
 c05df34:	e00e      	b.n	c05df54 <tfm_hal_memory_has_access+0x70>
    } else if (attr & TFM_HAL_ACCESS_READABLE) {
 c05df36:	079b      	lsls	r3, r3, #30
 c05df38:	d502      	bpl.n	c05df40 <tfm_hal_memory_has_access+0x5c>
        flags |= CMSE_MPU_READ;
 c05df3a:	f044 0208 	orr.w	r2, r4, #8
 c05df3e:	e7ed      	b.n	c05df1c <tfm_hal_memory_has_access+0x38>
        FIH_RET(fih_int_encode(TFM_HAL_ERROR_INVALID_INPUT));
 c05df40:	f7fd fce0 	bl	c05b904 <fih_cfi_decrement>
 c05df44:	f24c 23da 	movw	r3, #49882	@ 0xc2da
 c05df48:	9302      	str	r3, [sp, #8]
 c05df4a:	4b10      	ldr	r3, [pc, #64]	@ (c05df8c <tfm_hal_memory_has_access+0xa8>)
 c05df4c:	9303      	str	r3, [sp, #12]
 c05df4e:	466b      	mov	r3, sp
 c05df50:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 c05df54:	e883 0003 	stmia.w	r3, {r0, r1}
    return ret;
 c05df58:	e893 0003 	ldmia.w	r3, {r0, r1}
 c05df5c:	e885 0003 	stmia.w	r5, {r0, r1}
	FIH_RET(fih_int_encode(TFM_HAL_ERROR_MEM_FAULT));
#else
	return TFM_HAL_ERROR_MEM_FAULT;
#endif
    }
}
 c05df60:	4628      	mov	r0, r5
 c05df62:	b00d      	add	sp, #52	@ 0x34
 c05df64:	bd30      	pop	{r4, r5, pc}
	FIH_RET(fih_int_encode(TFM_HAL_ERROR_MEM_FAULT));
 c05df66:	f7fd fccd 	bl	c05b904 <fih_cfi_decrement>
    fih_int ret = {x, x ^ _FIH_MASK_VALUE};
 c05df6a:	f06f 037f 	mvn.w	r3, #127	@ 0x7f
 c05df6e:	930a      	str	r3, [sp, #40]	@ 0x28
 c05df70:	f103 43b4 	add.w	r3, r3, #1509949440	@ 0x5a000000
 c05df74:	f103 133c 	add.w	r3, r3, #3932220	@ 0x3c003c
 c05df78:	f503 4326 	add.w	r3, r3, #42496	@ 0xa600
 c05df7c:	930b      	str	r3, [sp, #44]	@ 0x2c
 c05df7e:	aa0c      	add	r2, sp, #48	@ 0x30
 c05df80:	ab08      	add	r3, sp, #32
 c05df82:	e912 0003 	ldmdb	r2, {r0, r1}
 c05df86:	e7e5      	b.n	c05df54 <tfm_hal_memory_has_access+0x70>
 c05df88:	a5c35a3c 	.word	0xa5c35a3c
 c05df8c:	a5c398e6 	.word	0xa5c398e6

0c05df90 <tfm_hal_its_fs_info>:
#endif

__WEAK enum tfm_hal_status_t
tfm_hal_its_fs_info(struct tfm_hal_its_fs_info_t *fs_info)
{
    if (!fs_info) {
 c05df90:	b148      	cbz	r0, c05dfa6 <tfm_hal_its_fs_info+0x16>
        return TFM_HAL_ERROR_INVALID_INPUT;
    }

    fs_info->flash_area_addr = TFM_HAL_ITS_FLASH_AREA_ADDR;
    fs_info->flash_area_size = TFM_HAL_ITS_FLASH_AREA_SIZE;
 c05df92:	f44f 3248 	mov.w	r2, #204800	@ 0x32000
 c05df96:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
 c05df9a:	e9c0 2300 	strd	r2, r3, [r0]
    fs_info->sectors_per_block = TFM_HAL_ITS_SECTORS_PER_BLOCK;
 c05df9e:	2301      	movs	r3, #1
 c05dfa0:	7203      	strb	r3, [r0, #8]

    return TFM_HAL_SUCCESS;
 c05dfa2:	2000      	movs	r0, #0
 c05dfa4:	4770      	bx	lr
        return TFM_HAL_ERROR_INVALID_INPUT;
 c05dfa6:	f24c 20da 	movw	r0, #49882	@ 0xc2da
}
 c05dfaa:	4770      	bx	lr

0c05dfac <tfm_hal_output_spm_log>:
#include "uart_stdout.h"

int32_t tfm_hal_output_spm_log(const char *str, uint32_t len)
{
    /* Peripheral based log function call the stdio_output_string directly */
    return stdio_output_string((const unsigned char *)str, len);
 c05dfac:	f000 bb6e 	b.w	c05e68c <stdio_output_string>

0c05dfb0 <get_flash_image_index>:
 * Get the flash area of the image mcuboot_image_id.
 */
static bool get_flash_image_index(uint8_t mcuboot_image_id, uint8_t *index)
{
    for (uint8_t i = 0; i < TFM_FWU_MAX_IMAGES; i++) {
        if (mcuboot_ctx[i].mcuboot_image_id == mcuboot_image_id) {
 c05dfb0:	4b07      	ldr	r3, [pc, #28]	@ (c05dfd0 <get_flash_image_index+0x20>)
 c05dfb2:	791a      	ldrb	r2, [r3, #4]
 c05dfb4:	4282      	cmp	r2, r0
 c05dfb6:	d006      	beq.n	c05dfc6 <get_flash_image_index+0x16>
 c05dfb8:	7c1b      	ldrb	r3, [r3, #16]
 c05dfba:	4283      	cmp	r3, r0
 c05dfbc:	d105      	bne.n	c05dfca <get_flash_image_index+0x1a>
    for (uint8_t i = 0; i < TFM_FWU_MAX_IMAGES; i++) {
 c05dfbe:	2301      	movs	r3, #1
            *index = i;
            return true;
 c05dfc0:	2001      	movs	r0, #1
            *index = i;
 c05dfc2:	700b      	strb	r3, [r1, #0]
            return true;
 c05dfc4:	4770      	bx	lr
    for (uint8_t i = 0; i < TFM_FWU_MAX_IMAGES; i++) {
 c05dfc6:	2300      	movs	r3, #0
 c05dfc8:	e7fa      	b.n	c05dfc0 <get_flash_image_index+0x10>
        }
    }
    return false;
 c05dfca:	2000      	movs	r0, #0
}
 c05dfcc:	4770      	bx	lr
 c05dfce:	bf00      	nop
 c05dfd0:	300391ec 	.word	0x300391ec

0c05dfd4 <util_img_hash.constprop.0>:
    mcuboot_ctx[index].loaded_size = 0;
    return PSA_SUCCESS;
}


static psa_status_t util_img_hash(const struct flash_area *fap,
 c05dfd4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 c05dfd8:	461f      	mov	r7, r3
                                 size_t data_size,
                                 uint8_t *hash_result,
                                 size_t buf_size,
                                 size_t *hash_size)
{
    psa_hash_operation_t handle = psa_hash_operation_init();
 c05dfda:	2300      	movs	r3, #0
static psa_status_t util_img_hash(const struct flash_area *fap,
 c05dfdc:	f5ad 5d80 	sub.w	sp, sp, #4096	@ 0x1000
 c05dfe0:	b082      	sub	sp, #8
    psa_hash_operation_t handle = psa_hash_operation_init();
 c05dfe2:	ac02      	add	r4, sp, #8
 c05dfe4:	f844 3d04 	str.w	r3, [r4, #-4]!
static psa_status_t util_img_hash(const struct flash_area *fap,
 c05dfe8:	4680      	mov	r8, r0
 c05dfea:	460d      	mov	r5, r1
    uint32_t tmp_buf_sz = BOOT_TMPBUF_SZ;
    uint32_t blk_sz;
    uint32_t off;

    /* Setup the hash object for the desired hash. */
    status = psa_hash_setup(&handle, PSA_ALG_SHA_256);
 c05dfec:	4620      	mov	r0, r4
 c05dfee:	4916      	ldr	r1, [pc, #88]	@ (c05e048 <util_img_hash.constprop.0+0x74>)
static psa_status_t util_img_hash(const struct flash_area *fap,
 c05dff0:	4616      	mov	r6, r2
    status = psa_hash_setup(&handle, PSA_ALG_SHA_256);
 c05dff2:	f7de f904 	bl	c03c1fe <psa_hash_setup>
    if (status != PSA_SUCCESS) {
 c05dff6:	b940      	cbnz	r0, c05e00a <util_img_hash.constprop.0+0x36>
        return status;
    }

    for (off = 0; off < data_size; off += blk_sz) {
 c05dff8:	4681      	mov	r9, r0
 c05dffa:	454d      	cmp	r5, r9
 c05dffc:	d80a      	bhi.n	c05e014 <util_img_hash.constprop.0+0x40>
        if (status != PSA_SUCCESS) {
            return status;
        }
    }

    status = psa_hash_finish(&handle, hash_result, buf_size, hash_size);
 c05dffe:	463b      	mov	r3, r7
 c05e000:	2220      	movs	r2, #32
 c05e002:	4631      	mov	r1, r6
 c05e004:	4620      	mov	r0, r4
 c05e006:	f7de f958 	bl	c03c2ba <psa_hash_finish>

    return status;
}
 c05e00a:	f50d 5d80 	add.w	sp, sp, #4096	@ 0x1000
 c05e00e:	b002      	add	sp, #8
 c05e010:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        blk_sz = data_size - off;
 c05e014:	eba5 0a09 	sub.w	sl, r5, r9
        if (blk_sz > tmp_buf_sz) {
 c05e018:	f5ba 5f80 	cmp.w	sl, #4096	@ 0x1000
 c05e01c:	bf28      	it	cs
 c05e01e:	f44f 5a80 	movcs.w	sl, #4096	@ 0x1000
        if (flash_area_read(fap, off, tmpbuf, blk_sz)) {
 c05e022:	4649      	mov	r1, r9
 c05e024:	4653      	mov	r3, sl
 c05e026:	4640      	mov	r0, r8
 c05e028:	aa02      	add	r2, sp, #8
 c05e02a:	f7fd fd04 	bl	c05ba36 <flash_area_read>
 c05e02e:	b940      	cbnz	r0, c05e042 <util_img_hash.constprop.0+0x6e>
        status = psa_hash_update(&handle, tmpbuf, blk_sz);
 c05e030:	4652      	mov	r2, sl
 c05e032:	4620      	mov	r0, r4
 c05e034:	a902      	add	r1, sp, #8
 c05e036:	f7de f90f 	bl	c03c258 <psa_hash_update>
        if (status != PSA_SUCCESS) {
 c05e03a:	2800      	cmp	r0, #0
 c05e03c:	d1e5      	bne.n	c05e00a <util_img_hash.constprop.0+0x36>
    for (off = 0; off < data_size; off += blk_sz) {
 c05e03e:	44d1      	add	r9, sl
 c05e040:	e7db      	b.n	c05dffa <util_img_hash.constprop.0+0x26>
            return PSA_ERROR_GENERIC_ERROR;
 c05e042:	f06f 0083 	mvn.w	r0, #131	@ 0x83
 c05e046:	e7e0      	b.n	c05e00a <util_img_hash.constprop.0+0x36>
 c05e048:	02000009 	.word	0x02000009

0c05e04c <convert_id_from_bl_to_mcuboot.constprop.0>:
    if (bl_image_id == FWU_IMAGE_TYPE_SECURE) {
 c05e04c:	2802      	cmp	r0, #2
static int convert_id_from_bl_to_mcuboot(bl_image_id_t bl_image_id,
 c05e04e:	b508      	push	{r3, lr}
    if (bl_image_id == FWU_IMAGE_TYPE_SECURE) {
 c05e050:	d008      	beq.n	c05e064 <convert_id_from_bl_to_mcuboot.constprop.0+0x18>
    } else if (bl_image_id == FWU_IMAGE_TYPE_NONSECURE) {
 c05e052:	2801      	cmp	r0, #1
 c05e054:	d007      	beq.n	c05e066 <convert_id_from_bl_to_mcuboot.constprop.0+0x1a>
        LOG_MSG("TFM FWU: invalid image_type: %d", bl_image_id);
 c05e056:	4601      	mov	r1, r0
 c05e058:	4804      	ldr	r0, [pc, #16]	@ (c05e06c <convert_id_from_bl_to_mcuboot.constprop.0+0x20>)
 c05e05a:	f7de fc49 	bl	c03c8f0 <tfm_log_printf>
        return -1;
 c05e05e:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 c05e062:	e002      	b.n	c05e06a <convert_id_from_bl_to_mcuboot.constprop.0+0x1e>
 c05e064:	2000      	movs	r0, #0
        *mcuboot_image_id = 1;
 c05e066:	7008      	strb	r0, [r1, #0]
    return 0;
 c05e068:	2000      	movs	r0, #0
}
 c05e06a:	bd08      	pop	{r3, pc}
 c05e06c:	0c061f7c 	.word	0x0c061f7c

0c05e070 <fwu_bootloader_init>:
    return tfm_core_get_boot_data(TLV_MAJOR_FWU,
 c05e070:	2234      	movs	r2, #52	@ 0x34
{
 c05e072:	b508      	push	{r3, lr}
    return tfm_core_get_boot_data(TLV_MAJOR_FWU,
 c05e074:	4904      	ldr	r1, [pc, #16]	@ (c05e088 <fwu_bootloader_init+0x18>)
 c05e076:	2002      	movs	r0, #2
 c05e078:	f7de fb96 	bl	c03c7a8 <tfm_core_get_boot_data>
        return PSA_ERROR_GENERIC_ERROR;
 c05e07c:	2800      	cmp	r0, #0
}
 c05e07e:	bf18      	it	ne
 c05e080:	f06f 0083 	mvnne.w	r0, #131	@ 0x83
 c05e084:	bd08      	pop	{r3, pc}
 c05e086:	bf00      	nop
 c05e088:	300391b8 	.word	0x300391b8

0c05e08c <fwu_bootloader_staging_area_init>:
    uint8_t mcuboot_image_id = 0;
 c05e08c:	2300      	movs	r3, #0
{
 c05e08e:	b537      	push	{r0, r1, r2, r4, r5, lr}
    if (convert_id_from_bl_to_mcuboot(bootloader_image_id,
 c05e090:	f10d 0102 	add.w	r1, sp, #2
    uint8_t mcuboot_image_id = 0;
 c05e094:	f88d 3002 	strb.w	r3, [sp, #2]
    if (convert_id_from_bl_to_mcuboot(bootloader_image_id,
 c05e098:	f7ff ffd8 	bl	c05e04c <convert_id_from_bl_to_mcuboot.constprop.0>
 c05e09c:	2800      	cmp	r0, #0
 c05e09e:	d136      	bne.n	c05e10e <fwu_bootloader_staging_area_init+0x82>
    if (flash_area_open(FLASH_AREA_IMAGE_SECONDARY(mcuboot_image_id),
 c05e0a0:	f89d 4002 	ldrb.w	r4, [sp, #2]
 c05e0a4:	b184      	cbz	r4, c05e0c8 <fwu_bootloader_staging_area_init+0x3c>
 c05e0a6:	1e63      	subs	r3, r4, #1
 c05e0a8:	b2db      	uxtb	r3, r3
 c05e0aa:	2b02      	cmp	r3, #2
 c05e0ac:	d80e      	bhi.n	c05e0cc <fwu_bootloader_staging_area_init+0x40>
 c05e0ae:	4a1b      	ldr	r2, [pc, #108]	@ (c05e11c <fwu_bootloader_staging_area_init+0x90>)
 c05e0b0:	5cd0      	ldrb	r0, [r2, r3]
 c05e0b2:	a901      	add	r1, sp, #4
 c05e0b4:	f7fd fcaa 	bl	c05ba0c <flash_area_open>
 c05e0b8:	b150      	cbz	r0, c05e0d0 <fwu_bootloader_staging_area_init+0x44>
        LOG_MSG("TFM FWU: opening flash failed.\r\n");
 c05e0ba:	4819      	ldr	r0, [pc, #100]	@ (c05e120 <fwu_bootloader_staging_area_init+0x94>)
        LOG_MSG("TFM FWU: erasing flash failed.\r\n");
 c05e0bc:	f7de fc18 	bl	c03c8f0 <tfm_log_printf>
        return PSA_ERROR_GENERIC_ERROR;
 c05e0c0:	f06f 0083 	mvn.w	r0, #131	@ 0x83
}
 c05e0c4:	b003      	add	sp, #12
 c05e0c6:	bd30      	pop	{r4, r5, pc}
    if (flash_area_open(FLASH_AREA_IMAGE_SECONDARY(mcuboot_image_id),
 c05e0c8:	2003      	movs	r0, #3
 c05e0ca:	e7f2      	b.n	c05e0b2 <fwu_bootloader_staging_area_init+0x26>
 c05e0cc:	20ff      	movs	r0, #255	@ 0xff
 c05e0ce:	e7f0      	b.n	c05e0b2 <fwu_bootloader_staging_area_init+0x26>
    if (get_flash_image_index(mcuboot_image_id, &index) ||
 c05e0d0:	4620      	mov	r0, r4
 c05e0d2:	f10d 0103 	add.w	r1, sp, #3
 c05e0d6:	f7ff ff6b 	bl	c05dfb0 <get_flash_image_index>
 c05e0da:	4a12      	ldr	r2, [pc, #72]	@ (c05e124 <fwu_bootloader_staging_area_init+0x98>)
 c05e0dc:	b930      	cbnz	r0, c05e0ec <fwu_bootloader_staging_area_init+0x60>
        if (mcuboot_ctx[i].fap == NULL) {
 c05e0de:	6813      	ldr	r3, [r2, #0]
 c05e0e0:	b113      	cbz	r3, c05e0e8 <fwu_bootloader_staging_area_init+0x5c>
 c05e0e2:	68d3      	ldr	r3, [r2, #12]
 c05e0e4:	b9b3      	cbnz	r3, c05e114 <fwu_bootloader_staging_area_init+0x88>
    for (uint8_t i = 0; i < TFM_FWU_MAX_IMAGES; i++) {
 c05e0e6:	2301      	movs	r3, #1
            *index = i;
 c05e0e8:	f88d 3003 	strb.w	r3, [sp, #3]
        mcuboot_ctx[index].mcuboot_image_id = mcuboot_image_id;
 c05e0ec:	210c      	movs	r1, #12
 c05e0ee:	f89d 3003 	ldrb.w	r3, [sp, #3]
        mcuboot_ctx[index].fap = fap;
 c05e0f2:	9801      	ldr	r0, [sp, #4]
        mcuboot_ctx[index].mcuboot_image_id = mcuboot_image_id;
 c05e0f4:	434b      	muls	r3, r1
        mcuboot_ctx[index].loaded_size = 0;
 c05e0f6:	2100      	movs	r1, #0
        mcuboot_ctx[index].mcuboot_image_id = mcuboot_image_id;
 c05e0f8:	18d5      	adds	r5, r2, r3
        mcuboot_ctx[index].fap = fap;
 c05e0fa:	50d0      	str	r0, [r2, r3]
    if (flash_area_erase(fap, 0, fap->fa_size) != 0) {
 c05e0fc:	68c2      	ldr	r2, [r0, #12]
        mcuboot_ctx[index].mcuboot_image_id = mcuboot_image_id;
 c05e0fe:	712c      	strb	r4, [r5, #4]
        mcuboot_ctx[index].loaded_size = 0;
 c05e100:	60a9      	str	r1, [r5, #8]
    if (flash_area_erase(fap, 0, fap->fa_size) != 0) {
 c05e102:	f7fd fcc2 	bl	c05ba8a <flash_area_erase>
 c05e106:	2800      	cmp	r0, #0
 c05e108:	d0dc      	beq.n	c05e0c4 <fwu_bootloader_staging_area_init+0x38>
        LOG_MSG("TFM FWU: erasing flash failed.\r\n");
 c05e10a:	4807      	ldr	r0, [pc, #28]	@ (c05e128 <fwu_bootloader_staging_area_init+0x9c>)
 c05e10c:	e7d6      	b.n	c05e0bc <fwu_bootloader_staging_area_init+0x30>
        return PSA_ERROR_INVALID_ARGUMENT;
 c05e10e:	f06f 0086 	mvn.w	r0, #134	@ 0x86
 c05e112:	e7d7      	b.n	c05e0c4 <fwu_bootloader_staging_area_init+0x38>
        return PSA_ERROR_INSUFFICIENT_MEMORY;
 c05e114:	f06f 008c 	mvn.w	r0, #140	@ 0x8c
 c05e118:	e7d4      	b.n	c05e0c4 <fwu_bootloader_staging_area_init+0x38>
 c05e11a:	bf00      	nop
 c05e11c:	0c06203c 	.word	0x0c06203c
 c05e120:	0c061f9c 	.word	0x0c061f9c
 c05e124:	300391ec 	.word	0x300391ec
 c05e128:	0c061fbd 	.word	0x0c061fbd

0c05e12c <fwu_bootloader_load_image>:
{
 c05e12c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 c05e12e:	461c      	mov	r4, r3
    uint8_t mcuboot_image_id = 0;
 c05e130:	2300      	movs	r3, #0
{
 c05e132:	460f      	mov	r7, r1
    if (block == NULL) {
 c05e134:	4615      	mov	r5, r2
    uint8_t mcuboot_image_id = 0;
 c05e136:	f88d 3006 	strb.w	r3, [sp, #6]
    if (block == NULL) {
 c05e13a:	b91a      	cbnz	r2, c05e144 <fwu_bootloader_load_image+0x18>
        return PSA_ERROR_INVALID_ARGUMENT;
 c05e13c:	f06f 0086 	mvn.w	r0, #134	@ 0x86
}
 c05e140:	b003      	add	sp, #12
 c05e142:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if (convert_id_from_bl_to_mcuboot(bootloader_image_id,
 c05e144:	f10d 0106 	add.w	r1, sp, #6
 c05e148:	f7ff ff80 	bl	c05e04c <convert_id_from_bl_to_mcuboot.constprop.0>
 c05e14c:	2800      	cmp	r0, #0
 c05e14e:	d1f5      	bne.n	c05e13c <fwu_bootloader_load_image+0x10>
    if (get_flash_image_index(mcuboot_image_id, &index)) {
 c05e150:	f89d 0006 	ldrb.w	r0, [sp, #6]
 c05e154:	f10d 0107 	add.w	r1, sp, #7
 c05e158:	f7ff ff2a 	bl	c05dfb0 <get_flash_image_index>
 c05e15c:	2800      	cmp	r0, #0
 c05e15e:	d0ed      	beq.n	c05e13c <fwu_bootloader_load_image+0x10>
        fap = mcuboot_ctx[index].fap;
 c05e160:	230c      	movs	r3, #12
 c05e162:	f89d 0007 	ldrb.w	r0, [sp, #7]
 c05e166:	f8df c02c 	ldr.w	ip, [pc, #44]	@ c05e194 <fwu_bootloader_load_image+0x68>
 c05e16a:	4358      	muls	r0, r3
    if (flash_area_write(fap, block_offset, block, block_size) != 0) {
 c05e16c:	462a      	mov	r2, r5
        fap = mcuboot_ctx[index].fap;
 c05e16e:	eb0c 0600 	add.w	r6, ip, r0
    if (flash_area_write(fap, block_offset, block, block_size) != 0) {
 c05e172:	4623      	mov	r3, r4
 c05e174:	4639      	mov	r1, r7
 c05e176:	f85c 0000 	ldr.w	r0, [ip, r0]
 c05e17a:	f7fd fc71 	bl	c05ba60 <flash_area_write>
 c05e17e:	b128      	cbz	r0, c05e18c <fwu_bootloader_load_image+0x60>
        LOG_MSG("TFM FWU: write flash failed.\r\n");
 c05e180:	4805      	ldr	r0, [pc, #20]	@ (c05e198 <fwu_bootloader_load_image+0x6c>)
 c05e182:	f7de fbb5 	bl	c03c8f0 <tfm_log_printf>
        return PSA_ERROR_GENERIC_ERROR;
 c05e186:	f06f 0083 	mvn.w	r0, #131	@ 0x83
 c05e18a:	e7d9      	b.n	c05e140 <fwu_bootloader_load_image+0x14>
    mcuboot_ctx[index].loaded_size += block_size;
 c05e18c:	68b3      	ldr	r3, [r6, #8]
 c05e18e:	4423      	add	r3, r4
 c05e190:	60b3      	str	r3, [r6, #8]
    return PSA_SUCCESS;
 c05e192:	e7d5      	b.n	c05e140 <fwu_bootloader_load_image+0x14>
 c05e194:	300391ec 	.word	0x300391ec
 c05e198:	0c061fde 	.word	0x0c061fde

0c05e19c <fwu_bootloader_install_image>:
    uint8_t mcuboot_image_id = 0;
 c05e19c:	2300      	movs	r3, #0
{
 c05e19e:	b507      	push	{r0, r1, r2, lr}
    uint8_t mcuboot_image_id = 0;
 c05e1a0:	f88d 3006 	strb.w	r3, [sp, #6]
    if ((dependency == NULL || dependency_version == NULL)) {
 c05e1a4:	b921      	cbnz	r1, c05e1b0 <fwu_bootloader_install_image+0x14>
        return PSA_ERROR_INVALID_ARGUMENT;
 c05e1a6:	f06f 0086 	mvn.w	r0, #134	@ 0x86
}
 c05e1aa:	b003      	add	sp, #12
 c05e1ac:	f85d fb04 	ldr.w	pc, [sp], #4
    if ((dependency == NULL || dependency_version == NULL)) {
 c05e1b0:	2a00      	cmp	r2, #0
 c05e1b2:	d0f8      	beq.n	c05e1a6 <fwu_bootloader_install_image+0xa>
    if (convert_id_from_bl_to_mcuboot(bootloader_image_id,
 c05e1b4:	f10d 0106 	add.w	r1, sp, #6
 c05e1b8:	f7ff ff48 	bl	c05e04c <convert_id_from_bl_to_mcuboot.constprop.0>
 c05e1bc:	2800      	cmp	r0, #0
 c05e1be:	d1f2      	bne.n	c05e1a6 <fwu_bootloader_install_image+0xa>
    if (get_flash_image_index(mcuboot_image_id, &index)) {
 c05e1c0:	f89d 0006 	ldrb.w	r0, [sp, #6]
 c05e1c4:	f10d 0107 	add.w	r1, sp, #7
 c05e1c8:	f7ff fef2 	bl	c05dfb0 <get_flash_image_index>
 c05e1cc:	2800      	cmp	r0, #0
 c05e1ce:	d0ea      	beq.n	c05e1a6 <fwu_bootloader_install_image+0xa>
        fap = mcuboot_ctx[index].fap;
 c05e1d0:	220c      	movs	r2, #12
 c05e1d2:	f89d 3007 	ldrb.w	r3, [sp, #7]
 c05e1d6:	4353      	muls	r3, r2
        if (boot_write_magic(fap) != 0) {
 c05e1d8:	4a04      	ldr	r2, [pc, #16]	@ (c05e1ec <fwu_bootloader_install_image+0x50>)
 c05e1da:	58d0      	ldr	r0, [r2, r3]
 c05e1dc:	f7fb f828 	bl	c059230 <boot_write_magic>
            return PSA_ERROR_GENERIC_ERROR;
 c05e1e0:	2800      	cmp	r0, #0
 c05e1e2:	bf0c      	ite	eq
 c05e1e4:	2001      	moveq	r0, #1
 c05e1e6:	f06f 0083 	mvnne.w	r0, #131	@ 0x83
 c05e1ea:	e7de      	b.n	c05e1aa <fwu_bootloader_install_image+0xe>
 c05e1ec:	300391ec 	.word	0x300391ec

0c05e1f0 <fwu_bootloader_mark_image_accepted>:
{
 c05e1f0:	b508      	push	{r3, lr}
    if (boot_set_confirmed() != 0) {
 c05e1f2:	f7fb f837 	bl	c059264 <boot_set_confirmed>
        return PSA_ERROR_GENERIC_ERROR;
 c05e1f6:	2800      	cmp	r0, #0
}
 c05e1f8:	bf18      	it	ne
 c05e1fa:	f06f 0083 	mvnne.w	r0, #131	@ 0x83
 c05e1fe:	bd08      	pop	{r3, pc}

0c05e200 <fwu_bootloader_abort>:
    uint8_t mcuboot_image_id = 0;
 c05e200:	2300      	movs	r3, #0
{
 c05e202:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    if (convert_id_from_bl_to_mcuboot(bootloader_image_id,
 c05e206:	f10d 0106 	add.w	r1, sp, #6
    uint8_t mcuboot_image_id = 0;
 c05e20a:	f88d 3006 	strb.w	r3, [sp, #6]
    if (convert_id_from_bl_to_mcuboot(bootloader_image_id,
 c05e20e:	f7ff ff1d 	bl	c05e04c <convert_id_from_bl_to_mcuboot.constprop.0>
 c05e212:	4604      	mov	r4, r0
 c05e214:	b128      	cbz	r0, c05e222 <fwu_bootloader_abort+0x22>
        return PSA_ERROR_INVALID_ARGUMENT;
 c05e216:	f06f 0486 	mvn.w	r4, #134	@ 0x86
}
 c05e21a:	4620      	mov	r0, r4
 c05e21c:	b002      	add	sp, #8
 c05e21e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if (get_flash_image_index(mcuboot_image_id, &index)) {
 c05e222:	f89d 0006 	ldrb.w	r0, [sp, #6]
 c05e226:	f10d 0107 	add.w	r1, sp, #7
 c05e22a:	f7ff fec1 	bl	c05dfb0 <get_flash_image_index>
 c05e22e:	2800      	cmp	r0, #0
 c05e230:	d0f1      	beq.n	c05e216 <fwu_bootloader_abort+0x16>
        fap = mcuboot_ctx[index].fap;
 c05e232:	230c      	movs	r3, #12
 c05e234:	f89d 5007 	ldrb.w	r5, [sp, #7]
 c05e238:	4e08      	ldr	r6, [pc, #32]	@ (c05e25c <fwu_bootloader_abort+0x5c>)
 c05e23a:	435d      	muls	r5, r3
 c05e23c:	5977      	ldr	r7, [r6, r5]
    flash_area_erase(fap, 0, fap->fa_size);
 c05e23e:	4621      	mov	r1, r4
 c05e240:	68fa      	ldr	r2, [r7, #12]
 c05e242:	4638      	mov	r0, r7
 c05e244:	f7fd fc21 	bl	c05ba8a <flash_area_erase>
        fap = mcuboot_ctx[index].fap;
 c05e248:	eb06 0805 	add.w	r8, r6, r5
    flash_area_close(fap);
 c05e24c:	4638      	mov	r0, r7
 c05e24e:	f7fd fbf1 	bl	c05ba34 <flash_area_close>
    mcuboot_ctx[index].fap = NULL;
 c05e252:	5174      	str	r4, [r6, r5]
    mcuboot_ctx[index].loaded_size = 0;
 c05e254:	f8c8 4008 	str.w	r4, [r8, #8]
    return PSA_SUCCESS;
 c05e258:	e7df      	b.n	c05e21a <fwu_bootloader_abort+0x1a>
 c05e25a:	bf00      	nop
 c05e25c:	300391ec 	.word	0x300391ec

0c05e260 <fwu_bootloader_get_image_info>:

psa_status_t fwu_bootloader_get_image_info(bl_image_id_t bootloader_image_id,
                                  bool active_image,
                                  psa_image_info_t *info)
{
    struct image_version image_ver = { 0 };
 c05e260:	2300      	movs	r3, #0
{
 c05e262:	b5f0      	push	{r4, r5, r6, r7, lr}
 c05e264:	b099      	sub	sp, #100	@ 0x64
 c05e266:	460e      	mov	r6, r1
    uint8_t *tlv_end;
    uint8_t *tlv_curr;
    bool found = false;
    uint8_t mcuboot_image_id = 0;

    if (info == NULL) {
 c05e268:	4615      	mov	r5, r2
    struct image_version image_ver = { 0 };
 c05e26a:	e9cd 3306 	strd	r3, r3, [sp, #24]
    uint8_t mcuboot_image_id = 0;
 c05e26e:	f88d 300e 	strb.w	r3, [sp, #14]
    if (info == NULL) {
 c05e272:	b922      	cbnz	r2, c05e27e <fwu_bootloader_get_image_info+0x1e>
        return PSA_ERROR_INVALID_ARGUMENT;
 c05e274:	f06f 0486 	mvn.w	r4, #134	@ 0x86
            return PSA_ERROR_GENERIC_ERROR;
        }
    } else {
        return get_secondary_image_info(mcuboot_image_id, info);
    }
}
 c05e278:	4620      	mov	r0, r4
 c05e27a:	b019      	add	sp, #100	@ 0x64
 c05e27c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if (convert_id_from_bl_to_mcuboot(bootloader_image_id,
 c05e27e:	f10d 010e 	add.w	r1, sp, #14
 c05e282:	f7ff fee3 	bl	c05e04c <convert_id_from_bl_to_mcuboot.constprop.0>
 c05e286:	4604      	mov	r4, r0
 c05e288:	2800      	cmp	r0, #0
 c05e28a:	d1f3      	bne.n	c05e274 <fwu_bootloader_get_image_info+0x14>
    memset(info, 0, sizeof(psa_image_info_t));
 c05e28c:	4601      	mov	r1, r0
 c05e28e:	222c      	movs	r2, #44	@ 0x2c
 c05e290:	4628      	mov	r0, r5
    memset(info->digest, TFM_IMAGE_INFO_INVALID_DIGEST, sizeof(info->digest));
 c05e292:	f105 0709 	add.w	r7, r5, #9
    memset(info, 0, sizeof(psa_image_info_t));
 c05e296:	f7fd fa4a 	bl	c05b72e <memset>
    memset(info->digest, TFM_IMAGE_INFO_INVALID_DIGEST, sizeof(info->digest));
 c05e29a:	2220      	movs	r2, #32
 c05e29c:	21ff      	movs	r1, #255	@ 0xff
 c05e29e:	4638      	mov	r0, r7
 c05e2a0:	f7fd fa45 	bl	c05b72e <memset>
    if (active_image) {
 c05e2a4:	b32e      	cbz	r6, c05e2f2 <fwu_bootloader_get_image_info+0x92>
        info->state = PSA_IMAGE_INSTALLED;
 c05e2a6:	2302      	movs	r3, #2
        if (boot_shared_data.header.tlv_magic != SHARED_DATA_TLV_INFO_MAGIC) {
 c05e2a8:	f242 0216 	movw	r2, #8214	@ 0x2016
        info->state = PSA_IMAGE_INSTALLED;
 c05e2ac:	722b      	strb	r3, [r5, #8]
        if (boot_shared_data.header.tlv_magic != SHARED_DATA_TLV_INFO_MAGIC) {
 c05e2ae:	4b46      	ldr	r3, [pc, #280]	@ (c05e3c8 <fwu_bootloader_get_image_info+0x168>)
 c05e2b0:	8819      	ldrh	r1, [r3, #0]
 c05e2b2:	4291      	cmp	r1, r2
 c05e2b4:	d106      	bne.n	c05e2c4 <fwu_bootloader_get_image_info+0x64>
                  boot_shared_data.header.tlv_tot_len;
 c05e2b6:	8859      	ldrh	r1, [r3, #2]
               (GET_FWU_MODULE(tlv_entry.tlv_type) == mcuboot_image_id)) {
 c05e2b8:	f89d 000e 	ldrb.w	r0, [sp, #14]
        tlv_end = (uint8_t *)&boot_shared_data +
 c05e2bc:	4419      	add	r1, r3
            tlv_curr += SHARED_DATA_ENTRY_HEADER_SIZE + tlv_entry.tlv_len;
 c05e2be:	3304      	adds	r3, #4
        while (tlv_curr < tlv_end) {
 c05e2c0:	428b      	cmp	r3, r1
 c05e2c2:	d302      	bcc.n	c05e2ca <fwu_bootloader_get_image_info+0x6a>
            return PSA_ERROR_GENERIC_ERROR;
 c05e2c4:	f06f 0483 	mvn.w	r4, #131	@ 0x83
 c05e2c8:	e7d6      	b.n	c05e278 <fwu_bootloader_get_image_info+0x18>
            (void)memcpy(&tlv_entry, tlv_curr, SHARED_DATA_ENTRY_HEADER_SIZE);
 c05e2ca:	681a      	ldr	r2, [r3, #0]
            if ((GET_FWU_CLAIM(tlv_entry.tlv_type) == SW_VERSION) &&
 c05e2cc:	0696      	lsls	r6, r2, #26
 c05e2ce:	d10d      	bne.n	c05e2ec <fwu_bootloader_get_image_info+0x8c>
               (GET_FWU_MODULE(tlv_entry.tlv_type) == mcuboot_image_id)) {
 c05e2d0:	f3c2 1685 	ubfx	r6, r2, #6, #6
            if ((GET_FWU_CLAIM(tlv_entry.tlv_type) == SW_VERSION) &&
 c05e2d4:	4286      	cmp	r6, r0
 c05e2d6:	d109      	bne.n	c05e2ec <fwu_bootloader_get_image_info+0x8c>
                if (tlv_entry.tlv_len != sizeof(struct image_version)) {
 c05e2d8:	0c12      	lsrs	r2, r2, #16
 c05e2da:	2a08      	cmp	r2, #8
 c05e2dc:	d1f2      	bne.n	c05e2c4 <fwu_bootloader_get_image_info+0x64>
                memcpy(&image_ver,
 c05e2de:	6858      	ldr	r0, [r3, #4]
 c05e2e0:	6899      	ldr	r1, [r3, #8]
 c05e2e2:	aa06      	add	r2, sp, #24
 c05e2e4:	c203      	stmia	r2!, {r0, r1}
            info->version.iv_major = image_ver.iv_major;
 c05e2e6:	6028      	str	r0, [r5, #0]
            info->version.iv_build_num = image_ver.iv_build_num;
 c05e2e8:	6069      	str	r1, [r5, #4]
            return PSA_SUCCESS;
 c05e2ea:	e7c5      	b.n	c05e278 <fwu_bootloader_get_image_info+0x18>
            tlv_curr += SHARED_DATA_ENTRY_HEADER_SIZE + tlv_entry.tlv_len;
 c05e2ec:	eb03 4312 	add.w	r3, r3, r2, lsr #16
 c05e2f0:	e7e5      	b.n	c05e2be <fwu_bootloader_get_image_info+0x5e>
    struct image_header hdr = {0};
 c05e2f2:	2220      	movs	r2, #32
 c05e2f4:	4631      	mov	r1, r6
 c05e2f6:	eb0d 0002 	add.w	r0, sp, r2
        return get_secondary_image_info(mcuboot_image_id, info);
 c05e2fa:	f89d 400e 	ldrb.w	r4, [sp, #14]
    const struct flash_area *fap = NULL;
 c05e2fe:	9604      	str	r6, [sp, #16]
    struct image_header hdr = {0};
 c05e300:	f7fd fa15 	bl	c05b72e <memset>
    uint8_t hash[PSA_FWU_MAX_DIGEST_SIZE] = {0};
 c05e304:	221c      	movs	r2, #28
 c05e306:	4631      	mov	r1, r6
 c05e308:	a811      	add	r0, sp, #68	@ 0x44
 c05e30a:	9610      	str	r6, [sp, #64]	@ 0x40
 c05e30c:	f7fd fa0f 	bl	c05b72e <memset>
    size_t hash_size = 0;
 c05e310:	2c03      	cmp	r4, #3
 c05e312:	bf98      	it	ls
 c05e314:	4b2d      	ldrls	r3, [pc, #180]	@ (c05e3cc <fwu_bootloader_get_image_info+0x16c>)
    if ((flash_area_open(FLASH_AREA_IMAGE_SECONDARY(image_id),
 c05e316:	a904      	add	r1, sp, #16
    size_t hash_size = 0;
 c05e318:	bf8c      	ite	hi
 c05e31a:	20ff      	movhi	r0, #255	@ 0xff
 c05e31c:	5d18      	ldrbls	r0, [r3, r4]
 c05e31e:	9605      	str	r6, [sp, #20]
    if ((flash_area_open(FLASH_AREA_IMAGE_SECONDARY(image_id),
 c05e320:	f7fd fb74 	bl	c05ba0c <flash_area_open>
 c05e324:	4601      	mov	r1, r0
 c05e326:	b118      	cbz	r0, c05e330 <fwu_bootloader_get_image_info+0xd0>
        LOG_MSG("TFM FWU: opening flash failed.\r\n");
 c05e328:	4829      	ldr	r0, [pc, #164]	@ (c05e3d0 <fwu_bootloader_get_image_info+0x170>)
        LOG_MSG("TFM FWU: reading flash failed.\r\n");
 c05e32a:	f7de fae1 	bl	c03c8f0 <tfm_log_printf>
        return PSA_ERROR_GENERIC_ERROR;
 c05e32e:	e7c9      	b.n	c05e2c4 <fwu_bootloader_get_image_info+0x64>
    if (flash_area_read(fap, 0, &hdr, sizeof(hdr)) != 0) {
 c05e330:	2320      	movs	r3, #32
 c05e332:	9804      	ldr	r0, [sp, #16]
 c05e334:	eb0d 0203 	add.w	r2, sp, r3
 c05e338:	f7fd fb7d 	bl	c05ba36 <flash_area_read>
 c05e33c:	b120      	cbz	r0, c05e348 <fwu_bootloader_get_image_info+0xe8>
        flash_area_close(fap);
 c05e33e:	9804      	ldr	r0, [sp, #16]
 c05e340:	f7fd fb78 	bl	c05ba34 <flash_area_close>
        LOG_MSG("TFM FWU: reading flash failed.\r\n");
 c05e344:	4823      	ldr	r0, [pc, #140]	@ (c05e3d4 <fwu_bootloader_get_image_info+0x174>)
 c05e346:	e7f0      	b.n	c05e32a <fwu_bootloader_get_image_info+0xca>
    if (get_flash_image_index(image_id, &index)) {
 c05e348:	4620      	mov	r0, r4
 c05e34a:	f10d 010f 	add.w	r1, sp, #15
 c05e34e:	f7ff fe2f 	bl	c05dfb0 <get_flash_image_index>
 c05e352:	b1c0      	cbz	r0, c05e386 <fwu_bootloader_get_image_info+0x126>
        data_size = mcuboot_ctx[index].loaded_size;
 c05e354:	210c      	movs	r1, #12
 c05e356:	f89d 200f 	ldrb.w	r2, [sp, #15]
 c05e35a:	4b1f      	ldr	r3, [pc, #124]	@ (c05e3d8 <fwu_bootloader_get_image_info+0x178>)
 c05e35c:	fb01 3302 	mla	r3, r1, r2, r3
 c05e360:	6899      	ldr	r1, [r3, #8]
    if (util_img_hash(fap, data_size, hash, (size_t)PSA_FWU_MAX_DIGEST_SIZE,
 c05e362:	9804      	ldr	r0, [sp, #16]
 c05e364:	ab05      	add	r3, sp, #20
 c05e366:	aa10      	add	r2, sp, #64	@ 0x40
 c05e368:	f7ff fe34 	bl	c05dfd4 <util_img_hash.constprop.0>
 c05e36c:	4604      	mov	r4, r0
 c05e36e:	bb20      	cbnz	r0, c05e3ba <fwu_bootloader_get_image_info+0x15a>
    return (memcpy(dest, src, num));
 c05e370:	4638      	mov	r0, r7
 c05e372:	9a05      	ldr	r2, [sp, #20]
 c05e374:	a910      	add	r1, sp, #64	@ 0x40
 c05e376:	f7fd f969 	bl	c05b64c <memcpy>
    info->state = PSA_IMAGE_UNDEFINED;
 c05e37a:	2300      	movs	r3, #0
    flash_area_close(fap);
 c05e37c:	9804      	ldr	r0, [sp, #16]
    info->state = PSA_IMAGE_UNDEFINED;
 c05e37e:	722b      	strb	r3, [r5, #8]
    flash_area_close(fap);
 c05e380:	f7fd fb58 	bl	c05ba34 <flash_area_close>
    return ret;
 c05e384:	e778      	b.n	c05e278 <fwu_bootloader_get_image_info+0x18>
        if (hdr.ih_magic == IMAGE_MAGIC) {
 c05e386:	4b15      	ldr	r3, [pc, #84]	@ (c05e3dc <fwu_bootloader_get_image_info+0x17c>)
 c05e388:	9a08      	ldr	r2, [sp, #32]
 c05e38a:	429a      	cmp	r2, r3
 c05e38c:	d118      	bne.n	c05e3c0 <fwu_bootloader_get_image_info+0x160>
            info->version.iv_major = hdr.ih_ver.iv_major;
 c05e38e:	e9dd 230d 	ldrd	r2, r3, [sp, #52]	@ 0x34
            LOG_MSG("version= %d., %d., %d.,+ %d\n\r",
 c05e392:	f89d 1034 	ldrb.w	r1, [sp, #52]	@ 0x34
            info->version.iv_build_num = hdr.ih_ver.iv_build_num;
 c05e396:	e9c5 2300 	strd	r2, r3, [r5]
            LOG_MSG("version= %d., %d., %d.,+ %d\n\r",
 c05e39a:	4811      	ldr	r0, [pc, #68]	@ (c05e3e0 <fwu_bootloader_get_image_info+0x180>)
 c05e39c:	9300      	str	r3, [sp, #0]
 c05e39e:	f89d 2035 	ldrb.w	r2, [sp, #53]	@ 0x35
 c05e3a2:	f8bd 3036 	ldrh.w	r3, [sp, #54]	@ 0x36
 c05e3a6:	f7de faa3 	bl	c03c8f0 <tfm_log_printf>
                        hdr.ih_protect_tlv_size;
 c05e3aa:	f8bd 302a 	ldrh.w	r3, [sp, #42]	@ 0x2a
            data_size = hdr.ih_hdr_size + hdr.ih_img_size +
 c05e3ae:	f8bd 1028 	ldrh.w	r1, [sp, #40]	@ 0x28
 c05e3b2:	4419      	add	r1, r3
 c05e3b4:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 c05e3b6:	4419      	add	r1, r3
 c05e3b8:	e7d3      	b.n	c05e362 <fwu_bootloader_get_image_info+0x102>
        ret = PSA_ERROR_GENERIC_ERROR;
 c05e3ba:	f06f 0483 	mvn.w	r4, #131	@ 0x83
 c05e3be:	e7dc      	b.n	c05e37a <fwu_bootloader_get_image_info+0x11a>
            return PSA_ERROR_DOES_NOT_EXIST;
 c05e3c0:	f06f 048b 	mvn.w	r4, #139	@ 0x8b
        return get_secondary_image_info(mcuboot_image_id, info);
 c05e3c4:	e758      	b.n	c05e278 <fwu_bootloader_get_image_info+0x18>
 c05e3c6:	bf00      	nop
 c05e3c8:	300391b8 	.word	0x300391b8
 c05e3cc:	0c06203f 	.word	0x0c06203f
 c05e3d0:	0c061f9c 	.word	0x0c061f9c
 c05e3d4:	0c061ffd 	.word	0x0c061ffd
 c05e3d8:	300391ec 	.word	0x300391ec
 c05e3dc:	96f3b83d 	.word	0x96f3b83d
 c05e3e0:	0c06201e 	.word	0x0c06201e

0c05e3e4 <tfm_nspm_get_current_client_id>:
}
 c05e3e4:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 c05e3e8:	4770      	bx	lr

0c05e3ea <__acle_se_TZ_InitContextSystem_S>:
}
 c05e3ea:	2001      	movs	r0, #1
 c05e3ec:	4671      	mov	r1, lr
 c05e3ee:	4672      	mov	r2, lr
 c05e3f0:	4673      	mov	r3, lr
 c05e3f2:	46f4      	mov	ip, lr
 c05e3f4:	f38e 8c00 	msr	CPSR_fs, lr
 c05e3f8:	4774      	bxns	lr

0c05e3fa <__acle_se_TZ_AllocModuleContext_S>:
}
 c05e3fa:	2001      	movs	r0, #1
 c05e3fc:	4671      	mov	r1, lr
 c05e3fe:	4672      	mov	r2, lr
 c05e400:	4673      	mov	r3, lr
 c05e402:	46f4      	mov	ip, lr
 c05e404:	f38e 8c00 	msr	CPSR_fs, lr
 c05e408:	4774      	bxns	lr

0c05e40a <__acle_se_TZ_FreeModuleContext_S>:
uint32_t TZ_FreeModuleContext_S (TZ_MemoryId_t id)
 c05e40a:	b508      	push	{r3, lr}
 c05e40c:	f7ff fff5 	bl	c05e3fa <__acle_se_TZ_AllocModuleContext_S>
 c05e410:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 c05e414:	4671      	mov	r1, lr
 c05e416:	4672      	mov	r2, lr
 c05e418:	4673      	mov	r3, lr
 c05e41a:	46f4      	mov	ip, lr
 c05e41c:	f38e 8c00 	msr	CPSR_fs, lr
 c05e420:	4774      	bxns	lr

0c05e422 <__acle_se_TZ_LoadContext_S>:
uint32_t TZ_LoadContext_S (TZ_MemoryId_t id)
 c05e422:	b508      	push	{r3, lr}
 c05e424:	f7ff ffe9 	bl	c05e3fa <__acle_se_TZ_AllocModuleContext_S>
 c05e428:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 c05e42c:	4671      	mov	r1, lr
 c05e42e:	4672      	mov	r2, lr
 c05e430:	4673      	mov	r3, lr
 c05e432:	46f4      	mov	ip, lr
 c05e434:	f38e 8c00 	msr	CPSR_fs, lr
 c05e438:	4774      	bxns	lr

0c05e43a <__acle_se_TZ_StoreContext_S>:
uint32_t TZ_StoreContext_S (TZ_MemoryId_t id)
 c05e43a:	b508      	push	{r3, lr}
 c05e43c:	f7ff ffdd 	bl	c05e3fa <__acle_se_TZ_AllocModuleContext_S>
 c05e440:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 c05e444:	4671      	mov	r1, lr
 c05e446:	4672      	mov	r2, lr
 c05e448:	4673      	mov	r3, lr
 c05e44a:	46f4      	mov	ip, lr
 c05e44c:	f38e 8c00 	msr	CPSR_fs, lr
 c05e450:	4774      	bxns	lr
	...

0c05e454 <configure_ns_code>:
        "bxns     r0             \n"
    );
}

void configure_ns_code(void)
{
 c05e454:	b508      	push	{r3, lr}
    /* SCB_NS.VTOR points to the Non-secure vector table base address */
    SCB_NS->VTOR = tfm_spm_hal_get_ns_VTOR();
 c05e456:	f7f2 fb6b 	bl	c050b30 <tfm_spm_hal_get_ns_VTOR>
 c05e45a:	4b03      	ldr	r3, [pc, #12]	@ (c05e468 <configure_ns_code+0x14>)
 c05e45c:	6098      	str	r0, [r3, #8]

    /* Setups Main stack pointer of the non-secure code */
    uint32_t ns_msp = tfm_spm_hal_get_ns_MSP();
 c05e45e:	f7f2 fb6d 	bl	c050b3c <tfm_spm_hal_get_ns_MSP>
  __ASM volatile ("MSR msp_ns, %0" : : "r" (topOfMainStack) : );
 c05e462:	f380 8888 	msr	MSP_NS, r0

    __TZ_set_MSP_NS(ns_msp);
}
 c05e466:	bd08      	pop	{r3, pc}
 c05e468:	e002ed00 	.word	0xe002ed00

0c05e46c <tfm_pool_init>:
#include "tfm_memory_utils.h"
#include "tfm_core_utils.h"

int32_t tfm_pool_init(struct tfm_pool_instance_t *pool, size_t poolsz,
                      size_t chunksz, size_t num)
{
 c05e46c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 c05e470:	4616      	mov	r6, r2
 c05e472:	461d      	mov	r5, r3
    struct tfm_pool_chunk_t *pchunk;
    size_t i;

    if (!pool || num == 0) {
 c05e474:	4604      	mov	r4, r0
 c05e476:	b348      	cbz	r0, c05e4cc <tfm_pool_init+0x60>
 c05e478:	b343      	cbz	r3, c05e4cc <tfm_pool_init+0x60>
        return SPM_ERROR_BAD_PARAMETERS;
    }

    /* Ensure buffer is large enough */
    if (poolsz != ((chunksz + sizeof(struct tfm_pool_chunk_t)) * num +
 c05e47a:	f102 0808 	add.w	r8, r2, #8
 c05e47e:	fb03 f708 	mul.w	r7, r3, r8
 c05e482:	f107 0210 	add.w	r2, r7, #16
 c05e486:	428a      	cmp	r2, r1
 c05e488:	d120      	bne.n	c05e4cc <tfm_pool_init+0x60>
        sizeof(struct tfm_pool_instance_t))) {
        return SPM_ERROR_BAD_PARAMETERS;
    }

    /* Buffer should be BSS cleared but clear it again */
    spm_memset(pool, 0, poolsz);
 c05e48a:	2100      	movs	r1, #0
 c05e48c:	f7ff faeb 	bl	c05da66 <spm_memset>

    /* Chain pool chunks */
    BI_LIST_INIT_NODE(&pool->chunks_list);
 c05e490:	f104 0208 	add.w	r2, r4, #8

    pchunk = (struct tfm_pool_chunk_t *)pool->chunks;
 c05e494:	f104 0110 	add.w	r1, r4, #16
 c05e498:	4694      	mov	ip, r2
 c05e49a:	460b      	mov	r3, r1
    for (i = 0; i < num; i++) {
 c05e49c:	2000      	movs	r0, #0
    BI_LIST_INIT_NODE(&pool->chunks_list);
 c05e49e:	60e2      	str	r2, [r4, #12]
    for (i = 0; i < num; i++) {
 c05e4a0:	3001      	adds	r0, #1
 c05e4a2:	4285      	cmp	r5, r0
        BI_LIST_INSERT_BEFORE(&pool->chunks_list, &pchunk->list);
 c05e4a4:	f8cc 3004 	str.w	r3, [ip, #4]
        pchunk = (struct tfm_pool_chunk_t *)&pchunk->data[chunksz];
 c05e4a8:	eb03 0e08 	add.w	lr, r3, r8
        BI_LIST_INSERT_BEFORE(&pool->chunks_list, &pchunk->list);
 c05e4ac:	e9c3 c200 	strd	ip, r2, [r3]
 c05e4b0:	469c      	mov	ip, r3
    for (i = 0; i < num; i++) {
 c05e4b2:	d109      	bne.n	c05e4c8 <tfm_pool_init+0x5c>

    /* Prepare instance and insert to pool list */
    pool->chunksz = chunksz;
    pool->chunk_count = num;

    return SPM_SUCCESS;
 c05e4b4:	2000      	movs	r0, #0
        BI_LIST_INSERT_BEFORE(&pool->chunks_list, &pchunk->list);
 c05e4b6:	eba7 0708 	sub.w	r7, r7, r8
 c05e4ba:	4439      	add	r1, r7
 c05e4bc:	60a1      	str	r1, [r4, #8]
 c05e4be:	604a      	str	r2, [r1, #4]
    pool->chunk_count = num;
 c05e4c0:	e9c4 6500 	strd	r6, r5, [r4]
}
 c05e4c4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        pchunk = (struct tfm_pool_chunk_t *)&pchunk->data[chunksz];
 c05e4c8:	4673      	mov	r3, lr
 c05e4ca:	e7e9      	b.n	c05e4a0 <tfm_pool_init+0x34>
        return SPM_ERROR_BAD_PARAMETERS;
 c05e4cc:	4800      	ldr	r0, [pc, #0]	@ (c05e4d0 <tfm_pool_init+0x64>)
 c05e4ce:	e7f9      	b.n	c05e4c4 <tfm_pool_init+0x58>
 c05e4d0:	80000001 	.word	0x80000001

0c05e4d4 <tfm_pool_alloc>:
void *tfm_pool_alloc(struct tfm_pool_instance_t *pool)
{
    struct bi_list_node_t *node;
    struct tfm_pool_chunk_t *pchunk;

    if (!pool) {
 c05e4d4:	b158      	cbz	r0, c05e4ee <tfm_pool_alloc+0x1a>
        return NULL;
    }

    if (BI_LIST_IS_EMPTY(&pool->chunks_list)) {
 c05e4d6:	68c3      	ldr	r3, [r0, #12]
 c05e4d8:	3008      	adds	r0, #8
 c05e4da:	4283      	cmp	r3, r0
 c05e4dc:	d006      	beq.n	c05e4ec <tfm_pool_alloc+0x18>

    node = BI_LIST_NEXT_NODE(&pool->chunks_list);
    pchunk = TFM_GET_CONTAINER_PTR(node, struct tfm_pool_chunk_t, list);

    /* Remove node from list node, it will be added when pool free */
    BI_LIST_REMOVE_NODE(node);
 c05e4de:	e9d3 1200 	ldrd	r1, r2, [r3]

    return &pchunk->data;
 c05e4e2:	f103 0008 	add.w	r0, r3, #8
    BI_LIST_REMOVE_NODE(node);
 c05e4e6:	604a      	str	r2, [r1, #4]
 c05e4e8:	6011      	str	r1, [r2, #0]
    return &pchunk->data;
 c05e4ea:	4770      	bx	lr
        return NULL;
 c05e4ec:	2000      	movs	r0, #0
}
 c05e4ee:	4770      	bx	lr

0c05e4f0 <tfm_pool_free>:
void tfm_pool_free(struct tfm_pool_instance_t *pool, void *ptr)
{
    struct tfm_pool_chunk_t *pchunk;

    pchunk = TFM_GET_CONTAINER_PTR(ptr, struct tfm_pool_chunk_t, data);
    BI_LIST_INSERT_BEFORE(&pool->chunks_list, &pchunk->list);
 c05e4f0:	6882      	ldr	r2, [r0, #8]
    pchunk = TFM_GET_CONTAINER_PTR(ptr, struct tfm_pool_chunk_t, data);
 c05e4f2:	f1a1 0308 	sub.w	r3, r1, #8
    BI_LIST_INSERT_BEFORE(&pool->chunks_list, &pchunk->list);
 c05e4f6:	6053      	str	r3, [r2, #4]
 c05e4f8:	f841 2c08 	str.w	r2, [r1, #-8]
 c05e4fc:	f840 3f08 	str.w	r3, [r0, #8]!
 c05e500:	f841 0c04 	str.w	r0, [r1, #-4]
}
 c05e504:	4770      	bx	lr

0c05e506 <is_valid_chunk_data_in_pool>:

bool is_valid_chunk_data_in_pool(struct tfm_pool_instance_t *pool,
                                 uint8_t *data)
{
    const uintptr_t chunks_start = (uintptr_t)(pool->chunks);
 c05e506:	f100 0210 	add.w	r2, r0, #16
    const size_t chunk_count = pool->chunk_count;
    const uintptr_t chunks_end = chunks_start + chunks_size * chunk_count;
    uintptr_t pool_chunk_address = 0;

    /* Check that the message was allocated from the pool. */
    if ((uintptr_t)data < chunks_start || (uintptr_t)data >= chunks_end) {
 c05e50a:	4291      	cmp	r1, r2
 c05e50c:	d310      	bcc.n	c05e530 <is_valid_chunk_data_in_pool+0x2a>
    const size_t chunks_size = pool->chunksz + sizeof(struct tfm_pool_chunk_t);
 c05e50e:	6803      	ldr	r3, [r0, #0]
    const uintptr_t chunks_end = chunks_start + chunks_size * chunk_count;
 c05e510:	6840      	ldr	r0, [r0, #4]
    const size_t chunks_size = pool->chunksz + sizeof(struct tfm_pool_chunk_t);
 c05e512:	3308      	adds	r3, #8
    const uintptr_t chunks_end = chunks_start + chunks_size * chunk_count;
 c05e514:	fb00 2003 	mla	r0, r0, r3, r2
    if ((uintptr_t)data < chunks_start || (uintptr_t)data >= chunks_end) {
 c05e518:	4281      	cmp	r1, r0
 c05e51a:	d209      	bcs.n	c05e530 <is_valid_chunk_data_in_pool+0x2a>
        return false;
    }

    pool_chunk_address =
 c05e51c:	3908      	subs	r1, #8
    (uint32_t)TFM_GET_CONTAINER_PTR(data, struct tfm_pool_chunk_t, data);

    /* Make sure that the chunk containing the message is aligned on */
    /* chunk boundary in the pool. */
    if ((pool_chunk_address - chunks_start) % chunks_size != 0) {
 c05e51e:	1a88      	subs	r0, r1, r2
 c05e520:	fbb0 f2f3 	udiv	r2, r0, r3
 c05e524:	fb03 0012 	mls	r0, r3, r2, r0
 c05e528:	fab0 f080 	clz	r0, r0
 c05e52c:	0940      	lsrs	r0, r0, #5
 c05e52e:	4770      	bx	lr
        return false;
 c05e530:	2000      	movs	r0, #0
        return false;
    }
    return true;
}
 c05e532:	4770      	bx	lr

0c05e534 <tfm_core_thrd_get_next>:
#define CURR_THRD   p_curr_thrd

/* Get next thread to run for scheduler */
struct tfm_core_thread_t *tfm_core_thrd_get_next(void)
{
    struct tfm_core_thread_t *pth = RNBL_HEAD;
 c05e534:	4b04      	ldr	r3, [pc, #16]	@ (c05e548 <tfm_core_thrd_get_next+0x14>)
 c05e536:	6818      	ldr	r0, [r3, #0]

    /*
     * First runnable thread has highest priority since threads are sorted with
     * priority.
     */
    while (pth && pth->state != THRD_STATE_RUNNABLE) {
 c05e538:	b110      	cbz	r0, c05e540 <tfm_core_thrd_get_next+0xc>
 c05e53a:	6943      	ldr	r3, [r0, #20]
 c05e53c:	2b01      	cmp	r3, #1
 c05e53e:	d100      	bne.n	c05e542 <tfm_core_thrd_get_next+0xe>
        pth = pth->next;
    }

    return pth;
}
 c05e540:	4770      	bx	lr
        pth = pth->next;
 c05e542:	6c80      	ldr	r0, [r0, #72]	@ 0x48
 c05e544:	e7f8      	b.n	c05e538 <tfm_core_thrd_get_next+0x4>
 c05e546:	bf00      	nop
 c05e548:	30039208 	.word	0x30039208

0c05e54c <tfm_core_thrd_get_curr>:

/* To get current running thread for caller */
struct tfm_core_thread_t *tfm_core_thrd_get_curr(void)
{
    return CURR_THRD;
}
 c05e54c:	4b01      	ldr	r3, [pc, #4]	@ (c05e554 <tfm_core_thrd_get_curr+0x8>)
 c05e54e:	6818      	ldr	r0, [r3, #0]
 c05e550:	4770      	bx	lr
 c05e552:	bf00      	nop
 c05e554:	30039204 	.word	0x30039204

0c05e558 <tfm_core_thrd_init>:

/* Set context members only. No validation here */
void tfm_core_thrd_init(struct tfm_core_thread_t *pth,
                        tfm_core_thrd_entry_t pfn, void *param,
                        uintptr_t stk_top, uintptr_t stk_btm)
{
 c05e558:	b510      	push	{r4, lr}
    pth->prior = THRD_PRIOR_MEDIUM;
    pth->state = THRD_STATE_CREATING;
 c05e55a:	f04f 0c7f 	mov.w	ip, #127	@ 0x7f
 c05e55e:	2400      	movs	r4, #0
    pth->pfn = pfn;
    pth->param = param;
 c05e560:	e9c0 1200 	strd	r1, r2, [r0]
    pth->stk_btm = stk_btm;
 c05e564:	9a02      	ldr	r2, [sp, #8]
    pth->state = THRD_STATE_CREATING;
 c05e566:	e9c0 c404 	strd	ip, r4, [r0, #16]
    pth->stk_top = stk_top;
 c05e56a:	e9c0 2302 	strd	r2, r3, [r0, #8]
}
 c05e56e:	bd10      	pop	{r4, pc}

0c05e570 <tfm_core_thrd_set_state>:

    /*
     * Set first runnable thread as head to reduce enumerate
     * depth while searching for a first runnable thread.
     */
    if ((pth->state == THRD_STATE_RUNNABLE) &&
 c05e570:	2901      	cmp	r1, #1
 c05e572:	4b06      	ldr	r3, [pc, #24]	@ (c05e58c <tfm_core_thrd_set_state+0x1c>)
    pth->state = new_state;
 c05e574:	6141      	str	r1, [r0, #20]
    if ((pth->state == THRD_STATE_RUNNABLE) &&
 c05e576:	d105      	bne.n	c05e584 <tfm_core_thrd_set_state+0x14>
        (RNBL_HEAD == NULL || (pth->prior < RNBL_HEAD->prior))) {
 c05e578:	681a      	ldr	r2, [r3, #0]
    if ((pth->state == THRD_STATE_RUNNABLE) &&
 c05e57a:	b12a      	cbz	r2, c05e588 <tfm_core_thrd_set_state+0x18>
        (RNBL_HEAD == NULL || (pth->prior < RNBL_HEAD->prior))) {
 c05e57c:	6901      	ldr	r1, [r0, #16]
 c05e57e:	6912      	ldr	r2, [r2, #16]
 c05e580:	4291      	cmp	r1, r2
 c05e582:	d301      	bcc.n	c05e588 <tfm_core_thrd_set_state+0x18>
        RNBL_HEAD = pth;
    } else {
        RNBL_HEAD = LIST_HEAD;
 c05e584:	4a02      	ldr	r2, [pc, #8]	@ (c05e590 <tfm_core_thrd_set_state+0x20>)
 c05e586:	6810      	ldr	r0, [r2, #0]
 c05e588:	6018      	str	r0, [r3, #0]
    }
}
 c05e58a:	4770      	bx	lr
 c05e58c:	30039208 	.word	0x30039208
 c05e590:	3003920c 	.word	0x3003920c

0c05e594 <tfm_core_thrd_start>:
{
 c05e594:	b537      	push	{r0, r1, r2, r4, r5, lr}
    if ((pth->state != THRD_STATE_CREATING) ||
 c05e596:	6945      	ldr	r5, [r0, #20]
{
 c05e598:	4604      	mov	r4, r0
    if ((pth->state != THRD_STATE_CREATING) ||
 c05e59a:	bb1d      	cbnz	r5, c05e5e4 <tfm_core_thrd_start+0x50>
        (pth->pfn == NULL)                  ||
 c05e59c:	6802      	ldr	r2, [r0, #0]
    if ((pth->state != THRD_STATE_CREATING) ||
 c05e59e:	b30a      	cbz	r2, c05e5e4 <tfm_core_thrd_start+0x50>
        (pth->stk_btm == 0)                 ||
 c05e5a0:	6883      	ldr	r3, [r0, #8]
        (pth->pfn == NULL)                  ||
 c05e5a2:	b1fb      	cbz	r3, c05e5e4 <tfm_core_thrd_start+0x50>
        (pth->stk_top == 0)) {
 c05e5a4:	68c1      	ldr	r1, [r0, #12]
        (pth->stk_btm == 0)                 ||
 c05e5a6:	b1e9      	cbz	r1, c05e5e4 <tfm_core_thrd_start+0x50>
    tfm_arch_init_context(&pth->arch_ctx, pth->param, (uintptr_t)pth->pfn,
 c05e5a8:	9100      	str	r1, [sp, #0]
 c05e5aa:	6841      	ldr	r1, [r0, #4]
 c05e5ac:	3018      	adds	r0, #24
 c05e5ae:	f7fe ff11 	bl	c05d3d4 <tfm_arch_init_context>
    if (*head == NULL || (node->prior <= (*head)->prior)) {
 c05e5b2:	490d      	ldr	r1, [pc, #52]	@ (c05e5e8 <tfm_core_thrd_start+0x54>)
 c05e5b4:	680b      	ldr	r3, [r1, #0]
 c05e5b6:	b11b      	cbz	r3, c05e5c0 <tfm_core_thrd_start+0x2c>
 c05e5b8:	6922      	ldr	r2, [r4, #16]
 c05e5ba:	6918      	ldr	r0, [r3, #16]
 c05e5bc:	4282      	cmp	r2, r0
 c05e5be:	d808      	bhi.n	c05e5d2 <tfm_core_thrd_start+0x3e>
        node->next = *head;
 c05e5c0:	64a3      	str	r3, [r4, #72]	@ 0x48
        *head = node;
 c05e5c2:	600c      	str	r4, [r1, #0]
    tfm_core_thrd_set_state(pth, THRD_STATE_RUNNABLE);
 c05e5c4:	2101      	movs	r1, #1
 c05e5c6:	4620      	mov	r0, r4
 c05e5c8:	f7ff ffd2 	bl	c05e570 <tfm_core_thrd_set_state>
}
 c05e5cc:	4628      	mov	r0, r5
 c05e5ce:	b003      	add	sp, #12
 c05e5d0:	bd30      	pop	{r4, r5, pc}
        while (iter->next && (node->prior > iter->next->prior)) {
 c05e5d2:	4619      	mov	r1, r3
 c05e5d4:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 c05e5d6:	b113      	cbz	r3, c05e5de <tfm_core_thrd_start+0x4a>
 c05e5d8:	6918      	ldr	r0, [r3, #16]
 c05e5da:	4282      	cmp	r2, r0
 c05e5dc:	d8f9      	bhi.n	c05e5d2 <tfm_core_thrd_start+0x3e>
        node->next = iter->next;
 c05e5de:	64a3      	str	r3, [r4, #72]	@ 0x48
        iter->next = node;
 c05e5e0:	648c      	str	r4, [r1, #72]	@ 0x48
 c05e5e2:	e7ef      	b.n	c05e5c4 <tfm_core_thrd_start+0x30>
        return THRD_ERR_INVALID_PARAM;
 c05e5e4:	2501      	movs	r5, #1
 c05e5e6:	e7f1      	b.n	c05e5cc <tfm_core_thrd_start+0x38>
 c05e5e8:	3003920c 	.word	0x3003920c

0c05e5ec <tfm_core_thrd_activate_schedule>:
#define TFM_STATE_RET_VAL(ctx) (((struct tfm_state_context_t *)((ctx)->sp))->r0)

__attribute__ ((always_inline))
__STATIC_INLINE void tfm_arch_trigger_pendsv(void)
{
    SCB->ICSR = SCB_ICSR_PENDSVSET_Msk;
 c05e5ec:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 c05e5f0:	4b01      	ldr	r3, [pc, #4]	@ (c05e5f8 <tfm_core_thrd_activate_schedule+0xc>)
 c05e5f2:	605a      	str	r2, [r3, #4]

/* Scheduling won't happen immediately but after the exception returns */
void tfm_core_thrd_activate_schedule(void)
{
    tfm_arch_trigger_pendsv();
}
 c05e5f4:	4770      	bx	lr
 c05e5f6:	bf00      	nop
 c05e5f8:	e000ed00 	.word	0xe000ed00

0c05e5fc <tfm_core_thrd_start_scheduler>:
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 c05e5fc:	6b83      	ldr	r3, [r0, #56]	@ 0x38
 c05e5fe:	f383 8809 	msr	PSP, r3
  __ASM volatile ("MSR psplim, %0" : : "r" (ProcStackPtrLimit));
 c05e602:	6bc3      	ldr	r3, [r0, #60]	@ 0x3c
 c05e604:	f383 880b 	msr	PSPLIM, r3
 c05e608:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
    TFM_CORE_ASSERT(pth != NULL);
    TFM_CORE_ASSERT(pth->arch_ctx.sp != 0);

    tfm_arch_update_ctx(&pth->arch_ctx);

    CURR_THRD = pth;
 c05e60c:	4b02      	ldr	r3, [pc, #8]	@ (c05e618 <tfm_core_thrd_start_scheduler+0x1c>)
 c05e60e:	6018      	str	r0, [r3, #0]
 c05e610:	4b02      	ldr	r3, [pc, #8]	@ (c05e61c <tfm_core_thrd_start_scheduler+0x20>)
 c05e612:	605a      	str	r2, [r3, #4]

    tfm_core_thrd_activate_schedule();
}
 c05e614:	4770      	bx	lr
 c05e616:	bf00      	nop
 c05e618:	30039204 	.word	0x30039204
 c05e61c:	e000ed00 	.word	0xe000ed00

0c05e620 <tfm_core_thrd_switch_context>:

void tfm_core_thrd_switch_context(struct tfm_arch_ctx_t *p_actx,
                                  struct tfm_core_thread_t *prev,
                                  struct tfm_core_thread_t *next)
{
 c05e620:	b538      	push	{r3, r4, r5, lr}
 c05e622:	4605      	mov	r5, r0
 c05e624:	4608      	mov	r0, r1
 c05e626:	4614      	mov	r4, r2

    /*
     * First, update latest context into the current thread context.
     * Then, update background context with next thread's context.
     */
    spm_memcpy(&prev->arch_ctx, p_actx, sizeof(*p_actx));
 c05e628:	4629      	mov	r1, r5
 c05e62a:	2230      	movs	r2, #48	@ 0x30
 c05e62c:	3018      	adds	r0, #24
 c05e62e:	f7ff f9e9 	bl	c05da04 <spm_memcpy>
    spm_memcpy(p_actx, &next->arch_ctx, sizeof(next->arch_ctx));
 c05e632:	2230      	movs	r2, #48	@ 0x30
 c05e634:	4628      	mov	r0, r5
 c05e636:	f104 0118 	add.w	r1, r4, #24
 c05e63a:	f7ff f9e3 	bl	c05da04 <spm_memcpy>

    /* Update current thread indicator */
    CURR_THRD = next;
 c05e63e:	4b01      	ldr	r3, [pc, #4]	@ (c05e644 <tfm_core_thrd_switch_context+0x24>)
 c05e640:	601c      	str	r4, [r3, #0]
}
 c05e642:	bd38      	pop	{r3, r4, r5, pc}
 c05e644:	30039204 	.word	0x30039204

0c05e648 <tfm_event_wait>:
#include "tfm_thread.h"
#include "utilities.h"
#include "tfm_wait.h"

void tfm_event_wait(struct tfm_event_t *pevnt)
{
 c05e648:	b510      	push	{r4, lr}
 c05e64a:	4604      	mov	r4, r0
    TFM_CORE_ASSERT(pevnt && pevnt->magic == TFM_EVENT_MAGIC);

    pevnt->owner = tfm_core_thrd_get_curr();
 c05e64c:	f7ff ff7e 	bl	c05e54c <tfm_core_thrd_get_curr>
    tfm_core_thrd_set_state(pevnt->owner, THRD_STATE_BLOCK);
 c05e650:	2102      	movs	r1, #2
    pevnt->owner = tfm_core_thrd_get_curr();
 c05e652:	6060      	str	r0, [r4, #4]
    tfm_core_thrd_set_state(pevnt->owner, THRD_STATE_BLOCK);
 c05e654:	f7ff ff8c 	bl	c05e570 <tfm_core_thrd_set_state>
    tfm_core_thrd_activate_schedule();
}
 c05e658:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    tfm_core_thrd_activate_schedule();
 c05e65c:	f7ff bfc6 	b.w	c05e5ec <tfm_core_thrd_activate_schedule>

0c05e660 <tfm_event_wake>:

void tfm_event_wake(struct tfm_event_t *pevnt, uint32_t retval)
{
 c05e660:	b538      	push	{r3, r4, r5, lr}
 c05e662:	4604      	mov	r4, r0
    TFM_CORE_ASSERT(pevnt && pevnt->magic == TFM_EVENT_MAGIC);

    if (pevnt->owner && pevnt->owner->state == THRD_STATE_BLOCK) {
 c05e664:	6840      	ldr	r0, [r0, #4]
{
 c05e666:	460d      	mov	r5, r1
    if (pevnt->owner && pevnt->owner->state == THRD_STATE_BLOCK) {
 c05e668:	b170      	cbz	r0, c05e688 <tfm_event_wake+0x28>
 c05e66a:	6943      	ldr	r3, [r0, #20]
 c05e66c:	2b02      	cmp	r3, #2
 c05e66e:	d10b      	bne.n	c05e688 <tfm_event_wake+0x28>
        tfm_core_thrd_set_state(pevnt->owner, THRD_STATE_RUNNABLE);
 c05e670:	2101      	movs	r1, #1
 c05e672:	f7ff ff7d 	bl	c05e570 <tfm_core_thrd_set_state>
 *  could set its return value to the caller before caller goes.
 */
void __STATIC_INLINE tfm_core_thrd_set_retval(struct tfm_core_thread_t *pth,
                                              uint32_t retval)
{
    TFM_STATE_RET_VAL(&pth->arch_ctx) = retval;
 c05e676:	6863      	ldr	r3, [r4, #4]
 c05e678:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 c05e67a:	601d      	str	r5, [r3, #0]
        tfm_core_thrd_set_retval(pevnt->owner, retval);
        pevnt->owner = NULL;
 c05e67c:	2300      	movs	r3, #0
 c05e67e:	6063      	str	r3, [r4, #4]
        tfm_core_thrd_activate_schedule();
    }
}
 c05e680:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
        tfm_core_thrd_activate_schedule();
 c05e684:	f7ff bfb2 	b.w	c05e5ec <tfm_core_thrd_activate_schedule>
}
 c05e688:	bd38      	pop	{r3, r4, r5, pc}
	...

0c05e68c <stdio_output_string>:
extern ARM_DRIVER_USART TFM_DRIVER_STDIO;
#define STDIO_DRIVER    TFM_DRIVER_STDIO
#endif

int stdio_output_string(const unsigned char *str, uint32_t len)
{
 c05e68c:	b537      	push	{r0, r1, r2, r4, r5, lr}
    int32_t ret;

    ret = STDIO_DRIVER.Send(str, len);
 c05e68e:	4c08      	ldr	r4, [pc, #32]	@ (c05e6b0 <stdio_output_string+0x24>)
 c05e690:	6963      	ldr	r3, [r4, #20]
 c05e692:	4798      	blx	r3
    if (ret != ARM_DRIVER_OK) {
 c05e694:	b948      	cbnz	r0, c05e6aa <stdio_output_string+0x1e>
        return 0;
    }
    /* Add a busy wait after sending. */
    while (STDIO_DRIVER.GetStatus().tx_busy);
 c05e696:	6ae5      	ldr	r5, [r4, #44]	@ 0x2c
 c05e698:	47a8      	blx	r5
 c05e69a:	07c3      	lsls	r3, r0, #31
 c05e69c:	d4fc      	bmi.n	c05e698 <stdio_output_string+0xc>

    return STDIO_DRIVER.GetTxCount();
 c05e69e:	6a23      	ldr	r3, [r4, #32]
 c05e6a0:	9301      	str	r3, [sp, #4]
}
 c05e6a2:	b003      	add	sp, #12
 c05e6a4:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    return STDIO_DRIVER.GetTxCount();
 c05e6a8:	4718      	bx	r3
}
 c05e6aa:	2000      	movs	r0, #0
 c05e6ac:	b003      	add	sp, #12
 c05e6ae:	bd30      	pop	{r4, r5, pc}
 c05e6b0:	0c05f7b8 	.word	0x0c05f7b8

0c05e6b4 <_write>:
    return ch;
}
#elif defined(__GNUC__)
/* Redirects printf to STDIO_DRIVER in case of GNUARM */
int _write(int fd, char *str, int len)
{
 c05e6b4:	4608      	mov	r0, r1
    (void)fd;

    /* Send string and return the number of characters written */
    return stdio_output_string((const unsigned char *)str, (uint32_t)len);
 c05e6b6:	4611      	mov	r1, r2
 c05e6b8:	f7ff bfe8 	b.w	c05e68c <stdio_output_string>

0c05e6bc <stdio_init>:
  return len;
}
#endif

void stdio_init(void)
{
 c05e6bc:	b510      	push	{r4, lr}
    int32_t ret;
    ret = STDIO_DRIVER.Initialize(NULL);
 c05e6be:	4c09      	ldr	r4, [pc, #36]	@ (c05e6e4 <stdio_init+0x28>)
 c05e6c0:	2000      	movs	r0, #0
 c05e6c2:	68a3      	ldr	r3, [r4, #8]
 c05e6c4:	4798      	blx	r3
    ASSERT_HIGH(ret);

    ret = STDIO_DRIVER.PowerControl(ARM_POWER_FULL);
 c05e6c6:	6923      	ldr	r3, [r4, #16]
 c05e6c8:	2002      	movs	r0, #2
 c05e6ca:	4798      	blx	r3
    ASSERT_HIGH(ret);

    ret = STDIO_DRIVER.Control(ARM_USART_MODE_ASYNCHRONOUS,
 c05e6cc:	6aa4      	ldr	r4, [r4, #40]	@ 0x28
 c05e6ce:	f44f 31e1 	mov.w	r1, #115200	@ 0x1c200
 c05e6d2:	2001      	movs	r0, #1
 c05e6d4:	47a0      	blx	r4
                               DEFAULT_UART_BAUDRATE);
    ASSERT_HIGH(ret);
    (void)ret;

    (void)STDIO_DRIVER.Control(ARM_USART_CONTROL_TX, 1);
 c05e6d6:	4623      	mov	r3, r4
}
 c05e6d8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    (void)STDIO_DRIVER.Control(ARM_USART_CONTROL_TX, 1);
 c05e6dc:	2101      	movs	r1, #1
 c05e6de:	2015      	movs	r0, #21
 c05e6e0:	4718      	bx	r3
 c05e6e2:	bf00      	nop
 c05e6e4:	0c05f7b8 	.word	0x0c05f7b8

0c05e6e8 <tfm_core_panic>:
#include "fih.h"
#include "utilities.h"
#include "tfm_hal_platform.h"

void tfm_core_panic(void)
{
 c05e6e8:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    volatile uint32_t counter = 0;
 c05e6ea:	2300      	movs	r3, #0
    volatile uint32_t delay = FIH_NEGATIVE_VALUE;
 c05e6ec:	4c21      	ldr	r4, [pc, #132]	@ (c05e774 <tfm_core_panic+0x8c>)
 c05e6ee:	9402      	str	r4, [sp, #8]
    volatile uint32_t counter = 0;
 c05e6f0:	9303      	str	r3, [sp, #12]
    delay = fih_delay_random();
 c05e6f2:	f7fd f96a 	bl	c05b9ca <fih_delay_random>
 c05e6f6:	9002      	str	r0, [sp, #8]
    if (delay == FIH_NEGATIVE_VALUE) {
 c05e6f8:	9b02      	ldr	r3, [sp, #8]
 c05e6fa:	42a3      	cmp	r3, r4
 c05e6fc:	d101      	bne.n	c05e702 <tfm_core_panic+0x1a>
        FIH_PANIC;
 c05e6fe:	f7f4 f933 	bl	c052968 <Error_Handler>
    delay &= 0xFF;
 c05e702:	9b02      	ldr	r3, [sp, #8]
 c05e704:	b2db      	uxtb	r3, r3
 c05e706:	9302      	str	r3, [sp, #8]
    for (i = 0; i < delay; i++) {
 c05e708:	2300      	movs	r3, #0
 c05e70a:	9a02      	ldr	r2, [sp, #8]
 c05e70c:	4293      	cmp	r3, r2
 c05e70e:	d327      	bcc.n	c05e760 <tfm_core_panic+0x78>
    uint8_t local_delay = delay;
 c05e710:	9b02      	ldr	r3, [sp, #8]
    if (counter != local_delay) {
 c05e712:	9a03      	ldr	r2, [sp, #12]
 c05e714:	b2db      	uxtb	r3, r3
 c05e716:	4293      	cmp	r3, r2
 c05e718:	d001      	beq.n	c05e71e <tfm_core_panic+0x36>
        FIH_PANIC;
 c05e71a:	f7f4 f925 	bl	c052968 <Error_Handler>
     * In the next stage, the specified error codes are also sent to any NSPE
     * management firmware. The NSPE management firmware can then decide to pass
     * those error codes back to the calling task or to use its own
     * functionality for terminating an execution context.
     */
    tfm_hal_system_reset();
 c05e71e:	f7f4 f926 	bl	c05296e <tfm_hal_system_reset>
    volatile uint32_t counter = 0;
 c05e722:	2300      	movs	r3, #0
    volatile uint32_t delay = FIH_NEGATIVE_VALUE;
 c05e724:	4c13      	ldr	r4, [pc, #76]	@ (c05e774 <tfm_core_panic+0x8c>)
 c05e726:	9400      	str	r4, [sp, #0]
    volatile uint32_t counter = 0;
 c05e728:	9301      	str	r3, [sp, #4]
    delay = fih_delay_random();
 c05e72a:	f7fd f94e 	bl	c05b9ca <fih_delay_random>
 c05e72e:	9000      	str	r0, [sp, #0]
    if (delay == FIH_NEGATIVE_VALUE) {
 c05e730:	9b00      	ldr	r3, [sp, #0]
 c05e732:	42a3      	cmp	r3, r4
 c05e734:	d101      	bne.n	c05e73a <tfm_core_panic+0x52>
        FIH_PANIC;
 c05e736:	f7f4 f917 	bl	c052968 <Error_Handler>
    delay &= 0xFF;
 c05e73a:	9b00      	ldr	r3, [sp, #0]
 c05e73c:	b2db      	uxtb	r3, r3
 c05e73e:	9300      	str	r3, [sp, #0]
    for (i = 0; i < delay; i++) {
 c05e740:	2300      	movs	r3, #0
 c05e742:	9a00      	ldr	r2, [sp, #0]
 c05e744:	4293      	cmp	r3, r2
 c05e746:	d310      	bcc.n	c05e76a <tfm_core_panic+0x82>
    uint8_t local_delay = delay;
 c05e748:	9b00      	ldr	r3, [sp, #0]
    if (counter != local_delay) {
 c05e74a:	9a01      	ldr	r2, [sp, #4]
 c05e74c:	b2db      	uxtb	r3, r3
 c05e74e:	4293      	cmp	r3, r2
 c05e750:	d001      	beq.n	c05e756 <tfm_core_panic+0x6e>
        FIH_PANIC;
 c05e752:	f7f4 f909 	bl	c052968 <Error_Handler>
#ifdef TFM_FIH_PROFILE_ON
    fih_delay();

    tfm_hal_system_reset();
#endif
}
 c05e756:	b004      	add	sp, #16
 c05e758:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    tfm_hal_system_reset();
 c05e75c:	f7f4 b907 	b.w	c05296e <tfm_hal_system_reset>
        counter++;
 c05e760:	9a03      	ldr	r2, [sp, #12]
    for (i = 0; i < delay; i++) {
 c05e762:	3301      	adds	r3, #1
        counter++;
 c05e764:	3201      	adds	r2, #1
 c05e766:	9203      	str	r2, [sp, #12]
    for (i = 0; i < delay; i++) {
 c05e768:	e7cf      	b.n	c05e70a <tfm_core_panic+0x22>
        counter++;
 c05e76a:	9a01      	ldr	r2, [sp, #4]
    for (i = 0; i < delay; i++) {
 c05e76c:	3301      	adds	r3, #1
        counter++;
 c05e76e:	3201      	adds	r2, #1
 c05e770:	9201      	str	r2, [sp, #4]
    for (i = 0; i < delay; i++) {
 c05e772:	e7e6      	b.n	c05e742 <tfm_core_panic+0x5a>
 c05e774:	aaaa5555 	.word	0xaaaa5555

0c05e778 <_close>:
 c05e778:	4b02      	ldr	r3, [pc, #8]	@ (c05e784 <_close+0xc>)
 c05e77a:	2258      	movs	r2, #88	@ 0x58
 c05e77c:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 c05e780:	601a      	str	r2, [r3, #0]
 c05e782:	4770      	bx	lr
 c05e784:	3003e954 	.word	0x3003e954

0c05e788 <_fstat>:
 c05e788:	4b02      	ldr	r3, [pc, #8]	@ (c05e794 <_fstat+0xc>)
 c05e78a:	2258      	movs	r2, #88	@ 0x58
 c05e78c:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 c05e790:	601a      	str	r2, [r3, #0]
 c05e792:	4770      	bx	lr
 c05e794:	3003e954 	.word	0x3003e954

0c05e798 <_isatty>:
 c05e798:	4b02      	ldr	r3, [pc, #8]	@ (c05e7a4 <_isatty+0xc>)
 c05e79a:	2258      	movs	r2, #88	@ 0x58
 c05e79c:	2000      	movs	r0, #0
 c05e79e:	601a      	str	r2, [r3, #0]
 c05e7a0:	4770      	bx	lr
 c05e7a2:	bf00      	nop
 c05e7a4:	3003e954 	.word	0x3003e954

0c05e7a8 <_lseek>:
 c05e7a8:	4b02      	ldr	r3, [pc, #8]	@ (c05e7b4 <_lseek+0xc>)
 c05e7aa:	2258      	movs	r2, #88	@ 0x58
 c05e7ac:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 c05e7b0:	601a      	str	r2, [r3, #0]
 c05e7b2:	4770      	bx	lr
 c05e7b4:	3003e954 	.word	0x3003e954

0c05e7b8 <_read>:
 c05e7b8:	4b02      	ldr	r3, [pc, #8]	@ (c05e7c4 <_read+0xc>)
 c05e7ba:	2258      	movs	r2, #88	@ 0x58
 c05e7bc:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 c05e7c0:	601a      	str	r2, [r3, #0]
 c05e7c2:	4770      	bx	lr
 c05e7c4:	3003e954 	.word	0x3003e954

0c05e7c8 <_sbrk>:
 c05e7c8:	4a04      	ldr	r2, [pc, #16]	@ (c05e7dc <_sbrk+0x14>)
 c05e7ca:	4603      	mov	r3, r0
 c05e7cc:	6811      	ldr	r1, [r2, #0]
 c05e7ce:	b909      	cbnz	r1, c05e7d4 <_sbrk+0xc>
 c05e7d0:	4903      	ldr	r1, [pc, #12]	@ (c05e7e0 <_sbrk+0x18>)
 c05e7d2:	6011      	str	r1, [r2, #0]
 c05e7d4:	6810      	ldr	r0, [r2, #0]
 c05e7d6:	4403      	add	r3, r0
 c05e7d8:	6013      	str	r3, [r2, #0]
 c05e7da:	4770      	bx	lr
 c05e7dc:	3003e95c 	.word	0x3003e95c
 c05e7e0:	30041060 	.word	0x30041060

0c05e7e4 <_exit>:
 c05e7e4:	e7fe      	b.n	c05e7e4 <_exit>
	...

0c05e7e8 <_init>:
 c05e7e8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 c05e7ea:	bf00      	nop
 c05e7ec:	bcf8      	pop	{r3, r4, r5, r6, r7}
 c05e7ee:	bc08      	pop	{r3}
 c05e7f0:	469e      	mov	lr, r3
 c05e7f2:	4770      	bx	lr

0c05e7f4 <_fini>:
 c05e7f4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 c05e7f6:	bf00      	nop
 c05e7f8:	bcf8      	pop	{r3, r4, r5, r6, r7}
 c05e7fa:	bc08      	pop	{r3}
 c05e7fc:	469e      	mov	lr, r3
 c05e7fe:	4770      	bx	lr
 c05e800:	2073424f 	.word	0x2073424f
 c05e804:	00000040 	.word	0x00000040

0c05e808 <DMA_NULL>:
	...

0c05e810 <DMA_CONST_2>:
 c05e810:	fadabeef bababeef                       ........

0c05e818 <aProtectTests>:
 c05e818:	0c05eca0 4952504e 45532056 00000043     ....NPRIV SEC...
	...
 c05e83c:	00000209 30040c44 4952504e 45532056     ....D..0NPRIV SE
 c05e84c:	00000043 00000000 00000000 00000000     C...............
	...
 c05e864:	0000020a 50032808 435a5447 5a545f31     .....(.PGTZC1_TZ
 c05e874:	20434943 33524549 00000000 00000000     CIC IER3........
	...
 c05e88c:	00020208 56023408 435a5447 5a545f32     .....4.VGTZC2_TZ
 c05e89c:	20434943 33524549 00000000 00000000     CIC IER3........
	...
 c05e8b4:	00020207 300411ff 4952504e 4e452056     .......0NPRIV EN
 c05e8c4:	00000044 00000000 00000000 00000000     D...............
	...
 c05e8dc:	00000204 30048000 4220534e 6e696765     .......0NS Begin
	...
 c05e904:	00010203 300411f8 4952504e 4e452056     .......0NPRIV EN
 c05e914:	00000044 00000000 00000000 00000000     D...............
	...
 c05e92c:	00000209 3003ea00 4952504e 4e452056     .......0NPRIV EN
 c05e93c:	00000044 00000000 00000000 00000000     D...............
	...
 c05e954:	00000209 3003e9f8 4952504e 4e452056     .......0NPRIV EN
 c05e964:	00000044 00000000 00000000 00000000     D...............
	...
 c05e97c:	00020209 30030000 20324c42 52414853     .......0BL2 SHAR
 c05e98c:	00004445 00000000 00000000 00000000     ED..............
	...
 c05e9a4:	0002020a 0c032000 00535449 00000000     ..... ..ITS.....
	...
 c05e9cc:	00020209 0c02e000 00005350 00000000     ........PS......
	...
 c05e9f4:	00020209 0c036020 61746144 616d4920     .... `..Data Ima
 c05ea04:	53206567 72756365 74532065 00747261     ge Secure Start.
	...
 c05ea1c:	00020209 30048000 56495250 00000000     .......0PRIV....
	...
 c05ea44:	00010204 30030000 20324c42 52414853     .......0BL2 SHAR
 c05ea54:	00004445 00000000 00000000 00000000     ED..............
	...
 c05ea6c:	00010204 0c032000 00535449 00000000     ..... ..ITS.....
	...
 c05ea94:	00010201 0c02e000 00005350 00000000     ........PS......
	...
 c05eabc:	00010201 0c036020 61746144 616d4920     .... `..Data Ima
 c05eacc:	53206567 72756365 74532065 00747261     ge Secure Start.
	...
 c05eae4:	00010201 30040000 20707041 20746f52     .......0App Rot 
 c05eaf4:	61746144 61745320 00007472 00000000     Data Start......
	...
 c05eb0c:	00000204 30040c44 4952504e 45532056     ....D..0NPRIV SE
 c05eb1c:	00000043 00000000 00000000 00000000     C...............
	...
 c05eb34:	00010206 0c038400 65646f43 63655320     ........Code Sec
 c05eb44:	20657275 72617453 00000074 00000000     ure Start.......
	...
 c05eb5c:	00010201 0c065cdf 65646f43 63655320     .....\..Code Sec
 c05eb6c:	20657275 28444e45 656e6576 00297265     ure END(veneer).
	...
 c05eb84:	00000201 0c065ce1 65646f43 63655320     .....\..Code Sec
 c05eb94:	20657275 28444e45 656e6576 00297265     ure END(veneer).
	...
 c05ebac:	00010201 520c0804 20474e52 53205049     .......RRNG IP S
 c05ebbc:	00000052 00000000 00000000 00000000     R...............
	...
 c05ebd4:	00020007 520c0808 20474e52 44205049     .......RRNG IP D
 c05ebe4:	00000052 00000000 00000000 00000000     R...............
	...
 c05ebfc:	00020007 0c04b501 206e7566 6c6c6163     ........fun call
	...
 c05ec24:	00000205 0c05eca9 4c5f5842 6f632052     ........BX_LR co
 c05ec34:	0074736e 00000000 00000000 00000000     nst.............
	...
 c05ec4c:	00000205 300411fe 63657845 52504e20     .......0Exec NPR
 c05ec5c:	52205649 00004d41 00000000 00000000     IV RAM..........
	...
 c05ec74:	00010206 00000000 63657845 6f697475     ........Executio
 c05ec84:	7573206e 73656363 6c756673 00000000     n successful....
	...
 c05ec9c:	00000011                                ....

0c05eca0 <DMA_CONST>:
 c05eca0:	feedbeef cacadada                       ........

0c05eca8 <BX_LR>:
 c05eca8:	00004770 deadbeef fadadead              pG..........

0c05ecb4 <attestation_profile_definition>:
 c05ecb4:	2d617370 2d6d6674 666f7270 2d656c69     psa-tfm-profile-
 c05ecc4:	646d2e31                                 1.md.

0c05ecc9 <verification_service_url>:
 c05ecc9:	2e777777 73757274 66646574 776d7269     www.trustedfirmw
 c05ecd9:	2e657261 0067726f 70636573 72313235     are.org.secp521r
 c05ece9:	72620031 706e6961 506c6f6f 72323135     1.brainpoolP512r
 c05ecf9:	65730031 38337063 00317234 69617262     1.secp384r1.brai
 c05ed09:	6f6f706e 3833506c 00317234 70636573     npoolP384r1.secp
 c05ed19:	72363532 65730031 35327063 00316b36     256r1.secp256k1.
 c05ed29:	69617262 6f6f706e 3532506c 00317236     brainpoolP256r1.
 c05ed39:	70636573 72343232 65730031 32327063     secp224r1.secp22
 c05ed49:	00316b34 70636573 72323931 65730031     4k1.secp192r1.se
 c05ed59:	39317063 00316b32 35353278 78003931     cp192k1.x25519.x
 c05ed69:	00383434                                 448....

0c05ed70 <ecp_supported_curves>:
 c05ed70:	00190005 00000209 0c05ece1 001c0008     ................
 c05ed80:	00000200 0c05eceb 00180004 00000180     ................
 c05ed90:	0c05ecfb 001b0007 00000180 0c05ed05     ................
 c05eda0:	00170003 00000100 0c05ed15 0016000c     ................
 c05edb0:	00000100 0c05ed1f 001a0006 00000100     ................
 c05edc0:	0c05ed29 00150002 000000e0 0c05ed39     )...........9...
 c05edd0:	0014000b 000000e0 0c05ed43 00130001     ........C.......
 c05ede0:	000000c0 0c05ed4d 0012000a 000000c0     ....M...........
 c05edf0:	0c05ed57 001d0009 00000100 0c05ed61     W...........a...
 c05ee00:	001e000d 000001c0 0c05ed68 00000000     ........h.......
	...
 c05ee18:	42443130 31003234 46454434 41454439     01DB42.14DEF9DEA
 c05ee28:	39374632 35364443 36323138 35413133     2F79CD65812631A5
 c05ee38:	44354643 00444533 41413839 33333800     CF5D3ED.98AA.833
 c05ee48:	31434435 42423336 42343231 32313536     5DC163BB124B6512
 c05ee58:	36394339 39454446 38443333 33323744     9C96FDE933D8D723
 c05ee68:	41303741 38434441 36443337 41343544     A70AADC873D6D54A
 c05ee78:	30424237 00000044                       7BB0D...

0c05ee80 <brainpoolP512r1_n>:
 c05ee80:	9ca90069 b5879682 085ddadd 1db1d381     i.........].....
 c05ee90:	7fac1047 41866119 4ca92619 553e5c41     G....a.A.&.LA\>U
 c05eea0:	70330870 d6639cca b3c9d20e cb308db3     p.3p..c.......0.
 c05eeb0:	33c9fc07 3fd4e6ae dbe9c48b aadd9db8     ...3...?........

0c05eec0 <brainpoolP512r1_gy>:
 c05eec0:	3ad80892 78cd1e0f a8f05406 d1ca2b2f     ...:...x.T../+..
 c05eed0:	8a2763ae 5bca4bd8 4a5f485e b2dcde49     .c'..K.[^H_JI...
 c05eee0:	881f8111 a000c55b 24a57b1a f209f700     ....[....{.$....
 c05eef0:	cf7822fd c0eabfa9 566332ec 7dde385d     ."x......2cV]8.}

0c05ef00 <brainpoolP512r1_gx>:
 c05ef00:	bcb9f822 8b352209 406a5e68 7c6d5047     "...."5.h^j@GPm|
 c05ef10:	93b97d5f 50d1687b e2d0d48d ff3b1f78     _}..{h.P....x.;.
 c05ef20:	f4d0098e b43b62ee b5d916c1 85ed9f70     .....b;.....p...
 c05ef30:	9c4c6a93 5a21322e d82ed964 81aee4bd     .jL..2!Zd.......

0c05ef40 <brainpoolP512r1_b>:
 c05ef40:	8016f723 2809bd63 5ebae5dd 984050b7     #...c..(...^.P@.
 c05ef50:	dc083e67 77fc94ca e7c1ac4d 2bf2c7b9     g>.....wM......+
 c05ef60:	7f1117a7 8b9ac8b5 0a2ef1c9 a8253aa1     .............:%.
 c05ef70:	2ded5d5a ea9863bc a83441ca 3df91610     Z].-.c...A4....=

0c05ef80 <brainpoolP512r1_a>:
 c05ef80:	77fc94ca e7c1ac4d 2bf2c7b9 7f1117a7     ...wM......+....
 c05ef90:	8b9ac8b5 0a2ef1c9 a8253aa1 2ded5d5a     .........:%.Z].-
 c05efa0:	ea9863bc a83441ca 3df91610 94cbdd8d     .c...A4....=....
 c05efb0:	ac234cc5 e2327145 8b603b89 7830a331     .L#.Eq2..;`.1.0x

0c05efc0 <brainpoolP512r1_p>:
 c05efc0:	583a48f3 28aa6056 2d82c685 2881ff2f     .H:XV`.(...-/..(
 c05efd0:	e6a380e6 aecda12a 9bc66842 7d4d9b00     ....*...Bh....M}
 c05efe0:	70330871 d6639cca b3c9d20e cb308db3     q.3p..c.......0.
 c05eff0:	33c9fc07 3fd4e6ae dbe9c48b aadd9db8     ...3...?........

0c05f000 <brainpoolP384r1_n>:
 c05f000:	e9046565 3b883202 6b7fc310 cf3ab6af     ee...2.;...k..:.
 c05f010:	ac0425a7 1f166e6c ed5456b3 152f7109     .%..ln...VT..q/.
 c05f020:	50e641df 0f5d6f7e a3386d28 8cb91e82     .A.P~o].(m8.....

0c05f030 <brainpoolP384r1_gy>:
 c05f030:	263c5315 42820341 77918111 0e464621     .S<&A..B...w!FF.
 c05f040:	f9912928 e19c054f feec5864 62b70b29     ()..O...dX..)..b
 c05f050:	95cfd552 5cb1eb8e 20f9c2a4 8abe1d75     R......\... u...

0c05f060 <brainpoolP384r1_gx>:
 c05f060:	47d4af1e ef87b2e2 36d646aa e826e034     ...G.....F.64.&.
 c05f070:	0cbd10e8 db7fcafe 7ef14fe3 8847a3e7     .........O.~..G.
 c05f080:	b7c13f6b a2a63a81 68cf45ff 1d1c64f0     k?...:...E.h.d..

0c05f090 <brainpoolP384r1_b>:
 c05f090:	fa504c11 3ab78696 95dbc994 7cb43902     .LP....:.....9.|
 c05f0a0:	3eeb62d5 2e880ea5 07dcd2a6 2fb77de1     .b.>.........}./
 c05f0b0:	16f0447c 8b39b554 22ce2826 04a8c7dd     |D..T.9.&(."....

0c05f0c0 <brainpoolP384r1_a>:
 c05f0c0:	22ce2826 04a8c7dd 503ad4eb 8aa5814a     &(."......:PJ...
 c05f0d0:	ba91f90f 139165ef 4fb22787 c2bea28e     .....e...'.O....
 c05f0e0:	ce05afa0 3c72080a 3d8c150c 7bc382c6     ......r<...=...{

0c05f0f0 <brainpoolP384r1_p>:
 c05f0f0:	3107ec53 87470013 901d1a71 acd3a729     S..1..G.q...)...
 c05f100:	7fb71123 12b1da19 ed5456b4 152f7109     #........VT..q/.
 c05f110:	50e641df 0f5d6f7e a3386d28 8cb91e82     .A.P~o].(m8.....

0c05f120 <brainpoolP256r1_n>:
 c05f120:	974856a7 901e0e82 b561a6f7 8c397aa3     .VH.......a..z9.
 c05f130:	9d838d71 3e660a90 a1eea9bc a9fb57db     q.....f>.....W..

0c05f140 <brainpoolP256r1_gy>:
 c05f140:	2f046997 5c1d54c7 2ded8e54 c2774513     .i./.T.\T..-.Ew.
 c05f150:	14611dc9 97f8461a c3dac4fd 547ef835     ..a..F......5.~T

0c05f160 <brainpoolP256r1_gx>:
 c05f160:	9ace3262 3a4453bd e3bd23c2 b9de27e1     b2...SD:.#...'..
 c05f170:	fc81b7af 2c4b482f cb7e57cb 8bd2aeb9     ..../HK,.W~.....

0c05f180 <brainpoolP256r1_b>:
 c05f180:	ff8c07b6 6bccdc18 5cf7e1ce 95841629     .......k...\)...
 c05f190:	bbd77cbf f330b5d9 e94a4b44 26dc5c6c     .|....0.DKJ.l\.&

0c05f1a0 <brainpoolP256r1_a>:
 c05f1a0:	f330b5d9 e94a4b44 26dc5c6c fb8055c1     ..0.DKJ.l\.&.U..
 c05f1b0:	417affe7 eef67530 fc2c3057 7d5a0975     ..zA0u..W0,.u.Z}

0c05f1c0 <brainpoolP256r1_p>:
 c05f1c0:	1f6e5377 2013481d d5262028 6e3bf623     wSn..H. ( &.#.;n
 c05f1d0:	9d838d72 3e660a90 a1eea9bc a9fb57db     r.....f>.....W..

0c05f1e0 <secp256k1_n>:
 c05f1e0:	d0364141 bfd25e8c af48a03b baaedce6     AA6..^..;.H.....
 c05f1f0:	fffffffe ffffffff ffffffff ffffffff     ................

0c05f200 <secp256k1_gy>:
 c05f200:	fb10d4b8 9c47d08f a6855419 fd17b448     ......G..T..H...
 c05f210:	0e1108a8 5da4fbfc 26a3c465 483ada77     .......]e..&w.:H

0c05f220 <secp256k1_gx>:
 c05f220:	16f81798 59f2815b 2dce28d9 029bfcdb     ....[..Y.(.-....
 c05f230:	ce870b07 55a06295 f9dcbbac 79be667e     .....b.U....~f.y

0c05f240 <secp256k1_b>:
 c05f240:	00000007                                ....

0c05f244 <secp256k1_a>:
 c05f244:	00000000                                ....

0c05f248 <secp256k1_p>:
 c05f248:	fffffc2f fffffffe ffffffff ffffffff     /...............
 c05f258:	ffffffff ffffffff ffffffff ffffffff     ................

0c05f268 <secp224k1_n>:
 c05f268:	769fb1f7 caf0a971 d2ec6184 0001dce8     ...vq....a......
	...
 c05f284:	00000001                                ....

0c05f288 <secp224k1_gy>:
 c05f288:	556d61a5 e2ca4bdb c0b0bd59 f7e319f7     .amU.K..Y.......
 c05f298:	82cafbd6 7fba3442 7e089fed              ....B4.....~

0c05f2a4 <secp224k1_gx>:
 c05f2a4:	b6b7a45c 0f7e650e e47075a9 69a467e9     \....e~..up..g.i
 c05f2b4:	30fc28a1 4df099df a1455b33              .(.0...M3[E.

0c05f2c0 <secp224k1_b>:
 c05f2c0:	00000005                                ....

0c05f2c4 <secp224k1_a>:
 c05f2c4:	00000000                                ....

0c05f2c8 <secp224k1_p>:
 c05f2c8:	ffffe56d fffffffe ffffffff ffffffff     m...............
 c05f2d8:	ffffffff ffffffff ffffffff              ............

0c05f2e4 <secp192k1_n>:
 c05f2e4:	74defd8d 0f69466a 26f2fc17 fffffffe     ...tjFi....&....
 c05f2f4:	ffffffff ffffffff                       ........

0c05f2fc <secp192k1_gy>:
 c05f2fc:	d95e2f9d 4082aa88 15be8634 844163d0     ./^....@4....cA.
 c05f30c:	9c5628a7 9b2f2f6d                       .(V.m//.

0c05f314 <secp192k1_gx>:
 c05f314:	eae06c7d 1da5d1b1 80b7f434 26b07d02     }l......4....}.&
 c05f324:	c057e9ae db4ff10e                       ..W...O.

0c05f32c <secp192k1_b>:
 c05f32c:	00000003                                ....

0c05f330 <secp192k1_a>:
 c05f330:	00000000                                ....

0c05f334 <secp192k1_p>:
 c05f334:	ffffee37 fffffffe ffffffff ffffffff     7...............
 c05f344:	ffffffff ffffffff                       ........

0c05f34c <secp521r1_n>:
 c05f34c:	91386409 bb6fb71e 899c47ae 3bb5c9b8     .d8...o..G.....;
 c05f35c:	f709a5d0 7fcc0148 bf2f966b 51868783     ....H...k./....Q
 c05f36c:	fffffffa ffffffff ffffffff ffffffff     ................
 c05f37c:	ffffffff ffffffff ffffffff ffffffff     ................
 c05f38c:	000001ff                                ....

0c05f390 <secp521r1_gy>:
 c05f390:	9fd16650 88be9476 a272c240 353c7086     Pf..v...@.r..p<5
 c05f3a0:	3fad0761 c550b901 5ef42640 97ee7299     a..?..P.@&.^.r..
 c05f3b0:	273e662c 17afbd17 579b4468 98f54449     ,f>'....hD.WID..
 c05f3c0:	2c7d1bd9 5c8a5fb4 9a3bc004 39296a78     ..},._.\..;.xj)9
 c05f3d0:	00000118                                ....

0c05f3d4 <secp521r1_gx>:
 c05f3d4:	c2e5bd66 f97e7e31 856a429b 3348b3c1     f...1~~..Bj...H3
 c05f3e4:	a2ffa8de fe1dc127 efe75928 a14b5e77     ....'...(Y..w^K.
 c05f3f4:	6b4d3dba f828af60 053fb521 9c648139     .=Mk`.(.!.?.9.d.
 c05f404:	2395b442 9e3ecb66 0404e9cd 858e06b7     B..#f.>.........
 c05f414:	000000c6                                ....

0c05f418 <secp521r1_b>:
 c05f418:	6b503f00 ef451fd4 3d2c34f1 3573df88     .?Pk..E..4,=..s5
 c05f428:	3bb1bf07 1652c0bd ec7e937b 56193951     ...;..R.{.~.Q9.V
 c05f438:	8ef109e1 b8b48991 99b315f3 a2da725b     ............[r..
 c05f448:	b68540ee 929a21a0 8e1c9a1f 953eb961     .@...!......a.>.
 c05f458:	00000051                                Q...

0c05f45c <secp521r1_p>:
 c05f45c:	ffffffff ffffffff ffffffff ffffffff     ................
 c05f46c:	ffffffff ffffffff ffffffff ffffffff     ................
 c05f47c:	ffffffff ffffffff ffffffff ffffffff     ................
 c05f48c:	ffffffff ffffffff ffffffff ffffffff     ................
 c05f49c:	000001ff                                ....

0c05f4a0 <secp384r1_n>:
 c05f4a0:	ccc52973 ecec196a 48b0a77a 581a0db2     s)..j...z..H...X
 c05f4b0:	f4372ddf c7634d81 ffffffff ffffffff     .-7..Mc.........
 c05f4c0:	ffffffff ffffffff ffffffff ffffffff     ................

0c05f4d0 <secp384r1_gy>:
 c05f4d0:	90ea0e5f 7a431d7c 1d7e819d 0a60b1ce     _...|.Cz..~...`.
 c05f4e0:	b5f0b8c0 e9da3113 289a147c f8f41dbd     .....1..|..(....
 c05f4f0:	9292dc29 5d9e98bf 96262c6f 3617de4a     )......]o,&.J..6

0c05f500 <secp384r1_gx>:
 c05f500:	72760ab7 3a545e38 bf55296c 5502f25d     ..vr8^T:l)U.]..U
 c05f510:	82542a38 59f741e0 8ba79b98 6e1d3b62     8*T..A.Y....b;.n
 c05f520:	f320ad74 8eb1c71e be8b0537 aa87ca22     t. .....7..."...

0c05f530 <secp384r1_b>:
 c05f530:	d3ec2aef 2a85c8ed 8a2ed19d c656398d     .*.....*.....9V.
 c05f540:	5013875a 0314088f fe814112 181d9c6e     Z..P.....A..n...
 c05f550:	e3f82d19 988e056b e23ee7e4 b3312fa7     .-..k.....>../1.

0c05f560 <secp384r1_p>:
 c05f560:	ffffffff 00000000 00000000 ffffffff     ................
 c05f570:	fffffffe ffffffff ffffffff ffffffff     ................
 c05f580:	ffffffff ffffffff ffffffff ffffffff     ................

0c05f590 <secp256r1_n>:
 c05f590:	fc632551 f3b9cac2 a7179e84 bce6faad     Q%c.............
 c05f5a0:	ffffffff ffffffff 00000000 ffffffff     ................

0c05f5b0 <secp256r1_gy>:
 c05f5b0:	37bf51f5 cbb64068 6b315ece 2bce3357     .Q.7h@...^1kW3.+
 c05f5c0:	7c0f9e16 8ee7eb4a fe1a7f9b 4fe342e2     ...|J........B.O

0c05f5d0 <secp256r1_gx>:
 c05f5d0:	d898c296 f4a13945 2deb33a0 77037d81     ....E9...3.-.}.w
 c05f5e0:	63a440f2 f8bce6e5 e12c4247 6b17d1f2     .@.c....GB,....k

0c05f5f0 <secp256r1_b>:
 c05f5f0:	27d2604b 3bce3c3e cc53b0f6 651d06b0     K`.'><.;..S....e
 c05f600:	769886bc b3ebbd55 aa3a93e7 5ac635d8     ...vU.....:..5.Z

0c05f610 <secp256r1_p>:
 c05f610:	ffffffff ffffffff ffffffff 00000000     ................
	...
 c05f628:	00000001 ffffffff                       ........

0c05f630 <secp224r1_n>:
 c05f630:	5c5c2a3d 13dd2945 e0b8f03e ffff16a2     =*\\E)..>.......
 c05f640:	ffffffff ffffffff ffffffff              ............

0c05f64c <secp224r1_gy>:
 c05f64c:	85007e34 44d58199 5a074764 cd4375a0     4~.....DdG.Z.uC.
 c05f65c:	4c22dfe6 b5f723fb bd376388              .."L.#...c7.

0c05f668 <secp224r1_gx>:
 c05f668:	115c1d21 343280d6 56c21122 4a03c1d3     !.\...24"..V...J
 c05f678:	321390b9 6bb4bf7f b70e0cbd              ...2...k....

0c05f684 <secp224r1_b>:
 c05f684:	2355ffb4 270b3943 d7bfd8ba 5044b0b7     ..U#C9.'......DP
 c05f694:	f5413256 0c04b3ab b4050a85              V2A.........

0c05f6a0 <secp224r1_p>:
 c05f6a0:	00000001 00000000 00000000 ffffffff     ................
 c05f6b0:	ffffffff ffffffff ffffffff 00000000     ................

0c05f6c0 <secp192r1_n>:
 c05f6c0:	b4d22831 146bc9b1 99def836 ffffffff     1(....k.6.......
 c05f6d0:	ffffffff ffffffff                       ........

0c05f6d8 <secp192r1_gy>:
 c05f6d8:	1e794811 73f977a1 6b24cdd5 631011ed     .Hy..w.s..$k...c
 c05f6e8:	ffc8da78 07192b95                       x....+..

0c05f6f0 <secp192r1_gx>:
 c05f6f0:	82ff1012 f4ff0afd 43a18800 7cbf20eb     ...........C. .|
 c05f700:	b03090f6 188da80e                       ..0.....

0c05f708 <secp192r1_b>:
 c05f708:	c146b9b1 feb8deec 72243049 0fa7e9ab     ..F.....I0$r....
 c05f718:	e59c80e7 64210519                       ......!d

0c05f720 <secp192r1_p>:
 c05f720:	ffffffff ffffffff fffffffe ffffffff     ................
 c05f730:	ffffffff ffffffff                       ........

0c05f738 <last4>:
	...
 c05f740:	00001c20 00000000 00003840 00000000      .......@8......
 c05f750:	00002460 00000000 00007080 00000000     `$.......p......
 c05f760:	00006ca0 00000000 000048c0 00000000     .l.......H......
 c05f770:	000054e0 00000000 0000e100 00000000     .T..............
 c05f780:	0000fd20 00000000 0000d940 00000000      .......@.......
 c05f790:	0000c560 00000000 00009180 00000000     `...............
 c05f7a0:	00008da0 00000000 0000a9c0 00000000     ................
 c05f7b0:	0000b5e0 00000000                       ........

0c05f7b8 <TFM_Driver_USART0>:
 c05f7b8:	0c04e4ad 0c04e4cd 0c04e549 0c04e4d1     ........I.......
 c05f7c8:	0c04e4d5 0c04e525 0c04e505 0c04e4d9     ....%...........
 c05f7d8:	0c04e4df 0c04e609 0c04e4e3 0c04e4e7     ................
 c05f7e8:	0c04e4f3 0c04e4f9                       ........

0c05f7f0 <DriverVersion>:
 c05f7f0:	02020203                                ....

0c05f7f4 <TFM_Driver_FLASH0>:
 c05f7f4:	0c04e641 0c04e661 0c04e699 0c04e665     A...a.......e...
 c05f804:	0c04e669 0c04e6e1 0c04e75d 0c04e855     i.......]...U...
 c05f814:	0c04e67f 0c04e685 0c04e691              ............

0c05f820 <ARM_FLASH0_DEV_DATA>:
 c05f820:	00000000 00000100 00002000 00002000     ......... ... ..
 c05f830:	00000010 000000ff                       ........

0c05f838 <DriverVersion>:
 c05f838:	01000201                                ....

0c05f83c <nv_counter_access_map>:
 c05f83c:	00000100 00000100 00000100 72616f42     ............Boar
 c05f84c:	52203a64 43207665 0a0d3230 616f4200     d: Rev C02...Boa
 c05f85c:	203a6472 20766552 0d313044 0000000a     rd: Rev D01.....

0c05f86c <sau_init_cfg>:
 c05f86c:	00000000 08068400 081ddfff 00000000     ................
 c05f87c:	000165ba 00066cc7 00037d16 0007398d     .e...l...}...9..
 c05f88c:	00000001 20000000 2002ffff 00000000     ....... ... ....
 c05f89c:	00017ba4 00071763 0003ae3a 000497b7     .{..c...:.......
 c05f8ac:	00000002 20048000 28003fff 00000000     ....... .?.(....
 c05f8bc:	00018799 000690fa 0003b1da 0007266d     ............m&..
 c05f8cc:	00000003 0c065c80 0c065ce0 00000001     .....\...\......
 c05f8dc:	00019987 0007097d 0003bdb1 00049bdc     ....}...........
 c05f8ec:	00000004 40000000 4fffffff 00000000     .......@...O....
 c05f8fc:	0000cccd 0007c5b0 0000fdc2 0004661e     .............f..
 c05f90c:	00000005 0bfa0500 0bfa14ff 00000000     ................
 c05f91c:	0000d2d3 00071763 00012cd3 00054acd     ....c....,...J..

0c05f92c <memory_regions>:
 c05f92c:	08068400 08068400 081ddfff 0c065c80     .............\..
 c05f93c:	0c065ce0 500220d0 500220d4 500220d8     .\... .P. .P. .P
 c05f94c:	500220dc 500220f0 500220f4 500220f8     . .P. .P. .P. .P
 c05f95c:	500220fc                                . .P

0c05f960 <region_cfg_init_s>:
 c05f960:	00000000 08000000 08107fdf 00000003     ................
 c05f970:	00000201 00006787 00065c00 0001d0ee     .....g...\......
 c05f980:	00077cb8 00000001 08107fe0 0c037fff     .|..............
 c05f990:	00000003 00000001 00007999 00062599     .........y...%..
 c05f9a0:	0001e1e1 00069d59 00000002 0c038000     ....Y...........
 c05f9b0:	0c03bfff 00000002 00000200 0000aab5     ................
 c05f9c0:	00068f2c 0001ffff 000762a6 00000003     ,........b......
 c05f9d0:	0c03c000 0c065cdf 00000001 00000300     .....\..........
 c05f9e0:	0000b4ab 00063b87 00023bd7 00055971     .....;...;..qY..
 c05f9f0:	00000004 0c067fc0 3002ffff 00000002     ...........0....
 c05fa00:	00000001 0002f6e5 0004cd62 000316fb     ........b.......
 c05fa10:	00064f8a 00000005 30030000 3003e9ff     .O.........0...0
 c05fa20:	00000002 00000001 0002fa8e 000637ec     .............7..
 c05fa30:	000362f6 00052d7c 00000006 3003ea00     .b..|-.........0
 c05fa40:	30047fff 00000002 00000101 0001b768     ...0........h...
 c05fa50:	00078084 0001e01f 0004cd63 00000007     ........c.......
 c05fa60:	40000000 5fffffff 00000003 00000101     ...@..._........
 c05fa70:	0001cf0e 00064f8a 0001fe01 00053362     .....O......b3..
 c05fa80:	ffffff01 ffffffff ffffffff ffffffff     ................
 c05fa90:	00000000                                ....

0c05fa94 <MSIRangeTable>:
 c05fa94:	02dc6c00 016e3600 00f42400 00b71b00     .l...6n..$......
 c05faa4:	003d0900 001e8480 0016e360 000f4240     ..=.....`...@B..
 c05fab4:	002ee000 00177000 000fa000 000bb800     .....p..........
 c05fac4:	00061a80 00030d40 000249f0 000186a0     ....@....I......

0c05fad4 <APBPrescTable>:
 c05fad4:	00000000 04030201                       ........

0c05fadc <AHBPrescTable>:
	...
 c05fae4:	04030201 09080706 00000000 ff000000     ................
 c05faf4:	ffff0000 ffffff00 00000000 0000ff00     ................
 c05fb04:	0000ffff ff00ffff 00000000 000000ff     ................
 c05fb14:	0000ffff 00ffffff                       ........

0c05fb1c <LPGPIO_Map>:
 c05fb1c:	52020000 00000001 52020000 00000003     ...R.......R....
 c05fb2c:	52020000 00000006 52020400 00000001     ...R.......R....
 c05fb3c:	52020400 0000000a 52020800 00000002     ...R.......R....
 c05fb4c:	52020c00 0000000d 52020c00 00000002     ...R.......R....
 c05fb5c:	52020800 0000000a 52020400 00000000     ...R.......R....
 c05fb6c:	52020800 0000000c 52020400 00000003     ...R.......R....
 c05fb7c:	52020400 00000004 52021000 00000000     ...R.......R....
 c05fb8c:	52021000 00000002 52021000 00000003     ...R.......R....

0c05fb9c <UARTPrescTable>:
 c05fb9c:	00020001 00060004 000a0008 0010000c     ................
 c05fbac:	00400020 01000080                        .@.....

0c05fbb4 <small_prime>:
 c05fbb4:	00000003 00000005 00000007 0000000b     ................
 c05fbc4:	0000000d 00000011 00000013 00000017     ................
 c05fbd4:	0000001d 0000001f 00000025 00000029     ........%...)...
 c05fbe4:	0000002b 0000002f 00000035 0000003b     +.../...5...;...
 c05fbf4:	0000003d 00000043 00000047 00000049     =...C...G...I...
 c05fc04:	0000004f 00000053 00000059 00000061     O...S...Y...a...
 c05fc14:	00000065 00000067 0000006b 0000006d     e...g...k...m...
 c05fc24:	00000071 0000007f 00000083 00000089     q...............
 c05fc34:	0000008b 00000095 00000097 0000009d     ................
 c05fc44:	000000a3 000000a7 000000ad 000000b3     ................
 c05fc54:	000000b5 000000bf 000000c1 000000c5     ................
 c05fc64:	000000c7 000000d3 000000df 000000e3     ................
 c05fc74:	000000e5 000000e9 000000ef 000000f1     ................
 c05fc84:	000000fb 00000101 00000107 0000010d     ................
 c05fc94:	0000010f 00000115 00000119 0000011b     ................
 c05fca4:	00000125 00000133 00000137 00000139     %...3...7...9...
 c05fcb4:	0000013d 0000014b 00000151 0000015b     =...K...Q...[...
 c05fcc4:	0000015d 00000161 00000167 0000016f     ]...a...g...o...
 c05fcd4:	00000175 0000017b 0000017f 00000185     u...{...........
 c05fce4:	0000018d 00000191 00000199 000001a3     ................
 c05fcf4:	000001a5 000001af 000001b1 000001b7     ................
 c05fd04:	000001bb 000001c1 000001c9 000001cd     ................
 c05fd14:	000001cf 000001d3 000001df 000001e7     ................
 c05fd24:	000001eb 000001f3 000001f7 000001fd     ................
 c05fd34:	00000209 0000020b 0000021d 00000223     ............#...
 c05fd44:	0000022d 00000233 00000239 0000023b     -...3...9...;...
 c05fd54:	00000241 0000024b 00000251 00000257     A...K...Q...W...
 c05fd64:	00000259 0000025f 00000265 00000269     Y..._...e...i...
 c05fd74:	0000026b 00000277 00000281 00000283     k...w...........
 c05fd84:	00000287 0000028d 00000293 00000295     ................
 c05fd94:	000002a1 000002a5 000002ab 000002b3     ................
 c05fda4:	000002bd 000002c5 000002cf 000002d7     ................
 c05fdb4:	000002dd 000002e3 000002e7 000002ef     ................
 c05fdc4:	000002f5 000002f9 00000301 00000305     ................
 c05fdd4:	00000313 0000031d 00000329 0000032b     ........)...+...
 c05fde4:	00000335 00000337 0000033b 0000033d     5...7...;...=...
 c05fdf4:	00000347 00000355 00000359 0000035b     G...U...Y...[...
 c05fe04:	0000035f 0000036d 00000371 00000373     _...m...q...s...
 c05fe14:	00000377 0000038b 0000038f 00000397     w...............
 c05fe24:	000003a1 000003a9 000003ad 000003b3     ................
 c05fe34:	000003b9 000003c7 000003cb 000003d1     ................
 c05fe44:	000003d7 000003df 000003e5 ffffff99     ................

0c05fe54 <mbedtls_cipher_definitions>:
 c05fe54:	00000002 0c06028c 00000003 0c060270     ............p...
 c05fe64:	00000004 0c060254 00000005 0c060238     ....T.......8...
 c05fe74:	00000006 0c06021c 00000007 0c060200     ................
 c05fe84:	00000008 0c0601e4 00000009 0c0601c8     ................
 c05fe94:	0000000a 0c0601ac 00000043 0c060190     ........C.......
 c05fea4:	00000044 0c060174 00000045 0c060158     D...t...E...X...
 c05feb4:	0000000b 0c06013c 0000000c 0c060120     ....<....... ...
 c05fec4:	0000000d 0c060104 0000000e 0c0600c0     ................
 c05fed4:	0000000f 0c0600a4 00000010 0c060088     ................
 c05fee4:	0000002b 0c060044 0000002c 0c060028     +...D...,...(...
 c05fef4:	0000002d 0c06000c 00000000 00000000     -...............
 c05ff04:	2d534541 2d363532 004d4343 2d534541     AES-256-CCM.AES-
 c05ff14:	2d323931 004d4343 2d534541 2d383231     192-CCM.AES-128-
 c05ff24:	004d4343 2d534541 2d363532 004d4347     CCM.AES-256-GCM.
 c05ff34:	2d534541 2d323931 004d4347 2d534541     AES-192-GCM.AES-
 c05ff44:	2d383231 004d4347 2d534541 2d363532     128-GCM.AES-256-
 c05ff54:	00525443 2d534541 2d323931 00525443     CTR.AES-192-CTR.
 c05ff64:	2d534541 2d383231 00525443 2d534541     AES-128-CTR.AES-
 c05ff74:	2d363532 0042464f 2d534541 2d323931     256-OFB.AES-192-
 c05ff84:	0042464f 2d534541 2d383231 0042464f     OFB.AES-128-OFB.
 c05ff94:	2d534541 2d363532 31424643 41003832     AES-256-CFB128.A
 c05ffa4:	312d5345 432d3239 32314246 45410038     ES-192-CFB128.AE
 c05ffb4:	32312d53 46432d38 38323142 53454100     S-128-CFB128.AES
 c05ffc4:	3635322d 4342432d 53454100 3239312d     -256-CBC.AES-192
 c05ffd4:	4342432d 53454100 3832312d 4342432d     -CBC.AES-128-CBC
 c05ffe4:	53454100 3635322d 4243452d 53454100     .AES-256-ECB.AES
 c05fff4:	3239312d 4243452d 53454100 3832312d     -192-ECB.AES-128
 c060004:	4243452d 00000000                       -ECB....

0c06000c <aes_256_ccm_info>:
 c06000c:	0000082d 00000100 0c05ff04 0000000c     -...............
 c06001c:	00000001 00000010 0c060060              ........`...

0c060028 <aes_192_ccm_info>:
 c060028:	0000082c 000000c0 0c05ff10 0000000c     ,...............
 c060038:	00000001 00000010 0c060060              ........`...

0c060044 <aes_128_ccm_info>:
 c060044:	0000082b 00000080 0c05ff1c 0000000c     +...............
 c060054:	00000001 00000010 0c060060              ........`...

0c060060 <ccm_aes_info>:
 c060060:	00000002 00000000 00000000 00000000     ................
	...
 c060078:	0c055451 0c055451 0c05543b 0c055429     QT..QT..;T..)T..

0c060088 <aes_256_gcm_info>:
 c060088:	00000610 00000100 0c05ff28 0000000c     ........(.......
 c060098:	00000001 00000010 0c0600dc              ............

0c0600a4 <aes_192_gcm_info>:
 c0600a4:	0000060f 000000c0 0c05ff34 0000000c     ........4.......
 c0600b4:	00000001 00000010 0c0600dc              ............

0c0600c0 <aes_128_gcm_info>:
 c0600c0:	0000060e 00000080 0c05ff40 0000000c     ........@.......
 c0600d0:	00000001 00000010 0c0600dc              ............

0c0600dc <gcm_aes_info>:
 c0600dc:	00000002 00000000 00000000 00000000     ................
	...
 c0600f4:	0c055485 0c055485 0c05546d 0c05545b     .T...T..mT..[T..

0c060104 <aes_256_ctr_info>:
 c060104:	0000050d 00000100 0c05ff4c 00000010     ........L.......
 c060114:	00000000 00000010 0c0602a8              ............

0c060120 <aes_192_ctr_info>:
 c060120:	0000050c 000000c0 0c05ff58 00000010     ........X.......
 c060130:	00000000 00000010 0c0602a8              ............

0c06013c <aes_128_ctr_info>:
 c06013c:	0000050b 00000080 0c05ff64 00000010     ........d.......
 c06014c:	00000000 00000010 0c0602a8              ............

0c060158 <aes_256_ofb_info>:
 c060158:	00000445 00000100 0c05ff70 00000010     E.......p.......
 c060168:	00000000 00000010 0c0602a8              ............

0c060174 <aes_192_ofb_info>:
 c060174:	00000444 000000c0 0c05ff7c 00000010     D.......|.......
 c060184:	00000000 00000010 0c0602a8              ............

0c060190 <aes_128_ofb_info>:
 c060190:	00000443 00000080 0c05ff88 00000010     C...............
 c0601a0:	00000000 00000010 0c0602a8              ............

0c0601ac <aes_256_cfb128_info>:
 c0601ac:	0000030a 00000100 0c05ff94 00000010     ................
 c0601bc:	00000000 00000010 0c0602a8              ............

0c0601c8 <aes_192_cfb128_info>:
 c0601c8:	00000309 000000c0 0c05ffa3 00000010     ................
 c0601d8:	00000000 00000010 0c0602a8              ............

0c0601e4 <aes_128_cfb128_info>:
 c0601e4:	00000308 00000080 0c05ffb2 00000010     ................
 c0601f4:	00000000 00000010 0c0602a8              ............

0c060200 <aes_256_cbc_info>:
 c060200:	00000207 00000100 0c05ffc1 00000010     ................
 c060210:	00000000 00000010 0c0602a8              ............

0c06021c <aes_192_cbc_info>:
 c06021c:	00000206 000000c0 0c05ffcd 00000010     ................
 c06022c:	00000000 00000010 0c0602a8              ............

0c060238 <aes_128_cbc_info>:
 c060238:	00000205 00000080 0c05ffd9 00000010     ................
 c060248:	00000000 00000010 0c0602a8              ............

0c060254 <aes_256_ecb_info>:
 c060254:	00000104 00000100 0c05ffe5 00000000     ................
 c060264:	00000000 00000010 0c0602a8              ............

0c060270 <aes_192_ecb_info>:
 c060270:	00000103 000000c0 0c05fff1 00000000     ................
 c060280:	00000000 00000010 0c0602a8              ............

0c06028c <aes_128_ecb_info>:
 c06028c:	00000102 00000080 0c05fffd 00000000     ................
 c06029c:	00000000 00000010 0c0602a8              ............

0c0602a8 <aes_info>:
 c0602a8:	00000002 0c0554cf 0c0554cb 0c0554c7     .....T...T...T..
 c0602b8:	0c0554c3 0c0554bf 0c0554bb 0c0554b7     .T...T...T...T..
 c0602c8:	0c0554a1 0c05548f                       .T...T..

0c0602d0 <CSWTCH.2>:
 c0602d0:	0c0602f8 0c0602f0 0c0602e8 0c0602e0     ................

0c0602e0 <mbedtls_sha512_info>:
 c0602e0:	0c060642 00804008                       B....@..

0c0602e8 <mbedtls_sha384_info>:
 c0602e8:	0c060615 00803007                       .....0..

0c0602f0 <mbedtls_sha256_info>:
 c0602f0:	0c0605e8 00402006                       ..... @.

0c0602f8 <mbedtls_sha224_info>:
 c0602f8:	0c0605bb 00401c05 8648862a 08020df7     ......@.*.H.....
 c060308:	616d6800 41485363 00343232 43414d48     .hmacSHA224.HMAC
 c060318:	4148532d 3432322d 48862a00 020df786     -SHA-224.*.H....
 c060328:	6d680009 48536361 36353241 414d4800     ..hmacSHA256.HMA
 c060338:	48532d43 35322d41 862a0036 0df78648     C-SHA-256.*.H...
 c060348:	68000a02 5363616d 38334148 4d480034     ...hmacSHA384.HM
 c060358:	532d4341 332d4148 2a003438 f7864886     AC-SHA-384.*.H..
 c060368:	000b020d 63616d68 35414853 48003231     ....hmacSHA512.H
 c060378:	2d43414d 2d414853 00323135 01488660     MAC-SHA-512.`.H.
 c060388:	02040365 64690004 6168732d 00343232     e.....id-sha224.
 c060398:	01488660 02040365 64690001 6168732d     `.H.e.....id-sha
 c0603a8:	00363532 01488660 02040365 64690002     256.`.H.e.....id
 c0603b8:	6168732d 00343833 01488660 02040365     -sha384.`.H.e...
 c0603c8:	64690003 6168732d 00323135 02030e2b     ..id-sha512.+...
 c0603d8:	65640007 43424373 53454400 4342432d     ..desCBC.DES-CBC
 c0603e8:	48862a00 030df786 65640007 64652d73     .*.H......des-ed
 c0603f8:	632d3365 44006362 452d5345 2d334544     e3-cbc.DES-EDE3-
 c060408:	00434243 ce48862a 0101033d 48862a00     CBC.*.H.=....*.H
 c060418:	01033dce 242b0007 08020303 00070101     .=....+$........
 c060428:	69617262 6f6f706e 3635326c 2b003172     brainpool256r1.+
 c060438:	02030324 0b010108 61726200 6f706e69     $........brainpo
 c060448:	38336c6f 00317234 0303242b 01010802     ol384r1.+$......
 c060458:	7262000d 706e6961 356c6f6f 31723231     ..brainpool512r1
 c060468:	48862a00 010df786 72000101 6e456173     .*.H.......rsaEn
 c060478:	70797263 6e6f6974 41535200 48862a00     cryption.RSA.*.H
 c060488:	01023dce 2d646900 75506365 63696c62     .=...id-ecPublic
 c060498:	0079654b 656e6547 20636972 6b204345     Key.Generic EC k
 c0604a8:	2b007965 0c010481 2d646900 48446365     ey.+.....id-ecDH
 c0604b8:	20434500 2079656b 20726f66 48444345     .EC key for ECDH
 c0604c8:	48862a00 010df786 73000e01 32326168     .*.H.......sha22
 c0604d8:	74695734 41535268 72636e45 69747079     4WithRSAEncrypti
 c0604e8:	52006e6f 77204153 20687469 2d414853     on.RSA with SHA-
 c0604f8:	00343232 8648862a 01010df7 6873000b     224.*.H.......sh
 c060508:	36353261 68746957 45415352 7972636e     a256WithRSAEncry
 c060518:	6f697470 5352006e 69772041 53206874     ption.RSA with S
 c060528:	322d4148 2a003635 f7864886 0c01010d     HA-256.*.H......
 c060538:	61687300 57343833 52687469 6e454153     .sha384WithRSAEn
 c060548:	70797263 6e6f6974 41535200 74697720     cryption.RSA wit
 c060558:	48532068 38332d41 862a0034 0df78648     h SHA-384.*.H...
 c060568:	000d0101 35616873 69573231 53526874     ....sha512WithRS
 c060578:	636e4541 74707972 006e6f69 20415352     AEncryption.RSA 
 c060588:	68746977 41485320 3231352d 48862a00     with SHA-512.*.H
 c060598:	03043dce 63650001 2d617364 68746977     .=....ecdsa-with
 c0605a8:	4148532d 00343232 53444345 69772041     -SHA224.ECDSA wi
 c0605b8:	53206874 32324148 862a0034 043dce48     th SHA224.*.H.=.
 c0605c8:	65000203 61736463 7469772d 48532d68     ...ecdsa-with-SH
 c0605d8:	36353241 44434500 77204153 20687469     A256.ECDSA with 
 c0605e8:	32414853 2a003635 3dce4886 00030304     SHA256.*.H.=....
 c0605f8:	73646365 69772d61 532d6874 38334148     ecdsa-with-SHA38
 c060608:	43450034 20415344 68746977 41485320     4.ECDSA with SHA
 c060618:	00343833 ce48862a 0403043d 64636500     384.*.H.=....ecd
 c060628:	772d6173 2d687469 35414853 45003231     sa-with-SHA512.E
 c060638:	41534443 74697720 48532068 32313541     CDSA with SHA512
 c060648:	48862a00 010df786 52000a01 53534153     .*.H.......RSASS
 c060658:	53502d41 6e610053 6c6f5079 00796369     A-PSS.anyPolicy.
 c060668:	20796e41 696c6f50 2b007963 05050106     Any Policy.+....
 c060678:	00010307 6b2d6469 65732d70 72657672     ....id-kp-server
 c060688:	68747541 534c5400 62655720 72655320     Auth.TLS Web Ser
 c060698:	20726576 68747541 69746e65 69746163     ver Authenticati
 c0606a8:	2b006e6f 05050106 00020307 6b2d6469     on.+........id-k
 c0606b8:	6c632d70 746e6569 68747541 534c5400     p-clientAuth.TLS
 c0606c8:	62655720 696c4320 20746e65 68747541      Web Client Auth
 c0606d8:	69746e65 69746163 2b006e6f 05050106     entication.+....
 c0606e8:	00030307 6b2d6469 6f632d70 69536564     ....id-kp-codeSi
 c0606f8:	6e696e67 6f430067 53206564 696e6769     gning.Code Signi
 c060708:	2b00676e 05050106 00040307 6b2d6469     ng.+........id-k
 c060718:	6d652d70 506c6961 65746f72 6f697463     p-emailProtectio
 c060728:	2d45006e 6c69616d 6f725020 74636574     n.E-mail Protect
 c060738:	006e6f69 0501062b 08030705 2d646900     ion.+........id-
 c060748:	742d706b 53656d69 706d6174 00676e69     kp-timeStamping.
 c060758:	656d6954 61745320 6e69706d 062b0067     Time Stamping.+.
 c060768:	07050501 69000903 706b2d64 53434f2d     .......id-kp-OCS
 c060778:	67695350 676e696e 53434f00 69532050     PSigning.OCSP Si
 c060788:	6e696e67 062b0067 82010401 000125e4     gning.+......%..
 c060798:	6b2d6469 69772d70 2d6e7573 2d6e6166     id-kp-wisun-fan-
 c0607a8:	69766564 57006563 55532d69 6c41204e     device.Wi-SUN Al
 c0607b8:	6e61696c 46206563 646c6569 65724120     liance Field Are
 c0607c8:	654e2061 726f7774 4628206b 00294e41     a Network (FAN).
 c0607d8:	00131d55 632d6469 61622d65 43636973     U...id-ce-basicC
 c0607e8:	74736e6f 6e696172 42007374 63697361     onstraints.Basic
 c0607f8:	6e6f4320 61727473 73746e69 0f1d5500      Constraints.U..
 c060808:	2d646900 6b2d6563 73557965 00656761     .id-ce-keyUsage.
 c060818:	00251d55 632d6469 78652d65 79654b74     U.%.id-ce-extKey
 c060828:	67617355 78450065 646e6574 4b206465     Usage.Extended K
 c060838:	55207965 65676173 111d5500 2d646900     ey Usage.U...id-
 c060848:	732d6563 656a6275 6c417463 6d614e74     ce-subjectAltNam
 c060858:	75530065 63656a62 6c412074 614e2074     e.Subject Alt Na
 c060868:	6000656d 86014886 010142f8 2d646900     me.`.H...B...id-
 c060878:	7374656e 65706163 7265632d 70797474     netscape-certtyp
 c060888:	654e0065 61637374 43206570 69747265     e.Netscape Certi
 c060898:	61636966 54206574 00657079 00201d55     ficate Type.U. .
 c0608a8:	632d6469 65632d65 66697472 74616369     id-ce-certificat
 c0608b8:	6c6f5065 65696369 65430073 66697472     ePolicies.Certif
 c0608c8:	74616369 6f502065 6963696c 55007365     icate Policies.U
 c0608d8:	69000304 74612d64 6d6f632d 4e6e6f6d     ...id-at-commonN
 c0608e8:	00656d61 6d6d6f43 4e206e6f 00656d61     ame.Common Name.
 c0608f8:	55004e43 69000604 74612d64 756f632d     CN.U...id-at-cou
 c060908:	7972746e 656d614e 756f4300 7972746e     ntryName.Country
 c060918:	07045500 2d646900 6c2d7461 6c61636f     .U...id-at-local
 c060928:	00797469 61636f4c 7974696c 08045500     ity.Locality.U..
 c060938:	2d646900 732d7461 65746174 61745300     .id-at-state.Sta
 c060948:	53006574 04550054 6469000a 2d74612d     te.ST.U...id-at-
 c060958:	6167726f 617a696e 6e6f6974 656d614e     organizationName
 c060968:	67724f00 7a696e61 6f697461 0455006e     .Organization.U.
 c060978:	6469000b 2d74612d 6167726f 617a696e     ..id-at-organiza
 c060988:	6e6f6974 6e556c61 614e7469 4f00656d     tionalUnitName.O
 c060998:	55206772 0074696e 2a00554f f7864886     rg Unit.OU.*.H..
 c0609a8:	0109010d 616d6500 64416c69 73657264     .....emailAddres
 c0609b8:	2d450073 6c69616d 64646120 73736572     s.E-mail address
 c0609c8:	05045500 2d646900 732d7461 61697265     .U...id-at-seria
 c0609d8:	6d754e6c 00726562 69726553 6e206c61     lNumber.Serial n
 c0609e8:	65626d75 04550072 64690010 2d74612d     umber.U...id-at-
 c0609f8:	74736f70 64416c61 73657264 6f500073     postalAddress.Po
 c060a08:	6c617473 64646120 73736572 11045500     stal address.U..
 c060a18:	2d646900 702d7461 6174736f 646f436c     .id-at-postalCod
 c060a28:	6f500065 6c617473 646f6320 04550065     e.Postal code.U.
 c060a38:	64690004 2d74612d 4e727573 00656d61     ..id-at-surName.
 c060a48:	6e727553 00656d61 55004e53 69002a04     Surname.SN.U.*.i
 c060a58:	74612d64 7669672d 614e6e65 4700656d     d-at-givenName.G
 c060a68:	6e657669 6d616e20 4e470065 2b045500     iven name.GN.U.+
 c060a78:	2d646900 692d7461 6974696e 00736c61     .id-at-initials.
 c060a88:	74696e49 736c6169 2c045500 2d646900     Initials.U.,.id-
 c060a98:	672d7461 72656e65 6f697461 6175516e     at-generationQua
 c060aa8:	6966696c 47007265 72656e65 6f697461     lifier.Generatio
 c060ab8:	7571206e 66696c61 00726569 000c0455     n qualifier.U...
 c060ac8:	612d6469 69742d74 00656c74 6c746954     id-at-title.Titl
 c060ad8:	04550065 6469002e 2d74612d 75516e64     e.U...id-at-dnQu
 c060ae8:	66696c61 00726569 74736944 75676e69     alifier.Distingu
 c060af8:	65687369 614e2064 7120656d 696c6175     ished Name quali
 c060b08:	72656966 41045500 2d646900 702d7461     fier.U.A.id-at-p
 c060b18:	64756573 6d796e6f 65735000 6e6f6475     seudonym.Pseudon
 c060b28:	09006d79 93892692 01642cf2 64690019     ym...&...,d...id
 c060b38:	6d6f642d 436e6961 6f706d6f 746e656e     -domainComponent
 c060b48:	6d6f4400 206e6961 706d6f63 6e656e6f     .Domain componen
 c060b58:	43440074 2d045500 2d646900 752d7461     t.DC.U.-.id-at-u
 c060b68:	7571696e 65644965 6669746e 00726569     niqueIdentifier.
 c060b78:	71696e55 49206575 746e6564 65696669     Unique Identifie
 c060b88:	00000072                                r...

0c060b8c <oid_md_alg>:
 c060b8c:	0c060384 00000009 0c06038e 0c0604f4     ................
 c060b9c:	00000005 0c060398 00000009 0c0603a2     ................
 c060bac:	0c060527 00000006 0c0603ac 00000009     '...............
 c060bbc:	0c0603b6 0c06055a 00000007 0c0603c0     ....Z...........
 c060bcc:	00000009 0c0603ca 0c06058d 00000008     ................
	...

0c060bf0 <oid_ecp_grp>:
 c060bf0:	0c06040c 00000008 0c05ed4d 0c05ed4d     ........M...M...
 c060c00:	00000001 0c060d30 00000005 0c05ed39     ....0.......9...
 c060c10:	0c05ed39 00000002 0c060415 00000008     9...............
 c060c20:	0c05ed15 0c05ed15 00000003 0c060d36     ............6...
 c060c30:	00000005 0c05ecfb 0c05ecfb 00000004     ................
 c060c40:	0c060d3c 00000005 0c05ece1 0c05ece1     <...............
 c060c50:	00000005 0c060d42 00000005 0c05ed57     ....B.......W...
 c060c60:	0c05ed57 0000000a 0c060d48 00000005     W.......H.......
 c060c70:	0c05ed43 0c05ed43 0000000b 0c060d4e     C...C.......N...
 c060c80:	00000005 0c05ed1f 0c05ed1f 0000000c     ................
 c060c90:	0c06041e 00000009 0c05ed29 0c060428     ........)...(...
 c060ca0:	00000006 0c060437 00000009 0c05ed05     ....7...........
 c060cb0:	0c060441 00000007 0c060450 00000009     A.......P.......
 c060cc0:	0c05eceb 0c06045a 00000008 00000000     ....Z...........
	...

0c060ce0 <oid_pk_alg>:
 c060ce0:	0c060469 00000009 0c060473 0c060481     i.......s.......
 c060cf0:	00000001 0c060485 00000007 0c06048d     ................
 c060d00:	0c06049c 00000002 0c0604ab 00000005     ................
 c060d10:	0c0604b1 0c0604b9 00000003 00000000     ................
	...
 c060d30:	0004812b 812b0021 00220004 0004812b     +...!.+...".+...
 c060d40:	812b0023 001f0004 0004812b 812b0020     #.+.....+... .+.
 c060d50:	000a0004 00201d55 00000000              ....U. .....

0c060d5c <CSWTCH.7>:
 c060d5c:	0c060e28 0c060df8 0c060dc8 0c060d98     (...............
 c060d6c:	2e617372 7372004e 00452e61 656b6365     rsa.N.rsa.E.ecke
 c060d7c:	00512e79 2d415352 00746c61 53444345     y.Q.RSA-alt.ECDS
 c060d8c:	43450041 0048445f 00004345              A.EC_DH.EC..

0c060d98 <mbedtls_ecdsa_info>:
 c060d98:	00000004 0c060d88 0c056ea5 0c056ec9     .........n...n..
 c060da8:	0c0570bd 0c057071 00000000 00000000     .p..qp..........
 c060db8:	0c057045 0c057049 0c05705f 0c056ea9     Ep..Ip.._p...n..

0c060dc8 <mbedtls_eckeydh_info>:
 c060dc8:	00000003 0c060d8e 0c056ea5 0c056ebd     .........n...n..
	...
 c060de8:	0c057045 0c05702f 0c05701d 0c056ea9     Ep../p...p...n..

0c060df8 <mbedtls_eckey_info>:
 c060df8:	00000002 0c060d94 0c056ea5 0c056e99     .........n...n..
 c060e08:	0c0570dd 0c057075 00000000 00000000     .p..up..........
 c060e18:	0c057045 0c05702f 0c05701d 0c056ea9     Ep../p...p...n..

0c060e28 <mbedtls_rsa_info>:
 c060e28:	00000001 0c060481 0c056f01 0c056e67     .........o..gn..
 c060e38:	0c056fcd 0c056f95 0c056f51 0c056f0d     .o...o..Qo...o..
 c060e48:	0c056efd 0c056ee3 0c056ed1 0c056e75     .n...n...n..un..

0c060e58 <CSWTCH.452>:
 c060e58:	14141010 201c0000 201c4030 201c0000     ....... 0@. ... 
 c060e68:	00004030                                0@..

0c060e6c <mbedtls_psa_random_state>:
 c060e6c:	30031188                                ...0

0c060e70 <CSWTCH.23>:
 c060e70:	14141010 201c0000 201c4030 201c0000     ....... 0@. ... 
 c060e80:	00004030                                0@..

0c060e84 <CSWTCH.17>:
 c060e84:	0c0602f8 0c0602f0 0c0602e8 0c0602e0     ................

0c060e94 <CSWTCH.67>:
 c060e94:	40404040 40400000 80808080 88900000     @@@@..@@........
 c060ea4:	                                         hH

0c060ea6 <CSWTCH.64>:
 c060ea6:	14141010 201c0000 201c4030 201c0000     ....... 0@. ... 
 c060eb6:	53504030 454b0041 03020059 0d0b0705     0@PSA.KEY.......
 c060ec6:	1d171311 2b29251f 3d3b352f 4f494743     .....%)+/5;=CGIO
 c060ed6:	65615953 716d6b67 8b89837f a39d9795     SYaegkmq........
 c060ee6:	b5b3ada7 c7c5c1bf e5e3dfd3 fbf1efe9     ................
	...

0c060ef8 <K>:
 c060ef8:	d728ae22 428a2f98 23ef65cd 71374491     ".(../.B.e.#.D7q
 c060f08:	ec4d3b2f b5c0fbcf 8189dbbc e9b5dba5     /;M.............
 c060f18:	f348b538 3956c25b b605d019 59f111f1     8.H.[.V9.......Y
 c060f28:	af194f9b 923f82a4 da6d8118 ab1c5ed5     .O....?...m..^..
 c060f38:	a3030242 d807aa98 45706fbe 12835b01     B........opE.[..
 c060f48:	4ee4b28c 243185be d5ffb4e2 550c7dc3     ...N..1$.....}.U
 c060f58:	f27b896f 72be5d74 3b1696b1 80deb1fe     o.{.t].r...;....
 c060f68:	25c71235 9bdc06a7 cf692694 c19bf174     5..%.....&i.t...
 c060f78:	9ef14ad2 e49b69c1 384f25e3 efbe4786     .J...i...%O8.G..
 c060f88:	8b8cd5b5 0fc19dc6 77ac9c65 240ca1cc     ........e..w...$
 c060f98:	592b0275 2de92c6f 6ea6e483 4a7484aa     u.+Yo,.-...n..tJ
 c060fa8:	bd41fbd4 5cb0a9dc 831153b5 76f988da     ..A....\.S.....v
 c060fb8:	ee66dfab 983e5152 2db43210 a831c66d     ..f.RQ>..2.-m.1.
 c060fc8:	98fb213f b00327c8 beef0ee4 bf597fc7     ?!...'........Y.
 c060fd8:	3da88fc2 c6e00bf3 930aa725 d5a79147     ...=....%...G...
 c060fe8:	e003826f 06ca6351 0a0e6e70 14292967     o...Qc..pn..g)).
 c060ff8:	46d22ffc 27b70a85 5c26c926 2e1b2138     ./.F...'&.&\8!..
 c061008:	5ac42aed 4d2c6dfc 9d95b3df 53380d13     .*.Z.m,M......8S
 c061018:	8baf63de 650a7354 3c77b2a8 766a0abb     .c..Ts.e..w<..jv
 c061028:	47edaee6 81c2c92e 1482353b 92722c85     ...G....;5...,r.
 c061038:	4cf10364 a2bfe8a1 bc423001 a81a664b     d..L.....0B.Kf..
 c061048:	d0f89791 c24b8b70 0654be30 c76c51a3     ....p.K.0.T..Ql.
 c061058:	d6ef5218 d192e819 5565a910 d6990624     .R........eU$...
 c061068:	5771202a f40e3585 32bbd1b8 106aa070     * qW.5.....2p.j.
 c061078:	b8d2d0c8 19a4c116 5141ab53 1e376c08     ........S.AQ.l7.
 c061088:	df8eeb99 2748774c e19b48a8 34b0bcb5     ....LwH'.H.....4
 c061098:	c5c95a63 391c0cb3 e3418acb 4ed8aa4a     cZ.....9..A.J..N
 c0610a8:	7763e373 5b9cca4f d6b2b8a3 682e6ff3     s.cwO..[.....o.h
 c0610b8:	5defb2fc 748f82ee 43172f60 78a5636f     ...]...t`/.Coc.x
 c0610c8:	a1f0ab72 84c87814 1a6439ec 8cc70208     r....x...9d.....
 c0610d8:	23631e28 90befffa de82bde9 a4506ceb     (.c#.........lP.
 c0610e8:	b2c67915 bef9a3f7 e372532b c67178f2     .y......+Sr..xq.
 c0610f8:	ea26619c ca273ece 21c0c207 d186b8c7     .a&..>'....!....
 c061108:	cde0eb1e eada7dd6 ee6ed178 f57d4f7f     .....}..x.n..O}.
 c061118:	72176fba 06f067aa a2c898a6 0a637dc5     .o.r.g.......}c.
 c061128:	bef90dae 113f9804 131c471b 1b710b35     ......?..G..5.q.
 c061138:	23047d84 28db77f5 40c72493 32caab7b     .}.#.w.(.$.@{..2
 c061148:	15c9bebc 3c9ebe0a 9c100d4c 431d67c4     .......<L....g.C
 c061158:	cb3e42b6 4cc5d4be fc657e2a 597f299c     .B>....L*~e..).Y
 c061168:	3ad6faec 5fcb6fab 4a475817 6c44198c     ...:.o._.XGJ..Dl

0c061178 <CSWTCH.89>:
 c061178:	00050201                                ....

0c06117c <boot_img_magic>:
 c06117c:	f395c277 7fefd260 0f505235 8079b62c     w...`...5RP.,.y.
 c06118c:	5f45535b 41535453 5d414546 25203a20     [SE_STSAFEA] : %
 c06119c:	65530073 6e697474 61502067 6e697269     s.Setting Pairin
 c0611ac:	656b2067 6e692079 53206f74 46415354     g key into STSAF
 c0611bc:	31412d45 3a203031 0a4b4f00 4f4b000d     E-A110 :.OK...KO
 c0611cc:	2a2a2a20 25783020 000d0a78 58323025      *** 0x%x...%02X
 c0611dc:	20732500 6572203a 6e6f6967 64252020     .%s : region  %d
 c0611ec:	7561202c 25206874 25000a78 203a2073     , auth %x..%s : 
 c0611fc:	69676572 20206e6f 202c6425 7366666f     region  %d, offs
 c06120c:	25207465 73202c64 20657a69 65206425     et %d, size %d e
 c06121c:	726f7272 25203d20 25000a64 203a2073     rror = %d..%s : 
 c06122c:	69676572 20206e6f 202c6425 75706e69     region  %d, inpu
 c06123c:	75622074 72656666 25203d20 0d0a2070     t buffer = %p ..
 c06124c:	61745300 6e697472 54532067 45464153     .Starting STSAFE
 c06125c:	3131412d 203a2030 204f4b00 202a2a2a     -A110 : .KO *** 
 c06126c:	62616e55 7420656c 7473206f 20747261     Unable to start 
 c06127c:	41535453 412d4546 20303131 78257830     STSAFE-A110 0x%x
 c06128c:	47000d0a 53207465 61697265 003a206c     ...Get Serial :.
 c06129c:	2a204f4b 55202a2a 6c62616e 6f742065     KO *** Unable to
 c0612ac:	74656720 72657320 206c6169 78257830      get serial 0x%x
 c0612bc:	53000d0a 43207465 74707972 654b206f     ...Set Crypto Ke
 c0612cc:	3a207379 4f4b0020 2a2a2a20 74655320     ys : .KO *** Set
 c0612dc:	69617020 676e6972 79656b20 25783020      pairing key 0x%
 c0612ec:	000d0a78 61737453 54206566 69747365     x...Stsafe Testi
 c0612fc:	7020676e 69726961 6b20676e 20737965     ng pairing keys 
 c06130c:	4b00203a 2a2a204f 6e55202a 656c6261     : .KO *** Unable
 c06131c:	206f7420 70617277 766e6520 706f6c65      to wrap envelop
 c06132c:	74697720 54532068 45464153 3131412d      with STSAFE-A11
 c06133c:	78302030 0d0a7825 204f4b00 202a2a2a     0 0x%x...KO *** 
 c06134c:	62616e55 7420656c 6e75206f 70617277     Unable to unwrap
 c06135c:	766e6520 706f6c65 74697720 54532068      envelop with ST
 c06136c:	45464153 3131412d 78302030 0d0a7825     SAFE-A110 0x%x..
 c06137c:	204f4b00 61746164 656f6420 6f6e2073     .KO data does no
 c06138c:	616d2074 0a686374                        t match...

0c061396 <CSWTCH.40>:
 c061396:	30203020                                 0 0

0c06139a <__func__.3>:
 c06139a:	525f4553 00646165                       SE_Read.

0c0613a2 <CSWTCH.117>:
 c0613a2:	30203020                                 0 0

0c0613a6 <CSWTCH.116>:
 c0613a6:	65456545                                 EeEe..

0c0613ac <CSWTCH.115>:
 c0613ac:	0c0613ba 0c06041e 0c060437 812b0000     ........7.....+.
 c0613bc:	00220004                                ..".

0c0613c0 <CSWTCH.23>:
 c0613c0:	ff700000 ff7cff76                        ..p.v.|.y.

0c0613ca <CSWTCH.5>:
 c0613ca:	02200054 02c00188                        T. .......

0c0613d4 <sfid_func_table>:
 c0613d4:	0c03a95d 0c03a9c5 0c03a821 0c03a8ad     ].......!.......
 c0613e4:	0c03a75d 0c03a905 0c03aa21 0c03aa81     ].......!.......
 c0613f4:	0c03aae1 0c03ab39 0c03a36f 0c03a3b1     ....9...o.......
 c061404:	0c03a143 0c03a1a5 0c03a1f5 0c03a25f     C..........._...
 c061414:	0c03a2bd 0c03a319 0c03b399 0c03b39f     ................
 c061424:	0c03b115 0c03b19d 0c03b225 0c03b275     ........%...u...
 c061434:	0c03b2df 0c03b33d 0c03a137 0c03a13d     ....=...7...=...
 c061444:	0c039efd 0c039f83 0c039e4b 0c039eab     ........K.......
 c061454:	0c03a009 0c03a06d 0c03a0d9 0c0399c1     ....m...........
 c061464:	0c039a4b 0c039ad5 0c039adb 0c039aed     K...............
 c061474:	0c039af3 0c039af9 0c039b05 0c039aff     ................
 c061484:	0c039ae7 0c039b0b 0c039ae1 0c039c51     ............Q...
 c061494:	0c039cbb 0c039d1d 0c039dd5 0c03ac9d     ................
 c0614a4:	0c03ad11 0c03ad5d 0c03ad99 0c03ae85     ....]...........
 c0614b4:	0c03b011 0c03ae41 0c03aee1 0c03af81     ....A...........
 c0614c4:	0c03b0ab 0c03b07f 0c03ac01 0c03a751     ............Q...
 c0614d4:	0c03a757                                W...

0c0614d8 <flash_map>:
 c0614d8:	00006401 0c05f7f4 00038000 00030000     .d..............
 c0614e8:	00006403 0c05f7f4 0010a000 00030000     .d..............
 c0614f8:	00006402 0c05f7f4 00068000 000a0000     .d..............
 c061508:	00006404 0c05f7f4 0013a000 000a0000     .d..............
 c061518:	00006405 0c05f7f4 00036000 00002000     .d.......`... ..
 c061528:	00006407 0c05f7f4 001da000 00002000     .d........... ..
 c061538:	00006406 0c05f7f4 00108000 00002000     .d........... ..
 c061548:	00006408 0c05f7f4 001dc000 00002000     .d........... ..
 c061558:	00006409 0c05f7f4 00004000 00010000     .d.......@......

0c061568 <its_flash_fs_ops_nor>:
 c061568:	0c039715 0c039729 0c03974b 0c03976d     ....)...K...m...
 c061578:	0c039771 3b315b1b 5b6d3433 20636553     q....[1;34m[Sec 
 c061588:	65726854 205d6461 75636553 69206572     Thread] Secure i
 c061598:	6567616d 696e6920 6c616974 6e697a69     mage initializin
 c0615a8:	5b1b2167 0a0d6d30 2d465400 7369204d     g!.[0m...TF-M is
 c0615b8:	74616c6f 206e6f69 6576656c 7369206c     olation level is
 c0615c8:	1b00203a 333b315b 6f426d34 6e69746f     : ..[1;34mBootin
 c0615d8:	46542067 3176204d 302e332e 6d305b1b     g TFM v1.3.0.[0m
 c0615e8:	                                         ...

0c0615eb <ps_key_label>:
 c0615eb:	726f7473 5f656761 0079656b 00000000     storage_key.....
	...

0c061618 <aIterate.0>:
 c061618:	04020101 2079654b 6f6c6c61 69746163     ....Key allocati
 c061628:	63206e6f 6f6e6e61 706f2074 74617265     on cannot operat
 c061638:	69772065 6d206874 6f687465 203a2064     e with method : 
 c061648:	000a7825 69676552 25206e6f 756f2064     %x..Region %d ou
 c061658:	666f2074 6e617220 000a6567 69676552     t of range..Regi
 c061668:	25206e6f 6e752064 20726564 20656874     on %d under the 
 c061678:	676e6172 4b000a65 73207965 20746f6c     range..Key slot 
 c061688:	696c6176 69746164 63206e6f 6f6e6e61     validation canno
 c061698:	706f2074 74617265 69772065 6d206874     t operate with m
 c0616a8:	6f687465 203a2064 000a7825 73696854     ethod : %x..This
 c0616b8:	70797420 61632065 746f6e6e 20656220      type cannot be 
 c0616c8:	6f706d69 64657472 203a2020 000a6425     imported  : %d..
 c0616d8:	61766e49 2064696c 2079656b 72747461     Invalid key attr
 c0616e8:	74756269 000a7365 61766e49 2064696c     ibutes..Invalid 
 c0616f8:	76697264 000a7265 75636553 45206572     driver..Secure E
 c061708:	656d656c 6420746e 65766972 6e692072     lement driver in
 c061718:	61697469 617a696c 6e6f6974 69616620     itialization fai
 c061728:	6572756c 6553000a 65727563 656c4520     lure..Secure Ele
 c061738:	746e656d 69726420 20726576 74696e69     ment driver init
 c061748:	696c6169 0a64657a 73736100 69747265     ialized..asserti
 c061758:	66206e6f 656c6961 6e692064 3a732520     on failed in %s:
 c061768:	28206425 75746361 253d6c61 78652064     %d (actual=%d ex
 c061778:	74636570 253d6465 000a2964 69726553     pected=%d)..Seri
 c061788:	4e206c61 65626d75 72662072 73206d6f     al Number from s
 c061798:	20746f6c 63206425 6f6e6e61 65622074     lot %d cannot be
 c0617a8:	74657320 206e6920 75622061 72656666      set in a buffer
 c0617b8:	20666f20 657a6973 25203a20 53000a64      of size : %d..S
 c0617c8:	61697265 754e206c 7265626d 6f726620     erial Number fro
 c0617d8:	6c73206d 2520746f 61632064 746f6e6e     m slot %d cannot
 c0617e8:	20656220 6f636572 65726576 4e000a64      be recovered..N
 c0617f8:	6520746f 67756f6e 656d2068 79726f6d     ot enough memory
 c061808:	726f6620 6f727020 73736563 20676e69      for processing 
 c061818:	74207075 7525206f 67657220 736e6f69     up to %u regions
 c061828:	614d000a 6e697070 61632067 746f6e6e     ..Mapping cannot
 c061838:	20656220 64616572 6552000a 6e6f6967      be read..Region
 c061848:	6d756e20 20726562 6e6e6163 6220746f      number cannot b
 c061858:	626f2065 6e696174 000a6465 70657250     e obtained..Prep
 c061868:	69766f72 6e6f6973 2064656e 746f6c73     rovisionned slot
 c061878:	6e616320 20746f6e 72206562 0a646165      cannot be read.
	...

0c06188a <CSWTCH.60>:
 c06188a:	ff6f0000 ff79ff79 ff76ff6b              ..o.y.y.k.v.

0c061896 <__func__.0>:
 c061896:	5f617370 735f6573 69735f74 665f6e67     psa_se_st_sign_f
 c0618a6:	                                         ct.

0c0618a9 <__func__.1>:
 c0618a9:	5f617370 735f6573 65675f74 656b5f6e     psa_se_st_gen_ke
 c0618b9:	63665f79                                 y_fct.

0c0618bf <__func__.2>:
 c0618bf:	5f617370 735f6573 78655f74 74726f70     psa_se_st_export
	...

0c0618d0 <__func__.3>:
 c0618d0:	5f617370 735f6573 6d695f74 74726f70     psa_se_st_import
 c0618e0:	00000000                                ....

0c0618e4 <psa_se_st>:
 c0618e4:	00000005 000000c8 0c04a505 3003093c     ............<..0
	...
 c061900:	3003092c 300377f0                       ,..0.w.0

0c061908 <tfm_core_irq_signals_count>:
 c061908:	00000002                                ....

0c06190c <tfm_core_irq_signals>:
 c06190c:	00000104 80000000 00000004 00000040     ............@...
 c06191c:	00000104 40000000 00000008 00000040     .......@....@...
	...

0c06193c <memory_data_list>:
 c06193c:	3003ea00 3003f200 30040438 30040c38     ...0...08..08..0
 c06194c:	3003dc90 3003e310 30039210 3003b210     ...0...0...0...0
 c06195c:	3003e310 3003e810 3003d210 3003dc90     ...0...0...0...0
 c06196c:	3003b210 3003d210 30040c50 30041050     ...0...0P..0P..0

0c06197c <static_data_list>:
 c06197c:	00000100 00000000 00000005 000000ff     ................
 c06198c:	0c03c7b1 00000000 00000000 00000000     ................
	...
 c0619ac:	00000100 00000100 00000005 0000007f     ................
 c0619bc:	0c04b399 00000000 00000000 00000000     ................
	...
 c0619d4:	00000006 30030980 00000100 00000101     .......0........
 c0619e4:	00000007 0000007f 0c03992d 00000000     ........-.......
	...
 c061a0c:	00000100 00000103 00000007 0000007f     ................
 c061a1c:	0c03a419 00000000 00000000 00000000     ................
	...
 c061a34:	00000004 30030970 00000100 00000104     ....p..0........
 c061a44:	00000007 0000007f 0c03b615 00000000     ................
	...
 c061a6c:	00000100 00000105 00000007 0000007f     ................
 c061a7c:	0c05d675 00000000 00000000 00000000     u...............
	...
 c061a94:	00000001 3003096c 00000100 0000010f     ....l..0........
 c061aa4:	00000007 0000007f 0c05de65 00000000     ........e.......
	...
 c061ac4:	00000002 30030964 00000100 00000113     ....d..0........
 c061ad4:	00000005 0000007f 0c04b8ad 00000000     ................
	...
 c061af4:	00000001 30030960 5f4d4654 535f5350     ....`..0TFM_PS_S
 c061b04:	54005445 505f4d46 45475f53 46540054     ET.TFM_PS_GET.TF
 c061b14:	53505f4d 5445475f 464e495f 4654004f     M_PS_GET_INFO.TF
 c061b24:	53505f4d 4d45525f 0045564f 5f4d4654     M_PS_REMOVE.TFM_
 c061b34:	475f5350 535f5445 4f505055 54005452     PS_GET_SUPPORT.T
 c061b44:	495f4d46 535f5354 54005445 495f4d46     FM_ITS_SET.TFM_I
 c061b54:	475f5354 54005445 495f4d46 475f5354     TS_GET.TFM_ITS_G
 c061b64:	495f5445 004f464e 5f4d4654 5f535449     ET_INFO.TFM_ITS_
 c061b74:	4f4d4552 54004556 435f4d46 54505952     REMOVE.TFM_CRYPT
 c061b84:	4654004f 50535f4d 414c505f 524f4654     O.TFM_SP_PLATFOR
 c061b94:	59535f4d 4d455453 5345525f 54005445     M_SYSTEM_RESET.T
 c061ba4:	535f4d46 4c505f50 4f465441 495f4d52     FM_SP_PLATFORM_I
 c061bb4:	4c54434f 4d465400 5f50535f 54414c50     OCTL.TFM_SP_PLAT
 c061bc4:	4d524f46 5f564e5f 4e554f43 00524554     FORM_NV_COUNTER.
 c061bd4:	5f4d4654 45545441 475f5453 545f5445     TFM_ATTEST_GET_T
 c061be4:	4e454b4f 4d465400 5454415f 5f545345     OKEN.TFM_ATTEST_
 c061bf4:	5f544547 454b4f54 49535f4e 5400455a     GET_TOKEN_SIZE.T
 c061c04:	415f4d46 53455454 45475f54 55505f54     FM_ATTEST_GET_PU
 c061c14:	43494c42 59454b5f 4d465400 5557465f     BLIC_KEY.TFM_FWU
 c061c24:	4952575f 54004554 465f4d46 495f5557     _WRITE.TFM_FWU_I
 c061c34:	4154534e 54004c4c 465f4d46 415f5557     NSTALL.TFM_FWU_A
 c061c44:	54524f42 4d465400 5557465f 4555515f     BORT.TFM_FWU_QUE
 c061c54:	54005952 465f4d46 525f5557 45555145     RY.TFM_FWU_REQUE
 c061c64:	525f5453 4f4f4245 46540054 57465f4d     ST_REBOOT.TFM_FW
 c061c74:	43415f55 54504543 4d465400 5050415f     U_ACCEPT.TFM_APP
 c061c84:	544f525f 434f495f 00004c54              _ROT_IOCTL..

0c061c90 <service_db>:
 c061c90:	0c061afc 00000100 00000010 00000060     ............`...
 c061ca0:	00000101 00000001 00000001 0c061b07     ................
 c061cb0:	00000100 00000020 00000061 00000101     .... ...a.......
 c061cc0:	00000001 00000001 0c061b12 00000100     ................
 c061cd0:	00000040 00000062 00000101 00000001     @...b...........
 c061ce0:	00000001 0c061b22 00000100 00000080     ...."...........
 c061cf0:	00000063 00000101 00000001 00000001     c...............
 c061d00:	0c061b30 00000100 00000100 00000064     0...........d...
 c061d10:	00000101 00000001 00000001 0c061b43     ............C...
 c061d20:	00000101 00000010 00000070 00000101     ........p.......
 c061d30:	00000001 00000001 0c061b4f 00000101     ........O.......
 c061d40:	00000020 00000071 00000101 00000001      ...q...........
 c061d50:	00000001 0c061b5b 00000101 00000040     ....[.......@...
 c061d60:	00000072 00000101 00000001 00000001     r...............
 c061d70:	0c061b6c 00000101 00000080 00000073     l...........s...
 c061d80:	00000101 00000001 00000001 0c061b7b     ............{...
 c061d90:	00000103 00000010 00000080 00000101     ................
 c061da0:	00000001 00000001 0c061b86 00000104     ................
 c061db0:	00000010 00000040 00000101 00000001     ....@...........
 c061dc0:	00000001 0c061ba3 00000104 00000020     ............ ...
 c061dd0:	00000041 00000101 00000001 00000001     A...............
 c061de0:	0c061bb9 00000104 00000040 00000042     ........@...B...
 c061df0:	00000100 00000001 00000001 0c061bd4     ................
 c061e00:	00000105 00000010 00000020 00000101     ........ .......
 c061e10:	00000001 00000001 0c061be9 00000105     ................
 c061e20:	00000020 00000021 00000101 00000001      ...!...........
 c061e30:	00000001 0c061c03 00000105 00000040     ............@...
 c061e40:	00000022 00000101 00000001 00000001     "...............
 c061e50:	0c061c1d 0000010f 00000010 000000a0     ................
 c061e60:	00000101 00000001 00000001 0c061c2b     ............+...
 c061e70:	0000010f 00000020 000000a1 00000101     .... ...........
 c061e80:	00000001 00000001 0c061c3b 0000010f     ........;.......
 c061e90:	00000040 000000a2 00000101 00000001     @...............
 c061ea0:	00000001 0c061c49 0000010f 00000080     ....I...........
 c061eb0:	000000a3 00000101 00000001 00000001     ................
 c061ec0:	0c061c57 0000010f 00000100 000000a4     W...............
 c061ed0:	00000101 00000001 00000001 0c061c6e     ............n...
 c061ee0:	0000010f 00000200 000000a5 00000101     ................
 c061ef0:	00000001 00000001 0c061c7d 00000113     ........}.......
 c061f00:	00000010 00000100 00000101 00000001     ................
 c061f10:	00000001                                ....

0c061f14 <HEX_TABLE>:
 c061f14:	33323130 37363534 42413938 46454443     0123456789ABCDEF

0c061f24 <ecdsa_list.0>:
 c061f24:	fffffff9 ffffffdd ffffffdc 00000000     ................
 c061f34:	6e676953 72757461                        Signature1.

0c061f3f <defined_short_circuit_kid>:
 c061f3f:	4b4b95ef 70f6bdd9 826033d0 2a15eff5     ..KK...p.3`....*
 c061f4f:	6a5bf3f8 a6ef006c 491fa7a9 c6187e51     ..[jl......IQ~..
 c061f5f:	204d4654 3a555746 766e6920 64696c61     TFM FWU: invalid
 c061f6f:	6f6c7320 64695f74 6425203a 4d465400      slot_id: %d.TFM
 c061f7f:	55574620 6e69203a 696c6176 6d692064      FWU: invalid im
 c061f8f:	5f656761 65707974 6425203a 4d465400     age_type: %d.TFM
 c061f9f:	55574620 706f203a 6e696e65 6c662067      FWU: opening fl
 c061faf:	20687361 6c696166 0d2e6465 4654000a     ash failed....TF
 c061fbf:	5746204d 65203a55 69736172 6620676e     M FWU: erasing f
 c061fcf:	6873616c 69616620 2e64656c 54000a0d     lash failed....T
 c061fdf:	46204d46 203a5557 74697277 6c662065     FM FWU: write fl
 c061fef:	20687361 6c696166 0d2e6465 4654000a     ash failed....TF
 c061fff:	5746204d 72203a55 69646165 6620676e     M FWU: reading f
 c06200f:	6873616c 69616620 2e64656c 76000a0d     lash failed....v
 c06201f:	69737265 203d6e6f 2c2e6425 2e642520     ersion= %d., %d.
 c06202f:	6425202c 202b2c2e 0d0a6425               , %d.,+ %d...

0c06203c <CSWTCH.59>:
 c06203c:	                                         ...

0c06203f <CSWTCH.56>:
 c06203f:	08070403 5b007830 75736e55 726f7070     ....0x.[Unsuppor
 c06204f:	20646574 5d676154                        ted Tag].

0c062058 <hex_digits_up>:
 c062058:	33323130 37363534 42413938 46454443     0123456789ABCDEF

0c062068 <hex_digits_lo>:
 c062068:	33323130 37363534 62613938 66656463     0123456789abcdef

0c062078 <__EH_FRAME_BEGIN__>:
 c062078:	00000010 00000000 00527a01 010e7c02     .........zR..|..
 c062088:	000d0c1b 00000010 00000018 fffe060a     ................
 c062098:	00000010 00000000                       ........

0c0620a0 <__FRAME_END__>:
 c0620a0:	00000000                                ....

Disassembly of section .gnu.sgstubs:

0c065c80 <tfm_psa_framework_version_veneer>:
 c065c80:	e97f e97f 	sg
 c065c84:	f7d6 bda4 	b.w	c03c7d0 <__acle_se_tfm_psa_framework_version_veneer>

0c065c88 <TZ_InitContextSystem_S>:
 c065c88:	e97f e97f 	sg
 c065c8c:	f7f8 bbad 	b.w	c05e3ea <__acle_se_TZ_InitContextSystem_S>

0c065c90 <TZ_LoadContext_S>:
 c065c90:	e97f e97f 	sg
 c065c94:	f7f8 bbc5 	b.w	c05e422 <__acle_se_TZ_LoadContext_S>

0c065c98 <tfm_psa_version_veneer>:
 c065c98:	e97f e97f 	sg
 c065c9c:	f7d6 bd9a 	b.w	c03c7d4 <__acle_se_tfm_psa_version_veneer>

0c065ca0 <tfm_psa_close_veneer>:
 c065ca0:	e97f e97f 	sg
 c065ca4:	f7d6 bd9c 	b.w	c03c7e0 <__acle_se_tfm_psa_close_veneer>

0c065ca8 <TZ_FreeModuleContext_S>:
 c065ca8:	e97f e97f 	sg
 c065cac:	f7f8 bbad 	b.w	c05e40a <__acle_se_TZ_FreeModuleContext_S>

0c065cb0 <tfm_psa_connect_veneer>:
 c065cb0:	e97f e97f 	sg
 c065cb4:	f7d6 bd90 	b.w	c03c7d8 <__acle_se_tfm_psa_connect_veneer>

0c065cb8 <TZ_AllocModuleContext_S>:
 c065cb8:	e97f e97f 	sg
 c065cbc:	f7f8 bb9d 	b.w	c05e3fa <__acle_se_TZ_AllocModuleContext_S>

0c065cc0 <TZ_StoreContext_S>:
 c065cc0:	e97f e97f 	sg
 c065cc4:	f7f8 bbb9 	b.w	c05e43a <__acle_se_TZ_StoreContext_S>

0c065cc8 <tfm_psa_call_veneer>:
 c065cc8:	e97f e97f 	sg
 c065ccc:	f7d6 bd86 	b.w	c03c7dc <__acle_se_tfm_psa_call_veneer>
	...
