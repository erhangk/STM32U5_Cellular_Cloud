
TFM_Loader_NonSecure.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00004a00  081fa000  081fa000  00001000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .ARM.exidx    00000008  081fea00  081fea00  00005a00  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .copy.table   0000000c  081fea08  081fea08  00005a08  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  3 .zero.table   00000008  081fea14  081fea14  00005a14  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .data         000000b0  20000000  081fea1c  00006000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .bss          00000698  200000b0  081feacc  000060b0  2**2
                  ALLOC
  6 .msp_stack    00000400  20000760  081ff180  00006760  2**5
                  ALLOC
  7 .heap         00000200  20000b60  081ff580  00006760  2**3
                  ALLOC
  8 .ARM.attributes 00000036  00000000  00000000  000060b0  2**0
                  CONTENTS, READONLY
  9 .comment      00000043  00000000  00000000  000060e6  2**0
                  CONTENTS, READONLY
 10 .debug_info   00013c88  00000000  00000000  00006129  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 11 .debug_abbrev 000033a9  00000000  00000000  00019db1  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 12 .debug_loclists 00006bf7  00000000  00000000  0001d15a  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_aranges 00000e98  00000000  00000000  00023d51  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_rnglists 00000dad  00000000  00000000  00024be9  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_macro  000338a5  00000000  00000000  00025996  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_line   00017d07  00000000  00000000  0005923b  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_str    0013d1dd  00000000  00000000  00070f42  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_frame  00002bdc  00000000  00000000  001ae120  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

081fa000 <__Vectors>:
 81fa000:	60 0b 00 20 31 ac 1f 08 21 ab 1f 08 23 ab 1f 08     `.. 1...!...#...
 81fa010:	25 ab 1f 08 27 ab 1f 08 29 ab 1f 08 2b ab 1f 08     %...'...)...+...
	...
 81fa02c:	2d ab 1f 08 2f ab 1f 08 00 00 00 00 31 ab 1f 08     -.../.......1...
 81fa03c:	33 ab 1f 08 35 ab 1f 08 37 ab 1f 08 39 ab 1f 08     3...5...7...9...
 81fa04c:	3b ab 1f 08 3d ab 1f 08 3f ab 1f 08 41 ab 1f 08     ;...=...?...A...
 81fa05c:	43 ab 1f 08 45 ab 1f 08 47 ab 1f 08 49 ab 1f 08     C...E...G...I...
 81fa06c:	4b ab 1f 08 4d ab 1f 08 4f ab 1f 08 51 ab 1f 08     K...M...O...Q...
 81fa07c:	53 ab 1f 08 55 ab 1f 08 57 ab 1f 08 59 ab 1f 08     S...U...W...Y...
 81fa08c:	5b ab 1f 08 5d ab 1f 08 5f ab 1f 08 61 ab 1f 08     [...]..._...a...
 81fa09c:	63 ab 1f 08 65 ab 1f 08 67 ab 1f 08 69 ab 1f 08     c...e...g...i...
 81fa0ac:	6b ab 1f 08 6d ab 1f 08 6f ab 1f 08 71 ab 1f 08     k...m...o...q...
 81fa0bc:	73 ab 1f 08 75 ab 1f 08 77 ab 1f 08 79 ab 1f 08     s...u...w...y...
 81fa0cc:	7b ab 1f 08 7d ab 1f 08 7f ab 1f 08 81 ab 1f 08     {...}...........
 81fa0dc:	83 ab 1f 08 85 ab 1f 08 87 ab 1f 08 89 ab 1f 08     ................
 81fa0ec:	8b ab 1f 08 8d ab 1f 08 8f ab 1f 08 91 ab 1f 08     ................
 81fa0fc:	93 ab 1f 08 95 ab 1f 08 97 ab 1f 08 99 ab 1f 08     ................
 81fa10c:	9b ab 1f 08 9d ab 1f 08 9f ab 1f 08 a1 ab 1f 08     ................
 81fa11c:	a3 ab 1f 08 a5 ab 1f 08 a7 ab 1f 08 a9 ab 1f 08     ................
 81fa12c:	ab ab 1f 08 ad ab 1f 08 af ab 1f 08 b1 ab 1f 08     ................
 81fa13c:	b3 ab 1f 08 b5 ab 1f 08 b7 ab 1f 08 b9 ab 1f 08     ................
 81fa14c:	bb ab 1f 08 bd ab 1f 08 bf ab 1f 08 c1 ab 1f 08     ................
 81fa15c:	c3 ab 1f 08 c5 ab 1f 08 c7 ab 1f 08 c9 ab 1f 08     ................
 81fa16c:	cb ab 1f 08 cd ab 1f 08 cf ab 1f 08 d1 ab 1f 08     ................
 81fa17c:	d3 ab 1f 08 d5 ab 1f 08 d7 ab 1f 08 d9 ab 1f 08     ................
 81fa18c:	db ab 1f 08 dd ab 1f 08 df ab 1f 08 e1 ab 1f 08     ................
 81fa19c:	e3 ab 1f 08 e5 ab 1f 08 e7 ab 1f 08 e9 ab 1f 08     ................
 81fa1ac:	eb ab 1f 08 ed ab 1f 08 ef ab 1f 08 f1 ab 1f 08     ................
 81fa1bc:	f3 ab 1f 08 f5 ab 1f 08 f7 ab 1f 08 f9 ab 1f 08     ................
 81fa1cc:	fb ab 1f 08 fd ab 1f 08 ff ab 1f 08 01 ac 1f 08     ................
 81fa1dc:	03 ac 1f 08 05 ac 1f 08 07 ac 1f 08 09 ac 1f 08     ................
 81fa1ec:	0b ac 1f 08 0d ac 1f 08 0f ac 1f 08 11 ac 1f 08     ................
 81fa1fc:	13 ac 1f 08 15 ac 1f 08 17 ac 1f 08 19 ac 1f 08     ................
 81fa20c:	1b ac 1f 08 1d ac 1f 08 1f ac 1f 08 21 ac 1f 08     ............!...
 81fa21c:	23 ac 1f 08 25 ac 1f 08 27 ac 1f 08 29 ac 1f 08     #...%...'...)...
 81fa22c:	2b ac 1f 08 2d ac 1f 08 2f ac 1f 08                 +...-.../...

081fa238 <__do_global_dtors_aux>:
 81fa238:	b510      	push	{r4, lr}
 81fa23a:	4c05      	ldr	r4, [pc, #20]	@ (81fa250 <__do_global_dtors_aux+0x18>)
 81fa23c:	7823      	ldrb	r3, [r4, #0]
 81fa23e:	b933      	cbnz	r3, 81fa24e <__do_global_dtors_aux+0x16>
 81fa240:	4b04      	ldr	r3, [pc, #16]	@ (81fa254 <__do_global_dtors_aux+0x1c>)
 81fa242:	b113      	cbz	r3, 81fa24a <__do_global_dtors_aux+0x12>
 81fa244:	4804      	ldr	r0, [pc, #16]	@ (81fa258 <__do_global_dtors_aux+0x20>)
 81fa246:	f3af 8000 	nop.w
 81fa24a:	2301      	movs	r3, #1
 81fa24c:	7023      	strb	r3, [r4, #0]
 81fa24e:	bd10      	pop	{r4, pc}
 81fa250:	200000b0 	.word	0x200000b0
 81fa254:	00000000 	.word	0x00000000
 81fa258:	081fe9fc 	.word	0x081fe9fc

081fa25c <frame_dummy>:
 81fa25c:	b508      	push	{r3, lr}
 81fa25e:	4b03      	ldr	r3, [pc, #12]	@ (81fa26c <frame_dummy+0x10>)
 81fa260:	b11b      	cbz	r3, 81fa26a <frame_dummy+0xe>
 81fa262:	4903      	ldr	r1, [pc, #12]	@ (81fa270 <frame_dummy+0x14>)
 81fa264:	4803      	ldr	r0, [pc, #12]	@ (81fa274 <frame_dummy+0x18>)
 81fa266:	f3af 8000 	nop.w
 81fa26a:	bd08      	pop	{r3, pc}
 81fa26c:	00000000 	.word	0x00000000
 81fa270:	200000b4 	.word	0x200000b4
 81fa274:	081fe9fc 	.word	0x081fe9fc

081fa278 <_stack_init>:
 81fa278:	f5a3 3a80 	sub.w	sl, r3, #65536	@ 0x10000
 81fa27c:	4770      	bx	lr
 81fa27e:	bf00      	nop

081fa280 <_mainCRTStartup>:
 81fa280:	4b17      	ldr	r3, [pc, #92]	@ (81fa2e0 <_mainCRTStartup+0x60>)
 81fa282:	2b00      	cmp	r3, #0
 81fa284:	bf08      	it	eq
 81fa286:	4b13      	ldreq	r3, [pc, #76]	@ (81fa2d4 <_mainCRTStartup+0x54>)
 81fa288:	469d      	mov	sp, r3
 81fa28a:	f7ff fff5 	bl	81fa278 <_stack_init>
 81fa28e:	2100      	movs	r1, #0
 81fa290:	468b      	mov	fp, r1
 81fa292:	460f      	mov	r7, r1
 81fa294:	4813      	ldr	r0, [pc, #76]	@ (81fa2e4 <_mainCRTStartup+0x64>)
 81fa296:	4a14      	ldr	r2, [pc, #80]	@ (81fa2e8 <_mainCRTStartup+0x68>)
 81fa298:	1a12      	subs	r2, r2, r0
 81fa29a:	f003 f8ed 	bl	81fd478 <memset>
 81fa29e:	4b0e      	ldr	r3, [pc, #56]	@ (81fa2d8 <_mainCRTStartup+0x58>)
 81fa2a0:	2b00      	cmp	r3, #0
 81fa2a2:	d000      	beq.n	81fa2a6 <_mainCRTStartup+0x26>
 81fa2a4:	4798      	blx	r3
 81fa2a6:	4b0d      	ldr	r3, [pc, #52]	@ (81fa2dc <_mainCRTStartup+0x5c>)
 81fa2a8:	2b00      	cmp	r3, #0
 81fa2aa:	d000      	beq.n	81fa2ae <_mainCRTStartup+0x2e>
 81fa2ac:	4798      	blx	r3
 81fa2ae:	2000      	movs	r0, #0
 81fa2b0:	2100      	movs	r1, #0
 81fa2b2:	0004      	movs	r4, r0
 81fa2b4:	000d      	movs	r5, r1
 81fa2b6:	480d      	ldr	r0, [pc, #52]	@ (81fa2ec <_mainCRTStartup+0x6c>)
 81fa2b8:	2800      	cmp	r0, #0
 81fa2ba:	d002      	beq.n	81fa2c2 <_mainCRTStartup+0x42>
 81fa2bc:	480c      	ldr	r0, [pc, #48]	@ (81fa2f0 <_mainCRTStartup+0x70>)
 81fa2be:	f3af 8000 	nop.w
 81fa2c2:	f003 f927 	bl	81fd514 <__libc_init_array>
 81fa2c6:	0020      	movs	r0, r4
 81fa2c8:	0029      	movs	r1, r5
 81fa2ca:	f000 fc05 	bl	81faad8 <main>
 81fa2ce:	f002 fe03 	bl	81fced8 <exit>
 81fa2d2:	bf00      	nop
 81fa2d4:	00080000 	.word	0x00080000
	...
 81fa2e0:	20000b60 	.word	0x20000b60
 81fa2e4:	200000b0 	.word	0x200000b0
 81fa2e8:	20000748 	.word	0x20000748
	...

081fa2f4 <COM_Init>:
  * @brief  Initialize COM module.
  * @param  None.
  * @retval HAL Status.
  */
HAL_StatusTypeDef  COM_Init(void)
{
 81fa2f4:	b508      	push	{r3, lr}
#if defined(__GNUC__)
  setvbuf(stdout, NULL, _IONBF, 0);
 81fa2f6:	4b10      	ldr	r3, [pc, #64]	@ (81fa338 <COM_Init+0x44>)
 81fa2f8:	2202      	movs	r2, #2
 81fa2fa:	6818      	ldr	r0, [r3, #0]
 81fa2fc:	2300      	movs	r3, #0
 81fa2fe:	6880      	ldr	r0, [r0, #8]
 81fa300:	4619      	mov	r1, r3
 81fa302:	f002 ff2d 	bl	81fd160 <setvbuf>
  - No parity
  - Hardware flow control disabled (RTS and CTS signals)
  - Receive and transmit enabled
  */
  UartHandle.Instance = COM_UART;
  UartHandle.Init.BaudRate = 115200U;
 81fa306:	f44f 33e1 	mov.w	r3, #115200	@ 0x1c200
  UartHandle.Instance = COM_UART;
 81fa30a:	480c      	ldr	r0, [pc, #48]	@ (81fa33c <COM_Init+0x48>)
  UartHandle.Init.BaudRate = 115200U;
 81fa30c:	4a0c      	ldr	r2, [pc, #48]	@ (81fa340 <COM_Init+0x4c>)
 81fa30e:	e9c0 2300 	strd	r2, r3, [r0]
  UartHandle.Init.WordLength = UART_WORDLENGTH_8B;
 81fa312:	2300      	movs	r3, #0
  UartHandle.Init.StopBits = UART_STOPBITS_1;
 81fa314:	e9c0 3302 	strd	r3, r3, [r0, #8]
  UartHandle.Init.Parity = UART_PARITY_NONE;
 81fa318:	6103      	str	r3, [r0, #16]
  UartHandle.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 81fa31a:	6183      	str	r3, [r0, #24]
  UartHandle.Init.Mode = UART_MODE_RX | UART_MODE_TX;
 81fa31c:	230c      	movs	r3, #12
 81fa31e:	6143      	str	r3, [r0, #20]
  UartHandle.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_RXOVERRUNDISABLE_INIT;
 81fa320:	2310      	movs	r3, #16
 81fa322:	6283      	str	r3, [r0, #40]	@ 0x28
  UartHandle.AdvancedInit.OverrunDisable = UART_ADVFEATURE_OVERRUN_DISABLE;
 81fa324:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
 81fa328:	63c3      	str	r3, [r0, #60]	@ 0x3c
  UartHandle.FifoMode = UART_FIFOMODE_ENABLE;
 81fa32a:	f04f 5300 	mov.w	r3, #536870912	@ 0x20000000
 81fa32e:	6643      	str	r3, [r0, #100]	@ 0x64
  return HAL_UART_Init(&UartHandle);
}
 81fa330:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  return HAL_UART_Init(&UartHandle);
 81fa334:	f002 bd9f 	b.w	81fce76 <HAL_UART_Init>
 81fa338:	20000058 	.word	0x20000058
 81fa33c:	200000d4 	.word	0x200000d4
 81fa340:	40013800 	.word	0x40013800

081fa344 <HAL_UART_MspInit>:
  * @brief  UART MSP Init.
  * @param  huart: UART handler pointer.
  * @retval None.
  */
void HAL_UART_MspInit(UART_HandleTypeDef *huart)
{
 81fa344:	b570      	push	{r4, r5, r6, lr}

  GPIO_InitTypeDef GPIO_InitStruct;
  if (huart->Instance == COM_UART)
 81fa346:	6802      	ldr	r2, [r0, #0]
 81fa348:	4b21      	ldr	r3, [pc, #132]	@ (81fa3d0 <HAL_UART_MspInit+0x8c>)
{
 81fa34a:	b088      	sub	sp, #32
  if (huart->Instance == COM_UART)
 81fa34c:	429a      	cmp	r2, r3
 81fa34e:	d13d      	bne.n	81fa3cc <HAL_UART_MspInit+0x88>
  {
    /* Peripheral Clock Enable */
    COM_UART_CLK_ENABLE();
 81fa350:	4b20      	ldr	r3, [pc, #128]	@ (81fa3d4 <HAL_UART_MspInit+0x90>)
    COM_UART_TX_GPIO_CLK_ENABLE();
    COM_UART_RX_GPIO_CLK_ENABLE();

    /*Configure GPIO pins : COM_UART_TX_Pin  */
    GPIO_InitStruct.Pin = COM_UART_TX_PIN;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 81fa352:	2402      	movs	r4, #2
    COM_UART_CLK_ENABLE();
 81fa354:	f8d3 20a4 	ldr.w	r2, [r3, #164]	@ 0xa4
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 81fa358:	2600      	movs	r6, #0
    COM_UART_CLK_ENABLE();
 81fa35a:	f442 4280 	orr.w	r2, r2, #16384	@ 0x4000
 81fa35e:	f8c3 20a4 	str.w	r2, [r3, #164]	@ 0xa4
 81fa362:	f8d3 20a4 	ldr.w	r2, [r3, #164]	@ 0xa4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
    GPIO_InitStruct.Alternate = COM_UART_TX_AF;
 81fa366:	2507      	movs	r5, #7
    COM_UART_CLK_ENABLE();
 81fa368:	f402 4280 	and.w	r2, r2, #16384	@ 0x4000
 81fa36c:	9200      	str	r2, [sp, #0]
 81fa36e:	9a00      	ldr	r2, [sp, #0]
    COM_UART_TX_GPIO_CLK_ENABLE();
 81fa370:	f8d3 208c 	ldr.w	r2, [r3, #140]	@ 0x8c
    HAL_GPIO_Init(COM_UART_TX_GPIO_PORT, &GPIO_InitStruct);
 81fa374:	4818      	ldr	r0, [pc, #96]	@ (81fa3d8 <HAL_UART_MspInit+0x94>)
    COM_UART_TX_GPIO_CLK_ENABLE();
 81fa376:	f042 0201 	orr.w	r2, r2, #1
 81fa37a:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
 81fa37e:	f8d3 208c 	ldr.w	r2, [r3, #140]	@ 0x8c
    HAL_GPIO_Init(COM_UART_TX_GPIO_PORT, &GPIO_InitStruct);
 81fa382:	a903      	add	r1, sp, #12
    COM_UART_TX_GPIO_CLK_ENABLE();
 81fa384:	f002 0201 	and.w	r2, r2, #1
 81fa388:	9201      	str	r2, [sp, #4]
 81fa38a:	9a01      	ldr	r2, [sp, #4]
    COM_UART_RX_GPIO_CLK_ENABLE();
 81fa38c:	f8d3 208c 	ldr.w	r2, [r3, #140]	@ 0x8c
 81fa390:	f042 0201 	orr.w	r2, r2, #1
 81fa394:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
 81fa398:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 81fa39c:	e9cd 6405 	strd	r6, r4, [sp, #20]
    COM_UART_RX_GPIO_CLK_ENABLE();
 81fa3a0:	f003 0301 	and.w	r3, r3, #1
 81fa3a4:	9302      	str	r3, [sp, #8]
 81fa3a6:	9b02      	ldr	r3, [sp, #8]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 81fa3a8:	f44f 7300 	mov.w	r3, #512	@ 0x200
    GPIO_InitStruct.Alternate = COM_UART_TX_AF;
 81fa3ac:	9507      	str	r5, [sp, #28]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 81fa3ae:	e9cd 3403 	strd	r3, r4, [sp, #12]
    HAL_GPIO_Init(COM_UART_TX_GPIO_PORT, &GPIO_InitStruct);
 81fa3b2:	f001 f8a5 	bl	81fb500 <HAL_GPIO_Init>

    /*Configure GPIO pins : COM_UART_RX_Pin  */
    GPIO_InitStruct.Pin = COM_UART_RX_PIN;
 81fa3b6:	f44f 6380 	mov.w	r3, #1024	@ 0x400
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
    GPIO_InitStruct.Alternate = COM_UART_RX_AF;
    HAL_GPIO_Init(COM_UART_RX_GPIO_PORT, &GPIO_InitStruct);
 81fa3ba:	4807      	ldr	r0, [pc, #28]	@ (81fa3d8 <HAL_UART_MspInit+0x94>)
 81fa3bc:	a903      	add	r1, sp, #12
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 81fa3be:	e9cd 3403 	strd	r3, r4, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 81fa3c2:	e9cd 6405 	strd	r6, r4, [sp, #20]
    GPIO_InitStruct.Alternate = COM_UART_RX_AF;
 81fa3c6:	9507      	str	r5, [sp, #28]
    HAL_GPIO_Init(COM_UART_RX_GPIO_PORT, &GPIO_InitStruct);
 81fa3c8:	f001 f89a 	bl	81fb500 <HAL_GPIO_Init>
  }
}
 81fa3cc:	b008      	add	sp, #32
 81fa3ce:	bd70      	pop	{r4, r5, r6, pc}
 81fa3d0:	40013800 	.word	0x40013800
 81fa3d4:	46020c00 	.word	0x46020c00
 81fa3d8:	42020000 	.word	0x42020000

081fa3dc <COM_Transmit>:
  * @param uDataLength: Data pointer to the Data to transmit.
  * @param uTimeout: Timeout duration.
  * @retval Status of the Transmit operation.
  */
HAL_StatusTypeDef COM_Transmit(uint8_t *Data, uint16_t uDataLength, uint32_t uTimeout)
{
 81fa3dc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  HAL_StatusTypeDef status;
  uint32_t i;
  if (Ymodem)
 81fa3e0:	f8df 8058 	ldr.w	r8, [pc, #88]	@ 81fa43c <COM_Transmit+0x60>
{
 81fa3e4:	4606      	mov	r6, r0
  if (Ymodem)
 81fa3e6:	f8d8 3000 	ldr.w	r3, [r8]
{
 81fa3ea:	460f      	mov	r7, r1
 81fa3ec:	4614      	mov	r4, r2
  if (Ymodem)
 81fa3ee:	b1b3      	cbz	r3, 81fa41e <COM_Transmit+0x42>
 81fa3f0:	2505      	movs	r5, #5
  {
    /* send abort Y modem transfer sequence */
    for(i=0;i<5;i++)
    {
        status = HAL_UART_Transmit(&UartHandle, (uint8_t *)&Abort, 1, uTimeout);
 81fa3f2:	f8df a04c 	ldr.w	sl, [pc, #76]	@ 81fa440 <COM_Transmit+0x64>
 81fa3f6:	f8df 9040 	ldr.w	r9, [pc, #64]	@ 81fa438 <COM_Transmit+0x5c>
 81fa3fa:	4623      	mov	r3, r4
 81fa3fc:	2201      	movs	r2, #1
 81fa3fe:	4651      	mov	r1, sl
 81fa400:	4648      	mov	r0, r9
 81fa402:	f002 fc0c 	bl	81fcc1e <HAL_UART_Transmit>
        if (status != HAL_OK)
 81fa406:	b990      	cbnz	r0, 81fa42e <COM_Transmit+0x52>
    for(i=0;i<5;i++)
 81fa408:	3d01      	subs	r5, #1
 81fa40a:	d1f6      	bne.n	81fa3fa <COM_Transmit+0x1e>
            return status;
    }
    status = HAL_UART_Transmit(&UartHandle,(uint8_t *)YMODEM_IT_MSG, sizeof(YMODEM_IT_MSG), uTimeout);
 81fa40c:	4623      	mov	r3, r4
 81fa40e:	221a      	movs	r2, #26
 81fa410:	4908      	ldr	r1, [pc, #32]	@ (81fa434 <COM_Transmit+0x58>)
 81fa412:	4809      	ldr	r0, [pc, #36]	@ (81fa438 <COM_Transmit+0x5c>)
 81fa414:	f002 fc03 	bl	81fcc1e <HAL_UART_Transmit>
    if (status != HAL_OK)
 81fa418:	b948      	cbnz	r0, 81fa42e <COM_Transmit+0x52>
            return status;
    Ymodem=0;
 81fa41a:	f8c8 5000 	str.w	r5, [r8]
  }
  return HAL_UART_Transmit(&UartHandle, (uint8_t *)Data, uDataLength, uTimeout);
 81fa41e:	4623      	mov	r3, r4
 81fa420:	463a      	mov	r2, r7
 81fa422:	4631      	mov	r1, r6
}
 81fa424:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  return HAL_UART_Transmit(&UartHandle, (uint8_t *)Data, uDataLength, uTimeout);
 81fa428:	4803      	ldr	r0, [pc, #12]	@ (81fa438 <COM_Transmit+0x5c>)
 81fa42a:	f002 bbf8 	b.w	81fcc1e <HAL_UART_Transmit>
}
 81fa42e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 81fa432:	bf00      	nop
 81fa434:	081fe348 	.word	0x081fe348
 81fa438:	200000d4 	.word	0x200000d4
 81fa43c:	200000d0 	.word	0x200000d0
 81fa440:	200000cc 	.word	0x200000cc

081fa444 <COM_Transmit_Y>:
  * @param uDataLength: Data pointer to the Data to transmit.
  * @param uTimeout: Timeout duration.
  * @retval Status of the Transmit operation.
  */
HAL_StatusTypeDef COM_Transmit_Y(uint8_t *Data, uint16_t uDataLength, uint32_t uTimeout)
{
 81fa444:	4613      	mov	r3, r2
  if (Ymodem)
 81fa446:	4a05      	ldr	r2, [pc, #20]	@ (81fa45c <COM_Transmit_Y+0x18>)
 81fa448:	6812      	ldr	r2, [r2, #0]
 81fa44a:	b122      	cbz	r2, 81fa456 <COM_Transmit_Y+0x12>
    return HAL_UART_Transmit(&UartHandle, (uint8_t *)Data, uDataLength, uTimeout);
 81fa44c:	460a      	mov	r2, r1
 81fa44e:	4601      	mov	r1, r0
 81fa450:	4803      	ldr	r0, [pc, #12]	@ (81fa460 <COM_Transmit_Y+0x1c>)
 81fa452:	f002 bbe4 	b.w	81fcc1e <HAL_UART_Transmit>
  else
    return HAL_ERROR;
}
 81fa456:	2001      	movs	r0, #1
 81fa458:	4770      	bx	lr
 81fa45a:	bf00      	nop
 81fa45c:	200000d0 	.word	0x200000d0
 81fa460:	200000d4 	.word	0x200000d4

081fa464 <COM_Receive>:
  * @param uDataLength: Data pointer to the Data to receive.
  * @param uTimeout: Timeout duration.
  * @retval Status of the Receive operation.
  */
HAL_StatusTypeDef COM_Receive(uint8_t *Data, uint16_t uDataLength, uint32_t uTimeout)
{
 81fa464:	4613      	mov	r3, r2
  if (!Ymodem)
 81fa466:	4a05      	ldr	r2, [pc, #20]	@ (81fa47c <COM_Receive+0x18>)
 81fa468:	6812      	ldr	r2, [r2, #0]
 81fa46a:	b922      	cbnz	r2, 81fa476 <COM_Receive+0x12>
    return HAL_UART_Receive(&UartHandle, (uint8_t *)Data, uDataLength, uTimeout);
 81fa46c:	460a      	mov	r2, r1
 81fa46e:	4601      	mov	r1, r0
 81fa470:	4803      	ldr	r0, [pc, #12]	@ (81fa480 <COM_Receive+0x1c>)
 81fa472:	f002 bc31 	b.w	81fccd8 <HAL_UART_Receive>
  else
    return HAL_ERROR;
}
 81fa476:	2001      	movs	r0, #1
 81fa478:	4770      	bx	lr
 81fa47a:	bf00      	nop
 81fa47c:	200000d0 	.word	0x200000d0
 81fa480:	200000d4 	.word	0x200000d4

081fa484 <COM_Receive_Y>:
  * @param uDataLength: Data pointer to the Data to receive.
  * @param uTimeout: Timeout duration.
  * @retval Status of the Receive operation.
  */
HAL_StatusTypeDef COM_Receive_Y(uint8_t *Data, uint16_t uDataLength, uint32_t uTimeout)
{
 81fa484:	4613      	mov	r3, r2
  if (Ymodem)
 81fa486:	4a05      	ldr	r2, [pc, #20]	@ (81fa49c <COM_Receive_Y+0x18>)
 81fa488:	6812      	ldr	r2, [r2, #0]
 81fa48a:	b122      	cbz	r2, 81fa496 <COM_Receive_Y+0x12>
    return HAL_UART_Receive(&UartHandle, (uint8_t *)Data, uDataLength, uTimeout);
 81fa48c:	460a      	mov	r2, r1
 81fa48e:	4601      	mov	r1, r0
 81fa490:	4803      	ldr	r0, [pc, #12]	@ (81fa4a0 <COM_Receive_Y+0x1c>)
 81fa492:	f002 bc21 	b.w	81fccd8 <HAL_UART_Receive>
  else
    return HAL_BUSY;
}
 81fa496:	2002      	movs	r0, #2
 81fa498:	4770      	bx	lr
 81fa49a:	bf00      	nop
 81fa49c:	200000d0 	.word	0x200000d0
 81fa4a0:	200000d4 	.word	0x200000d4

081fa4a4 <COM_Flush>:
  * @retval HAL_Status.
  */
HAL_StatusTypeDef COM_Flush(void)
{
  /* Clean the input path */
  __HAL_UART_FLUSH_DRREGISTER(&UartHandle);
 81fa4a4:	4b05      	ldr	r3, [pc, #20]	@ (81fa4bc <COM_Flush+0x18>)
  return HAL_OK;
}
 81fa4a6:	2000      	movs	r0, #0
  __HAL_UART_FLUSH_DRREGISTER(&UartHandle);
 81fa4a8:	681b      	ldr	r3, [r3, #0]
 81fa4aa:	699a      	ldr	r2, [r3, #24]
 81fa4ac:	f042 0208 	orr.w	r2, r2, #8
 81fa4b0:	619a      	str	r2, [r3, #24]
 81fa4b2:	699a      	ldr	r2, [r3, #24]
 81fa4b4:	f042 0210 	orr.w	r2, r2, #16
 81fa4b8:	619a      	str	r2, [r3, #24]
}
 81fa4ba:	4770      	bx	lr
 81fa4bc:	200000d4 	.word	0x200000d4

081fa4c0 <COM_Y_On>:


HAL_StatusTypeDef  COM_Y_On(uint8_t AbortChar)
{
    HAL_StatusTypeDef status=HAL_ERROR;
    if (!Ymodem)
 81fa4c0:	4904      	ldr	r1, [pc, #16]	@ (81fa4d4 <COM_Y_On+0x14>)
{
 81fa4c2:	4603      	mov	r3, r0
    if (!Ymodem)
 81fa4c4:	680a      	ldr	r2, [r1, #0]
 81fa4c6:	2001      	movs	r0, #1
 81fa4c8:	b91a      	cbnz	r2, 81fa4d2 <COM_Y_On+0x12>
    {
        Ymodem = 1;
 81fa4ca:	6008      	str	r0, [r1, #0]
        Abort=AbortChar;
        status=HAL_OK;
 81fa4cc:	4610      	mov	r0, r2
        Abort=AbortChar;
 81fa4ce:	4902      	ldr	r1, [pc, #8]	@ (81fa4d8 <COM_Y_On+0x18>)
 81fa4d0:	700b      	strb	r3, [r1, #0]
    }
    return status;
}
 81fa4d2:	4770      	bx	lr
 81fa4d4:	200000d0 	.word	0x200000d0
 81fa4d8:	200000cc 	.word	0x200000cc

081fa4dc <COM_Y_Off>:
HAL_StatusTypeDef  COM_Y_Off(void)
{
    HAL_StatusTypeDef status=HAL_ERROR;
    if (Ymodem)
 81fa4dc:	4b03      	ldr	r3, [pc, #12]	@ (81fa4ec <COM_Y_Off+0x10>)
 81fa4de:	681a      	ldr	r2, [r3, #0]
 81fa4e0:	b112      	cbz	r2, 81fa4e8 <COM_Y_Off+0xc>
    {
        Ymodem = 0;
 81fa4e2:	2000      	movs	r0, #0
 81fa4e4:	6018      	str	r0, [r3, #0]
        status=HAL_OK;
 81fa4e6:	4770      	bx	lr
    HAL_StatusTypeDef status=HAL_ERROR;
 81fa4e8:	2001      	movs	r0, #1
    }
    return status;
}
 81fa4ea:	4770      	bx	lr
 81fa4ec:	200000d0 	.word	0x200000d0

081fa4f0 <Str2Int>:
  * @param  pIntNum: The integer value
  * @retval 1: Correct
  *         0: Error
  */
uint32_t Str2Int(uint8_t *pInputStr, uint32_t *pIntNum)
{
 81fa4f0:	b570      	push	{r4, r5, r6, lr}
  uint32_t i = 0U;
  uint32_t res = 0U;
  uint32_t val = 0U;

  if ((pInputStr[0U] == '0') && ((pInputStr[1U] == 'x') || (pInputStr[1U] == 'X')))
 81fa4f2:	7803      	ldrb	r3, [r0, #0]
{
 81fa4f4:	4604      	mov	r4, r0
  if ((pInputStr[0U] == '0') && ((pInputStr[1U] == 'x') || (pInputStr[1U] == 'X')))
 81fa4f6:	2b30      	cmp	r3, #48	@ 0x30
 81fa4f8:	d104      	bne.n	81fa504 <Str2Int+0x14>
 81fa4fa:	7843      	ldrb	r3, [r0, #1]
 81fa4fc:	f003 03df 	and.w	r3, r3, #223	@ 0xdf
 81fa500:	2b58      	cmp	r3, #88	@ 0x58
 81fa502:	d015      	beq.n	81fa530 <Str2Int+0x40>
 81fa504:	2300      	movs	r3, #0
        *pIntNum = val;
        res = 1U;
      }
      else if (ISVALIDDEC(pInputStr[i]))
      {
        val = val * 10U + CONVERTDEC(pInputStr[i]);
 81fa506:	250a      	movs	r5, #10
 81fa508:	461a      	mov	r2, r3
      if (pInputStr[i] == '\0')
 81fa50a:	5ca0      	ldrb	r0, [r4, r2]
 81fa50c:	bb48      	cbnz	r0, 81fa562 <Str2Int+0x72>
        res = 1U;
 81fa50e:	2001      	movs	r0, #1
        *pIntNum = val;
 81fa510:	600b      	str	r3, [r1, #0]
      {
        /* return 0, Invalid input */
        res = 0U;
        break;
      }
      i++;
 81fa512:	3201      	adds	r2, #1
    while ((i < 11U) && (res != 1U))
 81fa514:	2a0b      	cmp	r2, #11
 81fa516:	d020      	beq.n	81fa55a <Str2Int+0x6a>
 81fa518:	2800      	cmp	r0, #0
 81fa51a:	d0f6      	beq.n	81fa50a <Str2Int+0x1a>
 81fa51c:	e01f      	b.n	81fa55e <Str2Int+0x6e>
        val = (val << 4U) + CONVERTHEX(pInputStr[i]);
 81fa51e:	f1a3 0541 	sub.w	r5, r3, #65	@ 0x41
 81fa522:	2d05      	cmp	r5, #5
 81fa524:	ea4f 1202 	mov.w	r2, r2, lsl #4
 81fa528:	bf94      	ite	ls
 81fa52a:	3b37      	subls	r3, #55	@ 0x37
 81fa52c:	3b57      	subhi	r3, #87	@ 0x57
 81fa52e:	e00d      	b.n	81fa54c <Str2Int+0x5c>
 81fa530:	2200      	movs	r2, #0
 81fa532:	2002      	movs	r0, #2
    while ((i < 11U) && (pInputStr[i] != '\0'))
 81fa534:	5c23      	ldrb	r3, [r4, r0]
 81fa536:	b16b      	cbz	r3, 81fa554 <Str2Int+0x64>
      if (ISVALIDHEX(pInputStr[i]))
 81fa538:	f023 0520 	bic.w	r5, r3, #32
 81fa53c:	3d41      	subs	r5, #65	@ 0x41
 81fa53e:	2d05      	cmp	r5, #5
 81fa540:	d9ed      	bls.n	81fa51e <Str2Int+0x2e>
 81fa542:	3b30      	subs	r3, #48	@ 0x30
 81fa544:	b2dd      	uxtb	r5, r3
 81fa546:	2d09      	cmp	r5, #9
 81fa548:	d804      	bhi.n	81fa554 <Str2Int+0x64>
        val = (val << 4U) + CONVERTHEX(pInputStr[i]);
 81fa54a:	0112      	lsls	r2, r2, #4
      i++;
 81fa54c:	3001      	adds	r0, #1
    while ((i < 11U) && (pInputStr[i] != '\0'))
 81fa54e:	280b      	cmp	r0, #11
        val = (val << 4U) + CONVERTHEX(pInputStr[i]);
 81fa550:	441a      	add	r2, r3
    while ((i < 11U) && (pInputStr[i] != '\0'))
 81fa552:	d1ef      	bne.n	81fa534 <Str2Int+0x44>
    if (pInputStr[i] == '\0')
 81fa554:	5c23      	ldrb	r3, [r4, r0]
 81fa556:	b10b      	cbz	r3, 81fa55c <Str2Int+0x6c>
        res = 0U;
 81fa558:	2000      	movs	r0, #0
    }
  }

  return res;
}
 81fa55a:	bd70      	pop	{r4, r5, r6, pc}
      *pIntNum = val;
 81fa55c:	600a      	str	r2, [r1, #0]
      res = 1U;
 81fa55e:	2001      	movs	r0, #1
  return res;
 81fa560:	e7fb      	b.n	81fa55a <Str2Int+0x6a>
      else if (((pInputStr[i] == 'k') || (pInputStr[i] == 'K')) && (i > 0U))
 81fa562:	286b      	cmp	r0, #107	@ 0x6b
 81fa564:	d001      	beq.n	81fa56a <Str2Int+0x7a>
 81fa566:	284b      	cmp	r0, #75	@ 0x4b
 81fa568:	d103      	bne.n	81fa572 <Str2Int+0x82>
 81fa56a:	2a00      	cmp	r2, #0
 81fa56c:	d0f4      	beq.n	81fa558 <Str2Int+0x68>
        val = val << 10U;
 81fa56e:	029b      	lsls	r3, r3, #10
 81fa570:	e7cd      	b.n	81fa50e <Str2Int+0x1e>
      else if (((pInputStr[i] == 'm') || (pInputStr[i] == 'M')) && (i > 0U))
 81fa572:	f000 06df 	and.w	r6, r0, #223	@ 0xdf
 81fa576:	2e4d      	cmp	r6, #77	@ 0x4d
 81fa578:	d103      	bne.n	81fa582 <Str2Int+0x92>
 81fa57a:	2a00      	cmp	r2, #0
 81fa57c:	d0ec      	beq.n	81fa558 <Str2Int+0x68>
        val = val << 20U;
 81fa57e:	051b      	lsls	r3, r3, #20
        *pIntNum = val;
 81fa580:	e7c5      	b.n	81fa50e <Str2Int+0x1e>
      else if (ISVALIDDEC(pInputStr[i]))
 81fa582:	f1a0 0630 	sub.w	r6, r0, #48	@ 0x30
 81fa586:	2e09      	cmp	r6, #9
 81fa588:	d8e6      	bhi.n	81fa558 <Str2Int+0x68>
        val = val * 10U + CONVERTDEC(pInputStr[i]);
 81fa58a:	fb05 0303 	mla	r3, r5, r3, r0
 81fa58e:	2000      	movs	r0, #0
 81fa590:	3b30      	subs	r3, #48	@ 0x30
 81fa592:	e7be      	b.n	81fa512 <Str2Int+0x22>

081fa594 <Serial_PutByte>:
  * @brief  Transmit a byte to the HyperTerminal
  * @param  param The byte to be sent
  * @retval HAL_StatusTypeDef HAL_OK if OK
  */
HAL_StatusTypeDef Serial_PutByte(uint8_t uParam)
{
 81fa594:	b507      	push	{r0, r1, r2, lr}
  return COM_Transmit_Y(&uParam, 1U, TX_TIMEOUT);
 81fa596:	2264      	movs	r2, #100	@ 0x64
{
 81fa598:	f88d 0007 	strb.w	r0, [sp, #7]
  return COM_Transmit_Y(&uParam, 1U, TX_TIMEOUT);
 81fa59c:	2101      	movs	r1, #1
 81fa59e:	f10d 0007 	add.w	r0, sp, #7
 81fa5a2:	f7ff ff4f 	bl	81fa444 <COM_Transmit_Y>
}
 81fa5a6:	b003      	add	sp, #12
 81fa5a8:	f85d fb04 	ldr.w	pc, [sp], #4

081fa5ac <FW_UPDATE_PrintWelcome>:
  * @brief  Display the FW_UPDATE Main Menu choices on HyperTerminal
  * @param  None.
  * @retval None.
  */
static void FW_UPDATE_PrintWelcome(void)
{
 81fa5ac:	b508      	push	{r3, lr}
  printf("\r\n================ New Fw Image ============================\r\n\n");
 81fa5ae:	480a      	ldr	r0, [pc, #40]	@ (81fa5d8 <FW_UPDATE_PrintWelcome+0x2c>)
 81fa5b0:	f002 fdce 	bl	81fd150 <puts>
  printf("  Reset to trigger Installation ------------------------- 1\r\n\n");
 81fa5b4:	4809      	ldr	r0, [pc, #36]	@ (81fa5dc <FW_UPDATE_PrintWelcome+0x30>)
 81fa5b6:	f002 fdcb 	bl	81fd150 <puts>
#if (MCUBOOT_APP_IMAGE_NUMBER == 2)
  printf("  Download Secure App Image ----------------------------- 2\r\n\n");
 81fa5ba:	4809      	ldr	r0, [pc, #36]	@ (81fa5e0 <FW_UPDATE_PrintWelcome+0x34>)
 81fa5bc:	f002 fdc8 	bl	81fd150 <puts>
  printf("  Download NonSecure App Image -------------------------- 3\r\n\n");
 81fa5c0:	4808      	ldr	r0, [pc, #32]	@ (81fa5e4 <FW_UPDATE_PrintWelcome+0x38>)
 81fa5c2:	f002 fdc5 	bl	81fd150 <puts>
#else
  printf("  Download App Image ------------------------------------ 2\r\n\n");
#endif /* (MCUBOOT_APP_IMAGE_NUMBER == 2) */
#if (MCUBOOT_S_DATA_IMAGE_NUMBER == 1)
  printf("  Download Secure Data Image ---------------------------- 4\r\n\n");
 81fa5c6:	4808      	ldr	r0, [pc, #32]	@ (81fa5e8 <FW_UPDATE_PrintWelcome+0x3c>)
 81fa5c8:	f002 fdc2 	bl	81fd150 <puts>
#endif /* (MCUBOOT_S_DATA_IMAGE_NUMBER == 1) */
#if (MCUBOOT_NS_DATA_IMAGE_NUMBER == 1)
  printf("  Download NonSecure Data Image ------------------------- 5\r\n\n");
#endif /* (MCUBOOT_S_DATA_IMAGE_NUMBER == 1) */
}
 81fa5cc:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  printf("  Download NonSecure Data Image ------------------------- 5\r\n\n");
 81fa5d0:	4806      	ldr	r0, [pc, #24]	@ (81fa5ec <FW_UPDATE_PrintWelcome+0x40>)
 81fa5d2:	f002 bdbd 	b.w	81fd150 <puts>
 81fa5d6:	bf00      	nop
 81fa5d8:	081fe362 	.word	0x081fe362
 81fa5dc:	081fe3a1 	.word	0x081fe3a1
 81fa5e0:	081fe3df 	.word	0x081fe3df
 81fa5e4:	081fe41d 	.word	0x081fe41d
 81fa5e8:	081fe45b 	.word	0x081fe45b
 81fa5ec:	081fe499 	.word	0x081fe499

081fa5f0 <FW_UPDATE_DownloadNewFirmware.constprop.0>:
/**
  * @brief Download a new Firmware from the host.
  * @retval HAL status
  */
static HAL_StatusTypeDef FW_UPDATE_DownloadNewFirmware(SFU_FwImageFlashTypeDef *pFwImageDwlArea)
 81fa5f0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 81fa5f2:	4605      	mov	r5, r0
{
  HAL_StatusTypeDef ret = HAL_ERROR;
  COM_StatusTypeDef e_result;
  int32_t ret_arm;
  uint32_t u_fw_size = pFwImageDwlArea->MaxSizeInBytes ;
 81fa5f4:	6803      	ldr	r3, [r0, #0]
  uint32_t sector_address;

  /* Clear download area */
  printf("  -- Erasing download area \r\n\n");
 81fa5f6:	482b      	ldr	r0, [pc, #172]	@ (81fa6a4 <FW_UPDATE_DownloadNewFirmware.constprop.0+0xb4>)
  uint32_t u_fw_size = pFwImageDwlArea->MaxSizeInBytes ;
 81fa5f8:	9301      	str	r3, [sp, #4]
    else
    {
      ret_arm = LOADER_FLASH_DEV_NAME.EraseSector(sector_address);
    }
#else
    ret_arm = LOADER_FLASH_DEV_NAME.EraseSector(sector_address);
 81fa5fa:	4e2b      	ldr	r6, [pc, #172]	@ (81fa6a8 <FW_UPDATE_DownloadNewFirmware.constprop.0+0xb8>)
  printf("  -- Erasing download area \r\n\n");
 81fa5fc:	f002 fda8 	bl	81fd150 <puts>
       sector_address += m_uFlashSectorSize)
 81fa600:	4f2a      	ldr	r7, [pc, #168]	@ (81fa6ac <FW_UPDATE_DownloadNewFirmware.constprop.0+0xbc>)
  for (sector_address = pFwImageDwlArea->DownloadAddr;
 81fa602:	686c      	ldr	r4, [r5, #4]
       sector_address < pFwImageDwlArea->DownloadAddr + pFwImageDwlArea->MaxSizeInBytes;
 81fa604:	e9d5 2300 	ldrd	r2, r3, [r5]
 81fa608:	4413      	add	r3, r2
 81fa60a:	429c      	cmp	r4, r3
 81fa60c:	d330      	bcc.n	81fa670 <FW_UPDATE_DownloadNewFirmware.constprop.0+0x80>
    {
      return HAL_ERROR;
    }
  }

  printf("  -- Send Firmware \r\n\n");
 81fa60e:	4828      	ldr	r0, [pc, #160]	@ (81fa6b0 <FW_UPDATE_DownloadNewFirmware.constprop.0+0xc0>)
 81fa610:	f002 fd9e 	bl	81fd150 <puts>

  /* Download binary */
  printf("  -- -- File> Transfer> YMODEM> Send \t\n");
 81fa614:	4827      	ldr	r0, [pc, #156]	@ (81fa6b4 <FW_UPDATE_DownloadNewFirmware.constprop.0+0xc4>)
 81fa616:	f002 fd9b 	bl	81fd150 <puts>

  /*Init of Ymodem*/
  Ymodem_Init();
 81fa61a:	f000 fb73 	bl	81fad04 <Ymodem_Init>

  /*Receive through Ymodem*/
  e_result = Ymodem_Receive(&u_fw_size, pFwImageDwlArea->DownloadAddr);
 81fa61e:	6869      	ldr	r1, [r5, #4]
 81fa620:	a801      	add	r0, sp, #4
 81fa622:	f000 fba1 	bl	81fad68 <Ymodem_Receive>
 81fa626:	4604      	mov	r4, r0
  printf("\r\n\n");
 81fa628:	4823      	ldr	r0, [pc, #140]	@ (81fa6b8 <FW_UPDATE_DownloadNewFirmware.constprop.0+0xc8>)
 81fa62a:	f002 fd91 	bl	81fd150 <puts>

  if ((e_result == COM_OK))
 81fa62e:	bb3c      	cbnz	r4, 81fa680 <FW_UPDATE_DownloadNewFirmware.constprop.0+0x90>
  {
    printf("  -- -- Programming Completed Successfully!\r\n\n");
 81fa630:	4822      	ldr	r0, [pc, #136]	@ (81fa6bc <FW_UPDATE_DownloadNewFirmware.constprop.0+0xcc>)
 81fa632:	f002 fd8d 	bl	81fd150 <puts>
#if defined(__ARMCC_VERSION)
    printf("  -- -- Bytes: %u\r\n\n", u_fw_size);
#else
    printf("  -- -- Bytes: %lu\r\n\n", u_fw_size);
 81fa636:	9901      	ldr	r1, [sp, #4]
 81fa638:	4821      	ldr	r0, [pc, #132]	@ (81fa6c0 <FW_UPDATE_DownloadNewFirmware.constprop.0+0xd0>)
 81fa63a:	f002 fd21 	bl	81fd080 <iprintf>
#endif /*  __ARMCC_VERSION */
    ret = HAL_OK;
#if   !defined(MCUBOOT_PRIMARY_ONLY)
    if (u_fw_size <= (pFwImageDwlArea->MaxSizeInBytes - sizeof(MagicTrailerValue)))
 81fa63e:	682b      	ldr	r3, [r5, #0]
 81fa640:	9a01      	ldr	r2, [sp, #4]
 81fa642:	f1a3 0110 	sub.w	r1, r3, #16
 81fa646:	4291      	cmp	r1, r2
 81fa648:	d30f      	bcc.n	81fa66a <FW_UPDATE_DownloadNewFirmware.constprop.0+0x7a>
    {
      uint32_t MagicAddress =
        pFwImageDwlArea->DownloadAddr + (pFwImageDwlArea->MaxSizeInBytes - sizeof(MagicTrailerValue));
 81fa64a:	686c      	ldr	r4, [r5, #4]
      /* write the magic to trigger installation at next reset */
#if defined(__ARMCC_VERSION)
      printf("  Write Magic Trailer at %x\r\n\n", MagicAddress);
#else
      printf("  Write Magic Trailer at %lx\r\n\n", MagicAddress);
 81fa64c:	481d      	ldr	r0, [pc, #116]	@ (81fa6c4 <FW_UPDATE_DownloadNewFirmware.constprop.0+0xd4>)
        pFwImageDwlArea->DownloadAddr + (pFwImageDwlArea->MaxSizeInBytes - sizeof(MagicTrailerValue));
 81fa64e:	441c      	add	r4, r3
      uint32_t MagicAddress =
 81fa650:	3c10      	subs	r4, #16
      printf("  Write Magic Trailer at %lx\r\n\n", MagicAddress);
 81fa652:	4621      	mov	r1, r4
 81fa654:	f002 fd14 	bl	81fd080 <iprintf>
#endif /*  __ARMCC_VERSION */
      if (LOADER_FLASH_DEV_NAME.ProgramData(MagicAddress, MagicTrailerValue, sizeof(MagicTrailerValue)) != ARM_DRIVER_OK)
 81fa658:	4b13      	ldr	r3, [pc, #76]	@ (81fa6a8 <FW_UPDATE_DownloadNewFirmware.constprop.0+0xb8>)
 81fa65a:	4620      	mov	r0, r4
 81fa65c:	2210      	movs	r2, #16
 81fa65e:	491a      	ldr	r1, [pc, #104]	@ (81fa6c8 <FW_UPDATE_DownloadNewFirmware.constprop.0+0xd8>)
 81fa660:	699b      	ldr	r3, [r3, #24]
 81fa662:	4798      	blx	r3
 81fa664:	1e04      	subs	r4, r0, #0
 81fa666:	bf18      	it	ne
 81fa668:	2401      	movne	r4, #1
    HAL_Delay(500U);
    COM_Flush();
  }

  return ret;
}
 81fa66a:	4620      	mov	r0, r4
 81fa66c:	b003      	add	sp, #12
 81fa66e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    ret_arm = LOADER_FLASH_DEV_NAME.EraseSector(sector_address);
 81fa670:	4620      	mov	r0, r4
 81fa672:	69f3      	ldr	r3, [r6, #28]
 81fa674:	4798      	blx	r3
    if (ret_arm < 0)
 81fa676:	2800      	cmp	r0, #0
 81fa678:	db09      	blt.n	81fa68e <FW_UPDATE_DownloadNewFirmware.constprop.0+0x9e>
       sector_address += m_uFlashSectorSize)
 81fa67a:	683b      	ldr	r3, [r7, #0]
 81fa67c:	441c      	add	r4, r3
 81fa67e:	e7c1      	b.n	81fa604 <FW_UPDATE_DownloadNewFirmware.constprop.0+0x14>
  else if (e_result == COM_ABORT)
 81fa680:	2c02      	cmp	r4, #2
 81fa682:	d106      	bne.n	81fa692 <FW_UPDATE_DownloadNewFirmware.constprop.0+0xa2>
    printf("  -- -- !!Aborted by user!!\r\n\n");
 81fa684:	4811      	ldr	r0, [pc, #68]	@ (81fa6cc <FW_UPDATE_DownloadNewFirmware.constprop.0+0xdc>)
 81fa686:	f002 fd63 	bl	81fd150 <puts>
    COM_Flush();
 81fa68a:	f7ff ff0b 	bl	81fa4a4 <COM_Flush>
      return HAL_ERROR;
 81fa68e:	2401      	movs	r4, #1
 81fa690:	e7eb      	b.n	81fa66a <FW_UPDATE_DownloadNewFirmware.constprop.0+0x7a>
    printf("  -- -- !!Error during file download!!\r\n\n");
 81fa692:	480f      	ldr	r0, [pc, #60]	@ (81fa6d0 <FW_UPDATE_DownloadNewFirmware.constprop.0+0xe0>)
 81fa694:	f002 fd5c 	bl	81fd150 <puts>
    HAL_Delay(500U);
 81fa698:	f44f 70fa 	mov.w	r0, #500	@ 0x1f4
 81fa69c:	f000 fd20 	bl	81fb0e0 <HAL_Delay>
    COM_Flush();
 81fa6a0:	e7f3      	b.n	81fa68a <FW_UPDATE_DownloadNewFirmware.constprop.0+0x9a>
 81fa6a2:	bf00      	nop
 81fa6a4:	081fe4d7 	.word	0x081fe4d7
 81fa6a8:	081fe754 	.word	0x081fe754
 81fa6ac:	2000016c 	.word	0x2000016c
 81fa6b0:	081fe4f5 	.word	0x081fe4f5
 81fa6b4:	081fe50b 	.word	0x081fe50b
 81fa6b8:	081fe4f2 	.word	0x081fe4f2
 81fa6bc:	081fe532 	.word	0x081fe532
 81fa6c0:	081fe560 	.word	0x081fe560
 81fa6c4:	081fe576 	.word	0x081fe576
 81fa6c8:	081fe744 	.word	0x081fe744
 81fa6cc:	081fe596 	.word	0x081fe596
 81fa6d0:	081fe5b4 	.word	0x081fe5b4

081fa6d4 <FW_UPDATE_Run>:
{
 81fa6d4:	b530      	push	{r4, r5, lr}
  uint8_t key = 0U;
 81fa6d6:	2500      	movs	r5, #0
{
 81fa6d8:	b087      	sub	sp, #28
  uint8_t key = 0U;
 81fa6da:	f88d 5007 	strb.w	r5, [sp, #7]
      FW_UPDATE_PrintWelcome();
 81fa6de:	f7ff ff65 	bl	81fa5ac <FW_UPDATE_PrintWelcome>
    key = 0U;
 81fa6e2:	f88d 5007 	strb.w	r5, [sp, #7]
    COM_Flush();
 81fa6e6:	f7ff fedd 	bl	81fa4a4 <COM_Flush>
    if (COM_Receive(&key, 1U, RX_TIMEOUT) == HAL_OK)
 81fa6ea:	f44f 62fa 	mov.w	r2, #2000	@ 0x7d0
 81fa6ee:	2101      	movs	r1, #1
 81fa6f0:	f10d 0007 	add.w	r0, sp, #7
 81fa6f4:	f7ff feb6 	bl	81fa464 <COM_Receive>
 81fa6f8:	2800      	cmp	r0, #0
 81fa6fa:	d1f2      	bne.n	81fa6e2 <FW_UPDATE_Run+0xe>
      switch (key)
 81fa6fc:	f89d 3007 	ldrb.w	r3, [sp, #7]
 81fa700:	3b31      	subs	r3, #49	@ 0x31
 81fa702:	2b04      	cmp	r3, #4
 81fa704:	f200 808d 	bhi.w	81fa822 <FW_UPDATE_Run+0x14e>
 81fa708:	e8df f003 	tbb	[pc, r3]
 81fa70c:	51351303 	.word	0x51351303
 81fa710:	6e          	.byte	0x6e
 81fa711:	00          	.byte	0x00
          printf("  -- Install image : reboot\r\n\n");
 81fa712:	4846      	ldr	r0, [pc, #280]	@ (81fa82c <FW_UPDATE_Run+0x158>)
 81fa714:	f002 fd1c 	bl	81fd150 <puts>
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 81fa718:	f3bf 8f4f 	dsb	sy
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 81fa71c:	4944      	ldr	r1, [pc, #272]	@ (81fa830 <FW_UPDATE_Run+0x15c>)
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 81fa71e:	4b45      	ldr	r3, [pc, #276]	@ (81fa834 <FW_UPDATE_Run+0x160>)
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 81fa720:	68ca      	ldr	r2, [r1, #12]
 81fa722:	f402 62e0 	and.w	r2, r2, #1792	@ 0x700
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 81fa726:	4313      	orrs	r3, r2
 81fa728:	60cb      	str	r3, [r1, #12]
 81fa72a:	f3bf 8f4f 	dsb	sy
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
 81fa72e:	bf00      	nop
  for(;;)                                                           /* wait until reset */
 81fa730:	e7fd      	b.n	81fa72e <FW_UPDATE_Run+0x5a>
  ARM_FLASH_INFO *data = LOADER_FLASH_DEV_NAME.GetInfo();
 81fa732:	4b41      	ldr	r3, [pc, #260]	@ (81fa838 <FW_UPDATE_Run+0x164>)
 81fa734:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 81fa736:	4798      	blx	r3
 81fa738:	4604      	mov	r4, r0
  printf("Download Secure App Image\r\n");
 81fa73a:	4840      	ldr	r0, [pc, #256]	@ (81fa83c <FW_UPDATE_Run+0x168>)
 81fa73c:	f002 fd08 	bl	81fd150 <puts>
  fw_image_dwl_area.MaxSizeInBytes = FLASH_AREA_2_SIZE;
 81fa740:	f44f 3340 	mov.w	r3, #196608	@ 0x30000
 81fa744:	f44f 1c85 	mov.w	ip, #1089536	@ 0x10a000
 81fa748:	e9cd 3c02 	strd	r3, ip, [sp, #8]
  fw_image_dwl_area.ImageOffsetInBytes = 0x0;
 81fa74c:	2300      	movs	r3, #0
  m_uFlashSectorSize = data->sector_size;
 81fa74e:	68a2      	ldr	r2, [r4, #8]
  fw_image_dwl_area.ImageOffsetInBytes = 0x0;
 81fa750:	9304      	str	r3, [sp, #16]
  m_uFlashSectorSize = data->sector_size;
 81fa752:	4b3b      	ldr	r3, [pc, #236]	@ (81fa840 <FW_UPDATE_Run+0x16c>)
  ret = FW_UPDATE_DownloadNewFirmware(&fw_image_dwl_area);
 81fa754:	a802      	add	r0, sp, #8
  m_uFlashSectorSize = data->sector_size;
 81fa756:	601a      	str	r2, [r3, #0]
  m_uFlashMinWriteSize = data->program_unit;
 81fa758:	6922      	ldr	r2, [r4, #16]
 81fa75a:	4b3a      	ldr	r3, [pc, #232]	@ (81fa844 <FW_UPDATE_Run+0x170>)
 81fa75c:	601a      	str	r2, [r3, #0]
  ret = FW_UPDATE_DownloadNewFirmware(&fw_image_dwl_area);
 81fa75e:	f7ff ff47 	bl	81fa5f0 <FW_UPDATE_DownloadNewFirmware.constprop.0>
  if (HAL_OK == ret)
 81fa762:	2800      	cmp	r0, #0
 81fa764:	d1bb      	bne.n	81fa6de <FW_UPDATE_Run+0xa>
    printf("  -- Secure App Image correctly downloaded \r\n\n");
 81fa766:	4838      	ldr	r0, [pc, #224]	@ (81fa848 <FW_UPDATE_Run+0x174>)
    printf("  -- NonSecure App Image correctly downloaded \r\n\n");
 81fa768:	f002 fcf2 	bl	81fd150 <puts>
    HAL_Delay(1000U);
 81fa76c:	f44f 707a 	mov.w	r0, #1000	@ 0x3e8
 81fa770:	f000 fcb6 	bl	81fb0e0 <HAL_Delay>
  return ret;
 81fa774:	e7b3      	b.n	81fa6de <FW_UPDATE_Run+0xa>
  ARM_FLASH_INFO *data = LOADER_FLASH_DEV_NAME.GetInfo();
 81fa776:	4b30      	ldr	r3, [pc, #192]	@ (81fa838 <FW_UPDATE_Run+0x164>)
 81fa778:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 81fa77a:	4798      	blx	r3
 81fa77c:	4604      	mov	r4, r0
  printf("Download NonSecure App Image\r\n");
 81fa77e:	4833      	ldr	r0, [pc, #204]	@ (81fa84c <FW_UPDATE_Run+0x178>)
 81fa780:	f002 fce6 	bl	81fd150 <puts>
  fw_image_dwl_area.MaxSizeInBytes = FLASH_NS_PARTITION_SIZE;
 81fa784:	f44f 2320 	mov.w	r3, #655360	@ 0xa0000
 81fa788:	f44f 109d 	mov.w	r0, #1286144	@ 0x13a000
 81fa78c:	e9cd 3002 	strd	r3, r0, [sp, #8]
  fw_image_dwl_area.ImageOffsetInBytes = 0x0;
 81fa790:	2300      	movs	r3, #0
  m_uFlashSectorSize = data->sector_size;
 81fa792:	68a2      	ldr	r2, [r4, #8]
  fw_image_dwl_area.ImageOffsetInBytes = 0x0;
 81fa794:	9304      	str	r3, [sp, #16]
  m_uFlashSectorSize = data->sector_size;
 81fa796:	4b2a      	ldr	r3, [pc, #168]	@ (81fa840 <FW_UPDATE_Run+0x16c>)
  ret = FW_UPDATE_DownloadNewFirmware(&fw_image_dwl_area);
 81fa798:	a802      	add	r0, sp, #8
  m_uFlashSectorSize = data->sector_size;
 81fa79a:	601a      	str	r2, [r3, #0]
  m_uFlashMinWriteSize = data->program_unit;
 81fa79c:	6922      	ldr	r2, [r4, #16]
 81fa79e:	4b29      	ldr	r3, [pc, #164]	@ (81fa844 <FW_UPDATE_Run+0x170>)
 81fa7a0:	601a      	str	r2, [r3, #0]
  ret = FW_UPDATE_DownloadNewFirmware(&fw_image_dwl_area);
 81fa7a2:	f7ff ff25 	bl	81fa5f0 <FW_UPDATE_DownloadNewFirmware.constprop.0>
  if (HAL_OK == ret)
 81fa7a6:	2800      	cmp	r0, #0
 81fa7a8:	d199      	bne.n	81fa6de <FW_UPDATE_Run+0xa>
    printf("  -- NonSecure App Image correctly downloaded \r\n\n");
 81fa7aa:	4829      	ldr	r0, [pc, #164]	@ (81fa850 <FW_UPDATE_Run+0x17c>)
 81fa7ac:	e7dc      	b.n	81fa768 <FW_UPDATE_Run+0x94>
  ARM_FLASH_INFO *data = LOADER_FLASH_DEV_NAME.GetInfo();
 81fa7ae:	4b22      	ldr	r3, [pc, #136]	@ (81fa838 <FW_UPDATE_Run+0x164>)
 81fa7b0:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 81fa7b2:	4798      	blx	r3
 81fa7b4:	4604      	mov	r4, r0
  printf("Download Secure Data Image\r\n");
 81fa7b6:	4827      	ldr	r0, [pc, #156]	@ (81fa854 <FW_UPDATE_Run+0x180>)
 81fa7b8:	f002 fcca 	bl	81fd150 <puts>
  fw_image_dwl_area.MaxSizeInBytes = FLASH_AREA_6_SIZE;
 81fa7bc:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
 81fa7c0:	f44f 11ed 	mov.w	r1, #1941504	@ 0x1da000
 81fa7c4:	e9cd 3102 	strd	r3, r1, [sp, #8]
  fw_image_dwl_area.ImageOffsetInBytes = 0x0;
 81fa7c8:	2300      	movs	r3, #0
  m_uFlashSectorSize = data->sector_size;
 81fa7ca:	68a2      	ldr	r2, [r4, #8]
  fw_image_dwl_area.ImageOffsetInBytes = 0x0;
 81fa7cc:	9304      	str	r3, [sp, #16]
  m_uFlashSectorSize = data->sector_size;
 81fa7ce:	4b1c      	ldr	r3, [pc, #112]	@ (81fa840 <FW_UPDATE_Run+0x16c>)
  ret = FW_UPDATE_DownloadNewFirmware(&fw_image_dwl_area);
 81fa7d0:	a802      	add	r0, sp, #8
  m_uFlashSectorSize = data->sector_size;
 81fa7d2:	601a      	str	r2, [r3, #0]
  m_uFlashMinWriteSize = data->program_unit;
 81fa7d4:	6922      	ldr	r2, [r4, #16]
 81fa7d6:	4b1b      	ldr	r3, [pc, #108]	@ (81fa844 <FW_UPDATE_Run+0x170>)
 81fa7d8:	601a      	str	r2, [r3, #0]
  ret = FW_UPDATE_DownloadNewFirmware(&fw_image_dwl_area);
 81fa7da:	f7ff ff09 	bl	81fa5f0 <FW_UPDATE_DownloadNewFirmware.constprop.0>
  if (HAL_OK == ret)
 81fa7de:	2800      	cmp	r0, #0
 81fa7e0:	f47f af7d 	bne.w	81fa6de <FW_UPDATE_Run+0xa>
    printf("  -- Secure Data Image correctly downloaded \r\n\n");
 81fa7e4:	481c      	ldr	r0, [pc, #112]	@ (81fa858 <FW_UPDATE_Run+0x184>)
 81fa7e6:	e7bf      	b.n	81fa768 <FW_UPDATE_Run+0x94>
  ARM_FLASH_INFO *data = LOADER_FLASH_DEV_NAME.GetInfo();
 81fa7e8:	4b13      	ldr	r3, [pc, #76]	@ (81fa838 <FW_UPDATE_Run+0x164>)
 81fa7ea:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 81fa7ec:	4798      	blx	r3
 81fa7ee:	4604      	mov	r4, r0
  printf("Download NonSecure Data Image\r\n");
 81fa7f0:	481a      	ldr	r0, [pc, #104]	@ (81fa85c <FW_UPDATE_Run+0x188>)
 81fa7f2:	f002 fcad 	bl	81fd150 <puts>
  fw_image_dwl_area.MaxSizeInBytes = FLASH_AREA_7_SIZE;
 81fa7f6:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
 81fa7fa:	f44f 12ee 	mov.w	r2, #1949696	@ 0x1dc000
 81fa7fe:	e9cd 3202 	strd	r3, r2, [sp, #8]
  fw_image_dwl_area.ImageOffsetInBytes = 0x0;
 81fa802:	2300      	movs	r3, #0
  m_uFlashSectorSize = data->sector_size;
 81fa804:	68a2      	ldr	r2, [r4, #8]
  fw_image_dwl_area.ImageOffsetInBytes = 0x0;
 81fa806:	9304      	str	r3, [sp, #16]
  m_uFlashSectorSize = data->sector_size;
 81fa808:	4b0d      	ldr	r3, [pc, #52]	@ (81fa840 <FW_UPDATE_Run+0x16c>)
  ret = FW_UPDATE_DownloadNewFirmware(&fw_image_dwl_area);
 81fa80a:	a802      	add	r0, sp, #8
  m_uFlashSectorSize = data->sector_size;
 81fa80c:	601a      	str	r2, [r3, #0]
  m_uFlashMinWriteSize = data->program_unit;
 81fa80e:	6922      	ldr	r2, [r4, #16]
 81fa810:	4b0c      	ldr	r3, [pc, #48]	@ (81fa844 <FW_UPDATE_Run+0x170>)
 81fa812:	601a      	str	r2, [r3, #0]
  ret = FW_UPDATE_DownloadNewFirmware(&fw_image_dwl_area);
 81fa814:	f7ff feec 	bl	81fa5f0 <FW_UPDATE_DownloadNewFirmware.constprop.0>
  if (HAL_OK == ret)
 81fa818:	2800      	cmp	r0, #0
 81fa81a:	f47f af60 	bne.w	81fa6de <FW_UPDATE_Run+0xa>
    printf("  -- NonSecure Data Image correctly downloaded \r\n\n");
 81fa81e:	4810      	ldr	r0, [pc, #64]	@ (81fa860 <FW_UPDATE_Run+0x18c>)
 81fa820:	e7a2      	b.n	81fa768 <FW_UPDATE_Run+0x94>
          printf("Invalid Number !\r");
 81fa822:	4810      	ldr	r0, [pc, #64]	@ (81fa864 <FW_UPDATE_Run+0x190>)
 81fa824:	f002 fc2c 	bl	81fd080 <iprintf>
          break;
 81fa828:	e759      	b.n	81fa6de <FW_UPDATE_Run+0xa>
 81fa82a:	bf00      	nop
 81fa82c:	081fe5dd 	.word	0x081fe5dd
 81fa830:	e000ed00 	.word	0xe000ed00
 81fa834:	05fa0004 	.word	0x05fa0004
 81fa838:	081fe754 	.word	0x081fe754
 81fa83c:	081fe5fb 	.word	0x081fe5fb
 81fa840:	2000016c 	.word	0x2000016c
 81fa844:	20000168 	.word	0x20000168
 81fa848:	081fe616 	.word	0x081fe616
 81fa84c:	081fe644 	.word	0x081fe644
 81fa850:	081fe662 	.word	0x081fe662
 81fa854:	081fe693 	.word	0x081fe693
 81fa858:	081fe6af 	.word	0x081fe6af
 81fa85c:	081fe6de 	.word	0x081fe6de
 81fa860:	081fe6fd 	.word	0x081fe6fd
 81fa864:	081fe72f 	.word	0x081fe72f

081fa868 <Ymodem_HeaderPktRxCpltCallback>:
  * @brief  Ymodem Header Packet Transfer completed callback.
  * @param  uFileSize Dimension of the file that will be received (Bytes).
  * @retval None
  */
HAL_StatusTypeDef Ymodem_HeaderPktRxCpltCallback(uint32_t uFlashDestination, uint32_t uFileSize)
{
 81fa868:	b510      	push	{r4, lr}
  /*Reset of the ymodem variables */
  m_uFileSizeYmodem = 0U;
  m_uPacketsReceived = 0U;
 81fa86a:	2400      	movs	r4, #0
 81fa86c:	4b07      	ldr	r3, [pc, #28]	@ (81fa88c <Ymodem_HeaderPktRxCpltCallback+0x24>)

  /* compute the number of 1K blocks */
  m_uNbrBlocksYmodem = (m_uFileSizeYmodem + (PACKET_1K_SIZE - 1U)) / PACKET_1K_SIZE;

  /* NOTE : delay inserted for Ymodem protocol*/
  HAL_Delay(1000);
 81fa86e:	f44f 707a 	mov.w	r0, #1000	@ 0x3e8
  m_uPacketsReceived = 0U;
 81fa872:	601c      	str	r4, [r3, #0]
  m_uFileSizeYmodem = uFileSize;
 81fa874:	4b06      	ldr	r3, [pc, #24]	@ (81fa890 <Ymodem_HeaderPktRxCpltCallback+0x28>)
 81fa876:	6019      	str	r1, [r3, #0]
  m_uNbrBlocksYmodem = (m_uFileSizeYmodem + (PACKET_1K_SIZE - 1U)) / PACKET_1K_SIZE;
 81fa878:	4b06      	ldr	r3, [pc, #24]	@ (81fa894 <Ymodem_HeaderPktRxCpltCallback+0x2c>)
 81fa87a:	f201 31ff 	addw	r1, r1, #1023	@ 0x3ff
 81fa87e:	0a89      	lsrs	r1, r1, #10
 81fa880:	6019      	str	r1, [r3, #0]
  HAL_Delay(1000);
 81fa882:	f000 fc2d 	bl	81fb0e0 <HAL_Delay>
  return HAL_OK;
}
 81fa886:	4620      	mov	r0, r4
 81fa888:	bd10      	pop	{r4, pc}
 81fa88a:	bf00      	nop
 81fa88c:	20000170 	.word	0x20000170
 81fa890:	20000178 	.word	0x20000178
 81fa894:	20000174 	.word	0x20000174

081fa898 <Ymodem_DataPktRxCpltCallback>:
  * @param  pData Pointer to the buffer.
  * @param  uSize Packet dimension (Bytes).
  * @retval None
  */
HAL_StatusTypeDef Ymodem_DataPktRxCpltCallback(uint8_t *pData, uint32_t uFlashDestination, uint32_t uSize)
{
 81fa898:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  int32_t ret;
  m_uPacketsReceived++;
 81fa89c:	4e1a      	ldr	r6, [pc, #104]	@ (81fa908 <Ymodem_DataPktRxCpltCallback+0x70>)

  /*Increase the number of received packets*/
  if (m_uPacketsReceived == m_uNbrBlocksYmodem) /*Last Packet*/
 81fa89e:	f8df 8078 	ldr.w	r8, [pc, #120]	@ 81fa918 <Ymodem_DataPktRxCpltCallback+0x80>
  m_uPacketsReceived++;
 81fa8a2:	6833      	ldr	r3, [r6, #0]
{
 81fa8a4:	4614      	mov	r4, r2
  if (m_uPacketsReceived == m_uNbrBlocksYmodem) /*Last Packet*/
 81fa8a6:	f8d8 2000 	ldr.w	r2, [r8]
  m_uPacketsReceived++;
 81fa8aa:	3301      	adds	r3, #1
  if (m_uPacketsReceived == m_uNbrBlocksYmodem) /*Last Packet*/
 81fa8ac:	4293      	cmp	r3, r2
{
 81fa8ae:	4607      	mov	r7, r0
 81fa8b0:	4689      	mov	r9, r1
  m_uPacketsReceived++;
 81fa8b2:	6033      	str	r3, [r6, #0]
  if (m_uPacketsReceived == m_uNbrBlocksYmodem) /*Last Packet*/
 81fa8b4:	d109      	bne.n	81fa8ca <Ymodem_DataPktRxCpltCallback+0x32>
  {
    /*Extracting actual payload from last packet*/
    if (0 == (m_uFileSizeYmodem % PACKET_1K_SIZE))
 81fa8b6:	4b15      	ldr	r3, [pc, #84]	@ (81fa90c <Ymodem_DataPktRxCpltCallback+0x74>)
 81fa8b8:	681c      	ldr	r4, [r3, #0]
    {
      /* The last packet is not full, drop the extra bytes */
      uSize = m_uFileSizeYmodem - ((uint32_t)(m_uFileSizeYmodem / PACKET_1K_SIZE) * PACKET_1K_SIZE);
    }

    m_uPacketsReceived = 0U;
 81fa8ba:	2300      	movs	r3, #0
    if (0 == (m_uFileSizeYmodem % PACKET_1K_SIZE))
 81fa8bc:	f3c4 0409 	ubfx	r4, r4, #0, #10
      uSize = PACKET_1K_SIZE;
 81fa8c0:	2c00      	cmp	r4, #0
 81fa8c2:	bf08      	it	eq
 81fa8c4:	f44f 6480 	moveq.w	r4, #1024	@ 0x400
    m_uPacketsReceived = 0U;
 81fa8c8:	6033      	str	r3, [r6, #0]
  }
  /*Adjust dimension to 64-bit length */
  if (uSize %  m_uFlashMinWriteSize != 0U)
 81fa8ca:	4b11      	ldr	r3, [pc, #68]	@ (81fa910 <Ymodem_DataPktRxCpltCallback+0x78>)
 81fa8cc:	681d      	ldr	r5, [r3, #0]
 81fa8ce:	fbb4 f3f5 	udiv	r3, r4, r5
 81fa8d2:	fb05 4313 	mls	r3, r5, r3, r4
 81fa8d6:	b133      	cbz	r3, 81fa8e6 <Ymodem_DataPktRxCpltCallback+0x4e>
  {
    memset(&pData[uSize], 0xff, (m_uFlashMinWriteSize - (uSize %  m_uFlashMinWriteSize)));
 81fa8d8:	1aed      	subs	r5, r5, r3
 81fa8da:	1938      	adds	r0, r7, r4
 81fa8dc:	462a      	mov	r2, r5
 81fa8de:	21ff      	movs	r1, #255	@ 0xff
 81fa8e0:	f002 fdca 	bl	81fd478 <memset>
    uSize += (m_uFlashMinWriteSize - (uSize %  m_uFlashMinWriteSize));
 81fa8e4:	442c      	add	r4, r5
    ret = SECURE_Flash_ProgramData(uFlashDestination, pData, uSize);
  }
  else
    ret = LOADER_FLASH_DEV_NAME.ProgramData(uFlashDestination, pData, uSize);
#else
  ret = LOADER_FLASH_DEV_NAME.ProgramData(uFlashDestination, pData, uSize);
 81fa8e6:	4b0b      	ldr	r3, [pc, #44]	@ (81fa914 <Ymodem_DataPktRxCpltCallback+0x7c>)
 81fa8e8:	4622      	mov	r2, r4
 81fa8ea:	699b      	ldr	r3, [r3, #24]
 81fa8ec:	4639      	mov	r1, r7
 81fa8ee:	4648      	mov	r0, r9
 81fa8f0:	4798      	blx	r3
#endif /*defined(MCUBOOT_PRIMARY_ONLY) */
  if (ret != ARM_DRIVER_OK)
 81fa8f2:	2300      	movs	r3, #0
 81fa8f4:	b128      	cbz	r0, 81fa902 <Ymodem_DataPktRxCpltCallback+0x6a>
  {
    /*Reset of the ymodem variables */
    m_uFileSizeYmodem = 0U;
    m_uPacketsReceived = 0U;
    m_uNbrBlocksYmodem = 0U;
    return HAL_ERROR;
 81fa8f6:	2001      	movs	r0, #1
    m_uFileSizeYmodem = 0U;
 81fa8f8:	4a04      	ldr	r2, [pc, #16]	@ (81fa90c <Ymodem_DataPktRxCpltCallback+0x74>)
    m_uPacketsReceived = 0U;
 81fa8fa:	6033      	str	r3, [r6, #0]
    m_uFileSizeYmodem = 0U;
 81fa8fc:	6013      	str	r3, [r2, #0]
    m_uNbrBlocksYmodem = 0U;
 81fa8fe:	f8c8 3000 	str.w	r3, [r8]
  }
  else
    return HAL_OK;
}
 81fa902:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 81fa906:	bf00      	nop
 81fa908:	20000170 	.word	0x20000170
 81fa90c:	20000178 	.word	0x20000178
 81fa910:	20000168 	.word	0x20000168
 81fa914:	081fe754 	.word	0x081fe754
 81fa918:	20000174 	.word	0x20000174

081fa91c <Flash_GetInfo>:
}
#endif
static ARM_FLASH_INFO *Flash_GetInfo(void)
{
  return ARM_FLASH0_DEV.data;
}
 81fa91c:	4800      	ldr	r0, [pc, #0]	@ (81fa920 <Flash_GetInfo+0x4>)
 81fa91e:	4770      	bx	lr
 81fa920:	081fe780 	.word	0x081fe780

081fa924 <Flash_Initialize>:
{
 81fa924:	b508      	push	{r3, lr}
  FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 81fa926:	f44f 707a 	mov.w	r0, #1000	@ 0x3e8
 81fa92a:	f000 fd13 	bl	81fb354 <FLASH_WaitForLastOperation>
}
 81fa92e:	2000      	movs	r0, #0
 81fa930:	bd08      	pop	{r3, pc}
	...

081fa934 <Flash_ProgramData>:
{
 81fa934:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  ARM_FLASH0_STATUS.error = DRIVER_STATUS_NO_ERROR;
 81fa938:	4f33      	ldr	r7, [pc, #204]	@ (81faa08 <Flash_ProgramData+0xd4>)
{
 81fa93a:	4691      	mov	r9, r2
  ARM_FLASH0_STATUS.error = DRIVER_STATUS_NO_ERROR;
 81fa93c:	683b      	ldr	r3, [r7, #0]
  if ((!is_range_valid(&ARM_FLASH0_DEV, addr + cnt - 1)) ||
 81fa93e:	3a01      	subs	r2, #1
 81fa940:	4402      	add	r2, r0
  ARM_FLASH0_STATUS.error = DRIVER_STATUS_NO_ERROR;
 81fa942:	f36f 0341 	bfc	r3, #1, #1
  if ((!is_range_valid(&ARM_FLASH0_DEV, addr + cnt - 1)) ||
 81fa946:	f5b2 1f00 	cmp.w	r2, #2097152	@ 0x200000
{
 81fa94a:	4604      	mov	r4, r0
 81fa94c:	4688      	mov	r8, r1
 81fa94e:	b085      	sub	sp, #20
  ARM_FLASH0_STATUS.error = DRIVER_STATUS_NO_ERROR;
 81fa950:	603b      	str	r3, [r7, #0]
  if ((!is_range_valid(&ARM_FLASH0_DEV, addr + cnt - 1)) ||
 81fa952:	d20c      	bcs.n	81fa96e <Flash_ProgramData+0x3a>
 81fa954:	ea40 0509 	orr.w	r5, r0, r9
      (!is_write_aligned(&ARM_FLASH0_DEV, addr))     ||
 81fa958:	f015 050f 	ands.w	r5, r5, #15
 81fa95c:	d107      	bne.n	81fa96e <Flash_ProgramData+0x3a>
  for (nb = 0; nb < vect->nb; nb++)
 81fa95e:	4b2b      	ldr	r3, [pc, #172]	@ (81faa0c <Flash_ProgramData+0xd8>)
    if ((start >= vect->range[nb].base) && ((start + len - 1) <= vect->range[nb].limit))
 81fa960:	e9d3 6002 	ldrd	r6, r0, [r3, #8]
  for (nb = 0; nb < vect->nb; nb++)
 81fa964:	462b      	mov	r3, r5
    if ((start >= vect->range[nb].base) && ((start + len - 1) <= vect->range[nb].limit))
 81fa966:	f100 0c04 	add.w	ip, r0, #4
  for (nb = 0; nb < vect->nb; nb++)
 81fa96a:	42b3      	cmp	r3, r6
 81fa96c:	d108      	bne.n	81fa980 <Flash_ProgramData+0x4c>
    return ARM_DRIVER_ERROR_PARAMETER;
 81fa96e:	f06f 0004 	mvn.w	r0, #4
    ARM_FLASH0_STATUS.error = DRIVER_STATUS_ERROR;
 81fa972:	683b      	ldr	r3, [r7, #0]
 81fa974:	f043 0302 	orr.w	r3, r3, #2
 81fa978:	603b      	str	r3, [r7, #0]
}
 81fa97a:	b005      	add	sp, #20
 81fa97c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    if ((start >= vect->range[nb].base) && ((start + len - 1) <= vect->range[nb].limit))
 81fa980:	f850 1033 	ldr.w	r1, [r0, r3, lsl #3]
 81fa984:	428c      	cmp	r4, r1
 81fa986:	d303      	bcc.n	81fa990 <Flash_ProgramData+0x5c>
 81fa988:	f85c 1033 	ldr.w	r1, [ip, r3, lsl #3]
 81fa98c:	428a      	cmp	r2, r1
 81fa98e:	d903      	bls.n	81fa998 <Flash_ProgramData+0x64>
  for (nb = 0; nb < vect->nb; nb++)
 81fa990:	3301      	adds	r3, #1
 81fa992:	e7ea      	b.n	81fa96a <Flash_ProgramData+0x36>
        err = HAL_OK;
 81fa994:	2400      	movs	r4, #0
 81fa996:	e026      	b.n	81fa9e6 <Flash_ProgramData+0xb2>
  HAL_FLASH_Unlock();
 81fa998:	f000 fcbe 	bl	81fb318 <HAL_FLASH_Unlock>
  ARM_FLASH0_STATUS.busy = DRIVER_STATUS_BUSY;
 81fa99c:	683b      	ldr	r3, [r7, #0]
        err = HAL_FLASH_Program(write_type, (flash_base + addr), (uint32_t)&dword[0]);
 81fa99e:	f104 6600 	add.w	r6, r4, #134217728	@ 0x8000000
  ARM_FLASH0_STATUS.busy = DRIVER_STATUS_BUSY;
 81fa9a2:	f043 0301 	orr.w	r3, r3, #1
 81fa9a6:	603b      	str	r3, [r7, #0]
    memcpy(dword, (void *)((uint32_t)data + loop), sizeof(dword));
 81fa9a8:	466c      	mov	r4, sp
 81fa9aa:	eb08 0305 	add.w	r3, r8, r5
 81fa9ae:	f103 0c10 	add.w	ip, r3, #16
 81fa9b2:	4622      	mov	r2, r4
 81fa9b4:	6818      	ldr	r0, [r3, #0]
 81fa9b6:	6859      	ldr	r1, [r3, #4]
 81fa9b8:	3308      	adds	r3, #8
 81fa9ba:	c203      	stmia	r2!, {r0, r1}
 81fa9bc:	4563      	cmp	r3, ip
 81fa9be:	4614      	mov	r4, r2
 81fa9c0:	d1f7      	bne.n	81fa9b2 <Flash_ProgramData+0x7e>
    if ((dword[0] != -1) || (dword[1] != -1))
 81fa9c2:	9b00      	ldr	r3, [sp, #0]
 81fa9c4:	9a02      	ldr	r2, [sp, #8]
 81fa9c6:	9903      	ldr	r1, [sp, #12]
 81fa9c8:	401a      	ands	r2, r3
 81fa9ca:	9b01      	ldr	r3, [sp, #4]
 81fa9cc:	400b      	ands	r3, r1
 81fa9ce:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 81fa9d2:	bf08      	it	eq
 81fa9d4:	f1b2 3fff 	cmpeq.w	r2, #4294967295	@ 0xffffffff
 81fa9d8:	d0dc      	beq.n	81fa994 <Flash_ProgramData+0x60>
        err = HAL_FLASH_Program(write_type, (flash_base + addr), (uint32_t)&dword[0]);
 81fa9da:	466a      	mov	r2, sp
 81fa9dc:	2001      	movs	r0, #1
 81fa9de:	1971      	adds	r1, r6, r5
 81fa9e0:	f000 fce2 	bl	81fb3a8 <HAL_FLASH_Program>
 81fa9e4:	4604      	mov	r4, r0
    loop += sizeof(dword);
 81fa9e6:	3510      	adds	r5, #16
  } while ((loop != cnt) && (err == HAL_OK));
 81fa9e8:	45a9      	cmp	r9, r5
 81fa9ea:	d001      	beq.n	81fa9f0 <Flash_ProgramData+0xbc>
 81fa9ec:	2c00      	cmp	r4, #0
 81fa9ee:	d0db      	beq.n	81fa9a8 <Flash_ProgramData+0x74>
  ARM_FLASH0_STATUS.busy = DRIVER_STATUS_IDLE;
 81fa9f0:	683b      	ldr	r3, [r7, #0]
 81fa9f2:	f36f 0300 	bfc	r3, #0, #1
 81fa9f6:	603b      	str	r3, [r7, #0]
  HAL_FLASH_Lock();
 81fa9f8:	f000 fca0 	bl	81fb33c <HAL_FLASH_Lock>
  return (err == HAL_OK) ? ARM_DRIVER_OK : ARM_DRIVER_ERROR;
 81fa9fc:	1e20      	subs	r0, r4, #0
 81fa9fe:	bf18      	it	ne
 81faa00:	2001      	movne	r0, #1
 81faa02:	4240      	negs	r0, r0
 81faa04:	e7b9      	b.n	81fa97a <Flash_ProgramData+0x46>
 81faa06:	bf00      	nop
 81faa08:	2000017c 	.word	0x2000017c
 81faa0c:	20000000 	.word	0x20000000

081faa10 <Flash_EraseSector>:
{
 81faa10:	b530      	push	{r4, r5, lr}
  if (!(is_range_valid(&ARM_FLASH0_DEV, addr)) ||
 81faa12:	f5b0 1f00 	cmp.w	r0, #2097152	@ 0x200000
{
 81faa16:	b087      	sub	sp, #28
  if (!(is_range_valid(&ARM_FLASH0_DEV, addr)) ||
 81faa18:	d208      	bcs.n	81faa2c <Flash_EraseSector+0x1c>
  return ((param % (flash_dev->data->sector_size)) != 0) ? (false) : (true);
 81faa1a:	f3c0 030c 	ubfx	r3, r0, #0, #13
  if (!(is_range_valid(&ARM_FLASH0_DEV, addr)) ||
 81faa1e:	b92b      	cbnz	r3, 81faa2c <Flash_EraseSector+0x1c>
  for (nb = 0; nb < vect->nb; nb++)
 81faa20:	4a1f      	ldr	r2, [pc, #124]	@ (81faaa0 <Flash_EraseSector+0x90>)
    if ((param >= vect->range[nb].base) && (param <= vect->range[nb].limit))
 81faa22:	e9d2 1200 	ldrd	r1, r2, [r2]
 81faa26:	1d14      	adds	r4, r2, #4
  for (nb = 0; nb < vect->nb; nb++)
 81faa28:	428b      	cmp	r3, r1
 81faa2a:	d108      	bne.n	81faa3e <Flash_EraseSector+0x2e>
    return ARM_DRIVER_ERROR_PARAMETER;
 81faa2c:	f06f 0004 	mvn.w	r0, #4
    ARM_FLASH0_STATUS.error = DRIVER_STATUS_ERROR;
 81faa30:	4a1c      	ldr	r2, [pc, #112]	@ (81faaa4 <Flash_EraseSector+0x94>)
 81faa32:	6813      	ldr	r3, [r2, #0]
 81faa34:	f043 0302 	orr.w	r3, r3, #2
 81faa38:	6013      	str	r3, [r2, #0]
}
 81faa3a:	b007      	add	sp, #28
 81faa3c:	bd30      	pop	{r4, r5, pc}
    if ((param >= vect->range[nb].base) && (param <= vect->range[nb].limit))
 81faa3e:	f852 5033 	ldr.w	r5, [r2, r3, lsl #3]
 81faa42:	42a8      	cmp	r0, r5
 81faa44:	d303      	bcc.n	81faa4e <Flash_EraseSector+0x3e>
 81faa46:	f854 5033 	ldr.w	r5, [r4, r3, lsl #3]
 81faa4a:	42a8      	cmp	r0, r5
 81faa4c:	d901      	bls.n	81faa52 <Flash_EraseSector+0x42>
  for (nb = 0; nb < vect->nb; nb++)
 81faa4e:	3301      	adds	r3, #1
 81faa50:	e7ea      	b.n	81faa28 <Flash_EraseSector+0x18>
  EraseInit.TypeErase = FLASH_TYPEERASE_PAGES;
 81faa52:	2302      	movs	r3, #2
  return ((param >= (FLASH_TOTAL_SIZE / 2)) ? 2 : 1);
 81faa54:	f5b0 1f80 	cmp.w	r0, #1048576	@ 0x100000
  EraseInit.TypeErase = FLASH_TYPEERASE_PAGES;
 81faa58:	9302      	str	r3, [sp, #8]
  return ((param >= (FLASH_TOTAL_SIZE / 2)) ? 2 : 1);
 81faa5a:	bf38      	it	cc
 81faa5c:	2301      	movcc	r3, #1
  EraseInit.Banks = bank_number(&ARM_FLASH0_DEV, addr);
 81faa5e:	9303      	str	r3, [sp, #12]
  EraseInit.NbPages = 1;
 81faa60:	2301      	movs	r3, #1
  ARM_FLASH0_STATUS.error = DRIVER_STATUS_NO_ERROR;
 81faa62:	4d10      	ldr	r5, [pc, #64]	@ (81faaa4 <Flash_EraseSector+0x94>)
  uint32_t page = param / flash_dev->data->page_size ;
 81faa64:	0b40      	lsrs	r0, r0, #13
  EraseInit.NbPages = 1;
 81faa66:	9305      	str	r3, [sp, #20]
  EraseInit.Page = page_number(&ARM_FLASH0_DEV, addr);
 81faa68:	9004      	str	r0, [sp, #16]
  ARM_FLASH0_STATUS.error = DRIVER_STATUS_NO_ERROR;
 81faa6a:	682b      	ldr	r3, [r5, #0]
 81faa6c:	f36f 0341 	bfc	r3, #1, #1
 81faa70:	602b      	str	r3, [r5, #0]
  HAL_FLASH_Unlock();
 81faa72:	f000 fc51 	bl	81fb318 <HAL_FLASH_Unlock>
  ARM_FLASH0_STATUS.busy = DRIVER_STATUS_BUSY;
 81faa76:	682b      	ldr	r3, [r5, #0]
  err = HAL_FLASHEx_Erase(&EraseInit, &pageError);
 81faa78:	a901      	add	r1, sp, #4
  ARM_FLASH0_STATUS.busy = DRIVER_STATUS_BUSY;
 81faa7a:	f043 0301 	orr.w	r3, r3, #1
 81faa7e:	602b      	str	r3, [r5, #0]
  err = HAL_FLASHEx_Erase(&EraseInit, &pageError);
 81faa80:	a802      	add	r0, sp, #8
 81faa82:	f000 fcef 	bl	81fb464 <HAL_FLASHEx_Erase>
 81faa86:	4604      	mov	r4, r0
  ARM_FLASH0_STATUS.busy = DRIVER_STATUS_IDLE;
 81faa88:	682b      	ldr	r3, [r5, #0]
 81faa8a:	f36f 0300 	bfc	r3, #0, #1
 81faa8e:	602b      	str	r3, [r5, #0]
  HAL_FLASH_Lock();
 81faa90:	f000 fc54 	bl	81fb33c <HAL_FLASH_Lock>
  return (err == HAL_OK) ? ARM_DRIVER_OK : ARM_DRIVER_ERROR;
 81faa94:	1e20      	subs	r0, r4, #0
 81faa96:	bf18      	it	ne
 81faa98:	2001      	movne	r0, #1
 81faa9a:	4240      	negs	r0, r0
 81faa9c:	e7cd      	b.n	81faa3a <Flash_EraseSector+0x2a>
 81faa9e:	bf00      	nop
 81faaa0:	20000000 	.word	0x20000000
 81faaa4:	2000017c 	.word	0x2000017c

081faaa8 <__io_putchar>:

/* Private typedef -----------------------------------------------------------*/
/* Private define ------------------------------------------------------------*/

PUTCHAR_PROTOTYPE
{
 81faaa8:	b507      	push	{r0, r1, r2, lr}
  COM_Transmit((uint8_t*)&ch, 1, TX_TIMEOUT);
 81faaaa:	2264      	movs	r2, #100	@ 0x64
{
 81faaac:	9001      	str	r0, [sp, #4]
  COM_Transmit((uint8_t*)&ch, 1, TX_TIMEOUT);
 81faaae:	2101      	movs	r1, #1
 81faab0:	a801      	add	r0, sp, #4
 81faab2:	f7ff fc93 	bl	81fa3dc <COM_Transmit>
  return ch;
}
 81faab6:	9801      	ldr	r0, [sp, #4]
 81faab8:	b003      	add	sp, #12
 81faaba:	f85d fb04 	ldr.w	pc, [sp], #4

081faabe <_write>:
  return ch;
}
#elif defined(__GNUC__)
/* Redirects printf to TFM_DRIVER_STDIO in case of GNUARM */
int _write(int fd, char *str, int len)
{
 81faabe:	b570      	push	{r4, r5, r6, lr}
 81faac0:	460e      	mov	r6, r1
 81faac2:	4614      	mov	r4, r2
  int i;

  for (i = 0; i < len; i++)
 81faac4:	2500      	movs	r5, #0
 81faac6:	42a5      	cmp	r5, r4
 81faac8:	db01      	blt.n	81faace <_write+0x10>
    __io_putchar(str[i]);
  }

  /* Return the number of characters written */
  return len;
}
 81faaca:	4620      	mov	r0, r4
 81faacc:	bd70      	pop	{r4, r5, r6, pc}
    __io_putchar(str[i]);
 81faace:	5d70      	ldrb	r0, [r6, r5]
 81faad0:	f7ff ffea 	bl	81faaa8 <__io_putchar>
  for (i = 0; i < len; i++)
 81faad4:	3501      	adds	r5, #1
 81faad6:	e7f6      	b.n	81faac6 <_write+0x8>

081faad8 <main>:
  * @param  None
  * @retval None
  */
int main(int argc, char **argv)
/*int main(void) */
{
 81faad8:	b508      	push	{r3, lr}
  duration should be kept 1ms since PPP_TIMEOUT_VALUEs are defined and
  handled in milliseconds basis.
  - Set NVIC Group Priority to 3
  - Low Level Initialization
  */
  HAL_Init();
 81faada:	f000 fad9 	bl	81fb090 <HAL_Init>

  /* Configure Communication module */
  COM_Init();
 81faade:	f7ff fc09 	bl	81fa2f4 <COM_Init>

  printf("\r\n======================================================================");
 81faae2:	480a      	ldr	r0, [pc, #40]	@ (81fab0c <main+0x34>)
 81faae4:	f002 facc 	bl	81fd080 <iprintf>
  printf("\r\n=              (C) COPYRIGHT 2021 STMicroelectronics                 =");
 81faae8:	4809      	ldr	r0, [pc, #36]	@ (81fab10 <main+0x38>)
 81faaea:	f002 fac9 	bl	81fd080 <iprintf>
  printf("\r\n=                                                                    =");
 81faaee:	4809      	ldr	r0, [pc, #36]	@ (81fab14 <main+0x3c>)
 81faaf0:	f002 fac6 	bl	81fd080 <iprintf>
  printf("\r\n=                          LOCAL LOADER                              =");
 81faaf4:	4808      	ldr	r0, [pc, #32]	@ (81fab18 <main+0x40>)
 81faaf6:	f002 fac3 	bl	81fd080 <iprintf>
  printf("\r\n======================================================================");
 81faafa:	4804      	ldr	r0, [pc, #16]	@ (81fab0c <main+0x34>)
 81faafc:	f002 fac0 	bl	81fd080 <iprintf>
  printf("\r\n\r\n");
 81fab00:	4806      	ldr	r0, [pc, #24]	@ (81fab1c <main+0x44>)
 81fab02:	f002 fb25 	bl	81fd150 <puts>

  /* User App firmware runs*/
  FW_UPDATE_Run();
 81fab06:	f7ff fde5 	bl	81fa6d4 <FW_UPDATE_Run>

  while (1U)
 81fab0a:	e7fe      	b.n	81fab0a <main+0x32>
 81fab0c:	081fe798 	.word	0x081fe798
 81fab10:	081fe7e1 	.word	0x081fe7e1
 81fab14:	081fe82a 	.word	0x081fe82a
 81fab18:	081fe873 	.word	0x081fe873
 81fab1c:	081fe8bc 	.word	0x081fe8bc

081fab20 <NMI_Handler>:
__WEAK void handler_name(void) { \
    while(1); \
}

/* Exceptions */
DEFAULT_IRQ_HANDLER(NMI_Handler)
 81fab20:	e7fe      	b.n	81fab20 <NMI_Handler>

081fab22 <HardFault_Handler>:
DEFAULT_IRQ_HANDLER(HardFault_Handler)
 81fab22:	e7fe      	b.n	81fab22 <HardFault_Handler>

081fab24 <MemManage_Handler>:
DEFAULT_IRQ_HANDLER(MemManage_Handler)
 81fab24:	e7fe      	b.n	81fab24 <MemManage_Handler>

081fab26 <BusFault_Handler>:
DEFAULT_IRQ_HANDLER(BusFault_Handler)
 81fab26:	e7fe      	b.n	81fab26 <BusFault_Handler>

081fab28 <UsageFault_Handler>:
DEFAULT_IRQ_HANDLER(UsageFault_Handler)
 81fab28:	e7fe      	b.n	81fab28 <UsageFault_Handler>

081fab2a <SecureFault_Handler>:
DEFAULT_IRQ_HANDLER(SecureFault_Handler)
 81fab2a:	e7fe      	b.n	81fab2a <SecureFault_Handler>

081fab2c <SVC_Handler>:
DEFAULT_IRQ_HANDLER(SVC_Handler)
 81fab2c:	e7fe      	b.n	81fab2c <SVC_Handler>

081fab2e <DebugMon_Handler>:
DEFAULT_IRQ_HANDLER(DebugMon_Handler)
 81fab2e:	e7fe      	b.n	81fab2e <DebugMon_Handler>

081fab30 <PendSV_Handler>:
DEFAULT_IRQ_HANDLER(PendSV_Handler)
 81fab30:	e7fe      	b.n	81fab30 <PendSV_Handler>

081fab32 <SysTick_Handler>:
DEFAULT_IRQ_HANDLER(SysTick_Handler)
 81fab32:	e7fe      	b.n	81fab32 <SysTick_Handler>

081fab34 <WWDG_IRQHandler>:

DEFAULT_IRQ_HANDLER(WWDG_IRQHandler)
 81fab34:	e7fe      	b.n	81fab34 <WWDG_IRQHandler>

081fab36 <PVD_PVM_IRQHandler>:
DEFAULT_IRQ_HANDLER(PVD_PVM_IRQHandler)
 81fab36:	e7fe      	b.n	81fab36 <PVD_PVM_IRQHandler>

081fab38 <RTC_IRQHandler>:
DEFAULT_IRQ_HANDLER(RTC_IRQHandler)
 81fab38:	e7fe      	b.n	81fab38 <RTC_IRQHandler>

081fab3a <RTC_IRQHandler_S>:
DEFAULT_IRQ_HANDLER(RTC_IRQHandler_S)
 81fab3a:	e7fe      	b.n	81fab3a <RTC_IRQHandler_S>

081fab3c <TAMP_IRQHandler>:
DEFAULT_IRQ_HANDLER(TAMP_IRQHandler)
 81fab3c:	e7fe      	b.n	81fab3c <TAMP_IRQHandler>

081fab3e <RAMCFG_IRQHandler>:
DEFAULT_IRQ_HANDLER(RAMCFG_IRQHandler)
 81fab3e:	e7fe      	b.n	81fab3e <RAMCFG_IRQHandler>

081fab40 <FLASH_IRQHandler>:
DEFAULT_IRQ_HANDLER(FLASH_IRQHandler)
 81fab40:	e7fe      	b.n	81fab40 <FLASH_IRQHandler>

081fab42 <FLASH_IRQHandler_S>:
DEFAULT_IRQ_HANDLER(FLASH_IRQHandler_S)
 81fab42:	e7fe      	b.n	81fab42 <FLASH_IRQHandler_S>

081fab44 <GTZC_IRQHandler>:
DEFAULT_IRQ_HANDLER(GTZC_IRQHandler)
 81fab44:	e7fe      	b.n	81fab44 <GTZC_IRQHandler>

081fab46 <RCC_IRQHandler>:
DEFAULT_IRQ_HANDLER(RCC_IRQHandler)
 81fab46:	e7fe      	b.n	81fab46 <RCC_IRQHandler>

081fab48 <RCC_IRQHandler_S>:
DEFAULT_IRQ_HANDLER(RCC_IRQHandler_S)
 81fab48:	e7fe      	b.n	81fab48 <RCC_IRQHandler_S>

081fab4a <EXTI0_IRQHandler>:
DEFAULT_IRQ_HANDLER(EXTI0_IRQHandler)
 81fab4a:	e7fe      	b.n	81fab4a <EXTI0_IRQHandler>

081fab4c <EXTI1_IRQHandler>:
DEFAULT_IRQ_HANDLER(EXTI1_IRQHandler)
 81fab4c:	e7fe      	b.n	81fab4c <EXTI1_IRQHandler>

081fab4e <EXTI2_IRQHandler>:
DEFAULT_IRQ_HANDLER(EXTI2_IRQHandler)
 81fab4e:	e7fe      	b.n	81fab4e <EXTI2_IRQHandler>

081fab50 <EXTI3_IRQHandler>:
DEFAULT_IRQ_HANDLER(EXTI3_IRQHandler)
 81fab50:	e7fe      	b.n	81fab50 <EXTI3_IRQHandler>

081fab52 <EXTI4_IRQHandler>:
DEFAULT_IRQ_HANDLER(EXTI4_IRQHandler)
 81fab52:	e7fe      	b.n	81fab52 <EXTI4_IRQHandler>

081fab54 <EXTI5_IRQHandler>:
DEFAULT_IRQ_HANDLER(EXTI5_IRQHandler)
 81fab54:	e7fe      	b.n	81fab54 <EXTI5_IRQHandler>

081fab56 <EXTI6_IRQHandler>:
DEFAULT_IRQ_HANDLER(EXTI6_IRQHandler)
 81fab56:	e7fe      	b.n	81fab56 <EXTI6_IRQHandler>

081fab58 <EXTI7_IRQHandler>:
DEFAULT_IRQ_HANDLER(EXTI7_IRQHandler)
 81fab58:	e7fe      	b.n	81fab58 <EXTI7_IRQHandler>

081fab5a <EXTI8_IRQHandler>:
DEFAULT_IRQ_HANDLER(EXTI8_IRQHandler)
 81fab5a:	e7fe      	b.n	81fab5a <EXTI8_IRQHandler>

081fab5c <EXTI9_IRQHandler>:
DEFAULT_IRQ_HANDLER(EXTI9_IRQHandler)
 81fab5c:	e7fe      	b.n	81fab5c <EXTI9_IRQHandler>

081fab5e <EXTI10_IRQHandler>:
DEFAULT_IRQ_HANDLER(EXTI10_IRQHandler)
 81fab5e:	e7fe      	b.n	81fab5e <EXTI10_IRQHandler>

081fab60 <EXTI11_IRQHandler>:
DEFAULT_IRQ_HANDLER(EXTI11_IRQHandler)
 81fab60:	e7fe      	b.n	81fab60 <EXTI11_IRQHandler>

081fab62 <EXTI12_IRQHandler>:
DEFAULT_IRQ_HANDLER(EXTI12_IRQHandler)
 81fab62:	e7fe      	b.n	81fab62 <EXTI12_IRQHandler>

081fab64 <EXTI13_IRQHandler>:
DEFAULT_IRQ_HANDLER(EXTI13_IRQHandler)
 81fab64:	e7fe      	b.n	81fab64 <EXTI13_IRQHandler>

081fab66 <EXTI14_IRQHandler>:
DEFAULT_IRQ_HANDLER(EXTI14_IRQHandler)
 81fab66:	e7fe      	b.n	81fab66 <EXTI14_IRQHandler>

081fab68 <EXTI15_IRQHandler>:
DEFAULT_IRQ_HANDLER(EXTI15_IRQHandler)
 81fab68:	e7fe      	b.n	81fab68 <EXTI15_IRQHandler>

081fab6a <IWDG_IRQHandler>:
DEFAULT_IRQ_HANDLER(IWDG_IRQHandler)
 81fab6a:	e7fe      	b.n	81fab6a <IWDG_IRQHandler>

081fab6c <SAES_IRQHandler>:
#if defined(STM32U585xx) || defined(STM32U5A5xx) || defined(STM32U5A9xx) || defined(STM32U545xx)
DEFAULT_IRQ_HANDLER(SAES_IRQHandler)
 81fab6c:	e7fe      	b.n	81fab6c <SAES_IRQHandler>

081fab6e <GPDMA1_Channel0_IRQHandler>:
#endif /* defined(STM32U585xx) || defined(STM32U5A5xx) || defined(STM32U5A9xx) || defined(STM32U545xx) */
DEFAULT_IRQ_HANDLER(GPDMA1_Channel0_IRQHandler)
 81fab6e:	e7fe      	b.n	81fab6e <GPDMA1_Channel0_IRQHandler>

081fab70 <GPDMA1_Channel1_IRQHandler>:
DEFAULT_IRQ_HANDLER(GPDMA1_Channel1_IRQHandler)
 81fab70:	e7fe      	b.n	81fab70 <GPDMA1_Channel1_IRQHandler>

081fab72 <GPDMA1_Channel2_IRQHandler>:
DEFAULT_IRQ_HANDLER(GPDMA1_Channel2_IRQHandler)
 81fab72:	e7fe      	b.n	81fab72 <GPDMA1_Channel2_IRQHandler>

081fab74 <GPDMA1_Channel3_IRQHandler>:
DEFAULT_IRQ_HANDLER(GPDMA1_Channel3_IRQHandler)
 81fab74:	e7fe      	b.n	81fab74 <GPDMA1_Channel3_IRQHandler>

081fab76 <GPDMA1_Channel4_IRQHandler>:
DEFAULT_IRQ_HANDLER(GPDMA1_Channel4_IRQHandler)
 81fab76:	e7fe      	b.n	81fab76 <GPDMA1_Channel4_IRQHandler>

081fab78 <GPDMA1_Channel5_IRQHandler>:
DEFAULT_IRQ_HANDLER(GPDMA1_Channel5_IRQHandler)
 81fab78:	e7fe      	b.n	81fab78 <GPDMA1_Channel5_IRQHandler>

081fab7a <GPDMA1_Channel6_IRQHandler>:
DEFAULT_IRQ_HANDLER(GPDMA1_Channel6_IRQHandler)
 81fab7a:	e7fe      	b.n	81fab7a <GPDMA1_Channel6_IRQHandler>

081fab7c <GPDMA1_Channel7_IRQHandler>:
DEFAULT_IRQ_HANDLER(GPDMA1_Channel7_IRQHandler)
 81fab7c:	e7fe      	b.n	81fab7c <GPDMA1_Channel7_IRQHandler>

081fab7e <ADC1_IRQHandler>:
#if defined(STM32U585xx) || defined(STM32U575xx) || defined(STM32U535xx) || defined(STM32U545xx)
DEFAULT_IRQ_HANDLER(ADC1_IRQHandler)
 81fab7e:	e7fe      	b.n	81fab7e <ADC1_IRQHandler>

081fab80 <DAC1_IRQHandler>:
#else
DEFAULT_IRQ_HANDLER(ADC1_2_IRQHandler)
#endif /* defined(STM32U585xx) || defined(STM32U575xx) || defined(STM32U535xx) || defined(STM32U545xx) */
DEFAULT_IRQ_HANDLER(DAC1_IRQHandler)
 81fab80:	e7fe      	b.n	81fab80 <DAC1_IRQHandler>

081fab82 <FDCAN1_IT0_IRQHandler>:
DEFAULT_IRQ_HANDLER(FDCAN1_IT0_IRQHandler)
 81fab82:	e7fe      	b.n	81fab82 <FDCAN1_IT0_IRQHandler>

081fab84 <FDCAN1_IT1_IRQHandler>:
DEFAULT_IRQ_HANDLER(FDCAN1_IT1_IRQHandler)
 81fab84:	e7fe      	b.n	81fab84 <FDCAN1_IT1_IRQHandler>

081fab86 <TIM1_BRK_IRQHandler>:
DEFAULT_IRQ_HANDLER(TIM1_BRK_IRQHandler)
 81fab86:	e7fe      	b.n	81fab86 <TIM1_BRK_IRQHandler>

081fab88 <TIM1_UP_IRQHandler>:
DEFAULT_IRQ_HANDLER(TIM1_UP_IRQHandler)
 81fab88:	e7fe      	b.n	81fab88 <TIM1_UP_IRQHandler>

081fab8a <TIM1_TRG_COM_IRQHandler>:
DEFAULT_IRQ_HANDLER(TIM1_TRG_COM_IRQHandler)
 81fab8a:	e7fe      	b.n	81fab8a <TIM1_TRG_COM_IRQHandler>

081fab8c <TIM1_CC_IRQHandler>:
DEFAULT_IRQ_HANDLER(TIM1_CC_IRQHandler)
 81fab8c:	e7fe      	b.n	81fab8c <TIM1_CC_IRQHandler>

081fab8e <TIM2_IRQHandler>:
DEFAULT_IRQ_HANDLER(TIM2_IRQHandler)
 81fab8e:	e7fe      	b.n	81fab8e <TIM2_IRQHandler>

081fab90 <TIM3_IRQHandler>:
DEFAULT_IRQ_HANDLER(TIM3_IRQHandler)
 81fab90:	e7fe      	b.n	81fab90 <TIM3_IRQHandler>

081fab92 <TIM4_IRQHandler>:
DEFAULT_IRQ_HANDLER(TIM4_IRQHandler)
 81fab92:	e7fe      	b.n	81fab92 <TIM4_IRQHandler>

081fab94 <TIM5_IRQHandler>:
DEFAULT_IRQ_HANDLER(TIM5_IRQHandler)
 81fab94:	e7fe      	b.n	81fab94 <TIM5_IRQHandler>

081fab96 <TIM6_IRQHandler>:
DEFAULT_IRQ_HANDLER(TIM6_IRQHandler)
 81fab96:	e7fe      	b.n	81fab96 <TIM6_IRQHandler>

081fab98 <TIM7_IRQHandler>:
DEFAULT_IRQ_HANDLER(TIM7_IRQHandler)
 81fab98:	e7fe      	b.n	81fab98 <TIM7_IRQHandler>

081fab9a <TIM8_BRK_IRQHandler>:
DEFAULT_IRQ_HANDLER(TIM8_BRK_IRQHandler)
 81fab9a:	e7fe      	b.n	81fab9a <TIM8_BRK_IRQHandler>

081fab9c <TIM8_UP_IRQHandler>:
DEFAULT_IRQ_HANDLER(TIM8_UP_IRQHandler)
 81fab9c:	e7fe      	b.n	81fab9c <TIM8_UP_IRQHandler>

081fab9e <TIM8_TRG_COM_IRQHandler>:
DEFAULT_IRQ_HANDLER(TIM8_TRG_COM_IRQHandler)
 81fab9e:	e7fe      	b.n	81fab9e <TIM8_TRG_COM_IRQHandler>

081faba0 <TIM8_CC_IRQHandler>:
DEFAULT_IRQ_HANDLER(TIM8_CC_IRQHandler)
 81faba0:	e7fe      	b.n	81faba0 <TIM8_CC_IRQHandler>

081faba2 <I2C1_EV_IRQHandler>:
DEFAULT_IRQ_HANDLER(I2C1_EV_IRQHandler)
 81faba2:	e7fe      	b.n	81faba2 <I2C1_EV_IRQHandler>

081faba4 <I2C1_ER_IRQHandler>:
DEFAULT_IRQ_HANDLER(I2C1_ER_IRQHandler)
 81faba4:	e7fe      	b.n	81faba4 <I2C1_ER_IRQHandler>

081faba6 <I2C2_EV_IRQHandler>:
DEFAULT_IRQ_HANDLER(I2C2_EV_IRQHandler)
 81faba6:	e7fe      	b.n	81faba6 <I2C2_EV_IRQHandler>

081faba8 <I2C2_ER_IRQHandler>:
DEFAULT_IRQ_HANDLER(I2C2_ER_IRQHandler)
 81faba8:	e7fe      	b.n	81faba8 <I2C2_ER_IRQHandler>

081fabaa <SPI1_IRQHandler>:
DEFAULT_IRQ_HANDLER(SPI1_IRQHandler)
 81fabaa:	e7fe      	b.n	81fabaa <SPI1_IRQHandler>

081fabac <SPI2_IRQHandler>:
DEFAULT_IRQ_HANDLER(SPI2_IRQHandler)
 81fabac:	e7fe      	b.n	81fabac <SPI2_IRQHandler>

081fabae <USART1_IRQHandler>:
DEFAULT_IRQ_HANDLER(USART1_IRQHandler)
 81fabae:	e7fe      	b.n	81fabae <USART1_IRQHandler>

081fabb0 <USART2_IRQHandler>:
#if !(defined(STM32U535xx) || defined(STM32U545xx))
DEFAULT_IRQ_HANDLER(USART2_IRQHandler)
 81fabb0:	e7fe      	b.n	81fabb0 <USART2_IRQHandler>

081fabb2 <USART3_IRQHandler>:
#endif /* !(defined(STM32U535xx) || defined(STM32U545xx)) */
DEFAULT_IRQ_HANDLER(USART3_IRQHandler)
 81fabb2:	e7fe      	b.n	81fabb2 <USART3_IRQHandler>

081fabb4 <UART4_IRQHandler>:
DEFAULT_IRQ_HANDLER(UART4_IRQHandler)
 81fabb4:	e7fe      	b.n	81fabb4 <UART4_IRQHandler>

081fabb6 <UART5_IRQHandler>:
DEFAULT_IRQ_HANDLER(UART5_IRQHandler)
 81fabb6:	e7fe      	b.n	81fabb6 <UART5_IRQHandler>

081fabb8 <LPUART1_IRQHandler>:
DEFAULT_IRQ_HANDLER(LPUART1_IRQHandler)
 81fabb8:	e7fe      	b.n	81fabb8 <LPUART1_IRQHandler>

081fabba <LPTIM1_IRQHandler>:
DEFAULT_IRQ_HANDLER(LPTIM1_IRQHandler)
 81fabba:	e7fe      	b.n	81fabba <LPTIM1_IRQHandler>

081fabbc <LPTIM2_IRQHandler>:
DEFAULT_IRQ_HANDLER(LPTIM2_IRQHandler)
 81fabbc:	e7fe      	b.n	81fabbc <LPTIM2_IRQHandler>

081fabbe <TIM15_IRQHandler>:
DEFAULT_IRQ_HANDLER(TIM15_IRQHandler)
 81fabbe:	e7fe      	b.n	81fabbe <TIM15_IRQHandler>

081fabc0 <TIM16_IRQHandler>:
DEFAULT_IRQ_HANDLER(TIM16_IRQHandler)
 81fabc0:	e7fe      	b.n	81fabc0 <TIM16_IRQHandler>

081fabc2 <TIM17_IRQHandler>:
DEFAULT_IRQ_HANDLER(TIM17_IRQHandler)
 81fabc2:	e7fe      	b.n	81fabc2 <TIM17_IRQHandler>

081fabc4 <COMP_IRQHandler>:
DEFAULT_IRQ_HANDLER(COMP_IRQHandler)
 81fabc4:	e7fe      	b.n	81fabc4 <COMP_IRQHandler>

081fabc6 <OTG_FS_IRQHandler>:
#if defined(STM32U535xx) || defined(STM32U545xx)
DEFAULT_IRQ_HANDLER(USB_IRQHandler)
#elif defined(STM32U585xx) || defined(STM32U575xx)
DEFAULT_IRQ_HANDLER(OTG_FS_IRQHandler)
 81fabc6:	e7fe      	b.n	81fabc6 <OTG_FS_IRQHandler>

081fabc8 <CRS_IRQHandler>:
#else
DEFAULT_IRQ_HANDLER(OTG_HS_IRQHandler)
#endif /* defined(STM32U535xx) || defined(STM32U545xx) */
DEFAULT_IRQ_HANDLER(CRS_IRQHandler)
 81fabc8:	e7fe      	b.n	81fabc8 <CRS_IRQHandler>

081fabca <FMC_IRQHandler>:
#if !(defined(STM32U535xx) || defined(STM32U545xx))
DEFAULT_IRQ_HANDLER(FMC_IRQHandler)
 81fabca:	e7fe      	b.n	81fabca <FMC_IRQHandler>

081fabcc <OCTOSPI1_IRQHandler>:
#endif /* !(defined(STM32U535xx) || defined(STM32U545xx)) */
DEFAULT_IRQ_HANDLER(OCTOSPI1_IRQHandler)
 81fabcc:	e7fe      	b.n	81fabcc <OCTOSPI1_IRQHandler>

081fabce <PWR_S3WU_IRQHandler>:
DEFAULT_IRQ_HANDLER(PWR_S3WU_IRQHandler)
 81fabce:	e7fe      	b.n	81fabce <PWR_S3WU_IRQHandler>

081fabd0 <SDMMC1_IRQHandler>:
DEFAULT_IRQ_HANDLER(SDMMC1_IRQHandler)
 81fabd0:	e7fe      	b.n	81fabd0 <SDMMC1_IRQHandler>

081fabd2 <SDMMC2_IRQHandler>:
#if !(defined(STM32U535xx) || defined(STM32U545xx))
DEFAULT_IRQ_HANDLER(SDMMC2_IRQHandler)
 81fabd2:	e7fe      	b.n	81fabd2 <SDMMC2_IRQHandler>

081fabd4 <GPDMA1_Channel8_IRQHandler>:
#endif /* !(defined(STM32U535xx) || defined(STM32U545xx)) */

DEFAULT_IRQ_HANDLER(DMA2_Channel1_IRQHandler)
DEFAULT_IRQ_HANDLER(GPDMA1_Channel8_IRQHandler)
 81fabd4:	e7fe      	b.n	81fabd4 <GPDMA1_Channel8_IRQHandler>

081fabd6 <GPDMA1_Channel9_IRQHandler>:
DEFAULT_IRQ_HANDLER(GPDMA1_Channel9_IRQHandler)
 81fabd6:	e7fe      	b.n	81fabd6 <GPDMA1_Channel9_IRQHandler>

081fabd8 <GPDMA1_Channel10_IRQHandler>:
DEFAULT_IRQ_HANDLER(GPDMA1_Channel10_IRQHandler)
 81fabd8:	e7fe      	b.n	81fabd8 <GPDMA1_Channel10_IRQHandler>

081fabda <GPDMA1_Channel11_IRQHandler>:
DEFAULT_IRQ_HANDLER(GPDMA1_Channel11_IRQHandler)
 81fabda:	e7fe      	b.n	81fabda <GPDMA1_Channel11_IRQHandler>

081fabdc <GPDMA1_Channel12_IRQHandler>:
DEFAULT_IRQ_HANDLER(GPDMA1_Channel12_IRQHandler)
 81fabdc:	e7fe      	b.n	81fabdc <GPDMA1_Channel12_IRQHandler>

081fabde <GPDMA1_Channel13_IRQHandler>:
DEFAULT_IRQ_HANDLER(GPDMA1_Channel13_IRQHandler)
 81fabde:	e7fe      	b.n	81fabde <GPDMA1_Channel13_IRQHandler>

081fabe0 <GPDMA1_Channel14_IRQHandler>:
DEFAULT_IRQ_HANDLER(GPDMA1_Channel14_IRQHandler)
 81fabe0:	e7fe      	b.n	81fabe0 <GPDMA1_Channel14_IRQHandler>

081fabe2 <GPDMA1_Channel15_IRQHandler>:
DEFAULT_IRQ_HANDLER(GPDMA1_Channel15_IRQHandler)
 81fabe2:	e7fe      	b.n	81fabe2 <GPDMA1_Channel15_IRQHandler>

081fabe4 <I2C3_EV_IRQHandler>:
DEFAULT_IRQ_HANDLER(I2C3_EV_IRQHandler)
 81fabe4:	e7fe      	b.n	81fabe4 <I2C3_EV_IRQHandler>

081fabe6 <I2C3_ER_IRQHandler>:
DEFAULT_IRQ_HANDLER(I2C3_ER_IRQHandler)
 81fabe6:	e7fe      	b.n	81fabe6 <I2C3_ER_IRQHandler>

081fabe8 <SAI1_IRQHandler>:
DEFAULT_IRQ_HANDLER(SAI1_IRQHandler)
 81fabe8:	e7fe      	b.n	81fabe8 <SAI1_IRQHandler>

081fabea <SAI2_IRQHandler>:
#if !(defined(STM32U535xx) || defined(STM32U545xx))
DEFAULT_IRQ_HANDLER(SAI2_IRQHandler)
 81fabea:	e7fe      	b.n	81fabea <SAI2_IRQHandler>

081fabec <TSC_IRQHandler>:
#endif /* !(defined(STM32U535xx) || defined(STM32U545xx)) */
DEFAULT_IRQ_HANDLER(TSC_IRQHandler)
 81fabec:	e7fe      	b.n	81fabec <TSC_IRQHandler>

081fabee <AES_IRQHandler>:
#if defined(STM32U585xx) || defined(STM32U5A5xx) || defined(STM32U5A9xx) || defined(STM32U545xx)
DEFAULT_IRQ_HANDLER(AES_IRQHandler)
 81fabee:	e7fe      	b.n	81fabee <AES_IRQHandler>

081fabf0 <RNG_IRQHandler>:
#endif /* defined(STM32U585xx) || defined(STM32U5A5xx) || defined(STM32U5A9xx) || defined(STM32U545xx) */
DEFAULT_IRQ_HANDLER(RNG_IRQHandler)
 81fabf0:	e7fe      	b.n	81fabf0 <RNG_IRQHandler>

081fabf2 <FPU_IRQHandler>:
DEFAULT_IRQ_HANDLER(FPU_IRQHandler)
 81fabf2:	e7fe      	b.n	81fabf2 <FPU_IRQHandler>

081fabf4 <HASH_IRQHandler>:
DEFAULT_IRQ_HANDLER(HASH_IRQHandler)
 81fabf4:	e7fe      	b.n	81fabf4 <HASH_IRQHandler>

081fabf6 <PKA_IRQHandler>:
#if defined(STM32U585xx) || defined(STM32U5A5xx) || defined(STM32U5A9xx) || defined(STM32U545xx)
DEFAULT_IRQ_HANDLER(PKA_IRQHandler)
 81fabf6:	e7fe      	b.n	81fabf6 <PKA_IRQHandler>

081fabf8 <LPTIM3_IRQHandler>:
#endif /* defined(STM32U585xx) || defined(STM32U5A5xx) || defined(STM32U5A9xx) || defined(STM32U545xx) */
DEFAULT_IRQ_HANDLER(LPTIM3_IRQHandler)
 81fabf8:	e7fe      	b.n	81fabf8 <LPTIM3_IRQHandler>

081fabfa <SPI3_IRQHandler>:
DEFAULT_IRQ_HANDLER(SPI3_IRQHandler)
 81fabfa:	e7fe      	b.n	81fabfa <SPI3_IRQHandler>

081fabfc <I2C4_ER_IRQHandler>:
DEFAULT_IRQ_HANDLER(I2C4_ER_IRQHandler)
 81fabfc:	e7fe      	b.n	81fabfc <I2C4_ER_IRQHandler>

081fabfe <I2C4_EV_IRQHandler>:
DEFAULT_IRQ_HANDLER(I2C4_EV_IRQHandler)
 81fabfe:	e7fe      	b.n	81fabfe <I2C4_EV_IRQHandler>

081fac00 <MDF1_FLT0_IRQHandler>:
DEFAULT_IRQ_HANDLER(MDF1_FLT0_IRQHandler)
 81fac00:	e7fe      	b.n	81fac00 <MDF1_FLT0_IRQHandler>

081fac02 <MDF1_FLT1_IRQHandler>:
DEFAULT_IRQ_HANDLER(MDF1_FLT1_IRQHandler)
 81fac02:	e7fe      	b.n	81fac02 <MDF1_FLT1_IRQHandler>

081fac04 <MDF1_FLT2_IRQHandler>:
#if !(defined(STM32U535xx) || defined(STM32U545xx))
DEFAULT_IRQ_HANDLER(MDF1_FLT2_IRQHandler)
 81fac04:	e7fe      	b.n	81fac04 <MDF1_FLT2_IRQHandler>

081fac06 <MDF1_FLT3_IRQHandler>:
DEFAULT_IRQ_HANDLER(MDF1_FLT3_IRQHandler)
 81fac06:	e7fe      	b.n	81fac06 <MDF1_FLT3_IRQHandler>

081fac08 <UCPD1_IRQHandler>:
DEFAULT_IRQ_HANDLER(UCPD1_IRQHandler)
 81fac08:	e7fe      	b.n	81fac08 <UCPD1_IRQHandler>

081fac0a <ICACHE_IRQHandler>:
#endif /* !(defined(STM32U535xx) || defined(STM32U545xx)) */
DEFAULT_IRQ_HANDLER(ICACHE_IRQHandler)
 81fac0a:	e7fe      	b.n	81fac0a <ICACHE_IRQHandler>

081fac0c <OTFDEC1_IRQHandler>:
#if defined(STM32U545xx)
DEFAULT_IRQ_HANDLER(OTFDEC1_IRQHandler)
#elif defined(STM32U585xx) || defined(STM32U5A5xx) || defined(STM32U5A9xx)
DEFAULT_IRQ_HANDLER(OTFDEC1_IRQHandler)
 81fac0c:	e7fe      	b.n	81fac0c <OTFDEC1_IRQHandler>

081fac0e <OTFDEC2_IRQHandler>:
DEFAULT_IRQ_HANDLER(OTFDEC2_IRQHandler)
 81fac0e:	e7fe      	b.n	81fac0e <OTFDEC2_IRQHandler>

081fac10 <LPTIM4_IRQHandler>:
#endif /* defined(STM32U545xx) */
DEFAULT_IRQ_HANDLER(LPTIM4_IRQHandler)
 81fac10:	e7fe      	b.n	81fac10 <LPTIM4_IRQHandler>

081fac12 <DCACHE1_IRQHandler>:
DEFAULT_IRQ_HANDLER(DCACHE1_IRQHandler)
 81fac12:	e7fe      	b.n	81fac12 <DCACHE1_IRQHandler>

081fac14 <ADF1_IRQHandler>:
DEFAULT_IRQ_HANDLER(ADF1_IRQHandler)
 81fac14:	e7fe      	b.n	81fac14 <ADF1_IRQHandler>

081fac16 <ADC4_IRQHandler>:
DEFAULT_IRQ_HANDLER(ADC4_IRQHandler)
 81fac16:	e7fe      	b.n	81fac16 <ADC4_IRQHandler>

081fac18 <LPDMA1_Channel0_IRQHandler>:
DEFAULT_IRQ_HANDLER(LPDMA1_Channel0_IRQHandler)
 81fac18:	e7fe      	b.n	81fac18 <LPDMA1_Channel0_IRQHandler>

081fac1a <LPDMA1_Channel1_IRQHandler>:
DEFAULT_IRQ_HANDLER(LPDMA1_Channel1_IRQHandler)
 81fac1a:	e7fe      	b.n	81fac1a <LPDMA1_Channel1_IRQHandler>

081fac1c <LPDMA1_Channel2_IRQHandler>:
DEFAULT_IRQ_HANDLER(LPDMA1_Channel2_IRQHandler)
 81fac1c:	e7fe      	b.n	81fac1c <LPDMA1_Channel2_IRQHandler>

081fac1e <LPDMA1_Channel3_IRQHandler>:
DEFAULT_IRQ_HANDLER(LPDMA1_Channel3_IRQHandler)
 81fac1e:	e7fe      	b.n	81fac1e <LPDMA1_Channel3_IRQHandler>

081fac20 <DMA2D_IRQHandler>:
#if !(defined(STM32U535xx) || defined(STM32U545xx))
DEFAULT_IRQ_HANDLER(DMA2D_IRQHandler)
 81fac20:	e7fe      	b.n	81fac20 <DMA2D_IRQHandler>

081fac22 <DCMI_PSSI_IRQHandler>:
#endif /* !(defined(STM32U535xx) || defined(STM32U545xx)) */
DEFAULT_IRQ_HANDLER(DCMI_PSSI_IRQHandler)
 81fac22:	e7fe      	b.n	81fac22 <DCMI_PSSI_IRQHandler>

081fac24 <OCTOSPI2_IRQHandler>:
#if !(defined(STM32U535xx) || defined(STM32U545xx))
DEFAULT_IRQ_HANDLER(OCTOSPI2_IRQHandler)
 81fac24:	e7fe      	b.n	81fac24 <OCTOSPI2_IRQHandler>

081fac26 <MDF1_FLT4_IRQHandler>:
DEFAULT_IRQ_HANDLER(MDF1_FLT4_IRQHandler)
 81fac26:	e7fe      	b.n	81fac26 <MDF1_FLT4_IRQHandler>

081fac28 <MDF1_FLT5_IRQHandler>:
DEFAULT_IRQ_HANDLER(MDF1_FLT5_IRQHandler)
 81fac28:	e7fe      	b.n	81fac28 <MDF1_FLT5_IRQHandler>

081fac2a <CORDIC_IRQHandler>:
#endif /* !(defined(STM32U535xx) || defined(STM32U545xx)) */
DEFAULT_IRQ_HANDLER(CORDIC_IRQHandler)
 81fac2a:	e7fe      	b.n	81fac2a <CORDIC_IRQHandler>

081fac2c <FMAC_IRQHandler>:
DEFAULT_IRQ_HANDLER(FMAC_IRQHandler)
 81fac2c:	e7fe      	b.n	81fac2c <FMAC_IRQHandler>

081fac2e <LSECSSD_IRQHandler>:
DEFAULT_IRQ_HANDLER(LSECSSD_IRQHandler)
 81fac2e:	e7fe      	b.n	81fac2e <LSECSSD_IRQHandler>

081fac30 <Reset_Handler>:

/*----------------------------------------------------------------------------
  Reset Handler called on controller reset
 *----------------------------------------------------------------------------*/
void Reset_Handler(void)
{
 81fac30:	b508      	push	{r3, lr}
  __ASM volatile ("MSR msplim, %0" : : "r" (MainStackPtrLimit));
 81fac32:	4b14      	ldr	r3, [pc, #80]	@ (81fac84 <Reset_Handler+0x54>)
 81fac34:	f383 880a 	msr	MSPLIM, r3
#if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)
  __IO uint32_t tmp;

#endif
  __set_MSPLIM((uint32_t)(&__STACK_LIMIT));
  SystemInit();                             /* CMSIS System Initialization */
 81fac38:	f000 fa06 	bl	81fb048 <SystemInit>
  for (__copy_table_t const* pTable = &__copy_table_start__; pTable < &__copy_table_end__; ++pTable) {
 81fac3c:	4b12      	ldr	r3, [pc, #72]	@ (81fac88 <Reset_Handler+0x58>)
 81fac3e:	4913      	ldr	r1, [pc, #76]	@ (81fac8c <Reset_Handler+0x5c>)
 81fac40:	428b      	cmp	r3, r1
 81fac42:	d312      	bcc.n	81fac6a <Reset_Handler+0x3a>
      pTable->dest[i] = 0u;
 81fac44:	2000      	movs	r0, #0
  for (__zero_table_t const* pTable = &__zero_table_start__; pTable < &__zero_table_end__; ++pTable) {
 81fac46:	4b12      	ldr	r3, [pc, #72]	@ (81fac90 <Reset_Handler+0x60>)
 81fac48:	4912      	ldr	r1, [pc, #72]	@ (81fac94 <Reset_Handler+0x64>)
 81fac4a:	428b      	cmp	r3, r1
 81fac4c:	d318      	bcc.n	81fac80 <Reset_Handler+0x50>
  _start();
 81fac4e:	f7ff fb17 	bl	81fa280 <_mainCRTStartup>
      pTable->dest[i] = pTable->src[i];
 81fac52:	6818      	ldr	r0, [r3, #0]
 81fac54:	f850 4022 	ldr.w	r4, [r0, r2, lsl #2]
 81fac58:	6858      	ldr	r0, [r3, #4]
 81fac5a:	f840 4022 	str.w	r4, [r0, r2, lsl #2]
    for(uint32_t i=0u; i<pTable->wlen; ++i) {
 81fac5e:	3201      	adds	r2, #1
 81fac60:	6898      	ldr	r0, [r3, #8]
 81fac62:	4282      	cmp	r2, r0
 81fac64:	d3f5      	bcc.n	81fac52 <Reset_Handler+0x22>
  for (__copy_table_t const* pTable = &__copy_table_start__; pTable < &__copy_table_end__; ++pTable) {
 81fac66:	330c      	adds	r3, #12
 81fac68:	e7ea      	b.n	81fac40 <Reset_Handler+0x10>
    for(uint32_t i=0u; i<pTable->wlen; ++i) {
 81fac6a:	2200      	movs	r2, #0
 81fac6c:	e7f8      	b.n	81fac60 <Reset_Handler+0x30>
      pTable->dest[i] = 0u;
 81fac6e:	681c      	ldr	r4, [r3, #0]
 81fac70:	f844 0022 	str.w	r0, [r4, r2, lsl #2]
    for(uint32_t i=0u; i<pTable->wlen; ++i) {
 81fac74:	3201      	adds	r2, #1
 81fac76:	685c      	ldr	r4, [r3, #4]
 81fac78:	42a2      	cmp	r2, r4
 81fac7a:	d3f8      	bcc.n	81fac6e <Reset_Handler+0x3e>
  for (__zero_table_t const* pTable = &__zero_table_start__; pTable < &__zero_table_end__; ++pTable) {
 81fac7c:	3308      	adds	r3, #8
 81fac7e:	e7e4      	b.n	81fac4a <Reset_Handler+0x1a>
    for(uint32_t i=0u; i<pTable->wlen; ++i) {
 81fac80:	2200      	movs	r2, #0
 81fac82:	e7f8      	b.n	81fac76 <Reset_Handler+0x46>
 81fac84:	20000760 	.word	0x20000760
 81fac88:	081fea08 	.word	0x081fea08
 81fac8c:	081fea14 	.word	0x081fea14
 81fac90:	081fea14 	.word	0x081fea14
 81fac94:	081fea1c 	.word	0x081fea1c

081fac98 <HAL_InitTick>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
  /* load 1Hz for timeout 1 second */
  uint32_t ticks = SystemCoreClock ;
 81fac98:	4b05      	ldr	r3, [pc, #20]	@ (81facb0 <HAL_InitTick+0x18>)
  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 81fac9a:	2000      	movs	r0, #0
  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 81fac9c:	681a      	ldr	r2, [r3, #0]
 81fac9e:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 81faca2:	3a01      	subs	r2, #1
 81faca4:	615a      	str	r2, [r3, #20]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 81faca6:	2205      	movs	r2, #5
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 81faca8:	6198      	str	r0, [r3, #24]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 81facaa:	611a      	str	r2, [r3, #16]
                   SysTick_CTRL_ENABLE_Msk;
  return HAL_OK;
}
 81facac:	4770      	bx	lr
 81facae:	bf00      	nop
 81facb0:	20000028 	.word	0x20000028

081facb4 <HAL_GetTick>:
uint32_t HAL_GetTick(void)
{
  static uint32_t m_uTick = 0U;
  static uint32_t t1 = 0U, tdelta = 0U;
  uint32_t t2;
  t2 =  SysTick->VAL;
 81facb4:	f04f 21e0 	mov.w	r1, #3758153728	@ 0xe000e000
{
 81facb8:	b530      	push	{r4, r5, lr}

  if (t2 <= t1)
  {
    tdelta += t1 - t2;
 81facba:	480e      	ldr	r0, [pc, #56]	@ (81facf4 <HAL_GetTick+0x40>)
  if (t2 <= t1)
 81facbc:	4c0e      	ldr	r4, [pc, #56]	@ (81facf8 <HAL_GetTick+0x44>)
  t2 =  SysTick->VAL;
 81facbe:	698a      	ldr	r2, [r1, #24]
    tdelta += t1 - t2;
 81facc0:	6805      	ldr	r5, [r0, #0]
  if (t2 <= t1)
 81facc2:	6823      	ldr	r3, [r4, #0]
 81facc4:	4293      	cmp	r3, r2
 81facc6:	442b      	add	r3, r5
  else
  {
    tdelta += t1 + SysTick->LOAD - t2;
  }

  if (tdelta > (SystemCoreClock / (1000U)))
 81facc8:	f44f 757a 	mov.w	r5, #1000	@ 0x3e8
    tdelta += t1 + SysTick->LOAD - t2;
 81faccc:	bf3c      	itt	cc
 81facce:	6949      	ldrcc	r1, [r1, #20]
 81facd0:	185b      	addcc	r3, r3, r1
  if (tdelta > (SystemCoreClock / (1000U)))
 81facd2:	490a      	ldr	r1, [pc, #40]	@ (81facfc <HAL_GetTick+0x48>)
    tdelta += t1 + SysTick->LOAD - t2;
 81facd4:	1a9b      	subs	r3, r3, r2
  if (tdelta > (SystemCoreClock / (1000U)))
 81facd6:	6809      	ldr	r1, [r1, #0]
 81facd8:	6003      	str	r3, [r0, #0]
 81facda:	fbb1 f1f5 	udiv	r1, r1, r5
 81facde:	4299      	cmp	r1, r3
 81face0:	4b07      	ldr	r3, [pc, #28]	@ (81fad00 <HAL_GetTick+0x4c>)
 81face2:	d204      	bcs.n	81facee <HAL_GetTick+0x3a>
  {
    tdelta = 0U;
 81face4:	2500      	movs	r5, #0
    m_uTick ++;
 81face6:	6819      	ldr	r1, [r3, #0]
    tdelta = 0U;
 81face8:	6005      	str	r5, [r0, #0]
    m_uTick ++;
 81facea:	3101      	adds	r1, #1
 81facec:	6019      	str	r1, [r3, #0]
  }

  t1 = t2;
  return m_uTick;
}
 81facee:	6818      	ldr	r0, [r3, #0]
  t1 = t2;
 81facf0:	6022      	str	r2, [r4, #0]
}
 81facf2:	bd30      	pop	{r4, r5, pc}
 81facf4:	20000184 	.word	0x20000184
 81facf8:	20000188 	.word	0x20000188
 81facfc:	20000028 	.word	0x20000028
 81fad00:	20000180 	.word	0x20000180

081fad04 <Ymodem_Init>:
  * @param None.
  * @retval None.
  */
void Ymodem_Init(void)
{
  __HAL_RCC_CRC_CLK_ENABLE();
 81fad04:	4b15      	ldr	r3, [pc, #84]	@ (81fad5c <Ymodem_Init+0x58>)
{
 81fad06:	b507      	push	{r0, r1, r2, lr}
  __HAL_RCC_CRC_CLK_ENABLE();
 81fad08:	f8d3 2088 	ldr.w	r2, [r3, #136]	@ 0x88
  /*-1- Configure the CRC peripheral */
  CrcHandle.Instance = CRC;

  /* The CRC-16-CCIT polynomial is used */
  CrcHandle.Init.DefaultPolynomialUse    = DEFAULT_POLYNOMIAL_DISABLE;
  CrcHandle.Init.GeneratingPolynomial    = 0x1021U;
 81fad0c:	4814      	ldr	r0, [pc, #80]	@ (81fad60 <Ymodem_Init+0x5c>)
  __HAL_RCC_CRC_CLK_ENABLE();
 81fad0e:	f442 5280 	orr.w	r2, r2, #4096	@ 0x1000
 81fad12:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
 81fad16:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
  CrcHandle.Init.CRCLength               = CRC_POLYLENGTH_16B;
 81fad1a:	f241 0221 	movw	r2, #4129	@ 0x1021
  __HAL_RCC_CRC_CLK_ENABLE();
 81fad1e:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
 81fad22:	9301      	str	r3, [sp, #4]
 81fad24:	9b01      	ldr	r3, [sp, #4]
  CrcHandle.Init.CRCLength               = CRC_POLYLENGTH_16B;
 81fad26:	2308      	movs	r3, #8
 81fad28:	e9c0 2302 	strd	r2, r3, [r0, #8]
  CrcHandle.Instance = CRC;
 81fad2c:	4b0d      	ldr	r3, [pc, #52]	@ (81fad64 <Ymodem_Init+0x60>)
 81fad2e:	6003      	str	r3, [r0, #0]
  CrcHandle.Init.DefaultPolynomialUse    = DEFAULT_POLYNOMIAL_DISABLE;
 81fad30:	f240 1301 	movw	r3, #257	@ 0x101
 81fad34:	8083      	strh	r3, [r0, #4]

  /* The zero init value is used */
  CrcHandle.Init.DefaultInitValueUse     = DEFAULT_INIT_VALUE_DISABLE;
  CrcHandle.Init.InitValue               = 0U;
 81fad36:	2300      	movs	r3, #0

  /* The input data are not inverted */
  CrcHandle.Init.InputDataInversionMode  = CRC_INPUTDATA_INVERSION_NONE;
 81fad38:	e9c0 3304 	strd	r3, r3, [r0, #16]

  /* The output data are not inverted */
  CrcHandle.Init.OutputDataInversionMode = CRC_OUTPUTDATA_INVERSION_DISABLE;
 81fad3c:	6183      	str	r3, [r0, #24]

  /* The input data are 32-bit long words */
  CrcHandle.InputDataFormat              = CRC_INPUTDATA_FORMAT_BYTES;
 81fad3e:	2301      	movs	r3, #1
 81fad40:	6203      	str	r3, [r0, #32]

  if (HAL_CRC_Init(&CrcHandle) != HAL_OK)
 81fad42:	f000 fa39 	bl	81fb1b8 <HAL_CRC_Init>
 81fad46:	b100      	cbz	r0, 81fad4a <Ymodem_Init+0x46>
  {
    /* Initialization Error */
    while (1);
 81fad48:	e7fe      	b.n	81fad48 <Ymodem_Init+0x44>
  }
  if (COM_Y_On(CA) != HAL_OK)
 81fad4a:	2018      	movs	r0, #24
 81fad4c:	f7ff fbb8 	bl	81fa4c0 <COM_Y_On>
 81fad50:	b100      	cbz	r0, 81fad54 <Ymodem_Init+0x50>
  {
    while(1);
 81fad52:	e7fe      	b.n	81fad52 <Ymodem_Init+0x4e>
  }
}
 81fad54:	b003      	add	sp, #12
 81fad56:	f85d fb04 	ldr.w	pc, [sp], #4
 81fad5a:	bf00      	nop
 81fad5c:	46020c00 	.word	0x46020c00
 81fad60:	2000018c 	.word	0x2000018c
 81fad64:	40023000 	.word	0x40023000

081fad68 <Ymodem_Receive>:
  * @param  puSize The uSize of the file.
  * @param  uFlashDestination where the file has to be downloaded.
  * @retval COM_StatusTypeDef result of reception/programming
  */
COM_StatusTypeDef Ymodem_Receive(uint32_t *puSize, uint32_t uFlashDestination)
{
 81fad68:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint32_t ramsource, filesize;
  uint8_t *file_ptr;
  uint8_t file_size[FILE_SIZE_LENGTH + 1U], tmp;
  uint32_t packets_received;
  COM_StatusTypeDef e_result = COM_OK;
  uint32_t cause = 0;
 81fad6c:	2700      	movs	r7, #0
{
 81fad6e:	4683      	mov	fp, r0
 81fad70:	b08d      	sub	sp, #52	@ 0x34
  uint32_t i, packet_length, session_done = 0U, file_done, errors = 0U, session_begin = 0U;
 81fad72:	e9cd 7701 	strd	r7, r7, [sp, #4]
{
 81fad76:	9100      	str	r1, [sp, #0]
  while ((session_done == 0U) && (e_result == COM_OK))
  {
    packets_received = 0U;
 81fad78:	f04f 0a00 	mov.w	sl, #0
 81fad7c:	e113      	b.n	81fafa6 <Ymodem_Receive+0x23e>
 81fad7e:	46c1      	mov	r9, r8
                    else
                    {
                      /* End session */
                      COM_Transmit_Y(&tmp, 1U, NAK_TIMEOUT);
                      COM_Transmit_Y(&tmp, 1U, NAK_TIMEOUT);
                      cause = 2;
 81fad80:	2702      	movs	r7, #2
  status = (HAL_StatusTypeDef)COM_Receive_Y(&char1, 1, uTimeout);
 81fad82:	f44f 62fa 	mov.w	r2, #2000	@ 0x7d0
 81fad86:	2101      	movs	r1, #1
 81fad88:	f10d 0015 	add.w	r0, sp, #21
 81fad8c:	f7ff fb7a 	bl	81fa484 <COM_Receive_Y>
  if (status == HAL_OK)
 81fad90:	4605      	mov	r5, r0
 81fad92:	2800      	cmp	r0, #0
 81fad94:	f040 8146 	bne.w	81fb024 <Ymodem_Receive+0x2bc>
    switch (char1)
 81fad98:	f89d 3015 	ldrb.w	r3, [sp, #21]
 81fad9c:	2b18      	cmp	r3, #24
 81fad9e:	f000 808a 	beq.w	81faeb6 <Ymodem_Receive+0x14e>
 81fada2:	d87e      	bhi.n	81faea2 <Ymodem_Receive+0x13a>
 81fada4:	2b02      	cmp	r3, #2
 81fada6:	f000 80b0 	beq.w	81faf0a <Ymodem_Receive+0x1a2>
 81fadaa:	2b04      	cmp	r3, #4
 81fadac:	f000 8081 	beq.w	81faeb2 <Ymodem_Receive+0x14a>
 81fadb0:	2b01      	cmp	r3, #1
 81fadb2:	bf0b      	itete	eq
 81fadb4:	2000      	moveq	r0, #0
 81fadb6:	2001      	movne	r0, #1
 81fadb8:	2480      	moveq	r4, #128	@ 0x80
 81fadba:	2400      	movne	r4, #0
    *pData = char1;
 81fadbc:	f89d 3015 	ldrb.w	r3, [sp, #21]
 81fadc0:	4a9a      	ldr	r2, [pc, #616]	@ (81fb02c <Ymodem_Receive+0x2c4>)
    if (packet_size >= PACKET_SIZE)
 81fadc2:	2c7f      	cmp	r4, #127	@ 0x7f
    *pData = char1;
 81fadc4:	7013      	strb	r3, [r2, #0]
    if (packet_size >= PACKET_SIZE)
 81fadc6:	f240 80a7 	bls.w	81faf18 <Ymodem_Receive+0x1b0>
      status = COM_Receive_Y(&pData[PACKET_NUMBER_INDEX], packet_size + PACKET_OVERHEAD_SIZE, uTimeout);
 81fadca:	f44f 62fa 	mov.w	r2, #2000	@ 0x7d0
 81fadce:	4898      	ldr	r0, [pc, #608]	@ (81fb030 <Ymodem_Receive+0x2c8>)
 81fadd0:	1d21      	adds	r1, r4, #4
 81fadd2:	f7ff fb57 	bl	81fa484 <COM_Receive_Y>
      if (status == HAL_OK)
 81fadd6:	4680      	mov	r8, r0
 81fadd8:	2800      	cmp	r0, #0
 81fadda:	f040 8124 	bne.w	81fb026 <Ymodem_Receive+0x2be>
        if (pData[PACKET_NUMBER_INDEX] != ((pData[PACKET_CNUMBER_INDEX]) ^ NEGATIVE_BYTE))
 81fadde:	4a93      	ldr	r2, [pc, #588]	@ (81fb02c <Ymodem_Receive+0x2c4>)
 81fade0:	78d3      	ldrb	r3, [r2, #3]
 81fade2:	7892      	ldrb	r2, [r2, #2]
 81fade4:	43db      	mvns	r3, r3
 81fade6:	b2db      	uxtb	r3, r3
 81fade8:	429a      	cmp	r2, r3
 81fadea:	f040 8098 	bne.w	81faf1e <Ymodem_Receive+0x1b6>
          crc = pData[ packet_size + PACKET_DATA_INDEX ] << 8U;
 81fadee:	4e91      	ldr	r6, [pc, #580]	@ (81fb034 <Ymodem_Receive+0x2cc>)
          if (HAL_CRC_Calculate(&CrcHandle, (uint32_t *)&pData[PACKET_DATA_INDEX], packet_size) != crc)
 81fadf0:	4891      	ldr	r0, [pc, #580]	@ (81fb038 <Ymodem_Receive+0x2d0>)
          crc += pData[ packet_size + PACKET_DATA_INDEX + 1U ];
 81fadf2:	1c73      	adds	r3, r6, #1
          crc = pData[ packet_size + PACKET_DATA_INDEX ] << 8U;
 81fadf4:	5d32      	ldrb	r2, [r6, r4]
          crc += pData[ packet_size + PACKET_DATA_INDEX + 1U ];
 81fadf6:	5d1b      	ldrb	r3, [r3, r4]
          if (HAL_CRC_Calculate(&CrcHandle, (uint32_t *)&pData[PACKET_DATA_INDEX], packet_size) != crc)
 81fadf8:	4631      	mov	r1, r6
          crc += pData[ packet_size + PACKET_DATA_INDEX + 1U ];
 81fadfa:	eb03 2302 	add.w	r3, r3, r2, lsl #8
          if (HAL_CRC_Calculate(&CrcHandle, (uint32_t *)&pData[PACKET_DATA_INDEX], packet_size) != crc)
 81fadfe:	4622      	mov	r2, r4
          crc += pData[ packet_size + PACKET_DATA_INDEX + 1U ];
 81fae00:	9303      	str	r3, [sp, #12]
          if (HAL_CRC_Calculate(&CrcHandle, (uint32_t *)&pData[PACKET_DATA_INDEX], packet_size) != crc)
 81fae02:	f000 fa13 	bl	81fb22c <HAL_CRC_Calculate>
 81fae06:	9b03      	ldr	r3, [sp, #12]
 81fae08:	4283      	cmp	r3, r0
 81fae0a:	f040 8088 	bne.w	81faf1e <Ymodem_Receive+0x1b6>
              if (m_aPacketData[PACKET_NUMBER_INDEX] != (packets_received & 0xff))
 81fae0e:	f816 2c02 	ldrb.w	r2, [r6, #-2]
 81fae12:	fa5f f38a 	uxtb.w	r3, sl
 81fae16:	429a      	cmp	r2, r3
 81fae18:	f040 80c5 	bne.w	81fafa6 <Ymodem_Receive+0x23e>
                if (packets_received == 0U)
 81fae1c:	f1ba 0f00 	cmp.w	sl, #0
 81fae20:	f040 80d3 	bne.w	81fafca <Ymodem_Receive+0x262>
                  if (m_aPacketData[PACKET_DATA_INDEX] != 0U)
 81fae24:	4b81      	ldr	r3, [pc, #516]	@ (81fb02c <Ymodem_Receive+0x2c4>)
 81fae26:	791b      	ldrb	r3, [r3, #4]
 81fae28:	2b00      	cmp	r3, #0
 81fae2a:	f000 80bf 	beq.w	81fafac <Ymodem_Receive+0x244>
 81fae2e:	4b83      	ldr	r3, [pc, #524]	@ (81fb03c <Ymodem_Receive+0x2d4>)
                    i = 0U;
 81fae30:	4652      	mov	r2, sl
 81fae32:	4618      	mov	r0, r3
                    while ((*file_ptr != 0U) && (i < FILE_NAME_LENGTH))
 81fae34:	f816 1b01 	ldrb.w	r1, [r6], #1
 81fae38:	b111      	cbz	r1, 81fae40 <Ymodem_Receive+0xd8>
 81fae3a:	2a40      	cmp	r2, #64	@ 0x40
 81fae3c:	f040 8096 	bne.w	81faf6c <Ymodem_Receive+0x204>
                    m_aFileName[i++] = '\0';
 81fae40:	2300      	movs	r3, #0
 81fae42:	5483      	strb	r3, [r0, r2]
                    while ((*file_ptr != ' ') && (i < FILE_SIZE_LENGTH))
 81fae44:	aa07      	add	r2, sp, #28
 81fae46:	4610      	mov	r0, r2
 81fae48:	5cf1      	ldrb	r1, [r6, r3]
 81fae4a:	2920      	cmp	r1, #32
 81fae4c:	d002      	beq.n	81fae54 <Ymodem_Receive+0xec>
 81fae4e:	2b10      	cmp	r3, #16
 81fae50:	f040 8090 	bne.w	81faf74 <Ymodem_Receive+0x20c>
                    file_size[i++] = '\0';
 81fae54:	2400      	movs	r4, #0
 81fae56:	3330      	adds	r3, #48	@ 0x30
 81fae58:	446b      	add	r3, sp
                    Str2Int(file_size, &filesize);
 81fae5a:	a906      	add	r1, sp, #24
                    file_size[i++] = '\0';
 81fae5c:	f803 4c14 	strb.w	r4, [r3, #-20]
                    Str2Int(file_size, &filesize);
 81fae60:	f7ff fb46 	bl	81fa4f0 <Str2Int>
                    if ((uint32_t)filesize > *puSize)
 81fae64:	f8db 3000 	ldr.w	r3, [fp]
 81fae68:	9906      	ldr	r1, [sp, #24]
 81fae6a:	428b      	cmp	r3, r1
 81fae6c:	f080 8086 	bcs.w	81faf7c <Ymodem_Receive+0x214>
                      tmp = CA;
 81fae70:	2318      	movs	r3, #24
                      e_result = COM_ABORT;
 81fae72:	f04f 0802 	mov.w	r8, #2
                      *puSize = 0;
 81fae76:	f8cb 4000 	str.w	r4, [fp]
                      tmp = CA;
 81fae7a:	f88d 3014 	strb.w	r3, [sp, #20]
                      COM_Transmit_Y(&tmp, 1U, NAK_TIMEOUT);
 81fae7e:	f44f 1280 	mov.w	r2, #1048576	@ 0x100000
 81fae82:	2101      	movs	r1, #1
 81fae84:	a805      	add	r0, sp, #20
 81fae86:	f7ff fadd 	bl	81fa444 <COM_Transmit_Y>
                      COM_Transmit_Y(&tmp, 1U, NAK_TIMEOUT);
 81fae8a:	f44f 1280 	mov.w	r2, #1048576	@ 0x100000
 81fae8e:	2101      	movs	r1, #1
 81fae90:	a805      	add	r0, sp, #20
 81fae92:	f7ff fad7 	bl	81fa444 <COM_Transmit_Y>
    while ((file_done == 0U) && (e_result == COM_OK))
 81fae96:	f1b8 0f00 	cmp.w	r8, #0
 81fae9a:	f43f af70 	beq.w	81fad7e <Ymodem_Receive+0x16>
                      cause = 2;
 81fae9e:	2702      	movs	r7, #2
 81faea0:	e05b      	b.n	81faf5a <Ymodem_Receive+0x1f2>
    switch (char1)
 81faea2:	2b61      	cmp	r3, #97	@ 0x61
 81faea4:	d034      	beq.n	81faf10 <Ymodem_Receive+0x1a8>
 81faea6:	2b72      	cmp	r3, #114	@ 0x72
 81faea8:	d013      	beq.n	81faed2 <Ymodem_Receive+0x16a>
 81faeaa:	2b41      	cmp	r3, #65	@ 0x41
 81faeac:	bf0c      	ite	eq
 81faeae:	2002      	moveq	r0, #2
 81faeb0:	2001      	movne	r0, #1
  uint32_t packet_size = 0U;
 81faeb2:	2400      	movs	r4, #0
 81faeb4:	e782      	b.n	81fadbc <Ymodem_Receive+0x54>
        if ((COM_Receive_Y(&char1, 1U, uTimeout) == HAL_OK) && (char1 == CA))
 81faeb6:	f44f 62fa 	mov.w	r2, #2000	@ 0x7d0
 81faeba:	2101      	movs	r1, #1
 81faebc:	f10d 0015 	add.w	r0, sp, #21
 81faec0:	f7ff fae0 	bl	81fa484 <COM_Receive_Y>
 81faec4:	b918      	cbnz	r0, 81faece <Ymodem_Receive+0x166>
 81faec6:	f89d 3015 	ldrb.w	r3, [sp, #21]
 81faeca:	2b18      	cmp	r3, #24
 81faecc:	d022      	beq.n	81faf14 <Ymodem_Receive+0x1ac>
          status = HAL_ERROR;
 81faece:	2001      	movs	r0, #1
 81faed0:	e7ef      	b.n	81faeb2 <Ymodem_Receive+0x14a>
        if ((COM_Receive_Y(&char2, 1U, uTimeout) == HAL_OK) &&                /* Ymodem startup sequence : rb ==> 0x72 + 0x62 + 0x0D */
 81faed2:	f44f 62fa 	mov.w	r2, #2000	@ 0x7d0
 81faed6:	2101      	movs	r1, #1
 81faed8:	f10d 0016 	add.w	r0, sp, #22
 81faedc:	f7ff fad2 	bl	81fa484 <COM_Receive_Y>
 81faee0:	2800      	cmp	r0, #0
 81faee2:	d1f4      	bne.n	81faece <Ymodem_Receive+0x166>
            (COM_Receive_Y(&char3, 1U, uTimeout) == HAL_OK) &&
 81faee4:	f44f 62fa 	mov.w	r2, #2000	@ 0x7d0
 81faee8:	2101      	movs	r1, #1
 81faeea:	f10d 0017 	add.w	r0, sp, #23
 81faeee:	f7ff fac9 	bl	81fa484 <COM_Receive_Y>
        if ((COM_Receive_Y(&char2, 1U, uTimeout) == HAL_OK) &&                /* Ymodem startup sequence : rb ==> 0x72 + 0x62 + 0x0D */
 81faef2:	2800      	cmp	r0, #0
 81faef4:	d1eb      	bne.n	81faece <Ymodem_Receive+0x166>
            (COM_Receive_Y(&char3, 1U, uTimeout) == HAL_OK) &&
 81faef6:	f89d 3016 	ldrb.w	r3, [sp, #22]
 81faefa:	2b62      	cmp	r3, #98	@ 0x62
 81faefc:	d1e7      	bne.n	81faece <Ymodem_Receive+0x166>
            (char2 == 0x62) &&
 81faefe:	f89d 3017 	ldrb.w	r3, [sp, #23]
 81faf02:	2b0d      	cmp	r3, #13
 81faf04:	d1e3      	bne.n	81faece <Ymodem_Receive+0x166>
                packet_size = 3U;
 81faf06:	2403      	movs	r4, #3
 81faf08:	e758      	b.n	81fadbc <Ymodem_Receive+0x54>
        packet_size = PACKET_1K_SIZE;
 81faf0a:	f44f 6480 	mov.w	r4, #1024	@ 0x400
 81faf0e:	e755      	b.n	81fadbc <Ymodem_Receive+0x54>
        status = HAL_BUSY;
 81faf10:	2002      	movs	r0, #2
 81faf12:	e7ce      	b.n	81faeb2 <Ymodem_Receive+0x14a>
          packet_size = 2U;
 81faf14:	2402      	movs	r4, #2
 81faf16:	e751      	b.n	81fadbc <Ymodem_Receive+0x54>
      switch (ReceivePacket(m_aPacketData, &packet_length, DOWNLOAD_TIMEOUT))
 81faf18:	b178      	cbz	r0, 81faf3a <Ymodem_Receive+0x1d2>
 81faf1a:	2802      	cmp	r0, #2
 81faf1c:	d071      	beq.n	81fb002 <Ymodem_Receive+0x29a>
          Serial_PutByte(CA);
          e_result = COM_ABORT;
          cause  = 5;
          break;
        default:
          if (session_begin > 0U)
 81faf1e:	9b02      	ldr	r3, [sp, #8]
 81faf20:	b10b      	cbz	r3, 81faf26 <Ymodem_Receive+0x1be>
          {
            errors ++;
 81faf22:	f109 0901 	add.w	r9, r9, #1
          }
          if (errors > MAX_ERRORS)
 81faf26:	f1b9 0f05 	cmp.w	r9, #5
 81faf2a:	d972      	bls.n	81fb012 <Ymodem_Receive+0x2aa>
          {
            /* Abort communication */
            Serial_PutByte(CA);
 81faf2c:	2018      	movs	r0, #24
 81faf2e:	f7ff fb31 	bl	81fa594 <Serial_PutByte>
            Serial_PutByte(CA);
 81faf32:	2018      	movs	r0, #24
 81faf34:	f7ff fb2e 	bl	81fa594 <Serial_PutByte>
 81faf38:	e723      	b.n	81fad82 <Ymodem_Receive+0x1a>
          switch (packet_length)
 81faf3a:	2c03      	cmp	r4, #3
 81faf3c:	d033      	beq.n	81fafa6 <Ymodem_Receive+0x23e>
 81faf3e:	b94c      	cbnz	r4, 81faf54 <Ymodem_Receive+0x1ec>
              if (!eot)
 81faf40:	9b01      	ldr	r3, [sp, #4]
 81faf42:	b963      	cbnz	r3, 81faf5e <Ymodem_Receive+0x1f6>
                    Serial_PutByte(NAK);
 81faf44:	2015      	movs	r0, #21
 81faf46:	f7ff fb25 	bl	81fa594 <Serial_PutByte>
                    eot = 1;
 81faf4a:	2301      	movs	r3, #1
          errors = 0U;
 81faf4c:	f8dd 9004 	ldr.w	r9, [sp, #4]
                    eot = 1;
 81faf50:	9301      	str	r3, [sp, #4]
 81faf52:	e716      	b.n	81fad82 <Ymodem_Receive+0x1a>
              Serial_PutByte(ACK);
 81faf54:	2006      	movs	r0, #6
 81faf56:	f7ff fb1d 	bl	81fa594 <Serial_PutByte>
  uint32_t i, packet_length, session_done = 0U, file_done, errors = 0U, session_begin = 0U;
 81faf5a:	2502      	movs	r5, #2
 81faf5c:	e02a      	b.n	81fafb4 <Ymodem_Receive+0x24c>
                    Serial_PutByte(ACK);
 81faf5e:	2006      	movs	r0, #6
 81faf60:	f7ff fb18 	bl	81fa594 <Serial_PutByte>
                    *puSize = filesize;
 81faf64:	9b06      	ldr	r3, [sp, #24]
 81faf66:	f8cb 3000 	str.w	r3, [fp]
                    file_done = 1U;
 81faf6a:	e705      	b.n	81fad78 <Ymodem_Receive+0x10>
                      m_aFileName[i++] = *file_ptr++;
 81faf6c:	3201      	adds	r2, #1
 81faf6e:	f803 1b01 	strb.w	r1, [r3], #1
 81faf72:	e75f      	b.n	81fae34 <Ymodem_Receive+0xcc>
                      file_size[i++] = *file_ptr++;
 81faf74:	3301      	adds	r3, #1
 81faf76:	f802 1b01 	strb.w	r1, [r2], #1
 81faf7a:	e765      	b.n	81fae48 <Ymodem_Receive+0xe0>
                    if ((*puSize) && (Ymodem_HeaderPktRxCpltCallback(uFlashDestination, (uint32_t) filesize) == HAL_OK))
 81faf7c:	2b00      	cmp	r3, #0
 81faf7e:	f43f af7e 	beq.w	81fae7e <Ymodem_Receive+0x116>
 81faf82:	9800      	ldr	r0, [sp, #0]
 81faf84:	f7ff fc70 	bl	81fa868 <Ymodem_HeaderPktRxCpltCallback>
 81faf88:	2800      	cmp	r0, #0
 81faf8a:	f47f af78 	bne.w	81fae7e <Ymodem_Receive+0x116>
                      Serial_PutByte(ACK);
 81faf8e:	2006      	movs	r0, #6
 81faf90:	f7ff fb00 	bl	81fa594 <Serial_PutByte>
                      COM_Flush();
 81faf94:	f7ff fa86 	bl	81fa4a4 <COM_Flush>
                      Serial_PutByte(CRC16);
 81faf98:	2043      	movs	r0, #67	@ 0x43
                    Serial_PutByte(ACK);
 81faf9a:	f7ff fafb 	bl	81fa594 <Serial_PutByte>
                session_begin = 1U;
 81faf9e:	2301      	movs	r3, #1
                packets_received ++;
 81fafa0:	f10a 0a01 	add.w	sl, sl, #1
                session_begin = 1U;
 81fafa4:	9302      	str	r3, [sp, #8]
                packets_received ++;
 81fafa6:	f04f 0900 	mov.w	r9, #0
 81fafaa:	e6ea      	b.n	81fad82 <Ymodem_Receive+0x1a>
                    Serial_PutByte(ACK);
 81fafac:	2006      	movs	r0, #6
 81fafae:	f7ff faf1 	bl	81fa594 <Serial_PutByte>
                    cause = 3;
 81fafb2:	2703      	movs	r7, #3
          }
          break;
      }
    }
  }
  COM_Y_Off();
 81fafb4:	f7ff fa92 	bl	81fa4dc <COM_Y_Off>
#if defined(__ARMCC_VERSION)
  printf("e_result = %x , %u\n", e_result, cause);
#else
  printf("e_result = %x , %lu\n", e_result, cause);
 81fafb8:	463a      	mov	r2, r7
 81fafba:	4629      	mov	r1, r5
 81fafbc:	4820      	ldr	r0, [pc, #128]	@ (81fb040 <Ymodem_Receive+0x2d8>)
 81fafbe:	f002 f85f 	bl	81fd080 <iprintf>
#endif /* __ARMCC_VERSION */
  return e_result;
}
 81fafc2:	4628      	mov	r0, r5
 81fafc4:	b00d      	add	sp, #52	@ 0x34
 81fafc6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                  if ((*puSize) && (Ymodem_DataPktRxCpltCallback((uint8_t *)
 81fafca:	f8db 3000 	ldr.w	r3, [fp]
 81fafce:	b153      	cbz	r3, 81fafe6 <Ymodem_Receive+0x27e>
 81fafd0:	4622      	mov	r2, r4
 81fafd2:	4630      	mov	r0, r6
 81fafd4:	9900      	ldr	r1, [sp, #0]
 81fafd6:	f7ff fc5f 	bl	81fa898 <Ymodem_DataPktRxCpltCallback>
 81fafda:	b920      	cbnz	r0, 81fafe6 <Ymodem_Receive+0x27e>
                    uFlashDestination += (packet_length);
 81fafdc:	9b00      	ldr	r3, [sp, #0]
                    Serial_PutByte(ACK);
 81fafde:	2006      	movs	r0, #6
                    uFlashDestination += (packet_length);
 81fafe0:	4423      	add	r3, r4
 81fafe2:	9300      	str	r3, [sp, #0]
                    Serial_PutByte(ACK);
 81fafe4:	e7d9      	b.n	81faf9a <Ymodem_Receive+0x232>
                    COM_Transmit_Y(&tmp, 1U, NAK_TIMEOUT);
 81fafe6:	f44f 1280 	mov.w	r2, #1048576	@ 0x100000
 81fafea:	2101      	movs	r1, #1
 81fafec:	a805      	add	r0, sp, #20
 81fafee:	f7ff fa29 	bl	81fa444 <COM_Transmit_Y>
                    COM_Transmit_Y(&tmp, 1U, NAK_TIMEOUT);
 81faff2:	f44f 1280 	mov.w	r2, #1048576	@ 0x100000
 81faff6:	2101      	movs	r1, #1
 81faff8:	a805      	add	r0, sp, #20
 81faffa:	f7ff fa23 	bl	81fa444 <COM_Transmit_Y>
                    cause = 4;
 81faffe:	2704      	movs	r7, #4
 81fb000:	e7cd      	b.n	81faf9e <Ymodem_Receive+0x236>
          Serial_PutByte(CA);
 81fb002:	2018      	movs	r0, #24
 81fb004:	f7ff fac6 	bl	81fa594 <Serial_PutByte>
          Serial_PutByte(CA);
 81fb008:	2018      	movs	r0, #24
 81fb00a:	f7ff fac3 	bl	81fa594 <Serial_PutByte>
          cause  = 5;
 81fb00e:	2705      	movs	r7, #5
          break;
 81fb010:	e7a3      	b.n	81faf5a <Ymodem_Receive+0x1f2>
            Serial_PutByte(CRC16); /* Ask for a packet */
 81fb012:	2043      	movs	r0, #67	@ 0x43
 81fb014:	f7ff fabe 	bl	81fa594 <Serial_PutByte>
            COM_Transmit_Y((uint8_t *)BACK_SLASH_POINT, sizeof(BACK_SLASH_POINT)-1, TX_TIMEOUT);
 81fb018:	2264      	movs	r2, #100	@ 0x64
 81fb01a:	2102      	movs	r1, #2
 81fb01c:	4809      	ldr	r0, [pc, #36]	@ (81fb044 <Ymodem_Receive+0x2dc>)
 81fb01e:	f7ff fa11 	bl	81fa444 <COM_Transmit_Y>
 81fb022:	e6ae      	b.n	81fad82 <Ymodem_Receive+0x1a>
 81fb024:	4680      	mov	r8, r0
      switch (ReceivePacket(m_aPacketData, &packet_length, DOWNLOAD_TIMEOUT))
 81fb026:	f1b8 0f02 	cmp.w	r8, #2
 81fb02a:	e777      	b.n	81faf1c <Ymodem_Receive+0x1b4>
 81fb02c:	200001f1 	.word	0x200001f1
 81fb030:	200001f3 	.word	0x200001f3
 81fb034:	200001f5 	.word	0x200001f5
 81fb038:	2000018c 	.word	0x2000018c
 81fb03c:	200001b0 	.word	0x200001b0
 81fb040:	081fe8c0 	.word	0x081fe8c0
 81fb044:	081fe8d5 	.word	0x081fe8d5

081fb048 <SystemInit>:
   SCB->CPACR |= ((3UL << 20U)|(3UL << 22U));  /* set CP10 and CP11 Full Access */
  #endif

  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set MSION bit */
  RCC->CR = RCC_CR_MSISON;
 81fb048:	2201      	movs	r2, #1
   SCB->CPACR |= ((3UL << 20U)|(3UL << 22U));  /* set CP10 and CP11 Full Access */
 81fb04a:	480e      	ldr	r0, [pc, #56]	@ (81fb084 <SystemInit+0x3c>)
 81fb04c:	f8d0 3088 	ldr.w	r3, [r0, #136]	@ 0x88
 81fb050:	f443 0370 	orr.w	r3, r3, #15728640	@ 0xf00000
 81fb054:	f8c0 3088 	str.w	r3, [r0, #136]	@ 0x88
  RCC->CR = RCC_CR_MSISON;
 81fb058:	4b0b      	ldr	r3, [pc, #44]	@ (81fb088 <SystemInit+0x40>)
 81fb05a:	601a      	str	r2, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR1 = 0U;
 81fb05c:	2200      	movs	r2, #0
 81fb05e:	61da      	str	r2, [r3, #28]
  RCC->CFGR2 = 0U;
 81fb060:	621a      	str	r2, [r3, #32]
  RCC->CFGR3 = 0U;
 81fb062:	625a      	str	r2, [r3, #36]	@ 0x24

  /* Reset HSEON, CSSON , HSION, PLLxON bits */
  RCC->CR &= ~(RCC_CR_HSEON | RCC_CR_CSSON | RCC_CR_PLL1ON | RCC_CR_PLL2ON | RCC_CR_PLL3ON);
 81fb064:	6819      	ldr	r1, [r3, #0]
 81fb066:	f021 51a8 	bic.w	r1, r1, #352321536	@ 0x15000000
 81fb06a:	f421 2110 	bic.w	r1, r1, #589824	@ 0x90000
 81fb06e:	6019      	str	r1, [r3, #0]

  /* Reset PLLCFGR register */
  RCC->PLL1CFGR = 0U;
 81fb070:	629a      	str	r2, [r3, #40]	@ 0x28

  /* Reset HSEBYP bit */
  RCC->CR &= ~(RCC_CR_HSEBYP);
 81fb072:	6819      	ldr	r1, [r3, #0]
 81fb074:	f421 2180 	bic.w	r1, r1, #262144	@ 0x40000
 81fb078:	6019      	str	r1, [r3, #0]

  /* Disable all interrupts */
  RCC->CIER = 0U;
 81fb07a:	651a      	str	r2, [r3, #80]	@ 0x50

  /* Configure the Vector Table location add offset address ------------------*/
  #ifdef VECT_TAB_SRAM
    SCB->VTOR = SRAM1_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
  #else
    SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 81fb07c:	f04f 6300 	mov.w	r3, #134217728	@ 0x8000000
 81fb080:	6083      	str	r3, [r0, #8]
  #endif
}
 81fb082:	4770      	bx	lr
 81fb084:	e000ed00 	.word	0xe000ed00
 81fb088:	46020c00 	.word	0x46020c00

081fb08c <HAL_MspInit>:
__weak void HAL_MspInit(void)
{
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_MspInit could be implemented in the user file
   */
}
 81fb08c:	4770      	bx	lr
	...

081fb090 <HAL_Init>:
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 81fb090:	4a0f      	ldr	r2, [pc, #60]	@ (81fb0d0 <HAL_Init+0x40>)
{
 81fb092:	b510      	push	{r4, lr}
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 81fb094:	6813      	ldr	r3, [r2, #0]
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 81fb096:	2003      	movs	r0, #3
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 81fb098:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 81fb09c:	6013      	str	r3, [r2, #0]
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 81fb09e:	f000 f831 	bl	81fb104 <HAL_NVIC_SetPriorityGrouping>
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR2 & RCC_CFGR2_HPRE) >> RCC_CFGR2_HPRE_Pos];
 81fb0a2:	f000 fb3b 	bl	81fb71c <HAL_RCC_GetSysClockFreq>
 81fb0a6:	4b0b      	ldr	r3, [pc, #44]	@ (81fb0d4 <HAL_Init+0x44>)
 81fb0a8:	4a0b      	ldr	r2, [pc, #44]	@ (81fb0d8 <HAL_Init+0x48>)
 81fb0aa:	6a1b      	ldr	r3, [r3, #32]
 81fb0ac:	f003 030f 	and.w	r3, r3, #15
 81fb0b0:	5cd3      	ldrb	r3, [r2, r3]
 81fb0b2:	40d8      	lsrs	r0, r3
 81fb0b4:	4b09      	ldr	r3, [pc, #36]	@ (81fb0dc <HAL_Init+0x4c>)
 81fb0b6:	6018      	str	r0, [r3, #0]
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
 81fb0b8:	200f      	movs	r0, #15
 81fb0ba:	f7ff fded 	bl	81fac98 <HAL_InitTick>
 81fb0be:	4604      	mov	r4, r0
 81fb0c0:	b918      	cbnz	r0, 81fb0ca <HAL_Init+0x3a>
  HAL_MspInit();
 81fb0c2:	f7ff ffe3 	bl	81fb08c <HAL_MspInit>
}
 81fb0c6:	4620      	mov	r0, r4
 81fb0c8:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
 81fb0ca:	2401      	movs	r4, #1
 81fb0cc:	e7fb      	b.n	81fb0c6 <HAL_Init+0x36>
 81fb0ce:	bf00      	nop
 81fb0d0:	40022000 	.word	0x40022000
 81fb0d4:	46020c00 	.word	0x46020c00
 81fb0d8:	081fe920 	.word	0x081fe920
 81fb0dc:	20000028 	.word	0x20000028

081fb0e0 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay  specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 81fb0e0:	b538      	push	{r3, r4, r5, lr}
 81fb0e2:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
 81fb0e4:	f7ff fde6 	bl	81facb4 <HAL_GetTick>
 81fb0e8:	4605      	mov	r5, r0
  uint32_t wait = Delay;

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
 81fb0ea:	1c63      	adds	r3, r4, #1
  {
    wait += (uint32_t)(uwTickFreq);
 81fb0ec:	bf1e      	ittt	ne
 81fb0ee:	4b04      	ldrne	r3, [pc, #16]	@ (81fb100 <HAL_Delay+0x20>)
 81fb0f0:	781b      	ldrbne	r3, [r3, #0]
 81fb0f2:	18e4      	addne	r4, r4, r3
  }

  while ((HAL_GetTick() - tickstart) < wait)
 81fb0f4:	f7ff fdde 	bl	81facb4 <HAL_GetTick>
 81fb0f8:	1b43      	subs	r3, r0, r5
 81fb0fa:	42a3      	cmp	r3, r4
 81fb0fc:	d3fa      	bcc.n	81fb0f4 <HAL_Delay+0x14>
  {
  }
}
 81fb0fe:	bd38      	pop	{r3, r4, r5, pc}
 81fb100:	2000002c 	.word	0x2000002c

081fb104 <HAL_NVIC_SetPriorityGrouping>:
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 81fb104:	4907      	ldr	r1, [pc, #28]	@ (81fb124 <HAL_NVIC_SetPriorityGrouping+0x20>)
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 81fb106:	0203      	lsls	r3, r0, #8
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 81fb108:	68ca      	ldr	r2, [r1, #12]
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 81fb10a:	f403 63e0 	and.w	r3, r3, #1792	@ 0x700
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 81fb10e:	f422 62e0 	bic.w	r2, r2, #1792	@ 0x700
 81fb112:	0412      	lsls	r2, r2, #16
 81fb114:	0c12      	lsrs	r2, r2, #16
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 81fb116:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
 81fb118:	f043 63bf 	orr.w	r3, r3, #100139008	@ 0x5f80000
 81fb11c:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
  SCB->AIRCR =  reg_value;
 81fb120:	60cb      	str	r3, [r1, #12]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
}
 81fb122:	4770      	bx	lr
 81fb124:	e000ed00 	.word	0xe000ed00

081fb128 <CRC_Handle_8>:
  * @param  pBuffer pointer to the input data buffer
  * @param  BufferLength input data buffer length
  * @retval uint32_t CRC (returned value LSBs for CRC shorter than 32 bits)
  */
static uint32_t CRC_Handle_8(CRC_HandleTypeDef *hcrc, uint8_t pBuffer[], uint32_t BufferLength)
{
 81fb128:	b5f0      	push	{r4, r5, r6, r7, lr}
 81fb12a:	460c      	mov	r4, r1
 81fb12c:	f022 0503 	bic.w	r5, r2, #3
  /* Processing time optimization: 4 bytes are entered in a row with a single word write,
   * last bytes must be carefully fed to the CRC calculator to ensure a correct type
   * handling by the peripheral */
  for (i = 0U; i < (BufferLength / 4U); i++)
  {
    hcrc->Instance->DR = ((uint32_t)pBuffer[4U * i] << 24U) | \
 81fb130:	6806      	ldr	r6, [r0, #0]
  for (i = 0U; i < (BufferLength / 4U); i++)
 81fb132:	0897      	lsrs	r7, r2, #2
 81fb134:	440d      	add	r5, r1
 81fb136:	42a5      	cmp	r5, r4
 81fb138:	d108      	bne.n	81fb14c <CRC_Handle_8+0x24>
                         ((uint32_t)pBuffer[(4U * i) + 1U] << 16U) | \
                         ((uint32_t)pBuffer[(4U * i) + 2U] << 8U)  | \
                         (uint32_t)pBuffer[(4U * i) + 3U];
  }
  /* last bytes specific handling */
  if ((BufferLength % 4U) != 0U)
 81fb13a:	f012 0203 	ands.w	r2, r2, #3
 81fb13e:	d01e      	beq.n	81fb17e <CRC_Handle_8+0x56>
  {
    if ((BufferLength % 4U) == 1U)
 81fb140:	2a01      	cmp	r2, #1
 81fb142:	d114      	bne.n	81fb16e <CRC_Handle_8+0x46>
    {
      *(__IO uint8_t *)(__IO void *)(&hcrc->Instance->DR) = pBuffer[4U * i];         /* Derogation MisraC2012 R.11.5 */
 81fb144:	f811 3027 	ldrb.w	r3, [r1, r7, lsl #2]
    {
      data = ((uint16_t)(pBuffer[4U * i]) << 8U) | (uint16_t)pBuffer[(4U * i) + 1U];
      pReg = (__IO uint16_t *)(__IO void *)(&hcrc->Instance->DR);                    /* Derogation MisraC2012 R.11.5 */
      *pReg = data;

      *(__IO uint8_t *)(__IO void *)(&hcrc->Instance->DR) = pBuffer[(4U * i) + 2U];  /* Derogation MisraC2012 R.11.5 */
 81fb148:	7033      	strb	r3, [r6, #0]
 81fb14a:	e018      	b.n	81fb17e <CRC_Handle_8+0x56>
                         ((uint32_t)pBuffer[(4U * i) + 1U] << 16U) | \
 81fb14c:	7863      	ldrb	r3, [r4, #1]
    hcrc->Instance->DR = ((uint32_t)pBuffer[4U * i] << 24U) | \
 81fb14e:	f894 c000 	ldrb.w	ip, [r4]
                         ((uint32_t)pBuffer[(4U * i) + 1U] << 16U) | \
 81fb152:	041b      	lsls	r3, r3, #16
                         ((uint32_t)pBuffer[(4U * i) + 2U] << 8U)  | \
 81fb154:	ea43 630c 	orr.w	r3, r3, ip, lsl #24
                         (uint32_t)pBuffer[(4U * i) + 3U];
 81fb158:	f894 c003 	ldrb.w	ip, [r4, #3]
 81fb15c:	3404      	adds	r4, #4
                         ((uint32_t)pBuffer[(4U * i) + 2U] << 8U)  | \
 81fb15e:	ea43 030c 	orr.w	r3, r3, ip
 81fb162:	f814 cc02 	ldrb.w	ip, [r4, #-2]
 81fb166:	ea43 230c 	orr.w	r3, r3, ip, lsl #8
    hcrc->Instance->DR = ((uint32_t)pBuffer[4U * i] << 24U) | \
 81fb16a:	6033      	str	r3, [r6, #0]
  for (i = 0U; i < (BufferLength / 4U); i++)
 81fb16c:	e7e3      	b.n	81fb136 <CRC_Handle_8+0xe>
      data = ((uint16_t)(pBuffer[4U * i]) << 8U) | (uint16_t)pBuffer[(4U * i) + 1U];
 81fb16e:	786b      	ldrb	r3, [r5, #1]
    if ((BufferLength % 4U) == 2U)
 81fb170:	2a02      	cmp	r2, #2
      data = ((uint16_t)(pBuffer[4U * i]) << 8U) | (uint16_t)pBuffer[(4U * i) + 1U];
 81fb172:	f811 2027 	ldrb.w	r2, [r1, r7, lsl #2]
 81fb176:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
      *pReg = data;
 81fb17a:	8033      	strh	r3, [r6, #0]
    if ((BufferLength % 4U) == 2U)
 81fb17c:	d102      	bne.n	81fb184 <CRC_Handle_8+0x5c>
    }
  }

  /* Return the CRC computed value */
  return hcrc->Instance->DR;
 81fb17e:	6803      	ldr	r3, [r0, #0]
 81fb180:	6818      	ldr	r0, [r3, #0]
}
 81fb182:	bdf0      	pop	{r4, r5, r6, r7, pc}
      *(__IO uint8_t *)(__IO void *)(&hcrc->Instance->DR) = pBuffer[(4U * i) + 2U];  /* Derogation MisraC2012 R.11.5 */
 81fb184:	78ab      	ldrb	r3, [r5, #2]
 81fb186:	e7df      	b.n	81fb148 <CRC_Handle_8+0x20>

081fb188 <CRC_Handle_16>:
  __IO uint16_t *pReg;

  /* Processing time optimization: 2 HalfWords are entered in a row with a single word write,
   * in case of odd length, last HalfWord must be carefully fed to the CRC calculator to ensure
   * a correct type handling by the peripheral */
  for (i = 0U; i < (BufferLength / 2U); i++)
 81fb188:	2300      	movs	r3, #0
  {
    hcrc->Instance->DR = ((uint32_t)pBuffer[2U * i] << 16U) | (uint32_t)pBuffer[(2U * i) + 1U];
 81fb18a:	6800      	ldr	r0, [r0, #0]
{
 81fb18c:	b5f0      	push	{r4, r5, r6, r7, lr}
  for (i = 0U; i < (BufferLength / 2U); i++)
 81fb18e:	0855      	lsrs	r5, r2, #1
    hcrc->Instance->DR = ((uint32_t)pBuffer[2U * i] << 16U) | (uint32_t)pBuffer[(2U * i) + 1U];
 81fb190:	1c8e      	adds	r6, r1, #2
  for (i = 0U; i < (BufferLength / 2U); i++)
 81fb192:	429d      	cmp	r5, r3
 81fb194:	d106      	bne.n	81fb1a4 <CRC_Handle_16+0x1c>
  }
  if ((BufferLength % 2U) != 0U)
 81fb196:	07d3      	lsls	r3, r2, #31
  {
    pReg = (__IO uint16_t *)(__IO void *)(&hcrc->Instance->DR);                 /* Derogation MisraC2012 R.11.5 */
    *pReg = pBuffer[2U * i];
 81fb198:	bf44      	itt	mi
 81fb19a:	f831 3025 	ldrhmi.w	r3, [r1, r5, lsl #2]
 81fb19e:	8003      	strhmi	r3, [r0, #0]
  }

  /* Return the CRC computed value */
  return hcrc->Instance->DR;
 81fb1a0:	6800      	ldr	r0, [r0, #0]
}
 81fb1a2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    hcrc->Instance->DR = ((uint32_t)pBuffer[2U * i] << 16U) | (uint32_t)pBuffer[(2U * i) + 1U];
 81fb1a4:	f831 7023 	ldrh.w	r7, [r1, r3, lsl #2]
 81fb1a8:	f836 4023 	ldrh.w	r4, [r6, r3, lsl #2]
  for (i = 0U; i < (BufferLength / 2U); i++)
 81fb1ac:	3301      	adds	r3, #1
    hcrc->Instance->DR = ((uint32_t)pBuffer[2U * i] << 16U) | (uint32_t)pBuffer[(2U * i) + 1U];
 81fb1ae:	ea44 4407 	orr.w	r4, r4, r7, lsl #16
 81fb1b2:	6004      	str	r4, [r0, #0]
  for (i = 0U; i < (BufferLength / 2U); i++)
 81fb1b4:	e7ed      	b.n	81fb192 <CRC_Handle_16+0xa>

081fb1b6 <HAL_CRC_MspInit>:
}
 81fb1b6:	4770      	bx	lr

081fb1b8 <HAL_CRC_Init>:
{
 81fb1b8:	b510      	push	{r4, lr}
  if (hcrc == NULL)
 81fb1ba:	4604      	mov	r4, r0
 81fb1bc:	b908      	cbnz	r0, 81fb1c2 <HAL_CRC_Init+0xa>
    return HAL_ERROR;
 81fb1be:	2001      	movs	r0, #1
}
 81fb1c0:	bd10      	pop	{r4, pc}
  if (hcrc->State == HAL_CRC_STATE_RESET)
 81fb1c2:	7f43      	ldrb	r3, [r0, #29]
 81fb1c4:	f003 02ff 	and.w	r2, r3, #255	@ 0xff
 81fb1c8:	b913      	cbnz	r3, 81fb1d0 <HAL_CRC_Init+0x18>
    hcrc->Lock = HAL_UNLOCKED;
 81fb1ca:	7702      	strb	r2, [r0, #28]
    HAL_CRC_MspInit(hcrc);
 81fb1cc:	f7ff fff3 	bl	81fb1b6 <HAL_CRC_MspInit>
  hcrc->State = HAL_CRC_STATE_BUSY;
 81fb1d0:	2302      	movs	r3, #2
 81fb1d2:	7763      	strb	r3, [r4, #29]
  if (hcrc->Init.DefaultPolynomialUse == DEFAULT_POLYNOMIAL_ENABLE)
 81fb1d4:	7923      	ldrb	r3, [r4, #4]
 81fb1d6:	b9e3      	cbnz	r3, 81fb212 <HAL_CRC_Init+0x5a>
    WRITE_REG(hcrc->Instance->POL, DEFAULT_CRC32_POLY);
 81fb1d8:	6823      	ldr	r3, [r4, #0]
 81fb1da:	4a13      	ldr	r2, [pc, #76]	@ (81fb228 <HAL_CRC_Init+0x70>)
 81fb1dc:	615a      	str	r2, [r3, #20]
    MODIFY_REG(hcrc->Instance->CR, CRC_CR_POLYSIZE, CRC_POLYLENGTH_32B);
 81fb1de:	689a      	ldr	r2, [r3, #8]
 81fb1e0:	f022 0218 	bic.w	r2, r2, #24
 81fb1e4:	609a      	str	r2, [r3, #8]
  if (hcrc->Init.DefaultInitValueUse == DEFAULT_INIT_VALUE_ENABLE)
 81fb1e6:	7962      	ldrb	r2, [r4, #5]
    WRITE_REG(hcrc->Instance->INIT, DEFAULT_CRC_INITVALUE);
 81fb1e8:	6823      	ldr	r3, [r4, #0]
  if (hcrc->Init.DefaultInitValueUse == DEFAULT_INIT_VALUE_ENABLE)
 81fb1ea:	b9d2      	cbnz	r2, 81fb222 <HAL_CRC_Init+0x6a>
    WRITE_REG(hcrc->Instance->INIT, DEFAULT_CRC_INITVALUE);
 81fb1ec:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
    WRITE_REG(hcrc->Instance->INIT, hcrc->Init.InitValue);
 81fb1f0:	611a      	str	r2, [r3, #16]
  MODIFY_REG(hcrc->Instance->CR, CRC_CR_REV_IN, hcrc->Init.InputDataInversionMode);
 81fb1f2:	689a      	ldr	r2, [r3, #8]
 81fb1f4:	6961      	ldr	r1, [r4, #20]
 81fb1f6:	f022 0260 	bic.w	r2, r2, #96	@ 0x60
 81fb1fa:	430a      	orrs	r2, r1
 81fb1fc:	609a      	str	r2, [r3, #8]
  MODIFY_REG(hcrc->Instance->CR, CRC_CR_REV_OUT, hcrc->Init.OutputDataInversionMode);
 81fb1fe:	689a      	ldr	r2, [r3, #8]
 81fb200:	69a1      	ldr	r1, [r4, #24]
 81fb202:	f022 0280 	bic.w	r2, r2, #128	@ 0x80
 81fb206:	430a      	orrs	r2, r1
 81fb208:	609a      	str	r2, [r3, #8]
  hcrc->State = HAL_CRC_STATE_READY;
 81fb20a:	2301      	movs	r3, #1
  return HAL_OK;
 81fb20c:	2000      	movs	r0, #0
  hcrc->State = HAL_CRC_STATE_READY;
 81fb20e:	7763      	strb	r3, [r4, #29]
  return HAL_OK;
 81fb210:	e7d6      	b.n	81fb1c0 <HAL_CRC_Init+0x8>
    if (HAL_CRCEx_Polynomial_Set(hcrc, hcrc->Init.GeneratingPolynomial, hcrc->Init.CRCLength) != HAL_OK)
 81fb212:	4620      	mov	r0, r4
 81fb214:	e9d4 1202 	ldrd	r1, r2, [r4, #8]
 81fb218:	f000 f82c 	bl	81fb274 <HAL_CRCEx_Polynomial_Set>
 81fb21c:	2800      	cmp	r0, #0
 81fb21e:	d0e2      	beq.n	81fb1e6 <HAL_CRC_Init+0x2e>
 81fb220:	e7cd      	b.n	81fb1be <HAL_CRC_Init+0x6>
    WRITE_REG(hcrc->Instance->INIT, hcrc->Init.InitValue);
 81fb222:	6922      	ldr	r2, [r4, #16]
 81fb224:	e7e4      	b.n	81fb1f0 <HAL_CRC_Init+0x38>
 81fb226:	bf00      	nop
 81fb228:	04c11db7 	.word	0x04c11db7

081fb22c <HAL_CRC_Calculate>:
{
 81fb22c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  hcrc->State = HAL_CRC_STATE_BUSY;
 81fb22e:	2602      	movs	r6, #2
 81fb230:	7746      	strb	r6, [r0, #29]
  __HAL_CRC_DR_RESET(hcrc);
 81fb232:	6806      	ldr	r6, [r0, #0]
{
 81fb234:	4604      	mov	r4, r0
  __HAL_CRC_DR_RESET(hcrc);
 81fb236:	68b7      	ldr	r7, [r6, #8]
 81fb238:	f047 0701 	orr.w	r7, r7, #1
 81fb23c:	60b7      	str	r7, [r6, #8]
  switch (hcrc->InputDataFormat)
 81fb23e:	6a07      	ldr	r7, [r0, #32]
 81fb240:	2f02      	cmp	r7, #2
 81fb242:	d014      	beq.n	81fb26e <HAL_CRC_Calculate+0x42>
 81fb244:	2f03      	cmp	r7, #3
 81fb246:	d005      	beq.n	81fb254 <HAL_CRC_Calculate+0x28>
 81fb248:	2f01      	cmp	r7, #1
 81fb24a:	d00d      	beq.n	81fb268 <HAL_CRC_Calculate+0x3c>
 81fb24c:	2000      	movs	r0, #0
  hcrc->State = HAL_CRC_STATE_READY;
 81fb24e:	2301      	movs	r3, #1
 81fb250:	7763      	strb	r3, [r4, #29]
}
 81fb252:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 81fb254:	eb01 0582 	add.w	r5, r1, r2, lsl #2
      for (index = 0U; index < BufferLength; index++)
 81fb258:	42a9      	cmp	r1, r5
 81fb25a:	d101      	bne.n	81fb260 <HAL_CRC_Calculate+0x34>
      temp = hcrc->Instance->DR;
 81fb25c:	6830      	ldr	r0, [r6, #0]
      break;
 81fb25e:	e7f6      	b.n	81fb24e <HAL_CRC_Calculate+0x22>
        hcrc->Instance->DR = pBuffer[index];
 81fb260:	f851 3b04 	ldr.w	r3, [r1], #4
 81fb264:	6033      	str	r3, [r6, #0]
      for (index = 0U; index < BufferLength; index++)
 81fb266:	e7f7      	b.n	81fb258 <HAL_CRC_Calculate+0x2c>
      temp = CRC_Handle_8(hcrc, (uint8_t *)pBuffer, BufferLength);
 81fb268:	f7ff ff5e 	bl	81fb128 <CRC_Handle_8>
      break;
 81fb26c:	e7ef      	b.n	81fb24e <HAL_CRC_Calculate+0x22>
      temp = CRC_Handle_16(hcrc, (uint16_t *)(void *)pBuffer, BufferLength);    /* Derogation MisraC2012 R.11.5 */
 81fb26e:	f7ff ff8b 	bl	81fb188 <CRC_Handle_16>
      break;
 81fb272:	e7ec      	b.n	81fb24e <HAL_CRC_Calculate+0x22>

081fb274 <HAL_CRCEx_Polynomial_Set>:

  /* Check the parameters */
  assert_param(IS_CRC_POL_LENGTH(PolyLength));

  /* Ensure that the generating polynomial is odd */
  if ((Pol & (uint32_t)(0x1U)) ==  0U)
 81fb274:	07cb      	lsls	r3, r1, #31
{
 81fb276:	b510      	push	{r4, lr}
  if ((Pol & (uint32_t)(0x1U)) ==  0U)
 81fb278:	d50d      	bpl.n	81fb296 <HAL_CRCEx_Polynomial_Set+0x22>
  uint32_t msb = 31U; /* polynomial degree is 32 at most, so msb is initialized to max value */
 81fb27a:	231f      	movs	r3, #31
     * definition. HAL_ERROR is reported if Pol degree is
     * larger than that indicated by PolyLength.
     * Look for MSB position: msb will contain the degree of
     *  the second to the largest polynomial member. E.g., for
     *  X^7 + X^6 + X^5 + X^2 + 1, msb = 6. */
    while ((msb-- > 0U) && ((Pol & ((uint32_t)(0x1U) << (msb & 0x1FU))) == 0U))
 81fb27c:	3b01      	subs	r3, #1
 81fb27e:	d31d      	bcc.n	81fb2bc <HAL_CRCEx_Polynomial_Set+0x48>
 81fb280:	fa21 f403 	lsr.w	r4, r1, r3
 81fb284:	07e4      	lsls	r4, r4, #31
 81fb286:	d5f9      	bpl.n	81fb27c <HAL_CRCEx_Polynomial_Set+0x8>
    {
    }

    switch (PolyLength)
 81fb288:	2a10      	cmp	r2, #16
 81fb28a:	d013      	beq.n	81fb2b4 <HAL_CRCEx_Polynomial_Set+0x40>
 81fb28c:	2a10      	cmp	r2, #16
 81fb28e:	d804      	bhi.n	81fb29a <HAL_CRCEx_Polynomial_Set+0x26>
 81fb290:	b13a      	cbz	r2, 81fb2a2 <HAL_CRCEx_Polynomial_Set+0x2e>
 81fb292:	2a08      	cmp	r2, #8
 81fb294:	d010      	beq.n	81fb2b8 <HAL_CRCEx_Polynomial_Set+0x44>
 81fb296:	2001      	movs	r0, #1

    /* set generating polynomial size */
    MODIFY_REG(hcrc->Instance->CR, CRC_CR_POLYSIZE, PolyLength);
  }
  /* Return function status */
  return status;
 81fb298:	e00b      	b.n	81fb2b2 <HAL_CRCEx_Polynomial_Set+0x3e>
    switch (PolyLength)
 81fb29a:	2a18      	cmp	r2, #24
 81fb29c:	d1fb      	bne.n	81fb296 <HAL_CRCEx_Polynomial_Set+0x22>
        if (msb >= HAL_CRC_LENGTH_7B)
 81fb29e:	2b06      	cmp	r3, #6
        if (msb >= HAL_CRC_LENGTH_16B)
 81fb2a0:	d8f9      	bhi.n	81fb296 <HAL_CRCEx_Polynomial_Set+0x22>
    WRITE_REG(hcrc->Instance->POL, Pol);
 81fb2a2:	6800      	ldr	r0, [r0, #0]
 81fb2a4:	6141      	str	r1, [r0, #20]
    MODIFY_REG(hcrc->Instance->CR, CRC_CR_POLYSIZE, PolyLength);
 81fb2a6:	6883      	ldr	r3, [r0, #8]
 81fb2a8:	f023 0318 	bic.w	r3, r3, #24
 81fb2ac:	4313      	orrs	r3, r2
 81fb2ae:	6083      	str	r3, [r0, #8]
 81fb2b0:	2000      	movs	r0, #0
}
 81fb2b2:	bd10      	pop	{r4, pc}
        if (msb >= HAL_CRC_LENGTH_8B)
 81fb2b4:	2b07      	cmp	r3, #7
 81fb2b6:	e7f3      	b.n	81fb2a0 <HAL_CRCEx_Polynomial_Set+0x2c>
        if (msb >= HAL_CRC_LENGTH_16B)
 81fb2b8:	2b0f      	cmp	r3, #15
 81fb2ba:	e7f1      	b.n	81fb2a0 <HAL_CRCEx_Polynomial_Set+0x2c>
    switch (PolyLength)
 81fb2bc:	2a10      	cmp	r2, #16
 81fb2be:	d1e5      	bne.n	81fb28c <HAL_CRCEx_Polynomial_Set+0x18>
 81fb2c0:	e7e9      	b.n	81fb296 <HAL_CRCEx_Polynomial_Set+0x22>
	...

081fb2c4 <FLASH_Program_QuadWord>:

  /* Access to SECCR or NSCR registers depends on operation type */
  reg_cr = IS_FLASH_SECURE_OPERATION() ? &(FLASH->SECCR) : &(FLASH_NS->NSCR);

  /* Set PG bit */
  SET_BIT((*reg_cr), FLASH_NSCR_PG);
 81fb2c4:	4a08      	ldr	r2, [pc, #32]	@ (81fb2e8 <FLASH_Program_QuadWord+0x24>)
{
 81fb2c6:	b510      	push	{r4, lr}
  SET_BIT((*reg_cr), FLASH_NSCR_PG);
 81fb2c8:	6a93      	ldr	r3, [r2, #40]	@ 0x28
 81fb2ca:	f043 0301 	orr.w	r3, r3, #1
 81fb2ce:	6293      	str	r3, [r2, #40]	@ 0x28
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 81fb2d0:	f3ef 8210 	mrs	r2, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 81fb2d4:	b672      	cpsid	i
}
 81fb2d6:	2300      	movs	r3, #0
  __disable_irq();

  /* Program the quad-word */
  do
  {
    *dest_addr = *src_addr;
 81fb2d8:	58cc      	ldr	r4, [r1, r3]
 81fb2da:	50c4      	str	r4, [r0, r3]
    dest_addr++;
    src_addr++;
    index--;
  } while (index != 0U);
 81fb2dc:	3304      	adds	r3, #4
 81fb2de:	2b10      	cmp	r3, #16
 81fb2e0:	d1fa      	bne.n	81fb2d8 <FLASH_Program_QuadWord+0x14>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 81fb2e2:	f382 8810 	msr	PRIMASK, r2

  /* Exit critical section: restore previous priority mask */
  __set_PRIMASK(primask_bit);
}
 81fb2e6:	bd10      	pop	{r4, pc}
 81fb2e8:	40022000 	.word	0x40022000

081fb2ec <FLASH_Program_Burst>:

  /* Access to SECCR or NSCR registers depends on operation type */
  reg_cr = IS_FLASH_SECURE_OPERATION() ? &(FLASH->SECCR) : &(FLASH_NS->NSCR);

  /* Set PG and BWR bits */
  SET_BIT((*reg_cr), (FLASH_NSCR_PG | FLASH_NSCR_BWR));
 81fb2ec:	4a09      	ldr	r2, [pc, #36]	@ (81fb314 <FLASH_Program_Burst+0x28>)
{
 81fb2ee:	b510      	push	{r4, lr}
  SET_BIT((*reg_cr), (FLASH_NSCR_PG | FLASH_NSCR_BWR));
 81fb2f0:	6a93      	ldr	r3, [r2, #40]	@ 0x28
 81fb2f2:	f443 4380 	orr.w	r3, r3, #16384	@ 0x4000
 81fb2f6:	f043 0301 	orr.w	r3, r3, #1
 81fb2fa:	6293      	str	r3, [r2, #40]	@ 0x28
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 81fb2fc:	f3ef 8210 	mrs	r2, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 81fb300:	b672      	cpsid	i
}
 81fb302:	2300      	movs	r3, #0
  __disable_irq();

  /* Program the burst */
  do
  {
    *dest_addr = *src_addr;
 81fb304:	58cc      	ldr	r4, [r1, r3]
 81fb306:	50c4      	str	r4, [r0, r3]
    dest_addr++;
    src_addr++;
    burst_index--;
  } while (burst_index != 0U);
 81fb308:	3304      	adds	r3, #4
 81fb30a:	2b80      	cmp	r3, #128	@ 0x80
 81fb30c:	d1fa      	bne.n	81fb304 <FLASH_Program_Burst+0x18>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 81fb30e:	f382 8810 	msr	PRIMASK, r2

  /* Exit critical section: restore previous priority mask */
  __set_PRIMASK(primask_bit);
}
 81fb312:	bd10      	pop	{r4, pc}
 81fb314:	40022000 	.word	0x40022000

081fb318 <HAL_FLASH_Unlock>:
  if (READ_BIT(FLASH->NSCR, FLASH_NSCR_LOCK) != 0U)
 81fb318:	4b06      	ldr	r3, [pc, #24]	@ (81fb334 <HAL_FLASH_Unlock+0x1c>)
 81fb31a:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
 81fb31c:	2a00      	cmp	r2, #0
    WRITE_REG(FLASH->NSKEYR, FLASH_KEY1);
 81fb31e:	bfbf      	itttt	lt
 81fb320:	4a05      	ldrlt	r2, [pc, #20]	@ (81fb338 <HAL_FLASH_Unlock+0x20>)
 81fb322:	609a      	strlt	r2, [r3, #8]
    WRITE_REG(FLASH->NSKEYR, FLASH_KEY2);
 81fb324:	f102 3288 	addlt.w	r2, r2, #2290649224	@ 0x88888888
 81fb328:	609a      	strlt	r2, [r3, #8]
    if (READ_BIT(FLASH->NSCR, FLASH_NSCR_LOCK) != 0U)
 81fb32a:	bfba      	itte	lt
 81fb32c:	6a98      	ldrlt	r0, [r3, #40]	@ 0x28
 81fb32e:	0fc0      	lsrlt	r0, r0, #31
  HAL_StatusTypeDef status = HAL_OK;
 81fb330:	2000      	movge	r0, #0
}
 81fb332:	4770      	bx	lr
 81fb334:	40022000 	.word	0x40022000
 81fb338:	45670123 	.word	0x45670123

081fb33c <HAL_FLASH_Lock>:
  SET_BIT(FLASH->NSCR, FLASH_NSCR_LOCK);
 81fb33c:	4b04      	ldr	r3, [pc, #16]	@ (81fb350 <HAL_FLASH_Lock+0x14>)
 81fb33e:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
 81fb340:	f042 4200 	orr.w	r2, r2, #2147483648	@ 0x80000000
 81fb344:	629a      	str	r2, [r3, #40]	@ 0x28
  if (READ_BIT(FLASH->NSCR, FLASH_NSCR_LOCK) != 0U)
 81fb346:	6a98      	ldr	r0, [r3, #40]	@ 0x28
}
 81fb348:	43c0      	mvns	r0, r0
 81fb34a:	0fc0      	lsrs	r0, r0, #31
 81fb34c:	4770      	bx	lr
 81fb34e:	bf00      	nop
 81fb350:	40022000 	.word	0x40022000

081fb354 <FLASH_WaitForLastOperation>:
{
 81fb354:	b570      	push	{r4, r5, r6, lr}
 81fb356:	4605      	mov	r5, r0
  uint32_t timeout = HAL_GetTick() + Timeout;
 81fb358:	f7ff fcac 	bl	81facb4 <HAL_GetTick>
  while (((*reg_sr) & (FLASH_FLAG_BSY | FLASH_FLAG_WDW)) != 0U)
 81fb35c:	4c10      	ldr	r4, [pc, #64]	@ (81fb3a0 <FLASH_WaitForLastOperation+0x4c>)
  uint32_t timeout = HAL_GetTick() + Timeout;
 81fb35e:	1946      	adds	r6, r0, r5
  while (((*reg_sr) & (FLASH_FLAG_BSY | FLASH_FLAG_WDW)) != 0U)
 81fb360:	6a23      	ldr	r3, [r4, #32]
 81fb362:	f413 3f40 	tst.w	r3, #196608	@ 0x30000
 81fb366:	d10b      	bne.n	81fb380 <FLASH_WaitForLastOperation+0x2c>
  error = ((*reg_sr) & FLASH_FLAG_SR_ERRORS);
 81fb368:	f242 02fa 	movw	r2, #8442	@ 0x20fa
 81fb36c:	6a23      	ldr	r3, [r4, #32]
  if (error != 0U)
 81fb36e:	4013      	ands	r3, r2
 81fb370:	d00e      	beq.n	81fb390 <FLASH_WaitForLastOperation+0x3c>
    return HAL_ERROR;
 81fb372:	2001      	movs	r0, #1
    pFlash.ErrorCode |= error;
 81fb374:	490b      	ldr	r1, [pc, #44]	@ (81fb3a4 <FLASH_WaitForLastOperation+0x50>)
 81fb376:	684a      	ldr	r2, [r1, #4]
 81fb378:	431a      	orrs	r2, r3
 81fb37a:	604a      	str	r2, [r1, #4]
    (*reg_sr) = error;
 81fb37c:	6223      	str	r3, [r4, #32]
}
 81fb37e:	bd70      	pop	{r4, r5, r6, pc}
    if (Timeout != HAL_MAX_DELAY)
 81fb380:	1c6a      	adds	r2, r5, #1
 81fb382:	d0ed      	beq.n	81fb360 <FLASH_WaitForLastOperation+0xc>
      if (HAL_GetTick() >= timeout)
 81fb384:	f7ff fc96 	bl	81facb4 <HAL_GetTick>
 81fb388:	42b0      	cmp	r0, r6
 81fb38a:	d3e9      	bcc.n	81fb360 <FLASH_WaitForLastOperation+0xc>
        return HAL_TIMEOUT;
 81fb38c:	2003      	movs	r0, #3
 81fb38e:	e7f6      	b.n	81fb37e <FLASH_WaitForLastOperation+0x2a>
  if (((*reg_sr) & FLASH_FLAG_EOP) != 0U)
 81fb390:	6a23      	ldr	r3, [r4, #32]
    return HAL_ERROR;
 81fb392:	2000      	movs	r0, #0
  if (((*reg_sr) & FLASH_FLAG_EOP) != 0U)
 81fb394:	07db      	lsls	r3, r3, #31
    (*reg_sr) = FLASH_FLAG_EOP;
 81fb396:	bf44      	itt	mi
 81fb398:	2301      	movmi	r3, #1
 81fb39a:	6223      	strmi	r3, [r4, #32]
 81fb39c:	e7ef      	b.n	81fb37e <FLASH_WaitForLastOperation+0x2a>
 81fb39e:	bf00      	nop
 81fb3a0:	40022000 	.word	0x40022000
 81fb3a4:	20000030 	.word	0x20000030

081fb3a8 <HAL_FLASH_Program>:
{
 81fb3a8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  __HAL_LOCK(&pFlash);
 81fb3aa:	4d15      	ldr	r5, [pc, #84]	@ (81fb400 <HAL_FLASH_Program+0x58>)
{
 81fb3ac:	4604      	mov	r4, r0
  __HAL_LOCK(&pFlash);
 81fb3ae:	782b      	ldrb	r3, [r5, #0]
{
 81fb3b0:	460e      	mov	r6, r1
  __HAL_LOCK(&pFlash);
 81fb3b2:	2b01      	cmp	r3, #1
{
 81fb3b4:	4617      	mov	r7, r2
  __HAL_LOCK(&pFlash);
 81fb3b6:	d020      	beq.n	81fb3fa <HAL_FLASH_Program+0x52>
 81fb3b8:	2301      	movs	r3, #1
 81fb3ba:	702b      	strb	r3, [r5, #0]
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 81fb3bc:	2300      	movs	r3, #0
  status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 81fb3be:	f44f 707a 	mov.w	r0, #1000	@ 0x3e8
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 81fb3c2:	606b      	str	r3, [r5, #4]
  status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 81fb3c4:	f7ff ffc6 	bl	81fb354 <FLASH_WaitForLastOperation>
  if (status == HAL_OK)
 81fb3c8:	b988      	cbnz	r0, 81fb3ee <HAL_FLASH_Program+0x46>
    pFlash.ProcedureOnGoing = TypeProgram;
 81fb3ca:	60ac      	str	r4, [r5, #8]
    if ((TypeProgram & (~FLASH_NON_SECURE_MASK)) == FLASH_TYPEPROGRAM_QUADWORD)
 81fb3cc:	f024 4400 	bic.w	r4, r4, #2147483648	@ 0x80000000
 81fb3d0:	2c01      	cmp	r4, #1
      FLASH_Program_QuadWord(Address, DataAddress);
 81fb3d2:	4639      	mov	r1, r7
 81fb3d4:	4630      	mov	r0, r6
    if ((TypeProgram & (~FLASH_NON_SECURE_MASK)) == FLASH_TYPEPROGRAM_QUADWORD)
 81fb3d6:	d10d      	bne.n	81fb3f4 <HAL_FLASH_Program+0x4c>
      FLASH_Program_QuadWord(Address, DataAddress);
 81fb3d8:	f7ff ff74 	bl	81fb2c4 <FLASH_Program_QuadWord>
    status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 81fb3dc:	f44f 707a 	mov.w	r0, #1000	@ 0x3e8
 81fb3e0:	f7ff ffb8 	bl	81fb354 <FLASH_WaitForLastOperation>
    CLEAR_BIT((*reg_cr), (TypeProgram & ~(FLASH_NON_SECURE_MASK)));
 81fb3e4:	4a07      	ldr	r2, [pc, #28]	@ (81fb404 <HAL_FLASH_Program+0x5c>)
 81fb3e6:	6a93      	ldr	r3, [r2, #40]	@ 0x28
 81fb3e8:	ea23 0304 	bic.w	r3, r3, r4
 81fb3ec:	6293      	str	r3, [r2, #40]	@ 0x28
  __HAL_UNLOCK(&pFlash);
 81fb3ee:	2300      	movs	r3, #0
 81fb3f0:	702b      	strb	r3, [r5, #0]
}
 81fb3f2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      FLASH_Program_Burst(Address, DataAddress);
 81fb3f4:	f7ff ff7a 	bl	81fb2ec <FLASH_Program_Burst>
 81fb3f8:	e7f0      	b.n	81fb3dc <HAL_FLASH_Program+0x34>
  __HAL_LOCK(&pFlash);
 81fb3fa:	2002      	movs	r0, #2
 81fb3fc:	e7f9      	b.n	81fb3f2 <HAL_FLASH_Program+0x4a>
 81fb3fe:	bf00      	nop
 81fb400:	20000030 	.word	0x20000030
 81fb404:	40022000 	.word	0x40022000

081fb408 <FLASH_MassErase>:

  /* Access to SECCR or NSCR registers depends on operation type */
  reg_cr = IS_FLASH_SECURE_OPERATION() ? &(FLASH->SECCR) : &(FLASH_NS->NSCR);

  /* Set the Mass Erase Bit for the bank 1 and proceed to erase */
  if ((Banks & FLASH_BANK_1) != 0U)
 81fb408:	07c2      	lsls	r2, r0, #31
 81fb40a:	d506      	bpl.n	81fb41a <FLASH_MassErase+0x12>
  {
    SET_BIT((*reg_cr), FLASH_NSCR_MER1 | FLASH_NSCR_STRT);
 81fb40c:	4a07      	ldr	r2, [pc, #28]	@ (81fb42c <FLASH_MassErase+0x24>)
 81fb40e:	6a93      	ldr	r3, [r2, #40]	@ 0x28
 81fb410:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 81fb414:	f043 0304 	orr.w	r3, r3, #4
 81fb418:	6293      	str	r3, [r2, #40]	@ 0x28
  }

  /* Set the Mass Erase Bit for the bank 2 and proceed to erase */
  if ((Banks & FLASH_BANK_2) != 0U)
 81fb41a:	0783      	lsls	r3, r0, #30
  {
    SET_BIT((*reg_cr), FLASH_NSCR_MER2 | FLASH_NSCR_STRT);
 81fb41c:	bf41      	itttt	mi
 81fb41e:	4a03      	ldrmi	r2, [pc, #12]	@ (81fb42c <FLASH_MassErase+0x24>)
 81fb420:	6a93      	ldrmi	r3, [r2, #40]	@ 0x28
 81fb422:	f443 33c0 	orrmi.w	r3, r3, #98304	@ 0x18000
 81fb426:	6293      	strmi	r3, [r2, #40]	@ 0x28
  }
}
 81fb428:	4770      	bx	lr
 81fb42a:	bf00      	nop
 81fb42c:	40022000 	.word	0x40022000

081fb430 <FLASH_PageErase>:
  assert_param(IS_FLASH_BANK_EXCLUSIVE(Banks));

  /* Access to SECCR or NSCR registers depends on operation type */
  reg_cr = IS_FLASH_SECURE_OPERATION() ? &(FLASH->SECCR) : &(FLASH_NS->NSCR);

  if ((Banks & FLASH_BANK_1) != 0U)
 81fb430:	4a0b      	ldr	r2, [pc, #44]	@ (81fb460 <FLASH_PageErase+0x30>)
 81fb432:	f011 0f01 	tst.w	r1, #1
  {
    CLEAR_BIT((*reg_cr), FLASH_NSCR_BKER);
 81fb436:	6a93      	ldr	r3, [r2, #40]	@ 0x28
 81fb438:	bf14      	ite	ne
 81fb43a:	f423 6300 	bicne.w	r3, r3, #2048	@ 0x800
  }
  else
  {
    SET_BIT((*reg_cr), FLASH_NSCR_BKER);
 81fb43e:	f443 6300 	orreq.w	r3, r3, #2048	@ 0x800
 81fb442:	6293      	str	r3, [r2, #40]	@ 0x28
  }

  /* Proceed to erase the page */
  MODIFY_REG((*reg_cr), (FLASH_NSCR_PNB | FLASH_NSCR_PER | FLASH_NSCR_STRT), \
 81fb444:	6a93      	ldr	r3, [r2, #40]	@ 0x28
 81fb446:	f423 3381 	bic.w	r3, r3, #66048	@ 0x10200
 81fb44a:	f423 73fd 	bic.w	r3, r3, #506	@ 0x1fa
 81fb44e:	ea43 00c0 	orr.w	r0, r3, r0, lsl #3
 81fb452:	f440 3080 	orr.w	r0, r0, #65536	@ 0x10000
 81fb456:	f040 0002 	orr.w	r0, r0, #2
 81fb45a:	6290      	str	r0, [r2, #40]	@ 0x28
             ((Page << FLASH_NSCR_PNB_Pos) | FLASH_NSCR_PER | FLASH_NSCR_STRT));
}
 81fb45c:	4770      	bx	lr
 81fb45e:	bf00      	nop
 81fb460:	40022000 	.word	0x40022000

081fb464 <HAL_FLASHEx_Erase>:
{
 81fb464:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  __HAL_LOCK(&pFlash);
 81fb468:	4e23      	ldr	r6, [pc, #140]	@ (81fb4f8 <HAL_FLASHEx_Erase+0x94>)
{
 81fb46a:	4605      	mov	r5, r0
  __HAL_LOCK(&pFlash);
 81fb46c:	7833      	ldrb	r3, [r6, #0]
{
 81fb46e:	4688      	mov	r8, r1
  __HAL_LOCK(&pFlash);
 81fb470:	2b01      	cmp	r3, #1
 81fb472:	d03e      	beq.n	81fb4f2 <HAL_FLASHEx_Erase+0x8e>
 81fb474:	2301      	movs	r3, #1
 81fb476:	7033      	strb	r3, [r6, #0]
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 81fb478:	2300      	movs	r3, #0
  status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 81fb47a:	f44f 707a 	mov.w	r0, #1000	@ 0x3e8
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 81fb47e:	6073      	str	r3, [r6, #4]
  status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 81fb480:	f7ff ff68 	bl	81fb354 <FLASH_WaitForLastOperation>
  if (status == HAL_OK)
 81fb484:	4604      	mov	r4, r0
 81fb486:	b9b8      	cbnz	r0, 81fb4b8 <HAL_FLASHEx_Erase+0x54>
    if ((pEraseInit->TypeErase & (~FLASH_NON_SECURE_MASK)) == FLASH_TYPEERASE_MASSERASE)
 81fb488:	f248 0204 	movw	r2, #32772	@ 0x8004
    pFlash.ProcedureOnGoing = pEraseInit->TypeErase;
 81fb48c:	682b      	ldr	r3, [r5, #0]
 81fb48e:	60b3      	str	r3, [r6, #8]
    if ((pEraseInit->TypeErase & (~FLASH_NON_SECURE_MASK)) == FLASH_TYPEERASE_MASSERASE)
 81fb490:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
 81fb494:	4293      	cmp	r3, r2
 81fb496:	d114      	bne.n	81fb4c2 <HAL_FLASHEx_Erase+0x5e>
      FLASH_MassErase(pEraseInit->Banks);
 81fb498:	6868      	ldr	r0, [r5, #4]
 81fb49a:	f7ff ffb5 	bl	81fb408 <FLASH_MassErase>
      status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 81fb49e:	f44f 707a 	mov.w	r0, #1000	@ 0x3e8
 81fb4a2:	f7ff ff57 	bl	81fb354 <FLASH_WaitForLastOperation>
        status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 81fb4a6:	4604      	mov	r4, r0
    CLEAR_BIT((*reg_cr), (pEraseInit->TypeErase) & (~(FLASH_NON_SECURE_MASK)));
 81fb4a8:	4914      	ldr	r1, [pc, #80]	@ (81fb4fc <HAL_FLASHEx_Erase+0x98>)
 81fb4aa:	682a      	ldr	r2, [r5, #0]
 81fb4ac:	6a8b      	ldr	r3, [r1, #40]	@ 0x28
 81fb4ae:	f022 4200 	bic.w	r2, r2, #2147483648	@ 0x80000000
 81fb4b2:	ea23 0302 	bic.w	r3, r3, r2
 81fb4b6:	628b      	str	r3, [r1, #40]	@ 0x28
  __HAL_UNLOCK(&pFlash);
 81fb4b8:	2300      	movs	r3, #0
 81fb4ba:	7033      	strb	r3, [r6, #0]
}
 81fb4bc:	4620      	mov	r0, r4
 81fb4be:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      *PageError = 0xFFFFFFFFU;
 81fb4c2:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 81fb4c6:	f8c8 3000 	str.w	r3, [r8]
      for (page_index = pEraseInit->Page; page_index < (pEraseInit->Page + pEraseInit->NbPages); page_index++)
 81fb4ca:	68af      	ldr	r7, [r5, #8]
 81fb4cc:	e9d5 3202 	ldrd	r3, r2, [r5, #8]
 81fb4d0:	4413      	add	r3, r2
 81fb4d2:	42bb      	cmp	r3, r7
 81fb4d4:	d9e8      	bls.n	81fb4a8 <HAL_FLASHEx_Erase+0x44>
        FLASH_PageErase(page_index, pEraseInit->Banks);
 81fb4d6:	4638      	mov	r0, r7
 81fb4d8:	6869      	ldr	r1, [r5, #4]
 81fb4da:	f7ff ffa9 	bl	81fb430 <FLASH_PageErase>
        status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 81fb4de:	f44f 707a 	mov.w	r0, #1000	@ 0x3e8
 81fb4e2:	f7ff ff37 	bl	81fb354 <FLASH_WaitForLastOperation>
        if (status != HAL_OK)
 81fb4e6:	b110      	cbz	r0, 81fb4ee <HAL_FLASHEx_Erase+0x8a>
          *PageError = page_index;
 81fb4e8:	f8c8 7000 	str.w	r7, [r8]
 81fb4ec:	e7db      	b.n	81fb4a6 <HAL_FLASHEx_Erase+0x42>
      for (page_index = pEraseInit->Page; page_index < (pEraseInit->Page + pEraseInit->NbPages); page_index++)
 81fb4ee:	3701      	adds	r7, #1
 81fb4f0:	e7ec      	b.n	81fb4cc <HAL_FLASHEx_Erase+0x68>
  __HAL_LOCK(&pFlash);
 81fb4f2:	2402      	movs	r4, #2
 81fb4f4:	e7e2      	b.n	81fb4bc <HAL_FLASHEx_Erase+0x58>
 81fb4f6:	bf00      	nop
 81fb4f8:	20000030 	.word	0x20000030
 81fb4fc:	40022000 	.word	0x40022000

081fb500 <HAL_GPIO_Init>:
  * @param  pGPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, const GPIO_InitTypeDef *pGPIO_Init)
{
 81fb500:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
      /* Configure the External Interrupt or event for the current IO */
      if ((pGPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
      {
        tmp = EXTI->EXTICR[position >> 2U];
        tmp &= ~((0x0FUL) << (8U * (position & 0x03U)));
        tmp |= (GPIO_GET_INDEX(GPIOx) << (8U * (position & 0x03U)));
 81fb504:	4b81      	ldr	r3, [pc, #516]	@ (81fb70c <HAL_GPIO_Init+0x20c>)
{
 81fb506:	b085      	sub	sp, #20
        tmp |= (GPIO_GET_INDEX(GPIOx) << (8U * (position & 0x03U)));
 81fb508:	ea03 2390 	and.w	r3, r3, r0, lsr #10
 81fb50c:	9303      	str	r3, [sp, #12]
 81fb50e:	4b80      	ldr	r3, [pc, #512]	@ (81fb710 <HAL_GPIO_Init+0x210>)
  uint32_t position = 0U;
 81fb510:	2200      	movs	r2, #0
 81fb512:	9302      	str	r3, [sp, #8]
        tmp &= ~(GPIO_PUPDR_PUPD0 << (pin_position * 2U));
 81fb514:	f04f 0e03 	mov.w	lr, #3
  while (((pGPIO_Init->Pin) >> position) != 0U)
 81fb518:	4603      	mov	r3, r0
        EXTI->EXTICR[position >> 2U] = tmp;

        /* Clear Rising Falling edge configuration */
        tmp = EXTI->RTSR1;
 81fb51a:	4f7e      	ldr	r7, [pc, #504]	@ (81fb714 <HAL_GPIO_Init+0x214>)
  while (((pGPIO_Init->Pin) >> position) != 0U)
 81fb51c:	680e      	ldr	r6, [r1, #0]
 81fb51e:	fa36 f402 	lsrs.w	r4, r6, r2
 81fb522:	d102      	bne.n	81fb52a <HAL_GPIO_Init+0x2a>
        EXTI->IMR1 = tmp;
      }
    }
    position++;
  }
}
 81fb524:	b005      	add	sp, #20
 81fb526:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    iocurrent = (pGPIO_Init->Pin) & (1UL << position);
 81fb52a:	2401      	movs	r4, #1
 81fb52c:	fa04 fc02 	lsl.w	ip, r4, r2
    if (iocurrent != 0U)
 81fb530:	ea1c 0406 	ands.w	r4, ip, r6
 81fb534:	9401      	str	r4, [sp, #4]
 81fb536:	f000 808e 	beq.w	81fb656 <HAL_GPIO_Init+0x156>
      if (GPIOx == LPGPIO1)
 81fb53a:	4c77      	ldr	r4, [pc, #476]	@ (81fb718 <HAL_GPIO_Init+0x218>)
        tmp |= ((pGPIO_Init->Mode & GPIO_MODE_OUTPUT_PP) << position);
 81fb53c:	684d      	ldr	r5, [r1, #4]
      if (GPIOx == LPGPIO1)
 81fb53e:	42a0      	cmp	r0, r4
      else if ((pGPIO_Init->Mode == GPIO_MODE_AF_PP) || (pGPIO_Init->Mode == GPIO_MODE_AF_OD))
 81fb540:	f025 0810 	bic.w	r8, r5, #16
      if (GPIOx == LPGPIO1)
 81fb544:	f040 808c 	bne.w	81fb660 <HAL_GPIO_Init+0x160>
        tmp &= ~(0x0FUL << (((pin_position) & 0x07U) * 4U));
 81fb548:	260f      	movs	r6, #15
        tmp = GPIOx->MODER;
 81fb54a:	6804      	ldr	r4, [r0, #0]
        tmp |= ((pGPIO_Init->Mode & GPIO_MODE_OUTPUT_PP) << position);
 81fb54c:	f005 0301 	and.w	r3, r5, #1
        tmp &= ~(LPGPIO_MODER_MOD0 << position);
 81fb550:	ea24 040c 	bic.w	r4, r4, ip
        tmp |= ((pGPIO_Init->Mode & GPIO_MODE_OUTPUT_PP) << position);
 81fb554:	4093      	lsls	r3, r2
 81fb556:	4323      	orrs	r3, r4
        pin_position = LPGPIO_Map[position].Pin_Pos;
 81fb558:	9c02      	ldr	r4, [sp, #8]
        GPIOx->MODER = tmp;
 81fb55a:	6003      	str	r3, [r0, #0]
        pin_position = LPGPIO_Map[position].Pin_Pos;
 81fb55c:	6864      	ldr	r4, [r4, #4]
        p_gpio = LPGPIO_Map[position].GPIO_PORT;
 81fb55e:	9b02      	ldr	r3, [sp, #8]
        tmp &= ~(0x0FUL << (((pin_position) & 0x07U) * 4U));
 81fb560:	f004 0c07 	and.w	ip, r4, #7
 81fb564:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
 81fb568:	fa06 fa0c 	lsl.w	sl, r6, ip
        tmp |= ((GPIO_AF11_LPGPIO1 & 0x0FUL) << (((pin_position) & 0x07U) * 4U));
 81fb56c:	260b      	movs	r6, #11
 81fb56e:	fa06 fc0c 	lsl.w	ip, r6, ip
        tmp |= ((GPIO_MODE_AF_PP & 0x0FUL) << (pin_position * 2U));
 81fb572:	2602      	movs	r6, #2
        p_gpio = LPGPIO_Map[position].GPIO_PORT;
 81fb574:	681b      	ldr	r3, [r3, #0]
        tmp = p_gpio->AFR[(pin_position) >> 3U];
 81fb576:	ea4f 09d4 	mov.w	r9, r4, lsr #3
 81fb57a:	eb03 0989 	add.w	r9, r3, r9, lsl #2
 81fb57e:	f8d9 b020 	ldr.w	fp, [r9, #32]
        tmp &= ~(0x0FUL << (((pin_position) & 0x07U) * 4U));
 81fb582:	ea2b 0a0a 	bic.w	sl, fp, sl
        tmp |= ((GPIO_AF11_LPGPIO1 & 0x0FUL) << (((pin_position) & 0x07U) * 4U));
 81fb586:	ea4c 0c0a 	orr.w	ip, ip, sl
        p_gpio->AFR[(pin_position) >> 3U] = tmp;
 81fb58a:	f8c9 c020 	str.w	ip, [r9, #32]
        tmp = p_gpio->MODER;
 81fb58e:	f8d3 9000 	ldr.w	r9, [r3]
        tmp &= ~(GPIO_MODER_MODE0 << (pin_position * 2U));
 81fb592:	ea4f 0c44 	mov.w	ip, r4, lsl #1
 81fb596:	fa0e fa0c 	lsl.w	sl, lr, ip
 81fb59a:	ea29 090a 	bic.w	r9, r9, sl
        tmp |= ((GPIO_MODE_AF_PP & 0x0FUL) << (pin_position * 2U));
 81fb59e:	fa06 fc0c 	lsl.w	ip, r6, ip
 81fb5a2:	ea4c 0c09 	orr.w	ip, ip, r9
        p_gpio->MODER = tmp;
 81fb5a6:	f8c3 c000 	str.w	ip, [r3]
      if ((pGPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (pGPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 81fb5aa:	f108 38ff 	add.w	r8, r8, #4294967295	@ 0xffffffff
 81fb5ae:	f1b8 0f01 	cmp.w	r8, #1
 81fb5b2:	f240 8082 	bls.w	81fb6ba <HAL_GPIO_Init+0x1ba>
      if (pGPIO_Init->Mode != GPIO_MODE_ANALOG)
 81fb5b6:	2d03      	cmp	r5, #3
 81fb5b8:	d04d      	beq.n	81fb656 <HAL_GPIO_Init+0x156>
        tmp = p_gpio->PUPDR;
 81fb5ba:	f8d3 800c 	ldr.w	r8, [r3, #12]
        tmp |= ((pGPIO_Init->Pull) << (pin_position * 2U));
 81fb5be:	688e      	ldr	r6, [r1, #8]
        tmp &= ~(GPIO_PUPDR_PUPD0 << (pin_position * 2U));
 81fb5c0:	0064      	lsls	r4, r4, #1
 81fb5c2:	fa0e fc04 	lsl.w	ip, lr, r4
 81fb5c6:	ea28 0c0c 	bic.w	ip, r8, ip
        tmp |= ((pGPIO_Init->Pull) << (pin_position * 2U));
 81fb5ca:	fa06 f404 	lsl.w	r4, r6, r4
 81fb5ce:	ea44 040c 	orr.w	r4, r4, ip
        p_gpio->PUPDR = tmp;
 81fb5d2:	60dc      	str	r4, [r3, #12]
      if ((pGPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 81fb5d4:	00ec      	lsls	r4, r5, #3
 81fb5d6:	d53e      	bpl.n	81fb656 <HAL_GPIO_Init+0x156>
        tmp &= ~((0x0FUL) << (8U * (position & 0x03U)));
 81fb5d8:	260f      	movs	r6, #15
 81fb5da:	f022 0c03 	bic.w	ip, r2, #3
 81fb5de:	f10c 4c8c 	add.w	ip, ip, #1174405120	@ 0x46000000
 81fb5e2:	f002 0403 	and.w	r4, r2, #3
 81fb5e6:	f50c 3c08 	add.w	ip, ip, #139264	@ 0x22000
 81fb5ea:	00e4      	lsls	r4, r4, #3
        tmp = EXTI->EXTICR[position >> 2U];
 81fb5ec:	f8dc 9060 	ldr.w	r9, [ip, #96]	@ 0x60
        tmp &= ~((0x0FUL) << (8U * (position & 0x03U)));
 81fb5f0:	fa06 f804 	lsl.w	r8, r6, r4
        tmp |= (GPIO_GET_INDEX(GPIOx) << (8U * (position & 0x03U)));
 81fb5f4:	9e03      	ldr	r6, [sp, #12]
        tmp &= ~((0x0FUL) << (8U * (position & 0x03U)));
 81fb5f6:	ea29 0808 	bic.w	r8, r9, r8
        tmp |= (GPIO_GET_INDEX(GPIOx) << (8U * (position & 0x03U)));
 81fb5fa:	fa06 f404 	lsl.w	r4, r6, r4
        tmp &= ~((uint32_t)iocurrent);
 81fb5fe:	9e01      	ldr	r6, [sp, #4]
        tmp |= (GPIO_GET_INDEX(GPIOx) << (8U * (position & 0x03U)));
 81fb600:	ea44 0408 	orr.w	r4, r4, r8
        EXTI->EXTICR[position >> 2U] = tmp;
 81fb604:	f8cc 4060 	str.w	r4, [ip, #96]	@ 0x60
        tmp &= ~((uint32_t)iocurrent);
 81fb608:	ea6f 0c06 	mvn.w	ip, r6
        if ((pGPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 81fb60c:	02ee      	lsls	r6, r5, #11
          tmp |= iocurrent;
 81fb60e:	bf48      	it	mi
 81fb610:	9e01      	ldrmi	r6, [sp, #4]
        tmp = EXTI->RTSR1;
 81fb612:	683c      	ldr	r4, [r7, #0]
          tmp |= iocurrent;
 81fb614:	bf4c      	ite	mi
 81fb616:	4334      	orrmi	r4, r6
        tmp &= ~((uint32_t)iocurrent);
 81fb618:	ea0c 0404 	andpl.w	r4, ip, r4
        EXTI->RTSR1 = tmp;
 81fb61c:	603c      	str	r4, [r7, #0]
        if ((pGPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 81fb61e:	02ae      	lsls	r6, r5, #10
        tmp = EXTI->FTSR1;
 81fb620:	687c      	ldr	r4, [r7, #4]
          tmp |= iocurrent;
 81fb622:	bf4a      	itet	mi
 81fb624:	9e01      	ldrmi	r6, [sp, #4]
        tmp &= ~((uint32_t)iocurrent);
 81fb626:	ea0c 0404 	andpl.w	r4, ip, r4
          tmp |= iocurrent;
 81fb62a:	4334      	orrmi	r4, r6
        EXTI->FTSR1 = tmp;
 81fb62c:	607c      	str	r4, [r7, #4]
        if ((pGPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 81fb62e:	03ae      	lsls	r6, r5, #14
        tmp = EXTI->EMR1;
 81fb630:	f8d7 4084 	ldr.w	r4, [r7, #132]	@ 0x84
          tmp |= iocurrent;
 81fb634:	bf4a      	itet	mi
 81fb636:	9e01      	ldrmi	r6, [sp, #4]
        tmp &= ~((uint32_t)iocurrent);
 81fb638:	ea0c 0404 	andpl.w	r4, ip, r4
          tmp |= iocurrent;
 81fb63c:	4334      	orrmi	r4, r6
        EXTI->EMR1 = tmp;
 81fb63e:	f8c7 4084 	str.w	r4, [r7, #132]	@ 0x84
        if ((pGPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 81fb642:	03ed      	lsls	r5, r5, #15
        tmp = EXTI->IMR1;
 81fb644:	f8d7 4080 	ldr.w	r4, [r7, #128]	@ 0x80
          tmp |= iocurrent;
 81fb648:	bf4a      	itet	mi
 81fb64a:	9d01      	ldrmi	r5, [sp, #4]
        tmp &= ~((uint32_t)iocurrent);
 81fb64c:	ea0c 0404 	andpl.w	r4, ip, r4
          tmp |= iocurrent;
 81fb650:	432c      	orrmi	r4, r5
        EXTI->IMR1 = tmp;
 81fb652:	f8c7 4080 	str.w	r4, [r7, #128]	@ 0x80
    position++;
 81fb656:	9c02      	ldr	r4, [sp, #8]
 81fb658:	3201      	adds	r2, #1
 81fb65a:	3408      	adds	r4, #8
 81fb65c:	9402      	str	r4, [sp, #8]
 81fb65e:	e75d      	b.n	81fb51c <HAL_GPIO_Init+0x1c>
      else if ((pGPIO_Init->Mode == GPIO_MODE_AF_PP) || (pGPIO_Init->Mode == GPIO_MODE_AF_OD))
 81fb660:	ea4f 0942 	mov.w	r9, r2, lsl #1
        tmp &= ~(GPIO_MODER_MODE0 << (pin_position * 2U));
 81fb664:	fa0e f409 	lsl.w	r4, lr, r9
        tmp |= ((pGPIO_Init->Mode & GPIO_MODE) << (pin_position * 2U));
 81fb668:	f005 0c03 	and.w	ip, r5, #3
      else if ((pGPIO_Init->Mode == GPIO_MODE_AF_PP) || (pGPIO_Init->Mode == GPIO_MODE_AF_OD))
 81fb66c:	f1b8 0f02 	cmp.w	r8, #2
        tmp &= ~(GPIO_MODER_MODE0 << (pin_position * 2U));
 81fb670:	ea6f 0404 	mvn.w	r4, r4
        tmp |= ((pGPIO_Init->Mode & GPIO_MODE) << (pin_position * 2U));
 81fb674:	fa0c fc09 	lsl.w	ip, ip, r9
      else if ((pGPIO_Init->Mode == GPIO_MODE_AF_PP) || (pGPIO_Init->Mode == GPIO_MODE_AF_OD))
 81fb678:	d13e      	bne.n	81fb6f8 <HAL_GPIO_Init+0x1f8>
        tmp &= ~(0x0FUL << ((position & 0x07U) * 4U));
 81fb67a:	260f      	movs	r6, #15
        tmp = GPIOx->AFR[position >> 3U];
 81fb67c:	ea4f 08d2 	mov.w	r8, r2, lsr #3
        tmp &= ~(0x0FUL << ((position & 0x07U) * 4U));
 81fb680:	f002 0907 	and.w	r9, r2, #7
 81fb684:	eb00 0888 	add.w	r8, r0, r8, lsl #2
 81fb688:	ea4f 0989 	mov.w	r9, r9, lsl #2
        tmp = GPIOx->AFR[position >> 3U];
 81fb68c:	f8d8 a020 	ldr.w	sl, [r8, #32]
        tmp &= ~(0x0FUL << ((position & 0x07U) * 4U));
 81fb690:	fa06 fb09 	lsl.w	fp, r6, r9
        tmp |= ((pGPIO_Init->Alternate & 0x0FUL) << ((position & 0x07U) * 4U));
 81fb694:	690e      	ldr	r6, [r1, #16]
        tmp &= ~(0x0FUL << ((position & 0x07U) * 4U));
 81fb696:	ea2a 0a0b 	bic.w	sl, sl, fp
        tmp |= ((pGPIO_Init->Alternate & 0x0FUL) << ((position & 0x07U) * 4U));
 81fb69a:	f006 0b0f 	and.w	fp, r6, #15
 81fb69e:	fa0b fb09 	lsl.w	fp, fp, r9
 81fb6a2:	ea4b 0b0a 	orr.w	fp, fp, sl
        GPIOx->AFR[position >> 3U] = tmp;
 81fb6a6:	f8c8 b020 	str.w	fp, [r8, #32]
        tmp = p_gpio->MODER;
 81fb6aa:	f8d3 8000 	ldr.w	r8, [r3]
        tmp &= ~(GPIO_MODER_MODE0 << (pin_position * 2U));
 81fb6ae:	ea04 0808 	and.w	r8, r4, r8
        tmp |= ((pGPIO_Init->Mode & GPIO_MODE) << (pin_position * 2U));
 81fb6b2:	ea48 040c 	orr.w	r4, r8, ip
        p_gpio->MODER = tmp;
 81fb6b6:	601c      	str	r4, [r3, #0]
    pin_position = position;
 81fb6b8:	4614      	mov	r4, r2
        tmp |= (pGPIO_Init->Speed << (pin_position * 2U));
 81fb6ba:	68ce      	ldr	r6, [r1, #12]
        tmp &= ~(GPIO_OSPEEDR_OSPEED0 << (pin_position * 2U));
 81fb6bc:	ea4f 0844 	mov.w	r8, r4, lsl #1
 81fb6c0:	fa0e f908 	lsl.w	r9, lr, r8
        tmp |= (pGPIO_Init->Speed << (pin_position * 2U));
 81fb6c4:	fa06 f808 	lsl.w	r8, r6, r8
        tmp &= ~(GPIO_OTYPER_OT0 << pin_position);
 81fb6c8:	2601      	movs	r6, #1
        tmp = p_gpio->OSPEEDR;
 81fb6ca:	f8d3 c008 	ldr.w	ip, [r3, #8]
        tmp &= ~(GPIO_OSPEEDR_OSPEED0 << (pin_position * 2U));
 81fb6ce:	ea2c 0c09 	bic.w	ip, ip, r9
        tmp |= (pGPIO_Init->Speed << (pin_position * 2U));
 81fb6d2:	ea48 080c 	orr.w	r8, r8, ip
        p_gpio->OSPEEDR = tmp;
 81fb6d6:	f8c3 8008 	str.w	r8, [r3, #8]
        tmp = p_gpio->OTYPER;
 81fb6da:	f8d3 8004 	ldr.w	r8, [r3, #4]
        tmp &= ~(GPIO_OTYPER_OT0 << pin_position);
 81fb6de:	fa06 fc04 	lsl.w	ip, r6, r4
 81fb6e2:	ea28 080c 	bic.w	r8, r8, ip
        tmp |= (((pGPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << pin_position);
 81fb6e6:	f3c5 1c00 	ubfx	ip, r5, #4, #1
 81fb6ea:	fa0c fc04 	lsl.w	ip, ip, r4
 81fb6ee:	ea4c 0c08 	orr.w	ip, ip, r8
        p_gpio->OTYPER = tmp;
 81fb6f2:	f8c3 c004 	str.w	ip, [r3, #4]
 81fb6f6:	e75e      	b.n	81fb5b6 <HAL_GPIO_Init+0xb6>
        tmp = p_gpio->MODER;
 81fb6f8:	f8d3 9000 	ldr.w	r9, [r3]
        tmp &= ~(GPIO_MODER_MODE0 << (pin_position * 2U));
 81fb6fc:	ea04 0409 	and.w	r4, r4, r9
        tmp |= ((pGPIO_Init->Mode & GPIO_MODE) << (pin_position * 2U));
 81fb700:	ea44 040c 	orr.w	r4, r4, ip
        p_gpio->MODER = tmp;
 81fb704:	601c      	str	r4, [r3, #0]
    pin_position = position;
 81fb706:	4614      	mov	r4, r2
 81fb708:	e74f      	b.n	81fb5aa <HAL_GPIO_Init+0xaa>
 81fb70a:	bf00      	nop
 81fb70c:	002f7f7f 	.word	0x002f7f7f
 81fb710:	081fe930 	.word	0x081fe930
 81fb714:	46022000 	.word	0x46022000
 81fb718:	46020000 	.word	0x46020000

081fb71c <HAL_RCC_GetSysClockFreq>:
  uint32_t sysclk_source;
  uint32_t pll_oscsource;
  float_t fracn1;
  float_t pllvco;

  sysclk_source = __HAL_RCC_GET_SYSCLK_SOURCE();
 81fb71c:	4a40      	ldr	r2, [pc, #256]	@ (81fb820 <HAL_RCC_GetSysClockFreq+0x104>)
{
 81fb71e:	b510      	push	{r4, lr}
  sysclk_source = __HAL_RCC_GET_SYSCLK_SOURCE();
 81fb720:	69d3      	ldr	r3, [r2, #28]
  pll_oscsource = __HAL_RCC_GET_PLL_OSCSOURCE();
 81fb722:	6a91      	ldr	r1, [r2, #40]	@ 0x28

  if ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_MSI) ||
 81fb724:	f013 030c 	ands.w	r3, r3, #12
 81fb728:	d005      	beq.n	81fb736 <HAL_RCC_GetSysClockFreq+0x1a>
 81fb72a:	2b0c      	cmp	r3, #12
 81fb72c:	d148      	bne.n	81fb7c0 <HAL_RCC_GetSysClockFreq+0xa4>
  pll_oscsource = __HAL_RCC_GET_PLL_OSCSOURCE();
 81fb72e:	f001 0103 	and.w	r1, r1, #3
      ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (pll_oscsource == RCC_PLLSOURCE_MSI)))
 81fb732:	2901      	cmp	r1, #1
 81fb734:	d144      	bne.n	81fb7c0 <HAL_RCC_GetSysClockFreq+0xa4>
  {
    /* MSI or PLL with MSI source used as system clock source */

    /* Get SYSCLK source */
    if (READ_BIT(RCC->ICSCR1, RCC_ICSCR1_MSIRGSEL) == 0U)
 81fb736:	6891      	ldr	r1, [r2, #8]
 81fb738:	0209      	lsls	r1, r1, #8
    {
      /* MSISRANGE from RCC_CSR applies */
      msirange = (RCC->CSR & RCC_CSR_MSISSRANGE) >> RCC_CSR_MSISSRANGE_Pos;
 81fb73a:	bf54      	ite	pl
 81fb73c:	f8d2 20f4 	ldrpl.w	r2, [r2, #244]	@ 0xf4
    }
    else
    {
      /* MSIRANGE from RCC_CR applies */
      msirange = (RCC->ICSCR1 & RCC_ICSCR1_MSISRANGE) >> RCC_ICSCR1_MSISRANGE_Pos;
 81fb740:	6892      	ldrmi	r2, [r2, #8]
    }
    /*MSI frequency range in HZ*/
    msirange = MSIRangeTable[msirange];
 81fb742:	4938      	ldr	r1, [pc, #224]	@ (81fb824 <HAL_RCC_GetSysClockFreq+0x108>)
      msirange = (RCC->CSR & RCC_CSR_MSISSRANGE) >> RCC_CSR_MSISSRANGE_Pos;
 81fb744:	bf54      	ite	pl
 81fb746:	f3c2 3203 	ubfxpl	r2, r2, #12, #4
      msirange = (RCC->ICSCR1 & RCC_ICSCR1_MSISRANGE) >> RCC_ICSCR1_MSISRANGE_Pos;
 81fb74a:	0f12      	lsrmi	r2, r2, #28
    msirange = MSIRangeTable[msirange];
 81fb74c:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]

    if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_MSI)
 81fb750:	2b00      	cmp	r3, #0
 81fb752:	d063      	beq.n	81fb81c <HAL_RCC_GetSysClockFreq+0x100>
  uint32_t sysclockfreq = 0U;
 81fb754:	2000      	movs	r0, #0
  else
  {
    /* Nothing to do */
  }

  if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 81fb756:	2b0c      	cmp	r3, #12
 81fb758:	d15e      	bne.n	81fb818 <HAL_RCC_GetSysClockFreq+0xfc>
  {
    /* PLL used as system clock  source
       PLL_VCO = (HSE_VALUE or HSI_VALUE or MSI_VALUE/ PLLM) * PLLN
       SYSCLK = PLL_VCO / PLLR
    */
    pllsource = (RCC->PLL1CFGR & RCC_PLL1CFGR_PLL1SRC);
 81fb75a:	4931      	ldr	r1, [pc, #196]	@ (81fb820 <HAL_RCC_GetSysClockFreq+0x104>)
 81fb75c:	eddf 5a32 	vldr	s11, [pc, #200]	@ 81fb828 <HAL_RCC_GetSysClockFreq+0x10c>
 81fb760:	6a88      	ldr	r0, [r1, #40]	@ 0x28
    pllm = ((RCC->PLL1CFGR & RCC_PLL1CFGR_PLL1M) >> RCC_PLL1CFGR_PLL1M_Pos) + 1U;
 81fb762:	6a8b      	ldr	r3, [r1, #40]	@ 0x28
    pllfracen = ((RCC->PLL1CFGR & RCC_PLL1CFGR_PLL1FRACEN) >> RCC_PLL1CFGR_PLL1FRACEN_Pos);
 81fb764:	6a8c      	ldr	r4, [r1, #40]	@ 0x28
    pllm = ((RCC->PLL1CFGR & RCC_PLL1CFGR_PLL1M) >> RCC_PLL1CFGR_PLL1M_Pos) + 1U;
 81fb766:	f3c3 2303 	ubfx	r3, r3, #8, #4
 81fb76a:	3301      	adds	r3, #1
 81fb76c:	ee07 3a90 	vmov	s15, r3
    fracn1 = (float_t)(uint32_t)(pllfracen * ((RCC->PLL1FRACR & RCC_PLL1FRACR_PLL1FRACN) >> \
 81fb770:	6b8b      	ldr	r3, [r1, #56]	@ 0x38
    pllfracen = ((RCC->PLL1CFGR & RCC_PLL1CFGR_PLL1FRACEN) >> RCC_PLL1CFGR_PLL1FRACEN_Pos);
 81fb772:	f3c4 1400 	ubfx	r4, r4, #4, #1
    fracn1 = (float_t)(uint32_t)(pllfracen * ((RCC->PLL1FRACR & RCC_PLL1FRACR_PLL1FRACN) >> \
 81fb776:	f3c3 03cc 	ubfx	r3, r3, #3, #13
 81fb77a:	4363      	muls	r3, r4
 81fb77c:	ee07 3a10 	vmov	s14, r3
    pllsource = (RCC->PLL1CFGR & RCC_PLL1CFGR_PLL1SRC);
 81fb780:	f000 0003 	and.w	r0, r0, #3
                                              RCC_PLL1FRACR_PLL1FRACN_Pos));

    if (pllm != 0U)
    {
      switch (pllsource)
 81fb784:	2802      	cmp	r0, #2
    fracn1 = (float_t)(uint32_t)(pllfracen * ((RCC->PLL1FRACR & RCC_PLL1FRACR_PLL1FRACN) >> \
 81fb786:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
      switch (pllsource)
 81fb78a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 81fb78e:	eeb7 6a00 	vmov.f32	s12, #112	@ 0x3f800000  1.0
 81fb792:	d021      	beq.n	81fb7d8 <HAL_RCC_GetSysClockFreq+0xbc>
 81fb794:	2803      	cmp	r0, #3
 81fb796:	d01f      	beq.n	81fb7d8 <HAL_RCC_GetSysClockFreq+0xbc>
                                                           (fracn1 / (float_t)0x2000) + (float_t)1U);
          break;

        case RCC_PLLSOURCE_MSI:  /* MSI used as PLL clock source */
        default:
          pllvco = ((float_t) msirange / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N) + \
 81fb798:	ee06 2a90 	vmov	s13, r2
 81fb79c:	eef8 6a66 	vcvt.f32.u32	s13, s13
 81fb7a0:	6b4b      	ldr	r3, [r1, #52]	@ 0x34
 81fb7a2:	ee86 5aa7 	vdiv.f32	s10, s13, s15
 81fb7a6:	f3c3 0308 	ubfx	r3, r3, #0, #9
 81fb7aa:	ee07 3a90 	vmov	s15, r3
 81fb7ae:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 81fb7b2:	eee7 7a25 	vfma.f32	s15, s14, s11
                                                           (fracn1 / (float_t)0x2000) + (float_t)1U);
 81fb7b6:	ee77 7a86 	vadd.f32	s15, s15, s12
          pllvco = ((float_t) msirange / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N) + \
 81fb7ba:	ee67 7a85 	vmul.f32	s15, s15, s10
          break;
 81fb7be:	e01c      	b.n	81fb7fa <HAL_RCC_GetSysClockFreq+0xde>
  else if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI)
 81fb7c0:	69d2      	ldr	r2, [r2, #28]
 81fb7c2:	f002 020c 	and.w	r2, r2, #12
 81fb7c6:	2a04      	cmp	r2, #4
 81fb7c8:	d004      	beq.n	81fb7d4 <HAL_RCC_GetSysClockFreq+0xb8>
  else if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSE)
 81fb7ca:	2b08      	cmp	r3, #8
 81fb7cc:	d025      	beq.n	81fb81a <HAL_RCC_GetSysClockFreq+0xfe>
  uint32_t sysclockfreq = 0U;
 81fb7ce:	2000      	movs	r0, #0
  uint32_t msirange = 0U;
 81fb7d0:	2200      	movs	r2, #0
 81fb7d2:	e7c0      	b.n	81fb756 <HAL_RCC_GetSysClockFreq+0x3a>
    sysclockfreq = HSI_VALUE;
 81fb7d4:	4815      	ldr	r0, [pc, #84]	@ (81fb82c <HAL_RCC_GetSysClockFreq+0x110>)
 81fb7d6:	e7fb      	b.n	81fb7d0 <HAL_RCC_GetSysClockFreq+0xb4>
          pllvco = ((float_t)HSE_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N) + \
 81fb7d8:	ed9f 5a15 	vldr	s10, [pc, #84]	@ 81fb830 <HAL_RCC_GetSysClockFreq+0x114>
 81fb7dc:	6b4b      	ldr	r3, [r1, #52]	@ 0x34
 81fb7de:	eec5 6a27 	vdiv.f32	s13, s10, s15
 81fb7e2:	f3c3 0308 	ubfx	r3, r3, #0, #9
 81fb7e6:	ee07 3a90 	vmov	s15, r3
 81fb7ea:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 81fb7ee:	eee7 7a25 	vfma.f32	s15, s14, s11
                                                           (fracn1 / (float_t)0x2000) + (float_t)1U);
 81fb7f2:	ee77 7a86 	vadd.f32	s15, s15, s12
          pllvco = ((float_t)HSE_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N) + \
 81fb7f6:	ee67 7aa6 	vmul.f32	s15, s15, s13
      }

      pllr = (((RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1R) >> RCC_PLL1DIVR_PLL1R_Pos) + 1U);
 81fb7fa:	4b09      	ldr	r3, [pc, #36]	@ (81fb820 <HAL_RCC_GetSysClockFreq+0x104>)
 81fb7fc:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 81fb7fe:	f3c3 6306 	ubfx	r3, r3, #24, #7
 81fb802:	3301      	adds	r3, #1
      sysclockfreq = (uint32_t)(float_t)((float_t)pllvco / (float_t)pllr);
 81fb804:	ee07 3a10 	vmov	s14, r3
 81fb808:	eef8 6ac7 	vcvt.f32.s32	s13, s14
 81fb80c:	ee87 7aa6 	vdiv.f32	s14, s15, s13
 81fb810:	eefc 7ac7 	vcvt.u32.f32	s15, s14
 81fb814:	ee17 0a90 	vmov	r0, s15
      sysclockfreq = 0;
    }
  }

  return sysclockfreq;
}
 81fb818:	bd10      	pop	{r4, pc}
    sysclockfreq = HSE_VALUE;
 81fb81a:	4a04      	ldr	r2, [pc, #16]	@ (81fb82c <HAL_RCC_GetSysClockFreq+0x110>)
  uint32_t msirange = 0U;
 81fb81c:	4610      	mov	r0, r2
 81fb81e:	e7fb      	b.n	81fb818 <HAL_RCC_GetSysClockFreq+0xfc>
 81fb820:	46020c00 	.word	0x46020c00
 81fb824:	081fe8d8 	.word	0x081fe8d8
 81fb828:	39000000 	.word	0x39000000
 81fb82c:	00f42400 	.word	0x00f42400
 81fb830:	4b742400 	.word	0x4b742400

081fb834 <HAL_RCC_GetHCLKFreq>:
  *
  * @note   The SystemCoreClock CMSIS variable is used to store System Clock Frequency.
  * @retval HCLK frequency in Hz
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
 81fb834:	b508      	push	{r3, lr}
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR2 & RCC_CFGR2_HPRE) >> RCC_CFGR2_HPRE_Pos];
 81fb836:	f7ff ff71 	bl	81fb71c <HAL_RCC_GetSysClockFreq>
 81fb83a:	4b05      	ldr	r3, [pc, #20]	@ (81fb850 <HAL_RCC_GetHCLKFreq+0x1c>)
 81fb83c:	4a05      	ldr	r2, [pc, #20]	@ (81fb854 <HAL_RCC_GetHCLKFreq+0x20>)
 81fb83e:	6a1b      	ldr	r3, [r3, #32]
 81fb840:	f003 030f 	and.w	r3, r3, #15
 81fb844:	5cd3      	ldrb	r3, [r2, r3]
 81fb846:	40d8      	lsrs	r0, r3
 81fb848:	4b03      	ldr	r3, [pc, #12]	@ (81fb858 <HAL_RCC_GetHCLKFreq+0x24>)
 81fb84a:	6018      	str	r0, [r3, #0]
  return SystemCoreClock;
}
 81fb84c:	bd08      	pop	{r3, pc}
 81fb84e:	bf00      	nop
 81fb850:	46020c00 	.word	0x46020c00
 81fb854:	081fe920 	.word	0x081fe920
 81fb858:	20000028 	.word	0x20000028

081fb85c <HAL_RCC_GetPCLK1Freq>:
  * @note   Each time PCLK1 changes, this function must be called to update the
  *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency in Hz
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
 81fb85c:	b508      	push	{r3, lr}
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR2 & RCC_CFGR2_PPRE1) >> RCC_CFGR2_PPRE1_Pos]);
 81fb85e:	f7ff ffe9 	bl	81fb834 <HAL_RCC_GetHCLKFreq>
 81fb862:	4b04      	ldr	r3, [pc, #16]	@ (81fb874 <HAL_RCC_GetPCLK1Freq+0x18>)
 81fb864:	4a04      	ldr	r2, [pc, #16]	@ (81fb878 <HAL_RCC_GetPCLK1Freq+0x1c>)
 81fb866:	6a1b      	ldr	r3, [r3, #32]
 81fb868:	f3c3 1302 	ubfx	r3, r3, #4, #3
 81fb86c:	5cd3      	ldrb	r3, [r2, r3]
}
 81fb86e:	40d8      	lsrs	r0, r3
 81fb870:	bd08      	pop	{r3, pc}
 81fb872:	bf00      	nop
 81fb874:	46020c00 	.word	0x46020c00
 81fb878:	081fe918 	.word	0x081fe918

081fb87c <HAL_RCC_GetPCLK2Freq>:
  * @note   Each time PCLK2 changes, this function must be called to update the
  *         right PCLK2 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK2 frequency in Hz
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
 81fb87c:	b508      	push	{r3, lr}
  /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR2 & RCC_CFGR2_PPRE2) >> RCC_CFGR2_PPRE2_Pos]);
 81fb87e:	f7ff ffd9 	bl	81fb834 <HAL_RCC_GetHCLKFreq>
 81fb882:	4b04      	ldr	r3, [pc, #16]	@ (81fb894 <HAL_RCC_GetPCLK2Freq+0x18>)
 81fb884:	4a04      	ldr	r2, [pc, #16]	@ (81fb898 <HAL_RCC_GetPCLK2Freq+0x1c>)
 81fb886:	6a1b      	ldr	r3, [r3, #32]
 81fb888:	f3c3 2302 	ubfx	r3, r3, #8, #3
 81fb88c:	5cd3      	ldrb	r3, [r2, r3]
}
 81fb88e:	40d8      	lsrs	r0, r3
 81fb890:	bd08      	pop	{r3, pc}
 81fb892:	bf00      	nop
 81fb894:	46020c00 	.word	0x46020c00
 81fb898:	081fe918 	.word	0x081fe918

081fb89c <HAL_RCC_GetPCLK3Freq>:
  * @note   Each time PCLK3 changes, this function must be called to update the
  *         right PCLK3 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK3 frequency in Hz
  */
uint32_t HAL_RCC_GetPCLK3Freq(void)
{
 81fb89c:	b508      	push	{r3, lr}
  /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR3 & RCC_CFGR3_PPRE3) >> RCC_CFGR3_PPRE3_Pos]);
 81fb89e:	f7ff ffc9 	bl	81fb834 <HAL_RCC_GetHCLKFreq>
 81fb8a2:	4b04      	ldr	r3, [pc, #16]	@ (81fb8b4 <HAL_RCC_GetPCLK3Freq+0x18>)
 81fb8a4:	4a04      	ldr	r2, [pc, #16]	@ (81fb8b8 <HAL_RCC_GetPCLK3Freq+0x1c>)
 81fb8a6:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 81fb8a8:	f3c3 1302 	ubfx	r3, r3, #4, #3
 81fb8ac:	5cd3      	ldrb	r3, [r2, r3]
}
 81fb8ae:	40d8      	lsrs	r0, r3
 81fb8b0:	bd08      	pop	{r3, pc}
 81fb8b2:	bf00      	nop
 81fb8b4:	46020c00 	.word	0x46020c00
 81fb8b8:	081fe918 	.word	0x081fe918

081fb8bc <HAL_RCCEx_GetPLL1ClockFreq>:
  uint32_t pll1n;
  uint32_t pll1fracen;
  float_t fracn1;
  float_t pll1vco;

  pll1n = (RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N);
 81fb8bc:	4a48      	ldr	r2, [pc, #288]	@ (81fb9e0 <HAL_RCCEx_GetPLL1ClockFreq+0x124>)
{
 81fb8be:	b510      	push	{r4, lr}
  pll1n = (RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N);
 81fb8c0:	6b53      	ldr	r3, [r2, #52]	@ 0x34
  pll1source = (RCC->PLL1CFGR & RCC_PLL1CFGR_PLL1SRC);
 81fb8c2:	6a91      	ldr	r1, [r2, #40]	@ 0x28
  pll1n = (RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N);
 81fb8c4:	f3c3 0308 	ubfx	r3, r3, #0, #9
 81fb8c8:	ee07 3a90 	vmov	s15, r3
  pll1m = ((RCC->PLL1CFGR & RCC_PLL1CFGR_PLL1M) >> RCC_PLL1CFGR_PLL1M_Pos) + 1U;
 81fb8cc:	6a93      	ldr	r3, [r2, #40]	@ 0x28
  pll1fracen = ((RCC->PLL1CFGR & RCC_PLL1CFGR_PLL1FRACEN) >> RCC_PLL1CFGR_PLL1FRACEN_Pos);
 81fb8ce:	6a94      	ldr	r4, [r2, #40]	@ 0x28
  pll1m = ((RCC->PLL1CFGR & RCC_PLL1CFGR_PLL1M) >> RCC_PLL1CFGR_PLL1M_Pos) + 1U;
 81fb8d0:	f3c3 2303 	ubfx	r3, r3, #8, #4
 81fb8d4:	3301      	adds	r3, #1
 81fb8d6:	ee06 3a90 	vmov	s13, r3
  fracn1 = (float_t)(uint32_t)(pll1fracen * ((RCC->PLL1FRACR & RCC_PLL1FRACR_PLL1FRACN) >> \
 81fb8da:	6b93      	ldr	r3, [r2, #56]	@ 0x38
  pll1fracen = ((RCC->PLL1CFGR & RCC_PLL1CFGR_PLL1FRACEN) >> RCC_PLL1CFGR_PLL1FRACEN_Pos);
 81fb8dc:	f3c4 1400 	ubfx	r4, r4, #4, #1
  fracn1 = (float_t)(uint32_t)(pll1fracen * ((RCC->PLL1FRACR & RCC_PLL1FRACR_PLL1FRACN) >> \
 81fb8e0:	f3c3 03cc 	ubfx	r3, r3, #3, #13
 81fb8e4:	4363      	muls	r3, r4
 81fb8e6:	ee07 3a10 	vmov	s14, r3
  pll1source = (RCC->PLL1CFGR & RCC_PLL1CFGR_PLL1SRC);
 81fb8ea:	f001 0103 	and.w	r1, r1, #3
                                             RCC_PLL1FRACR_PLL1FRACN_Pos));

  if (pll1m != 0U)
  {
    switch (pll1source)
 81fb8ee:	2902      	cmp	r1, #2
  fracn1 = (float_t)(uint32_t)(pll1fracen * ((RCC->PLL1FRACR & RCC_PLL1FRACR_PLL1FRACN) >> \
 81fb8f0:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
    switch (pll1source)
 81fb8f4:	eef8 6ae6 	vcvt.f32.s32	s13, s13
 81fb8f8:	eddf 5a3a 	vldr	s11, [pc, #232]	@ 81fb9e4 <HAL_RCCEx_GetPLL1ClockFreq+0x128>
 81fb8fc:	eeb7 6a00 	vmov.f32	s12, #112	@ 0x3f800000  1.0
 81fb900:	d05b      	beq.n	81fb9ba <HAL_RCCEx_GetPLL1ClockFreq+0xfe>
 81fb902:	2903      	cmp	r1, #3
 81fb904:	d059      	beq.n	81fb9ba <HAL_RCCEx_GetPLL1ClockFreq+0xfe>
      case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
        pll1vco = ((float_t)HSE_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N) + \
                                                           (fracn1 / (float_t)0x2000) + (float_t)1);
        break;
      default:
        pll1vco = ((float_t)MSIRangeTable[(__HAL_RCC_GET_MSI_RANGE() >> RCC_ICSCR1_MSISRANGE_Pos)] / (float_t)pll1m) * \
 81fb906:	6893      	ldr	r3, [r2, #8]
 81fb908:	4937      	ldr	r1, [pc, #220]	@ (81fb9e8 <HAL_RCCEx_GetPLL1ClockFreq+0x12c>)
 81fb90a:	021b      	lsls	r3, r3, #8
 81fb90c:	bf4b      	itete	mi
 81fb90e:	6893      	ldrmi	r3, [r2, #8]
 81fb910:	f8d2 30f4 	ldrpl.w	r3, [r2, #244]	@ 0xf4
 81fb914:	0f1b      	lsrmi	r3, r3, #28
 81fb916:	f3c3 3303 	ubfxpl	r3, r3, #12, #4
 81fb91a:	eb01 0383 	add.w	r3, r1, r3, lsl #2
 81fb91e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 81fb922:	ed93 5a00 	vldr	s10, [r3]
                  ((float_t)pll1n + (fracn1 / (float_t)0x2000) + (float_t)1);
 81fb926:	eee7 7a25 	vfma.f32	s15, s14, s11
        pll1vco = ((float_t)MSIRangeTable[(__HAL_RCC_GET_MSI_RANGE() >> RCC_ICSCR1_MSISRANGE_Pos)] / (float_t)pll1m) * \
 81fb92a:	eeb8 5a45 	vcvt.f32.u32	s10, s10
                  ((float_t)pll1n + (fracn1 / (float_t)0x2000) + (float_t)1);
 81fb92e:	ee77 7a86 	vadd.f32	s15, s15, s12
        pll1vco = ((float_t)MSIRangeTable[(__HAL_RCC_GET_MSI_RANGE() >> RCC_ICSCR1_MSISRANGE_Pos)] / (float_t)pll1m) * \
 81fb932:	eec5 4a26 	vdiv.f32	s9, s10, s13
 81fb936:	ee67 7aa4 	vmul.f32	s15, s15, s9
        break;
    }

    if (__HAL_RCC_GET_PLLCLKOUT_CONFIG(RCC_PLL1_DIVP) != 0U)
 81fb93a:	4a29      	ldr	r2, [pc, #164]	@ (81fb9e0 <HAL_RCCEx_GetPLL1ClockFreq+0x124>)
 81fb93c:	6a93      	ldr	r3, [r2, #40]	@ 0x28
 81fb93e:	f413 3380 	ands.w	r3, r3, #65536	@ 0x10000
 81fb942:	d00e      	beq.n	81fb962 <HAL_RCCEx_GetPLL1ClockFreq+0xa6>
    {
      PLL1_Clocks->PLL1_P_Frequency = (uint32_t)(float_t)(pll1vco / ((float_t)(uint32_t)((RCC->PLL1DIVR & \
 81fb944:	6b53      	ldr	r3, [r2, #52]	@ 0x34
 81fb946:	f3c3 2346 	ubfx	r3, r3, #9, #7
 81fb94a:	ee06 3a90 	vmov	s13, r3
 81fb94e:	eef8 6ae6 	vcvt.f32.s32	s13, s13
                                                                     RCC_PLL1DIVR_PLL1P) >> RCC_PLL1DIVR_PLL1P_Pos) + \
 81fb952:	ee76 6a86 	vadd.f32	s13, s13, s12
      PLL1_Clocks->PLL1_P_Frequency = (uint32_t)(float_t)(pll1vco / ((float_t)(uint32_t)((RCC->PLL1DIVR & \
 81fb956:	ee87 7aa6 	vdiv.f32	s14, s15, s13
 81fb95a:	eebc 7ac7 	vcvt.u32.f32	s14, s14
 81fb95e:	ee17 3a10 	vmov	r3, s14
    else
    {
      PLL1_Clocks->PLL1_P_Frequency = 0U;
    }

    if (__HAL_RCC_GET_PLLCLKOUT_CONFIG(RCC_PLL1_DIVQ) != 0U)
 81fb962:	4a1f      	ldr	r2, [pc, #124]	@ (81fb9e0 <HAL_RCCEx_GetPLL1ClockFreq+0x124>)
 81fb964:	6003      	str	r3, [r0, #0]
 81fb966:	6a93      	ldr	r3, [r2, #40]	@ 0x28
 81fb968:	f413 3300 	ands.w	r3, r3, #131072	@ 0x20000
 81fb96c:	d00e      	beq.n	81fb98c <HAL_RCCEx_GetPLL1ClockFreq+0xd0>
    {
      PLL1_Clocks->PLL1_Q_Frequency = (uint32_t)(float_t)(pll1vco / ((float_t)(uint32_t)((RCC->PLL1DIVR & \
 81fb96e:	6b53      	ldr	r3, [r2, #52]	@ 0x34
 81fb970:	f3c3 4306 	ubfx	r3, r3, #16, #7
 81fb974:	ee06 3a90 	vmov	s13, r3
 81fb978:	eef8 6ae6 	vcvt.f32.s32	s13, s13
                                                                     RCC_PLL1DIVR_PLL1Q) >> RCC_PLL1DIVR_PLL1Q_Pos) + \
 81fb97c:	ee76 6a86 	vadd.f32	s13, s13, s12
      PLL1_Clocks->PLL1_Q_Frequency = (uint32_t)(float_t)(pll1vco / ((float_t)(uint32_t)((RCC->PLL1DIVR & \
 81fb980:	ee87 7aa6 	vdiv.f32	s14, s15, s13
 81fb984:	eebc 7ac7 	vcvt.u32.f32	s14, s14
 81fb988:	ee17 3a10 	vmov	r3, s14
    else
    {
      PLL1_Clocks->PLL1_Q_Frequency = 0U;
    }

    if (__HAL_RCC_GET_PLLCLKOUT_CONFIG(RCC_PLL1_DIVR) != 0U)
 81fb98c:	4a14      	ldr	r2, [pc, #80]	@ (81fb9e0 <HAL_RCCEx_GetPLL1ClockFreq+0x124>)
 81fb98e:	6043      	str	r3, [r0, #4]
 81fb990:	6a93      	ldr	r3, [r2, #40]	@ 0x28
 81fb992:	f413 2380 	ands.w	r3, r3, #262144	@ 0x40000
 81fb996:	d00e      	beq.n	81fb9b6 <HAL_RCCEx_GetPLL1ClockFreq+0xfa>
    {
      PLL1_Clocks->PLL1_R_Frequency = (uint32_t)(float_t)(pll1vco / ((float_t)(uint32_t)((RCC->PLL1DIVR & \
 81fb998:	6b53      	ldr	r3, [r2, #52]	@ 0x34
 81fb99a:	f3c3 6306 	ubfx	r3, r3, #24, #7
 81fb99e:	ee06 3a90 	vmov	s13, r3
 81fb9a2:	eef8 6ae6 	vcvt.f32.s32	s13, s13
                                                                     RCC_PLL1DIVR_PLL1R) >> RCC_PLL1DIVR_PLL1R_Pos) + \
 81fb9a6:	ee76 6a86 	vadd.f32	s13, s13, s12
      PLL1_Clocks->PLL1_R_Frequency = (uint32_t)(float_t)(pll1vco / ((float_t)(uint32_t)((RCC->PLL1DIVR & \
 81fb9aa:	ee87 7aa6 	vdiv.f32	s14, s15, s13
 81fb9ae:	eefc 7ac7 	vcvt.u32.f32	s15, s14
 81fb9b2:	ee17 3a90 	vmov	r3, s15
 81fb9b6:	6083      	str	r3, [r0, #8]
    PLL1_Clocks->PLL1_P_Frequency = 0U;
    PLL1_Clocks->PLL1_Q_Frequency = 0U;
    PLL1_Clocks->PLL1_R_Frequency = 0U;
  }

}
 81fb9b8:	bd10      	pop	{r4, pc}
        pll1vco = ((float_t)HSE_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N) + \
 81fb9ba:	eddf 7a0c 	vldr	s15, [pc, #48]	@ 81fb9ec <HAL_RCCEx_GetPLL1ClockFreq+0x130>
 81fb9be:	6b53      	ldr	r3, [r2, #52]	@ 0x34
 81fb9c0:	ee87 5aa6 	vdiv.f32	s10, s15, s13
 81fb9c4:	f3c3 0308 	ubfx	r3, r3, #0, #9
 81fb9c8:	ee07 3a90 	vmov	s15, r3
 81fb9cc:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 81fb9d0:	eee7 7a25 	vfma.f32	s15, s14, s11
                                                           (fracn1 / (float_t)0x2000) + (float_t)1);
 81fb9d4:	ee77 7a86 	vadd.f32	s15, s15, s12
        pll1vco = ((float_t)HSE_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_PLL1N) + \
 81fb9d8:	ee67 7a85 	vmul.f32	s15, s15, s10
        break;
 81fb9dc:	e7ad      	b.n	81fb93a <HAL_RCCEx_GetPLL1ClockFreq+0x7e>
 81fb9de:	bf00      	nop
 81fb9e0:	46020c00 	.word	0x46020c00
 81fb9e4:	39000000 	.word	0x39000000
 81fb9e8:	081fe8d8 	.word	0x081fe8d8
 81fb9ec:	4b742400 	.word	0x4b742400

081fb9f0 <HAL_RCCEx_GetPLL2ClockFreq>:
  float_t fracn2;
  float_t pll2vco;

  /* PLL_VCO = (HSE_VALUE or HSI_VALUE or CSI_VALUE/ PLL2M) * PLL2N
     PLL2xCLK = PLL2_VCO / PLL2x */
  pll2n = (RCC->PLL2DIVR & RCC_PLL2DIVR_PLL2N);
 81fb9f0:	4a48      	ldr	r2, [pc, #288]	@ (81fbb14 <HAL_RCCEx_GetPLL2ClockFreq+0x124>)
{
 81fb9f2:	b510      	push	{r4, lr}
  pll2n = (RCC->PLL2DIVR & RCC_PLL2DIVR_PLL2N);
 81fb9f4:	6bd3      	ldr	r3, [r2, #60]	@ 0x3c
  pll2source = (RCC->PLL2CFGR & RCC_PLL2CFGR_PLL2SRC);
 81fb9f6:	6ad1      	ldr	r1, [r2, #44]	@ 0x2c
  pll2n = (RCC->PLL2DIVR & RCC_PLL2DIVR_PLL2N);
 81fb9f8:	f3c3 0308 	ubfx	r3, r3, #0, #9
 81fb9fc:	ee07 3a90 	vmov	s15, r3
  pll2m = ((RCC->PLL2CFGR & RCC_PLL2CFGR_PLL2M) >> RCC_PLL2CFGR_PLL2M_Pos) + 1U;
 81fba00:	6ad3      	ldr	r3, [r2, #44]	@ 0x2c
  pll2fracen = ((RCC->PLL2CFGR & RCC_PLL2CFGR_PLL2FRACEN) >> RCC_PLL2CFGR_PLL2FRACEN_Pos);
 81fba02:	6ad4      	ldr	r4, [r2, #44]	@ 0x2c
  pll2m = ((RCC->PLL2CFGR & RCC_PLL2CFGR_PLL2M) >> RCC_PLL2CFGR_PLL2M_Pos) + 1U;
 81fba04:	f3c3 2303 	ubfx	r3, r3, #8, #4
 81fba08:	3301      	adds	r3, #1
 81fba0a:	ee06 3a90 	vmov	s13, r3
  fracn2 = (float_t)(uint32_t)(pll2fracen * ((RCC->PLL2FRACR & RCC_PLL2FRACR_PLL2FRACN) >> \
 81fba0e:	6c13      	ldr	r3, [r2, #64]	@ 0x40
  pll2fracen = ((RCC->PLL2CFGR & RCC_PLL2CFGR_PLL2FRACEN) >> RCC_PLL2CFGR_PLL2FRACEN_Pos);
 81fba10:	f3c4 1400 	ubfx	r4, r4, #4, #1
  fracn2 = (float_t)(uint32_t)(pll2fracen * ((RCC->PLL2FRACR & RCC_PLL2FRACR_PLL2FRACN) >> \
 81fba14:	f3c3 03cc 	ubfx	r3, r3, #3, #13
 81fba18:	4363      	muls	r3, r4
 81fba1a:	ee07 3a10 	vmov	s14, r3
  pll2source = (RCC->PLL2CFGR & RCC_PLL2CFGR_PLL2SRC);
 81fba1e:	f001 0103 	and.w	r1, r1, #3
                                             RCC_PLL2FRACR_PLL2FRACN_Pos));

  if (pll2m != 0U)
  {
    switch (pll2source)
 81fba22:	2902      	cmp	r1, #2
  fracn2 = (float_t)(uint32_t)(pll2fracen * ((RCC->PLL2FRACR & RCC_PLL2FRACR_PLL2FRACN) >> \
 81fba24:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
    switch (pll2source)
 81fba28:	eef8 6ae6 	vcvt.f32.s32	s13, s13
 81fba2c:	eddf 5a3a 	vldr	s11, [pc, #232]	@ 81fbb18 <HAL_RCCEx_GetPLL2ClockFreq+0x128>
 81fba30:	eeb7 6a00 	vmov.f32	s12, #112	@ 0x3f800000  1.0
 81fba34:	d05b      	beq.n	81fbaee <HAL_RCCEx_GetPLL2ClockFreq+0xfe>
 81fba36:	2903      	cmp	r1, #3
 81fba38:	d059      	beq.n	81fbaee <HAL_RCCEx_GetPLL2ClockFreq+0xfe>
        pll2vco = ((float_t)HSE_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_PLL2N) + \
                                                           (fracn2 / (float_t)0x2000) + (float_t)1);
        break;

      default:
        pll2vco = ((float_t)MSIRangeTable[(__HAL_RCC_GET_MSI_RANGE() >> RCC_ICSCR1_MSISRANGE_Pos)] / (float_t) pll2m) \
 81fba3a:	6893      	ldr	r3, [r2, #8]
 81fba3c:	4937      	ldr	r1, [pc, #220]	@ (81fbb1c <HAL_RCCEx_GetPLL2ClockFreq+0x12c>)
 81fba3e:	021b      	lsls	r3, r3, #8
 81fba40:	bf4b      	itete	mi
 81fba42:	6893      	ldrmi	r3, [r2, #8]
 81fba44:	f8d2 30f4 	ldrpl.w	r3, [r2, #244]	@ 0xf4
 81fba48:	0f1b      	lsrmi	r3, r3, #28
 81fba4a:	f3c3 3303 	ubfxpl	r3, r3, #12, #4
 81fba4e:	eb01 0383 	add.w	r3, r1, r3, lsl #2
 81fba52:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 81fba56:	ed93 5a00 	vldr	s10, [r3]
                  * ((float_t)pll2n + (fracn2 / (float_t)0x2000) + (float_t)1);
 81fba5a:	eee7 7a25 	vfma.f32	s15, s14, s11
        pll2vco = ((float_t)MSIRangeTable[(__HAL_RCC_GET_MSI_RANGE() >> RCC_ICSCR1_MSISRANGE_Pos)] / (float_t) pll2m) \
 81fba5e:	eeb8 5a45 	vcvt.f32.u32	s10, s10
                  * ((float_t)pll2n + (fracn2 / (float_t)0x2000) + (float_t)1);
 81fba62:	ee77 7a86 	vadd.f32	s15, s15, s12
        pll2vco = ((float_t)MSIRangeTable[(__HAL_RCC_GET_MSI_RANGE() >> RCC_ICSCR1_MSISRANGE_Pos)] / (float_t) pll2m) \
 81fba66:	eec5 4a26 	vdiv.f32	s9, s10, s13
 81fba6a:	ee67 7aa4 	vmul.f32	s15, s15, s9
        break;
    }
    if (__HAL_RCC_GET_PLL2CLKOUT_CONFIG(RCC_PLL2_DIVP) != 0U)
 81fba6e:	4a29      	ldr	r2, [pc, #164]	@ (81fbb14 <HAL_RCCEx_GetPLL2ClockFreq+0x124>)
 81fba70:	6ad3      	ldr	r3, [r2, #44]	@ 0x2c
 81fba72:	f413 3380 	ands.w	r3, r3, #65536	@ 0x10000
 81fba76:	d00e      	beq.n	81fba96 <HAL_RCCEx_GetPLL2ClockFreq+0xa6>
    {
      PLL2_Clocks->PLL2_P_Frequency = (uint32_t)(float_t)(pll2vco / ((float_t)(uint32_t)((RCC->PLL2DIVR & \
 81fba78:	6bd3      	ldr	r3, [r2, #60]	@ 0x3c
 81fba7a:	f3c3 2346 	ubfx	r3, r3, #9, #7
 81fba7e:	ee06 3a90 	vmov	s13, r3
 81fba82:	eef8 6ae6 	vcvt.f32.s32	s13, s13
                                                                     RCC_PLL2DIVR_PLL2P) >> RCC_PLL2DIVR_PLL2P_Pos) + \
 81fba86:	ee76 6a86 	vadd.f32	s13, s13, s12
      PLL2_Clocks->PLL2_P_Frequency = (uint32_t)(float_t)(pll2vco / ((float_t)(uint32_t)((RCC->PLL2DIVR & \
 81fba8a:	ee87 7aa6 	vdiv.f32	s14, s15, s13
 81fba8e:	eebc 7ac7 	vcvt.u32.f32	s14, s14
 81fba92:	ee17 3a10 	vmov	r3, s14
    }
    else
    {
      PLL2_Clocks->PLL2_P_Frequency = 0U;
    }
    if (__HAL_RCC_GET_PLL2CLKOUT_CONFIG(RCC_PLL2_DIVQ) != 0U)
 81fba96:	4a1f      	ldr	r2, [pc, #124]	@ (81fbb14 <HAL_RCCEx_GetPLL2ClockFreq+0x124>)
 81fba98:	6003      	str	r3, [r0, #0]
 81fba9a:	6ad3      	ldr	r3, [r2, #44]	@ 0x2c
 81fba9c:	f413 3300 	ands.w	r3, r3, #131072	@ 0x20000
 81fbaa0:	d00e      	beq.n	81fbac0 <HAL_RCCEx_GetPLL2ClockFreq+0xd0>
    {
      PLL2_Clocks->PLL2_Q_Frequency = (uint32_t)(float_t)(pll2vco / ((float_t)(uint32_t)((RCC->PLL2DIVR & \
 81fbaa2:	6bd3      	ldr	r3, [r2, #60]	@ 0x3c
 81fbaa4:	f3c3 4306 	ubfx	r3, r3, #16, #7
 81fbaa8:	ee06 3a90 	vmov	s13, r3
 81fbaac:	eef8 6ae6 	vcvt.f32.s32	s13, s13
                                                                     RCC_PLL2DIVR_PLL2Q) >> RCC_PLL2DIVR_PLL2Q_Pos) + \
 81fbab0:	ee76 6a86 	vadd.f32	s13, s13, s12
      PLL2_Clocks->PLL2_Q_Frequency = (uint32_t)(float_t)(pll2vco / ((float_t)(uint32_t)((RCC->PLL2DIVR & \
 81fbab4:	ee87 7aa6 	vdiv.f32	s14, s15, s13
 81fbab8:	eebc 7ac7 	vcvt.u32.f32	s14, s14
 81fbabc:	ee17 3a10 	vmov	r3, s14
    }
    else
    {
      PLL2_Clocks->PLL2_Q_Frequency = 0U;
    }
    if (__HAL_RCC_GET_PLL2CLKOUT_CONFIG(RCC_PLL2_DIVR) != 0U)
 81fbac0:	4a14      	ldr	r2, [pc, #80]	@ (81fbb14 <HAL_RCCEx_GetPLL2ClockFreq+0x124>)
 81fbac2:	6043      	str	r3, [r0, #4]
 81fbac4:	6ad3      	ldr	r3, [r2, #44]	@ 0x2c
 81fbac6:	f413 2380 	ands.w	r3, r3, #262144	@ 0x40000
 81fbaca:	d00e      	beq.n	81fbaea <HAL_RCCEx_GetPLL2ClockFreq+0xfa>
    {
      PLL2_Clocks->PLL2_R_Frequency = (uint32_t)(float_t)(pll2vco / ((float_t)(uint32_t)((RCC->PLL2DIVR & \
 81fbacc:	6bd3      	ldr	r3, [r2, #60]	@ 0x3c
 81fbace:	f3c3 6306 	ubfx	r3, r3, #24, #7
 81fbad2:	ee06 3a90 	vmov	s13, r3
 81fbad6:	eef8 6ae6 	vcvt.f32.s32	s13, s13
                                                                     RCC_PLL2DIVR_PLL2R) >> RCC_PLL2DIVR_PLL2R_Pos) + \
 81fbada:	ee76 6a86 	vadd.f32	s13, s13, s12
      PLL2_Clocks->PLL2_R_Frequency = (uint32_t)(float_t)(pll2vco / ((float_t)(uint32_t)((RCC->PLL2DIVR & \
 81fbade:	ee87 7aa6 	vdiv.f32	s14, s15, s13
 81fbae2:	eefc 7ac7 	vcvt.u32.f32	s15, s14
 81fbae6:	ee17 3a90 	vmov	r3, s15
 81fbaea:	6083      	str	r3, [r0, #8]
  {
    PLL2_Clocks->PLL2_P_Frequency = 0U;
    PLL2_Clocks->PLL2_Q_Frequency = 0U;
    PLL2_Clocks->PLL2_R_Frequency = 0U;
  }
}
 81fbaec:	bd10      	pop	{r4, pc}
        pll2vco = ((float_t)HSE_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_PLL2N) + \
 81fbaee:	eddf 7a0c 	vldr	s15, [pc, #48]	@ 81fbb20 <HAL_RCCEx_GetPLL2ClockFreq+0x130>
 81fbaf2:	6bd3      	ldr	r3, [r2, #60]	@ 0x3c
 81fbaf4:	ee87 5aa6 	vdiv.f32	s10, s15, s13
 81fbaf8:	f3c3 0308 	ubfx	r3, r3, #0, #9
 81fbafc:	ee07 3a90 	vmov	s15, r3
 81fbb00:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 81fbb04:	eee7 7a25 	vfma.f32	s15, s14, s11
                                                           (fracn2 / (float_t)0x2000) + (float_t)1);
 81fbb08:	ee77 7a86 	vadd.f32	s15, s15, s12
        pll2vco = ((float_t)HSE_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_PLL2N) + \
 81fbb0c:	ee67 7a85 	vmul.f32	s15, s15, s10
        break;
 81fbb10:	e7ad      	b.n	81fba6e <HAL_RCCEx_GetPLL2ClockFreq+0x7e>
 81fbb12:	bf00      	nop
 81fbb14:	46020c00 	.word	0x46020c00
 81fbb18:	39000000 	.word	0x39000000
 81fbb1c:	081fe8d8 	.word	0x081fe8d8
 81fbb20:	4b742400 	.word	0x4b742400

081fbb24 <HAL_RCCEx_GetPLL3ClockFreq>:

  /* PLL3_VCO = (HSE_VALUE or HSI_VALUE or CSI_VALUE/ PLL3M) * PLL3N
  PLL3xCLK = PLL3_VCO / PLLxR
  */

  pll3n = (RCC->PLL3DIVR & RCC_PLL3DIVR_PLL3N);
 81fbb24:	4a48      	ldr	r2, [pc, #288]	@ (81fbc48 <HAL_RCCEx_GetPLL3ClockFreq+0x124>)
{
 81fbb26:	b510      	push	{r4, lr}
  pll3n = (RCC->PLL3DIVR & RCC_PLL3DIVR_PLL3N);
 81fbb28:	6c53      	ldr	r3, [r2, #68]	@ 0x44
  pll3source = (RCC->PLL3CFGR & RCC_PLL3CFGR_PLL3SRC);
 81fbb2a:	6b11      	ldr	r1, [r2, #48]	@ 0x30
  pll3n = (RCC->PLL3DIVR & RCC_PLL3DIVR_PLL3N);
 81fbb2c:	f3c3 0308 	ubfx	r3, r3, #0, #9
 81fbb30:	ee07 3a90 	vmov	s15, r3
  pll3m = ((RCC->PLL3CFGR & RCC_PLL3CFGR_PLL3M) >> RCC_PLL3CFGR_PLL3M_Pos) + 1U;
 81fbb34:	6b13      	ldr	r3, [r2, #48]	@ 0x30
  pll3fracen = ((RCC->PLL3CFGR & RCC_PLL3CFGR_PLL3FRACEN) >> RCC_PLL3CFGR_PLL3FRACEN_Pos);
 81fbb36:	6b14      	ldr	r4, [r2, #48]	@ 0x30
  pll3m = ((RCC->PLL3CFGR & RCC_PLL3CFGR_PLL3M) >> RCC_PLL3CFGR_PLL3M_Pos) + 1U;
 81fbb38:	f3c3 2303 	ubfx	r3, r3, #8, #4
 81fbb3c:	3301      	adds	r3, #1
 81fbb3e:	ee06 3a90 	vmov	s13, r3
  fracn3 = (float_t)(uint32_t)(pll3fracen * ((RCC->PLL3FRACR & RCC_PLL3FRACR_PLL3FRACN) >> \
 81fbb42:	6c93      	ldr	r3, [r2, #72]	@ 0x48
  pll3fracen = ((RCC->PLL3CFGR & RCC_PLL3CFGR_PLL3FRACEN) >> RCC_PLL3CFGR_PLL3FRACEN_Pos);
 81fbb44:	f3c4 1400 	ubfx	r4, r4, #4, #1
  fracn3 = (float_t)(uint32_t)(pll3fracen * ((RCC->PLL3FRACR & RCC_PLL3FRACR_PLL3FRACN) >> \
 81fbb48:	f3c3 03cc 	ubfx	r3, r3, #3, #13
 81fbb4c:	4363      	muls	r3, r4
 81fbb4e:	ee07 3a10 	vmov	s14, r3
  pll3source = (RCC->PLL3CFGR & RCC_PLL3CFGR_PLL3SRC);
 81fbb52:	f001 0103 	and.w	r1, r1, #3
                                             RCC_PLL3FRACR_PLL3FRACN_Pos));

  if (pll3m != 0U)
  {
    switch (pll3source)
 81fbb56:	2902      	cmp	r1, #2
  fracn3 = (float_t)(uint32_t)(pll3fracen * ((RCC->PLL3FRACR & RCC_PLL3FRACR_PLL3FRACN) >> \
 81fbb58:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
    switch (pll3source)
 81fbb5c:	eef8 6ae6 	vcvt.f32.s32	s13, s13
 81fbb60:	eddf 5a3a 	vldr	s11, [pc, #232]	@ 81fbc4c <HAL_RCCEx_GetPLL3ClockFreq+0x128>
 81fbb64:	eeb7 6a00 	vmov.f32	s12, #112	@ 0x3f800000  1.0
 81fbb68:	d05b      	beq.n	81fbc22 <HAL_RCCEx_GetPLL3ClockFreq+0xfe>
 81fbb6a:	2903      	cmp	r1, #3
 81fbb6c:	d059      	beq.n	81fbc22 <HAL_RCCEx_GetPLL3ClockFreq+0xfe>
        pll3vco = ((float_t)HSE_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_PLL3N) + \
                                                           (fracn3 / (float_t)0x2000) + (float_t)1);
        break;

      default:
        pll3vco = ((float_t)MSIRangeTable[(__HAL_RCC_GET_MSI_RANGE() >> RCC_ICSCR1_MSISRANGE_Pos)] / (float_t)pll3m) * \
 81fbb6e:	6893      	ldr	r3, [r2, #8]
 81fbb70:	4937      	ldr	r1, [pc, #220]	@ (81fbc50 <HAL_RCCEx_GetPLL3ClockFreq+0x12c>)
 81fbb72:	021b      	lsls	r3, r3, #8
 81fbb74:	bf4b      	itete	mi
 81fbb76:	6893      	ldrmi	r3, [r2, #8]
 81fbb78:	f8d2 30f4 	ldrpl.w	r3, [r2, #244]	@ 0xf4
 81fbb7c:	0f1b      	lsrmi	r3, r3, #28
 81fbb7e:	f3c3 3303 	ubfxpl	r3, r3, #12, #4
 81fbb82:	eb01 0383 	add.w	r3, r1, r3, lsl #2
 81fbb86:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 81fbb8a:	ed93 5a00 	vldr	s10, [r3]
                  ((float_t)pll3n + (fracn3 / (float_t)0x2000) + (float_t)1);
 81fbb8e:	eee7 7a25 	vfma.f32	s15, s14, s11
        pll3vco = ((float_t)MSIRangeTable[(__HAL_RCC_GET_MSI_RANGE() >> RCC_ICSCR1_MSISRANGE_Pos)] / (float_t)pll3m) * \
 81fbb92:	eeb8 5a45 	vcvt.f32.u32	s10, s10
                  ((float_t)pll3n + (fracn3 / (float_t)0x2000) + (float_t)1);
 81fbb96:	ee77 7a86 	vadd.f32	s15, s15, s12
        pll3vco = ((float_t)MSIRangeTable[(__HAL_RCC_GET_MSI_RANGE() >> RCC_ICSCR1_MSISRANGE_Pos)] / (float_t)pll3m) * \
 81fbb9a:	eec5 4a26 	vdiv.f32	s9, s10, s13
 81fbb9e:	ee67 7aa4 	vmul.f32	s15, s15, s9
        break;
    }

    if (__HAL_RCC_GET_PLL3CLKOUT_CONFIG(RCC_PLL3_DIVP) != 0U)
 81fbba2:	4a29      	ldr	r2, [pc, #164]	@ (81fbc48 <HAL_RCCEx_GetPLL3ClockFreq+0x124>)
 81fbba4:	6b13      	ldr	r3, [r2, #48]	@ 0x30
 81fbba6:	f413 3380 	ands.w	r3, r3, #65536	@ 0x10000
 81fbbaa:	d00e      	beq.n	81fbbca <HAL_RCCEx_GetPLL3ClockFreq+0xa6>
    {
      PLL3_Clocks->PLL3_P_Frequency = (uint32_t)(float_t)(pll3vco / ((float_t)(uint32_t)((RCC->PLL3DIVR & \
 81fbbac:	6c53      	ldr	r3, [r2, #68]	@ 0x44
 81fbbae:	f3c3 2346 	ubfx	r3, r3, #9, #7
 81fbbb2:	ee06 3a90 	vmov	s13, r3
 81fbbb6:	eef8 6ae6 	vcvt.f32.s32	s13, s13
                                                                     RCC_PLL3DIVR_PLL3P) >> RCC_PLL3DIVR_PLL3P_Pos) + \
 81fbbba:	ee76 6a86 	vadd.f32	s13, s13, s12
      PLL3_Clocks->PLL3_P_Frequency = (uint32_t)(float_t)(pll3vco / ((float_t)(uint32_t)((RCC->PLL3DIVR & \
 81fbbbe:	ee87 7aa6 	vdiv.f32	s14, s15, s13
 81fbbc2:	eebc 7ac7 	vcvt.u32.f32	s14, s14
 81fbbc6:	ee17 3a10 	vmov	r3, s14
    else
    {
      PLL3_Clocks->PLL3_P_Frequency = 0U;
    }

    if (__HAL_RCC_GET_PLL3CLKOUT_CONFIG(RCC_PLL3_DIVQ) != 0U)
 81fbbca:	4a1f      	ldr	r2, [pc, #124]	@ (81fbc48 <HAL_RCCEx_GetPLL3ClockFreq+0x124>)
 81fbbcc:	6003      	str	r3, [r0, #0]
 81fbbce:	6b13      	ldr	r3, [r2, #48]	@ 0x30
 81fbbd0:	f413 3300 	ands.w	r3, r3, #131072	@ 0x20000
 81fbbd4:	d00e      	beq.n	81fbbf4 <HAL_RCCEx_GetPLL3ClockFreq+0xd0>
    {
      PLL3_Clocks->PLL3_Q_Frequency = (uint32_t)(float_t)(pll3vco / ((float_t)(uint32_t)((RCC->PLL3DIVR & \
 81fbbd6:	6c53      	ldr	r3, [r2, #68]	@ 0x44
 81fbbd8:	f3c3 4306 	ubfx	r3, r3, #16, #7
 81fbbdc:	ee06 3a90 	vmov	s13, r3
 81fbbe0:	eef8 6ae6 	vcvt.f32.s32	s13, s13
                                                                     RCC_PLL3DIVR_PLL3Q) >> RCC_PLL3DIVR_PLL3Q_Pos) + \
 81fbbe4:	ee76 6a86 	vadd.f32	s13, s13, s12
      PLL3_Clocks->PLL3_Q_Frequency = (uint32_t)(float_t)(pll3vco / ((float_t)(uint32_t)((RCC->PLL3DIVR & \
 81fbbe8:	ee87 7aa6 	vdiv.f32	s14, s15, s13
 81fbbec:	eebc 7ac7 	vcvt.u32.f32	s14, s14
 81fbbf0:	ee17 3a10 	vmov	r3, s14
    else
    {
      PLL3_Clocks->PLL3_Q_Frequency = 0U;
    }

    if (__HAL_RCC_GET_PLL3CLKOUT_CONFIG(RCC_PLL3_DIVR) != 0U)
 81fbbf4:	4a14      	ldr	r2, [pc, #80]	@ (81fbc48 <HAL_RCCEx_GetPLL3ClockFreq+0x124>)
 81fbbf6:	6043      	str	r3, [r0, #4]
 81fbbf8:	6b13      	ldr	r3, [r2, #48]	@ 0x30
 81fbbfa:	f413 2380 	ands.w	r3, r3, #262144	@ 0x40000
 81fbbfe:	d00e      	beq.n	81fbc1e <HAL_RCCEx_GetPLL3ClockFreq+0xfa>
    {
      PLL3_Clocks->PLL3_R_Frequency = (uint32_t)(float_t)(pll3vco / ((float_t)(uint32_t)((RCC->PLL3DIVR & \
 81fbc00:	6c53      	ldr	r3, [r2, #68]	@ 0x44
 81fbc02:	f3c3 6306 	ubfx	r3, r3, #24, #7
 81fbc06:	ee06 3a90 	vmov	s13, r3
 81fbc0a:	eef8 6ae6 	vcvt.f32.s32	s13, s13
                                                                     RCC_PLL3DIVR_PLL3R) >> RCC_PLL3DIVR_PLL3R_Pos) + \
 81fbc0e:	ee76 6a86 	vadd.f32	s13, s13, s12
      PLL3_Clocks->PLL3_R_Frequency = (uint32_t)(float_t)(pll3vco / ((float_t)(uint32_t)((RCC->PLL3DIVR & \
 81fbc12:	ee87 7aa6 	vdiv.f32	s14, s15, s13
 81fbc16:	eefc 7ac7 	vcvt.u32.f32	s15, s14
 81fbc1a:	ee17 3a90 	vmov	r3, s15
 81fbc1e:	6083      	str	r3, [r0, #8]
  {
    PLL3_Clocks->PLL3_P_Frequency = 0U;
    PLL3_Clocks->PLL3_Q_Frequency = 0U;
    PLL3_Clocks->PLL3_R_Frequency = 0U;
  }
}
 81fbc20:	bd10      	pop	{r4, pc}
        pll3vco = ((float_t)HSE_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_PLL3N) + \
 81fbc22:	eddf 7a0c 	vldr	s15, [pc, #48]	@ 81fbc54 <HAL_RCCEx_GetPLL3ClockFreq+0x130>
 81fbc26:	6c53      	ldr	r3, [r2, #68]	@ 0x44
 81fbc28:	ee87 5aa6 	vdiv.f32	s10, s15, s13
 81fbc2c:	f3c3 0308 	ubfx	r3, r3, #0, #9
 81fbc30:	ee07 3a90 	vmov	s15, r3
 81fbc34:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 81fbc38:	eee7 7a25 	vfma.f32	s15, s14, s11
                                                           (fracn3 / (float_t)0x2000) + (float_t)1);
 81fbc3c:	ee77 7a86 	vadd.f32	s15, s15, s12
        pll3vco = ((float_t)HSE_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_PLL3N) + \
 81fbc40:	ee67 7a85 	vmul.f32	s15, s15, s10
        break;
 81fbc44:	e7ad      	b.n	81fbba2 <HAL_RCCEx_GetPLL3ClockFreq+0x7e>
 81fbc46:	bf00      	nop
 81fbc48:	46020c00 	.word	0x46020c00
 81fbc4c:	39000000 	.word	0x39000000
 81fbc50:	081fe8d8 	.word	0x081fe8d8
 81fbc54:	4b742400 	.word	0x4b742400

081fbc58 <HAL_RCCEx_GetPeriphCLKFreq>:
  * @retval Frequency in Hz
  *
  *        (*) value not defined in all devices.
  */
uint32_t HAL_RCCEx_GetPeriphCLKFreq(uint64_t PeriphClk)
{
 81fbc58:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 81fbc5a:	f5a0 4380 	sub.w	r3, r0, #16384	@ 0x4000
 81fbc5e:	430b      	orrs	r3, r1
 81fbc60:	f000 8115 	beq.w	81fbe8e <HAL_RCCEx_GetPeriphCLKFreq+0x236>
 81fbc64:	f244 0301 	movw	r3, #16385	@ 0x4001
 81fbc68:	4298      	cmp	r0, r3
 81fbc6a:	f171 0300 	sbcs.w	r3, r1, #0
 81fbc6e:	d25f      	bcs.n	81fbd30 <HAL_RCCEx_GetPeriphCLKFreq+0xd8>
 81fbc70:	f1a0 0380 	sub.w	r3, r0, #128	@ 0x80
 81fbc74:	430b      	orrs	r3, r1
 81fbc76:	f000 8362 	beq.w	81fc33e <HAL_RCCEx_GetPeriphCLKFreq+0x6e6>
 81fbc7a:	2881      	cmp	r0, #129	@ 0x81
 81fbc7c:	f171 0300 	sbcs.w	r3, r1, #0
 81fbc80:	d22e      	bcs.n	81fbce0 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
 81fbc82:	2809      	cmp	r0, #9
 81fbc84:	f171 0300 	sbcs.w	r3, r1, #0
 81fbc88:	d218      	bcs.n	81fbcbc <HAL_RCCEx_GetPeriphCLKFreq+0x64>
 81fbc8a:	ea50 0301 	orrs.w	r3, r0, r1
 81fbc8e:	f000 85ba 	beq.w	81fc806 <HAL_RCCEx_GetPeriphCLKFreq+0xbae>
 81fbc92:	3801      	subs	r0, #1
 81fbc94:	f141 31ff 	adc.w	r1, r1, #4294967295	@ 0xffffffff
 81fbc98:	2808      	cmp	r0, #8
 81fbc9a:	f171 0100 	sbcs.w	r1, r1, #0
 81fbc9e:	f080 85b5 	bcs.w	81fc80c <HAL_RCCEx_GetPeriphCLKFreq+0xbb4>
 81fbca2:	2807      	cmp	r0, #7
 81fbca4:	f200 85b2 	bhi.w	81fc80c <HAL_RCCEx_GetPeriphCLKFreq+0xbb4>
 81fbca8:	e8df f010 	tbh	[pc, r0, lsl #1]
 81fbcac:	01d101aa 	.word	0x01d101aa
 81fbcb0:	01f105b0 	.word	0x01f105b0
 81fbcb4:	05b005b0 	.word	0x05b005b0
 81fbcb8:	020e05b0 	.word	0x020e05b0
 81fbcbc:	f1a0 0320 	sub.w	r3, r0, #32
 81fbcc0:	430b      	orrs	r3, r1
 81fbcc2:	f000 823b 	beq.w	81fc13c <HAL_RCCEx_GetPeriphCLKFreq+0x4e4>
 81fbcc6:	f1a0 0340 	sub.w	r3, r0, #64	@ 0x40
 81fbcca:	430b      	orrs	r3, r1
 81fbccc:	f000 830c 	beq.w	81fc2e8 <HAL_RCCEx_GetPeriphCLKFreq+0x690>
 81fbcd0:	3810      	subs	r0, #16
 81fbcd2:	4308      	orrs	r0, r1
 81fbcd4:	f000 8213 	beq.w	81fc0fe <HAL_RCCEx_GetPeriphCLKFreq+0x4a6>
        {
          frequency = HSI_VALUE;
        }
        else
        {
          frequency = 0U;
 81fbcd8:	2000      	movs	r0, #0
  else
  {
    frequency = 0;
  }
  return (frequency);
}
 81fbcda:	b005      	add	sp, #20
 81fbcdc:	f85d fb04 	ldr.w	pc, [sp], #4
 81fbce0:	f5a0 6300 	sub.w	r3, r0, #2048	@ 0x800
 81fbce4:	430b      	orrs	r3, r1
 81fbce6:	f000 83af 	beq.w	81fc448 <HAL_RCCEx_GetPeriphCLKFreq+0x7f0>
 81fbcea:	f640 0301 	movw	r3, #2049	@ 0x801
 81fbcee:	4298      	cmp	r0, r3
 81fbcf0:	f171 0300 	sbcs.w	r3, r1, #0
 81fbcf4:	d210      	bcs.n	81fbd18 <HAL_RCCEx_GetPeriphCLKFreq+0xc0>
 81fbcf6:	f5a0 7300 	sub.w	r3, r0, #512	@ 0x200
 81fbcfa:	430b      	orrs	r3, r1
 81fbcfc:	f000 83e4 	beq.w	81fc4c8 <HAL_RCCEx_GetPeriphCLKFreq+0x870>
 81fbd00:	f5a0 6380 	sub.w	r3, r0, #1024	@ 0x400
 81fbd04:	430b      	orrs	r3, r1
 81fbd06:	f000 8420 	beq.w	81fc54a <HAL_RCCEx_GetPeriphCLKFreq+0x8f2>
 81fbd0a:	f5a0 7080 	sub.w	r0, r0, #256	@ 0x100
 81fbd0e:	4308      	orrs	r0, r1
 81fbd10:	f000 8340 	beq.w	81fc394 <HAL_RCCEx_GetPeriphCLKFreq+0x73c>
          frequency = 0U;
 81fbd14:	2000      	movs	r0, #0
 81fbd16:	e7e0      	b.n	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
 81fbd18:	f5a0 5380 	sub.w	r3, r0, #4096	@ 0x1000
 81fbd1c:	430b      	orrs	r3, r1
 81fbd1e:	f000 80d5 	beq.w	81fbecc <HAL_RCCEx_GetPeriphCLKFreq+0x274>
 81fbd22:	f5a0 5000 	sub.w	r0, r0, #8192	@ 0x2000
 81fbd26:	4308      	orrs	r0, r1
 81fbd28:	f000 8087 	beq.w	81fbe3a <HAL_RCCEx_GetPeriphCLKFreq+0x1e2>
 81fbd2c:	2000      	movs	r0, #0
 81fbd2e:	e7d4      	b.n	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
 81fbd30:	f5a0 0380 	sub.w	r3, r0, #4194304	@ 0x400000
 81fbd34:	430b      	orrs	r3, r1
 81fbd36:	f000 835c 	beq.w	81fc3f2 <HAL_RCCEx_GetPeriphCLKFreq+0x79a>
 81fbd3a:	4ba8      	ldr	r3, [pc, #672]	@ (81fbfdc <HAL_RCCEx_GetPeriphCLKFreq+0x384>)
 81fbd3c:	4298      	cmp	r0, r3
 81fbd3e:	f171 0300 	sbcs.w	r3, r1, #0
 81fbd42:	d22a      	bcs.n	81fbd9a <HAL_RCCEx_GetPeriphCLKFreq+0x142>
 81fbd44:	f5a0 2380 	sub.w	r3, r0, #262144	@ 0x40000
 81fbd48:	430b      	orrs	r3, r1
 81fbd4a:	d04d      	beq.n	81fbde8 <HAL_RCCEx_GetPeriphCLKFreq+0x190>
 81fbd4c:	4ba4      	ldr	r3, [pc, #656]	@ (81fbfe0 <HAL_RCCEx_GetPeriphCLKFreq+0x388>)
 81fbd4e:	4298      	cmp	r0, r3
 81fbd50:	f171 0300 	sbcs.w	r3, r1, #0
 81fbd54:	d210      	bcs.n	81fbd78 <HAL_RCCEx_GetPeriphCLKFreq+0x120>
 81fbd56:	f5a0 3380 	sub.w	r3, r0, #65536	@ 0x10000
 81fbd5a:	430b      	orrs	r3, r1
 81fbd5c:	f000 8262 	beq.w	81fc224 <HAL_RCCEx_GetPeriphCLKFreq+0x5cc>
 81fbd60:	f5a0 3300 	sub.w	r3, r0, #131072	@ 0x20000
 81fbd64:	430b      	orrs	r3, r1
 81fbd66:	f000 828c 	beq.w	81fc282 <HAL_RCCEx_GetPeriphCLKFreq+0x62a>
 81fbd6a:	f5a0 4000 	sub.w	r0, r0, #32768	@ 0x8000
 81fbd6e:	4308      	orrs	r0, r1
 81fbd70:	f000 8217 	beq.w	81fc1a2 <HAL_RCCEx_GetPeriphCLKFreq+0x54a>
 81fbd74:	2000      	movs	r0, #0
 81fbd76:	e7b0      	b.n	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
 81fbd78:	f5a0 1380 	sub.w	r3, r0, #1048576	@ 0x100000
 81fbd7c:	430b      	orrs	r3, r1
 81fbd7e:	f000 80ba 	beq.w	81fbef6 <HAL_RCCEx_GetPeriphCLKFreq+0x29e>
 81fbd82:	f5a0 1300 	sub.w	r3, r0, #2097152	@ 0x200000
 81fbd86:	430b      	orrs	r3, r1
 81fbd88:	f000 80e9 	beq.w	81fbf5e <HAL_RCCEx_GetPeriphCLKFreq+0x306>
 81fbd8c:	f5a0 2000 	sub.w	r0, r0, #524288	@ 0x80000
 81fbd90:	4308      	orrs	r0, r1
 81fbd92:	f000 851a 	beq.w	81fc7ca <HAL_RCCEx_GetPeriphCLKFreq+0xb72>
 81fbd96:	2000      	movs	r0, #0
 81fbd98:	e79f      	b.n	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
 81fbd9a:	f100 437c 	add.w	r3, r0, #4227858432	@ 0xfc000000
 81fbd9e:	430b      	orrs	r3, r1
 81fbda0:	f000 84c4 	beq.w	81fc72c <HAL_RCCEx_GetPeriphCLKFreq+0xad4>
 81fbda4:	4b8f      	ldr	r3, [pc, #572]	@ (81fbfe4 <HAL_RCCEx_GetPeriphCLKFreq+0x38c>)
 81fbda6:	4298      	cmp	r0, r3
 81fbda8:	f171 0300 	sbcs.w	r3, r1, #0
 81fbdac:	d210      	bcs.n	81fbdd0 <HAL_RCCEx_GetPeriphCLKFreq+0x178>
 81fbdae:	f100 437f 	add.w	r3, r0, #4278190080	@ 0xff000000
 81fbdb2:	430b      	orrs	r3, r1
 81fbdb4:	f000 8451 	beq.w	81fc65a <HAL_RCCEx_GetPeriphCLKFreq+0xa02>
 81fbdb8:	f100 437e 	add.w	r3, r0, #4261412864	@ 0xfe000000
 81fbdbc:	430b      	orrs	r3, r1
 81fbdbe:	f000 8482 	beq.w	81fc6c6 <HAL_RCCEx_GetPeriphCLKFreq+0xa6e>
 81fbdc2:	f5a0 0000 	sub.w	r0, r0, #8388608	@ 0x800000
 81fbdc6:	4308      	orrs	r0, r1
 81fbdc8:	f000 8411 	beq.w	81fc5ee <HAL_RCCEx_GetPeriphCLKFreq+0x996>
 81fbdcc:	2000      	movs	r0, #0
 81fbdce:	e784      	b.n	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
 81fbdd0:	f100 4378 	add.w	r3, r0, #4160749568	@ 0xf8000000
 81fbdd4:	430b      	orrs	r3, r1
 81fbdd6:	f000 83ec 	beq.w	81fc5b2 <HAL_RCCEx_GetPeriphCLKFreq+0x95a>
 81fbdda:	f100 4070 	add.w	r0, r0, #4026531840	@ 0xf0000000
 81fbdde:	4308      	orrs	r0, r1
 81fbde0:	f000 84d4 	beq.w	81fc78c <HAL_RCCEx_GetPeriphCLKFreq+0xb34>
 81fbde4:	2000      	movs	r0, #0
 81fbde6:	e778      	b.n	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
    srcclk = __HAL_RCC_GET_RTC_SOURCE();
 81fbde8:	4a7f      	ldr	r2, [pc, #508]	@ (81fbfe8 <HAL_RCCEx_GetPeriphCLKFreq+0x390>)
 81fbdea:	f8d2 30f0 	ldr.w	r3, [r2, #240]	@ 0xf0
    if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_RTCCLKSOURCE_LSE))
 81fbdee:	f8d2 10f0 	ldr.w	r1, [r2, #240]	@ 0xf0
    srcclk = __HAL_RCC_GET_RTC_SOURCE();
 81fbdf2:	f403 7340 	and.w	r3, r3, #768	@ 0x300
    if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_RTCCLKSOURCE_LSE))
 81fbdf6:	0789      	lsls	r1, r1, #30
 81fbdf8:	d503      	bpl.n	81fbe02 <HAL_RCCEx_GetPeriphCLKFreq+0x1aa>
 81fbdfa:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 81fbdfe:	f000 8508 	beq.w	81fc812 <HAL_RCCEx_GetPeriphCLKFreq+0xbba>
    else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIRDY)) && (srcclk == RCC_RTCCLKSOURCE_LSI))
 81fbe02:	f8d2 10f0 	ldr.w	r1, [r2, #240]	@ 0xf0
 81fbe06:	0109      	lsls	r1, r1, #4
 81fbe08:	d50b      	bpl.n	81fbe22 <HAL_RCCEx_GetPeriphCLKFreq+0x1ca>
 81fbe0a:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 81fbe0e:	d108      	bne.n	81fbe22 <HAL_RCCEx_GetPeriphCLKFreq+0x1ca>
      if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIPREDIV))
 81fbe10:	f8d2 30f0 	ldr.w	r3, [r2, #240]	@ 0xf0
        frequency = LSI_VALUE / 128U;
 81fbe14:	f013 5f80 	tst.w	r3, #268435456	@ 0x10000000
 81fbe18:	bf0c      	ite	eq
 81fbe1a:	f44f 40fa 	moveq.w	r0, #32000	@ 0x7d00
 81fbe1e:	20fa      	movne	r0, #250	@ 0xfa
 81fbe20:	e75b      	b.n	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)) && (srcclk == RCC_RTCCLKSOURCE_HSE_DIV32))
 81fbe22:	4a71      	ldr	r2, [pc, #452]	@ (81fbfe8 <HAL_RCCEx_GetPeriphCLKFreq+0x390>)
 81fbe24:	6810      	ldr	r0, [r2, #0]
 81fbe26:	f410 3000 	ands.w	r0, r0, #131072	@ 0x20000
 81fbe2a:	f43f af56 	beq.w	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
      frequency = HSE_VALUE / 32U;
 81fbe2e:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
 81fbe32:	486e      	ldr	r0, [pc, #440]	@ (81fbfec <HAL_RCCEx_GetPeriphCLKFreq+0x394>)
 81fbe34:	bf18      	it	ne
 81fbe36:	2000      	movne	r0, #0
 81fbe38:	e74f      	b.n	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
    srcclk = __HAL_RCC_GET_SAI1_SOURCE();
 81fbe3a:	4a6b      	ldr	r2, [pc, #428]	@ (81fbfe8 <HAL_RCCEx_GetPeriphCLKFreq+0x390>)
 81fbe3c:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
 81fbe40:	f003 03e0 	and.w	r3, r3, #224	@ 0xe0
    switch (srcclk)
 81fbe44:	2b40      	cmp	r3, #64	@ 0x40
 81fbe46:	d00c      	beq.n	81fbe62 <HAL_RCCEx_GetPeriphCLKFreq+0x20a>
 81fbe48:	d804      	bhi.n	81fbe54 <HAL_RCCEx_GetPeriphCLKFreq+0x1fc>
 81fbe4a:	b17b      	cbz	r3, 81fbe6c <HAL_RCCEx_GetPeriphCLKFreq+0x214>
 81fbe4c:	2b20      	cmp	r3, #32
 81fbe4e:	d012      	beq.n	81fbe76 <HAL_RCCEx_GetPeriphCLKFreq+0x21e>
          frequency = 0U;
 81fbe50:	2000      	movs	r0, #0
 81fbe52:	e742      	b.n	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
    switch (srcclk)
 81fbe54:	2b60      	cmp	r3, #96	@ 0x60
 81fbe56:	f000 84e0 	beq.w	81fc81a <HAL_RCCEx_GetPeriphCLKFreq+0xbc2>
 81fbe5a:	2b80      	cmp	r3, #128	@ 0x80
 81fbe5c:	d010      	beq.n	81fbe80 <HAL_RCCEx_GetPeriphCLKFreq+0x228>
          frequency = 0U;
 81fbe5e:	2000      	movs	r0, #0
 81fbe60:	e73b      	b.n	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
        HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
 81fbe62:	a801      	add	r0, sp, #4
 81fbe64:	f7ff fd2a 	bl	81fb8bc <HAL_RCCEx_GetPLL1ClockFreq>
        frequency = pll1_clocks.PLL1_P_Frequency;
 81fbe68:	9801      	ldr	r0, [sp, #4]
        break;
 81fbe6a:	e736      	b.n	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
        HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 81fbe6c:	a801      	add	r0, sp, #4
 81fbe6e:	f7ff fdbf 	bl	81fb9f0 <HAL_RCCEx_GetPLL2ClockFreq>
        frequency = pll2_clocks.PLL2_P_Frequency;
 81fbe72:	9801      	ldr	r0, [sp, #4]
        break;
 81fbe74:	e731      	b.n	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
        HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 81fbe76:	a801      	add	r0, sp, #4
 81fbe78:	f7ff fe54 	bl	81fbb24 <HAL_RCCEx_GetPLL3ClockFreq>
        frequency = pll3_clocks.PLL3_P_Frequency;
 81fbe7c:	9801      	ldr	r0, [sp, #4]
        break;
 81fbe7e:	e72c      	b.n	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
 81fbe80:	6810      	ldr	r0, [r2, #0]
          frequency = HSI_VALUE;
 81fbe82:	4b5b      	ldr	r3, [pc, #364]	@ (81fbff0 <HAL_RCCEx_GetPeriphCLKFreq+0x398>)
 81fbe84:	f410 6080 	ands.w	r0, r0, #1024	@ 0x400
 81fbe88:	bf18      	it	ne
 81fbe8a:	4618      	movne	r0, r3
 81fbe8c:	e725      	b.n	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
    srcclk = __HAL_RCC_GET_SAI2_SOURCE();
 81fbe8e:	4a56      	ldr	r2, [pc, #344]	@ (81fbfe8 <HAL_RCCEx_GetPeriphCLKFreq+0x390>)
 81fbe90:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
 81fbe94:	f403 63e0 	and.w	r3, r3, #1792	@ 0x700
    switch (srcclk)
 81fbe98:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 81fbe9c:	d0e1      	beq.n	81fbe62 <HAL_RCCEx_GetPeriphCLKFreq+0x20a>
 81fbe9e:	d806      	bhi.n	81fbeae <HAL_RCCEx_GetPeriphCLKFreq+0x256>
 81fbea0:	2b00      	cmp	r3, #0
 81fbea2:	d0e3      	beq.n	81fbe6c <HAL_RCCEx_GetPeriphCLKFreq+0x214>
 81fbea4:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 81fbea8:	d0e5      	beq.n	81fbe76 <HAL_RCCEx_GetPeriphCLKFreq+0x21e>
          frequency = 0U;
 81fbeaa:	2000      	movs	r0, #0
 81fbeac:	e715      	b.n	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
    switch (srcclk)
 81fbeae:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
 81fbeb2:	f000 84b6 	beq.w	81fc822 <HAL_RCCEx_GetPeriphCLKFreq+0xbca>
 81fbeb6:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 81fbeba:	f040 84b6 	bne.w	81fc82a <HAL_RCCEx_GetPeriphCLKFreq+0xbd2>
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
 81fbebe:	6810      	ldr	r0, [r2, #0]
          frequency = HSI_VALUE;
 81fbec0:	4b4b      	ldr	r3, [pc, #300]	@ (81fbff0 <HAL_RCCEx_GetPeriphCLKFreq+0x398>)
 81fbec2:	f410 6080 	ands.w	r0, r0, #1024	@ 0x400
 81fbec6:	bf18      	it	ne
 81fbec8:	4618      	movne	r0, r3
 81fbeca:	e706      	b.n	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
    srcclk = __HAL_RCC_GET_SAES_SOURCE();
 81fbecc:	4a46      	ldr	r2, [pc, #280]	@ (81fbfe8 <HAL_RCCEx_GetPeriphCLKFreq+0x390>)
 81fbece:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
    if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY) && (srcclk == RCC_SAESCLKSOURCE_SHSI))
 81fbed2:	6811      	ldr	r1, [r2, #0]
    srcclk = __HAL_RCC_GET_SAES_SOURCE();
 81fbed4:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
    if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY) && (srcclk == RCC_SAESCLKSOURCE_SHSI))
 81fbed8:	0549      	lsls	r1, r1, #21
 81fbeda:	d502      	bpl.n	81fbee2 <HAL_RCCEx_GetPeriphCLKFreq+0x28a>
 81fbedc:	2b00      	cmp	r3, #0
 81fbede:	f000 84a7 	beq.w	81fc830 <HAL_RCCEx_GetPeriphCLKFreq+0xbd8>
    else if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY) && (srcclk == RCC_SAESCLKSOURCE_SHSI_DIV2))
 81fbee2:	6810      	ldr	r0, [r2, #0]
 81fbee4:	f410 6080 	ands.w	r0, r0, #1024	@ 0x400
 81fbee8:	f43f aef7 	beq.w	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
      frequency = HSI_VALUE >> 1U;
 81fbeec:	2b00      	cmp	r3, #0
 81fbeee:	4841      	ldr	r0, [pc, #260]	@ (81fbff4 <HAL_RCCEx_GetPeriphCLKFreq+0x39c>)
 81fbef0:	bf08      	it	eq
 81fbef2:	2000      	moveq	r0, #0
 81fbef4:	e6f1      	b.n	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
    srcclk = __HAL_RCC_GET_ICLK_SOURCE();
 81fbef6:	4b3c      	ldr	r3, [pc, #240]	@ (81fbfe8 <HAL_RCCEx_GetPeriphCLKFreq+0x390>)
 81fbef8:	f8d3 20e0 	ldr.w	r2, [r3, #224]	@ 0xe0
 81fbefc:	f002 6240 	and.w	r2, r2, #201326592	@ 0xc000000
    switch (srcclk)
 81fbf00:	f1b2 6f00 	cmp.w	r2, #134217728	@ 0x8000000
 81fbf04:	d00b      	beq.n	81fbf1e <HAL_RCCEx_GetPeriphCLKFreq+0x2c6>
 81fbf06:	d805      	bhi.n	81fbf14 <HAL_RCCEx_GetPeriphCLKFreq+0x2bc>
 81fbf08:	b172      	cbz	r2, 81fbf28 <HAL_RCCEx_GetPeriphCLKFreq+0x2d0>
 81fbf0a:	f1b2 6f80 	cmp.w	r2, #67108864	@ 0x4000000
 81fbf0e:	d039      	beq.n	81fbf84 <HAL_RCCEx_GetPeriphCLKFreq+0x32c>
          frequency = 0U;
 81fbf10:	2000      	movs	r0, #0
 81fbf12:	e6e2      	b.n	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
    switch (srcclk)
 81fbf14:	f1b2 6f40 	cmp.w	r2, #201326592	@ 0xc000000
 81fbf18:	d00d      	beq.n	81fbf36 <HAL_RCCEx_GetPeriphCLKFreq+0x2de>
          frequency = 0U;
 81fbf1a:	2000      	movs	r0, #0
 81fbf1c:	e6dd      	b.n	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
        HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
 81fbf1e:	a801      	add	r0, sp, #4
 81fbf20:	f7ff fccc 	bl	81fb8bc <HAL_RCCEx_GetPLL1ClockFreq>
        frequency = pll1_clocks.PLL1_Q_Frequency;
 81fbf24:	9802      	ldr	r0, [sp, #8]
        break;
 81fbf26:	e6d8      	b.n	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSI48RDY))
 81fbf28:	6818      	ldr	r0, [r3, #0]
          frequency = HSI48_VALUE;
 81fbf2a:	4b33      	ldr	r3, [pc, #204]	@ (81fbff8 <HAL_RCCEx_GetPeriphCLKFreq+0x3a0>)
 81fbf2c:	f410 5000 	ands.w	r0, r0, #8192	@ 0x2000
 81fbf30:	bf18      	it	ne
 81fbf32:	4618      	movne	r0, r3
 81fbf34:	e6d1      	b.n	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIKRDY))
 81fbf36:	6818      	ldr	r0, [r3, #0]
 81fbf38:	f010 0020 	ands.w	r0, r0, #32
 81fbf3c:	f43f aecd 	beq.w	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
          frequency = MSIRangeTable[(__HAL_RCC_GET_MSIK_RANGE() >> RCC_ICSCR1_MSIKRANGE_Pos)];
 81fbf40:	689a      	ldr	r2, [r3, #8]
 81fbf42:	0210      	lsls	r0, r2, #8
 81fbf44:	bf4c      	ite	mi
 81fbf46:	689b      	ldrmi	r3, [r3, #8]
 81fbf48:	f8d3 30f4 	ldrpl.w	r3, [r3, #244]	@ 0xf4
 81fbf4c:	4a2b      	ldr	r2, [pc, #172]	@ (81fbffc <HAL_RCCEx_GetPeriphCLKFreq+0x3a4>)
 81fbf4e:	bf4c      	ite	mi
 81fbf50:	f3c3 6303 	ubfxmi	r3, r3, #24, #4
 81fbf54:	f3c3 2303 	ubfxpl	r3, r3, #8, #4
 81fbf58:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
 81fbf5c:	e6bd      	b.n	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
    srcclk = __HAL_RCC_GET_SDMMC_SOURCE();
 81fbf5e:	4b22      	ldr	r3, [pc, #136]	@ (81fbfe8 <HAL_RCCEx_GetPeriphCLKFreq+0x390>)
 81fbf60:	f8d3 00e4 	ldr.w	r0, [r3, #228]	@ 0xe4
    if (srcclk == RCC_SDMMCCLKSOURCE_CLK48)
 81fbf64:	f410 4080 	ands.w	r0, r0, #16384	@ 0x4000
 81fbf68:	d132      	bne.n	81fbfd0 <HAL_RCCEx_GetPeriphCLKFreq+0x378>
      srcclk = __HAL_RCC_GET_ICLK_SOURCE();
 81fbf6a:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 81fbf6e:	f003 6340 	and.w	r3, r3, #201326592	@ 0xc000000
      switch (srcclk)
 81fbf72:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
 81fbf76:	d0d2      	beq.n	81fbf1e <HAL_RCCEx_GetPeriphCLKFreq+0x2c6>
 81fbf78:	d809      	bhi.n	81fbf8e <HAL_RCCEx_GetPeriphCLKFreq+0x336>
 81fbf7a:	b30b      	cbz	r3, 81fbfc0 <HAL_RCCEx_GetPeriphCLKFreq+0x368>
 81fbf7c:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
 81fbf80:	f47f aeab 	bne.w	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
        HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 81fbf84:	a801      	add	r0, sp, #4
 81fbf86:	f7ff fd33 	bl	81fb9f0 <HAL_RCCEx_GetPLL2ClockFreq>
        frequency = pll2_clocks.PLL2_Q_Frequency;
 81fbf8a:	9802      	ldr	r0, [sp, #8]
        break;
 81fbf8c:	e6a5      	b.n	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
      switch (srcclk)
 81fbf8e:	f1b3 6f40 	cmp.w	r3, #201326592	@ 0xc000000
 81fbf92:	f47f aea2 	bne.w	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
          if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIKRDY))
 81fbf96:	4b14      	ldr	r3, [pc, #80]	@ (81fbfe8 <HAL_RCCEx_GetPeriphCLKFreq+0x390>)
 81fbf98:	6818      	ldr	r0, [r3, #0]
 81fbf9a:	f010 0020 	ands.w	r0, r0, #32
 81fbf9e:	f43f ae9c 	beq.w	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
            frequency = MSIRangeTable[(__HAL_RCC_GET_MSIK_RANGE() >> RCC_ICSCR1_MSIKRANGE_Pos)];
 81fbfa2:	689a      	ldr	r2, [r3, #8]
 81fbfa4:	0211      	lsls	r1, r2, #8
 81fbfa6:	bf4c      	ite	mi
 81fbfa8:	689b      	ldrmi	r3, [r3, #8]
 81fbfaa:	f8d3 30f4 	ldrpl.w	r3, [r3, #244]	@ 0xf4
 81fbfae:	4a13      	ldr	r2, [pc, #76]	@ (81fbffc <HAL_RCCEx_GetPeriphCLKFreq+0x3a4>)
 81fbfb0:	bf4c      	ite	mi
 81fbfb2:	f3c3 6303 	ubfxmi	r3, r3, #24, #4
 81fbfb6:	f3c3 2303 	ubfxpl	r3, r3, #8, #4
 81fbfba:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
 81fbfbe:	e68c      	b.n	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
          if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSI48RDY))
 81fbfc0:	4b09      	ldr	r3, [pc, #36]	@ (81fbfe8 <HAL_RCCEx_GetPeriphCLKFreq+0x390>)
 81fbfc2:	6818      	ldr	r0, [r3, #0]
          frequency = HSI48_VALUE;
 81fbfc4:	4b0c      	ldr	r3, [pc, #48]	@ (81fbff8 <HAL_RCCEx_GetPeriphCLKFreq+0x3a0>)
 81fbfc6:	f410 5000 	ands.w	r0, r0, #8192	@ 0x2000
 81fbfca:	bf18      	it	ne
 81fbfcc:	4618      	movne	r0, r3
 81fbfce:	e684      	b.n	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
      HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
 81fbfd0:	a801      	add	r0, sp, #4
 81fbfd2:	f7ff fc73 	bl	81fb8bc <HAL_RCCEx_GetPLL1ClockFreq>
      frequency = pll1_clocks.PLL1_P_Frequency;
 81fbfd6:	9801      	ldr	r0, [sp, #4]
 81fbfd8:	e67f      	b.n	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
 81fbfda:	bf00      	nop
 81fbfdc:	00400001 	.word	0x00400001
 81fbfe0:	00040001 	.word	0x00040001
 81fbfe4:	04000001 	.word	0x04000001
 81fbfe8:	46020c00 	.word	0x46020c00
 81fbfec:	0007a120 	.word	0x0007a120
 81fbff0:	00f42400 	.word	0x00f42400
 81fbff4:	007a1200 	.word	0x007a1200
 81fbff8:	02dc6c00 	.word	0x02dc6c00
 81fbffc:	081fe8d8 	.word	0x081fe8d8
    srcclk = __HAL_RCC_GET_USART1_SOURCE();
 81fc000:	4aa8      	ldr	r2, [pc, #672]	@ (81fc2a4 <HAL_RCCEx_GetPeriphCLKFreq+0x64c>)
 81fc002:	f8d2 30e0 	ldr.w	r3, [r2, #224]	@ 0xe0
    if (srcclk == RCC_USART1CLKSOURCE_PCLK2)
 81fc006:	f013 0303 	ands.w	r3, r3, #3
 81fc00a:	d104      	bne.n	81fc016 <HAL_RCCEx_GetPeriphCLKFreq+0x3be>
}
 81fc00c:	b005      	add	sp, #20
 81fc00e:	f85d eb04 	ldr.w	lr, [sp], #4
        frequency = HAL_RCC_GetPCLK2Freq();
 81fc012:	f7ff bc33 	b.w	81fb87c <HAL_RCC_GetPCLK2Freq>
    else if (srcclk == RCC_USART1CLKSOURCE_SYSCLK)
 81fc016:	2b01      	cmp	r3, #1
 81fc018:	d104      	bne.n	81fc024 <HAL_RCCEx_GetPeriphCLKFreq+0x3cc>
}
 81fc01a:	b005      	add	sp, #20
 81fc01c:	f85d eb04 	ldr.w	lr, [sp], #4
        frequency = HAL_RCC_GetSysClockFreq();
 81fc020:	f7ff bb7c 	b.w	81fb71c <HAL_RCC_GetSysClockFreq>
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_USART1CLKSOURCE_HSI))
 81fc024:	6812      	ldr	r2, [r2, #0]
 81fc026:	0552      	lsls	r2, r2, #21
 81fc028:	d502      	bpl.n	81fc030 <HAL_RCCEx_GetPeriphCLKFreq+0x3d8>
 81fc02a:	2b02      	cmp	r3, #2
 81fc02c:	f000 8403 	beq.w	81fc836 <HAL_RCCEx_GetPeriphCLKFreq+0xbde>
    else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_USART1CLKSOURCE_LSE))
 81fc030:	4a9c      	ldr	r2, [pc, #624]	@ (81fc2a4 <HAL_RCCEx_GetPeriphCLKFreq+0x64c>)
 81fc032:	f8d2 00f0 	ldr.w	r0, [r2, #240]	@ 0xf0
 81fc036:	f010 0002 	ands.w	r0, r0, #2
 81fc03a:	f43f ae4e 	beq.w	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
 81fc03e:	f1a3 0c03 	sub.w	ip, r3, #3
 81fc042:	f1dc 0300 	rsbs	r3, ip, #0
 81fc046:	eb43 030c 	adc.w	r3, r3, ip
 81fc04a:	03d8      	lsls	r0, r3, #15
 81fc04c:	e645      	b.n	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
    srcclk = __HAL_RCC_GET_USART2_SOURCE();
 81fc04e:	4a95      	ldr	r2, [pc, #596]	@ (81fc2a4 <HAL_RCCEx_GetPeriphCLKFreq+0x64c>)
 81fc050:	f8d2 30e0 	ldr.w	r3, [r2, #224]	@ 0xe0
    if (srcclk == RCC_USART2CLKSOURCE_PCLK1)
 81fc054:	f013 030c 	ands.w	r3, r3, #12
 81fc058:	d104      	bne.n	81fc064 <HAL_RCCEx_GetPeriphCLKFreq+0x40c>
}
 81fc05a:	b005      	add	sp, #20
 81fc05c:	f85d eb04 	ldr.w	lr, [sp], #4
        frequency = HAL_RCC_GetPCLK1Freq();
 81fc060:	f7ff bbfc 	b.w	81fb85c <HAL_RCC_GetPCLK1Freq>
    else if (srcclk == RCC_USART2CLKSOURCE_SYSCLK)
 81fc064:	2b04      	cmp	r3, #4
 81fc066:	d0d8      	beq.n	81fc01a <HAL_RCCEx_GetPeriphCLKFreq+0x3c2>
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_USART2CLKSOURCE_HSI))
 81fc068:	6812      	ldr	r2, [r2, #0]
 81fc06a:	0550      	lsls	r0, r2, #21
 81fc06c:	d502      	bpl.n	81fc074 <HAL_RCCEx_GetPeriphCLKFreq+0x41c>
 81fc06e:	2b08      	cmp	r3, #8
 81fc070:	f000 83e4 	beq.w	81fc83c <HAL_RCCEx_GetPeriphCLKFreq+0xbe4>
    else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_USART2CLKSOURCE_LSE))
 81fc074:	4a8b      	ldr	r2, [pc, #556]	@ (81fc2a4 <HAL_RCCEx_GetPeriphCLKFreq+0x64c>)
 81fc076:	f8d2 00f0 	ldr.w	r0, [r2, #240]	@ 0xf0
 81fc07a:	f010 0002 	ands.w	r0, r0, #2
 81fc07e:	f43f ae2c 	beq.w	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
 81fc082:	f1a3 010c 	sub.w	r1, r3, #12
 81fc086:	424b      	negs	r3, r1
 81fc088:	414b      	adcs	r3, r1
 81fc08a:	03d8      	lsls	r0, r3, #15
 81fc08c:	e625      	b.n	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
    srcclk = __HAL_RCC_GET_USART3_SOURCE();
 81fc08e:	4a85      	ldr	r2, [pc, #532]	@ (81fc2a4 <HAL_RCCEx_GetPeriphCLKFreq+0x64c>)
 81fc090:	f8d2 30e0 	ldr.w	r3, [r2, #224]	@ 0xe0
    if (srcclk == RCC_USART3CLKSOURCE_PCLK1)
 81fc094:	f013 0330 	ands.w	r3, r3, #48	@ 0x30
 81fc098:	d0df      	beq.n	81fc05a <HAL_RCCEx_GetPeriphCLKFreq+0x402>
    else if (srcclk == RCC_USART3CLKSOURCE_SYSCLK)
 81fc09a:	2b10      	cmp	r3, #16
 81fc09c:	d0bd      	beq.n	81fc01a <HAL_RCCEx_GetPeriphCLKFreq+0x3c2>
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_USART3CLKSOURCE_HSI))
 81fc09e:	6812      	ldr	r2, [r2, #0]
 81fc0a0:	0552      	lsls	r2, r2, #21
 81fc0a2:	d502      	bpl.n	81fc0aa <HAL_RCCEx_GetPeriphCLKFreq+0x452>
 81fc0a4:	2b20      	cmp	r3, #32
 81fc0a6:	f000 83cc 	beq.w	81fc842 <HAL_RCCEx_GetPeriphCLKFreq+0xbea>
    else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_USART3CLKSOURCE_LSE))
 81fc0aa:	4a7e      	ldr	r2, [pc, #504]	@ (81fc2a4 <HAL_RCCEx_GetPeriphCLKFreq+0x64c>)
 81fc0ac:	f8d2 00f0 	ldr.w	r0, [r2, #240]	@ 0xf0
 81fc0b0:	f010 0002 	ands.w	r0, r0, #2
 81fc0b4:	f43f ae11 	beq.w	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
 81fc0b8:	f1a3 0c30 	sub.w	ip, r3, #48	@ 0x30
 81fc0bc:	f1dc 0300 	rsbs	r3, ip, #0
 81fc0c0:	eb43 030c 	adc.w	r3, r3, ip
 81fc0c4:	03d8      	lsls	r0, r3, #15
 81fc0c6:	e608      	b.n	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
    srcclk = __HAL_RCC_GET_UART4_SOURCE();
 81fc0c8:	4a76      	ldr	r2, [pc, #472]	@ (81fc2a4 <HAL_RCCEx_GetPeriphCLKFreq+0x64c>)
 81fc0ca:	f8d2 30e0 	ldr.w	r3, [r2, #224]	@ 0xe0
    if (srcclk == RCC_UART4CLKSOURCE_PCLK1)
 81fc0ce:	f013 03c0 	ands.w	r3, r3, #192	@ 0xc0
 81fc0d2:	d0c2      	beq.n	81fc05a <HAL_RCCEx_GetPeriphCLKFreq+0x402>
    else if (srcclk == RCC_UART4CLKSOURCE_SYSCLK)
 81fc0d4:	2b40      	cmp	r3, #64	@ 0x40
 81fc0d6:	d0a0      	beq.n	81fc01a <HAL_RCCEx_GetPeriphCLKFreq+0x3c2>
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_UART4CLKSOURCE_HSI))
 81fc0d8:	6812      	ldr	r2, [r2, #0]
 81fc0da:	0550      	lsls	r0, r2, #21
 81fc0dc:	d502      	bpl.n	81fc0e4 <HAL_RCCEx_GetPeriphCLKFreq+0x48c>
 81fc0de:	2b80      	cmp	r3, #128	@ 0x80
 81fc0e0:	f000 83b2 	beq.w	81fc848 <HAL_RCCEx_GetPeriphCLKFreq+0xbf0>
    else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_UART4CLKSOURCE_LSE))
 81fc0e4:	4a6f      	ldr	r2, [pc, #444]	@ (81fc2a4 <HAL_RCCEx_GetPeriphCLKFreq+0x64c>)
 81fc0e6:	f8d2 00f0 	ldr.w	r0, [r2, #240]	@ 0xf0
 81fc0ea:	f010 0002 	ands.w	r0, r0, #2
 81fc0ee:	f43f adf4 	beq.w	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
 81fc0f2:	f1a3 01c0 	sub.w	r1, r3, #192	@ 0xc0
 81fc0f6:	424b      	negs	r3, r1
 81fc0f8:	414b      	adcs	r3, r1
 81fc0fa:	03d8      	lsls	r0, r3, #15
 81fc0fc:	e5ed      	b.n	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
    srcclk = __HAL_RCC_GET_UART5_SOURCE();
 81fc0fe:	4a69      	ldr	r2, [pc, #420]	@ (81fc2a4 <HAL_RCCEx_GetPeriphCLKFreq+0x64c>)
 81fc100:	f8d2 30e0 	ldr.w	r3, [r2, #224]	@ 0xe0
    if (srcclk == RCC_UART5CLKSOURCE_PCLK1)
 81fc104:	f413 7340 	ands.w	r3, r3, #768	@ 0x300
 81fc108:	d0a7      	beq.n	81fc05a <HAL_RCCEx_GetPeriphCLKFreq+0x402>
    else if (srcclk == RCC_UART5CLKSOURCE_SYSCLK)
 81fc10a:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 81fc10e:	d084      	beq.n	81fc01a <HAL_RCCEx_GetPeriphCLKFreq+0x3c2>
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_UART5CLKSOURCE_HSI))
 81fc110:	6812      	ldr	r2, [r2, #0]
 81fc112:	0552      	lsls	r2, r2, #21
 81fc114:	d503      	bpl.n	81fc11e <HAL_RCCEx_GetPeriphCLKFreq+0x4c6>
 81fc116:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 81fc11a:	f000 8398 	beq.w	81fc84e <HAL_RCCEx_GetPeriphCLKFreq+0xbf6>
    else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_UART5CLKSOURCE_LSE))
 81fc11e:	4a61      	ldr	r2, [pc, #388]	@ (81fc2a4 <HAL_RCCEx_GetPeriphCLKFreq+0x64c>)
 81fc120:	f8d2 00f0 	ldr.w	r0, [r2, #240]	@ 0xf0
 81fc124:	f010 0002 	ands.w	r0, r0, #2
 81fc128:	f43f add7 	beq.w	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
 81fc12c:	f5a3 7c40 	sub.w	ip, r3, #768	@ 0x300
 81fc130:	f1dc 0300 	rsbs	r3, ip, #0
 81fc134:	eb43 030c 	adc.w	r3, r3, ip
 81fc138:	03d8      	lsls	r0, r3, #15
 81fc13a:	e5ce      	b.n	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
    srcclk = __HAL_RCC_GET_LPUART1_SOURCE();
 81fc13c:	4a59      	ldr	r2, [pc, #356]	@ (81fc2a4 <HAL_RCCEx_GetPeriphCLKFreq+0x64c>)
 81fc13e:	f8d2 30e8 	ldr.w	r3, [r2, #232]	@ 0xe8
    if (srcclk == RCC_LPUART1CLKSOURCE_PCLK3)
 81fc142:	f013 0307 	ands.w	r3, r3, #7
 81fc146:	d104      	bne.n	81fc152 <HAL_RCCEx_GetPeriphCLKFreq+0x4fa>
}
 81fc148:	b005      	add	sp, #20
 81fc14a:	f85d eb04 	ldr.w	lr, [sp], #4
        frequency = HAL_RCC_GetPCLK3Freq();
 81fc14e:	f7ff bba5 	b.w	81fb89c <HAL_RCC_GetPCLK3Freq>
    else if (srcclk == RCC_LPUART1CLKSOURCE_SYSCLK)
 81fc152:	2b01      	cmp	r3, #1
 81fc154:	f43f af61 	beq.w	81fc01a <HAL_RCCEx_GetPeriphCLKFreq+0x3c2>
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_LPUART1CLKSOURCE_HSI))
 81fc158:	6812      	ldr	r2, [r2, #0]
 81fc15a:	0550      	lsls	r0, r2, #21
 81fc15c:	d502      	bpl.n	81fc164 <HAL_RCCEx_GetPeriphCLKFreq+0x50c>
 81fc15e:	2b02      	cmp	r3, #2
 81fc160:	f000 8378 	beq.w	81fc854 <HAL_RCCEx_GetPeriphCLKFreq+0xbfc>
    else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_LPUART1CLKSOURCE_LSE))
 81fc164:	4a4f      	ldr	r2, [pc, #316]	@ (81fc2a4 <HAL_RCCEx_GetPeriphCLKFreq+0x64c>)
 81fc166:	f8d2 10f0 	ldr.w	r1, [r2, #240]	@ 0xf0
 81fc16a:	0789      	lsls	r1, r1, #30
 81fc16c:	d502      	bpl.n	81fc174 <HAL_RCCEx_GetPeriphCLKFreq+0x51c>
 81fc16e:	2b03      	cmp	r3, #3
 81fc170:	f000 8373 	beq.w	81fc85a <HAL_RCCEx_GetPeriphCLKFreq+0xc02>
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIKRDY)) && (srcclk == RCC_LPUART1CLKSOURCE_MSIK))
 81fc174:	6810      	ldr	r0, [r2, #0]
 81fc176:	f010 0020 	ands.w	r0, r0, #32
 81fc17a:	f43f adae 	beq.w	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
 81fc17e:	2b04      	cmp	r3, #4
 81fc180:	f040 836f 	bne.w	81fc862 <HAL_RCCEx_GetPeriphCLKFreq+0xc0a>
      frequency = MSIRangeTable[(__HAL_RCC_GET_MSIK_RANGE() >> RCC_ICSCR1_MSIKRANGE_Pos)];
 81fc184:	6893      	ldr	r3, [r2, #8]
 81fc186:	021b      	lsls	r3, r3, #8
 81fc188:	bf4c      	ite	mi
 81fc18a:	6893      	ldrmi	r3, [r2, #8]
 81fc18c:	f8d2 30f4 	ldrpl.w	r3, [r2, #244]	@ 0xf4
 81fc190:	4a45      	ldr	r2, [pc, #276]	@ (81fc2a8 <HAL_RCCEx_GetPeriphCLKFreq+0x650>)
 81fc192:	bf4c      	ite	mi
 81fc194:	f3c3 6303 	ubfxmi	r3, r3, #24, #4
 81fc198:	f3c3 2303 	ubfxpl	r3, r3, #8, #4
 81fc19c:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
 81fc1a0:	e59b      	b.n	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
    srcclk = __HAL_RCC_GET_ADCDAC_SOURCE();
 81fc1a2:	4a40      	ldr	r2, [pc, #256]	@ (81fc2a4 <HAL_RCCEx_GetPeriphCLKFreq+0x64c>)
 81fc1a4:	f8d2 30e8 	ldr.w	r3, [r2, #232]	@ 0xe8
 81fc1a8:	f403 43e0 	and.w	r3, r3, #28672	@ 0x7000
    if (srcclk == RCC_ADCDACCLKSOURCE_SYSCLK)
 81fc1ac:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 81fc1b0:	f43f af33 	beq.w	81fc01a <HAL_RCCEx_GetPeriphCLKFreq+0x3c2>
    else if (srcclk == RCC_ADCDACCLKSOURCE_PLL2)
 81fc1b4:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 81fc1b8:	d104      	bne.n	81fc1c4 <HAL_RCCEx_GetPeriphCLKFreq+0x56c>
      HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 81fc1ba:	a801      	add	r0, sp, #4
 81fc1bc:	f7ff fc18 	bl	81fb9f0 <HAL_RCCEx_GetPLL2ClockFreq>
      frequency = pll2_clocks.PLL2_R_Frequency;
 81fc1c0:	9803      	ldr	r0, [sp, #12]
 81fc1c2:	e58a      	b.n	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
    else if (srcclk == RCC_ADCDACCLKSOURCE_HCLK)
 81fc1c4:	b923      	cbnz	r3, 81fc1d0 <HAL_RCCEx_GetPeriphCLKFreq+0x578>
}
 81fc1c6:	b005      	add	sp, #20
 81fc1c8:	f85d eb04 	ldr.w	lr, [sp], #4
        frequency = HAL_RCC_GetHCLKFreq();
 81fc1cc:	f7ff bb32 	b.w	81fb834 <HAL_RCC_GetHCLKFreq>
    else if (srcclk == RCC_ADCDACCLKSOURCE_MSIK)
 81fc1d0:	f5b3 4fa0 	cmp.w	r3, #20480	@ 0x5000
 81fc1d4:	d113      	bne.n	81fc1fe <HAL_RCCEx_GetPeriphCLKFreq+0x5a6>
      if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIKRDY))
 81fc1d6:	6810      	ldr	r0, [r2, #0]
 81fc1d8:	f010 0020 	ands.w	r0, r0, #32
 81fc1dc:	f43f ad7d 	beq.w	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
        frequency = MSIRangeTable[(__HAL_RCC_GET_MSIK_RANGE() >> RCC_ICSCR1_MSIKRANGE_Pos)];
 81fc1e0:	6893      	ldr	r3, [r2, #8]
 81fc1e2:	0218      	lsls	r0, r3, #8
 81fc1e4:	bf4c      	ite	mi
 81fc1e6:	6893      	ldrmi	r3, [r2, #8]
 81fc1e8:	f8d2 30f4 	ldrpl.w	r3, [r2, #244]	@ 0xf4
 81fc1ec:	4a2e      	ldr	r2, [pc, #184]	@ (81fc2a8 <HAL_RCCEx_GetPeriphCLKFreq+0x650>)
 81fc1ee:	bf4c      	ite	mi
 81fc1f0:	f3c3 6303 	ubfxmi	r3, r3, #24, #4
 81fc1f4:	f3c3 2303 	ubfxpl	r3, r3, #8, #4
 81fc1f8:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
 81fc1fc:	e56d      	b.n	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)) && (srcclk == RCC_ADCDACCLKSOURCE_HSE))
 81fc1fe:	6812      	ldr	r2, [r2, #0]
 81fc200:	0391      	lsls	r1, r2, #14
 81fc202:	d503      	bpl.n	81fc20c <HAL_RCCEx_GetPeriphCLKFreq+0x5b4>
 81fc204:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
 81fc208:	f000 832e 	beq.w	81fc868 <HAL_RCCEx_GetPeriphCLKFreq+0xc10>
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_ADCDACCLKSOURCE_HSI))
 81fc20c:	4a25      	ldr	r2, [pc, #148]	@ (81fc2a4 <HAL_RCCEx_GetPeriphCLKFreq+0x64c>)
 81fc20e:	6810      	ldr	r0, [r2, #0]
 81fc210:	f410 6080 	ands.w	r0, r0, #1024	@ 0x400
 81fc214:	f43f ad61 	beq.w	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
          frequency = HSI_VALUE;
 81fc218:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
 81fc21c:	4823      	ldr	r0, [pc, #140]	@ (81fc2ac <HAL_RCCEx_GetPeriphCLKFreq+0x654>)
 81fc21e:	bf18      	it	ne
 81fc220:	2000      	movne	r0, #0
 81fc222:	e55a      	b.n	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
    srcclk = __HAL_RCC_GET_MDF1_SOURCE();
 81fc224:	4b1f      	ldr	r3, [pc, #124]	@ (81fc2a4 <HAL_RCCEx_GetPeriphCLKFreq+0x64c>)
 81fc226:	f8d3 20e4 	ldr.w	r2, [r3, #228]	@ 0xe4
 81fc22a:	f002 0207 	and.w	r2, r2, #7
    switch (srcclk)
 81fc22e:	2a04      	cmp	r2, #4
 81fc230:	d80c      	bhi.n	81fc24c <HAL_RCCEx_GetPeriphCLKFreq+0x5f4>
 81fc232:	a101      	add	r1, pc, #4	@ (adr r1, 81fc238 <HAL_RCCEx_GetPeriphCLKFreq+0x5e0>)
 81fc234:	f851 f022 	ldr.w	pc, [r1, r2, lsl #2]
 81fc238:	081fc1c7 	.word	0x081fc1c7
 81fc23c:	081fbe63 	.word	0x081fbe63
 81fc240:	081fc251 	.word	0x081fc251
 81fc244:	081fc86f 	.word	0x081fc86f
 81fc248:	081fc25b 	.word	0x081fc25b
          frequency = 0U;
 81fc24c:	2000      	movs	r0, #0
 81fc24e:	e544      	b.n	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
        HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 81fc250:	a801      	add	r0, sp, #4
 81fc252:	f7ff fc67 	bl	81fbb24 <HAL_RCCEx_GetPLL3ClockFreq>
        frequency = pll3_clocks.PLL3_Q_Frequency;
 81fc256:	9802      	ldr	r0, [sp, #8]
        break;
 81fc258:	e53f      	b.n	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIKRDY))
 81fc25a:	6818      	ldr	r0, [r3, #0]
 81fc25c:	f010 0020 	ands.w	r0, r0, #32
 81fc260:	f43f ad3b 	beq.w	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
          frequency = MSIRangeTable[(__HAL_RCC_GET_MSIK_RANGE() >> RCC_ICSCR1_MSIKRANGE_Pos)];
 81fc264:	689a      	ldr	r2, [r3, #8]
 81fc266:	0212      	lsls	r2, r2, #8
 81fc268:	bf4c      	ite	mi
 81fc26a:	689b      	ldrmi	r3, [r3, #8]
 81fc26c:	f8d3 30f4 	ldrpl.w	r3, [r3, #244]	@ 0xf4
 81fc270:	4a0d      	ldr	r2, [pc, #52]	@ (81fc2a8 <HAL_RCCEx_GetPeriphCLKFreq+0x650>)
 81fc272:	bf4c      	ite	mi
 81fc274:	f3c3 6303 	ubfxmi	r3, r3, #24, #4
 81fc278:	f3c3 2303 	ubfxpl	r3, r3, #8, #4
 81fc27c:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
 81fc280:	e52b      	b.n	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
    srcclk = __HAL_RCC_GET_ADF1_SOURCE();
 81fc282:	4a08      	ldr	r2, [pc, #32]	@ (81fc2a4 <HAL_RCCEx_GetPeriphCLKFreq+0x64c>)
 81fc284:	f8d2 30e8 	ldr.w	r3, [r2, #232]	@ 0xe8
 81fc288:	f403 23e0 	and.w	r3, r3, #458752	@ 0x70000
    switch (srcclk)
 81fc28c:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 81fc290:	d0de      	beq.n	81fc250 <HAL_RCCEx_GetPeriphCLKFreq+0x5f8>
 81fc292:	d80d      	bhi.n	81fc2b0 <HAL_RCCEx_GetPeriphCLKFreq+0x658>
 81fc294:	2b00      	cmp	r3, #0
 81fc296:	d096      	beq.n	81fc1c6 <HAL_RCCEx_GetPeriphCLKFreq+0x56e>
 81fc298:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 81fc29c:	f43f ade1 	beq.w	81fbe62 <HAL_RCCEx_GetPeriphCLKFreq+0x20a>
          frequency = 0U;
 81fc2a0:	2000      	movs	r0, #0
 81fc2a2:	e51a      	b.n	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
 81fc2a4:	46020c00 	.word	0x46020c00
 81fc2a8:	081fe8d8 	.word	0x081fe8d8
 81fc2ac:	00f42400 	.word	0x00f42400
    switch (srcclk)
 81fc2b0:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
 81fc2b4:	f000 82df 	beq.w	81fc876 <HAL_RCCEx_GetPeriphCLKFreq+0xc1e>
 81fc2b8:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
 81fc2bc:	f040 82df 	bne.w	81fc87e <HAL_RCCEx_GetPeriphCLKFreq+0xc26>
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIKRDY))
 81fc2c0:	6810      	ldr	r0, [r2, #0]
 81fc2c2:	f010 0020 	ands.w	r0, r0, #32
 81fc2c6:	f43f ad08 	beq.w	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
          frequency = MSIRangeTable[(__HAL_RCC_GET_MSIK_RANGE() >> RCC_ICSCR1_MSIKRANGE_Pos)];
 81fc2ca:	6893      	ldr	r3, [r2, #8]
 81fc2cc:	021b      	lsls	r3, r3, #8
 81fc2ce:	bf4c      	ite	mi
 81fc2d0:	6893      	ldrmi	r3, [r2, #8]
 81fc2d2:	f8d2 30f4 	ldrpl.w	r3, [r2, #244]	@ 0xf4
 81fc2d6:	4aa9      	ldr	r2, [pc, #676]	@ (81fc57c <HAL_RCCEx_GetPeriphCLKFreq+0x924>)
 81fc2d8:	bf4c      	ite	mi
 81fc2da:	f3c3 6303 	ubfxmi	r3, r3, #24, #4
 81fc2de:	f3c3 2303 	ubfxpl	r3, r3, #8, #4
 81fc2e2:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
 81fc2e6:	e4f8      	b.n	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
    srcclk = __HAL_RCC_GET_I2C1_SOURCE();
 81fc2e8:	4aa5      	ldr	r2, [pc, #660]	@ (81fc580 <HAL_RCCEx_GetPeriphCLKFreq+0x928>)
 81fc2ea:	f8d2 30e0 	ldr.w	r3, [r2, #224]	@ 0xe0
    if (srcclk == RCC_I2C1CLKSOURCE_PCLK1)
 81fc2ee:	f413 6340 	ands.w	r3, r3, #3072	@ 0xc00
 81fc2f2:	f43f aeb2 	beq.w	81fc05a <HAL_RCCEx_GetPeriphCLKFreq+0x402>
    else if (srcclk == RCC_I2C1CLKSOURCE_SYSCLK)
 81fc2f6:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 81fc2fa:	f43f ae8e 	beq.w	81fc01a <HAL_RCCEx_GetPeriphCLKFreq+0x3c2>
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_I2C1CLKSOURCE_HSI))
 81fc2fe:	6812      	ldr	r2, [r2, #0]
 81fc300:	0550      	lsls	r0, r2, #21
 81fc302:	d503      	bpl.n	81fc30c <HAL_RCCEx_GetPeriphCLKFreq+0x6b4>
 81fc304:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
 81fc308:	f000 82bc 	beq.w	81fc884 <HAL_RCCEx_GetPeriphCLKFreq+0xc2c>
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIKRDY)) && (srcclk == RCC_I2C1CLKSOURCE_MSIK))
 81fc30c:	4a9c      	ldr	r2, [pc, #624]	@ (81fc580 <HAL_RCCEx_GetPeriphCLKFreq+0x928>)
 81fc30e:	6810      	ldr	r0, [r2, #0]
 81fc310:	f010 0020 	ands.w	r0, r0, #32
 81fc314:	f43f ace1 	beq.w	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
 81fc318:	f5b3 6f40 	cmp.w	r3, #3072	@ 0xc00
 81fc31c:	f040 82b5 	bne.w	81fc88a <HAL_RCCEx_GetPeriphCLKFreq+0xc32>
      frequency = MSIRangeTable[(__HAL_RCC_GET_MSIK_RANGE() >> RCC_ICSCR1_MSIKRANGE_Pos)];
 81fc320:	6893      	ldr	r3, [r2, #8]
 81fc322:	0219      	lsls	r1, r3, #8
 81fc324:	bf4c      	ite	mi
 81fc326:	6893      	ldrmi	r3, [r2, #8]
 81fc328:	f8d2 30f4 	ldrpl.w	r3, [r2, #244]	@ 0xf4
 81fc32c:	4a93      	ldr	r2, [pc, #588]	@ (81fc57c <HAL_RCCEx_GetPeriphCLKFreq+0x924>)
 81fc32e:	bf4c      	ite	mi
 81fc330:	f3c3 6303 	ubfxmi	r3, r3, #24, #4
 81fc334:	f3c3 2303 	ubfxpl	r3, r3, #8, #4
 81fc338:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
 81fc33c:	e4cd      	b.n	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
    srcclk = __HAL_RCC_GET_I2C2_SOURCE();
 81fc33e:	4a90      	ldr	r2, [pc, #576]	@ (81fc580 <HAL_RCCEx_GetPeriphCLKFreq+0x928>)
 81fc340:	f8d2 30e0 	ldr.w	r3, [r2, #224]	@ 0xe0
    if (srcclk == RCC_I2C2CLKSOURCE_PCLK1)
 81fc344:	f413 5340 	ands.w	r3, r3, #12288	@ 0x3000
 81fc348:	f43f ae87 	beq.w	81fc05a <HAL_RCCEx_GetPeriphCLKFreq+0x402>
    else if (srcclk == RCC_I2C2CLKSOURCE_SYSCLK)
 81fc34c:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 81fc350:	f43f ae63 	beq.w	81fc01a <HAL_RCCEx_GetPeriphCLKFreq+0x3c2>
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_I2C2CLKSOURCE_HSI))
 81fc354:	6812      	ldr	r2, [r2, #0]
 81fc356:	0552      	lsls	r2, r2, #21
 81fc358:	d503      	bpl.n	81fc362 <HAL_RCCEx_GetPeriphCLKFreq+0x70a>
 81fc35a:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 81fc35e:	f000 829d 	beq.w	81fc89c <HAL_RCCEx_GetPeriphCLKFreq+0xc44>
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIKRDY)) && (srcclk == RCC_I2C2CLKSOURCE_MSIK))
 81fc362:	4a87      	ldr	r2, [pc, #540]	@ (81fc580 <HAL_RCCEx_GetPeriphCLKFreq+0x928>)
 81fc364:	6810      	ldr	r0, [r2, #0]
 81fc366:	f010 0020 	ands.w	r0, r0, #32
 81fc36a:	f43f acb6 	beq.w	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
 81fc36e:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
 81fc372:	f040 8296 	bne.w	81fc8a2 <HAL_RCCEx_GetPeriphCLKFreq+0xc4a>
      frequency = MSIRangeTable[(__HAL_RCC_GET_MSIK_RANGE() >> RCC_ICSCR1_MSIKRANGE_Pos)];
 81fc376:	6893      	ldr	r3, [r2, #8]
 81fc378:	0218      	lsls	r0, r3, #8
 81fc37a:	bf4c      	ite	mi
 81fc37c:	6893      	ldrmi	r3, [r2, #8]
 81fc37e:	f8d2 30f4 	ldrpl.w	r3, [r2, #244]	@ 0xf4
 81fc382:	4a7e      	ldr	r2, [pc, #504]	@ (81fc57c <HAL_RCCEx_GetPeriphCLKFreq+0x924>)
 81fc384:	bf4c      	ite	mi
 81fc386:	f3c3 6303 	ubfxmi	r3, r3, #24, #4
 81fc38a:	f3c3 2303 	ubfxpl	r3, r3, #8, #4
 81fc38e:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
 81fc392:	e4a2      	b.n	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
    srcclk = __HAL_RCC_GET_I2C3_SOURCE();
 81fc394:	4b7a      	ldr	r3, [pc, #488]	@ (81fc580 <HAL_RCCEx_GetPeriphCLKFreq+0x928>)
 81fc396:	f8d3 20e8 	ldr.w	r2, [r3, #232]	@ 0xe8
 81fc39a:	f002 02c0 	and.w	r2, r2, #192	@ 0xc0
    switch (srcclk)
 81fc39e:	2a80      	cmp	r2, #128	@ 0x80
 81fc3a0:	d00c      	beq.n	81fc3bc <HAL_RCCEx_GetPeriphCLKFreq+0x764>
 81fc3a2:	d807      	bhi.n	81fc3b4 <HAL_RCCEx_GetPeriphCLKFreq+0x75c>
 81fc3a4:	2a00      	cmp	r2, #0
 81fc3a6:	f43f aecf 	beq.w	81fc148 <HAL_RCCEx_GetPeriphCLKFreq+0x4f0>
 81fc3aa:	2a40      	cmp	r2, #64	@ 0x40
 81fc3ac:	f43f ae35 	beq.w	81fc01a <HAL_RCCEx_GetPeriphCLKFreq+0x3c2>
          frequency = 0U;
 81fc3b0:	2000      	movs	r0, #0
 81fc3b2:	e492      	b.n	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
    switch (srcclk)
 81fc3b4:	2ac0      	cmp	r2, #192	@ 0xc0
 81fc3b6:	d008      	beq.n	81fc3ca <HAL_RCCEx_GetPeriphCLKFreq+0x772>
          frequency = 0U;
 81fc3b8:	2000      	movs	r0, #0
 81fc3ba:	e48e      	b.n	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
 81fc3bc:	6818      	ldr	r0, [r3, #0]
          frequency = HSI_VALUE;
 81fc3be:	4b71      	ldr	r3, [pc, #452]	@ (81fc584 <HAL_RCCEx_GetPeriphCLKFreq+0x92c>)
 81fc3c0:	f410 6080 	ands.w	r0, r0, #1024	@ 0x400
 81fc3c4:	bf18      	it	ne
 81fc3c6:	4618      	movne	r0, r3
 81fc3c8:	e487      	b.n	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIKRDY))
 81fc3ca:	6818      	ldr	r0, [r3, #0]
 81fc3cc:	f010 0020 	ands.w	r0, r0, #32
 81fc3d0:	f43f ac83 	beq.w	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
          frequency = MSIRangeTable[(__HAL_RCC_GET_MSIK_RANGE() >> RCC_ICSCR1_MSIKRANGE_Pos)];
 81fc3d4:	689a      	ldr	r2, [r3, #8]
 81fc3d6:	0211      	lsls	r1, r2, #8
 81fc3d8:	bf4c      	ite	mi
 81fc3da:	689b      	ldrmi	r3, [r3, #8]
 81fc3dc:	f8d3 30f4 	ldrpl.w	r3, [r3, #244]	@ 0xf4
 81fc3e0:	4a66      	ldr	r2, [pc, #408]	@ (81fc57c <HAL_RCCEx_GetPeriphCLKFreq+0x924>)
 81fc3e2:	bf4c      	ite	mi
 81fc3e4:	f3c3 6303 	ubfxmi	r3, r3, #24, #4
 81fc3e8:	f3c3 2303 	ubfxpl	r3, r3, #8, #4
 81fc3ec:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
 81fc3f0:	e473      	b.n	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
    srcclk = __HAL_RCC_GET_I2C4_SOURCE();
 81fc3f2:	4a63      	ldr	r2, [pc, #396]	@ (81fc580 <HAL_RCCEx_GetPeriphCLKFreq+0x928>)
 81fc3f4:	f8d2 30e0 	ldr.w	r3, [r2, #224]	@ 0xe0
    if (srcclk == RCC_I2C4CLKSOURCE_PCLK1)
 81fc3f8:	f413 4340 	ands.w	r3, r3, #49152	@ 0xc000
 81fc3fc:	f43f ae2d 	beq.w	81fc05a <HAL_RCCEx_GetPeriphCLKFreq+0x402>
    else if (srcclk == RCC_I2C4CLKSOURCE_SYSCLK)
 81fc400:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
 81fc404:	f43f ae09 	beq.w	81fc01a <HAL_RCCEx_GetPeriphCLKFreq+0x3c2>
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_I2C4CLKSOURCE_HSI))
 81fc408:	6812      	ldr	r2, [r2, #0]
 81fc40a:	0552      	lsls	r2, r2, #21
 81fc40c:	d503      	bpl.n	81fc416 <HAL_RCCEx_GetPeriphCLKFreq+0x7be>
 81fc40e:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
 81fc412:	f000 8249 	beq.w	81fc8a8 <HAL_RCCEx_GetPeriphCLKFreq+0xc50>
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIKRDY)) && (srcclk == RCC_I2C4CLKSOURCE_MSIK))
 81fc416:	4a5a      	ldr	r2, [pc, #360]	@ (81fc580 <HAL_RCCEx_GetPeriphCLKFreq+0x928>)
 81fc418:	6810      	ldr	r0, [r2, #0]
 81fc41a:	f010 0020 	ands.w	r0, r0, #32
 81fc41e:	f43f ac5c 	beq.w	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
 81fc422:	f5b3 4f40 	cmp.w	r3, #49152	@ 0xc000
 81fc426:	f040 8242 	bne.w	81fc8ae <HAL_RCCEx_GetPeriphCLKFreq+0xc56>
      frequency = MSIRangeTable[(__HAL_RCC_GET_MSIK_RANGE() >> RCC_ICSCR1_MSIKRANGE_Pos)];
 81fc42a:	6893      	ldr	r3, [r2, #8]
 81fc42c:	021b      	lsls	r3, r3, #8
 81fc42e:	bf4c      	ite	mi
 81fc430:	6893      	ldrmi	r3, [r2, #8]
 81fc432:	f8d2 30f4 	ldrpl.w	r3, [r2, #244]	@ 0xf4
 81fc436:	4a51      	ldr	r2, [pc, #324]	@ (81fc57c <HAL_RCCEx_GetPeriphCLKFreq+0x924>)
 81fc438:	bf4c      	ite	mi
 81fc43a:	f3c3 6303 	ubfxmi	r3, r3, #24, #4
 81fc43e:	f3c3 2303 	ubfxpl	r3, r3, #8, #4
 81fc442:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
 81fc446:	e448      	b.n	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
    srcclk = __HAL_RCC_GET_LPTIM34_SOURCE();
 81fc448:	4a4d      	ldr	r2, [pc, #308]	@ (81fc580 <HAL_RCCEx_GetPeriphCLKFreq+0x928>)
 81fc44a:	f8d2 30e8 	ldr.w	r3, [r2, #232]	@ 0xe8
    if (srcclk == RCC_LPTIM34CLKSOURCE_MSIK)
 81fc44e:	f413 7340 	ands.w	r3, r3, #768	@ 0x300
 81fc452:	d113      	bne.n	81fc47c <HAL_RCCEx_GetPeriphCLKFreq+0x824>
      if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIKRDY))
 81fc454:	6810      	ldr	r0, [r2, #0]
 81fc456:	f010 0020 	ands.w	r0, r0, #32
 81fc45a:	f43f ac3e 	beq.w	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
        frequency = MSIRangeTable[(__HAL_RCC_GET_MSIK_RANGE() >> RCC_ICSCR1_MSIKRANGE_Pos)];
 81fc45e:	6893      	ldr	r3, [r2, #8]
 81fc460:	0218      	lsls	r0, r3, #8
 81fc462:	bf4c      	ite	mi
 81fc464:	6893      	ldrmi	r3, [r2, #8]
 81fc466:	f8d2 30f4 	ldrpl.w	r3, [r2, #244]	@ 0xf4
 81fc46a:	4a44      	ldr	r2, [pc, #272]	@ (81fc57c <HAL_RCCEx_GetPeriphCLKFreq+0x924>)
 81fc46c:	bf4c      	ite	mi
 81fc46e:	f3c3 6303 	ubfxmi	r3, r3, #24, #4
 81fc472:	f3c3 2303 	ubfxpl	r3, r3, #8, #4
 81fc476:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
 81fc47a:	e42e      	b.n	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
    else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIRDY)) && (srcclk == RCC_LPTIM34CLKSOURCE_LSI))
 81fc47c:	f8d2 10f0 	ldr.w	r1, [r2, #240]	@ 0xf0
 81fc480:	0109      	lsls	r1, r1, #4
 81fc482:	d50b      	bpl.n	81fc49c <HAL_RCCEx_GetPeriphCLKFreq+0x844>
 81fc484:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 81fc488:	d108      	bne.n	81fc49c <HAL_RCCEx_GetPeriphCLKFreq+0x844>
      if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIPREDIV))
 81fc48a:	f8d2 30f0 	ldr.w	r3, [r2, #240]	@ 0xf0
        frequency = LSI_VALUE / 128U;
 81fc48e:	f013 5f80 	tst.w	r3, #268435456	@ 0x10000000
 81fc492:	bf0c      	ite	eq
 81fc494:	f44f 40fa 	moveq.w	r0, #32000	@ 0x7d00
 81fc498:	20fa      	movne	r0, #250	@ 0xfa
 81fc49a:	e41e      	b.n	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_LPTIM34CLKSOURCE_HSI))
 81fc49c:	6812      	ldr	r2, [r2, #0]
 81fc49e:	0552      	lsls	r2, r2, #21
 81fc4a0:	d503      	bpl.n	81fc4aa <HAL_RCCEx_GetPeriphCLKFreq+0x852>
 81fc4a2:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 81fc4a6:	f000 8205 	beq.w	81fc8b4 <HAL_RCCEx_GetPeriphCLKFreq+0xc5c>
    else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_LPTIM34CLKSOURCE_LSE))
 81fc4aa:	4a35      	ldr	r2, [pc, #212]	@ (81fc580 <HAL_RCCEx_GetPeriphCLKFreq+0x928>)
 81fc4ac:	f8d2 00f0 	ldr.w	r0, [r2, #240]	@ 0xf0
 81fc4b0:	f010 0002 	ands.w	r0, r0, #2
 81fc4b4:	f43f ac11 	beq.w	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
 81fc4b8:	f5a3 7c40 	sub.w	ip, r3, #768	@ 0x300
 81fc4bc:	f1dc 0300 	rsbs	r3, ip, #0
 81fc4c0:	eb43 030c 	adc.w	r3, r3, ip
 81fc4c4:	03d8      	lsls	r0, r3, #15
 81fc4c6:	e408      	b.n	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
    srcclk = __HAL_RCC_GET_LPTIM1_SOURCE();
 81fc4c8:	4a2d      	ldr	r2, [pc, #180]	@ (81fc580 <HAL_RCCEx_GetPeriphCLKFreq+0x928>)
 81fc4ca:	f8d2 30e8 	ldr.w	r3, [r2, #232]	@ 0xe8
    if (srcclk == RCC_LPTIM1CLKSOURCE_MSIK)
 81fc4ce:	f413 6340 	ands.w	r3, r3, #3072	@ 0xc00
 81fc4d2:	d114      	bne.n	81fc4fe <HAL_RCCEx_GetPeriphCLKFreq+0x8a6>
      if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIKRDY))
 81fc4d4:	6810      	ldr	r0, [r2, #0]
 81fc4d6:	f010 0020 	ands.w	r0, r0, #32
 81fc4da:	f43f abfe 	beq.w	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
        frequency = MSIRangeTable[(__HAL_RCC_GET_MSIK_RANGE() >> RCC_ICSCR1_MSIKRANGE_Pos)];
 81fc4de:	6893      	ldr	r3, [r2, #8]
 81fc4e0:	0218      	lsls	r0, r3, #8
 81fc4e2:	bf4c      	ite	mi
 81fc4e4:	6893      	ldrmi	r3, [r2, #8]
 81fc4e6:	f8d2 30f4 	ldrpl.w	r3, [r2, #244]	@ 0xf4
 81fc4ea:	4a24      	ldr	r2, [pc, #144]	@ (81fc57c <HAL_RCCEx_GetPeriphCLKFreq+0x924>)
 81fc4ec:	bf4c      	ite	mi
 81fc4ee:	f3c3 6303 	ubfxmi	r3, r3, #24, #4
 81fc4f2:	f3c3 2303 	ubfxpl	r3, r3, #8, #4
 81fc4f6:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
 81fc4fa:	f7ff bbee 	b.w	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
    else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIRDY)) && (srcclk == RCC_LPTIM1CLKSOURCE_LSI))
 81fc4fe:	f8d2 10f0 	ldr.w	r1, [r2, #240]	@ 0xf0
 81fc502:	0109      	lsls	r1, r1, #4
 81fc504:	d50c      	bpl.n	81fc520 <HAL_RCCEx_GetPeriphCLKFreq+0x8c8>
 81fc506:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 81fc50a:	d109      	bne.n	81fc520 <HAL_RCCEx_GetPeriphCLKFreq+0x8c8>
      if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIPREDIV))
 81fc50c:	f8d2 30f0 	ldr.w	r3, [r2, #240]	@ 0xf0
        frequency = LSI_VALUE / 128U;
 81fc510:	f013 5f80 	tst.w	r3, #268435456	@ 0x10000000
 81fc514:	bf0c      	ite	eq
 81fc516:	f44f 40fa 	moveq.w	r0, #32000	@ 0x7d00
 81fc51a:	20fa      	movne	r0, #250	@ 0xfa
 81fc51c:	f7ff bbdd 	b.w	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_LPTIM1CLKSOURCE_HSI))
 81fc520:	6812      	ldr	r2, [r2, #0]
 81fc522:	0552      	lsls	r2, r2, #21
 81fc524:	d503      	bpl.n	81fc52e <HAL_RCCEx_GetPeriphCLKFreq+0x8d6>
 81fc526:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
 81fc52a:	f000 81c6 	beq.w	81fc8ba <HAL_RCCEx_GetPeriphCLKFreq+0xc62>
    else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_LPTIM1CLKSOURCE_LSE))
 81fc52e:	4a14      	ldr	r2, [pc, #80]	@ (81fc580 <HAL_RCCEx_GetPeriphCLKFreq+0x928>)
 81fc530:	f8d2 00f0 	ldr.w	r0, [r2, #240]	@ 0xf0
 81fc534:	f010 0002 	ands.w	r0, r0, #2
 81fc538:	f43f abcf 	beq.w	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
 81fc53c:	f5a3 6040 	sub.w	r0, r3, #3072	@ 0xc00
 81fc540:	4243      	negs	r3, r0
 81fc542:	4143      	adcs	r3, r0
 81fc544:	03d8      	lsls	r0, r3, #15
 81fc546:	f7ff bbc8 	b.w	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
    srcclk = __HAL_RCC_GET_LPTIM2_SOURCE();
 81fc54a:	4a0d      	ldr	r2, [pc, #52]	@ (81fc580 <HAL_RCCEx_GetPeriphCLKFreq+0x928>)
 81fc54c:	f8d2 30e0 	ldr.w	r3, [r2, #224]	@ 0xe0
    if (srcclk == RCC_LPTIM2CLKSOURCE_PCLK1)
 81fc550:	f413 2340 	ands.w	r3, r3, #786432	@ 0xc0000
 81fc554:	f43f ad81 	beq.w	81fc05a <HAL_RCCEx_GetPeriphCLKFreq+0x402>
    else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIRDY)) && (srcclk == RCC_LPTIM2CLKSOURCE_LSI))
 81fc558:	f8d2 10f0 	ldr.w	r1, [r2, #240]	@ 0xf0
 81fc55c:	0109      	lsls	r1, r1, #4
 81fc55e:	d513      	bpl.n	81fc588 <HAL_RCCEx_GetPeriphCLKFreq+0x930>
 81fc560:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
 81fc564:	d110      	bne.n	81fc588 <HAL_RCCEx_GetPeriphCLKFreq+0x930>
      if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIPREDIV))
 81fc566:	f8d2 30f0 	ldr.w	r3, [r2, #240]	@ 0xf0
        frequency = LSI_VALUE / 128U;
 81fc56a:	f013 5f80 	tst.w	r3, #268435456	@ 0x10000000
 81fc56e:	bf0c      	ite	eq
 81fc570:	f44f 40fa 	moveq.w	r0, #32000	@ 0x7d00
 81fc574:	20fa      	movne	r0, #250	@ 0xfa
 81fc576:	f7ff bbb0 	b.w	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
 81fc57a:	bf00      	nop
 81fc57c:	081fe8d8 	.word	0x081fe8d8
 81fc580:	46020c00 	.word	0x46020c00
 81fc584:	00f42400 	.word	0x00f42400
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_LPTIM2CLKSOURCE_HSI))
 81fc588:	6812      	ldr	r2, [r2, #0]
 81fc58a:	0552      	lsls	r2, r2, #21
 81fc58c:	d503      	bpl.n	81fc596 <HAL_RCCEx_GetPeriphCLKFreq+0x93e>
 81fc58e:	f5b3 2f00 	cmp.w	r3, #524288	@ 0x80000
 81fc592:	f000 8195 	beq.w	81fc8c0 <HAL_RCCEx_GetPeriphCLKFreq+0xc68>
    else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_LPTIM2CLKSOURCE_LSE))
 81fc596:	4abe      	ldr	r2, [pc, #760]	@ (81fc890 <HAL_RCCEx_GetPeriphCLKFreq+0xc38>)
 81fc598:	f8d2 00f0 	ldr.w	r0, [r2, #240]	@ 0xf0
 81fc59c:	f010 0002 	ands.w	r0, r0, #2
 81fc5a0:	f43f ab9b 	beq.w	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
 81fc5a4:	f5a3 2040 	sub.w	r0, r3, #786432	@ 0xc0000
 81fc5a8:	4243      	negs	r3, r0
 81fc5aa:	4143      	adcs	r3, r0
 81fc5ac:	03d8      	lsls	r0, r3, #15
 81fc5ae:	f7ff bb94 	b.w	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
    srcclk = __HAL_RCC_GET_FDCAN1_SOURCE();
 81fc5b2:	4ab7      	ldr	r2, [pc, #732]	@ (81fc890 <HAL_RCCEx_GetPeriphCLKFreq+0xc38>)
 81fc5b4:	f8d2 30e0 	ldr.w	r3, [r2, #224]	@ 0xe0
    if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)) && (srcclk == RCC_FDCAN1CLKSOURCE_HSE))
 81fc5b8:	6812      	ldr	r2, [r2, #0]
    srcclk = __HAL_RCC_GET_FDCAN1_SOURCE();
 81fc5ba:	f003 7340 	and.w	r3, r3, #50331648	@ 0x3000000
    if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)) && (srcclk == RCC_FDCAN1CLKSOURCE_HSE))
 81fc5be:	0391      	lsls	r1, r2, #14
 81fc5c0:	d502      	bpl.n	81fc5c8 <HAL_RCCEx_GetPeriphCLKFreq+0x970>
 81fc5c2:	2b00      	cmp	r3, #0
 81fc5c4:	f000 817f 	beq.w	81fc8c6 <HAL_RCCEx_GetPeriphCLKFreq+0xc6e>
    else if (srcclk == RCC_FDCAN1CLKSOURCE_PLL1) /* PLL1 ? */
 81fc5c8:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
 81fc5cc:	d105      	bne.n	81fc5da <HAL_RCCEx_GetPeriphCLKFreq+0x982>
      HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
 81fc5ce:	a801      	add	r0, sp, #4
 81fc5d0:	f7ff f974 	bl	81fb8bc <HAL_RCCEx_GetPLL1ClockFreq>
      frequency = pll1_clocks.PLL1_Q_Frequency;
 81fc5d4:	9802      	ldr	r0, [sp, #8]
 81fc5d6:	f7ff bb80 	b.w	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
    else if (srcclk == RCC_FDCAN1CLKSOURCE_PLL2) /* PLL2 ? */
 81fc5da:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
 81fc5de:	f040 8175 	bne.w	81fc8cc <HAL_RCCEx_GetPeriphCLKFreq+0xc74>
      HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 81fc5e2:	a801      	add	r0, sp, #4
 81fc5e4:	f7ff fa04 	bl	81fb9f0 <HAL_RCCEx_GetPLL2ClockFreq>
      frequency = pll2_clocks.PLL2_P_Frequency;
 81fc5e8:	9801      	ldr	r0, [sp, #4]
 81fc5ea:	f7ff bb76 	b.w	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
    srcclk = __HAL_RCC_GET_SPI1_SOURCE();
 81fc5ee:	4ba8      	ldr	r3, [pc, #672]	@ (81fc890 <HAL_RCCEx_GetPeriphCLKFreq+0xc38>)
 81fc5f0:	f8d3 20e0 	ldr.w	r2, [r3, #224]	@ 0xe0
 81fc5f4:	f402 1240 	and.w	r2, r2, #3145728	@ 0x300000
    switch (srcclk)
 81fc5f8:	f5b2 1f00 	cmp.w	r2, #2097152	@ 0x200000
 81fc5fc:	d010      	beq.n	81fc620 <HAL_RCCEx_GetPeriphCLKFreq+0x9c8>
 81fc5fe:	d809      	bhi.n	81fc614 <HAL_RCCEx_GetPeriphCLKFreq+0x9bc>
 81fc600:	2a00      	cmp	r2, #0
 81fc602:	f43f ad03 	beq.w	81fc00c <HAL_RCCEx_GetPeriphCLKFreq+0x3b4>
 81fc606:	f5b2 1f80 	cmp.w	r2, #1048576	@ 0x100000
 81fc60a:	f43f ad06 	beq.w	81fc01a <HAL_RCCEx_GetPeriphCLKFreq+0x3c2>
          frequency = 0U;
 81fc60e:	2000      	movs	r0, #0
 81fc610:	f7ff bb63 	b.w	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
    switch (srcclk)
 81fc614:	f5b2 1f40 	cmp.w	r2, #3145728	@ 0x300000
 81fc618:	d00a      	beq.n	81fc630 <HAL_RCCEx_GetPeriphCLKFreq+0x9d8>
          frequency = 0U;
 81fc61a:	2000      	movs	r0, #0
 81fc61c:	f7ff bb5d 	b.w	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
 81fc620:	6818      	ldr	r0, [r3, #0]
          frequency = HSI_VALUE;
 81fc622:	4b9c      	ldr	r3, [pc, #624]	@ (81fc894 <HAL_RCCEx_GetPeriphCLKFreq+0xc3c>)
 81fc624:	f410 6080 	ands.w	r0, r0, #1024	@ 0x400
 81fc628:	bf18      	it	ne
 81fc62a:	4618      	movne	r0, r3
 81fc62c:	f7ff bb55 	b.w	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIKRDY))
 81fc630:	6818      	ldr	r0, [r3, #0]
 81fc632:	f010 0020 	ands.w	r0, r0, #32
 81fc636:	f43f ab50 	beq.w	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
          frequency = MSIRangeTable[(__HAL_RCC_GET_MSIK_RANGE() >> RCC_ICSCR1_MSIKRANGE_Pos)];
 81fc63a:	689a      	ldr	r2, [r3, #8]
 81fc63c:	0212      	lsls	r2, r2, #8
 81fc63e:	bf4c      	ite	mi
 81fc640:	689b      	ldrmi	r3, [r3, #8]
 81fc642:	f8d3 30f4 	ldrpl.w	r3, [r3, #244]	@ 0xf4
 81fc646:	4a94      	ldr	r2, [pc, #592]	@ (81fc898 <HAL_RCCEx_GetPeriphCLKFreq+0xc40>)
 81fc648:	bf4c      	ite	mi
 81fc64a:	f3c3 6303 	ubfxmi	r3, r3, #24, #4
 81fc64e:	f3c3 2303 	ubfxpl	r3, r3, #8, #4
 81fc652:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
 81fc656:	f7ff bb40 	b.w	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
    srcclk = __HAL_RCC_GET_SPI2_SOURCE();
 81fc65a:	4b8d      	ldr	r3, [pc, #564]	@ (81fc890 <HAL_RCCEx_GetPeriphCLKFreq+0xc38>)
 81fc65c:	f8d3 20e0 	ldr.w	r2, [r3, #224]	@ 0xe0
 81fc660:	f402 3240 	and.w	r2, r2, #196608	@ 0x30000
    switch (srcclk)
 81fc664:	f5b2 3f00 	cmp.w	r2, #131072	@ 0x20000
 81fc668:	d010      	beq.n	81fc68c <HAL_RCCEx_GetPeriphCLKFreq+0xa34>
 81fc66a:	d809      	bhi.n	81fc680 <HAL_RCCEx_GetPeriphCLKFreq+0xa28>
 81fc66c:	2a00      	cmp	r2, #0
 81fc66e:	f43f acf4 	beq.w	81fc05a <HAL_RCCEx_GetPeriphCLKFreq+0x402>
 81fc672:	f5b2 3f80 	cmp.w	r2, #65536	@ 0x10000
 81fc676:	f43f acd0 	beq.w	81fc01a <HAL_RCCEx_GetPeriphCLKFreq+0x3c2>
          frequency = 0U;
 81fc67a:	2000      	movs	r0, #0
 81fc67c:	f7ff bb2d 	b.w	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
    switch (srcclk)
 81fc680:	f5b2 3f40 	cmp.w	r2, #196608	@ 0x30000
 81fc684:	d00a      	beq.n	81fc69c <HAL_RCCEx_GetPeriphCLKFreq+0xa44>
          frequency = 0U;
 81fc686:	2000      	movs	r0, #0
 81fc688:	f7ff bb27 	b.w	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
 81fc68c:	6818      	ldr	r0, [r3, #0]
          frequency = HSI_VALUE;
 81fc68e:	4b81      	ldr	r3, [pc, #516]	@ (81fc894 <HAL_RCCEx_GetPeriphCLKFreq+0xc3c>)
 81fc690:	f410 6080 	ands.w	r0, r0, #1024	@ 0x400
 81fc694:	bf18      	it	ne
 81fc696:	4618      	movne	r0, r3
 81fc698:	f7ff bb1f 	b.w	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIKRDY))
 81fc69c:	6818      	ldr	r0, [r3, #0]
 81fc69e:	f010 0020 	ands.w	r0, r0, #32
 81fc6a2:	f43f ab1a 	beq.w	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
          frequency = MSIRangeTable[(__HAL_RCC_GET_MSIK_RANGE() >> RCC_ICSCR1_MSIKRANGE_Pos)];
 81fc6a6:	689a      	ldr	r2, [r3, #8]
 81fc6a8:	0210      	lsls	r0, r2, #8
 81fc6aa:	bf4c      	ite	mi
 81fc6ac:	689b      	ldrmi	r3, [r3, #8]
 81fc6ae:	f8d3 30f4 	ldrpl.w	r3, [r3, #244]	@ 0xf4
 81fc6b2:	4a79      	ldr	r2, [pc, #484]	@ (81fc898 <HAL_RCCEx_GetPeriphCLKFreq+0xc40>)
 81fc6b4:	bf4c      	ite	mi
 81fc6b6:	f3c3 6303 	ubfxmi	r3, r3, #24, #4
 81fc6ba:	f3c3 2303 	ubfxpl	r3, r3, #8, #4
 81fc6be:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
 81fc6c2:	f7ff bb0a 	b.w	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
    srcclk = __HAL_RCC_GET_SPI3_SOURCE();
 81fc6c6:	4b72      	ldr	r3, [pc, #456]	@ (81fc890 <HAL_RCCEx_GetPeriphCLKFreq+0xc38>)
 81fc6c8:	f8d3 20e8 	ldr.w	r2, [r3, #232]	@ 0xe8
 81fc6cc:	f002 0218 	and.w	r2, r2, #24
    switch (srcclk)
 81fc6d0:	2a10      	cmp	r2, #16
 81fc6d2:	d00e      	beq.n	81fc6f2 <HAL_RCCEx_GetPeriphCLKFreq+0xa9a>
 81fc6d4:	d808      	bhi.n	81fc6e8 <HAL_RCCEx_GetPeriphCLKFreq+0xa90>
 81fc6d6:	2a00      	cmp	r2, #0
 81fc6d8:	f43f ad36 	beq.w	81fc148 <HAL_RCCEx_GetPeriphCLKFreq+0x4f0>
 81fc6dc:	2a08      	cmp	r2, #8
 81fc6de:	f43f ac9c 	beq.w	81fc01a <HAL_RCCEx_GetPeriphCLKFreq+0x3c2>
          frequency = 0U;
 81fc6e2:	2000      	movs	r0, #0
 81fc6e4:	f7ff baf9 	b.w	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
    switch (srcclk)
 81fc6e8:	2a18      	cmp	r2, #24
 81fc6ea:	d00a      	beq.n	81fc702 <HAL_RCCEx_GetPeriphCLKFreq+0xaaa>
          frequency = 0U;
 81fc6ec:	2000      	movs	r0, #0
 81fc6ee:	f7ff baf4 	b.w	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
 81fc6f2:	6818      	ldr	r0, [r3, #0]
          frequency = HSI_VALUE;
 81fc6f4:	4b67      	ldr	r3, [pc, #412]	@ (81fc894 <HAL_RCCEx_GetPeriphCLKFreq+0xc3c>)
 81fc6f6:	f410 6080 	ands.w	r0, r0, #1024	@ 0x400
 81fc6fa:	bf18      	it	ne
 81fc6fc:	4618      	movne	r0, r3
 81fc6fe:	f7ff baec 	b.w	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIKRDY))
 81fc702:	6818      	ldr	r0, [r3, #0]
 81fc704:	f010 0020 	ands.w	r0, r0, #32
 81fc708:	f43f aae7 	beq.w	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
          frequency = MSIRangeTable[(__HAL_RCC_GET_MSIK_RANGE() >> RCC_ICSCR1_MSIKRANGE_Pos)];
 81fc70c:	689a      	ldr	r2, [r3, #8]
 81fc70e:	0211      	lsls	r1, r2, #8
 81fc710:	bf4c      	ite	mi
 81fc712:	689b      	ldrmi	r3, [r3, #8]
 81fc714:	f8d3 30f4 	ldrpl.w	r3, [r3, #244]	@ 0xf4
 81fc718:	4a5f      	ldr	r2, [pc, #380]	@ (81fc898 <HAL_RCCEx_GetPeriphCLKFreq+0xc40>)
 81fc71a:	bf4c      	ite	mi
 81fc71c:	f3c3 6303 	ubfxmi	r3, r3, #24, #4
 81fc720:	f3c3 2303 	ubfxpl	r3, r3, #8, #4
 81fc724:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
 81fc728:	f7ff bad7 	b.w	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
    srcclk = __HAL_RCC_GET_OSPI_SOURCE();
 81fc72c:	4a58      	ldr	r2, [pc, #352]	@ (81fc890 <HAL_RCCEx_GetPeriphCLKFreq+0xc38>)
 81fc72e:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
 81fc732:	f403 1340 	and.w	r3, r3, #3145728	@ 0x300000
    switch (srcclk)
 81fc736:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
 81fc73a:	f43f abf0 	beq.w	81fbf1e <HAL_RCCEx_GetPeriphCLKFreq+0x2c6>
 81fc73e:	d808      	bhi.n	81fc752 <HAL_RCCEx_GetPeriphCLKFreq+0xafa>
 81fc740:	2b00      	cmp	r3, #0
 81fc742:	f43f ac6a 	beq.w	81fc01a <HAL_RCCEx_GetPeriphCLKFreq+0x3c2>
 81fc746:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
 81fc74a:	d009      	beq.n	81fc760 <HAL_RCCEx_GetPeriphCLKFreq+0xb08>
          frequency = 0U;
 81fc74c:	2000      	movs	r0, #0
 81fc74e:	f7ff bac4 	b.w	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
    switch (srcclk)
 81fc752:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
 81fc756:	f43f ac15 	beq.w	81fbf84 <HAL_RCCEx_GetPeriphCLKFreq+0x32c>
          frequency = 0U;
 81fc75a:	2000      	movs	r0, #0
 81fc75c:	f7ff babd 	b.w	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_MSIKRDY))
 81fc760:	6810      	ldr	r0, [r2, #0]
 81fc762:	f010 0020 	ands.w	r0, r0, #32
 81fc766:	f43f aab8 	beq.w	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
          frequency = MSIRangeTable[(__HAL_RCC_GET_MSIK_RANGE() >> RCC_ICSCR1_MSIKRANGE_Pos)];
 81fc76a:	4b49      	ldr	r3, [pc, #292]	@ (81fc890 <HAL_RCCEx_GetPeriphCLKFreq+0xc38>)
 81fc76c:	689a      	ldr	r2, [r3, #8]
 81fc76e:	0212      	lsls	r2, r2, #8
 81fc770:	bf4c      	ite	mi
 81fc772:	689b      	ldrmi	r3, [r3, #8]
 81fc774:	f8d3 30f4 	ldrpl.w	r3, [r3, #244]	@ 0xf4
 81fc778:	4a47      	ldr	r2, [pc, #284]	@ (81fc898 <HAL_RCCEx_GetPeriphCLKFreq+0xc40>)
 81fc77a:	bf4c      	ite	mi
 81fc77c:	f3c3 6303 	ubfxmi	r3, r3, #24, #4
 81fc780:	f3c3 2303 	ubfxpl	r3, r3, #8, #4
 81fc784:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
 81fc788:	f7ff baa7 	b.w	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
    srcclk = __HAL_RCC_GET_DAC1_SOURCE();
 81fc78c:	4a40      	ldr	r2, [pc, #256]	@ (81fc890 <HAL_RCCEx_GetPeriphCLKFreq+0xc38>)
 81fc78e:	f8d2 30e8 	ldr.w	r3, [r2, #232]	@ 0xe8
    if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_DAC1CLKSOURCE_LSE))
 81fc792:	f8d2 10f0 	ldr.w	r1, [r2, #240]	@ 0xf0
    srcclk = __HAL_RCC_GET_DAC1_SOURCE();
 81fc796:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
    if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSERDY)) && (srcclk == RCC_DAC1CLKSOURCE_LSE))
 81fc79a:	0788      	lsls	r0, r1, #30
 81fc79c:	d502      	bpl.n	81fc7a4 <HAL_RCCEx_GetPeriphCLKFreq+0xb4c>
 81fc79e:	2b00      	cmp	r3, #0
 81fc7a0:	f000 8097 	beq.w	81fc8d2 <HAL_RCCEx_GetPeriphCLKFreq+0xc7a>
    else if ((HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIRDY)) && (srcclk == RCC_DAC1CLKSOURCE_LSI))
 81fc7a4:	f8d2 00f0 	ldr.w	r0, [r2, #240]	@ 0xf0
 81fc7a8:	f010 6000 	ands.w	r0, r0, #134217728	@ 0x8000000
 81fc7ac:	f43f aa95 	beq.w	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
 81fc7b0:	2b00      	cmp	r3, #0
 81fc7b2:	f000 8092 	beq.w	81fc8da <HAL_RCCEx_GetPeriphCLKFreq+0xc82>
      if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSIPREDIV))
 81fc7b6:	f8d2 30f0 	ldr.w	r3, [r2, #240]	@ 0xf0
        frequency = LSI_VALUE / 128U;
 81fc7ba:	f013 5f80 	tst.w	r3, #268435456	@ 0x10000000
 81fc7be:	bf0c      	ite	eq
 81fc7c0:	f44f 40fa 	moveq.w	r0, #32000	@ 0x7d00
 81fc7c4:	20fa      	movne	r0, #250	@ 0xfa
 81fc7c6:	f7ff ba88 	b.w	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
    srcclk = __HAL_RCC_GET_RNG_SOURCE();
 81fc7ca:	4a31      	ldr	r2, [pc, #196]	@ (81fc890 <HAL_RCCEx_GetPeriphCLKFreq+0xc38>)
 81fc7cc:	f8d2 30e4 	ldr.w	r3, [r2, #228]	@ 0xe4
    if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSI48RDY)) && (srcclk == RCC_RNGCLKSOURCE_HSI48))
 81fc7d0:	6811      	ldr	r1, [r2, #0]
    srcclk = __HAL_RCC_GET_RNG_SOURCE();
 81fc7d2:	f403 5340 	and.w	r3, r3, #12288	@ 0x3000
    if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSI48RDY)) && (srcclk == RCC_RNGCLKSOURCE_HSI48))
 81fc7d6:	0489      	lsls	r1, r1, #18
 81fc7d8:	d502      	bpl.n	81fc7e0 <HAL_RCCEx_GetPeriphCLKFreq+0xb88>
 81fc7da:	2b00      	cmp	r3, #0
 81fc7dc:	f000 8080 	beq.w	81fc8e0 <HAL_RCCEx_GetPeriphCLKFreq+0xc88>
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSI48RDY)) && (srcclk == RCC_RNGCLKSOURCE_HSI48_DIV2))
 81fc7e0:	6812      	ldr	r2, [r2, #0]
 81fc7e2:	0492      	lsls	r2, r2, #18
 81fc7e4:	d502      	bpl.n	81fc7ec <HAL_RCCEx_GetPeriphCLKFreq+0xb94>
 81fc7e6:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 81fc7ea:	d07c      	beq.n	81fc8e6 <HAL_RCCEx_GetPeriphCLKFreq+0xc8e>
    else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (srcclk == RCC_RNGCLKSOURCE_HSI))
 81fc7ec:	4a28      	ldr	r2, [pc, #160]	@ (81fc890 <HAL_RCCEx_GetPeriphCLKFreq+0xc38>)
 81fc7ee:	6810      	ldr	r0, [r2, #0]
 81fc7f0:	f410 6080 	ands.w	r0, r0, #1024	@ 0x400
 81fc7f4:	f43f aa71 	beq.w	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
          frequency = HSI_VALUE;
 81fc7f8:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 81fc7fc:	4825      	ldr	r0, [pc, #148]	@ (81fc894 <HAL_RCCEx_GetPeriphCLKFreq+0xc3c>)
 81fc7fe:	bf18      	it	ne
 81fc800:	2000      	movne	r0, #0
 81fc802:	f7ff ba6a 	b.w	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
          frequency = 0U;
 81fc806:	2000      	movs	r0, #0
 81fc808:	f7ff ba67 	b.w	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
 81fc80c:	2000      	movs	r0, #0
 81fc80e:	f7ff ba64 	b.w	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
      frequency = LSE_VALUE;
 81fc812:	f44f 4000 	mov.w	r0, #32768	@ 0x8000
 81fc816:	f7ff ba60 	b.w	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
        frequency = EXTERNAL_SAI1_CLOCK_VALUE;
 81fc81a:	f64b 3080 	movw	r0, #48000	@ 0xbb80
 81fc81e:	f7ff ba5c 	b.w	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
 81fc822:	f64b 3080 	movw	r0, #48000	@ 0xbb80
 81fc826:	f7ff ba58 	b.w	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
          frequency = 0U;
 81fc82a:	2000      	movs	r0, #0
 81fc82c:	f7ff ba55 	b.w	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
          frequency = HSI_VALUE;
 81fc830:	4818      	ldr	r0, [pc, #96]	@ (81fc894 <HAL_RCCEx_GetPeriphCLKFreq+0xc3c>)
 81fc832:	f7ff ba52 	b.w	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
 81fc836:	4817      	ldr	r0, [pc, #92]	@ (81fc894 <HAL_RCCEx_GetPeriphCLKFreq+0xc3c>)
 81fc838:	f7ff ba4f 	b.w	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
 81fc83c:	4815      	ldr	r0, [pc, #84]	@ (81fc894 <HAL_RCCEx_GetPeriphCLKFreq+0xc3c>)
 81fc83e:	f7ff ba4c 	b.w	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
 81fc842:	4814      	ldr	r0, [pc, #80]	@ (81fc894 <HAL_RCCEx_GetPeriphCLKFreq+0xc3c>)
 81fc844:	f7ff ba49 	b.w	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
 81fc848:	4812      	ldr	r0, [pc, #72]	@ (81fc894 <HAL_RCCEx_GetPeriphCLKFreq+0xc3c>)
 81fc84a:	f7ff ba46 	b.w	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
 81fc84e:	4811      	ldr	r0, [pc, #68]	@ (81fc894 <HAL_RCCEx_GetPeriphCLKFreq+0xc3c>)
 81fc850:	f7ff ba43 	b.w	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
 81fc854:	480f      	ldr	r0, [pc, #60]	@ (81fc894 <HAL_RCCEx_GetPeriphCLKFreq+0xc3c>)
 81fc856:	f7ff ba40 	b.w	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
      frequency = LSE_VALUE;
 81fc85a:	f44f 4000 	mov.w	r0, #32768	@ 0x8000
 81fc85e:	f7ff ba3c 	b.w	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
          frequency = 0U;
 81fc862:	2000      	movs	r0, #0
 81fc864:	f7ff ba39 	b.w	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
          frequency = HSI_VALUE;
 81fc868:	480a      	ldr	r0, [pc, #40]	@ (81fc894 <HAL_RCCEx_GetPeriphCLKFreq+0xc3c>)
 81fc86a:	f7ff ba36 	b.w	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
        frequency = EXTERNAL_SAI1_CLOCK_VALUE;
 81fc86e:	f64b 3080 	movw	r0, #48000	@ 0xbb80
 81fc872:	f7ff ba32 	b.w	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
 81fc876:	f64b 3080 	movw	r0, #48000	@ 0xbb80
 81fc87a:	f7ff ba2e 	b.w	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
          frequency = 0U;
 81fc87e:	2000      	movs	r0, #0
 81fc880:	f7ff ba2b 	b.w	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
          frequency = HSI_VALUE;
 81fc884:	4803      	ldr	r0, [pc, #12]	@ (81fc894 <HAL_RCCEx_GetPeriphCLKFreq+0xc3c>)
 81fc886:	f7ff ba28 	b.w	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
          frequency = 0U;
 81fc88a:	2000      	movs	r0, #0
 81fc88c:	f7ff ba25 	b.w	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
 81fc890:	46020c00 	.word	0x46020c00
 81fc894:	00f42400 	.word	0x00f42400
 81fc898:	081fe8d8 	.word	0x081fe8d8
          frequency = HSI_VALUE;
 81fc89c:	4813      	ldr	r0, [pc, #76]	@ (81fc8ec <HAL_RCCEx_GetPeriphCLKFreq+0xc94>)
 81fc89e:	f7ff ba1c 	b.w	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
          frequency = 0U;
 81fc8a2:	2000      	movs	r0, #0
 81fc8a4:	f7ff ba19 	b.w	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
          frequency = HSI_VALUE;
 81fc8a8:	4810      	ldr	r0, [pc, #64]	@ (81fc8ec <HAL_RCCEx_GetPeriphCLKFreq+0xc94>)
 81fc8aa:	f7ff ba16 	b.w	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
          frequency = 0U;
 81fc8ae:	2000      	movs	r0, #0
 81fc8b0:	f7ff ba13 	b.w	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
          frequency = HSI_VALUE;
 81fc8b4:	480d      	ldr	r0, [pc, #52]	@ (81fc8ec <HAL_RCCEx_GetPeriphCLKFreq+0xc94>)
 81fc8b6:	f7ff ba10 	b.w	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
 81fc8ba:	480c      	ldr	r0, [pc, #48]	@ (81fc8ec <HAL_RCCEx_GetPeriphCLKFreq+0xc94>)
 81fc8bc:	f7ff ba0d 	b.w	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
 81fc8c0:	480a      	ldr	r0, [pc, #40]	@ (81fc8ec <HAL_RCCEx_GetPeriphCLKFreq+0xc94>)
 81fc8c2:	f7ff ba0a 	b.w	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
 81fc8c6:	4809      	ldr	r0, [pc, #36]	@ (81fc8ec <HAL_RCCEx_GetPeriphCLKFreq+0xc94>)
 81fc8c8:	f7ff ba07 	b.w	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
          frequency = 0U;
 81fc8cc:	2000      	movs	r0, #0
 81fc8ce:	f7ff ba04 	b.w	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
      frequency = LSE_VALUE;
 81fc8d2:	f44f 4000 	mov.w	r0, #32768	@ 0x8000
 81fc8d6:	f7ff ba00 	b.w	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
          frequency = 0U;
 81fc8da:	4618      	mov	r0, r3
 81fc8dc:	f7ff b9fd 	b.w	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
          frequency = HSI48_VALUE;
 81fc8e0:	4803      	ldr	r0, [pc, #12]	@ (81fc8f0 <HAL_RCCEx_GetPeriphCLKFreq+0xc98>)
 81fc8e2:	f7ff b9fa 	b.w	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
      frequency = HSI48_VALUE >> 1U ;
 81fc8e6:	4803      	ldr	r0, [pc, #12]	@ (81fc8f4 <HAL_RCCEx_GetPeriphCLKFreq+0xc9c>)
 81fc8e8:	f7ff b9f7 	b.w	81fbcda <HAL_RCCEx_GetPeriphCLKFreq+0x82>
 81fc8ec:	00f42400 	.word	0x00f42400
 81fc8f0:	02dc6c00 	.word	0x02dc6c00
 81fc8f4:	016e3600 	.word	0x016e3600

081fc8f8 <UART_EndRxTransfer>:
  * @brief  End ongoing Rx transfer on UART peripheral (following error detection or Reception completion).
  * @param  huart UART handle.
  * @retval None
  */
static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
{
 81fc8f8:	b510      	push	{r4, lr}
  /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
 81fc8fa:	6802      	ldr	r2, [r0, #0]
 */
__STATIC_FORCEINLINE uint32_t __LDREXW(volatile uint32_t *addr)
{
    uint32_t result;

   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 81fc8fc:	e852 3f00 	ldrex	r3, [r2]
 81fc900:	f423 7390 	bic.w	r3, r3, #288	@ 0x120
 */
__STATIC_FORCEINLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
{
   uint32_t result;

   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 81fc904:	e842 3100 	strex	r1, r3, [r2]
   return(result);
 81fc908:	6802      	ldr	r2, [r0, #0]
 81fc90a:	2900      	cmp	r1, #0
 81fc90c:	d1f5      	bne.n	81fc8fa <UART_EndRxTransfer+0x2>
  ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
 81fc90e:	4c0f      	ldr	r4, [pc, #60]	@ (81fc94c <UART_EndRxTransfer+0x54>)
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 81fc910:	f102 0308 	add.w	r3, r2, #8
 81fc914:	e853 3f00 	ldrex	r3, [r3]
 81fc918:	4023      	ands	r3, r4
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 81fc91a:	f102 0c08 	add.w	ip, r2, #8
 81fc91e:	e84c 3100 	strex	r1, r3, [ip]
 81fc922:	2900      	cmp	r1, #0
 81fc924:	d1f4      	bne.n	81fc910 <UART_EndRxTransfer+0x18>

  /* In case of reception waiting for IDLE event, disable also the IDLE IE interrupt source */
  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 81fc926:	6ec3      	ldr	r3, [r0, #108]	@ 0x6c
 81fc928:	2b01      	cmp	r3, #1
 81fc92a:	d107      	bne.n	81fc93c <UART_EndRxTransfer+0x44>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 81fc92c:	e852 3f00 	ldrex	r3, [r2]
  {
    ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 81fc930:	f023 0310 	bic.w	r3, r3, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 81fc934:	e842 3100 	strex	r1, r3, [r2]
 81fc938:	2900      	cmp	r1, #0
 81fc93a:	d1f7      	bne.n	81fc92c <UART_EndRxTransfer+0x34>
  }

  /* At end of Rx process, restore huart->RxState to Ready */
  huart->RxState = HAL_UART_STATE_READY;
 81fc93c:	2320      	movs	r3, #32
 81fc93e:	f8c0 308c 	str.w	r3, [r0, #140]	@ 0x8c
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 81fc942:	2300      	movs	r3, #0
 81fc944:	66c3      	str	r3, [r0, #108]	@ 0x6c

  /* Reset RxIsr function pointer */
  huart->RxISR = NULL;
 81fc946:	6743      	str	r3, [r0, #116]	@ 0x74
}
 81fc948:	bd10      	pop	{r4, pc}
 81fc94a:	bf00      	nop
 81fc94c:	effffffe 	.word	0xeffffffe

081fc950 <UART_SetConfig>:
{
 81fc950:	b538      	push	{r3, r4, r5, lr}
 81fc952:	4604      	mov	r4, r0
  if (UART_INSTANCE_LOWPOWER(huart))
 81fc954:	6803      	ldr	r3, [r0, #0]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 81fc956:	69c1      	ldr	r1, [r0, #28]
 81fc958:	6882      	ldr	r2, [r0, #8]
 81fc95a:	6900      	ldr	r0, [r0, #16]
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 81fc95c:	681d      	ldr	r5, [r3, #0]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 81fc95e:	4302      	orrs	r2, r0
 81fc960:	6960      	ldr	r0, [r4, #20]
 81fc962:	4302      	orrs	r2, r0
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 81fc964:	485c      	ldr	r0, [pc, #368]	@ (81fcad8 <UART_SetConfig+0x188>)
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 81fc966:	430a      	orrs	r2, r1
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 81fc968:	4028      	ands	r0, r5
 81fc96a:	4302      	orrs	r2, r0
 81fc96c:	601a      	str	r2, [r3, #0]
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 81fc96e:	685a      	ldr	r2, [r3, #4]
 81fc970:	68e0      	ldr	r0, [r4, #12]
 81fc972:	f422 5240 	bic.w	r2, r2, #12288	@ 0x3000
 81fc976:	4302      	orrs	r2, r0
 81fc978:	605a      	str	r2, [r3, #4]
  if (!(UART_INSTANCE_LOWPOWER(huart)))
 81fc97a:	4a58      	ldr	r2, [pc, #352]	@ (81fcadc <UART_SetConfig+0x18c>)
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;
 81fc97c:	69a0      	ldr	r0, [r4, #24]
  if (!(UART_INSTANCE_LOWPOWER(huart)))
 81fc97e:	4293      	cmp	r3, r2
 81fc980:	d005      	beq.n	81fc98e <UART_SetConfig+0x3e>
 81fc982:	f102 5280 	add.w	r2, r2, #268435456	@ 0x10000000
 81fc986:	4293      	cmp	r3, r2
    tmpreg |= huart->Init.OneBitSampling;
 81fc988:	bf1c      	itt	ne
 81fc98a:	6a22      	ldrne	r2, [r4, #32]
 81fc98c:	4310      	orrne	r0, r2
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 81fc98e:	689a      	ldr	r2, [r3, #8]
 81fc990:	f022 426e 	bic.w	r2, r2, #3992977408	@ 0xee000000
 81fc994:	f422 6230 	bic.w	r2, r2, #2816	@ 0xb00
 81fc998:	4302      	orrs	r2, r0
 81fc99a:	609a      	str	r2, [r3, #8]
  MODIFY_REG(huart->Instance->PRESC, USART_PRESC_PRESCALER, huart->Init.ClockPrescaler);
 81fc99c:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 81fc99e:	6a60      	ldr	r0, [r4, #36]	@ 0x24
 81fc9a0:	f022 020f 	bic.w	r2, r2, #15
 81fc9a4:	4302      	orrs	r2, r0
 81fc9a6:	62da      	str	r2, [r3, #44]	@ 0x2c
  UART_GETCLOCKSOURCE(huart, clocksource);
 81fc9a8:	4a4d      	ldr	r2, [pc, #308]	@ (81fcae0 <UART_SetConfig+0x190>)
 81fc9aa:	4293      	cmp	r3, r2
 81fc9ac:	d04e      	beq.n	81fca4c <UART_SetConfig+0xfc>
 81fc9ae:	f5a2 4274 	sub.w	r2, r2, #62464	@ 0xf400
 81fc9b2:	4293      	cmp	r3, r2
 81fc9b4:	d06f      	beq.n	81fca96 <UART_SetConfig+0x146>
 81fc9b6:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
 81fc9ba:	4293      	cmp	r3, r2
 81fc9bc:	d06d      	beq.n	81fca9a <UART_SetConfig+0x14a>
 81fc9be:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
 81fc9c2:	4293      	cmp	r3, r2
 81fc9c4:	d06b      	beq.n	81fca9e <UART_SetConfig+0x14e>
 81fc9c6:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
 81fc9ca:	4293      	cmp	r3, r2
 81fc9cc:	d069      	beq.n	81fcaa2 <UART_SetConfig+0x152>
 81fc9ce:	4a43      	ldr	r2, [pc, #268]	@ (81fcadc <UART_SetConfig+0x18c>)
 81fc9d0:	4293      	cmp	r3, r2
 81fc9d2:	d01c      	beq.n	81fca0e <UART_SetConfig+0xbe>
  if (UART_INSTANCE_LOWPOWER(huart))
 81fc9d4:	f102 5280 	add.w	r2, r2, #268435456	@ 0x10000000
 81fc9d8:	4293      	cmp	r3, r2
  UART_GETCLOCKSOURCE(huart, clocksource);
 81fc9da:	f04f 0000 	mov.w	r0, #0
  if (UART_INSTANCE_LOWPOWER(huart))
 81fc9de:	d136      	bne.n	81fca4e <UART_SetConfig+0xfe>
    pclk = HAL_RCCEx_GetPeriphCLKFreq(clocksource);
 81fc9e0:	2100      	movs	r1, #0
 81fc9e2:	f7ff f939 	bl	81fbc58 <HAL_RCCEx_GetPeriphCLKFreq>
    if (pclk != 0U)
 81fc9e6:	b378      	cbz	r0, 81fca48 <UART_SetConfig+0xf8>
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
 81fc9e8:	6a61      	ldr	r1, [r4, #36]	@ 0x24
 81fc9ea:	4a3e      	ldr	r2, [pc, #248]	@ (81fcae4 <UART_SetConfig+0x194>)
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 81fc9ec:	6865      	ldr	r5, [r4, #4]
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
 81fc9ee:	f832 2011 	ldrh.w	r2, [r2, r1, lsl #1]
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 81fc9f2:	eb05 0145 	add.w	r1, r5, r5, lsl #1
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
 81fc9f6:	fbb0 f3f2 	udiv	r3, r0, r2
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 81fc9fa:	4299      	cmp	r1, r3
 81fc9fc:	d909      	bls.n	81fca12 <UART_SetConfig+0xc2>
        ret = HAL_ERROR;
 81fc9fe:	2001      	movs	r0, #1
  huart->NbRxDataToProcess = 1;
 81fca00:	f04f 1301 	mov.w	r3, #65537	@ 0x10001
 81fca04:	66a3      	str	r3, [r4, #104]	@ 0x68
  huart->RxISR = NULL;
 81fca06:	2300      	movs	r3, #0
  huart->TxISR = NULL;
 81fca08:	e9c4 331d 	strd	r3, r3, [r4, #116]	@ 0x74
}
 81fca0c:	bd38      	pop	{r3, r4, r5, pc}
  UART_GETCLOCKSOURCE(huart, clocksource);
 81fca0e:	2020      	movs	r0, #32
 81fca10:	e7e6      	b.n	81fc9e0 <UART_SetConfig+0x90>
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 81fca12:	ebb3 3f05 	cmp.w	r3, r5, lsl #12
 81fca16:	d8f2      	bhi.n	81fc9fe <UART_SetConfig+0xae>
        usartdiv = (uint32_t)(UART_DIV_LPUART(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 81fca18:	2300      	movs	r3, #0
 81fca1a:	4619      	mov	r1, r3
 81fca1c:	f001 fac4 	bl	81fdfa8 <__aeabi_uldivmod>
 81fca20:	0209      	lsls	r1, r1, #8
 81fca22:	ea41 6110 	orr.w	r1, r1, r0, lsr #24
 81fca26:	086b      	lsrs	r3, r5, #1
 81fca28:	0200      	lsls	r0, r0, #8
 81fca2a:	18c0      	adds	r0, r0, r3
 81fca2c:	462a      	mov	r2, r5
 81fca2e:	f04f 0300 	mov.w	r3, #0
 81fca32:	f141 0100 	adc.w	r1, r1, #0
 81fca36:	f001 fab7 	bl	81fdfa8 <__aeabi_uldivmod>
        if ((usartdiv >= LPUART_BRR_MIN) && (usartdiv <= LPUART_BRR_MAX))
 81fca3a:	4b2b      	ldr	r3, [pc, #172]	@ (81fcae8 <UART_SetConfig+0x198>)
 81fca3c:	f5a0 7240 	sub.w	r2, r0, #768	@ 0x300
 81fca40:	429a      	cmp	r2, r3
 81fca42:	d8dc      	bhi.n	81fc9fe <UART_SetConfig+0xae>
          huart->Instance->BRR = usartdiv;
 81fca44:	6823      	ldr	r3, [r4, #0]
 81fca46:	60d8      	str	r0, [r3, #12]
  HAL_StatusTypeDef ret               = HAL_OK;
 81fca48:	2000      	movs	r0, #0
 81fca4a:	e7d9      	b.n	81fca00 <UART_SetConfig+0xb0>
  UART_GETCLOCKSOURCE(huart, clocksource);
 81fca4c:	2001      	movs	r0, #1
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 81fca4e:	f5b1 4f00 	cmp.w	r1, #32768	@ 0x8000
    pclk = HAL_RCCEx_GetPeriphCLKFreq(clocksource);
 81fca52:	f04f 0100 	mov.w	r1, #0
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 81fca56:	d126      	bne.n	81fcaa6 <UART_SetConfig+0x156>
    pclk = HAL_RCCEx_GetPeriphCLKFreq(clocksource);
 81fca58:	f7ff f8fe 	bl	81fbc58 <HAL_RCCEx_GetPeriphCLKFreq>
    if (pclk != 0U)
 81fca5c:	2800      	cmp	r0, #0
 81fca5e:	d0f3      	beq.n	81fca48 <UART_SetConfig+0xf8>
      usartdiv = (uint32_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 81fca60:	6a61      	ldr	r1, [r4, #36]	@ 0x24
 81fca62:	4b20      	ldr	r3, [pc, #128]	@ (81fcae4 <UART_SetConfig+0x194>)
 81fca64:	6862      	ldr	r2, [r4, #4]
 81fca66:	f833 3011 	ldrh.w	r3, [r3, r1, lsl #1]
 81fca6a:	fbb0 f0f3 	udiv	r0, r0, r3
 81fca6e:	0853      	lsrs	r3, r2, #1
 81fca70:	eb03 0340 	add.w	r3, r3, r0, lsl #1
 81fca74:	fbb3 f3f2 	udiv	r3, r3, r2
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 81fca78:	f64f 72ef 	movw	r2, #65519	@ 0xffef
 81fca7c:	f1a3 0110 	sub.w	r1, r3, #16
 81fca80:	4291      	cmp	r1, r2
 81fca82:	d8bc      	bhi.n	81fc9fe <UART_SetConfig+0xae>
        brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
 81fca84:	f023 020f 	bic.w	r2, r3, #15
        huart->Instance->BRR = brrtemp;
 81fca88:	6821      	ldr	r1, [r4, #0]
        brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
 81fca8a:	b292      	uxth	r2, r2
        brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
 81fca8c:	f3c3 0342 	ubfx	r3, r3, #1, #3
        huart->Instance->BRR = brrtemp;
 81fca90:	4313      	orrs	r3, r2
 81fca92:	60cb      	str	r3, [r1, #12]
 81fca94:	e7d8      	b.n	81fca48 <UART_SetConfig+0xf8>
  UART_GETCLOCKSOURCE(huart, clocksource);
 81fca96:	2002      	movs	r0, #2
 81fca98:	e7d9      	b.n	81fca4e <UART_SetConfig+0xfe>
 81fca9a:	2004      	movs	r0, #4
 81fca9c:	e7d7      	b.n	81fca4e <UART_SetConfig+0xfe>
 81fca9e:	2008      	movs	r0, #8
 81fcaa0:	e7d5      	b.n	81fca4e <UART_SetConfig+0xfe>
 81fcaa2:	2010      	movs	r0, #16
 81fcaa4:	e7d3      	b.n	81fca4e <UART_SetConfig+0xfe>
    pclk = HAL_RCCEx_GetPeriphCLKFreq(clocksource);
 81fcaa6:	f7ff f8d7 	bl	81fbc58 <HAL_RCCEx_GetPeriphCLKFreq>
    if (pclk != 0U)
 81fcaaa:	2800      	cmp	r0, #0
 81fcaac:	d0cc      	beq.n	81fca48 <UART_SetConfig+0xf8>
      usartdiv = (uint32_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 81fcaae:	6a61      	ldr	r1, [r4, #36]	@ 0x24
 81fcab0:	4b0c      	ldr	r3, [pc, #48]	@ (81fcae4 <UART_SetConfig+0x194>)
 81fcab2:	6862      	ldr	r2, [r4, #4]
 81fcab4:	f833 3011 	ldrh.w	r3, [r3, r1, lsl #1]
 81fcab8:	fbb0 f3f3 	udiv	r3, r0, r3
 81fcabc:	eb03 0352 	add.w	r3, r3, r2, lsr #1
 81fcac0:	fbb3 f3f2 	udiv	r3, r3, r2
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 81fcac4:	f64f 72ef 	movw	r2, #65519	@ 0xffef
 81fcac8:	f1a3 0110 	sub.w	r1, r3, #16
 81fcacc:	4291      	cmp	r1, r2
 81fcace:	d896      	bhi.n	81fc9fe <UART_SetConfig+0xae>
        huart->Instance->BRR = (uint16_t)usartdiv;
 81fcad0:	6822      	ldr	r2, [r4, #0]
 81fcad2:	60d3      	str	r3, [r2, #12]
 81fcad4:	e7b8      	b.n	81fca48 <UART_SetConfig+0xf8>
 81fcad6:	bf00      	nop
 81fcad8:	cfff69f3 	.word	0xcfff69f3
 81fcadc:	46002400 	.word	0x46002400
 81fcae0:	40013800 	.word	0x40013800
 81fcae4:	081fe9b0 	.word	0x081fe9b0
 81fcae8:	000ffcff 	.word	0x000ffcff

081fcaec <UART_AdvFeatureConfig>:
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 81fcaec:	6a83      	ldr	r3, [r0, #40]	@ 0x28
{
 81fcaee:	b510      	push	{r4, lr}
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 81fcaf0:	07da      	lsls	r2, r3, #31
 81fcaf2:	d506      	bpl.n	81fcb02 <UART_AdvFeatureConfig+0x16>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
 81fcaf4:	6801      	ldr	r1, [r0, #0]
 81fcaf6:	6ac4      	ldr	r4, [r0, #44]	@ 0x2c
 81fcaf8:	684a      	ldr	r2, [r1, #4]
 81fcafa:	f422 3200 	bic.w	r2, r2, #131072	@ 0x20000
 81fcafe:	4322      	orrs	r2, r4
 81fcb00:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
 81fcb02:	079c      	lsls	r4, r3, #30
 81fcb04:	d506      	bpl.n	81fcb14 <UART_AdvFeatureConfig+0x28>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
 81fcb06:	6801      	ldr	r1, [r0, #0]
 81fcb08:	6b04      	ldr	r4, [r0, #48]	@ 0x30
 81fcb0a:	684a      	ldr	r2, [r1, #4]
 81fcb0c:	f422 3280 	bic.w	r2, r2, #65536	@ 0x10000
 81fcb10:	4322      	orrs	r2, r4
 81fcb12:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
 81fcb14:	0759      	lsls	r1, r3, #29
 81fcb16:	d506      	bpl.n	81fcb26 <UART_AdvFeatureConfig+0x3a>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
 81fcb18:	6801      	ldr	r1, [r0, #0]
 81fcb1a:	6b44      	ldr	r4, [r0, #52]	@ 0x34
 81fcb1c:	684a      	ldr	r2, [r1, #4]
 81fcb1e:	f422 2280 	bic.w	r2, r2, #262144	@ 0x40000
 81fcb22:	4322      	orrs	r2, r4
 81fcb24:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
 81fcb26:	071a      	lsls	r2, r3, #28
 81fcb28:	d506      	bpl.n	81fcb38 <UART_AdvFeatureConfig+0x4c>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
 81fcb2a:	6801      	ldr	r1, [r0, #0]
 81fcb2c:	6b84      	ldr	r4, [r0, #56]	@ 0x38
 81fcb2e:	684a      	ldr	r2, [r1, #4]
 81fcb30:	f422 4200 	bic.w	r2, r2, #32768	@ 0x8000
 81fcb34:	4322      	orrs	r2, r4
 81fcb36:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
 81fcb38:	06dc      	lsls	r4, r3, #27
 81fcb3a:	d506      	bpl.n	81fcb4a <UART_AdvFeatureConfig+0x5e>
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
 81fcb3c:	6801      	ldr	r1, [r0, #0]
 81fcb3e:	6bc4      	ldr	r4, [r0, #60]	@ 0x3c
 81fcb40:	688a      	ldr	r2, [r1, #8]
 81fcb42:	f422 5280 	bic.w	r2, r2, #4096	@ 0x1000
 81fcb46:	4322      	orrs	r2, r4
 81fcb48:	608a      	str	r2, [r1, #8]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
 81fcb4a:	0699      	lsls	r1, r3, #26
 81fcb4c:	d506      	bpl.n	81fcb5c <UART_AdvFeatureConfig+0x70>
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
 81fcb4e:	6801      	ldr	r1, [r0, #0]
 81fcb50:	6c04      	ldr	r4, [r0, #64]	@ 0x40
 81fcb52:	688a      	ldr	r2, [r1, #8]
 81fcb54:	f422 5200 	bic.w	r2, r2, #8192	@ 0x2000
 81fcb58:	4322      	orrs	r2, r4
 81fcb5a:	608a      	str	r2, [r1, #8]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
 81fcb5c:	065a      	lsls	r2, r3, #25
 81fcb5e:	d510      	bpl.n	81fcb82 <UART_AdvFeatureConfig+0x96>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 81fcb60:	6801      	ldr	r1, [r0, #0]
 81fcb62:	6c44      	ldr	r4, [r0, #68]	@ 0x44
 81fcb64:	684a      	ldr	r2, [r1, #4]
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 81fcb66:	f5b4 1f80 	cmp.w	r4, #1048576	@ 0x100000
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 81fcb6a:	f422 1280 	bic.w	r2, r2, #1048576	@ 0x100000
 81fcb6e:	ea42 0204 	orr.w	r2, r2, r4
 81fcb72:	604a      	str	r2, [r1, #4]
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 81fcb74:	d105      	bne.n	81fcb82 <UART_AdvFeatureConfig+0x96>
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
 81fcb76:	684a      	ldr	r2, [r1, #4]
 81fcb78:	6c84      	ldr	r4, [r0, #72]	@ 0x48
 81fcb7a:	f422 02c0 	bic.w	r2, r2, #6291456	@ 0x600000
 81fcb7e:	4322      	orrs	r2, r4
 81fcb80:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
 81fcb82:	061b      	lsls	r3, r3, #24
 81fcb84:	d506      	bpl.n	81fcb94 <UART_AdvFeatureConfig+0xa8>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
 81fcb86:	6802      	ldr	r2, [r0, #0]
 81fcb88:	6cc1      	ldr	r1, [r0, #76]	@ 0x4c
 81fcb8a:	6853      	ldr	r3, [r2, #4]
 81fcb8c:	f423 2300 	bic.w	r3, r3, #524288	@ 0x80000
 81fcb90:	430b      	orrs	r3, r1
 81fcb92:	6053      	str	r3, [r2, #4]
}
 81fcb94:	bd10      	pop	{r4, pc}

081fcb96 <UART_WaitOnFlagUntilTimeout>:
{
 81fcb96:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 81fcb9a:	4604      	mov	r4, r0
 81fcb9c:	460f      	mov	r7, r1
 81fcb9e:	4616      	mov	r6, r2
 81fcba0:	4698      	mov	r8, r3
 81fcba2:	f8dd 9020 	ldr.w	r9, [sp, #32]
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 81fcba6:	6822      	ldr	r2, [r4, #0]
 81fcba8:	69d3      	ldr	r3, [r2, #28]
 81fcbaa:	ea37 0303 	bics.w	r3, r7, r3
 81fcbae:	bf0c      	ite	eq
 81fcbb0:	2301      	moveq	r3, #1
 81fcbb2:	2300      	movne	r3, #0
 81fcbb4:	42b3      	cmp	r3, r6
 81fcbb6:	d001      	beq.n	81fcbbc <UART_WaitOnFlagUntilTimeout+0x26>
  return HAL_OK;
 81fcbb8:	2000      	movs	r0, #0
 81fcbba:	e01e      	b.n	81fcbfa <UART_WaitOnFlagUntilTimeout+0x64>
    if (Timeout != HAL_MAX_DELAY)
 81fcbbc:	f1b9 3fff 	cmp.w	r9, #4294967295	@ 0xffffffff
 81fcbc0:	d0f2      	beq.n	81fcba8 <UART_WaitOnFlagUntilTimeout+0x12>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 81fcbc2:	f7fe f877 	bl	81facb4 <HAL_GetTick>
 81fcbc6:	eba0 0008 	sub.w	r0, r0, r8
 81fcbca:	4548      	cmp	r0, r9
 81fcbcc:	d825      	bhi.n	81fcc1a <UART_WaitOnFlagUntilTimeout+0x84>
 81fcbce:	f1b9 0f00 	cmp.w	r9, #0
 81fcbd2:	d022      	beq.n	81fcc1a <UART_WaitOnFlagUntilTimeout+0x84>
      if (READ_BIT(huart->Instance->CR1, USART_CR1_RE) != 0U)
 81fcbd4:	6820      	ldr	r0, [r4, #0]
 81fcbd6:	6803      	ldr	r3, [r0, #0]
 81fcbd8:	075a      	lsls	r2, r3, #29
 81fcbda:	d5e4      	bpl.n	81fcba6 <UART_WaitOnFlagUntilTimeout+0x10>
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_ORE) == SET)
 81fcbdc:	69c5      	ldr	r5, [r0, #28]
 81fcbde:	f015 0508 	ands.w	r5, r5, #8
 81fcbe2:	d00c      	beq.n	81fcbfe <UART_WaitOnFlagUntilTimeout+0x68>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF);
 81fcbe4:	2508      	movs	r5, #8
 81fcbe6:	6205      	str	r5, [r0, #32]
          UART_EndRxTransfer(huart);
 81fcbe8:	4620      	mov	r0, r4
 81fcbea:	f7ff fe85 	bl	81fc8f8 <UART_EndRxTransfer>
          __HAL_UNLOCK(huart);
 81fcbee:	2300      	movs	r3, #0
          return HAL_ERROR;
 81fcbf0:	2001      	movs	r0, #1
          huart->ErrorCode = HAL_UART_ERROR_ORE;
 81fcbf2:	f8c4 5090 	str.w	r5, [r4, #144]	@ 0x90
          __HAL_UNLOCK(huart);
 81fcbf6:	f884 3084 	strb.w	r3, [r4, #132]	@ 0x84
}
 81fcbfa:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_RTOF) == SET)
 81fcbfe:	69c3      	ldr	r3, [r0, #28]
 81fcc00:	051b      	lsls	r3, r3, #20
 81fcc02:	d5d0      	bpl.n	81fcba6 <UART_WaitOnFlagUntilTimeout+0x10>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
 81fcc04:	f44f 6300 	mov.w	r3, #2048	@ 0x800
 81fcc08:	6203      	str	r3, [r0, #32]
          UART_EndRxTransfer(huart);
 81fcc0a:	4620      	mov	r0, r4
 81fcc0c:	f7ff fe74 	bl	81fc8f8 <UART_EndRxTransfer>
          huart->ErrorCode = HAL_UART_ERROR_RTO;
 81fcc10:	2320      	movs	r3, #32
          __HAL_UNLOCK(huart);
 81fcc12:	f884 5084 	strb.w	r5, [r4, #132]	@ 0x84
          huart->ErrorCode = HAL_UART_ERROR_RTO;
 81fcc16:	f8c4 3090 	str.w	r3, [r4, #144]	@ 0x90
        return HAL_TIMEOUT;
 81fcc1a:	2003      	movs	r0, #3
 81fcc1c:	e7ed      	b.n	81fcbfa <UART_WaitOnFlagUntilTimeout+0x64>

081fcc1e <HAL_UART_Transmit>:
{
 81fcc1e:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 81fcc22:	4698      	mov	r8, r3
  if (huart->gState == HAL_UART_STATE_READY)
 81fcc24:	f8d0 3088 	ldr.w	r3, [r0, #136]	@ 0x88
{
 81fcc28:	4604      	mov	r4, r0
  if (huart->gState == HAL_UART_STATE_READY)
 81fcc2a:	2b20      	cmp	r3, #32
{
 81fcc2c:	460e      	mov	r6, r1
 81fcc2e:	4617      	mov	r7, r2
  if (huart->gState == HAL_UART_STATE_READY)
 81fcc30:	d14e      	bne.n	81fccd0 <HAL_UART_Transmit+0xb2>
    if ((pData == NULL) || (Size == 0U))
 81fcc32:	2900      	cmp	r1, #0
 81fcc34:	d04e      	beq.n	81fccd4 <HAL_UART_Transmit+0xb6>
 81fcc36:	2a00      	cmp	r2, #0
 81fcc38:	d04c      	beq.n	81fccd4 <HAL_UART_Transmit+0xb6>
    if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
 81fcc3a:	6803      	ldr	r3, [r0, #0]
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 81fcc3c:	2500      	movs	r5, #0
    if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
 81fcc3e:	689a      	ldr	r2, [r3, #8]
 81fcc40:	0612      	lsls	r2, r2, #24
      CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
 81fcc42:	bf42      	ittt	mi
 81fcc44:	689a      	ldrmi	r2, [r3, #8]
 81fcc46:	f022 0280 	bicmi.w	r2, r2, #128	@ 0x80
 81fcc4a:	609a      	strmi	r2, [r3, #8]
    huart->gState = HAL_UART_STATE_BUSY_TX;
 81fcc4c:	2321      	movs	r3, #33	@ 0x21
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 81fcc4e:	f8c0 5090 	str.w	r5, [r0, #144]	@ 0x90
    huart->gState = HAL_UART_STATE_BUSY_TX;
 81fcc52:	f8c0 3088 	str.w	r3, [r0, #136]	@ 0x88
    tickstart = HAL_GetTick();
 81fcc56:	f7fe f82d 	bl	81facb4 <HAL_GetTick>
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 81fcc5a:	68a3      	ldr	r3, [r4, #8]
    tickstart = HAL_GetTick();
 81fcc5c:	4681      	mov	r9, r0
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 81fcc5e:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
    huart->TxXferSize  = Size;
 81fcc62:	f8a4 7054 	strh.w	r7, [r4, #84]	@ 0x54
    huart->TxXferCount = Size;
 81fcc66:	f8a4 7056 	strh.w	r7, [r4, #86]	@ 0x56
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 81fcc6a:	d103      	bne.n	81fcc74 <HAL_UART_Transmit+0x56>
 81fcc6c:	6923      	ldr	r3, [r4, #16]
 81fcc6e:	b90b      	cbnz	r3, 81fcc74 <HAL_UART_Transmit+0x56>
 81fcc70:	4635      	mov	r5, r6
      pdata8bits  = NULL;
 81fcc72:	461e      	mov	r6, r3
    while (huart->TxXferCount > 0U)
 81fcc74:	f8b4 2056 	ldrh.w	r2, [r4, #86]	@ 0x56
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
 81fcc78:	464b      	mov	r3, r9
    while (huart->TxXferCount > 0U)
 81fcc7a:	b292      	uxth	r2, r2
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
 81fcc7c:	f8cd 8000 	str.w	r8, [sp]
    while (huart->TxXferCount > 0U)
 81fcc80:	b942      	cbnz	r2, 81fcc94 <HAL_UART_Transmit+0x76>
    if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
 81fcc82:	2140      	movs	r1, #64	@ 0x40
 81fcc84:	4620      	mov	r0, r4
 81fcc86:	f7ff ff86 	bl	81fcb96 <UART_WaitOnFlagUntilTimeout>
 81fcc8a:	2320      	movs	r3, #32
 81fcc8c:	b948      	cbnz	r0, 81fcca2 <HAL_UART_Transmit+0x84>
    huart->gState = HAL_UART_STATE_READY;
 81fcc8e:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
    return HAL_OK;
 81fcc92:	e009      	b.n	81fcca8 <HAL_UART_Transmit+0x8a>
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
 81fcc94:	2200      	movs	r2, #0
 81fcc96:	2180      	movs	r1, #128	@ 0x80
 81fcc98:	4620      	mov	r0, r4
 81fcc9a:	f7ff ff7c 	bl	81fcb96 <UART_WaitOnFlagUntilTimeout>
 81fcc9e:	b130      	cbz	r0, 81fccae <HAL_UART_Transmit+0x90>
        huart->gState = HAL_UART_STATE_READY;
 81fcca0:	2320      	movs	r3, #32
        return HAL_TIMEOUT;
 81fcca2:	2003      	movs	r0, #3
        huart->gState = HAL_UART_STATE_READY;
 81fcca4:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
}
 81fcca8:	b003      	add	sp, #12
 81fccaa:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        huart->Instance->TDR = (uint16_t)(*pdata16bits & 0x01FFU);
 81fccae:	6822      	ldr	r2, [r4, #0]
      if (pdata8bits == NULL)
 81fccb0:	b95e      	cbnz	r6, 81fccca <HAL_UART_Transmit+0xac>
        huart->Instance->TDR = (uint16_t)(*pdata16bits & 0x01FFU);
 81fccb2:	f835 3b02 	ldrh.w	r3, [r5], #2
 81fccb6:	f3c3 0308 	ubfx	r3, r3, #0, #9
        huart->Instance->TDR = (uint8_t)(*pdata8bits & 0xFFU);
 81fccba:	6293      	str	r3, [r2, #40]	@ 0x28
      huart->TxXferCount--;
 81fccbc:	f8b4 2056 	ldrh.w	r2, [r4, #86]	@ 0x56
 81fccc0:	3a01      	subs	r2, #1
 81fccc2:	b292      	uxth	r2, r2
 81fccc4:	f8a4 2056 	strh.w	r2, [r4, #86]	@ 0x56
 81fccc8:	e7d4      	b.n	81fcc74 <HAL_UART_Transmit+0x56>
        huart->Instance->TDR = (uint8_t)(*pdata8bits & 0xFFU);
 81fccca:	f816 3b01 	ldrb.w	r3, [r6], #1
 81fccce:	e7f4      	b.n	81fccba <HAL_UART_Transmit+0x9c>
    return HAL_BUSY;
 81fccd0:	2002      	movs	r0, #2
 81fccd2:	e7e9      	b.n	81fcca8 <HAL_UART_Transmit+0x8a>
      return  HAL_ERROR;
 81fccd4:	2001      	movs	r0, #1
 81fccd6:	e7e7      	b.n	81fcca8 <HAL_UART_Transmit+0x8a>

081fccd8 <HAL_UART_Receive>:
{
 81fccd8:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 81fccdc:	4698      	mov	r8, r3
  if (huart->RxState == HAL_UART_STATE_READY)
 81fccde:	f8d0 308c 	ldr.w	r3, [r0, #140]	@ 0x8c
{
 81fcce2:	4604      	mov	r4, r0
  if (huart->RxState == HAL_UART_STATE_READY)
 81fcce4:	2b20      	cmp	r3, #32
{
 81fcce6:	460f      	mov	r7, r1
 81fcce8:	4616      	mov	r6, r2
  if (huart->RxState == HAL_UART_STATE_READY)
 81fccea:	d165      	bne.n	81fcdb8 <HAL_UART_Receive+0xe0>
    if ((pData == NULL) || (Size == 0U))
 81fccec:	2900      	cmp	r1, #0
 81fccee:	d065      	beq.n	81fcdbc <HAL_UART_Receive+0xe4>
 81fccf0:	2a00      	cmp	r2, #0
 81fccf2:	d063      	beq.n	81fcdbc <HAL_UART_Receive+0xe4>
    if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 81fccf4:	6803      	ldr	r3, [r0, #0]
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 81fccf6:	2500      	movs	r5, #0
    if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 81fccf8:	689a      	ldr	r2, [r3, #8]
 81fccfa:	0652      	lsls	r2, r2, #25
      CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 81fccfc:	bf42      	ittt	mi
 81fccfe:	689a      	ldrmi	r2, [r3, #8]
 81fcd00:	f022 0240 	bicmi.w	r2, r2, #64	@ 0x40
 81fcd04:	609a      	strmi	r2, [r3, #8]
    huart->RxState = HAL_UART_STATE_BUSY_RX;
 81fcd06:	2322      	movs	r3, #34	@ 0x22
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 81fcd08:	f8c0 5090 	str.w	r5, [r0, #144]	@ 0x90
    huart->RxState = HAL_UART_STATE_BUSY_RX;
 81fcd0c:	f8c0 308c 	str.w	r3, [r0, #140]	@ 0x8c
    huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 81fcd10:	66c5      	str	r5, [r0, #108]	@ 0x6c
    tickstart = HAL_GetTick();
 81fcd12:	f7fd ffcf 	bl	81facb4 <HAL_GetTick>
    UART_MASK_COMPUTATION(huart);
 81fcd16:	68a3      	ldr	r3, [r4, #8]
    tickstart = HAL_GetTick();
 81fcd18:	4681      	mov	r9, r0
    UART_MASK_COMPUTATION(huart);
 81fcd1a:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
    huart->RxXferSize  = Size;
 81fcd1e:	f8a4 605c 	strh.w	r6, [r4, #92]	@ 0x5c
    huart->RxXferCount = Size;
 81fcd22:	f8a4 605e 	strh.w	r6, [r4, #94]	@ 0x5e
    UART_MASK_COMPUTATION(huart);
 81fcd26:	d10d      	bne.n	81fcd44 <HAL_UART_Receive+0x6c>
 81fcd28:	6923      	ldr	r3, [r4, #16]
 81fcd2a:	b1c3      	cbz	r3, 81fcd5e <HAL_UART_Receive+0x86>
    uhMask = huart->Mask;
 81fcd2c:	26ff      	movs	r6, #255	@ 0xff
 81fcd2e:	4632      	mov	r2, r6
    UART_MASK_COMPUTATION(huart);
 81fcd30:	f8a4 2060 	strh.w	r2, [r4, #96]	@ 0x60
    while (huart->RxXferCount > 0U)
 81fcd34:	f8b4 005e 	ldrh.w	r0, [r4, #94]	@ 0x5e
 81fcd38:	b280      	uxth	r0, r0
 81fcd3a:	b9e8      	cbnz	r0, 81fcd78 <HAL_UART_Receive+0xa0>
    huart->RxState = HAL_UART_STATE_READY;
 81fcd3c:	2320      	movs	r3, #32
 81fcd3e:	f8c4 308c 	str.w	r3, [r4, #140]	@ 0x8c
    return HAL_OK;
 81fcd42:	e026      	b.n	81fcd92 <HAL_UART_Receive+0xba>
    UART_MASK_COMPUTATION(huart);
 81fcd44:	b923      	cbnz	r3, 81fcd50 <HAL_UART_Receive+0x78>
 81fcd46:	6925      	ldr	r5, [r4, #16]
 81fcd48:	b995      	cbnz	r5, 81fcd70 <HAL_UART_Receive+0x98>
 81fcd4a:	22ff      	movs	r2, #255	@ 0xff
    uhMask = huart->Mask;
 81fcd4c:	4616      	mov	r6, r2
 81fcd4e:	e7ef      	b.n	81fcd30 <HAL_UART_Receive+0x58>
    UART_MASK_COMPUTATION(huart);
 81fcd50:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
 81fcd54:	d109      	bne.n	81fcd6a <HAL_UART_Receive+0x92>
 81fcd56:	6923      	ldr	r3, [r4, #16]
 81fcd58:	b153      	cbz	r3, 81fcd70 <HAL_UART_Receive+0x98>
 81fcd5a:	223f      	movs	r2, #63	@ 0x3f
 81fcd5c:	e7f6      	b.n	81fcd4c <HAL_UART_Receive+0x74>
    uhMask = huart->Mask;
 81fcd5e:	f240 16ff 	movw	r6, #511	@ 0x1ff
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 81fcd62:	463d      	mov	r5, r7
 81fcd64:	4632      	mov	r2, r6
      pdata8bits  = NULL;
 81fcd66:	2700      	movs	r7, #0
 81fcd68:	e7e2      	b.n	81fcd30 <HAL_UART_Receive+0x58>
 81fcd6a:	462a      	mov	r2, r5
    uhMask = huart->Mask;
 81fcd6c:	462e      	mov	r6, r5
 81fcd6e:	e7df      	b.n	81fcd30 <HAL_UART_Receive+0x58>
 81fcd70:	227f      	movs	r2, #127	@ 0x7f
      pdata16bits = NULL;
 81fcd72:	461d      	mov	r5, r3
    uhMask = huart->Mask;
 81fcd74:	4616      	mov	r6, r2
 81fcd76:	e7db      	b.n	81fcd30 <HAL_UART_Receive+0x58>
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_RXNE, RESET, tickstart, Timeout) != HAL_OK)
 81fcd78:	464b      	mov	r3, r9
 81fcd7a:	2200      	movs	r2, #0
 81fcd7c:	2120      	movs	r1, #32
 81fcd7e:	4620      	mov	r0, r4
 81fcd80:	f8cd 8000 	str.w	r8, [sp]
 81fcd84:	f7ff ff07 	bl	81fcb96 <UART_WaitOnFlagUntilTimeout>
 81fcd88:	b130      	cbz	r0, 81fcd98 <HAL_UART_Receive+0xc0>
        huart->RxState = HAL_UART_STATE_READY;
 81fcd8a:	2320      	movs	r3, #32
        return HAL_TIMEOUT;
 81fcd8c:	2003      	movs	r0, #3
        huart->RxState = HAL_UART_STATE_READY;
 81fcd8e:	f8c4 308c 	str.w	r3, [r4, #140]	@ 0x8c
}
 81fcd92:	b003      	add	sp, #12
 81fcd94:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        *pdata16bits = (uint16_t)(huart->Instance->RDR & uhMask);
 81fcd98:	6823      	ldr	r3, [r4, #0]
 81fcd9a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 81fcd9c:	4033      	ands	r3, r6
      if (pdata8bits == NULL)
 81fcd9e:	b947      	cbnz	r7, 81fcdb2 <HAL_UART_Receive+0xda>
        *pdata16bits = (uint16_t)(huart->Instance->RDR & uhMask);
 81fcda0:	f825 3b02 	strh.w	r3, [r5], #2
      huart->RxXferCount--;
 81fcda4:	f8b4 305e 	ldrh.w	r3, [r4, #94]	@ 0x5e
 81fcda8:	3b01      	subs	r3, #1
 81fcdaa:	b29b      	uxth	r3, r3
 81fcdac:	f8a4 305e 	strh.w	r3, [r4, #94]	@ 0x5e
 81fcdb0:	e7c0      	b.n	81fcd34 <HAL_UART_Receive+0x5c>
        *pdata8bits = (uint8_t)(huart->Instance->RDR & (uint8_t)uhMask);
 81fcdb2:	f807 3b01 	strb.w	r3, [r7], #1
        pdata8bits++;
 81fcdb6:	e7f5      	b.n	81fcda4 <HAL_UART_Receive+0xcc>
    return HAL_BUSY;
 81fcdb8:	2002      	movs	r0, #2
 81fcdba:	e7ea      	b.n	81fcd92 <HAL_UART_Receive+0xba>
      return  HAL_ERROR;
 81fcdbc:	2001      	movs	r0, #1
 81fcdbe:	e7e8      	b.n	81fcd92 <HAL_UART_Receive+0xba>

081fcdc0 <UART_CheckIdleState>:
{
 81fcdc0:	b573      	push	{r0, r1, r4, r5, r6, lr}
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 81fcdc2:	2600      	movs	r6, #0
{
 81fcdc4:	4604      	mov	r4, r0
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 81fcdc6:	f8c0 6090 	str.w	r6, [r0, #144]	@ 0x90
  tickstart = HAL_GetTick();
 81fcdca:	f7fd ff73 	bl	81facb4 <HAL_GetTick>
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 81fcdce:	6823      	ldr	r3, [r4, #0]
  tickstart = HAL_GetTick();
 81fcdd0:	4605      	mov	r5, r0
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 81fcdd2:	681b      	ldr	r3, [r3, #0]
 81fcdd4:	071a      	lsls	r2, r3, #28
 81fcdd6:	d51c      	bpl.n	81fce12 <UART_CheckIdleState+0x52>
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 81fcdd8:	f06f 437e 	mvn.w	r3, #4261412864	@ 0xfe000000
 81fcddc:	4632      	mov	r2, r6
 81fcdde:	9300      	str	r3, [sp, #0]
 81fcde0:	f44f 1100 	mov.w	r1, #2097152	@ 0x200000
 81fcde4:	4603      	mov	r3, r0
 81fcde6:	4620      	mov	r0, r4
 81fcde8:	f7ff fed5 	bl	81fcb96 <UART_WaitOnFlagUntilTimeout>
 81fcdec:	b188      	cbz	r0, 81fce12 <UART_CheckIdleState+0x52>
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE_TXFNFIE));
 81fcdee:	6822      	ldr	r2, [r4, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 81fcdf0:	e852 3f00 	ldrex	r3, [r2]
 81fcdf4:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 81fcdf8:	e842 3100 	strex	r1, r3, [r2]
 81fcdfc:	2900      	cmp	r1, #0
 81fcdfe:	d1f6      	bne.n	81fcdee <UART_CheckIdleState+0x2e>
      huart->gState = HAL_UART_STATE_READY;
 81fce00:	2320      	movs	r3, #32
 81fce02:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
      return HAL_TIMEOUT;
 81fce06:	2003      	movs	r0, #3
      __HAL_UNLOCK(huart);
 81fce08:	2300      	movs	r3, #0
 81fce0a:	f884 3084 	strb.w	r3, [r4, #132]	@ 0x84
}
 81fce0e:	b002      	add	sp, #8
 81fce10:	bd70      	pop	{r4, r5, r6, pc}
  if ((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
 81fce12:	6823      	ldr	r3, [r4, #0]
 81fce14:	681b      	ldr	r3, [r3, #0]
 81fce16:	075b      	lsls	r3, r3, #29
 81fce18:	d524      	bpl.n	81fce64 <UART_CheckIdleState+0xa4>
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 81fce1a:	f06f 437e 	mvn.w	r3, #4261412864	@ 0xfe000000
 81fce1e:	2200      	movs	r2, #0
 81fce20:	9300      	str	r3, [sp, #0]
 81fce22:	f44f 0180 	mov.w	r1, #4194304	@ 0x400000
 81fce26:	462b      	mov	r3, r5
 81fce28:	4620      	mov	r0, r4
 81fce2a:	f7ff feb4 	bl	81fcb96 <UART_WaitOnFlagUntilTimeout>
 81fce2e:	b1c8      	cbz	r0, 81fce64 <UART_CheckIdleState+0xa4>
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
 81fce30:	6822      	ldr	r2, [r4, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 81fce32:	e852 3f00 	ldrex	r3, [r2]
 81fce36:	f423 7390 	bic.w	r3, r3, #288	@ 0x120
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 81fce3a:	e842 3100 	strex	r1, r3, [r2]
   return(result);
 81fce3e:	6822      	ldr	r2, [r4, #0]
 81fce40:	2900      	cmp	r1, #0
 81fce42:	d1f5      	bne.n	81fce30 <UART_CheckIdleState+0x70>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 81fce44:	f102 0308 	add.w	r3, r2, #8
 81fce48:	e853 3f00 	ldrex	r3, [r3]
      ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 81fce4c:	f023 0301 	bic.w	r3, r3, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 81fce50:	f102 0008 	add.w	r0, r2, #8
 81fce54:	e840 3100 	strex	r1, r3, [r0]
 81fce58:	2900      	cmp	r1, #0
 81fce5a:	d1f3      	bne.n	81fce44 <UART_CheckIdleState+0x84>
      huart->RxState = HAL_UART_STATE_READY;
 81fce5c:	2320      	movs	r3, #32
 81fce5e:	f8c4 308c 	str.w	r3, [r4, #140]	@ 0x8c
      return HAL_TIMEOUT;
 81fce62:	e7d0      	b.n	81fce06 <UART_CheckIdleState+0x46>
  huart->gState = HAL_UART_STATE_READY;
 81fce64:	2320      	movs	r3, #32
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 81fce66:	2000      	movs	r0, #0
  huart->gState = HAL_UART_STATE_READY;
 81fce68:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
  huart->RxState = HAL_UART_STATE_READY;
 81fce6c:	f8c4 308c 	str.w	r3, [r4, #140]	@ 0x8c
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 81fce70:	66e0      	str	r0, [r4, #108]	@ 0x6c
  huart->RxEventType = HAL_UART_RXEVENT_TC;
 81fce72:	6720      	str	r0, [r4, #112]	@ 0x70
  return HAL_OK;
 81fce74:	e7c8      	b.n	81fce08 <UART_CheckIdleState+0x48>

081fce76 <HAL_UART_Init>:
{
 81fce76:	b510      	push	{r4, lr}
  if (huart == NULL)
 81fce78:	4604      	mov	r4, r0
 81fce7a:	b350      	cbz	r0, 81fced2 <HAL_UART_Init+0x5c>
  if (huart->gState == HAL_UART_STATE_RESET)
 81fce7c:	f8d0 3088 	ldr.w	r3, [r0, #136]	@ 0x88
 81fce80:	b91b      	cbnz	r3, 81fce8a <HAL_UART_Init+0x14>
    huart->Lock = HAL_UNLOCKED;
 81fce82:	f880 3084 	strb.w	r3, [r0, #132]	@ 0x84
    HAL_UART_MspInit(huart);
 81fce86:	f7fd fa5d 	bl	81fa344 <HAL_UART_MspInit>
  huart->gState = HAL_UART_STATE_BUSY;
 81fce8a:	2324      	movs	r3, #36	@ 0x24
  __HAL_UART_DISABLE(huart);
 81fce8c:	6822      	ldr	r2, [r4, #0]
  huart->gState = HAL_UART_STATE_BUSY;
 81fce8e:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
  __HAL_UART_DISABLE(huart);
 81fce92:	6813      	ldr	r3, [r2, #0]
  if (UART_SetConfig(huart) == HAL_ERROR)
 81fce94:	4620      	mov	r0, r4
  __HAL_UART_DISABLE(huart);
 81fce96:	f023 0301 	bic.w	r3, r3, #1
 81fce9a:	6013      	str	r3, [r2, #0]
  if (UART_SetConfig(huart) == HAL_ERROR)
 81fce9c:	f7ff fd58 	bl	81fc950 <UART_SetConfig>
 81fcea0:	2801      	cmp	r0, #1
 81fcea2:	d016      	beq.n	81fced2 <HAL_UART_Init+0x5c>
  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
 81fcea4:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
 81fcea6:	b113      	cbz	r3, 81fceae <HAL_UART_Init+0x38>
    UART_AdvFeatureConfig(huart);
 81fcea8:	4620      	mov	r0, r4
 81fceaa:	f7ff fe1f 	bl	81fcaec <UART_AdvFeatureConfig>
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 81fceae:	6823      	ldr	r3, [r4, #0]
  return (UART_CheckIdleState(huart));
 81fceb0:	4620      	mov	r0, r4
}
 81fceb2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 81fceb6:	685a      	ldr	r2, [r3, #4]
 81fceb8:	f422 4290 	bic.w	r2, r2, #18432	@ 0x4800
 81fcebc:	605a      	str	r2, [r3, #4]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 81fcebe:	689a      	ldr	r2, [r3, #8]
 81fcec0:	f022 022a 	bic.w	r2, r2, #42	@ 0x2a
 81fcec4:	609a      	str	r2, [r3, #8]
  __HAL_UART_ENABLE(huart);
 81fcec6:	681a      	ldr	r2, [r3, #0]
 81fcec8:	f042 0201 	orr.w	r2, r2, #1
 81fcecc:	601a      	str	r2, [r3, #0]
  return (UART_CheckIdleState(huart));
 81fcece:	f7ff bf77 	b.w	81fcdc0 <UART_CheckIdleState>
}
 81fced2:	2001      	movs	r0, #1
 81fced4:	bd10      	pop	{r4, pc}
	...

081fced8 <exit>:
 81fced8:	b508      	push	{r3, lr}
 81fceda:	4b06      	ldr	r3, [pc, #24]	@ (81fcef4 <exit+0x1c>)
 81fcedc:	4604      	mov	r4, r0
 81fcede:	b113      	cbz	r3, 81fcee6 <exit+0xe>
 81fcee0:	2100      	movs	r1, #0
 81fcee2:	f3af 8000 	nop.w
 81fcee6:	4b04      	ldr	r3, [pc, #16]	@ (81fcef8 <exit+0x20>)
 81fcee8:	681b      	ldr	r3, [r3, #0]
 81fceea:	b103      	cbz	r3, 81fceee <exit+0x16>
 81fceec:	4798      	blx	r3
 81fceee:	4620      	mov	r0, r4
 81fcef0:	f001 fa1c 	bl	81fe32c <_exit>
 81fcef4:	00000000 	.word	0x00000000
 81fcef8:	20000730 	.word	0x20000730

081fcefc <std>:
 81fcefc:	2300      	movs	r3, #0
 81fcefe:	b510      	push	{r4, lr}
 81fcf00:	4604      	mov	r4, r0
 81fcf02:	6083      	str	r3, [r0, #8]
 81fcf04:	8181      	strh	r1, [r0, #12]
 81fcf06:	4619      	mov	r1, r3
 81fcf08:	6643      	str	r3, [r0, #100]	@ 0x64
 81fcf0a:	81c2      	strh	r2, [r0, #14]
 81fcf0c:	2208      	movs	r2, #8
 81fcf0e:	6183      	str	r3, [r0, #24]
 81fcf10:	e9c0 3300 	strd	r3, r3, [r0]
 81fcf14:	e9c0 3304 	strd	r3, r3, [r0, #16]
 81fcf18:	305c      	adds	r0, #92	@ 0x5c
 81fcf1a:	f000 faad 	bl	81fd478 <memset>
 81fcf1e:	4b0d      	ldr	r3, [pc, #52]	@ (81fcf54 <std+0x58>)
 81fcf20:	6224      	str	r4, [r4, #32]
 81fcf22:	6263      	str	r3, [r4, #36]	@ 0x24
 81fcf24:	4b0c      	ldr	r3, [pc, #48]	@ (81fcf58 <std+0x5c>)
 81fcf26:	62a3      	str	r3, [r4, #40]	@ 0x28
 81fcf28:	4b0c      	ldr	r3, [pc, #48]	@ (81fcf5c <std+0x60>)
 81fcf2a:	62e3      	str	r3, [r4, #44]	@ 0x2c
 81fcf2c:	4b0c      	ldr	r3, [pc, #48]	@ (81fcf60 <std+0x64>)
 81fcf2e:	6323      	str	r3, [r4, #48]	@ 0x30
 81fcf30:	4b0c      	ldr	r3, [pc, #48]	@ (81fcf64 <std+0x68>)
 81fcf32:	429c      	cmp	r4, r3
 81fcf34:	d006      	beq.n	81fcf44 <std+0x48>
 81fcf36:	f103 0268 	add.w	r2, r3, #104	@ 0x68
 81fcf3a:	4294      	cmp	r4, r2
 81fcf3c:	d002      	beq.n	81fcf44 <std+0x48>
 81fcf3e:	33d0      	adds	r3, #208	@ 0xd0
 81fcf40:	429c      	cmp	r4, r3
 81fcf42:	d105      	bne.n	81fcf50 <std+0x54>
 81fcf44:	f104 0058 	add.w	r0, r4, #88	@ 0x58
 81fcf48:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 81fcf4c:	f000 bb06 	b.w	81fd55c <__retarget_lock_init_recursive>
 81fcf50:	bd10      	pop	{r4, pc}
 81fcf52:	bf00      	nop
 81fcf54:	081fd2c9 	.word	0x081fd2c9
 81fcf58:	081fd2eb 	.word	0x081fd2eb
 81fcf5c:	081fd323 	.word	0x081fd323
 81fcf60:	081fd347 	.word	0x081fd347
 81fcf64:	200005f8 	.word	0x200005f8

081fcf68 <stdio_exit_handler>:
 81fcf68:	4a02      	ldr	r2, [pc, #8]	@ (81fcf74 <stdio_exit_handler+0xc>)
 81fcf6a:	4903      	ldr	r1, [pc, #12]	@ (81fcf78 <stdio_exit_handler+0x10>)
 81fcf6c:	4803      	ldr	r0, [pc, #12]	@ (81fcf7c <stdio_exit_handler+0x14>)
 81fcf6e:	f000 b869 	b.w	81fd044 <_fwalk_sglue>
 81fcf72:	bf00      	nop
 81fcf74:	2000004c 	.word	0x2000004c
 81fcf78:	081fde15 	.word	0x081fde15
 81fcf7c:	2000005c 	.word	0x2000005c

081fcf80 <cleanup_stdio>:
 81fcf80:	6841      	ldr	r1, [r0, #4]
 81fcf82:	4b0c      	ldr	r3, [pc, #48]	@ (81fcfb4 <cleanup_stdio+0x34>)
 81fcf84:	4299      	cmp	r1, r3
 81fcf86:	b510      	push	{r4, lr}
 81fcf88:	4604      	mov	r4, r0
 81fcf8a:	d001      	beq.n	81fcf90 <cleanup_stdio+0x10>
 81fcf8c:	f000 ff42 	bl	81fde14 <_fflush_r>
 81fcf90:	68a1      	ldr	r1, [r4, #8]
 81fcf92:	4b09      	ldr	r3, [pc, #36]	@ (81fcfb8 <cleanup_stdio+0x38>)
 81fcf94:	4299      	cmp	r1, r3
 81fcf96:	d002      	beq.n	81fcf9e <cleanup_stdio+0x1e>
 81fcf98:	4620      	mov	r0, r4
 81fcf9a:	f000 ff3b 	bl	81fde14 <_fflush_r>
 81fcf9e:	68e1      	ldr	r1, [r4, #12]
 81fcfa0:	4b06      	ldr	r3, [pc, #24]	@ (81fcfbc <cleanup_stdio+0x3c>)
 81fcfa2:	4299      	cmp	r1, r3
 81fcfa4:	d004      	beq.n	81fcfb0 <cleanup_stdio+0x30>
 81fcfa6:	4620      	mov	r0, r4
 81fcfa8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 81fcfac:	f000 bf32 	b.w	81fde14 <_fflush_r>
 81fcfb0:	bd10      	pop	{r4, pc}
 81fcfb2:	bf00      	nop
 81fcfb4:	200005f8 	.word	0x200005f8
 81fcfb8:	20000660 	.word	0x20000660
 81fcfbc:	200006c8 	.word	0x200006c8

081fcfc0 <global_stdio_init.part.0>:
 81fcfc0:	b510      	push	{r4, lr}
 81fcfc2:	4b0b      	ldr	r3, [pc, #44]	@ (81fcff0 <global_stdio_init.part.0+0x30>)
 81fcfc4:	2104      	movs	r1, #4
 81fcfc6:	4c0b      	ldr	r4, [pc, #44]	@ (81fcff4 <global_stdio_init.part.0+0x34>)
 81fcfc8:	4a0b      	ldr	r2, [pc, #44]	@ (81fcff8 <global_stdio_init.part.0+0x38>)
 81fcfca:	4620      	mov	r0, r4
 81fcfcc:	601a      	str	r2, [r3, #0]
 81fcfce:	2200      	movs	r2, #0
 81fcfd0:	f7ff ff94 	bl	81fcefc <std>
 81fcfd4:	f104 0068 	add.w	r0, r4, #104	@ 0x68
 81fcfd8:	2201      	movs	r2, #1
 81fcfda:	2109      	movs	r1, #9
 81fcfdc:	f7ff ff8e 	bl	81fcefc <std>
 81fcfe0:	f104 00d0 	add.w	r0, r4, #208	@ 0xd0
 81fcfe4:	2202      	movs	r2, #2
 81fcfe6:	2112      	movs	r1, #18
 81fcfe8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 81fcfec:	f7ff bf86 	b.w	81fcefc <std>
 81fcff0:	20000730 	.word	0x20000730
 81fcff4:	200005f8 	.word	0x200005f8
 81fcff8:	081fcf69 	.word	0x081fcf69

081fcffc <__sfp_lock_acquire>:
 81fcffc:	4801      	ldr	r0, [pc, #4]	@ (81fd004 <__sfp_lock_acquire+0x8>)
 81fcffe:	f000 baae 	b.w	81fd55e <__retarget_lock_acquire_recursive>
 81fd002:	bf00      	nop
 81fd004:	20000739 	.word	0x20000739

081fd008 <__sfp_lock_release>:
 81fd008:	4801      	ldr	r0, [pc, #4]	@ (81fd010 <__sfp_lock_release+0x8>)
 81fd00a:	f000 baa9 	b.w	81fd560 <__retarget_lock_release_recursive>
 81fd00e:	bf00      	nop
 81fd010:	20000739 	.word	0x20000739

081fd014 <__sinit>:
 81fd014:	b510      	push	{r4, lr}
 81fd016:	4604      	mov	r4, r0
 81fd018:	f7ff fff0 	bl	81fcffc <__sfp_lock_acquire>
 81fd01c:	6a23      	ldr	r3, [r4, #32]
 81fd01e:	b11b      	cbz	r3, 81fd028 <__sinit+0x14>
 81fd020:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 81fd024:	f7ff bff0 	b.w	81fd008 <__sfp_lock_release>
 81fd028:	4b04      	ldr	r3, [pc, #16]	@ (81fd03c <__sinit+0x28>)
 81fd02a:	6223      	str	r3, [r4, #32]
 81fd02c:	4b04      	ldr	r3, [pc, #16]	@ (81fd040 <__sinit+0x2c>)
 81fd02e:	681b      	ldr	r3, [r3, #0]
 81fd030:	2b00      	cmp	r3, #0
 81fd032:	d1f5      	bne.n	81fd020 <__sinit+0xc>
 81fd034:	f7ff ffc4 	bl	81fcfc0 <global_stdio_init.part.0>
 81fd038:	e7f2      	b.n	81fd020 <__sinit+0xc>
 81fd03a:	bf00      	nop
 81fd03c:	081fcf81 	.word	0x081fcf81
 81fd040:	20000730 	.word	0x20000730

081fd044 <_fwalk_sglue>:
 81fd044:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 81fd048:	4607      	mov	r7, r0
 81fd04a:	4688      	mov	r8, r1
 81fd04c:	4614      	mov	r4, r2
 81fd04e:	2600      	movs	r6, #0
 81fd050:	e9d4 9501 	ldrd	r9, r5, [r4, #4]
 81fd054:	f1b9 0901 	subs.w	r9, r9, #1
 81fd058:	d505      	bpl.n	81fd066 <_fwalk_sglue+0x22>
 81fd05a:	6824      	ldr	r4, [r4, #0]
 81fd05c:	2c00      	cmp	r4, #0
 81fd05e:	d1f7      	bne.n	81fd050 <_fwalk_sglue+0xc>
 81fd060:	4630      	mov	r0, r6
 81fd062:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 81fd066:	89ab      	ldrh	r3, [r5, #12]
 81fd068:	2b01      	cmp	r3, #1
 81fd06a:	d907      	bls.n	81fd07c <_fwalk_sglue+0x38>
 81fd06c:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
 81fd070:	3301      	adds	r3, #1
 81fd072:	d003      	beq.n	81fd07c <_fwalk_sglue+0x38>
 81fd074:	4629      	mov	r1, r5
 81fd076:	4638      	mov	r0, r7
 81fd078:	47c0      	blx	r8
 81fd07a:	4306      	orrs	r6, r0
 81fd07c:	3568      	adds	r5, #104	@ 0x68
 81fd07e:	e7e9      	b.n	81fd054 <_fwalk_sglue+0x10>

081fd080 <iprintf>:
 81fd080:	b40f      	push	{r0, r1, r2, r3}
 81fd082:	b507      	push	{r0, r1, r2, lr}
 81fd084:	4906      	ldr	r1, [pc, #24]	@ (81fd0a0 <iprintf+0x20>)
 81fd086:	ab04      	add	r3, sp, #16
 81fd088:	6808      	ldr	r0, [r1, #0]
 81fd08a:	f853 2b04 	ldr.w	r2, [r3], #4
 81fd08e:	6881      	ldr	r1, [r0, #8]
 81fd090:	9301      	str	r3, [sp, #4]
 81fd092:	f000 fb91 	bl	81fd7b8 <_vfiprintf_r>
 81fd096:	b003      	add	sp, #12
 81fd098:	f85d eb04 	ldr.w	lr, [sp], #4
 81fd09c:	b004      	add	sp, #16
 81fd09e:	4770      	bx	lr
 81fd0a0:	20000058 	.word	0x20000058

081fd0a4 <_puts_r>:
 81fd0a4:	6a03      	ldr	r3, [r0, #32]
 81fd0a6:	b570      	push	{r4, r5, r6, lr}
 81fd0a8:	4605      	mov	r5, r0
 81fd0aa:	460e      	mov	r6, r1
 81fd0ac:	6884      	ldr	r4, [r0, #8]
 81fd0ae:	b90b      	cbnz	r3, 81fd0b4 <_puts_r+0x10>
 81fd0b0:	f7ff ffb0 	bl	81fd014 <__sinit>
 81fd0b4:	6e63      	ldr	r3, [r4, #100]	@ 0x64
 81fd0b6:	07db      	lsls	r3, r3, #31
 81fd0b8:	d405      	bmi.n	81fd0c6 <_puts_r+0x22>
 81fd0ba:	89a3      	ldrh	r3, [r4, #12]
 81fd0bc:	0598      	lsls	r0, r3, #22
 81fd0be:	d402      	bmi.n	81fd0c6 <_puts_r+0x22>
 81fd0c0:	6da0      	ldr	r0, [r4, #88]	@ 0x58
 81fd0c2:	f000 fa4c 	bl	81fd55e <__retarget_lock_acquire_recursive>
 81fd0c6:	89a3      	ldrh	r3, [r4, #12]
 81fd0c8:	0719      	lsls	r1, r3, #28
 81fd0ca:	d502      	bpl.n	81fd0d2 <_puts_r+0x2e>
 81fd0cc:	6923      	ldr	r3, [r4, #16]
 81fd0ce:	2b00      	cmp	r3, #0
 81fd0d0:	d135      	bne.n	81fd13e <_puts_r+0x9a>
 81fd0d2:	4621      	mov	r1, r4
 81fd0d4:	4628      	mov	r0, r5
 81fd0d6:	f000 f979 	bl	81fd3cc <__swsetup_r>
 81fd0da:	b380      	cbz	r0, 81fd13e <_puts_r+0x9a>
 81fd0dc:	f04f 35ff 	mov.w	r5, #4294967295	@ 0xffffffff
 81fd0e0:	6e63      	ldr	r3, [r4, #100]	@ 0x64
 81fd0e2:	07da      	lsls	r2, r3, #31
 81fd0e4:	d405      	bmi.n	81fd0f2 <_puts_r+0x4e>
 81fd0e6:	89a3      	ldrh	r3, [r4, #12]
 81fd0e8:	059b      	lsls	r3, r3, #22
 81fd0ea:	d402      	bmi.n	81fd0f2 <_puts_r+0x4e>
 81fd0ec:	6da0      	ldr	r0, [r4, #88]	@ 0x58
 81fd0ee:	f000 fa37 	bl	81fd560 <__retarget_lock_release_recursive>
 81fd0f2:	4628      	mov	r0, r5
 81fd0f4:	bd70      	pop	{r4, r5, r6, pc}
 81fd0f6:	2b00      	cmp	r3, #0
 81fd0f8:	da04      	bge.n	81fd104 <_puts_r+0x60>
 81fd0fa:	69a2      	ldr	r2, [r4, #24]
 81fd0fc:	429a      	cmp	r2, r3
 81fd0fe:	dc17      	bgt.n	81fd130 <_puts_r+0x8c>
 81fd100:	290a      	cmp	r1, #10
 81fd102:	d015      	beq.n	81fd130 <_puts_r+0x8c>
 81fd104:	6823      	ldr	r3, [r4, #0]
 81fd106:	1c5a      	adds	r2, r3, #1
 81fd108:	6022      	str	r2, [r4, #0]
 81fd10a:	7019      	strb	r1, [r3, #0]
 81fd10c:	68a3      	ldr	r3, [r4, #8]
 81fd10e:	f816 1f01 	ldrb.w	r1, [r6, #1]!
 81fd112:	3b01      	subs	r3, #1
 81fd114:	60a3      	str	r3, [r4, #8]
 81fd116:	2900      	cmp	r1, #0
 81fd118:	d1ed      	bne.n	81fd0f6 <_puts_r+0x52>
 81fd11a:	2b00      	cmp	r3, #0
 81fd11c:	da11      	bge.n	81fd142 <_puts_r+0x9e>
 81fd11e:	4622      	mov	r2, r4
 81fd120:	210a      	movs	r1, #10
 81fd122:	4628      	mov	r0, r5
 81fd124:	f000 f913 	bl	81fd34e <__swbuf_r>
 81fd128:	3001      	adds	r0, #1
 81fd12a:	d0d7      	beq.n	81fd0dc <_puts_r+0x38>
 81fd12c:	250a      	movs	r5, #10
 81fd12e:	e7d7      	b.n	81fd0e0 <_puts_r+0x3c>
 81fd130:	4622      	mov	r2, r4
 81fd132:	4628      	mov	r0, r5
 81fd134:	f000 f90b 	bl	81fd34e <__swbuf_r>
 81fd138:	3001      	adds	r0, #1
 81fd13a:	d1e7      	bne.n	81fd10c <_puts_r+0x68>
 81fd13c:	e7ce      	b.n	81fd0dc <_puts_r+0x38>
 81fd13e:	3e01      	subs	r6, #1
 81fd140:	e7e4      	b.n	81fd10c <_puts_r+0x68>
 81fd142:	6823      	ldr	r3, [r4, #0]
 81fd144:	1c5a      	adds	r2, r3, #1
 81fd146:	6022      	str	r2, [r4, #0]
 81fd148:	220a      	movs	r2, #10
 81fd14a:	701a      	strb	r2, [r3, #0]
 81fd14c:	e7ee      	b.n	81fd12c <_puts_r+0x88>
	...

081fd150 <puts>:
 81fd150:	4b02      	ldr	r3, [pc, #8]	@ (81fd15c <puts+0xc>)
 81fd152:	4601      	mov	r1, r0
 81fd154:	6818      	ldr	r0, [r3, #0]
 81fd156:	f7ff bfa5 	b.w	81fd0a4 <_puts_r>
 81fd15a:	bf00      	nop
 81fd15c:	20000058 	.word	0x20000058

081fd160 <setvbuf>:
 81fd160:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 81fd164:	461d      	mov	r5, r3
 81fd166:	4b57      	ldr	r3, [pc, #348]	@ (81fd2c4 <setvbuf+0x164>)
 81fd168:	4604      	mov	r4, r0
 81fd16a:	460e      	mov	r6, r1
 81fd16c:	681f      	ldr	r7, [r3, #0]
 81fd16e:	4690      	mov	r8, r2
 81fd170:	b127      	cbz	r7, 81fd17c <setvbuf+0x1c>
 81fd172:	6a3b      	ldr	r3, [r7, #32]
 81fd174:	b913      	cbnz	r3, 81fd17c <setvbuf+0x1c>
 81fd176:	4638      	mov	r0, r7
 81fd178:	f7ff ff4c 	bl	81fd014 <__sinit>
 81fd17c:	f1b8 0f02 	cmp.w	r8, #2
 81fd180:	d006      	beq.n	81fd190 <setvbuf+0x30>
 81fd182:	f1b8 0f01 	cmp.w	r8, #1
 81fd186:	f200 8099 	bhi.w	81fd2bc <setvbuf+0x15c>
 81fd18a:	2d00      	cmp	r5, #0
 81fd18c:	f2c0 8096 	blt.w	81fd2bc <setvbuf+0x15c>
 81fd190:	6e63      	ldr	r3, [r4, #100]	@ 0x64
 81fd192:	07d9      	lsls	r1, r3, #31
 81fd194:	d405      	bmi.n	81fd1a2 <setvbuf+0x42>
 81fd196:	89a3      	ldrh	r3, [r4, #12]
 81fd198:	059a      	lsls	r2, r3, #22
 81fd19a:	d402      	bmi.n	81fd1a2 <setvbuf+0x42>
 81fd19c:	6da0      	ldr	r0, [r4, #88]	@ 0x58
 81fd19e:	f000 f9de 	bl	81fd55e <__retarget_lock_acquire_recursive>
 81fd1a2:	4621      	mov	r1, r4
 81fd1a4:	4638      	mov	r0, r7
 81fd1a6:	f000 fe35 	bl	81fde14 <_fflush_r>
 81fd1aa:	6b61      	ldr	r1, [r4, #52]	@ 0x34
 81fd1ac:	b141      	cbz	r1, 81fd1c0 <setvbuf+0x60>
 81fd1ae:	f104 0344 	add.w	r3, r4, #68	@ 0x44
 81fd1b2:	4299      	cmp	r1, r3
 81fd1b4:	d002      	beq.n	81fd1bc <setvbuf+0x5c>
 81fd1b6:	4638      	mov	r0, r7
 81fd1b8:	f000 f9d4 	bl	81fd564 <_free_r>
 81fd1bc:	2300      	movs	r3, #0
 81fd1be:	6363      	str	r3, [r4, #52]	@ 0x34
 81fd1c0:	2300      	movs	r3, #0
 81fd1c2:	61a3      	str	r3, [r4, #24]
 81fd1c4:	6063      	str	r3, [r4, #4]
 81fd1c6:	89a3      	ldrh	r3, [r4, #12]
 81fd1c8:	061b      	lsls	r3, r3, #24
 81fd1ca:	d503      	bpl.n	81fd1d4 <setvbuf+0x74>
 81fd1cc:	6921      	ldr	r1, [r4, #16]
 81fd1ce:	4638      	mov	r0, r7
 81fd1d0:	f000 f9c8 	bl	81fd564 <_free_r>
 81fd1d4:	89a3      	ldrh	r3, [r4, #12]
 81fd1d6:	f1b8 0f02 	cmp.w	r8, #2
 81fd1da:	f423 634a 	bic.w	r3, r3, #3232	@ 0xca0
 81fd1de:	f023 0303 	bic.w	r3, r3, #3
 81fd1e2:	81a3      	strh	r3, [r4, #12]
 81fd1e4:	d060      	beq.n	81fd2a8 <setvbuf+0x148>
 81fd1e6:	ab01      	add	r3, sp, #4
 81fd1e8:	466a      	mov	r2, sp
 81fd1ea:	4621      	mov	r1, r4
 81fd1ec:	4638      	mov	r0, r7
 81fd1ee:	f000 fe39 	bl	81fde64 <__swhatbuf_r>
 81fd1f2:	89a3      	ldrh	r3, [r4, #12]
 81fd1f4:	4318      	orrs	r0, r3
 81fd1f6:	81a0      	strh	r0, [r4, #12]
 81fd1f8:	bb2d      	cbnz	r5, 81fd246 <setvbuf+0xe6>
 81fd1fa:	9d00      	ldr	r5, [sp, #0]
 81fd1fc:	4628      	mov	r0, r5
 81fd1fe:	f000 f9fb 	bl	81fd5f8 <malloc>
 81fd202:	4606      	mov	r6, r0
 81fd204:	2800      	cmp	r0, #0
 81fd206:	d151      	bne.n	81fd2ac <setvbuf+0x14c>
 81fd208:	f8dd 9000 	ldr.w	r9, [sp]
 81fd20c:	45a9      	cmp	r9, r5
 81fd20e:	d13f      	bne.n	81fd290 <setvbuf+0x130>
 81fd210:	f04f 35ff 	mov.w	r5, #4294967295	@ 0xffffffff
 81fd214:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 81fd218:	f043 0202 	orr.w	r2, r3, #2
 81fd21c:	81a2      	strh	r2, [r4, #12]
 81fd21e:	2200      	movs	r2, #0
 81fd220:	60a2      	str	r2, [r4, #8]
 81fd222:	f104 0247 	add.w	r2, r4, #71	@ 0x47
 81fd226:	6022      	str	r2, [r4, #0]
 81fd228:	6122      	str	r2, [r4, #16]
 81fd22a:	2201      	movs	r2, #1
 81fd22c:	6162      	str	r2, [r4, #20]
 81fd22e:	6e62      	ldr	r2, [r4, #100]	@ 0x64
 81fd230:	07d6      	lsls	r6, r2, #31
 81fd232:	d404      	bmi.n	81fd23e <setvbuf+0xde>
 81fd234:	0598      	lsls	r0, r3, #22
 81fd236:	d402      	bmi.n	81fd23e <setvbuf+0xde>
 81fd238:	6da0      	ldr	r0, [r4, #88]	@ 0x58
 81fd23a:	f000 f991 	bl	81fd560 <__retarget_lock_release_recursive>
 81fd23e:	4628      	mov	r0, r5
 81fd240:	b003      	add	sp, #12
 81fd242:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 81fd246:	2e00      	cmp	r6, #0
 81fd248:	d0d8      	beq.n	81fd1fc <setvbuf+0x9c>
 81fd24a:	6a3b      	ldr	r3, [r7, #32]
 81fd24c:	b913      	cbnz	r3, 81fd254 <setvbuf+0xf4>
 81fd24e:	4638      	mov	r0, r7
 81fd250:	f7ff fee0 	bl	81fd014 <__sinit>
 81fd254:	f1b8 0f01 	cmp.w	r8, #1
 81fd258:	6026      	str	r6, [r4, #0]
 81fd25a:	bf02      	ittt	eq
 81fd25c:	89a3      	ldrheq	r3, [r4, #12]
 81fd25e:	f043 0301 	orreq.w	r3, r3, #1
 81fd262:	81a3      	strheq	r3, [r4, #12]
 81fd264:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 81fd268:	f013 0208 	ands.w	r2, r3, #8
 81fd26c:	e9c4 6504 	strd	r6, r5, [r4, #16]
 81fd270:	d01e      	beq.n	81fd2b0 <setvbuf+0x150>
 81fd272:	07d9      	lsls	r1, r3, #31
 81fd274:	bf45      	ittet	mi
 81fd276:	2200      	movmi	r2, #0
 81fd278:	426d      	negmi	r5, r5
 81fd27a:	60a5      	strpl	r5, [r4, #8]
 81fd27c:	60a2      	strmi	r2, [r4, #8]
 81fd27e:	bf48      	it	mi
 81fd280:	61a5      	strmi	r5, [r4, #24]
 81fd282:	6e62      	ldr	r2, [r4, #100]	@ 0x64
 81fd284:	07d2      	lsls	r2, r2, #31
 81fd286:	d401      	bmi.n	81fd28c <setvbuf+0x12c>
 81fd288:	059b      	lsls	r3, r3, #22
 81fd28a:	d513      	bpl.n	81fd2b4 <setvbuf+0x154>
 81fd28c:	2500      	movs	r5, #0
 81fd28e:	e7d6      	b.n	81fd23e <setvbuf+0xde>
 81fd290:	4648      	mov	r0, r9
 81fd292:	f000 f9b1 	bl	81fd5f8 <malloc>
 81fd296:	4606      	mov	r6, r0
 81fd298:	2800      	cmp	r0, #0
 81fd29a:	d0b9      	beq.n	81fd210 <setvbuf+0xb0>
 81fd29c:	89a3      	ldrh	r3, [r4, #12]
 81fd29e:	464d      	mov	r5, r9
 81fd2a0:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 81fd2a4:	81a3      	strh	r3, [r4, #12]
 81fd2a6:	e7d0      	b.n	81fd24a <setvbuf+0xea>
 81fd2a8:	2500      	movs	r5, #0
 81fd2aa:	e7b3      	b.n	81fd214 <setvbuf+0xb4>
 81fd2ac:	46a9      	mov	r9, r5
 81fd2ae:	e7f5      	b.n	81fd29c <setvbuf+0x13c>
 81fd2b0:	60a2      	str	r2, [r4, #8]
 81fd2b2:	e7e6      	b.n	81fd282 <setvbuf+0x122>
 81fd2b4:	6da0      	ldr	r0, [r4, #88]	@ 0x58
 81fd2b6:	f000 f953 	bl	81fd560 <__retarget_lock_release_recursive>
 81fd2ba:	e7e7      	b.n	81fd28c <setvbuf+0x12c>
 81fd2bc:	f04f 35ff 	mov.w	r5, #4294967295	@ 0xffffffff
 81fd2c0:	e7bd      	b.n	81fd23e <setvbuf+0xde>
 81fd2c2:	bf00      	nop
 81fd2c4:	20000058 	.word	0x20000058

081fd2c8 <__sread>:
 81fd2c8:	b510      	push	{r4, lr}
 81fd2ca:	460c      	mov	r4, r1
 81fd2cc:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 81fd2d0:	f000 f8fc 	bl	81fd4cc <_read_r>
 81fd2d4:	2800      	cmp	r0, #0
 81fd2d6:	bfab      	itete	ge
 81fd2d8:	6d63      	ldrge	r3, [r4, #84]	@ 0x54
 81fd2da:	89a3      	ldrhlt	r3, [r4, #12]
 81fd2dc:	181b      	addge	r3, r3, r0
 81fd2de:	f423 5380 	biclt.w	r3, r3, #4096	@ 0x1000
 81fd2e2:	bfac      	ite	ge
 81fd2e4:	6563      	strge	r3, [r4, #84]	@ 0x54
 81fd2e6:	81a3      	strhlt	r3, [r4, #12]
 81fd2e8:	bd10      	pop	{r4, pc}

081fd2ea <__swrite>:
 81fd2ea:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 81fd2ee:	461f      	mov	r7, r3
 81fd2f0:	898b      	ldrh	r3, [r1, #12]
 81fd2f2:	4605      	mov	r5, r0
 81fd2f4:	460c      	mov	r4, r1
 81fd2f6:	05db      	lsls	r3, r3, #23
 81fd2f8:	4616      	mov	r6, r2
 81fd2fa:	d505      	bpl.n	81fd308 <__swrite+0x1e>
 81fd2fc:	2302      	movs	r3, #2
 81fd2fe:	2200      	movs	r2, #0
 81fd300:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 81fd304:	f000 f8d0 	bl	81fd4a8 <_lseek_r>
 81fd308:	89a3      	ldrh	r3, [r4, #12]
 81fd30a:	4632      	mov	r2, r6
 81fd30c:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 81fd310:	4628      	mov	r0, r5
 81fd312:	f423 5380 	bic.w	r3, r3, #4096	@ 0x1000
 81fd316:	81a3      	strh	r3, [r4, #12]
 81fd318:	463b      	mov	r3, r7
 81fd31a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 81fd31e:	f000 b8e7 	b.w	81fd4f0 <_write_r>

081fd322 <__sseek>:
 81fd322:	b510      	push	{r4, lr}
 81fd324:	460c      	mov	r4, r1
 81fd326:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 81fd32a:	f000 f8bd 	bl	81fd4a8 <_lseek_r>
 81fd32e:	1c43      	adds	r3, r0, #1
 81fd330:	89a3      	ldrh	r3, [r4, #12]
 81fd332:	bf15      	itete	ne
 81fd334:	6560      	strne	r0, [r4, #84]	@ 0x54
 81fd336:	f423 5380 	biceq.w	r3, r3, #4096	@ 0x1000
 81fd33a:	f443 5380 	orrne.w	r3, r3, #4096	@ 0x1000
 81fd33e:	81a3      	strheq	r3, [r4, #12]
 81fd340:	bf18      	it	ne
 81fd342:	81a3      	strhne	r3, [r4, #12]
 81fd344:	bd10      	pop	{r4, pc}

081fd346 <__sclose>:
 81fd346:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 81fd34a:	f000 b89d 	b.w	81fd488 <_close_r>

081fd34e <__swbuf_r>:
 81fd34e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 81fd350:	460e      	mov	r6, r1
 81fd352:	4614      	mov	r4, r2
 81fd354:	4605      	mov	r5, r0
 81fd356:	b118      	cbz	r0, 81fd360 <__swbuf_r+0x12>
 81fd358:	6a03      	ldr	r3, [r0, #32]
 81fd35a:	b90b      	cbnz	r3, 81fd360 <__swbuf_r+0x12>
 81fd35c:	f7ff fe5a 	bl	81fd014 <__sinit>
 81fd360:	69a3      	ldr	r3, [r4, #24]
 81fd362:	60a3      	str	r3, [r4, #8]
 81fd364:	89a3      	ldrh	r3, [r4, #12]
 81fd366:	071a      	lsls	r2, r3, #28
 81fd368:	d501      	bpl.n	81fd36e <__swbuf_r+0x20>
 81fd36a:	6923      	ldr	r3, [r4, #16]
 81fd36c:	b943      	cbnz	r3, 81fd380 <__swbuf_r+0x32>
 81fd36e:	4621      	mov	r1, r4
 81fd370:	4628      	mov	r0, r5
 81fd372:	f000 f82b 	bl	81fd3cc <__swsetup_r>
 81fd376:	b118      	cbz	r0, 81fd380 <__swbuf_r+0x32>
 81fd378:	f04f 37ff 	mov.w	r7, #4294967295	@ 0xffffffff
 81fd37c:	4638      	mov	r0, r7
 81fd37e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 81fd380:	6823      	ldr	r3, [r4, #0]
 81fd382:	b2f6      	uxtb	r6, r6
 81fd384:	6922      	ldr	r2, [r4, #16]
 81fd386:	4637      	mov	r7, r6
 81fd388:	1a98      	subs	r0, r3, r2
 81fd38a:	6963      	ldr	r3, [r4, #20]
 81fd38c:	4283      	cmp	r3, r0
 81fd38e:	dc05      	bgt.n	81fd39c <__swbuf_r+0x4e>
 81fd390:	4621      	mov	r1, r4
 81fd392:	4628      	mov	r0, r5
 81fd394:	f000 fd3e 	bl	81fde14 <_fflush_r>
 81fd398:	2800      	cmp	r0, #0
 81fd39a:	d1ed      	bne.n	81fd378 <__swbuf_r+0x2a>
 81fd39c:	68a3      	ldr	r3, [r4, #8]
 81fd39e:	3b01      	subs	r3, #1
 81fd3a0:	60a3      	str	r3, [r4, #8]
 81fd3a2:	6823      	ldr	r3, [r4, #0]
 81fd3a4:	1c5a      	adds	r2, r3, #1
 81fd3a6:	6022      	str	r2, [r4, #0]
 81fd3a8:	701e      	strb	r6, [r3, #0]
 81fd3aa:	1c43      	adds	r3, r0, #1
 81fd3ac:	6962      	ldr	r2, [r4, #20]
 81fd3ae:	429a      	cmp	r2, r3
 81fd3b0:	d004      	beq.n	81fd3bc <__swbuf_r+0x6e>
 81fd3b2:	89a3      	ldrh	r3, [r4, #12]
 81fd3b4:	07db      	lsls	r3, r3, #31
 81fd3b6:	d5e1      	bpl.n	81fd37c <__swbuf_r+0x2e>
 81fd3b8:	2e0a      	cmp	r6, #10
 81fd3ba:	d1df      	bne.n	81fd37c <__swbuf_r+0x2e>
 81fd3bc:	4621      	mov	r1, r4
 81fd3be:	4628      	mov	r0, r5
 81fd3c0:	f000 fd28 	bl	81fde14 <_fflush_r>
 81fd3c4:	2800      	cmp	r0, #0
 81fd3c6:	d0d9      	beq.n	81fd37c <__swbuf_r+0x2e>
 81fd3c8:	e7d6      	b.n	81fd378 <__swbuf_r+0x2a>
	...

081fd3cc <__swsetup_r>:
 81fd3cc:	b538      	push	{r3, r4, r5, lr}
 81fd3ce:	4b29      	ldr	r3, [pc, #164]	@ (81fd474 <__swsetup_r+0xa8>)
 81fd3d0:	4605      	mov	r5, r0
 81fd3d2:	460c      	mov	r4, r1
 81fd3d4:	6818      	ldr	r0, [r3, #0]
 81fd3d6:	b118      	cbz	r0, 81fd3e0 <__swsetup_r+0x14>
 81fd3d8:	6a03      	ldr	r3, [r0, #32]
 81fd3da:	b90b      	cbnz	r3, 81fd3e0 <__swsetup_r+0x14>
 81fd3dc:	f7ff fe1a 	bl	81fd014 <__sinit>
 81fd3e0:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 81fd3e4:	0719      	lsls	r1, r3, #28
 81fd3e6:	d422      	bmi.n	81fd42e <__swsetup_r+0x62>
 81fd3e8:	06da      	lsls	r2, r3, #27
 81fd3ea:	d407      	bmi.n	81fd3fc <__swsetup_r+0x30>
 81fd3ec:	2209      	movs	r2, #9
 81fd3ee:	602a      	str	r2, [r5, #0]
 81fd3f0:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 81fd3f4:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 81fd3f8:	81a3      	strh	r3, [r4, #12]
 81fd3fa:	e033      	b.n	81fd464 <__swsetup_r+0x98>
 81fd3fc:	0758      	lsls	r0, r3, #29
 81fd3fe:	d512      	bpl.n	81fd426 <__swsetup_r+0x5a>
 81fd400:	6b61      	ldr	r1, [r4, #52]	@ 0x34
 81fd402:	b141      	cbz	r1, 81fd416 <__swsetup_r+0x4a>
 81fd404:	f104 0344 	add.w	r3, r4, #68	@ 0x44
 81fd408:	4299      	cmp	r1, r3
 81fd40a:	d002      	beq.n	81fd412 <__swsetup_r+0x46>
 81fd40c:	4628      	mov	r0, r5
 81fd40e:	f000 f8a9 	bl	81fd564 <_free_r>
 81fd412:	2300      	movs	r3, #0
 81fd414:	6363      	str	r3, [r4, #52]	@ 0x34
 81fd416:	89a3      	ldrh	r3, [r4, #12]
 81fd418:	f023 0324 	bic.w	r3, r3, #36	@ 0x24
 81fd41c:	81a3      	strh	r3, [r4, #12]
 81fd41e:	2300      	movs	r3, #0
 81fd420:	6063      	str	r3, [r4, #4]
 81fd422:	6923      	ldr	r3, [r4, #16]
 81fd424:	6023      	str	r3, [r4, #0]
 81fd426:	89a3      	ldrh	r3, [r4, #12]
 81fd428:	f043 0308 	orr.w	r3, r3, #8
 81fd42c:	81a3      	strh	r3, [r4, #12]
 81fd42e:	6923      	ldr	r3, [r4, #16]
 81fd430:	b94b      	cbnz	r3, 81fd446 <__swsetup_r+0x7a>
 81fd432:	89a3      	ldrh	r3, [r4, #12]
 81fd434:	f403 7320 	and.w	r3, r3, #640	@ 0x280
 81fd438:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 81fd43c:	d003      	beq.n	81fd446 <__swsetup_r+0x7a>
 81fd43e:	4621      	mov	r1, r4
 81fd440:	4628      	mov	r0, r5
 81fd442:	f000 fd34 	bl	81fdeae <__smakebuf_r>
 81fd446:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 81fd44a:	f013 0201 	ands.w	r2, r3, #1
 81fd44e:	d00a      	beq.n	81fd466 <__swsetup_r+0x9a>
 81fd450:	2200      	movs	r2, #0
 81fd452:	60a2      	str	r2, [r4, #8]
 81fd454:	6962      	ldr	r2, [r4, #20]
 81fd456:	4252      	negs	r2, r2
 81fd458:	61a2      	str	r2, [r4, #24]
 81fd45a:	6922      	ldr	r2, [r4, #16]
 81fd45c:	b942      	cbnz	r2, 81fd470 <__swsetup_r+0xa4>
 81fd45e:	f013 0080 	ands.w	r0, r3, #128	@ 0x80
 81fd462:	d1c5      	bne.n	81fd3f0 <__swsetup_r+0x24>
 81fd464:	bd38      	pop	{r3, r4, r5, pc}
 81fd466:	0799      	lsls	r1, r3, #30
 81fd468:	bf58      	it	pl
 81fd46a:	6962      	ldrpl	r2, [r4, #20]
 81fd46c:	60a2      	str	r2, [r4, #8]
 81fd46e:	e7f4      	b.n	81fd45a <__swsetup_r+0x8e>
 81fd470:	2000      	movs	r0, #0
 81fd472:	e7f7      	b.n	81fd464 <__swsetup_r+0x98>
 81fd474:	20000058 	.word	0x20000058

081fd478 <memset>:
 81fd478:	4402      	add	r2, r0
 81fd47a:	4603      	mov	r3, r0
 81fd47c:	4293      	cmp	r3, r2
 81fd47e:	d100      	bne.n	81fd482 <memset+0xa>
 81fd480:	4770      	bx	lr
 81fd482:	f803 1b01 	strb.w	r1, [r3], #1
 81fd486:	e7f9      	b.n	81fd47c <memset+0x4>

081fd488 <_close_r>:
 81fd488:	b538      	push	{r3, r4, r5, lr}
 81fd48a:	2300      	movs	r3, #0
 81fd48c:	4d05      	ldr	r5, [pc, #20]	@ (81fd4a4 <_close_r+0x1c>)
 81fd48e:	4604      	mov	r4, r0
 81fd490:	4608      	mov	r0, r1
 81fd492:	602b      	str	r3, [r5, #0]
 81fd494:	f000 ff14 	bl	81fe2c0 <_close>
 81fd498:	1c43      	adds	r3, r0, #1
 81fd49a:	d102      	bne.n	81fd4a2 <_close_r+0x1a>
 81fd49c:	682b      	ldr	r3, [r5, #0]
 81fd49e:	b103      	cbz	r3, 81fd4a2 <_close_r+0x1a>
 81fd4a0:	6023      	str	r3, [r4, #0]
 81fd4a2:	bd38      	pop	{r3, r4, r5, pc}
 81fd4a4:	20000734 	.word	0x20000734

081fd4a8 <_lseek_r>:
 81fd4a8:	b538      	push	{r3, r4, r5, lr}
 81fd4aa:	4604      	mov	r4, r0
 81fd4ac:	4d06      	ldr	r5, [pc, #24]	@ (81fd4c8 <_lseek_r+0x20>)
 81fd4ae:	4608      	mov	r0, r1
 81fd4b0:	4611      	mov	r1, r2
 81fd4b2:	2200      	movs	r2, #0
 81fd4b4:	602a      	str	r2, [r5, #0]
 81fd4b6:	461a      	mov	r2, r3
 81fd4b8:	f000 ff1a 	bl	81fe2f0 <_lseek>
 81fd4bc:	1c43      	adds	r3, r0, #1
 81fd4be:	d102      	bne.n	81fd4c6 <_lseek_r+0x1e>
 81fd4c0:	682b      	ldr	r3, [r5, #0]
 81fd4c2:	b103      	cbz	r3, 81fd4c6 <_lseek_r+0x1e>
 81fd4c4:	6023      	str	r3, [r4, #0]
 81fd4c6:	bd38      	pop	{r3, r4, r5, pc}
 81fd4c8:	20000734 	.word	0x20000734

081fd4cc <_read_r>:
 81fd4cc:	b538      	push	{r3, r4, r5, lr}
 81fd4ce:	4604      	mov	r4, r0
 81fd4d0:	4d06      	ldr	r5, [pc, #24]	@ (81fd4ec <_read_r+0x20>)
 81fd4d2:	4608      	mov	r0, r1
 81fd4d4:	4611      	mov	r1, r2
 81fd4d6:	2200      	movs	r2, #0
 81fd4d8:	602a      	str	r2, [r5, #0]
 81fd4da:	461a      	mov	r2, r3
 81fd4dc:	f000 ff10 	bl	81fe300 <_read>
 81fd4e0:	1c43      	adds	r3, r0, #1
 81fd4e2:	d102      	bne.n	81fd4ea <_read_r+0x1e>
 81fd4e4:	682b      	ldr	r3, [r5, #0]
 81fd4e6:	b103      	cbz	r3, 81fd4ea <_read_r+0x1e>
 81fd4e8:	6023      	str	r3, [r4, #0]
 81fd4ea:	bd38      	pop	{r3, r4, r5, pc}
 81fd4ec:	20000734 	.word	0x20000734

081fd4f0 <_write_r>:
 81fd4f0:	b538      	push	{r3, r4, r5, lr}
 81fd4f2:	4604      	mov	r4, r0
 81fd4f4:	4d06      	ldr	r5, [pc, #24]	@ (81fd510 <_write_r+0x20>)
 81fd4f6:	4608      	mov	r0, r1
 81fd4f8:	4611      	mov	r1, r2
 81fd4fa:	2200      	movs	r2, #0
 81fd4fc:	602a      	str	r2, [r5, #0]
 81fd4fe:	461a      	mov	r2, r3
 81fd500:	f7fd fadd 	bl	81faabe <_write>
 81fd504:	1c43      	adds	r3, r0, #1
 81fd506:	d102      	bne.n	81fd50e <_write_r+0x1e>
 81fd508:	682b      	ldr	r3, [r5, #0]
 81fd50a:	b103      	cbz	r3, 81fd50e <_write_r+0x1e>
 81fd50c:	6023      	str	r3, [r4, #0]
 81fd50e:	bd38      	pop	{r3, r4, r5, pc}
 81fd510:	20000734 	.word	0x20000734

081fd514 <__libc_init_array>:
 81fd514:	b570      	push	{r4, r5, r6, lr}
 81fd516:	4d0d      	ldr	r5, [pc, #52]	@ (81fd54c <__libc_init_array+0x38>)
 81fd518:	2600      	movs	r6, #0
 81fd51a:	4c0d      	ldr	r4, [pc, #52]	@ (81fd550 <__libc_init_array+0x3c>)
 81fd51c:	1b64      	subs	r4, r4, r5
 81fd51e:	10a4      	asrs	r4, r4, #2
 81fd520:	42a6      	cmp	r6, r4
 81fd522:	d109      	bne.n	81fd538 <__libc_init_array+0x24>
 81fd524:	4d0b      	ldr	r5, [pc, #44]	@ (81fd554 <__libc_init_array+0x40>)
 81fd526:	2600      	movs	r6, #0
 81fd528:	4c0b      	ldr	r4, [pc, #44]	@ (81fd558 <__libc_init_array+0x44>)
 81fd52a:	f000 ff01 	bl	81fe330 <_init>
 81fd52e:	1b64      	subs	r4, r4, r5
 81fd530:	10a4      	asrs	r4, r4, #2
 81fd532:	42a6      	cmp	r6, r4
 81fd534:	d105      	bne.n	81fd542 <__libc_init_array+0x2e>
 81fd536:	bd70      	pop	{r4, r5, r6, pc}
 81fd538:	f855 3b04 	ldr.w	r3, [r5], #4
 81fd53c:	3601      	adds	r6, #1
 81fd53e:	4798      	blx	r3
 81fd540:	e7ee      	b.n	81fd520 <__libc_init_array+0xc>
 81fd542:	f855 3b04 	ldr.w	r3, [r5], #4
 81fd546:	3601      	adds	r6, #1
 81fd548:	4798      	blx	r3
 81fd54a:	e7f2      	b.n	81fd532 <__libc_init_array+0x1e>
 81fd54c:	200000a8 	.word	0x200000a8
 81fd550:	200000a8 	.word	0x200000a8
 81fd554:	200000a8 	.word	0x200000a8
 81fd558:	200000ac 	.word	0x200000ac

081fd55c <__retarget_lock_init_recursive>:
 81fd55c:	4770      	bx	lr

081fd55e <__retarget_lock_acquire_recursive>:
 81fd55e:	4770      	bx	lr

081fd560 <__retarget_lock_release_recursive>:
 81fd560:	4770      	bx	lr
	...

081fd564 <_free_r>:
 81fd564:	b538      	push	{r3, r4, r5, lr}
 81fd566:	4605      	mov	r5, r0
 81fd568:	2900      	cmp	r1, #0
 81fd56a:	d041      	beq.n	81fd5f0 <_free_r+0x8c>
 81fd56c:	f851 3c04 	ldr.w	r3, [r1, #-4]
 81fd570:	1f0c      	subs	r4, r1, #4
 81fd572:	2b00      	cmp	r3, #0
 81fd574:	bfb8      	it	lt
 81fd576:	18e4      	addlt	r4, r4, r3
 81fd578:	f000 f8e8 	bl	81fd74c <__malloc_lock>
 81fd57c:	4a1d      	ldr	r2, [pc, #116]	@ (81fd5f4 <_free_r+0x90>)
 81fd57e:	6813      	ldr	r3, [r2, #0]
 81fd580:	b933      	cbnz	r3, 81fd590 <_free_r+0x2c>
 81fd582:	6063      	str	r3, [r4, #4]
 81fd584:	6014      	str	r4, [r2, #0]
 81fd586:	4628      	mov	r0, r5
 81fd588:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 81fd58c:	f000 b8e4 	b.w	81fd758 <__malloc_unlock>
 81fd590:	42a3      	cmp	r3, r4
 81fd592:	d908      	bls.n	81fd5a6 <_free_r+0x42>
 81fd594:	6820      	ldr	r0, [r4, #0]
 81fd596:	1821      	adds	r1, r4, r0
 81fd598:	428b      	cmp	r3, r1
 81fd59a:	bf01      	itttt	eq
 81fd59c:	6819      	ldreq	r1, [r3, #0]
 81fd59e:	685b      	ldreq	r3, [r3, #4]
 81fd5a0:	1809      	addeq	r1, r1, r0
 81fd5a2:	6021      	streq	r1, [r4, #0]
 81fd5a4:	e7ed      	b.n	81fd582 <_free_r+0x1e>
 81fd5a6:	461a      	mov	r2, r3
 81fd5a8:	685b      	ldr	r3, [r3, #4]
 81fd5aa:	b10b      	cbz	r3, 81fd5b0 <_free_r+0x4c>
 81fd5ac:	42a3      	cmp	r3, r4
 81fd5ae:	d9fa      	bls.n	81fd5a6 <_free_r+0x42>
 81fd5b0:	6811      	ldr	r1, [r2, #0]
 81fd5b2:	1850      	adds	r0, r2, r1
 81fd5b4:	42a0      	cmp	r0, r4
 81fd5b6:	d10b      	bne.n	81fd5d0 <_free_r+0x6c>
 81fd5b8:	6820      	ldr	r0, [r4, #0]
 81fd5ba:	4401      	add	r1, r0
 81fd5bc:	1850      	adds	r0, r2, r1
 81fd5be:	6011      	str	r1, [r2, #0]
 81fd5c0:	4283      	cmp	r3, r0
 81fd5c2:	d1e0      	bne.n	81fd586 <_free_r+0x22>
 81fd5c4:	6818      	ldr	r0, [r3, #0]
 81fd5c6:	685b      	ldr	r3, [r3, #4]
 81fd5c8:	4408      	add	r0, r1
 81fd5ca:	6053      	str	r3, [r2, #4]
 81fd5cc:	6010      	str	r0, [r2, #0]
 81fd5ce:	e7da      	b.n	81fd586 <_free_r+0x22>
 81fd5d0:	d902      	bls.n	81fd5d8 <_free_r+0x74>
 81fd5d2:	230c      	movs	r3, #12
 81fd5d4:	602b      	str	r3, [r5, #0]
 81fd5d6:	e7d6      	b.n	81fd586 <_free_r+0x22>
 81fd5d8:	6820      	ldr	r0, [r4, #0]
 81fd5da:	1821      	adds	r1, r4, r0
 81fd5dc:	428b      	cmp	r3, r1
 81fd5de:	bf02      	ittt	eq
 81fd5e0:	6819      	ldreq	r1, [r3, #0]
 81fd5e2:	685b      	ldreq	r3, [r3, #4]
 81fd5e4:	1809      	addeq	r1, r1, r0
 81fd5e6:	6063      	str	r3, [r4, #4]
 81fd5e8:	bf08      	it	eq
 81fd5ea:	6021      	streq	r1, [r4, #0]
 81fd5ec:	6054      	str	r4, [r2, #4]
 81fd5ee:	e7ca      	b.n	81fd586 <_free_r+0x22>
 81fd5f0:	bd38      	pop	{r3, r4, r5, pc}
 81fd5f2:	bf00      	nop
 81fd5f4:	20000740 	.word	0x20000740

081fd5f8 <malloc>:
 81fd5f8:	4b02      	ldr	r3, [pc, #8]	@ (81fd604 <malloc+0xc>)
 81fd5fa:	4601      	mov	r1, r0
 81fd5fc:	6818      	ldr	r0, [r3, #0]
 81fd5fe:	f000 b825 	b.w	81fd64c <_malloc_r>
 81fd602:	bf00      	nop
 81fd604:	20000058 	.word	0x20000058

081fd608 <sbrk_aligned>:
 81fd608:	b570      	push	{r4, r5, r6, lr}
 81fd60a:	4e0f      	ldr	r6, [pc, #60]	@ (81fd648 <sbrk_aligned+0x40>)
 81fd60c:	460c      	mov	r4, r1
 81fd60e:	4605      	mov	r5, r0
 81fd610:	6831      	ldr	r1, [r6, #0]
 81fd612:	b911      	cbnz	r1, 81fd61a <sbrk_aligned+0x12>
 81fd614:	f000 fcaa 	bl	81fdf6c <_sbrk_r>
 81fd618:	6030      	str	r0, [r6, #0]
 81fd61a:	4621      	mov	r1, r4
 81fd61c:	4628      	mov	r0, r5
 81fd61e:	f000 fca5 	bl	81fdf6c <_sbrk_r>
 81fd622:	1c43      	adds	r3, r0, #1
 81fd624:	d103      	bne.n	81fd62e <sbrk_aligned+0x26>
 81fd626:	f04f 34ff 	mov.w	r4, #4294967295	@ 0xffffffff
 81fd62a:	4620      	mov	r0, r4
 81fd62c:	bd70      	pop	{r4, r5, r6, pc}
 81fd62e:	1cc4      	adds	r4, r0, #3
 81fd630:	f024 0403 	bic.w	r4, r4, #3
 81fd634:	42a0      	cmp	r0, r4
 81fd636:	d0f8      	beq.n	81fd62a <sbrk_aligned+0x22>
 81fd638:	1a21      	subs	r1, r4, r0
 81fd63a:	4628      	mov	r0, r5
 81fd63c:	f000 fc96 	bl	81fdf6c <_sbrk_r>
 81fd640:	3001      	adds	r0, #1
 81fd642:	d1f2      	bne.n	81fd62a <sbrk_aligned+0x22>
 81fd644:	e7ef      	b.n	81fd626 <sbrk_aligned+0x1e>
 81fd646:	bf00      	nop
 81fd648:	2000073c 	.word	0x2000073c

081fd64c <_malloc_r>:
 81fd64c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 81fd650:	1ccd      	adds	r5, r1, #3
 81fd652:	4606      	mov	r6, r0
 81fd654:	f025 0503 	bic.w	r5, r5, #3
 81fd658:	3508      	adds	r5, #8
 81fd65a:	2d0c      	cmp	r5, #12
 81fd65c:	bf38      	it	cc
 81fd65e:	250c      	movcc	r5, #12
 81fd660:	2d00      	cmp	r5, #0
 81fd662:	db01      	blt.n	81fd668 <_malloc_r+0x1c>
 81fd664:	42a9      	cmp	r1, r5
 81fd666:	d904      	bls.n	81fd672 <_malloc_r+0x26>
 81fd668:	230c      	movs	r3, #12
 81fd66a:	6033      	str	r3, [r6, #0]
 81fd66c:	2000      	movs	r0, #0
 81fd66e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 81fd672:	f8df 80d4 	ldr.w	r8, [pc, #212]	@ 81fd748 <_malloc_r+0xfc>
 81fd676:	f000 f869 	bl	81fd74c <__malloc_lock>
 81fd67a:	f8d8 3000 	ldr.w	r3, [r8]
 81fd67e:	461c      	mov	r4, r3
 81fd680:	bb44      	cbnz	r4, 81fd6d4 <_malloc_r+0x88>
 81fd682:	4629      	mov	r1, r5
 81fd684:	4630      	mov	r0, r6
 81fd686:	f7ff ffbf 	bl	81fd608 <sbrk_aligned>
 81fd68a:	1c43      	adds	r3, r0, #1
 81fd68c:	4604      	mov	r4, r0
 81fd68e:	d158      	bne.n	81fd742 <_malloc_r+0xf6>
 81fd690:	f8d8 4000 	ldr.w	r4, [r8]
 81fd694:	4627      	mov	r7, r4
 81fd696:	2f00      	cmp	r7, #0
 81fd698:	d143      	bne.n	81fd722 <_malloc_r+0xd6>
 81fd69a:	2c00      	cmp	r4, #0
 81fd69c:	d04b      	beq.n	81fd736 <_malloc_r+0xea>
 81fd69e:	6823      	ldr	r3, [r4, #0]
 81fd6a0:	4639      	mov	r1, r7
 81fd6a2:	4630      	mov	r0, r6
 81fd6a4:	eb04 0903 	add.w	r9, r4, r3
 81fd6a8:	f000 fc60 	bl	81fdf6c <_sbrk_r>
 81fd6ac:	4581      	cmp	r9, r0
 81fd6ae:	d142      	bne.n	81fd736 <_malloc_r+0xea>
 81fd6b0:	6821      	ldr	r1, [r4, #0]
 81fd6b2:	4630      	mov	r0, r6
 81fd6b4:	1a6d      	subs	r5, r5, r1
 81fd6b6:	4629      	mov	r1, r5
 81fd6b8:	f7ff ffa6 	bl	81fd608 <sbrk_aligned>
 81fd6bc:	3001      	adds	r0, #1
 81fd6be:	d03a      	beq.n	81fd736 <_malloc_r+0xea>
 81fd6c0:	6823      	ldr	r3, [r4, #0]
 81fd6c2:	442b      	add	r3, r5
 81fd6c4:	6023      	str	r3, [r4, #0]
 81fd6c6:	f8d8 3000 	ldr.w	r3, [r8]
 81fd6ca:	685a      	ldr	r2, [r3, #4]
 81fd6cc:	bb62      	cbnz	r2, 81fd728 <_malloc_r+0xdc>
 81fd6ce:	f8c8 7000 	str.w	r7, [r8]
 81fd6d2:	e00f      	b.n	81fd6f4 <_malloc_r+0xa8>
 81fd6d4:	6822      	ldr	r2, [r4, #0]
 81fd6d6:	1b52      	subs	r2, r2, r5
 81fd6d8:	d420      	bmi.n	81fd71c <_malloc_r+0xd0>
 81fd6da:	2a0b      	cmp	r2, #11
 81fd6dc:	d917      	bls.n	81fd70e <_malloc_r+0xc2>
 81fd6de:	1961      	adds	r1, r4, r5
 81fd6e0:	42a3      	cmp	r3, r4
 81fd6e2:	6025      	str	r5, [r4, #0]
 81fd6e4:	bf18      	it	ne
 81fd6e6:	6059      	strne	r1, [r3, #4]
 81fd6e8:	6863      	ldr	r3, [r4, #4]
 81fd6ea:	bf08      	it	eq
 81fd6ec:	f8c8 1000 	streq.w	r1, [r8]
 81fd6f0:	5162      	str	r2, [r4, r5]
 81fd6f2:	604b      	str	r3, [r1, #4]
 81fd6f4:	4630      	mov	r0, r6
 81fd6f6:	f000 f82f 	bl	81fd758 <__malloc_unlock>
 81fd6fa:	f104 000b 	add.w	r0, r4, #11
 81fd6fe:	1d23      	adds	r3, r4, #4
 81fd700:	f020 0007 	bic.w	r0, r0, #7
 81fd704:	1ac2      	subs	r2, r0, r3
 81fd706:	bf1c      	itt	ne
 81fd708:	1a1b      	subne	r3, r3, r0
 81fd70a:	50a3      	strne	r3, [r4, r2]
 81fd70c:	e7af      	b.n	81fd66e <_malloc_r+0x22>
 81fd70e:	6862      	ldr	r2, [r4, #4]
 81fd710:	42a3      	cmp	r3, r4
 81fd712:	bf0c      	ite	eq
 81fd714:	f8c8 2000 	streq.w	r2, [r8]
 81fd718:	605a      	strne	r2, [r3, #4]
 81fd71a:	e7eb      	b.n	81fd6f4 <_malloc_r+0xa8>
 81fd71c:	4623      	mov	r3, r4
 81fd71e:	6864      	ldr	r4, [r4, #4]
 81fd720:	e7ae      	b.n	81fd680 <_malloc_r+0x34>
 81fd722:	463c      	mov	r4, r7
 81fd724:	687f      	ldr	r7, [r7, #4]
 81fd726:	e7b6      	b.n	81fd696 <_malloc_r+0x4a>
 81fd728:	461a      	mov	r2, r3
 81fd72a:	685b      	ldr	r3, [r3, #4]
 81fd72c:	42a3      	cmp	r3, r4
 81fd72e:	d1fb      	bne.n	81fd728 <_malloc_r+0xdc>
 81fd730:	2300      	movs	r3, #0
 81fd732:	6053      	str	r3, [r2, #4]
 81fd734:	e7de      	b.n	81fd6f4 <_malloc_r+0xa8>
 81fd736:	230c      	movs	r3, #12
 81fd738:	4630      	mov	r0, r6
 81fd73a:	6033      	str	r3, [r6, #0]
 81fd73c:	f000 f80c 	bl	81fd758 <__malloc_unlock>
 81fd740:	e794      	b.n	81fd66c <_malloc_r+0x20>
 81fd742:	6005      	str	r5, [r0, #0]
 81fd744:	e7d6      	b.n	81fd6f4 <_malloc_r+0xa8>
 81fd746:	bf00      	nop
 81fd748:	20000740 	.word	0x20000740

081fd74c <__malloc_lock>:
 81fd74c:	4801      	ldr	r0, [pc, #4]	@ (81fd754 <__malloc_lock+0x8>)
 81fd74e:	f7ff bf06 	b.w	81fd55e <__retarget_lock_acquire_recursive>
 81fd752:	bf00      	nop
 81fd754:	20000738 	.word	0x20000738

081fd758 <__malloc_unlock>:
 81fd758:	4801      	ldr	r0, [pc, #4]	@ (81fd760 <__malloc_unlock+0x8>)
 81fd75a:	f7ff bf01 	b.w	81fd560 <__retarget_lock_release_recursive>
 81fd75e:	bf00      	nop
 81fd760:	20000738 	.word	0x20000738

081fd764 <__sfputc_r>:
 81fd764:	6893      	ldr	r3, [r2, #8]
 81fd766:	3b01      	subs	r3, #1
 81fd768:	2b00      	cmp	r3, #0
 81fd76a:	6093      	str	r3, [r2, #8]
 81fd76c:	b410      	push	{r4}
 81fd76e:	da08      	bge.n	81fd782 <__sfputc_r+0x1e>
 81fd770:	6994      	ldr	r4, [r2, #24]
 81fd772:	42a3      	cmp	r3, r4
 81fd774:	db01      	blt.n	81fd77a <__sfputc_r+0x16>
 81fd776:	290a      	cmp	r1, #10
 81fd778:	d103      	bne.n	81fd782 <__sfputc_r+0x1e>
 81fd77a:	f85d 4b04 	ldr.w	r4, [sp], #4
 81fd77e:	f7ff bde6 	b.w	81fd34e <__swbuf_r>
 81fd782:	6813      	ldr	r3, [r2, #0]
 81fd784:	1c58      	adds	r0, r3, #1
 81fd786:	6010      	str	r0, [r2, #0]
 81fd788:	4608      	mov	r0, r1
 81fd78a:	7019      	strb	r1, [r3, #0]
 81fd78c:	f85d 4b04 	ldr.w	r4, [sp], #4
 81fd790:	4770      	bx	lr

081fd792 <__sfputs_r>:
 81fd792:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 81fd794:	4606      	mov	r6, r0
 81fd796:	460f      	mov	r7, r1
 81fd798:	4614      	mov	r4, r2
 81fd79a:	18d5      	adds	r5, r2, r3
 81fd79c:	42ac      	cmp	r4, r5
 81fd79e:	d101      	bne.n	81fd7a4 <__sfputs_r+0x12>
 81fd7a0:	2000      	movs	r0, #0
 81fd7a2:	e007      	b.n	81fd7b4 <__sfputs_r+0x22>
 81fd7a4:	463a      	mov	r2, r7
 81fd7a6:	f814 1b01 	ldrb.w	r1, [r4], #1
 81fd7aa:	4630      	mov	r0, r6
 81fd7ac:	f7ff ffda 	bl	81fd764 <__sfputc_r>
 81fd7b0:	1c43      	adds	r3, r0, #1
 81fd7b2:	d1f3      	bne.n	81fd79c <__sfputs_r+0xa>
 81fd7b4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

081fd7b8 <_vfiprintf_r>:
 81fd7b8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 81fd7bc:	460d      	mov	r5, r1
 81fd7be:	b09d      	sub	sp, #116	@ 0x74
 81fd7c0:	4614      	mov	r4, r2
 81fd7c2:	4698      	mov	r8, r3
 81fd7c4:	4606      	mov	r6, r0
 81fd7c6:	b118      	cbz	r0, 81fd7d0 <_vfiprintf_r+0x18>
 81fd7c8:	6a03      	ldr	r3, [r0, #32]
 81fd7ca:	b90b      	cbnz	r3, 81fd7d0 <_vfiprintf_r+0x18>
 81fd7cc:	f7ff fc22 	bl	81fd014 <__sinit>
 81fd7d0:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
 81fd7d2:	07d9      	lsls	r1, r3, #31
 81fd7d4:	d405      	bmi.n	81fd7e2 <_vfiprintf_r+0x2a>
 81fd7d6:	89ab      	ldrh	r3, [r5, #12]
 81fd7d8:	059a      	lsls	r2, r3, #22
 81fd7da:	d402      	bmi.n	81fd7e2 <_vfiprintf_r+0x2a>
 81fd7dc:	6da8      	ldr	r0, [r5, #88]	@ 0x58
 81fd7de:	f7ff febe 	bl	81fd55e <__retarget_lock_acquire_recursive>
 81fd7e2:	89ab      	ldrh	r3, [r5, #12]
 81fd7e4:	071b      	lsls	r3, r3, #28
 81fd7e6:	d501      	bpl.n	81fd7ec <_vfiprintf_r+0x34>
 81fd7e8:	692b      	ldr	r3, [r5, #16]
 81fd7ea:	b99b      	cbnz	r3, 81fd814 <_vfiprintf_r+0x5c>
 81fd7ec:	4629      	mov	r1, r5
 81fd7ee:	4630      	mov	r0, r6
 81fd7f0:	f7ff fdec 	bl	81fd3cc <__swsetup_r>
 81fd7f4:	b170      	cbz	r0, 81fd814 <_vfiprintf_r+0x5c>
 81fd7f6:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
 81fd7f8:	07dc      	lsls	r4, r3, #31
 81fd7fa:	d504      	bpl.n	81fd806 <_vfiprintf_r+0x4e>
 81fd7fc:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 81fd800:	b01d      	add	sp, #116	@ 0x74
 81fd802:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 81fd806:	89ab      	ldrh	r3, [r5, #12]
 81fd808:	0598      	lsls	r0, r3, #22
 81fd80a:	d4f7      	bmi.n	81fd7fc <_vfiprintf_r+0x44>
 81fd80c:	6da8      	ldr	r0, [r5, #88]	@ 0x58
 81fd80e:	f7ff fea7 	bl	81fd560 <__retarget_lock_release_recursive>
 81fd812:	e7f3      	b.n	81fd7fc <_vfiprintf_r+0x44>
 81fd814:	2300      	movs	r3, #0
 81fd816:	f8cd 800c 	str.w	r8, [sp, #12]
 81fd81a:	f04f 0901 	mov.w	r9, #1
 81fd81e:	f8df 81b4 	ldr.w	r8, [pc, #436]	@ 81fd9d4 <_vfiprintf_r+0x21c>
 81fd822:	9309      	str	r3, [sp, #36]	@ 0x24
 81fd824:	2320      	movs	r3, #32
 81fd826:	f88d 3029 	strb.w	r3, [sp, #41]	@ 0x29
 81fd82a:	2330      	movs	r3, #48	@ 0x30
 81fd82c:	f88d 302a 	strb.w	r3, [sp, #42]	@ 0x2a
 81fd830:	4623      	mov	r3, r4
 81fd832:	469a      	mov	sl, r3
 81fd834:	f813 2b01 	ldrb.w	r2, [r3], #1
 81fd838:	b10a      	cbz	r2, 81fd83e <_vfiprintf_r+0x86>
 81fd83a:	2a25      	cmp	r2, #37	@ 0x25
 81fd83c:	d1f9      	bne.n	81fd832 <_vfiprintf_r+0x7a>
 81fd83e:	ebba 0b04 	subs.w	fp, sl, r4
 81fd842:	d00b      	beq.n	81fd85c <_vfiprintf_r+0xa4>
 81fd844:	465b      	mov	r3, fp
 81fd846:	4622      	mov	r2, r4
 81fd848:	4629      	mov	r1, r5
 81fd84a:	4630      	mov	r0, r6
 81fd84c:	f7ff ffa1 	bl	81fd792 <__sfputs_r>
 81fd850:	3001      	adds	r0, #1
 81fd852:	f000 80a7 	beq.w	81fd9a4 <_vfiprintf_r+0x1ec>
 81fd856:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 81fd858:	445a      	add	r2, fp
 81fd85a:	9209      	str	r2, [sp, #36]	@ 0x24
 81fd85c:	f89a 3000 	ldrb.w	r3, [sl]
 81fd860:	2b00      	cmp	r3, #0
 81fd862:	f000 809f 	beq.w	81fd9a4 <_vfiprintf_r+0x1ec>
 81fd866:	2300      	movs	r3, #0
 81fd868:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 81fd86c:	f10a 0a01 	add.w	sl, sl, #1
 81fd870:	9304      	str	r3, [sp, #16]
 81fd872:	9307      	str	r3, [sp, #28]
 81fd874:	f88d 3053 	strb.w	r3, [sp, #83]	@ 0x53
 81fd878:	931a      	str	r3, [sp, #104]	@ 0x68
 81fd87a:	e9cd 2305 	strd	r2, r3, [sp, #20]
 81fd87e:	4654      	mov	r4, sl
 81fd880:	2205      	movs	r2, #5
 81fd882:	4854      	ldr	r0, [pc, #336]	@ (81fd9d4 <_vfiprintf_r+0x21c>)
 81fd884:	f814 1b01 	ldrb.w	r1, [r4], #1
 81fd888:	f000 fb80 	bl	81fdf8c <memchr>
 81fd88c:	9a04      	ldr	r2, [sp, #16]
 81fd88e:	b9d8      	cbnz	r0, 81fd8c8 <_vfiprintf_r+0x110>
 81fd890:	06d1      	lsls	r1, r2, #27
 81fd892:	bf44      	itt	mi
 81fd894:	2320      	movmi	r3, #32
 81fd896:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
 81fd89a:	0713      	lsls	r3, r2, #28
 81fd89c:	bf44      	itt	mi
 81fd89e:	232b      	movmi	r3, #43	@ 0x2b
 81fd8a0:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
 81fd8a4:	f89a 3000 	ldrb.w	r3, [sl]
 81fd8a8:	2b2a      	cmp	r3, #42	@ 0x2a
 81fd8aa:	d015      	beq.n	81fd8d8 <_vfiprintf_r+0x120>
 81fd8ac:	9a07      	ldr	r2, [sp, #28]
 81fd8ae:	4654      	mov	r4, sl
 81fd8b0:	2000      	movs	r0, #0
 81fd8b2:	f04f 0c0a 	mov.w	ip, #10
 81fd8b6:	4621      	mov	r1, r4
 81fd8b8:	f811 3b01 	ldrb.w	r3, [r1], #1
 81fd8bc:	3b30      	subs	r3, #48	@ 0x30
 81fd8be:	2b09      	cmp	r3, #9
 81fd8c0:	d94b      	bls.n	81fd95a <_vfiprintf_r+0x1a2>
 81fd8c2:	b1b0      	cbz	r0, 81fd8f2 <_vfiprintf_r+0x13a>
 81fd8c4:	9207      	str	r2, [sp, #28]
 81fd8c6:	e014      	b.n	81fd8f2 <_vfiprintf_r+0x13a>
 81fd8c8:	eba0 0308 	sub.w	r3, r0, r8
 81fd8cc:	46a2      	mov	sl, r4
 81fd8ce:	fa09 f303 	lsl.w	r3, r9, r3
 81fd8d2:	4313      	orrs	r3, r2
 81fd8d4:	9304      	str	r3, [sp, #16]
 81fd8d6:	e7d2      	b.n	81fd87e <_vfiprintf_r+0xc6>
 81fd8d8:	9b03      	ldr	r3, [sp, #12]
 81fd8da:	1d19      	adds	r1, r3, #4
 81fd8dc:	681b      	ldr	r3, [r3, #0]
 81fd8de:	2b00      	cmp	r3, #0
 81fd8e0:	9103      	str	r1, [sp, #12]
 81fd8e2:	bfbb      	ittet	lt
 81fd8e4:	425b      	neglt	r3, r3
 81fd8e6:	f042 0202 	orrlt.w	r2, r2, #2
 81fd8ea:	9307      	strge	r3, [sp, #28]
 81fd8ec:	9307      	strlt	r3, [sp, #28]
 81fd8ee:	bfb8      	it	lt
 81fd8f0:	9204      	strlt	r2, [sp, #16]
 81fd8f2:	7823      	ldrb	r3, [r4, #0]
 81fd8f4:	2b2e      	cmp	r3, #46	@ 0x2e
 81fd8f6:	d10a      	bne.n	81fd90e <_vfiprintf_r+0x156>
 81fd8f8:	7863      	ldrb	r3, [r4, #1]
 81fd8fa:	2b2a      	cmp	r3, #42	@ 0x2a
 81fd8fc:	d132      	bne.n	81fd964 <_vfiprintf_r+0x1ac>
 81fd8fe:	9b03      	ldr	r3, [sp, #12]
 81fd900:	3402      	adds	r4, #2
 81fd902:	1d1a      	adds	r2, r3, #4
 81fd904:	681b      	ldr	r3, [r3, #0]
 81fd906:	ea43 73e3 	orr.w	r3, r3, r3, asr #31
 81fd90a:	9203      	str	r2, [sp, #12]
 81fd90c:	9305      	str	r3, [sp, #20]
 81fd90e:	f8df a0d4 	ldr.w	sl, [pc, #212]	@ 81fd9e4 <_vfiprintf_r+0x22c>
 81fd912:	2203      	movs	r2, #3
 81fd914:	7821      	ldrb	r1, [r4, #0]
 81fd916:	4650      	mov	r0, sl
 81fd918:	f000 fb38 	bl	81fdf8c <memchr>
 81fd91c:	b138      	cbz	r0, 81fd92e <_vfiprintf_r+0x176>
 81fd91e:	eba0 000a 	sub.w	r0, r0, sl
 81fd922:	2240      	movs	r2, #64	@ 0x40
 81fd924:	9b04      	ldr	r3, [sp, #16]
 81fd926:	3401      	adds	r4, #1
 81fd928:	4082      	lsls	r2, r0
 81fd92a:	4313      	orrs	r3, r2
 81fd92c:	9304      	str	r3, [sp, #16]
 81fd92e:	f814 1b01 	ldrb.w	r1, [r4], #1
 81fd932:	2206      	movs	r2, #6
 81fd934:	4828      	ldr	r0, [pc, #160]	@ (81fd9d8 <_vfiprintf_r+0x220>)
 81fd936:	f88d 1028 	strb.w	r1, [sp, #40]	@ 0x28
 81fd93a:	f000 fb27 	bl	81fdf8c <memchr>
 81fd93e:	2800      	cmp	r0, #0
 81fd940:	d03f      	beq.n	81fd9c2 <_vfiprintf_r+0x20a>
 81fd942:	4b26      	ldr	r3, [pc, #152]	@ (81fd9dc <_vfiprintf_r+0x224>)
 81fd944:	bb1b      	cbnz	r3, 81fd98e <_vfiprintf_r+0x1d6>
 81fd946:	9b03      	ldr	r3, [sp, #12]
 81fd948:	3307      	adds	r3, #7
 81fd94a:	f023 0307 	bic.w	r3, r3, #7
 81fd94e:	3308      	adds	r3, #8
 81fd950:	9303      	str	r3, [sp, #12]
 81fd952:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 81fd954:	443b      	add	r3, r7
 81fd956:	9309      	str	r3, [sp, #36]	@ 0x24
 81fd958:	e76a      	b.n	81fd830 <_vfiprintf_r+0x78>
 81fd95a:	fb0c 3202 	mla	r2, ip, r2, r3
 81fd95e:	460c      	mov	r4, r1
 81fd960:	2001      	movs	r0, #1
 81fd962:	e7a8      	b.n	81fd8b6 <_vfiprintf_r+0xfe>
 81fd964:	2300      	movs	r3, #0
 81fd966:	3401      	adds	r4, #1
 81fd968:	f04f 0c0a 	mov.w	ip, #10
 81fd96c:	4619      	mov	r1, r3
 81fd96e:	9305      	str	r3, [sp, #20]
 81fd970:	4620      	mov	r0, r4
 81fd972:	f810 2b01 	ldrb.w	r2, [r0], #1
 81fd976:	3a30      	subs	r2, #48	@ 0x30
 81fd978:	2a09      	cmp	r2, #9
 81fd97a:	d903      	bls.n	81fd984 <_vfiprintf_r+0x1cc>
 81fd97c:	2b00      	cmp	r3, #0
 81fd97e:	d0c6      	beq.n	81fd90e <_vfiprintf_r+0x156>
 81fd980:	9105      	str	r1, [sp, #20]
 81fd982:	e7c4      	b.n	81fd90e <_vfiprintf_r+0x156>
 81fd984:	fb0c 2101 	mla	r1, ip, r1, r2
 81fd988:	4604      	mov	r4, r0
 81fd98a:	2301      	movs	r3, #1
 81fd98c:	e7f0      	b.n	81fd970 <_vfiprintf_r+0x1b8>
 81fd98e:	ab03      	add	r3, sp, #12
 81fd990:	462a      	mov	r2, r5
 81fd992:	a904      	add	r1, sp, #16
 81fd994:	4630      	mov	r0, r6
 81fd996:	9300      	str	r3, [sp, #0]
 81fd998:	4b11      	ldr	r3, [pc, #68]	@ (81fd9e0 <_vfiprintf_r+0x228>)
 81fd99a:	f3af 8000 	nop.w
 81fd99e:	4607      	mov	r7, r0
 81fd9a0:	1c78      	adds	r0, r7, #1
 81fd9a2:	d1d6      	bne.n	81fd952 <_vfiprintf_r+0x19a>
 81fd9a4:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
 81fd9a6:	07d9      	lsls	r1, r3, #31
 81fd9a8:	d405      	bmi.n	81fd9b6 <_vfiprintf_r+0x1fe>
 81fd9aa:	89ab      	ldrh	r3, [r5, #12]
 81fd9ac:	059a      	lsls	r2, r3, #22
 81fd9ae:	d402      	bmi.n	81fd9b6 <_vfiprintf_r+0x1fe>
 81fd9b0:	6da8      	ldr	r0, [r5, #88]	@ 0x58
 81fd9b2:	f7ff fdd5 	bl	81fd560 <__retarget_lock_release_recursive>
 81fd9b6:	89ab      	ldrh	r3, [r5, #12]
 81fd9b8:	065b      	lsls	r3, r3, #25
 81fd9ba:	f53f af1f 	bmi.w	81fd7fc <_vfiprintf_r+0x44>
 81fd9be:	9809      	ldr	r0, [sp, #36]	@ 0x24
 81fd9c0:	e71e      	b.n	81fd800 <_vfiprintf_r+0x48>
 81fd9c2:	ab03      	add	r3, sp, #12
 81fd9c4:	462a      	mov	r2, r5
 81fd9c6:	a904      	add	r1, sp, #16
 81fd9c8:	4630      	mov	r0, r6
 81fd9ca:	9300      	str	r3, [sp, #0]
 81fd9cc:	4b04      	ldr	r3, [pc, #16]	@ (81fd9e0 <_vfiprintf_r+0x228>)
 81fd9ce:	f000 f87d 	bl	81fdacc <_printf_i>
 81fd9d2:	e7e4      	b.n	81fd99e <_vfiprintf_r+0x1e6>
 81fd9d4:	081fe9c8 	.word	0x081fe9c8
 81fd9d8:	081fe9d2 	.word	0x081fe9d2
 81fd9dc:	00000000 	.word	0x00000000
 81fd9e0:	081fd793 	.word	0x081fd793
 81fd9e4:	081fe9ce 	.word	0x081fe9ce

081fd9e8 <_printf_common>:
 81fd9e8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 81fd9ec:	4616      	mov	r6, r2
 81fd9ee:	4698      	mov	r8, r3
 81fd9f0:	688a      	ldr	r2, [r1, #8]
 81fd9f2:	4607      	mov	r7, r0
 81fd9f4:	690b      	ldr	r3, [r1, #16]
 81fd9f6:	460c      	mov	r4, r1
 81fd9f8:	f8dd 9020 	ldr.w	r9, [sp, #32]
 81fd9fc:	4293      	cmp	r3, r2
 81fd9fe:	bfb8      	it	lt
 81fda00:	4613      	movlt	r3, r2
 81fda02:	6033      	str	r3, [r6, #0]
 81fda04:	f891 2043 	ldrb.w	r2, [r1, #67]	@ 0x43
 81fda08:	b10a      	cbz	r2, 81fda0e <_printf_common+0x26>
 81fda0a:	3301      	adds	r3, #1
 81fda0c:	6033      	str	r3, [r6, #0]
 81fda0e:	6823      	ldr	r3, [r4, #0]
 81fda10:	0699      	lsls	r1, r3, #26
 81fda12:	bf42      	ittt	mi
 81fda14:	6833      	ldrmi	r3, [r6, #0]
 81fda16:	3302      	addmi	r3, #2
 81fda18:	6033      	strmi	r3, [r6, #0]
 81fda1a:	6825      	ldr	r5, [r4, #0]
 81fda1c:	f015 0506 	ands.w	r5, r5, #6
 81fda20:	d106      	bne.n	81fda30 <_printf_common+0x48>
 81fda22:	f104 0a19 	add.w	sl, r4, #25
 81fda26:	68e3      	ldr	r3, [r4, #12]
 81fda28:	6832      	ldr	r2, [r6, #0]
 81fda2a:	1a9b      	subs	r3, r3, r2
 81fda2c:	42ab      	cmp	r3, r5
 81fda2e:	dc2b      	bgt.n	81fda88 <_printf_common+0xa0>
 81fda30:	f894 3043 	ldrb.w	r3, [r4, #67]	@ 0x43
 81fda34:	6822      	ldr	r2, [r4, #0]
 81fda36:	3b00      	subs	r3, #0
 81fda38:	bf18      	it	ne
 81fda3a:	2301      	movne	r3, #1
 81fda3c:	0692      	lsls	r2, r2, #26
 81fda3e:	d430      	bmi.n	81fdaa2 <_printf_common+0xba>
 81fda40:	f104 0243 	add.w	r2, r4, #67	@ 0x43
 81fda44:	4641      	mov	r1, r8
 81fda46:	4638      	mov	r0, r7
 81fda48:	47c8      	blx	r9
 81fda4a:	3001      	adds	r0, #1
 81fda4c:	d023      	beq.n	81fda96 <_printf_common+0xae>
 81fda4e:	6823      	ldr	r3, [r4, #0]
 81fda50:	341a      	adds	r4, #26
 81fda52:	f854 2c0a 	ldr.w	r2, [r4, #-10]
 81fda56:	f003 0306 	and.w	r3, r3, #6
 81fda5a:	2b04      	cmp	r3, #4
 81fda5c:	bf0a      	itet	eq
 81fda5e:	f854 5c0e 	ldreq.w	r5, [r4, #-14]
 81fda62:	2500      	movne	r5, #0
 81fda64:	6833      	ldreq	r3, [r6, #0]
 81fda66:	f04f 0600 	mov.w	r6, #0
 81fda6a:	bf08      	it	eq
 81fda6c:	1aed      	subeq	r5, r5, r3
 81fda6e:	f854 3c12 	ldr.w	r3, [r4, #-18]
 81fda72:	bf08      	it	eq
 81fda74:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
 81fda78:	4293      	cmp	r3, r2
 81fda7a:	bfc4      	itt	gt
 81fda7c:	1a9b      	subgt	r3, r3, r2
 81fda7e:	18ed      	addgt	r5, r5, r3
 81fda80:	42b5      	cmp	r5, r6
 81fda82:	d11a      	bne.n	81fdaba <_printf_common+0xd2>
 81fda84:	2000      	movs	r0, #0
 81fda86:	e008      	b.n	81fda9a <_printf_common+0xb2>
 81fda88:	2301      	movs	r3, #1
 81fda8a:	4652      	mov	r2, sl
 81fda8c:	4641      	mov	r1, r8
 81fda8e:	4638      	mov	r0, r7
 81fda90:	47c8      	blx	r9
 81fda92:	3001      	adds	r0, #1
 81fda94:	d103      	bne.n	81fda9e <_printf_common+0xb6>
 81fda96:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 81fda9a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 81fda9e:	3501      	adds	r5, #1
 81fdaa0:	e7c1      	b.n	81fda26 <_printf_common+0x3e>
 81fdaa2:	18e1      	adds	r1, r4, r3
 81fdaa4:	1c5a      	adds	r2, r3, #1
 81fdaa6:	2030      	movs	r0, #48	@ 0x30
 81fdaa8:	3302      	adds	r3, #2
 81fdaaa:	4422      	add	r2, r4
 81fdaac:	f881 0043 	strb.w	r0, [r1, #67]	@ 0x43
 81fdab0:	f894 1045 	ldrb.w	r1, [r4, #69]	@ 0x45
 81fdab4:	f882 1043 	strb.w	r1, [r2, #67]	@ 0x43
 81fdab8:	e7c2      	b.n	81fda40 <_printf_common+0x58>
 81fdaba:	2301      	movs	r3, #1
 81fdabc:	4622      	mov	r2, r4
 81fdabe:	4641      	mov	r1, r8
 81fdac0:	4638      	mov	r0, r7
 81fdac2:	47c8      	blx	r9
 81fdac4:	3001      	adds	r0, #1
 81fdac6:	d0e6      	beq.n	81fda96 <_printf_common+0xae>
 81fdac8:	3601      	adds	r6, #1
 81fdaca:	e7d9      	b.n	81fda80 <_printf_common+0x98>

081fdacc <_printf_i>:
 81fdacc:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 81fdad0:	7e0f      	ldrb	r7, [r1, #24]
 81fdad2:	4691      	mov	r9, r2
 81fdad4:	4680      	mov	r8, r0
 81fdad6:	460c      	mov	r4, r1
 81fdad8:	2f78      	cmp	r7, #120	@ 0x78
 81fdada:	469a      	mov	sl, r3
 81fdadc:	9e0c      	ldr	r6, [sp, #48]	@ 0x30
 81fdade:	f101 0243 	add.w	r2, r1, #67	@ 0x43
 81fdae2:	d807      	bhi.n	81fdaf4 <_printf_i+0x28>
 81fdae4:	2f62      	cmp	r7, #98	@ 0x62
 81fdae6:	d80a      	bhi.n	81fdafe <_printf_i+0x32>
 81fdae8:	2f00      	cmp	r7, #0
 81fdaea:	f000 80d2 	beq.w	81fdc92 <_printf_i+0x1c6>
 81fdaee:	2f58      	cmp	r7, #88	@ 0x58
 81fdaf0:	f000 80b9 	beq.w	81fdc66 <_printf_i+0x19a>
 81fdaf4:	f104 0642 	add.w	r6, r4, #66	@ 0x42
 81fdaf8:	f884 7042 	strb.w	r7, [r4, #66]	@ 0x42
 81fdafc:	e03a      	b.n	81fdb74 <_printf_i+0xa8>
 81fdafe:	f1a7 0363 	sub.w	r3, r7, #99	@ 0x63
 81fdb02:	2b15      	cmp	r3, #21
 81fdb04:	d8f6      	bhi.n	81fdaf4 <_printf_i+0x28>
 81fdb06:	a101      	add	r1, pc, #4	@ (adr r1, 81fdb0c <_printf_i+0x40>)
 81fdb08:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
 81fdb0c:	081fdb65 	.word	0x081fdb65
 81fdb10:	081fdb79 	.word	0x081fdb79
 81fdb14:	081fdaf5 	.word	0x081fdaf5
 81fdb18:	081fdaf5 	.word	0x081fdaf5
 81fdb1c:	081fdaf5 	.word	0x081fdaf5
 81fdb20:	081fdaf5 	.word	0x081fdaf5
 81fdb24:	081fdb79 	.word	0x081fdb79
 81fdb28:	081fdaf5 	.word	0x081fdaf5
 81fdb2c:	081fdaf5 	.word	0x081fdaf5
 81fdb30:	081fdaf5 	.word	0x081fdaf5
 81fdb34:	081fdaf5 	.word	0x081fdaf5
 81fdb38:	081fdc79 	.word	0x081fdc79
 81fdb3c:	081fdba3 	.word	0x081fdba3
 81fdb40:	081fdc33 	.word	0x081fdc33
 81fdb44:	081fdaf5 	.word	0x081fdaf5
 81fdb48:	081fdaf5 	.word	0x081fdaf5
 81fdb4c:	081fdc9b 	.word	0x081fdc9b
 81fdb50:	081fdaf5 	.word	0x081fdaf5
 81fdb54:	081fdba3 	.word	0x081fdba3
 81fdb58:	081fdaf5 	.word	0x081fdaf5
 81fdb5c:	081fdaf5 	.word	0x081fdaf5
 81fdb60:	081fdc3b 	.word	0x081fdc3b
 81fdb64:	6833      	ldr	r3, [r6, #0]
 81fdb66:	1d1a      	adds	r2, r3, #4
 81fdb68:	681b      	ldr	r3, [r3, #0]
 81fdb6a:	6032      	str	r2, [r6, #0]
 81fdb6c:	f104 0642 	add.w	r6, r4, #66	@ 0x42
 81fdb70:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
 81fdb74:	2301      	movs	r3, #1
 81fdb76:	e09d      	b.n	81fdcb4 <_printf_i+0x1e8>
 81fdb78:	6833      	ldr	r3, [r6, #0]
 81fdb7a:	6820      	ldr	r0, [r4, #0]
 81fdb7c:	1d19      	adds	r1, r3, #4
 81fdb7e:	6031      	str	r1, [r6, #0]
 81fdb80:	0606      	lsls	r6, r0, #24
 81fdb82:	d501      	bpl.n	81fdb88 <_printf_i+0xbc>
 81fdb84:	681d      	ldr	r5, [r3, #0]
 81fdb86:	e003      	b.n	81fdb90 <_printf_i+0xc4>
 81fdb88:	0645      	lsls	r5, r0, #25
 81fdb8a:	d5fb      	bpl.n	81fdb84 <_printf_i+0xb8>
 81fdb8c:	f9b3 5000 	ldrsh.w	r5, [r3]
 81fdb90:	2d00      	cmp	r5, #0
 81fdb92:	da03      	bge.n	81fdb9c <_printf_i+0xd0>
 81fdb94:	232d      	movs	r3, #45	@ 0x2d
 81fdb96:	426d      	negs	r5, r5
 81fdb98:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
 81fdb9c:	4859      	ldr	r0, [pc, #356]	@ (81fdd04 <_printf_i+0x238>)
 81fdb9e:	230a      	movs	r3, #10
 81fdba0:	e011      	b.n	81fdbc6 <_printf_i+0xfa>
 81fdba2:	6821      	ldr	r1, [r4, #0]
 81fdba4:	6833      	ldr	r3, [r6, #0]
 81fdba6:	0608      	lsls	r0, r1, #24
 81fdba8:	f853 5b04 	ldr.w	r5, [r3], #4
 81fdbac:	d402      	bmi.n	81fdbb4 <_printf_i+0xe8>
 81fdbae:	0649      	lsls	r1, r1, #25
 81fdbb0:	bf48      	it	mi
 81fdbb2:	b2ad      	uxthmi	r5, r5
 81fdbb4:	2f6f      	cmp	r7, #111	@ 0x6f
 81fdbb6:	6033      	str	r3, [r6, #0]
 81fdbb8:	4852      	ldr	r0, [pc, #328]	@ (81fdd04 <_printf_i+0x238>)
 81fdbba:	bf14      	ite	ne
 81fdbbc:	230a      	movne	r3, #10
 81fdbbe:	2308      	moveq	r3, #8
 81fdbc0:	2100      	movs	r1, #0
 81fdbc2:	f884 1043 	strb.w	r1, [r4, #67]	@ 0x43
 81fdbc6:	6866      	ldr	r6, [r4, #4]
 81fdbc8:	2e00      	cmp	r6, #0
 81fdbca:	60a6      	str	r6, [r4, #8]
 81fdbcc:	bfa2      	ittt	ge
 81fdbce:	6821      	ldrge	r1, [r4, #0]
 81fdbd0:	f021 0104 	bicge.w	r1, r1, #4
 81fdbd4:	6021      	strge	r1, [r4, #0]
 81fdbd6:	b90d      	cbnz	r5, 81fdbdc <_printf_i+0x110>
 81fdbd8:	2e00      	cmp	r6, #0
 81fdbda:	d04b      	beq.n	81fdc74 <_printf_i+0x1a8>
 81fdbdc:	4616      	mov	r6, r2
 81fdbde:	fbb5 f1f3 	udiv	r1, r5, r3
 81fdbe2:	fb03 5711 	mls	r7, r3, r1, r5
 81fdbe6:	5dc7      	ldrb	r7, [r0, r7]
 81fdbe8:	f806 7d01 	strb.w	r7, [r6, #-1]!
 81fdbec:	462f      	mov	r7, r5
 81fdbee:	460d      	mov	r5, r1
 81fdbf0:	42bb      	cmp	r3, r7
 81fdbf2:	d9f4      	bls.n	81fdbde <_printf_i+0x112>
 81fdbf4:	2b08      	cmp	r3, #8
 81fdbf6:	d10b      	bne.n	81fdc10 <_printf_i+0x144>
 81fdbf8:	6823      	ldr	r3, [r4, #0]
 81fdbfa:	07df      	lsls	r7, r3, #31
 81fdbfc:	d508      	bpl.n	81fdc10 <_printf_i+0x144>
 81fdbfe:	6923      	ldr	r3, [r4, #16]
 81fdc00:	6861      	ldr	r1, [r4, #4]
 81fdc02:	4299      	cmp	r1, r3
 81fdc04:	bfde      	ittt	le
 81fdc06:	2330      	movle	r3, #48	@ 0x30
 81fdc08:	f806 3c01 	strble.w	r3, [r6, #-1]
 81fdc0c:	f106 36ff 	addle.w	r6, r6, #4294967295	@ 0xffffffff
 81fdc10:	1b92      	subs	r2, r2, r6
 81fdc12:	6122      	str	r2, [r4, #16]
 81fdc14:	464b      	mov	r3, r9
 81fdc16:	aa03      	add	r2, sp, #12
 81fdc18:	4621      	mov	r1, r4
 81fdc1a:	4640      	mov	r0, r8
 81fdc1c:	f8cd a000 	str.w	sl, [sp]
 81fdc20:	f7ff fee2 	bl	81fd9e8 <_printf_common>
 81fdc24:	3001      	adds	r0, #1
 81fdc26:	d14a      	bne.n	81fdcbe <_printf_i+0x1f2>
 81fdc28:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 81fdc2c:	b004      	add	sp, #16
 81fdc2e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 81fdc32:	6823      	ldr	r3, [r4, #0]
 81fdc34:	f043 0320 	orr.w	r3, r3, #32
 81fdc38:	6023      	str	r3, [r4, #0]
 81fdc3a:	2778      	movs	r7, #120	@ 0x78
 81fdc3c:	4832      	ldr	r0, [pc, #200]	@ (81fdd08 <_printf_i+0x23c>)
 81fdc3e:	6823      	ldr	r3, [r4, #0]
 81fdc40:	f884 7045 	strb.w	r7, [r4, #69]	@ 0x45
 81fdc44:	061f      	lsls	r7, r3, #24
 81fdc46:	6831      	ldr	r1, [r6, #0]
 81fdc48:	f851 5b04 	ldr.w	r5, [r1], #4
 81fdc4c:	d402      	bmi.n	81fdc54 <_printf_i+0x188>
 81fdc4e:	065f      	lsls	r7, r3, #25
 81fdc50:	bf48      	it	mi
 81fdc52:	b2ad      	uxthmi	r5, r5
 81fdc54:	6031      	str	r1, [r6, #0]
 81fdc56:	07d9      	lsls	r1, r3, #31
 81fdc58:	bf44      	itt	mi
 81fdc5a:	f043 0320 	orrmi.w	r3, r3, #32
 81fdc5e:	6023      	strmi	r3, [r4, #0]
 81fdc60:	b11d      	cbz	r5, 81fdc6a <_printf_i+0x19e>
 81fdc62:	2310      	movs	r3, #16
 81fdc64:	e7ac      	b.n	81fdbc0 <_printf_i+0xf4>
 81fdc66:	4827      	ldr	r0, [pc, #156]	@ (81fdd04 <_printf_i+0x238>)
 81fdc68:	e7e9      	b.n	81fdc3e <_printf_i+0x172>
 81fdc6a:	6823      	ldr	r3, [r4, #0]
 81fdc6c:	f023 0320 	bic.w	r3, r3, #32
 81fdc70:	6023      	str	r3, [r4, #0]
 81fdc72:	e7f6      	b.n	81fdc62 <_printf_i+0x196>
 81fdc74:	4616      	mov	r6, r2
 81fdc76:	e7bd      	b.n	81fdbf4 <_printf_i+0x128>
 81fdc78:	6833      	ldr	r3, [r6, #0]
 81fdc7a:	6825      	ldr	r5, [r4, #0]
 81fdc7c:	1d18      	adds	r0, r3, #4
 81fdc7e:	6961      	ldr	r1, [r4, #20]
 81fdc80:	6030      	str	r0, [r6, #0]
 81fdc82:	062e      	lsls	r6, r5, #24
 81fdc84:	681b      	ldr	r3, [r3, #0]
 81fdc86:	d501      	bpl.n	81fdc8c <_printf_i+0x1c0>
 81fdc88:	6019      	str	r1, [r3, #0]
 81fdc8a:	e002      	b.n	81fdc92 <_printf_i+0x1c6>
 81fdc8c:	0668      	lsls	r0, r5, #25
 81fdc8e:	d5fb      	bpl.n	81fdc88 <_printf_i+0x1bc>
 81fdc90:	8019      	strh	r1, [r3, #0]
 81fdc92:	2300      	movs	r3, #0
 81fdc94:	4616      	mov	r6, r2
 81fdc96:	6123      	str	r3, [r4, #16]
 81fdc98:	e7bc      	b.n	81fdc14 <_printf_i+0x148>
 81fdc9a:	6833      	ldr	r3, [r6, #0]
 81fdc9c:	2100      	movs	r1, #0
 81fdc9e:	1d1a      	adds	r2, r3, #4
 81fdca0:	6032      	str	r2, [r6, #0]
 81fdca2:	681e      	ldr	r6, [r3, #0]
 81fdca4:	6862      	ldr	r2, [r4, #4]
 81fdca6:	4630      	mov	r0, r6
 81fdca8:	f000 f970 	bl	81fdf8c <memchr>
 81fdcac:	b108      	cbz	r0, 81fdcb2 <_printf_i+0x1e6>
 81fdcae:	1b80      	subs	r0, r0, r6
 81fdcb0:	6060      	str	r0, [r4, #4]
 81fdcb2:	6863      	ldr	r3, [r4, #4]
 81fdcb4:	6123      	str	r3, [r4, #16]
 81fdcb6:	2300      	movs	r3, #0
 81fdcb8:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
 81fdcbc:	e7aa      	b.n	81fdc14 <_printf_i+0x148>
 81fdcbe:	6923      	ldr	r3, [r4, #16]
 81fdcc0:	4632      	mov	r2, r6
 81fdcc2:	4649      	mov	r1, r9
 81fdcc4:	4640      	mov	r0, r8
 81fdcc6:	47d0      	blx	sl
 81fdcc8:	3001      	adds	r0, #1
 81fdcca:	d0ad      	beq.n	81fdc28 <_printf_i+0x15c>
 81fdccc:	6823      	ldr	r3, [r4, #0]
 81fdcce:	079b      	lsls	r3, r3, #30
 81fdcd0:	d413      	bmi.n	81fdcfa <_printf_i+0x22e>
 81fdcd2:	68e0      	ldr	r0, [r4, #12]
 81fdcd4:	9b03      	ldr	r3, [sp, #12]
 81fdcd6:	4298      	cmp	r0, r3
 81fdcd8:	bfb8      	it	lt
 81fdcda:	4618      	movlt	r0, r3
 81fdcdc:	e7a6      	b.n	81fdc2c <_printf_i+0x160>
 81fdcde:	2301      	movs	r3, #1
 81fdce0:	4632      	mov	r2, r6
 81fdce2:	4649      	mov	r1, r9
 81fdce4:	4640      	mov	r0, r8
 81fdce6:	47d0      	blx	sl
 81fdce8:	3001      	adds	r0, #1
 81fdcea:	d09d      	beq.n	81fdc28 <_printf_i+0x15c>
 81fdcec:	3501      	adds	r5, #1
 81fdcee:	68e3      	ldr	r3, [r4, #12]
 81fdcf0:	9903      	ldr	r1, [sp, #12]
 81fdcf2:	1a5b      	subs	r3, r3, r1
 81fdcf4:	42ab      	cmp	r3, r5
 81fdcf6:	dcf2      	bgt.n	81fdcde <_printf_i+0x212>
 81fdcf8:	e7eb      	b.n	81fdcd2 <_printf_i+0x206>
 81fdcfa:	2500      	movs	r5, #0
 81fdcfc:	f104 0619 	add.w	r6, r4, #25
 81fdd00:	e7f5      	b.n	81fdcee <_printf_i+0x222>
 81fdd02:	bf00      	nop
 81fdd04:	081fe9d9 	.word	0x081fe9d9
 81fdd08:	081fe9ea 	.word	0x081fe9ea

081fdd0c <__sflush_r>:
 81fdd0c:	f9b1 200c 	ldrsh.w	r2, [r1, #12]
 81fdd10:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 81fdd14:	0716      	lsls	r6, r2, #28
 81fdd16:	4605      	mov	r5, r0
 81fdd18:	460c      	mov	r4, r1
 81fdd1a:	d454      	bmi.n	81fddc6 <__sflush_r+0xba>
 81fdd1c:	684b      	ldr	r3, [r1, #4]
 81fdd1e:	2b00      	cmp	r3, #0
 81fdd20:	dc02      	bgt.n	81fdd28 <__sflush_r+0x1c>
 81fdd22:	6c0b      	ldr	r3, [r1, #64]	@ 0x40
 81fdd24:	2b00      	cmp	r3, #0
 81fdd26:	dd48      	ble.n	81fddba <__sflush_r+0xae>
 81fdd28:	6ae6      	ldr	r6, [r4, #44]	@ 0x2c
 81fdd2a:	2e00      	cmp	r6, #0
 81fdd2c:	d045      	beq.n	81fddba <__sflush_r+0xae>
 81fdd2e:	2300      	movs	r3, #0
 81fdd30:	f412 5280 	ands.w	r2, r2, #4096	@ 0x1000
 81fdd34:	682f      	ldr	r7, [r5, #0]
 81fdd36:	6a21      	ldr	r1, [r4, #32]
 81fdd38:	602b      	str	r3, [r5, #0]
 81fdd3a:	d030      	beq.n	81fdd9e <__sflush_r+0x92>
 81fdd3c:	6d62      	ldr	r2, [r4, #84]	@ 0x54
 81fdd3e:	89a3      	ldrh	r3, [r4, #12]
 81fdd40:	0759      	lsls	r1, r3, #29
 81fdd42:	d505      	bpl.n	81fdd50 <__sflush_r+0x44>
 81fdd44:	6863      	ldr	r3, [r4, #4]
 81fdd46:	1ad2      	subs	r2, r2, r3
 81fdd48:	6b63      	ldr	r3, [r4, #52]	@ 0x34
 81fdd4a:	b10b      	cbz	r3, 81fdd50 <__sflush_r+0x44>
 81fdd4c:	6c23      	ldr	r3, [r4, #64]	@ 0x40
 81fdd4e:	1ad2      	subs	r2, r2, r3
 81fdd50:	2300      	movs	r3, #0
 81fdd52:	6ae6      	ldr	r6, [r4, #44]	@ 0x2c
 81fdd54:	6a21      	ldr	r1, [r4, #32]
 81fdd56:	4628      	mov	r0, r5
 81fdd58:	47b0      	blx	r6
 81fdd5a:	1c43      	adds	r3, r0, #1
 81fdd5c:	89a3      	ldrh	r3, [r4, #12]
 81fdd5e:	d106      	bne.n	81fdd6e <__sflush_r+0x62>
 81fdd60:	6829      	ldr	r1, [r5, #0]
 81fdd62:	291d      	cmp	r1, #29
 81fdd64:	d82b      	bhi.n	81fddbe <__sflush_r+0xb2>
 81fdd66:	4a2a      	ldr	r2, [pc, #168]	@ (81fde10 <__sflush_r+0x104>)
 81fdd68:	410a      	asrs	r2, r1
 81fdd6a:	07d6      	lsls	r6, r2, #31
 81fdd6c:	d427      	bmi.n	81fddbe <__sflush_r+0xb2>
 81fdd6e:	2200      	movs	r2, #0
 81fdd70:	04d9      	lsls	r1, r3, #19
 81fdd72:	6062      	str	r2, [r4, #4]
 81fdd74:	6922      	ldr	r2, [r4, #16]
 81fdd76:	6022      	str	r2, [r4, #0]
 81fdd78:	d504      	bpl.n	81fdd84 <__sflush_r+0x78>
 81fdd7a:	1c42      	adds	r2, r0, #1
 81fdd7c:	d101      	bne.n	81fdd82 <__sflush_r+0x76>
 81fdd7e:	682b      	ldr	r3, [r5, #0]
 81fdd80:	b903      	cbnz	r3, 81fdd84 <__sflush_r+0x78>
 81fdd82:	6560      	str	r0, [r4, #84]	@ 0x54
 81fdd84:	6b61      	ldr	r1, [r4, #52]	@ 0x34
 81fdd86:	602f      	str	r7, [r5, #0]
 81fdd88:	b1b9      	cbz	r1, 81fddba <__sflush_r+0xae>
 81fdd8a:	f104 0344 	add.w	r3, r4, #68	@ 0x44
 81fdd8e:	4299      	cmp	r1, r3
 81fdd90:	d002      	beq.n	81fdd98 <__sflush_r+0x8c>
 81fdd92:	4628      	mov	r0, r5
 81fdd94:	f7ff fbe6 	bl	81fd564 <_free_r>
 81fdd98:	2300      	movs	r3, #0
 81fdd9a:	6363      	str	r3, [r4, #52]	@ 0x34
 81fdd9c:	e00d      	b.n	81fddba <__sflush_r+0xae>
 81fdd9e:	2301      	movs	r3, #1
 81fdda0:	4628      	mov	r0, r5
 81fdda2:	47b0      	blx	r6
 81fdda4:	4602      	mov	r2, r0
 81fdda6:	1c50      	adds	r0, r2, #1
 81fdda8:	d1c9      	bne.n	81fdd3e <__sflush_r+0x32>
 81fddaa:	682b      	ldr	r3, [r5, #0]
 81fddac:	2b00      	cmp	r3, #0
 81fddae:	d0c6      	beq.n	81fdd3e <__sflush_r+0x32>
 81fddb0:	2b1d      	cmp	r3, #29
 81fddb2:	d001      	beq.n	81fddb8 <__sflush_r+0xac>
 81fddb4:	2b16      	cmp	r3, #22
 81fddb6:	d11d      	bne.n	81fddf4 <__sflush_r+0xe8>
 81fddb8:	602f      	str	r7, [r5, #0]
 81fddba:	2000      	movs	r0, #0
 81fddbc:	e021      	b.n	81fde02 <__sflush_r+0xf6>
 81fddbe:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 81fddc2:	b21b      	sxth	r3, r3
 81fddc4:	e01a      	b.n	81fddfc <__sflush_r+0xf0>
 81fddc6:	690f      	ldr	r7, [r1, #16]
 81fddc8:	2f00      	cmp	r7, #0
 81fddca:	d0f6      	beq.n	81fddba <__sflush_r+0xae>
 81fddcc:	0793      	lsls	r3, r2, #30
 81fddce:	680e      	ldr	r6, [r1, #0]
 81fddd0:	600f      	str	r7, [r1, #0]
 81fddd2:	bf0c      	ite	eq
 81fddd4:	694b      	ldreq	r3, [r1, #20]
 81fddd6:	2300      	movne	r3, #0
 81fddd8:	eba6 0807 	sub.w	r8, r6, r7
 81fdddc:	608b      	str	r3, [r1, #8]
 81fddde:	f1b8 0f00 	cmp.w	r8, #0
 81fdde2:	ddea      	ble.n	81fddba <__sflush_r+0xae>
 81fdde4:	4643      	mov	r3, r8
 81fdde6:	463a      	mov	r2, r7
 81fdde8:	6a21      	ldr	r1, [r4, #32]
 81fddea:	4628      	mov	r0, r5
 81fddec:	6aa6      	ldr	r6, [r4, #40]	@ 0x28
 81fddee:	47b0      	blx	r6
 81fddf0:	2800      	cmp	r0, #0
 81fddf2:	dc08      	bgt.n	81fde06 <__sflush_r+0xfa>
 81fddf4:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 81fddf8:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 81fddfc:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 81fde00:	81a3      	strh	r3, [r4, #12]
 81fde02:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 81fde06:	4407      	add	r7, r0
 81fde08:	eba8 0800 	sub.w	r8, r8, r0
 81fde0c:	e7e7      	b.n	81fddde <__sflush_r+0xd2>
 81fde0e:	bf00      	nop
 81fde10:	dfbffffe 	.word	0xdfbffffe

081fde14 <_fflush_r>:
 81fde14:	b538      	push	{r3, r4, r5, lr}
 81fde16:	690b      	ldr	r3, [r1, #16]
 81fde18:	4605      	mov	r5, r0
 81fde1a:	460c      	mov	r4, r1
 81fde1c:	b913      	cbnz	r3, 81fde24 <_fflush_r+0x10>
 81fde1e:	2500      	movs	r5, #0
 81fde20:	4628      	mov	r0, r5
 81fde22:	bd38      	pop	{r3, r4, r5, pc}
 81fde24:	b118      	cbz	r0, 81fde2e <_fflush_r+0x1a>
 81fde26:	6a03      	ldr	r3, [r0, #32]
 81fde28:	b90b      	cbnz	r3, 81fde2e <_fflush_r+0x1a>
 81fde2a:	f7ff f8f3 	bl	81fd014 <__sinit>
 81fde2e:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 81fde32:	2b00      	cmp	r3, #0
 81fde34:	d0f3      	beq.n	81fde1e <_fflush_r+0xa>
 81fde36:	6e62      	ldr	r2, [r4, #100]	@ 0x64
 81fde38:	07d0      	lsls	r0, r2, #31
 81fde3a:	d404      	bmi.n	81fde46 <_fflush_r+0x32>
 81fde3c:	0599      	lsls	r1, r3, #22
 81fde3e:	d402      	bmi.n	81fde46 <_fflush_r+0x32>
 81fde40:	6da0      	ldr	r0, [r4, #88]	@ 0x58
 81fde42:	f7ff fb8c 	bl	81fd55e <__retarget_lock_acquire_recursive>
 81fde46:	4628      	mov	r0, r5
 81fde48:	4621      	mov	r1, r4
 81fde4a:	f7ff ff5f 	bl	81fdd0c <__sflush_r>
 81fde4e:	6e63      	ldr	r3, [r4, #100]	@ 0x64
 81fde50:	4605      	mov	r5, r0
 81fde52:	07da      	lsls	r2, r3, #31
 81fde54:	d4e4      	bmi.n	81fde20 <_fflush_r+0xc>
 81fde56:	89a3      	ldrh	r3, [r4, #12]
 81fde58:	059b      	lsls	r3, r3, #22
 81fde5a:	d4e1      	bmi.n	81fde20 <_fflush_r+0xc>
 81fde5c:	6da0      	ldr	r0, [r4, #88]	@ 0x58
 81fde5e:	f7ff fb7f 	bl	81fd560 <__retarget_lock_release_recursive>
 81fde62:	e7dd      	b.n	81fde20 <_fflush_r+0xc>

081fde64 <__swhatbuf_r>:
 81fde64:	b570      	push	{r4, r5, r6, lr}
 81fde66:	460c      	mov	r4, r1
 81fde68:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 81fde6c:	b096      	sub	sp, #88	@ 0x58
 81fde6e:	4615      	mov	r5, r2
 81fde70:	2900      	cmp	r1, #0
 81fde72:	461e      	mov	r6, r3
 81fde74:	da0c      	bge.n	81fde90 <__swhatbuf_r+0x2c>
 81fde76:	89a3      	ldrh	r3, [r4, #12]
 81fde78:	2100      	movs	r1, #0
 81fde7a:	f013 0f80 	tst.w	r3, #128	@ 0x80
 81fde7e:	bf14      	ite	ne
 81fde80:	2340      	movne	r3, #64	@ 0x40
 81fde82:	f44f 6380 	moveq.w	r3, #1024	@ 0x400
 81fde86:	2000      	movs	r0, #0
 81fde88:	6031      	str	r1, [r6, #0]
 81fde8a:	602b      	str	r3, [r5, #0]
 81fde8c:	b016      	add	sp, #88	@ 0x58
 81fde8e:	bd70      	pop	{r4, r5, r6, pc}
 81fde90:	466a      	mov	r2, sp
 81fde92:	f000 f849 	bl	81fdf28 <_fstat_r>
 81fde96:	2800      	cmp	r0, #0
 81fde98:	dbed      	blt.n	81fde76 <__swhatbuf_r+0x12>
 81fde9a:	9901      	ldr	r1, [sp, #4]
 81fde9c:	f401 4170 	and.w	r1, r1, #61440	@ 0xf000
 81fdea0:	f5a1 5300 	sub.w	r3, r1, #8192	@ 0x2000
 81fdea4:	4259      	negs	r1, r3
 81fdea6:	4159      	adcs	r1, r3
 81fdea8:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 81fdeac:	e7eb      	b.n	81fde86 <__swhatbuf_r+0x22>

081fdeae <__smakebuf_r>:
 81fdeae:	898b      	ldrh	r3, [r1, #12]
 81fdeb0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 81fdeb2:	079d      	lsls	r5, r3, #30
 81fdeb4:	4606      	mov	r6, r0
 81fdeb6:	460c      	mov	r4, r1
 81fdeb8:	d507      	bpl.n	81fdeca <__smakebuf_r+0x1c>
 81fdeba:	f104 0347 	add.w	r3, r4, #71	@ 0x47
 81fdebe:	6023      	str	r3, [r4, #0]
 81fdec0:	6123      	str	r3, [r4, #16]
 81fdec2:	2301      	movs	r3, #1
 81fdec4:	6163      	str	r3, [r4, #20]
 81fdec6:	b003      	add	sp, #12
 81fdec8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 81fdeca:	ab01      	add	r3, sp, #4
 81fdecc:	466a      	mov	r2, sp
 81fdece:	f7ff ffc9 	bl	81fde64 <__swhatbuf_r>
 81fded2:	9f00      	ldr	r7, [sp, #0]
 81fded4:	4605      	mov	r5, r0
 81fded6:	4630      	mov	r0, r6
 81fded8:	4639      	mov	r1, r7
 81fdeda:	f7ff fbb7 	bl	81fd64c <_malloc_r>
 81fdede:	b948      	cbnz	r0, 81fdef4 <__smakebuf_r+0x46>
 81fdee0:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 81fdee4:	059a      	lsls	r2, r3, #22
 81fdee6:	d4ee      	bmi.n	81fdec6 <__smakebuf_r+0x18>
 81fdee8:	f023 0303 	bic.w	r3, r3, #3
 81fdeec:	f043 0302 	orr.w	r3, r3, #2
 81fdef0:	81a3      	strh	r3, [r4, #12]
 81fdef2:	e7e2      	b.n	81fdeba <__smakebuf_r+0xc>
 81fdef4:	89a3      	ldrh	r3, [r4, #12]
 81fdef6:	6020      	str	r0, [r4, #0]
 81fdef8:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 81fdefc:	81a3      	strh	r3, [r4, #12]
 81fdefe:	9b01      	ldr	r3, [sp, #4]
 81fdf00:	e9c4 0704 	strd	r0, r7, [r4, #16]
 81fdf04:	b15b      	cbz	r3, 81fdf1e <__smakebuf_r+0x70>
 81fdf06:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 81fdf0a:	4630      	mov	r0, r6
 81fdf0c:	f000 f81e 	bl	81fdf4c <_isatty_r>
 81fdf10:	b128      	cbz	r0, 81fdf1e <__smakebuf_r+0x70>
 81fdf12:	89a3      	ldrh	r3, [r4, #12]
 81fdf14:	f023 0303 	bic.w	r3, r3, #3
 81fdf18:	f043 0301 	orr.w	r3, r3, #1
 81fdf1c:	81a3      	strh	r3, [r4, #12]
 81fdf1e:	89a3      	ldrh	r3, [r4, #12]
 81fdf20:	431d      	orrs	r5, r3
 81fdf22:	81a5      	strh	r5, [r4, #12]
 81fdf24:	e7cf      	b.n	81fdec6 <__smakebuf_r+0x18>
	...

081fdf28 <_fstat_r>:
 81fdf28:	b538      	push	{r3, r4, r5, lr}
 81fdf2a:	2300      	movs	r3, #0
 81fdf2c:	4d06      	ldr	r5, [pc, #24]	@ (81fdf48 <_fstat_r+0x20>)
 81fdf2e:	4604      	mov	r4, r0
 81fdf30:	4608      	mov	r0, r1
 81fdf32:	4611      	mov	r1, r2
 81fdf34:	602b      	str	r3, [r5, #0]
 81fdf36:	f000 f9cb 	bl	81fe2d0 <_fstat>
 81fdf3a:	1c43      	adds	r3, r0, #1
 81fdf3c:	d102      	bne.n	81fdf44 <_fstat_r+0x1c>
 81fdf3e:	682b      	ldr	r3, [r5, #0]
 81fdf40:	b103      	cbz	r3, 81fdf44 <_fstat_r+0x1c>
 81fdf42:	6023      	str	r3, [r4, #0]
 81fdf44:	bd38      	pop	{r3, r4, r5, pc}
 81fdf46:	bf00      	nop
 81fdf48:	20000734 	.word	0x20000734

081fdf4c <_isatty_r>:
 81fdf4c:	b538      	push	{r3, r4, r5, lr}
 81fdf4e:	2300      	movs	r3, #0
 81fdf50:	4d05      	ldr	r5, [pc, #20]	@ (81fdf68 <_isatty_r+0x1c>)
 81fdf52:	4604      	mov	r4, r0
 81fdf54:	4608      	mov	r0, r1
 81fdf56:	602b      	str	r3, [r5, #0]
 81fdf58:	f000 f9c2 	bl	81fe2e0 <_isatty>
 81fdf5c:	1c43      	adds	r3, r0, #1
 81fdf5e:	d102      	bne.n	81fdf66 <_isatty_r+0x1a>
 81fdf60:	682b      	ldr	r3, [r5, #0]
 81fdf62:	b103      	cbz	r3, 81fdf66 <_isatty_r+0x1a>
 81fdf64:	6023      	str	r3, [r4, #0]
 81fdf66:	bd38      	pop	{r3, r4, r5, pc}
 81fdf68:	20000734 	.word	0x20000734

081fdf6c <_sbrk_r>:
 81fdf6c:	b538      	push	{r3, r4, r5, lr}
 81fdf6e:	2300      	movs	r3, #0
 81fdf70:	4d05      	ldr	r5, [pc, #20]	@ (81fdf88 <_sbrk_r+0x1c>)
 81fdf72:	4604      	mov	r4, r0
 81fdf74:	4608      	mov	r0, r1
 81fdf76:	602b      	str	r3, [r5, #0]
 81fdf78:	f000 f9ca 	bl	81fe310 <_sbrk>
 81fdf7c:	1c43      	adds	r3, r0, #1
 81fdf7e:	d102      	bne.n	81fdf86 <_sbrk_r+0x1a>
 81fdf80:	682b      	ldr	r3, [r5, #0]
 81fdf82:	b103      	cbz	r3, 81fdf86 <_sbrk_r+0x1a>
 81fdf84:	6023      	str	r3, [r4, #0]
 81fdf86:	bd38      	pop	{r3, r4, r5, pc}
 81fdf88:	20000734 	.word	0x20000734

081fdf8c <memchr>:
 81fdf8c:	b2c9      	uxtb	r1, r1
 81fdf8e:	4603      	mov	r3, r0
 81fdf90:	4402      	add	r2, r0
 81fdf92:	b510      	push	{r4, lr}
 81fdf94:	4293      	cmp	r3, r2
 81fdf96:	4618      	mov	r0, r3
 81fdf98:	d101      	bne.n	81fdf9e <memchr+0x12>
 81fdf9a:	2000      	movs	r0, #0
 81fdf9c:	e003      	b.n	81fdfa6 <memchr+0x1a>
 81fdf9e:	7804      	ldrb	r4, [r0, #0]
 81fdfa0:	3301      	adds	r3, #1
 81fdfa2:	428c      	cmp	r4, r1
 81fdfa4:	d1f6      	bne.n	81fdf94 <memchr+0x8>
 81fdfa6:	bd10      	pop	{r4, pc}

081fdfa8 <__aeabi_uldivmod>:
 81fdfa8:	b953      	cbnz	r3, 81fdfc0 <__aeabi_uldivmod+0x18>
 81fdfaa:	b94a      	cbnz	r2, 81fdfc0 <__aeabi_uldivmod+0x18>
 81fdfac:	2900      	cmp	r1, #0
 81fdfae:	bf08      	it	eq
 81fdfb0:	2800      	cmpeq	r0, #0
 81fdfb2:	bf1c      	itt	ne
 81fdfb4:	f04f 31ff 	movne.w	r1, #4294967295	@ 0xffffffff
 81fdfb8:	f04f 30ff 	movne.w	r0, #4294967295	@ 0xffffffff
 81fdfbc:	f000 b97e 	b.w	81fe2bc <__aeabi_idiv0>
 81fdfc0:	f1ad 0c08 	sub.w	ip, sp, #8
 81fdfc4:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 81fdfc8:	f000 f806 	bl	81fdfd8 <__udivmoddi4>
 81fdfcc:	f8dd e004 	ldr.w	lr, [sp, #4]
 81fdfd0:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 81fdfd4:	b004      	add	sp, #16
 81fdfd6:	4770      	bx	lr

081fdfd8 <__udivmoddi4>:
 81fdfd8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 81fdfdc:	9d09      	ldr	r5, [sp, #36]	@ 0x24
 81fdfde:	460c      	mov	r4, r1
 81fdfe0:	2b00      	cmp	r3, #0
 81fdfe2:	d14d      	bne.n	81fe080 <__udivmoddi4+0xa8>
 81fdfe4:	428a      	cmp	r2, r1
 81fdfe6:	460f      	mov	r7, r1
 81fdfe8:	4684      	mov	ip, r0
 81fdfea:	4696      	mov	lr, r2
 81fdfec:	fab2 f382 	clz	r3, r2
 81fdff0:	d960      	bls.n	81fe0b4 <__udivmoddi4+0xdc>
 81fdff2:	b14b      	cbz	r3, 81fe008 <__udivmoddi4+0x30>
 81fdff4:	fa02 fe03 	lsl.w	lr, r2, r3
 81fdff8:	f1c3 0220 	rsb	r2, r3, #32
 81fdffc:	409f      	lsls	r7, r3
 81fdffe:	fa00 fc03 	lsl.w	ip, r0, r3
 81fe002:	fa20 f202 	lsr.w	r2, r0, r2
 81fe006:	4317      	orrs	r7, r2
 81fe008:	ea4f 461e 	mov.w	r6, lr, lsr #16
 81fe00c:	fa1f f48e 	uxth.w	r4, lr
 81fe010:	ea4f 421c 	mov.w	r2, ip, lsr #16
 81fe014:	fbb7 f1f6 	udiv	r1, r7, r6
 81fe018:	fb06 7711 	mls	r7, r6, r1, r7
 81fe01c:	fb01 f004 	mul.w	r0, r1, r4
 81fe020:	ea42 4207 	orr.w	r2, r2, r7, lsl #16
 81fe024:	4290      	cmp	r0, r2
 81fe026:	d908      	bls.n	81fe03a <__udivmoddi4+0x62>
 81fe028:	eb1e 0202 	adds.w	r2, lr, r2
 81fe02c:	f101 37ff 	add.w	r7, r1, #4294967295	@ 0xffffffff
 81fe030:	d202      	bcs.n	81fe038 <__udivmoddi4+0x60>
 81fe032:	4290      	cmp	r0, r2
 81fe034:	f200 812d 	bhi.w	81fe292 <__udivmoddi4+0x2ba>
 81fe038:	4639      	mov	r1, r7
 81fe03a:	1a12      	subs	r2, r2, r0
 81fe03c:	fa1f fc8c 	uxth.w	ip, ip
 81fe040:	fbb2 f0f6 	udiv	r0, r2, r6
 81fe044:	fb06 2210 	mls	r2, r6, r0, r2
 81fe048:	fb00 f404 	mul.w	r4, r0, r4
 81fe04c:	ea4c 4c02 	orr.w	ip, ip, r2, lsl #16
 81fe050:	4564      	cmp	r4, ip
 81fe052:	d908      	bls.n	81fe066 <__udivmoddi4+0x8e>
 81fe054:	eb1e 0c0c 	adds.w	ip, lr, ip
 81fe058:	f100 32ff 	add.w	r2, r0, #4294967295	@ 0xffffffff
 81fe05c:	d202      	bcs.n	81fe064 <__udivmoddi4+0x8c>
 81fe05e:	4564      	cmp	r4, ip
 81fe060:	f200 811a 	bhi.w	81fe298 <__udivmoddi4+0x2c0>
 81fe064:	4610      	mov	r0, r2
 81fe066:	ea40 4001 	orr.w	r0, r0, r1, lsl #16
 81fe06a:	ebac 0c04 	sub.w	ip, ip, r4
 81fe06e:	2100      	movs	r1, #0
 81fe070:	b125      	cbz	r5, 81fe07c <__udivmoddi4+0xa4>
 81fe072:	fa2c f303 	lsr.w	r3, ip, r3
 81fe076:	2200      	movs	r2, #0
 81fe078:	e9c5 3200 	strd	r3, r2, [r5]
 81fe07c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 81fe080:	428b      	cmp	r3, r1
 81fe082:	d905      	bls.n	81fe090 <__udivmoddi4+0xb8>
 81fe084:	b10d      	cbz	r5, 81fe08a <__udivmoddi4+0xb2>
 81fe086:	e9c5 0100 	strd	r0, r1, [r5]
 81fe08a:	2100      	movs	r1, #0
 81fe08c:	4608      	mov	r0, r1
 81fe08e:	e7f5      	b.n	81fe07c <__udivmoddi4+0xa4>
 81fe090:	fab3 f183 	clz	r1, r3
 81fe094:	2900      	cmp	r1, #0
 81fe096:	d14d      	bne.n	81fe134 <__udivmoddi4+0x15c>
 81fe098:	42a3      	cmp	r3, r4
 81fe09a:	f0c0 80f2 	bcc.w	81fe282 <__udivmoddi4+0x2aa>
 81fe09e:	4290      	cmp	r0, r2
 81fe0a0:	f080 80ef 	bcs.w	81fe282 <__udivmoddi4+0x2aa>
 81fe0a4:	4606      	mov	r6, r0
 81fe0a6:	4623      	mov	r3, r4
 81fe0a8:	4608      	mov	r0, r1
 81fe0aa:	2d00      	cmp	r5, #0
 81fe0ac:	d0e6      	beq.n	81fe07c <__udivmoddi4+0xa4>
 81fe0ae:	e9c5 6300 	strd	r6, r3, [r5]
 81fe0b2:	e7e3      	b.n	81fe07c <__udivmoddi4+0xa4>
 81fe0b4:	2b00      	cmp	r3, #0
 81fe0b6:	f040 80a2 	bne.w	81fe1fe <__udivmoddi4+0x226>
 81fe0ba:	1a8a      	subs	r2, r1, r2
 81fe0bc:	ea4f 471e 	mov.w	r7, lr, lsr #16
 81fe0c0:	fa1f f68e 	uxth.w	r6, lr
 81fe0c4:	2101      	movs	r1, #1
 81fe0c6:	fbb2 f4f7 	udiv	r4, r2, r7
 81fe0ca:	fb07 2014 	mls	r0, r7, r4, r2
 81fe0ce:	ea4f 421c 	mov.w	r2, ip, lsr #16
 81fe0d2:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
 81fe0d6:	fb06 f004 	mul.w	r0, r6, r4
 81fe0da:	4290      	cmp	r0, r2
 81fe0dc:	d90f      	bls.n	81fe0fe <__udivmoddi4+0x126>
 81fe0de:	eb1e 0202 	adds.w	r2, lr, r2
 81fe0e2:	f104 38ff 	add.w	r8, r4, #4294967295	@ 0xffffffff
 81fe0e6:	bf2c      	ite	cs
 81fe0e8:	f04f 0901 	movcs.w	r9, #1
 81fe0ec:	f04f 0900 	movcc.w	r9, #0
 81fe0f0:	4290      	cmp	r0, r2
 81fe0f2:	d903      	bls.n	81fe0fc <__udivmoddi4+0x124>
 81fe0f4:	f1b9 0f00 	cmp.w	r9, #0
 81fe0f8:	f000 80c8 	beq.w	81fe28c <__udivmoddi4+0x2b4>
 81fe0fc:	4644      	mov	r4, r8
 81fe0fe:	1a12      	subs	r2, r2, r0
 81fe100:	fa1f fc8c 	uxth.w	ip, ip
 81fe104:	fbb2 f0f7 	udiv	r0, r2, r7
 81fe108:	fb07 2210 	mls	r2, r7, r0, r2
 81fe10c:	fb00 f606 	mul.w	r6, r0, r6
 81fe110:	ea4c 4c02 	orr.w	ip, ip, r2, lsl #16
 81fe114:	4566      	cmp	r6, ip
 81fe116:	d908      	bls.n	81fe12a <__udivmoddi4+0x152>
 81fe118:	eb1e 0c0c 	adds.w	ip, lr, ip
 81fe11c:	f100 32ff 	add.w	r2, r0, #4294967295	@ 0xffffffff
 81fe120:	d202      	bcs.n	81fe128 <__udivmoddi4+0x150>
 81fe122:	4566      	cmp	r6, ip
 81fe124:	f200 80bb 	bhi.w	81fe29e <__udivmoddi4+0x2c6>
 81fe128:	4610      	mov	r0, r2
 81fe12a:	ebac 0c06 	sub.w	ip, ip, r6
 81fe12e:	ea40 4004 	orr.w	r0, r0, r4, lsl #16
 81fe132:	e79d      	b.n	81fe070 <__udivmoddi4+0x98>
 81fe134:	f1c1 0620 	rsb	r6, r1, #32
 81fe138:	408b      	lsls	r3, r1
 81fe13a:	fa04 fe01 	lsl.w	lr, r4, r1
 81fe13e:	fa22 f706 	lsr.w	r7, r2, r6
 81fe142:	fa20 fc06 	lsr.w	ip, r0, r6
 81fe146:	40f4      	lsrs	r4, r6
 81fe148:	408a      	lsls	r2, r1
 81fe14a:	431f      	orrs	r7, r3
 81fe14c:	ea4e 030c 	orr.w	r3, lr, ip
 81fe150:	fa00 fe01 	lsl.w	lr, r0, r1
 81fe154:	ea4f 4817 	mov.w	r8, r7, lsr #16
 81fe158:	ea4f 4913 	mov.w	r9, r3, lsr #16
 81fe15c:	fa1f fc87 	uxth.w	ip, r7
 81fe160:	fbb4 f0f8 	udiv	r0, r4, r8
 81fe164:	fb08 4410 	mls	r4, r8, r0, r4
 81fe168:	ea49 4404 	orr.w	r4, r9, r4, lsl #16
 81fe16c:	fb00 f90c 	mul.w	r9, r0, ip
 81fe170:	45a1      	cmp	r9, r4
 81fe172:	d90e      	bls.n	81fe192 <__udivmoddi4+0x1ba>
 81fe174:	193c      	adds	r4, r7, r4
 81fe176:	f100 3aff 	add.w	sl, r0, #4294967295	@ 0xffffffff
 81fe17a:	bf2c      	ite	cs
 81fe17c:	f04f 0b01 	movcs.w	fp, #1
 81fe180:	f04f 0b00 	movcc.w	fp, #0
 81fe184:	45a1      	cmp	r9, r4
 81fe186:	d903      	bls.n	81fe190 <__udivmoddi4+0x1b8>
 81fe188:	f1bb 0f00 	cmp.w	fp, #0
 81fe18c:	f000 8093 	beq.w	81fe2b6 <__udivmoddi4+0x2de>
 81fe190:	4650      	mov	r0, sl
 81fe192:	eba4 0409 	sub.w	r4, r4, r9
 81fe196:	fa1f f983 	uxth.w	r9, r3
 81fe19a:	fbb4 f3f8 	udiv	r3, r4, r8
 81fe19e:	fb08 4413 	mls	r4, r8, r3, r4
 81fe1a2:	fb03 fc0c 	mul.w	ip, r3, ip
 81fe1a6:	ea49 4404 	orr.w	r4, r9, r4, lsl #16
 81fe1aa:	45a4      	cmp	ip, r4
 81fe1ac:	d906      	bls.n	81fe1bc <__udivmoddi4+0x1e4>
 81fe1ae:	193c      	adds	r4, r7, r4
 81fe1b0:	f103 38ff 	add.w	r8, r3, #4294967295	@ 0xffffffff
 81fe1b4:	d201      	bcs.n	81fe1ba <__udivmoddi4+0x1e2>
 81fe1b6:	45a4      	cmp	ip, r4
 81fe1b8:	d87a      	bhi.n	81fe2b0 <__udivmoddi4+0x2d8>
 81fe1ba:	4643      	mov	r3, r8
 81fe1bc:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
 81fe1c0:	eba4 040c 	sub.w	r4, r4, ip
 81fe1c4:	fba0 9802 	umull	r9, r8, r0, r2
 81fe1c8:	4544      	cmp	r4, r8
 81fe1ca:	46cc      	mov	ip, r9
 81fe1cc:	4643      	mov	r3, r8
 81fe1ce:	d302      	bcc.n	81fe1d6 <__udivmoddi4+0x1fe>
 81fe1d0:	d106      	bne.n	81fe1e0 <__udivmoddi4+0x208>
 81fe1d2:	45ce      	cmp	lr, r9
 81fe1d4:	d204      	bcs.n	81fe1e0 <__udivmoddi4+0x208>
 81fe1d6:	3801      	subs	r0, #1
 81fe1d8:	ebb9 0c02 	subs.w	ip, r9, r2
 81fe1dc:	eb68 0307 	sbc.w	r3, r8, r7
 81fe1e0:	b15d      	cbz	r5, 81fe1fa <__udivmoddi4+0x222>
 81fe1e2:	ebbe 020c 	subs.w	r2, lr, ip
 81fe1e6:	eb64 0403 	sbc.w	r4, r4, r3
 81fe1ea:	fa04 f606 	lsl.w	r6, r4, r6
 81fe1ee:	fa22 f301 	lsr.w	r3, r2, r1
 81fe1f2:	40cc      	lsrs	r4, r1
 81fe1f4:	431e      	orrs	r6, r3
 81fe1f6:	e9c5 6400 	strd	r6, r4, [r5]
 81fe1fa:	2100      	movs	r1, #0
 81fe1fc:	e73e      	b.n	81fe07c <__udivmoddi4+0xa4>
 81fe1fe:	fa02 fe03 	lsl.w	lr, r2, r3
 81fe202:	f1c3 0120 	rsb	r1, r3, #32
 81fe206:	fa04 f203 	lsl.w	r2, r4, r3
 81fe20a:	fa00 fc03 	lsl.w	ip, r0, r3
 81fe20e:	40cc      	lsrs	r4, r1
 81fe210:	ea4f 471e 	mov.w	r7, lr, lsr #16
 81fe214:	fa20 f101 	lsr.w	r1, r0, r1
 81fe218:	fa1f f68e 	uxth.w	r6, lr
 81fe21c:	fbb4 f0f7 	udiv	r0, r4, r7
 81fe220:	430a      	orrs	r2, r1
 81fe222:	fb07 4410 	mls	r4, r7, r0, r4
 81fe226:	0c11      	lsrs	r1, r2, #16
 81fe228:	ea41 4104 	orr.w	r1, r1, r4, lsl #16
 81fe22c:	fb00 f406 	mul.w	r4, r0, r6
 81fe230:	428c      	cmp	r4, r1
 81fe232:	d90e      	bls.n	81fe252 <__udivmoddi4+0x27a>
 81fe234:	eb1e 0101 	adds.w	r1, lr, r1
 81fe238:	f100 38ff 	add.w	r8, r0, #4294967295	@ 0xffffffff
 81fe23c:	bf2c      	ite	cs
 81fe23e:	f04f 0901 	movcs.w	r9, #1
 81fe242:	f04f 0900 	movcc.w	r9, #0
 81fe246:	428c      	cmp	r4, r1
 81fe248:	d902      	bls.n	81fe250 <__udivmoddi4+0x278>
 81fe24a:	f1b9 0f00 	cmp.w	r9, #0
 81fe24e:	d02c      	beq.n	81fe2aa <__udivmoddi4+0x2d2>
 81fe250:	4640      	mov	r0, r8
 81fe252:	1b09      	subs	r1, r1, r4
 81fe254:	b292      	uxth	r2, r2
 81fe256:	fbb1 f4f7 	udiv	r4, r1, r7
 81fe25a:	fb07 1114 	mls	r1, r7, r4, r1
 81fe25e:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 81fe262:	fb04 f106 	mul.w	r1, r4, r6
 81fe266:	4291      	cmp	r1, r2
 81fe268:	d907      	bls.n	81fe27a <__udivmoddi4+0x2a2>
 81fe26a:	eb1e 0202 	adds.w	r2, lr, r2
 81fe26e:	f104 38ff 	add.w	r8, r4, #4294967295	@ 0xffffffff
 81fe272:	d201      	bcs.n	81fe278 <__udivmoddi4+0x2a0>
 81fe274:	4291      	cmp	r1, r2
 81fe276:	d815      	bhi.n	81fe2a4 <__udivmoddi4+0x2cc>
 81fe278:	4644      	mov	r4, r8
 81fe27a:	1a52      	subs	r2, r2, r1
 81fe27c:	ea44 4100 	orr.w	r1, r4, r0, lsl #16
 81fe280:	e721      	b.n	81fe0c6 <__udivmoddi4+0xee>
 81fe282:	1a86      	subs	r6, r0, r2
 81fe284:	eb64 0303 	sbc.w	r3, r4, r3
 81fe288:	2001      	movs	r0, #1
 81fe28a:	e70e      	b.n	81fe0aa <__udivmoddi4+0xd2>
 81fe28c:	3c02      	subs	r4, #2
 81fe28e:	4472      	add	r2, lr
 81fe290:	e735      	b.n	81fe0fe <__udivmoddi4+0x126>
 81fe292:	3902      	subs	r1, #2
 81fe294:	4472      	add	r2, lr
 81fe296:	e6d0      	b.n	81fe03a <__udivmoddi4+0x62>
 81fe298:	44f4      	add	ip, lr
 81fe29a:	3802      	subs	r0, #2
 81fe29c:	e6e3      	b.n	81fe066 <__udivmoddi4+0x8e>
 81fe29e:	44f4      	add	ip, lr
 81fe2a0:	3802      	subs	r0, #2
 81fe2a2:	e742      	b.n	81fe12a <__udivmoddi4+0x152>
 81fe2a4:	3c02      	subs	r4, #2
 81fe2a6:	4472      	add	r2, lr
 81fe2a8:	e7e7      	b.n	81fe27a <__udivmoddi4+0x2a2>
 81fe2aa:	3802      	subs	r0, #2
 81fe2ac:	4471      	add	r1, lr
 81fe2ae:	e7d0      	b.n	81fe252 <__udivmoddi4+0x27a>
 81fe2b0:	3b02      	subs	r3, #2
 81fe2b2:	443c      	add	r4, r7
 81fe2b4:	e782      	b.n	81fe1bc <__udivmoddi4+0x1e4>
 81fe2b6:	3802      	subs	r0, #2
 81fe2b8:	443c      	add	r4, r7
 81fe2ba:	e76a      	b.n	81fe192 <__udivmoddi4+0x1ba>

081fe2bc <__aeabi_idiv0>:
 81fe2bc:	4770      	bx	lr
 81fe2be:	bf00      	nop

081fe2c0 <_close>:
 81fe2c0:	4b02      	ldr	r3, [pc, #8]	@ (81fe2cc <_close+0xc>)
 81fe2c2:	2258      	movs	r2, #88	@ 0x58
 81fe2c4:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 81fe2c8:	601a      	str	r2, [r3, #0]
 81fe2ca:	4770      	bx	lr
 81fe2cc:	20000734 	.word	0x20000734

081fe2d0 <_fstat>:
 81fe2d0:	4b02      	ldr	r3, [pc, #8]	@ (81fe2dc <_fstat+0xc>)
 81fe2d2:	2258      	movs	r2, #88	@ 0x58
 81fe2d4:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 81fe2d8:	601a      	str	r2, [r3, #0]
 81fe2da:	4770      	bx	lr
 81fe2dc:	20000734 	.word	0x20000734

081fe2e0 <_isatty>:
 81fe2e0:	4b02      	ldr	r3, [pc, #8]	@ (81fe2ec <_isatty+0xc>)
 81fe2e2:	2258      	movs	r2, #88	@ 0x58
 81fe2e4:	2000      	movs	r0, #0
 81fe2e6:	601a      	str	r2, [r3, #0]
 81fe2e8:	4770      	bx	lr
 81fe2ea:	bf00      	nop
 81fe2ec:	20000734 	.word	0x20000734

081fe2f0 <_lseek>:
 81fe2f0:	4b02      	ldr	r3, [pc, #8]	@ (81fe2fc <_lseek+0xc>)
 81fe2f2:	2258      	movs	r2, #88	@ 0x58
 81fe2f4:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 81fe2f8:	601a      	str	r2, [r3, #0]
 81fe2fa:	4770      	bx	lr
 81fe2fc:	20000734 	.word	0x20000734

081fe300 <_read>:
 81fe300:	4b02      	ldr	r3, [pc, #8]	@ (81fe30c <_read+0xc>)
 81fe302:	2258      	movs	r2, #88	@ 0x58
 81fe304:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 81fe308:	601a      	str	r2, [r3, #0]
 81fe30a:	4770      	bx	lr
 81fe30c:	20000734 	.word	0x20000734

081fe310 <_sbrk>:
 81fe310:	4a04      	ldr	r2, [pc, #16]	@ (81fe324 <_sbrk+0x14>)
 81fe312:	4603      	mov	r3, r0
 81fe314:	6811      	ldr	r1, [r2, #0]
 81fe316:	b909      	cbnz	r1, 81fe31c <_sbrk+0xc>
 81fe318:	4903      	ldr	r1, [pc, #12]	@ (81fe328 <_sbrk+0x18>)
 81fe31a:	6011      	str	r1, [r2, #0]
 81fe31c:	6810      	ldr	r0, [r2, #0]
 81fe31e:	4403      	add	r3, r0
 81fe320:	6013      	str	r3, [r2, #0]
 81fe322:	4770      	bx	lr
 81fe324:	20000744 	.word	0x20000744
 81fe328:	20000b60 	.word	0x20000b60

081fe32c <_exit>:
 81fe32c:	e7fe      	b.n	81fe32c <_exit>
	...

081fe330 <_init>:
 81fe330:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 81fe332:	bf00      	nop
 81fe334:	bcf8      	pop	{r3, r4, r5, r6, r7}
 81fe336:	bc08      	pop	{r3}
 81fe338:	469e      	mov	lr, r3
 81fe33a:	4770      	bx	lr

081fe33c <_fini>:
 81fe33c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 81fe33e:	bf00      	nop
 81fe340:	bcf8      	pop	{r3, r4, r5, r6, r7}
 81fe342:	bc08      	pop	{r3}
 81fe344:	469e      	mov	lr, r3
 81fe346:	4770      	bx	lr

081fe348 <YMODEM_IT_MSG>:
 81fe348:	0a0d 6d59 646f 6d65 7320 6f74 2070 7962     ..Ymodem stop by
 81fe358:	7020 6972 746e 0d66 000a 0a0d 3d3d 3d3d      printf.....====
 81fe368:	3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 4e20 7765     ============ New
 81fe378:	4620 2077 6d49 6761 2065 3d3d 3d3d 3d3d      Fw Image ======
 81fe388:	3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d     ================
 81fe398:	3d3d 3d3d 3d3d 0a0d 2000 5220 7365 7465     ======...  Reset
 81fe3a8:	7420 206f 7274 6769 6567 2072 6e49 7473      to trigger Inst
 81fe3b8:	6c61 616c 6974 6e6f 2d20 2d2d 2d2d 2d2d     allation -------
 81fe3c8:	2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d     ----------------
 81fe3d8:	2d2d 3120 0a0d 2000 4420 776f 6c6e 616f     -- 1...  Downloa
 81fe3e8:	2064 6553 7563 6572 4120 7070 4920 616d     d Secure App Ima
 81fe3f8:	6567 2d20 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d     ge -------------
 81fe408:	2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d     ----------------
 81fe418:	3220 0a0d 2000 4420 776f 6c6e 616f 2064      2...  Download 
 81fe428:	6f4e 536e 6365 7275 2065 7041 2070 6d49     NonSecure App Im
 81fe438:	6761 2065 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d     age ------------
 81fe448:	2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 3320     -------------- 3
 81fe458:	0a0d 2000 4420 776f 6c6e 616f 2064 6553     ...  Download Se
 81fe468:	7563 6572 4420 7461 2061 6d49 6761 2065     cure Data Image 
 81fe478:	2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d     ----------------
 81fe488:	2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 3420 0a0d     ------------ 4..
 81fe498:	2000 4420 776f 6c6e 616f 2064 6f4e 536e     .  Download NonS
 81fe4a8:	6365 7275 2065 6144 6174 4920 616d 6567     ecure Data Image
 81fe4b8:	2d20 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d      ---------------
 81fe4c8:	2d2d 2d2d 2d2d 2d2d 2d2d 3520 0a0d 2000     ---------- 5... 
 81fe4d8:	2d20 202d 7245 7361 6e69 2067 6f64 6e77      -- Erasing down
 81fe4e8:	6f6c 6461 6120 6572 2061 0a0d 2000 2d20     load area ...  -
 81fe4f8:	202d 6553 646e 4620 7269 776d 7261 2065     - Send Firmware 
 81fe508:	0a0d 2000 2d20 202d 2d2d 4620 6c69 3e65     ...  -- -- File>
 81fe518:	5420 6172 736e 6566 3e72 5920 4f4d 4544      Transfer> YMODE
 81fe528:	3e4d 5320 6e65 2064 0009 2020 2d2d 2d20     M> Send ..  -- -
 81fe538:	202d 7250 676f 6172 6d6d 6e69 2067 6f43     - Programming Co
 81fe548:	706d 656c 6574 2064 7553 6363 7365 6673     mpleted Successf
 81fe558:	6c75 796c 0d21 000a 2020 2d2d 2d20 202d     ully!...  -- -- 
 81fe568:	7942 6574 3a73 2520 756c 0a0d 000a 2020     Bytes: %lu....  
 81fe578:	7257 7469 2065 614d 6967 2063 7254 6961     Write Magic Trai
 81fe588:	656c 2072 7461 2520 786c 0a0d 000a 2020     ler at %lx....  
 81fe598:	2d2d 2d20 202d 2121 6241 726f 6574 2064     -- -- !!Aborted 
 81fe5a8:	7962 7520 6573 2172 0d21 000a 2020 2d2d     by user!!...  --
 81fe5b8:	2d20 202d 2121 7245 6f72 2072 7564 6972      -- !!Error duri
 81fe5c8:	676e 6620 6c69 2065 6f64 6e77 6f6c 6461     ng file download
 81fe5d8:	2121 0a0d 2000 2d20 202d 6e49 7473 6c61     !!...  -- Instal
 81fe5e8:	206c 6d69 6761 2065 203a 6572 6f62 746f     l image : reboot
 81fe5f8:	0a0d 4400 776f 6c6e 616f 2064 6553 7563     ...Download Secu
 81fe608:	6572 4120 7070 4920 616d 6567 000d 2020     re App Image..  
 81fe618:	2d2d 5320 6365 7275 2065 7041 2070 6d49     -- Secure App Im
 81fe628:	6761 2065 6f63 7272 6365 6c74 2079 6f64     age correctly do
 81fe638:	6e77 6f6c 6461 6465 0d20 000a 6f44 6e77     wnloaded ...Down
 81fe648:	6f6c 6461 4e20 6e6f 6553 7563 6572 4120     load NonSecure A
 81fe658:	7070 4920 616d 6567 000d 2020 2d2d 4e20     pp Image..  -- N
 81fe668:	6e6f 6553 7563 6572 4120 7070 4920 616d     onSecure App Ima
 81fe678:	6567 6320 726f 6572 7463 796c 6420 776f     ge correctly dow
 81fe688:	6c6e 616f 6564 2064 0a0d 4400 776f 6c6e     nloaded ...Downl
 81fe698:	616f 2064 6553 7563 6572 4420 7461 2061     oad Secure Data 
 81fe6a8:	6d49 6761 0d65 2000 2d20 202d 6553 7563     Image..  -- Secu
 81fe6b8:	6572 4420 7461 2061 6d49 6761 2065 6f63     re Data Image co
 81fe6c8:	7272 6365 6c74 2079 6f64 6e77 6f6c 6461     rrectly download
 81fe6d8:	6465 0d20 000a 6f44 6e77 6f6c 6461 4e20     ed ...Download N
 81fe6e8:	6e6f 6553 7563 6572 4420 7461 2061 6d49     onSecure Data Im
 81fe6f8:	6761 0d65 2000 2d20 202d 6f4e 536e 6365     age..  -- NonSec
 81fe708:	7275 2065 6144 6174 4920 616d 6567 6320     ure Data Image c
 81fe718:	726f 6572 7463 796c 6420 776f 6c6e 616f     orrectly downloa
 81fe728:	6564 2064 0a0d 4900 766e 6c61 6469 4e20     ded ...Invalid N
 81fe738:	6d75 6562 2072 0d21 0000 0000               umber !.....

081fe744 <MagicTrailerValue>:
 81fe744:	c277 f395 d260 7fef 5235 0f50 b62c 8079     w...`...5RP.,.y.

081fe754 <TFM_Driver_FLASH0>:
	...
 81fe75c:	a925 081f 0000 0000 0000 0000 0000 0000     %...............
 81fe76c:	a935 081f aa11 081f 0000 0000 0000 0000     5...............
 81fe77c:	a91d 081f                                   ....

081fe780 <ARM_FLASH0_DEV_DATA>:
 81fe780:	0000 0000 0100 0000 2000 0000 2000 0000     ......... ... ..
 81fe790:	0010 0000 00ff 0000 0a0d 3d3d 3d3d 3d3d     ..........======
 81fe7a0:	3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d     ================
 81fe7b0:	3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d     ================
 81fe7c0:	3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d     ================
 81fe7d0:	3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d     ================
 81fe7e0:	0d00 3d0a 2020 2020 2020 2020 2020 2020     ...=            
 81fe7f0:	2020 4328 2029 4f43 5950 4952 4847 2054       (C) COPYRIGHT 
 81fe800:	3032 3132 5320 4d54 6369 6f72 6c65 6365     2021 STMicroelec
 81fe810:	7274 6e6f 6369 2073 2020 2020 2020 2020     tronics         
 81fe820:	2020 2020 2020 2020 003d 0a0d 203d 2020             =...=   
 81fe830:	2020 2020 2020 2020 2020 2020 2020 2020                     
 81fe840:	2020 2020 2020 2020 2020 2020 2020 2020                     
 81fe850:	2020 2020 2020 2020 2020 2020 2020 2020                     
 81fe860:	2020 2020 2020 2020 2020 2020 2020 2020                     
 81fe870:	3d20 0d00 3d0a 2020 2020 2020 2020 2020      =...=          
 81fe880:	2020 2020 2020 2020 2020 2020 2020 2020                     
 81fe890:	4f4c 4143 204c 4f4c 4441 5245 2020 2020     LOCAL LOADER    
 81fe8a0:	2020 2020 2020 2020 2020 2020 2020 2020                     
 81fe8b0:	2020 2020 2020 2020 2020 003d 0a0d 000d               =.....
 81fe8c0:	5f65 6572 7573 746c 3d20 2520 2078 202c     e_result = %x , 
 81fe8d0:	6c25 0a75                                    %lu..

081fe8d5 <BACK_SLASH_POINT>:
 81fe8d5:	2e08                                         ...

081fe8d8 <MSIRangeTable>:
 81fe8d8:	6c00 02dc 3600 016e 2400 00f4 1b00 00b7     .l...6n..$......
 81fe8e8:	0900 003d 8480 001e e360 0016 4240 000f     ..=.....`...@B..
 81fe8f8:	e000 002e 7000 0017 a000 000f b800 000b     .....p..........
 81fe908:	1a80 0006 0d40 0003 49f0 0002 86a0 0001     ....@....I......

081fe918 <APBPrescTable>:
 81fe918:	0000 0000 0201 0403                         ........

081fe920 <AHBPrescTable>:
	...
 81fe928:	0201 0403 0706 0908                         ........

081fe930 <LPGPIO_Map>:
 81fe930:	0000 4202 0001 0000 0000 4202 0003 0000     ...B.......B....
 81fe940:	0000 4202 0006 0000 0400 4202 0001 0000     ...B.......B....
 81fe950:	0400 4202 000a 0000 0800 4202 0002 0000     ...B.......B....
 81fe960:	0c00 4202 000d 0000 0c00 4202 0002 0000     ...B.......B....
 81fe970:	0800 4202 000a 0000 0400 4202 0000 0000     ...B.......B....
 81fe980:	0800 4202 000c 0000 0400 4202 0003 0000     ...B.......B....
 81fe990:	0400 4202 0004 0000 1000 4202 0000 0000     ...B.......B....
 81fe9a0:	1000 4202 0002 0000 1000 4202 0003 0000     ...B.......B....

081fe9b0 <UARTPrescTable>:
 81fe9b0:	0001 0002 0004 0006 0008 000a 000c 0010     ................
 81fe9c0:	0020 0040 0080 0100 2d23 2b30 0020 6c68      .@.....#-0+ .hl
 81fe9d0:	004c 6665 4567 4746 3000 3231 3433 3635     L.efgEFG.0123456
 81fe9e0:	3837 4139 4342 4544 0046 3130 3332 3534     789ABCDEF.012345
 81fe9f0:	3736 3938 6261 6463 6665 0000               6789abcdef..

081fe9fc <__EH_FRAME_BEGIN__>:
 81fe9fc:	0000 0000                                   ....
